}
    return ret;
}



/*
 * This function produces appripriate App and Topic strings from
 * the share's internal concatonated string format based on
 * the share type.
 *
 * Internally, the shares would be:
 * OLDApp|OLDTopic \0 NEWApp|NewTopic \n STATICApp|STATICTopic \0 \0.
 */
BOOL
GetShareAppTopic(
    DWORD           lType,          // type of share accessed
    PNDDESHAREINFO  lpShareInfo,    // share info buffer
    LPSTR           lpAppName,      // where to put it
    LPSTR           lpTopicName)      // where to put it
{
    LPSTR           lpName;

    lpName = lpShareInfo->lpszAppTopicList;
    switch (lType) {
    case SHARE_TYPE_STATIC:
        lpName += strlen(lpName) + 1;
        /* INTENTIONAL FALL-THROUGH */

    case SHARE_TYPE_NEW:
        lpName += strlen(lpName) + 1;
        /* INTENTIONAL FALL-THROUGH */

    case SHARE_TYPE_OLD:
        lstrcpyn(tmpBuf, lpName, 500);
        lpName = strchr(tmpBuf, '|');
        if (lpName) {
            *lpName++ = '\0';
            lstrcpyn(lpAppName, tmpBuf, 256);
            lstrcpyn(lpTopicName, lpName, 256);
        } else {
            return( FALSE );
        }
        break;
    default:
        /*  Invaid Share Type request: %1   */
        NDDELogError(MSG063, LogString("%d", lType), NULL);
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\uservald.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "USERVALD.C;1  16-Dec-92,10:18:06  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "api1632.h"
#include    <string.h>
#include    <stdlib.h>
#include    <windows.h>
#include    <hardware.h>
#include    <dde.h>
#include    "nddeapi.h"
#include    "nddesec.h"
#include    "winmsg.h"
#include    "sectype.h"
#include    "tmpbufc.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "uservald.h"
#include    "hndltokn.h"
#include    "nddemsg.h"
#include    "nddelog.h"

#if DBG
extern  BOOL    bDebugInfo;
#endif

BOOL
_stdcall
NDDEGetChallengeResponse(
    LUID    LogonId,
    LPSTR   lpszPasswordK1,
    int     cbPasswordK1,
    LPSTR   lpszChallenge,
    int     cbChallenge,
    DWORD  *pcbPasswordK1,
    BOOL   *pbHasPasswordK1 );

GENERIC_MAPPING ShareObjectGm = {NDDE_SHARE_GENERIC_READ,
                 NDDE_SHARE_GENERIC_WRITE,
                 NDDE_SHARE_GENERIC_EXECUTE,
                 NDDE_SHARE_GENERIC_ALL};



BOOL
GetTokenHandle( PHANDLE pTokenHandle )
{
    DWORD   last_error;
    BOOL    ok;

    if( !(ok = OpenThreadToken( GetCurrentThread(),
                          TOKEN_QUERY | TOKEN_IMPERSONATE,
                          TRUE,
                          pTokenHandle )) ) {

        if( (last_error = GetLastError()) == ERROR_NO_TOKEN ) {
            if( !(ok = OpenProcessToken( GetCurrentProcess(),
                                   TOKEN_QUERY | TOKEN_IMPERSONATE,
                                   pTokenHandle )) ) {
                last_error = GetLastError();
            }
        }
    }
    if (!ok) {
        /*  Unable to open current thread or process token: %1  */
        NDDELogError(MSG064, LogString("%d", last_error), NULL);
    }
    return( ok );
}

BOOL
WINAPI
GetCurrentUserDomainName(
    HWND        hwnd,
    LPSTR       lpUserName,
    DWORD       dwUserNameBufSize,
    LPSTR       lpDomainName,
    DWORD       dwDomainNameBufSize)
{
    HANDLE          hThreadToken    = NULL;
    HANDLE          hMemory         = 0;
    TOKEN_USER    * pUserToken      = NULL;
    DWORD           UserTokenLen;
    PSID            pUserSID;
    SID_NAME_USE    UserSIDType;
    BOOL            ok;
    char            pComputerName[] = "";

    if (ok = GetTokenHandle( &hThreadToken )) {
        ok = GetTokenInformation(hThreadToken, TokenUser,
            pUserToken, 0, &UserTokenLen);
        if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            hMemory = LocalAlloc(LPTR, UserTokenLen);
            if (hMemory) {
                pUserToken = (TOKEN_USER *)LocalLock(hMemory);
                ok = GetTokenInformation(hThreadToken, TokenUser,
                    pUserToken, UserTokenLen, &UserTokenLen);
            } else {
                MEMERROR();
            }
        }
        if (ok) {
            pUserSID = pUserToken->User.Sid;
            ok = LookupAccountSid(pComputerName,
                pUserSID,
                lpUserName,
                &dwUserNameBufSize,
                lpDomainName,
                &dwDomainNameBufSize,
                &UserSIDType);
            if (ok) {
                DIPRINTF(("Current User: %s, Domain: %s", lpUserName, lpDomainName));
            } else {
                /*  Unable to get user account info from open token: %1 */
                DWORD dwErr = GetLastError();

                DPRINTF(("LookupAccountSid failed, error = %s\n", LogString("%d", dwErr)));
                NDDELogError(MSG065, LogString("%d", dwErr), NULL);
            }
        } else {
            /*  Unable to get user token info: %1   */
            NDDELogError(MSG066, LogString("%d", GetLastError()), NULL);
        }
    }

    if (!ok) {
        lstrcpy(lpUserName, "");
        lstrcpy(lpDomainName, "");
    }
    if (hMemory) {
        LocalUnlock(hMemory);
        LocalFree(hMemory);
    }
    if (hThreadToken) {
        CloseHandle(hThreadToken);  // clean up our mess.
    }
    return(ok);
}

BOOL    DumpSid( LPTSTR szDumperName, PSID pSid );

/*------------------------------------------------------------------------
    Determinate Access given Client Token, Security Descriptor
    ----------------------------------------------------------------------*/
BOOL
DetermineAccess(
    LPSTR                   lpszDdeShareName,
    PSECURITY_DESCRIPTOR    pSD,
    LPDWORD                 lpdwGrantedAccess,
    LPVOID                  lpvHandleIdAudit,
    LPBOOL                  lpfGenerateOnClose)
{
    BOOL            OK;
    BOOL            fStatus;
    LONG            lErr;

    OK = IsValidSecurityDescriptor(pSD);
    if (!OK) {
#if DBG
        DPRINTF(("A bogus SD passed to DetermineAccess(): %d", GetLastError()));
        HEXDUMP(pSD, GetSecurityDescriptorLength(pSD));
#endif
        return(FALSE);
    }
    OK = AccessCheckAndAuditAlarm(
            NDDE_AUDIT_SUBSYSTEM,
            lpvHandleIdAudit,
            NDDE_AUDIT_OBJECT_TYPE,
            lpszDdeShareName,
            pSD,
            MAXIMUM_ALLOWED,
            &ShareObjectGm,
            FALSE,      // not creating the object
            lpdwGrantedAccess,
            &fStatus,
            lpfGenerateOnClose );
    if (OK) {
        return OK && fStatus;
    } else {
#if DBG
        if (bDebugInfo) {
            lErr = GetLastError();
            DumpWhoIAm( "For AccessCheckAndAuditAlarm" );
            DPRINTF(( "AccessCheckAndAuditAlarm OK:%d, fStatus: %d, dGA:%0X, LE: %d",
                OK, fStatus, *lpdwGrantedAccess, lErr));
            HEXDUMP(pSD, GetSecurityDescriptorLength(pSD));
        }
#endif
        return(FALSE);
    }
}


BOOL
GetUserDomain(
    HWND    hWndDdePartner,
    HWND    hWndDdeOurs,
    LPSTR   lpszUserName,
    int     cbUserName,
    LPSTR   lpszDomainName,
    int     cbDomainName )
{
    BOOL    ok = TRUE;

    ok = ImpersonateDdeClientWindow( hWndDdePartner, hWndDdeOurs );

    if (ok) {
        ok = GetCurrentUserDomainName( hWndDdeOurs, lpszUserName, cbUserName,
            lpszDomainName, cbDomainName );
        RevertToSelf();
    } else {
        /*  Unable to impersonate DDE client: %1    */
        NDDELogError(MSG068, LogString("%d", GetLastError()), NULL);
    }
    return( ok );
}

BOOL
GetUserDomainPassword(
    HWND    hWndDdePartner,
    HWND    hWndDdeOurs,
    LPSTR   lpszUserName,
    int     cbUserName,
    LPSTR   lpszDomainName,
    int     cbDomainName,
    LPSTR   lpszPasswordK1,
    DWORD   cbPasswordK1,
    LPSTR   lpszChallenge,
    int     cbChallenge,
    DWORD  *pcbPasswordK1,
    BOOL   *pbHasPasswordK1 )
{
    BOOL                ok = TRUE;
    TOKEN_STATISTICS    * pTokenStatistics = NULL;
    DWORD               TokenStatisticsLen;
    HANDLE              hMemory = 0;
    HANDLE              hThreadToken    = NULL;
    BOOL                bImpersonated   = FALSE;

    *pbHasPasswordK1 = FALSE;
    ok = ImpersonateDdeClientWindow( hWndDdePartner, hWndDdeOurs );
    if (ok) {
        bImpersonated = TRUE;
        ok = GetCurrentUserDomainName( hWndDdeOurs, lpszUserName, cbUserName,
            lpszDomainName, cbDomainName );
    }
    if( ok )  {
        ok = GetTokenHandle( &hThreadToken );
    }
    if( ok )  {
        ok = GetTokenInformation( hThreadToken, TokenStatistics,
            pTokenStatistics, 0, &TokenStatisticsLen);
        if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            hMemory = LocalAlloc(LPTR, TokenStatisticsLen);
            if (hMemory) {
                pTokenStatistics = (TOKEN_STATISTICS *)LocalLock(hMemory);
                ok = GetTokenInformation( hThreadToken, TokenStatistics,
                    pTokenStatistics, TokenStatisticsLen,
                    &TokenStatisticsLen);
            } else {
                MEMERROR();
            }
        }
        if( ok )  {
            RevertToSelf();
            bImpersonated = FALSE;
            ok = NDDEGetChallengeResponse(
                pTokenStatistics->AuthenticationId,
                lpszPasswordK1,
                cbPasswordK1,
                lpszChallenge,
                cbChallenge,
                pcbPasswordK1,
                pbHasPasswordK1 );
        }
        ok = TRUE; // have user and domain ... *pbHasPasswordK1 contains
                        // whether we have response or not
    } else {
        /*  Unable to impersonate DDE client: %1    */
        NDDELogError(MSG068, LogString("%d", GetLastError()), NULL);
    }
    if( bImpersonated )  {
        RevertToSelf();
        bImpersonated = FALSE;
    }
    if (hThreadToken) {
        CloseHandle(hThreadToken);      // clean up our mess
    }
    if (hMemory) {
        LocalUnlock(hMemory);
        LocalFree(hMemory);
    }
    return( ok );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\netdde\wininfo.h ===
#ifndef H__WIN_INFO
#define H__WIN_INFO

#include "nddeapip.h"

/*      Window States */
#define WST_WAIT_INIT_ACK       0x1
#define WST_OK                  0x2
#define WST_TERMINATED          0x3
#define WST_WAIT_NET_INIT_ACK   0x4
#define WST_TERMINATION_COMPLETE 0x5


#define WNDEXTRA                sizeof(void far *)       // sizeof void far *

#define MAX_INIT_NACK           32767       // number of init NACKs retried

typedef struct {
    unsigned    bClientSideOfNet        : 1;
    unsigned    bServerSideOfNet        : 1;
    unsigned    bOnWindowList           : 1;
    unsigned    bOnTermWindowList       : 1;
    unsigned    bSentTerminateNet       : 1;
    unsigned    bRcvdTerminateNet       : 1;
    unsigned    bSentTerminateLocally   : 1;
    unsigned    bRcvdTerminateLocally   : 1;
    unsigned    bInitiating             : 1;
    unsigned    bWin16Connection        : 1;
    int         nExtraInitiateAcks;
    HANDLE      hMemWaitInitQueue;              // queue of messages while
                                                //  waiting for INIT_ACK over
                                                //  network
    HWND        hWndDDE;
    HWND        hWndDDELocal;
    HMODULE     hTask;
    HWND        hWndPasswordDlg;
    LPVOID      lpDialogPrev;
    LPVOID      lpDialogNext;
    LPVOID      lpTaskDlgPrev;
    LPVOID      lpTaskDlgNext;
    HDDER       hDder;
    WORD        nInitNACK;                      // number of Init Nacks rcvd
    WORD        wState;                         // current window state
    HWND        hWndPrev;
    HWND        hWndNext;
    DWORD       dwSent;
    DWORD       dwRcvd;
    HDDEQ       qDDEIncomingCmd;
    HDDEQ       qDDEOutgoingCmd;
    LPDDEPKT    lpDdePktTerminate;
    WORD        offsNodeName;
    WORD        offsAppName;
    WORD        offsTopicName;
    WORD        offsClientName;
    WORD        connectFlags;        // add clausgi 7-21
    BOOL        dwWaitingServiceInitiate;
    char        szUserName[MAX_USERNAMEP + 1];
    char        szDomainName[MAX_DOMAINNAMEP + 1];
    char        szPassword[MAX_PASSWORD + 1];
    QOS         qosClient;
    DWORD       dwSecurityType;
    DWORD       sizeSecurityKeyRcvd;
    LPBYTE      lpSecurityKeyRcvd;
    DWORD       hSecurityKeyRcvd;
    BOOL        fCallObjectCloseAuditAlarm;
    BOOL        fGenerateAuditOnClose;
    HANDLE      hAudit;
    char        data[1];
} WININFO;
typedef WININFO FAR *LPWININFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\chksum32.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CHKSUM32.C;1  16-Dec-92,10:20:06  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1989-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NOMINMAX
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NONCMESSAGES
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOCOLOR
#define NOCREATESTRUCT
#define NOFONT
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOSOUND
#define NOWH
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER

#define NOKEYBOARDINFO
#define NOLANGUAGE
#define NOLFILEIO
#define NOMDI

#define NOANSI
#define NOSTRECTCHBLT
#define NOESCAPES
#define NOPALETTE
#define NORCCODES
#include "windows.h"
#include "debug.h"
#include "host.h"

VOID		FAR PASCAL Checksum32( DWORD FAR *lpChksum,
			    BYTE FAR *lpData, WORD wLength );

VOID
FAR PASCAL
Checksum32( DWORD FAR *lpChksum, BYTE FAR *lpData, WORD wLength )
{
    register DWORD	dwSum;
    register WORD	wTodo = wLength;
    register BYTE FAR  *lpInfo = lpData;
    
    dwSum = 0xFFFFFFFFL;

    while( wTodo > 4 )  {
	dwSum   += HostToPcLong( *((DWORD FAR *)lpInfo) );
	lpInfo  += 4;
	wTodo -= 4;
    }
    while( wTodo > 0 )  {
	dwSum += *((BYTE FAR *)lpInfo);
	lpInfo++;
	wTodo--;
    }
    
    *lpChksum = dwSum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\crc_16.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CRC_16.C;1  16-Dec-92,10:20:14  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1989-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#ifdef WIN32
#include "api1632.h"
#endif

#define LINT_ARGS
#include "windows.h"
#include "debug.h"

void FAR PASCAL crc_16( WORD FAR *ucrc, BYTE FAR *msg, int len );

/*************************************************************************\
* 									  *
*     NAME:								  *
*									  *
*	void crc_16( &crc, &msg, len )					  *
*     									  *
*     FUNCTION:								  *
*									  *
*	This function is used to compute 16-bit CRC as is used in BSC	  *
*	and known as CRC-16.  It is defined by the following		  *
*	polynomial (X**16 + X**15 + X**2 + 1).				  *
* 									  *
*     PARAMETERS:							  *
*									  *
*	WORD *crc	pointer to the 16-bit checksum currently	  *
*			being computed.  Note that the CRC must		  *
*			be initialized to 0xffff.			  *
*									  *
*	BYTE *msg	pointer to the first byte to be included	  *
*			in the crc computation				  *
* 									  *
*	int  len	number of bytes to be included in the crc	  *
*			computation					  *
*									  *
*     RETURN:		NONE.  Resulting crc is in the first argument	  *
* 									  *
\*************************************************************************/

void
FAR PASCAL
crc_16( ucrc, msg, len )
    WORD FAR	*ucrc;
    BYTE FAR	*msg;
    int		len;
{
    register WORD crc;
    register short bit;
    short chr;
    register short feedbackBit;
    register BYTE ch;

    crc = *ucrc;
/*DPRINTF(( "Start %08lX for %d w/ %04X", msg, len, crc ));*/
    for ( chr = 0; chr < len; chr++ ) {
	ch = *msg++;
/*DPRINTF(( "ch: %02X", ch ));*/
	for ( bit = 0; bit <= 7; bit++ ) {
	    feedbackBit = ( ch ^ crc ) & 1;
	    crc >>= 1;
	    if ( feedbackBit == 1 ) {
/*		crc |= 0x8000; */
/*		crc ^= 0x2001;	/* Polynomial terms represented here:	  */
				/* Bits 13 and 0 represent X**15 and X**2 */
				/* X**16 and 1 handled by the algorithm	  */

	    /* Note that since *crc has been shifted right, the two	  */
	    /* statements above could be replaced by a single statement:  */
	    /*		crc ^= 0xa001;					  */
		crc ^= 0xa001;
	    }
	    ch >>= 1;
	}
    }
/*DPRINTF(( "  rslt: %04X", crc ));*/
    *ucrc = crc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\getroute.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "GETROUTE.C;1  16-Dec-92,10:20:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "host.h"
#include "windows.h"
#include "netbasic.h"
#include "netintf.h"
#include "security.h"
#include "debug.h"
#include "api1632.h"
#include "proflspt.h"

extern char szNetddeIni[];

extern BOOL     bDefaultRouteDisconnect;
extern int      nDefaultRouteDisconnectTime;

BOOL
GetRoutingInfo(
    LPSTR       lpszNodeName,
    LPSTR       lpszRouteInfo,
    int         nMaxRouteInfo,
    BOOL FAR   *pbDisconnect,
    int FAR    *pnDelay )
{
    char        line[300];

    /* defaults */
    *pbDisconnect = bDefaultRouteDisconnect;
    *pnDelay = nDefaultRouteDisconnectTime;
    *lpszRouteInfo = '\0';

    if( MyGetPrivateProfileString( "Routes", lpszNodeName, "",
            (LPSTR) line, sizeof(line), szNetddeIni ) == 0 )  {
        return( FALSE );
    }

    if( line[0] != '\0' )  {
        lstrcpyn( lpszRouteInfo, line, nMaxRouteInfo );
    } else {
        lstrcpyn( lpszRouteInfo, lpszNodeName, nMaxRouteInfo );
    }

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\connects.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CONNECTS.C;1  16-Dec-92,10:20:12  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>

#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "security.h"
#include    "debug.h"
#include    "csv.h"
#include    "api1632.h"
#include    "proflspt.h"

extern char szNetddeIni[];

/*
    Global variables
*/
extern BOOL     bDefaultConnDisconnect;
extern int      nDefaultConnDisconnectTime;


BOOL
GetConnectionInfo(
    LPSTR       lpszNodeName,
    LPSTR       lpszNetIntf,
    LPSTR       lpszConnInfo,
    int         nMaxConnInfo,
    BOOL FAR   *pbDisconnect,
    int FAR    *pnDelay )
{
    BOOL        found = FALSE;
    char        line[256];
    int         len;
    PSTR        tokenNetIntf;
    PSTR        tokenConnInfo;
    PSTR        tokenDisconnect;
    PSTR        tokenDelay;

    /* defaults */
    *pbDisconnect = bDefaultConnDisconnect;
    *pnDelay = nDefaultConnDisconnectTime;
    *lpszNetIntf = '\0';
    *lpszConnInfo = '\0';
    lstrcpyn( lpszConnInfo, lpszNodeName, nMaxConnInfo );

    len = MyGetPrivateProfileString("ConnectionNames", lpszNodeName, "",
        (LPSTR) line, sizeof(line), szNetddeIni );
    if( len == 0 )  {
        return( FALSE );
    }

    tokenNetIntf = CsvToken( line );
    tokenConnInfo = CsvToken( NULL );
    tokenDisconnect = CsvToken( NULL );
    tokenDelay = CsvToken( NULL );
    found = TRUE;

    lstrcpyn( lpszNetIntf, tokenNetIntf, MAX_NI_NAME );

    /* only copy connInfo if some there to copy, otherwise
                        let the default stand     */
    if( tokenConnInfo && (tokenConnInfo[0] != '\0'))  {
        lstrcpyn( lpszConnInfo, tokenConnInfo, nMaxConnInfo );
    }

    *pbDisconnect = TokenBool( tokenDisconnect, bDefaultConnDisconnect );
    if( tokenDelay )  {
        *pnDelay = max( 1, atoi( tokenDelay ) );
    }

    return( found );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\dder.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DDER.C;9  9-Dec-92,8:34:44  LastEdit=IGORM  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
$History: End */

#include    "host.h"
#include    <windows.h>
#include    <hardware.h>

#ifdef _WINDOWS
#include    <memory.h>
#include    <string.h>
#include    <time.h>
#endif

#include    "dde.h"
#include    "wwdde.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "pktz.h"
#include    "dder.h"
#include    "ipc.h"
#include    "router.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hexdump.h"
#include    "host.h"
#include    "userdde.h"
#include    "security.h"
#include    "seckey.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "netddesh.h"

#ifdef _WINDOWS
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#endif

USES_ASSERT

/*
states
*/
#define DDER_INIT               (1)
#define DDER_WAIT_IPC_INIT      (2)
#define DDER_WAIT_ROUTER        (3)
#define DDER_WAIT_NET_INIT      (4)
#define DDER_CONNECTED          (5)
#define DDER_CLOSED             (6)


/*
DDER
    Structure for each DDER
*/
typedef struct s_dder {
/*  dd_prev, dd_next: links for all DDERs */
struct s_dder FAR   *dd_prev;
struct s_dder FAR   *dd_next;

/* dd_state: current state of DDER */
WORD                 dd_state;

/* dd_type: type of connection: DDTYPE_LOCAL_NET, DDTYPE_NET_LOCAL or
    DDTYPE_LOCAL_LOCAL */
WORD                 dd_type;

/* dd_hDderRemote: handle to corresponding DDER on remote system.
    NULL if local-local */
HDDER                dd_hDderRemote;

/* dd_hRouter: handle to router for this DDER.  NULL if local-local */
HROUTER              dd_hRouter;

/* dd_hIpcClient:  handle to IPC Client, NULL iff net->local */
HIPC                 dd_hIpcClient;

/* dd_hIpcServer:  handle to IPC Server, NULL iff local->net */
HIPC                 dd_hIpcServer;

/* dd_dderPrevForRouter: links of DDER's associated with router */
HDDER                dd_dderPrevForRouter;
HDDER                dd_dderNextForRouter;

/* statistics */
DWORD                   dd_sent;
DWORD                   dd_rcvd;

/* permission */
BOOL                    dd_bAdvisePermitted;
BOOL                    dd_bRequestPermitted;
BOOL                    dd_bPokePermitted;
BOOL                    dd_bExecutePermitted;
BOOL                    dd_bSecurityViolated;
BOOL                    dd_bClientTermRcvd;
BOOL                    dd_bWantToFree;
BOOL                    dd_pad;

/* dd_pktInitiate: initiate packet saved from waiting for router */
LPDDEPKTINIT            dd_lpDdePktInitiate;

/* dd_pktInitAck: initiate ack packet that guarantees that we have
    memory for it */
LPDDEPKTIACK            dd_lpDdePktInitAck;

/* terminate packets for client and server */
LPDDEPKTTERM            dd_lpDdePktTermServer;

/*  client's access token */
HANDLE                  dd_hClientAccessToken;

/*  pointer to share info */
PNDDESHAREINFO          dd_lpShareInfo;
} DDER;
typedef DDER FAR *LPDDER;

/*
External variables used
*/
#if DBG
extern  BOOL    bDebugInfo;
#endif // DBG
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  BOOL    bLogPermissionViolations;
extern  BOOL    bDefaultStartApp;
extern  DWORD   dwSecKeyAgeLimit;
extern  UINT    wMsgIpcInit;
/*
Local variables
*/
static  LPDDER          lpDderHead;

/*
Local routines
*/
#if DBG
VOID    FAR PASCAL DebugDderState(void);
VOID    DumpDder(LPDDER);
#endif // DBG

VOID    DderFree( HDDER hDder );
HDDER   DderCreate( void );
VOID    DderSendInitiateNackPacket( LPDDEPKTIACK lpDdePktInitAck,
        HDDER hDder, HDDER hDderDst, HROUTER hRouter, DWORD dwReason );

BOOL    SecurityValidate( LPDDER lpDder, LPSTR lpItem, BOOL bAllowed );

BOOL _stdcall NDDEGetChallenge(
LPBYTE lpChallenge,
UINT cbSize,
PUINT lpcbChallengeSize
);

DWORD   dwReasonInitFail;

#ifdef BYTE_SWAP
static VOID     ConvertDdePkt( LPDDEPKT lpDdePkt, BOOL bIncoming );
#else
#define ConvertDdePkt(x,y)
#endif



VOID
DderConnectionComplete(
HDDER   hDder,
HROUTER hRouter )
{
    LPDDER      lpDder;
    HDDER       hDderNext;
    BOOL        bFree = FALSE;

    DIPRINTF(( "DderConnectionComplete( %08lX, %08lX )", hDder, hRouter ));
    if( hDder == 0 )  {
        return;
    }

    lpDder = (LPDDER) hDder;

    hDderNext = lpDder->dd_dderNextForRouter;

    if( lpDder->dd_state == DDER_WAIT_ROUTER )  {
        assert( lpDder->dd_type == DDTYPE_LOCAL_NET );
        if( hRouter == 0 )  {
        /* couldn't get connection */
        assert( lpDder->dd_hIpcClient );

        /* abort the conversation */
        IpcAbortConversation( lpDder->dd_hIpcClient );
        lpDder->dd_hIpcClient = 0;

        bFree = TRUE;
        } else {
        /* got connection, send the init to the other side */
        lpDder->dd_state = DDER_WAIT_NET_INIT;

        /* remember the router */
        lpDder->dd_hRouter = hRouter;

        /* convert byte-ordering */
        ConvertDdePkt( (LPDDEPKT)lpDder->dd_lpDdePktInitiate, FALSE );

        lpDder->dd_sent++;

        /* send the packet */
        RouterPacketFromDder( lpDder->dd_hRouter, (HDDER)lpDder,
            (LPDDEPKT)lpDder->dd_lpDdePktInitiate );

        /* mark that we don't have the initiate packet anymore */
        lpDder->dd_lpDdePktInitiate = NULL;
        }
    }

    /* tell next hDder in list */
    if( hDderNext )  {
        DderConnectionComplete( hDderNext, hRouter );
    }

    if( bFree && hDder )  {
        DderFree( hDder );
    }
}


VOID
DderConnectionBroken( HDDER hDder )
{
    LPDDER      lpDder;
    HDDER       hDderNext;

    DIPRINTF(( "DderConnectionBroken( %08lX )", hDder ));

    if( hDder == 0 )  {
        return;
    }

    lpDder = (LPDDER) hDder;

    hDderNext = lpDder->dd_dderNextForRouter;

    /* assure that we don't talk to router anymore */
    lpDder->dd_hRouter = 0;

    if ( (lpDder->dd_type != DDTYPE_LOCAL_NET) &&
        (lpDder->dd_type != DDTYPE_NET_LOCAL) ) {
        InternalError("Bad DD type, %8lX lpDder->dd_type: %d",
            hDder, lpDder->dd_type);
        }

    /* abort DDE conversations */
    if( lpDder->dd_hIpcClient )  {
        IpcAbortConversation( lpDder->dd_hIpcClient );
        lpDder->dd_hIpcClient = 0;
    }
    if( lpDder->dd_hIpcServer )  {
        IpcAbortConversation( lpDder->dd_hIpcServer );
        lpDder->dd_hIpcServer = 0;
    }

    /* release us */
    DderFree( hDder );

    /* tell next hDder in list */
    if( hDderNext )  {
        DderConnectionBroken( hDderNext );
    }
}

VOID
DderSendInitiateNackPacket(
    LPDDEPKTIACK    lpDdePktInitAck,
    HDDER           hDder,
    HDDER           hDderDest,
    HROUTER         hRouter,
    DWORD           dwReason )
{
    LPDDEPKT        lpDdePkt        = (LPDDEPKT) lpDdePktInitAck;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTCMN     lpDdePktCmn;
    LPDDEPKTIACK    lpDdePktIack;
    LPBYTE          lpSecurityKey   = NULL;
    DWORD           sizeSecurityKey = 0L;
    DWORD           hSecurityKey;

    assert( lpDdePktInitAck );
    assert( hRouter );

    if( dwReason == RIACK_NEED_PASSWORD )  {
        lpDdePktInit = (LPDDEPKTINIT) lpDdePktInitAck;
        DdeSecKeyObtainNew( &hSecurityKey, &lpSecurityKey, &sizeSecurityKey );
        if( lpSecurityKey )  {
                lpDdePktIack = (LPDDEPKTIACK) CreateAckInitiatePkt( ourNodeName,
                    GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToApp),
                    GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToTopic),
                    lpSecurityKey, sizeSecurityKey, hSecurityKey,
                    FALSE, dwReason);
                if( lpDdePktIack )  {    /* created new one, dump old */
                    HeapFreePtr(lpDdePkt);
                    lpDdePkt = (LPDDEPKT) lpDdePktIack;
                    lpDdePkt->dp_hDstDder = hDderDest;
                } else {
                    dwReason = RIACK_DEST_MEMORY_ERR;
                }
        } else {
                dwReason = RIACK_DEST_MEMORY_ERR;
        }
    }

    if (dwReason != RIACK_NEED_PASSWORD) {   /* convert INIT to NACK initiate packet */
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktInitAck;
        lpDdePkt->dp_size = sizeof(DDEPKTIACK);
        lpDdePkt->dp_hDstDder = hDderDest;

        lpDdePktCmn->dc_message = WM_DDE_ACK_INITIATE;
        lpDdePktInitAck->dp_iack_offsFromNode = 0;
        lpDdePktInitAck->dp_iack_offsFromApp = 0;
        lpDdePktInitAck->dp_iack_offsFromTopic = 0;
        lpDdePktInitAck->dp_iack_fromDder = 0;
        lpDdePktInitAck->dp_iack_reason = dwReason;
    }

    /* convert byte-ordering */
    ConvertDdePkt( lpDdePkt, FALSE );

    /* xmit the packet */
    RouterPacketFromDder( hRouter, hDder, lpDdePkt );
}

BOOL
SecurityCheckPkt(
    LPDDER      lpDder,
    LPDDEPKT    lpDdePkt,
    LPDDEPKT   *lplpDdePkt )
{
    BOOL            bSend           = TRUE;
    BOOL            bViolation      = FALSE;
    LPDDEPKTCMN     lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKTPOKE    lpDdePktPoke;
    LPSTR           lpItem          = NULL;

    if( lpDder->dd_bSecurityViolated )  {
        /* already terminated because of security ... ignore pkt */
        bSend = FALSE;
        HeapFreePtr( lpDdePkt );
    } else {
        /* must check this message */
        bViolation = FALSE;
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ADVISE:
                lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt, lpDdePktAdvs->dp_advs_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bAdvisePermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_ADVISE", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_REQUEST:
                lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt, lpDdePktRqst->dp_rqst_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bRequestPermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_REQUEST", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_POKE:
                lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
                lpItem = GetStringOffset(lpDdePkt,
                lpDdePktPoke->dp_poke_offsItemName);
                if( !SecurityValidate( lpDder, lpItem, lpDder->dd_bPokePermitted ) )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: %1 on "%2"  */
                        NDDELogWarning(MSG102, "DDE_POKE", (LPSTR)lpItem, NULL);
                    }
                }
                break;

        case WM_DDE_EXECUTE:
                if( !lpDder->dd_bExecutePermitted )  {
                    bViolation = TRUE;
                    if( bLogPermissionViolations )  {
                        /*  SECURITY VIOLATION: DDE_EXECUTE"  */
                        NDDELogWarning(MSG103, NULL);
                    }
                }
                break;

        default:
            break;
    }

        if( bViolation )  {
                /*
             * free the packet that the client is trying to send
             */
                HeapFreePtr( lpDdePkt );

                /*
             * pretend the client sent a terminate
             */
                lpDdePkt = (LPDDEPKT) lpDder->dd_lpDdePktTermServer;
                lpDder->dd_lpDdePktTermServer = NULL;
                FillTerminatePkt( lpDdePkt );

                /*
             * note that we've had this violation, so that we
                 * ignore any future packets from this client
                 */
                lpDder->dd_bSecurityViolated = TRUE;
        }
    }
    *lplpDdePkt = lpDdePkt;
    return( bSend );
}

VOID
DderPacketFromRouter(
    HROUTER     hRouter,
    LPDDEPKT    lpDdePkt )
{
    HDDER           hDder;
    LPDDER          lpDder;
    LPDDEPKTCMN     lpDdePktCmn     = (LPDDEPKTCMN) lpDdePkt;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTIACK    lpDdePktInitAck;
    HIPC            hIpcDest;
    HDDER           hDderDest;
    BOOL            bFree           = FALSE;
    BOOL            bSend           = TRUE;

    DIPRINTF(( "DderPacketFromRouter( %08lX, %08lX )", hRouter, lpDdePkt ));
    /* convert byte-ordering */
    ConvertDdePkt( lpDdePkt, TRUE );

    hDder = lpDdePkt->dp_hDstDder;
    DIPRINTF(( "    hDder: %08lX", hDder ));

    assert( hRouter );
    lpDder = (LPDDER) hDder;
    if( lpDder == NULL )  {
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        assert( lpDdePktCmn->dc_message == WM_DDE_INITIATE );

        /* must be an initiate request */
        dwReasonInitFail = RIACK_UNKNOWN;
        hDder = DderInitConversation( 0, hRouter, lpDdePkt );
        if( hDder == 0 )  {
        /* couldn't create the conversation */

        /* use init packet to nack */
        hDderDest = lpDdePktInit->dp_init_fromDder;
        DderSendInitiateNackPacket( (LPDDEPKTIACK) lpDdePkt, hDder,
            hDderDest, hRouter, dwReasonInitFail );
        } else {
        RouterAssociateDder( hRouter, hDder );
        lpDder = (LPDDER) hDder;
        lpDder->dd_rcvd++;
        }
    } else {
        /* valid DDER */
        if( lpDder->dd_type == DDTYPE_LOCAL_NET )  {
        assert( lpDder->dd_hIpcClient );
        hIpcDest = lpDder->dd_hIpcClient;
        } else {
        assert( lpDder->dd_type == DDTYPE_NET_LOCAL );
        assert( lpDder->dd_hIpcServer );
        hIpcDest = lpDder->dd_hIpcServer;
        }

        lpDder->dd_rcvd++;

        /* look at message that is being sent */
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_INITIATE:
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        lpDder->dd_hDderRemote = lpDdePktInitAck->dp_iack_fromDder;
        if( lpDder->dd_hDderRemote == 0 )  {
            bFree = TRUE;
            lpDder->dd_state = DDER_CLOSED;
        } else {
            lpDder->dd_state = DDER_CONNECTED;
        }

        /* tell IPC */
        IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        break;
        case WM_DDE_TERMINATE:
        bSend = TRUE;
        if( lpDder->dd_type == DDTYPE_NET_LOCAL )  {
            lpDder->dd_bClientTermRcvd = TRUE;
            if( lpDder->dd_bSecurityViolated )  {
                bSend = FALSE;      /* already been sent */
                if( lpDder->dd_bWantToFree )  {
                    bFree = TRUE;
                }
            }
        }
        if( bSend )  {
            /* tell IPC */
            IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        }
        break;

        default:
        if( lpDder->dd_type == DDTYPE_LOCAL_NET )  {
            /* must be from server to client, just send the msg along */
            bSend = TRUE;
        } else {
            /*it's from a client to a srvr ... must validate permissions*/
            bSend = SecurityCheckPkt( lpDder, lpDdePkt, &lpDdePkt );
        }
        if( bSend )  {
            /* on messages other than ack_init, well just pass
                through to IPC */
            IpcXmitPacket( hIpcDest, (HDDER)lpDder, lpDdePkt );
        }
        }
    }
    if( bFree && hDder )  {
        DderFree( hDder );
    }
}

VOID
DderPacketFromIPC(
    HDDER       hDder,
    HIPC        hIpcFrom,
    LPDDEPKT    lpDdePkt )
{
    LPDDER              lpDder;
    HIPC                hIpcDest;
    BOOL                bFree = FALSE;
    BOOL                bSend = TRUE;
    LPDDEPKTINIT        lpDdePktInit;
    LPDDEPKTIACK        lpDdePktInitAck;
    LPDDEPKTCMN         lpDdePktCmn;

    assert( hDder );
    lpDder = (LPDDER) hDder;

#if DBG
    if( bDebugInfo ) {
        DPRINTF(( "DderPacketFromIPC( %08lX, %08lX, %08lX )",
        hDder, hIpcFrom, lpDdePkt ));
        DebugDdePkt( lpDdePkt );
    }
#endif // DBG

    /* if the message was a NACK initiate message, let's close down */
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_INITIATE:
        dwReasonInitFail = RIACK_UNKNOWN;
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        break;

    case WM_DDE_ACK_INITIATE:
        /* if the other side is NACKing the initiate,
        pass it on and then free us */
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        if( lpDdePktInitAck->dp_iack_fromDder == 0 )  {
                bFree = TRUE;
                lpDder->dd_state = DDER_CLOSED;
        } else {
                /* save our hDder in this packet */
                lpDdePktInitAck->dp_iack_fromDder = hDder;
                lpDder->dd_state = DDER_CONNECTED;
        }
        if( lpDder->dd_type == DDTYPE_LOCAL_LOCAL )  {
                lpDder->dd_hIpcServer = hIpcFrom;
        }

        break;
    }
    switch( lpDder->dd_type )  {
    case DDTYPE_LOCAL_NET:
    case DDTYPE_NET_LOCAL:
        lpDdePkt->dp_hDstDder = lpDder->dd_hDderRemote;

        /*
         * convert byte-ordering
         */
        ConvertDdePkt( lpDdePkt, FALSE );

        lpDder->dd_sent++;
        RouterPacketFromDder( lpDder->dd_hRouter, hDder, lpDdePkt );
        break;

    case DDTYPE_LOCAL_LOCAL:
        if( hIpcFrom == lpDder->dd_hIpcClient )  {
                hIpcDest = lpDder->dd_hIpcServer;
                if( lpDdePktCmn->dc_message == WM_DDE_TERMINATE )  {
                    lpDder->dd_bClientTermRcvd = TRUE;
                    if( lpDder->dd_bSecurityViolated )  {
                        bSend = FALSE;      /* already been sent */
                        if( lpDder->dd_bWantToFree )  {
                            bFree = TRUE;
                        }
                    }
                } else {
                    bSend = SecurityCheckPkt( lpDder, lpDdePkt, &lpDdePkt );
            }
        } else {
        bSend = TRUE;
        if( hIpcFrom != lpDder->dd_hIpcServer )  {
            InternalError(
                "Expecting from %08lX to be %08lX or %08lX",
                hIpcFrom, lpDder->dd_hIpcServer,
                lpDder->dd_hIpcClient );
        }
        hIpcDest = lpDder->dd_hIpcClient;
        }

        if( bSend )  {
                assert( hIpcDest );
                lpDder->dd_sent++;
                lpDder->dd_rcvd++;

                /*
             * xmit packet to other side
             */
                IpcXmitPacket( hIpcDest, hDder, lpDdePkt );
        }
        break;
    }

    /*
     * don't free it if we are in the middle of waiting for ipc init
     * to return
     */
    if( bFree && hDder && (lpDder->dd_state != DDER_WAIT_IPC_INIT) )  {
        DderFree( hDder );
    }
}


/*
 * Phase 5 of WM_DDE_INITIATE processing.
 *
 *
 */
HDDER
DderInitConversation(
    HIPC        hIpc,
    HROUTER     hRouter,
    LPDDEPKT    lpDdePkt )
{
    HDDER               hDder;
    LPDDER              lpDder;
    LPDDEPKTINIT        lpDdePktInit;
    LPSTR               lpszPktItem;
    BOOL                ok = TRUE;
    BOOL                bStart;
    BOOL                bSavedPkt = FALSE;
    char                cmdLine[ MAX_APP_NAME + MAX_TOPIC_NAME + 2];

    LPBYTE              lpSecurityKey   = NULL;
    DWORD               sizeSecurityKey = 0L;
    DWORD               hSecurityKey;
    LPDDEPKTIACK        lpDdePktIack;

    PTHREADDATA         ptd;
    IPCINIT             pii;

    DIPRINTF(( "DderInitConversation( %08lX, %08lX, %08lX )",
            hIpc, hRouter, lpDdePkt ));

    hDder = DderCreate();
    dwReasonInitFail = RIACK_UNKNOWN;
    if( hDder )  {
        lpDder = (LPDDER) hDder;
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        if( !hRouter )  {
            /* this came from IPC */

            /* blank out appropriate fields of msg */
            lpDdePkt->dp_hDstDder = 0;
            lpDdePkt->dp_hDstRouter = 0;
            lpDdePkt->dp_routerCmd = 0;
            lpDder->dd_lpDdePktInitiate = lpDdePktInit;

            /* mark that we saved the packet */
            bSavedPkt = TRUE;
        }

        lpszPktItem = GetStringOffset(lpDdePkt, lpDdePktInit->dp_init_offsToNode);
        /*
         * if destination node is blank, assume our node
         */
        DIPRINTF(("   with \"%Fs\"", lpszPktItem ));
        if( (lstrcmpi( lpszPktItem, ourNodeName ) == 0) ||
                (lstrlen(lpszPktItem) == 0) )  {
            /*
             * destination is our node
             */
            if( hRouter )  {
                /*
                 * this came from router
                 */
                assert( hIpc == 0 );
                lpDder->dd_type = DDTYPE_NET_LOCAL;
                lpDder->dd_hRouter = hRouter;
                lpDder->dd_hDderRemote = lpDdePktInit->dp_init_fromDder;
            } else {
                /*
                 * this came from IPC
                 */
                assert( hIpc != 0 );
                lpDder->dd_type = DDTYPE_LOCAL_LOCAL;
                lpDder->dd_hIpcClient = hIpc;
            }
        } else {
            /*
             * destination is another node
             * this came from IPC
             */
            assert( hIpc != 0 );
            assert( hRouter == 0 );
            lpDder->dd_type = DDTYPE_LOCAL_NET;
            lpDdePktInit->dp_init_fromDder = (HDDER) lpDder;
            lpDder->dd_hIpcClient = hIpc;
        }
        switch( lpDder->dd_type )  {
        case DDTYPE_NET_LOCAL:
            lpDder->dd_state = DDER_WAIT_IPC_INIT;
            bStart = FALSE;
            cmdLine[0] = '\0';

            pii.hDder = hDder;
            pii.lpDdePkt = lpDdePkt;
            pii.bStartApp = bStart;
            pii.lpszCmdLine = cmdLine;
            pii.dd_type = lpDder->dd_type;

            /*
             * Try sending wMsgIpcInit to each NetDDE window (one for each
             * desktop) and see if a connection results.
             */
            for (ptd = ptdHead;
                    dwReasonInitFail != RIACK_NEED_PASSWORD &&
                    ptd != NULL;
                        ptd = ptd->ptdNext) {

                lpDder->dd_hIpcServer = SendMessage(
                        ptd->hwndDDE,
                        wMsgIpcInit,
                        (WPARAM)&pii,
                        0);

                if (lpDder->dd_hIpcServer != 0)
                    break;

            }

            if( lpDder->dd_hIpcServer == 0 )  {
                DIPRINTF(("Ipc Net->Local failed.  Status = %d\n", dwReasonInitFail));
                if (dwReasonInitFail == RIACK_UNKNOWN) {
                    dwReasonInitFail = RIACK_STARTAPP_FAILED;
                }
                lpDder->dd_hRouter = 0;
                ok = FALSE;
            }
            if (lpDdePktInit->dp_init_hSecurityKey != 0) {
                DdeSecKeyRelease( lpDdePktInit->dp_init_hSecurityKey );
                lpDdePktInit->dp_init_hSecurityKey = 0;
            }
            break;

        case DDTYPE_LOCAL_LOCAL:
            lpDder->dd_state = DDER_WAIT_IPC_INIT;
            bStart = FALSE;
            cmdLine[0] = '\0';

            pii.hDder = hDder;
            pii.lpDdePkt = lpDdePkt;
            pii.bStartApp = bStart;
            pii.lpszCmdLine = cmdLine;
            pii.dd_type = lpDder->dd_type;

            for (ptd = ptdHead; dwReasonInitFail == RIACK_UNKNOWN &&
                    ptd != NULL; ptd = ptd->ptdNext) {
                lpDder->dd_hIpcServer = SendMessage(ptd->hwndDDE, wMsgIpcInit,
                        (WPARAM)&pii, 0);
                if (lpDder->dd_hIpcServer != 0)
                    break;
                if (dwReasonInitFail == RIACK_NOPERM_TO_STARTAPP) {
                    dwReasonInitFail = RIACK_UNKNOWN;
                    continue;
                }
                if( dwReasonInitFail == RIACK_NEED_PASSWORD )  {
                            DdeSecKeyObtainNew( &hSecurityKey, &lpSecurityKey,
                                        &sizeSecurityKey );
                            if( lpSecurityKey )  {
                                lpDdePktIack = (LPDDEPKTIACK)
                                    CreateAckInitiatePkt( ourNodeName,
                                        GetStringOffset(lpDdePkt,
                                            lpDdePktInit->dp_init_offsToApp),
                                        GetStringOffset(lpDdePkt,
                                            lpDdePktInit->dp_init_offsToTopic),
                                        lpSecurityKey, sizeSecurityKey, hSecurityKey,
                                        FALSE, dwReasonInitFail );
                                if( lpDdePktIack )  {
                                    IpcXmitPacket( lpDder->dd_hIpcClient,
                                                (HDDER)lpDder, (LPDDEPKT)lpDdePktIack );
                                } else {
                                    dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
                                }
                            } else {
                                dwReasonInitFail = RIACK_DEST_MEMORY_ERR;
                            }
                    break;
                    }
            }
            if( lpDder->dd_hIpcServer == 0 )  {
                DIPRINTF(("Ipc Local->Local failed.  Status = %d\n", dwReasonInitFail));
                if (dwReasonInitFail == RIACK_UNKNOWN)
                    dwReasonInitFail = RIACK_STARTAPP_FAILED;
                lpDder->dd_hRouter = 0;
                ok = FALSE;
            }
            if (lpDdePktInit->dp_init_hSecurityKey != 0) {
                DdeSecKeyRelease( lpDdePktInit->dp_init_hSecurityKey );
                lpDdePktInit->dp_init_hSecurityKey = 0;
            }
            break;

        case DDTYPE_LOCAL_NET:
            lpDder->dd_state = DDER_WAIT_ROUTER;
            /*
             * note that RouterGetRouterForDder() will associate Dder with
             * the router if OK
             */
            if( !RouterGetRouterForDder( GetStringOffset(lpDdePkt,
                    lpDdePktInit->dp_init_offsToNode), hDder ) )  {
                dwReasonInitFail = RIACK_ROUTE_NOT_ESTABLISHED;
                ok = FALSE;
            }
            break;

        default:
            InternalError( "DderInitConversation: Unknown type: %d",
                lpDder->dd_type );
        }

        if( !ok )  {
            if( bSavedPkt )  {
                lpDder->dd_lpDdePktInitiate = NULL;
                bSavedPkt = FALSE;
            }
            DderFree( hDder );
            hDder = 0;
        }
    }

    /*
     * if we didn't "save" the packet and we're returning ok ... free it
     */
    if( !bSavedPkt && hDder )  {
        HeapFreePtr( lpDdePkt );
    }

    return( hDder );
}

VOID
DderSetNextForRouter(
    HDDER   hDder,
    HDDER   hDderNext )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    lpDder->dd_dderNextForRouter = hDderNext;
}

VOID
DderSetPrevForRouter(
    HDDER   hDder,
    HDDER   hDderPrev )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    lpDder->dd_dderPrevForRouter = hDderPrev;
}

VOID
DderGetNextForRouter(
    HDDER       hDder,
    HDDER FAR  *lphDderNext )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    *lphDderNext = lpDder->dd_dderNextForRouter;
}

VOID
DderGetPrevForRouter(
    HDDER       hDder,
    HDDER FAR  *lphDderPrev )
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    *lphDderPrev = lpDder->dd_dderPrevForRouter;
}

HDDER
DderCreate( void )
{
    LPDDER      lpDder;
    HDDER       hDder;
    BOOL        ok = TRUE;

    lpDder = (LPDDER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD)sizeof(DDER) );
    if( lpDder )  {
        hDder = (HDDER) lpDder;
        lpDder->dd_prev                 = NULL;
        lpDder->dd_next                 = NULL;
        lpDder->dd_state                = 0;
        lpDder->dd_type                 = 0;
        lpDder->dd_hDderRemote          = 0;
        lpDder->dd_hRouter              = 0;
        lpDder->dd_hIpcClient           = 0;
        lpDder->dd_hIpcServer           = 0;
        lpDder->dd_dderPrevForRouter    = 0;
        lpDder->dd_dderNextForRouter    = 0;
        lpDder->dd_lpDdePktInitiate     = NULL;
        lpDder->dd_lpDdePktInitAck      = NULL;
        lpDder->dd_lpDdePktTermServer   = NULL;
        lpDder->dd_sent                 = 0;
        lpDder->dd_rcvd                 = 0;
        lpDder->dd_bAdvisePermitted     = TRUE;
        lpDder->dd_bRequestPermitted    = TRUE;
        lpDder->dd_bPokePermitted       = TRUE;
        lpDder->dd_bExecutePermitted    = TRUE;
        lpDder->dd_bSecurityViolated    = FALSE;
        lpDder->dd_bClientTermRcvd      = FALSE;
        lpDder->dd_bWantToFree          = FALSE;
        lpDder->dd_lpShareInfo          = NULL;
        lpDder->dd_hClientAccessToken   = 0;
        if( ok )  {
            lpDder->dd_lpDdePktInitAck = (LPDDEPKTIACK) HeapAllocPtr( hHeap,
                GMEM_MOVEABLE, (DWORD)sizeof(DDEPKTIACK) );
            if( lpDder->dd_lpDdePktInitAck == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            lpDder->dd_lpDdePktTermServer =
                (LPDDEPKTTERM) HeapAllocPtr( hHeap,
                    GMEM_MOVEABLE, (DWORD)sizeof(DDEPKTTERM) );
            if( lpDder->dd_lpDdePktTermServer == NULL )  {
                ok = FALSE;
                HeapFreePtr(lpDder->dd_lpDdePktInitAck);
            }
        }
        if( ok )  {
            /* link into list of DDERs */
            if( lpDderHead )  {
                lpDderHead->dd_prev = lpDder;
            }
            lpDder->dd_next = lpDderHead;
            lpDderHead = lpDder;
        } else {
            HeapFreePtr(lpDder);
            hDder = (HDDER) 0;
            dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
        }
    } else {
        hDder = (HDDER) 0;
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( hDder );
}

/*
    DderCloseConversation()

        This is called by the IPC after it has handled the terminates, etc.
        The IPC should not reference the hDder after calling this, since
        the hDder will be freed (at least in the hIpcFrom's eyes) upon this
        routine returning
 */
VOID
DderCloseConversation(
    HDDER   hDder,
    HIPC    hIpcFrom )
{
    LPDDER              lpDder;
    BOOL                bFree = FALSE;
    HIPC                hIpcOther;

    DIPRINTF(( "DderCloseConversation( %08lX, %08lX )", hDder, hIpcFrom ));

    assert( hDder );
    lpDder = (LPDDER) hDder;

    switch( lpDder->dd_type )  {
    case DDTYPE_LOCAL_NET:
    case DDTYPE_NET_LOCAL:
        /*
         * assume that IPC took care of transmitting TERMINATES and waiting
         * for return TERMINATE, etc.
         */
        bFree = TRUE;
        break;

    case DDTYPE_LOCAL_LOCAL:
        if( hIpcFrom == lpDder->dd_hIpcClient )  {
            lpDder->dd_hIpcClient = 0;
            hIpcOther = lpDder->dd_hIpcServer;
        } else {
            assert( hIpcFrom == lpDder->dd_hIpcServer );
            lpDder->dd_hIpcServer = 0;
            hIpcOther = lpDder->dd_hIpcClient;
        }
        if( hIpcOther == 0 )  {
            /*
             * both sides have told us to close ... really close
             */
            bFree = TRUE;
        }
        break;
    }

    if (bFree) {
        if( lpDder->dd_bSecurityViolated )  {
            DIPRINTF(( "  Security was violated, rcvdTerm:%d, want:%d",
                    lpDder->dd_bClientTermRcvd,
                    lpDder->dd_bWantToFree ));
            /*
             * For security violations, don't free the DDER until we
             * receive the client side termination
             */
            if( !lpDder->dd_bClientTermRcvd )  {
                lpDder->dd_bWantToFree = TRUE;
                bFree = FALSE;
            }
        }
    }
    DIPRINTF(( "DderCloseConversation, freeing? %d", bFree ));
    if( bFree )  {
        DderFree( hDder );
    }
}

VOID
FAR PASCAL
DderUpdatePermissions(
    HDDER                   hDder,
    PNDDESHAREINFO          lpShareInfo,
    DWORD                   dwGrantedAccess)
{
    LPDDER      lpDder;

    lpDder = (LPDDER) hDder;

    if( !lpShareInfo )  {
        return;
    }

    lpDder->dd_bAdvisePermitted =
            (dwGrantedAccess & NDDE_SHARE_ADVISE ? TRUE : FALSE);
    lpDder->dd_bRequestPermitted =
            (dwGrantedAccess & NDDE_SHARE_REQUEST ? TRUE : FALSE);
    lpDder->dd_bPokePermitted =
            (dwGrantedAccess & NDDE_SHARE_POKE ? TRUE : FALSE);
    lpDder->dd_bExecutePermitted =
            (dwGrantedAccess & NDDE_SHARE_EXECUTE ? TRUE : FALSE);

    if (lpDder->dd_lpShareInfo) {
        HeapFreePtr(lpDder->dd_lpShareInfo);
    }
    lpDder->dd_lpShareInfo = lpShareInfo;
}

VOID
DderFree( HDDER hDder )
{
    LPDDER      lpDder;
    LPDDER      lpDderPrev;
    LPDDER      lpDderNext;

    lpDder = (LPDDER) hDder;
#if DBG
    if( bDebugInfo ) {
        DPRINTF(( "DderFree( %08lX )", hDder ));
        DumpDder(lpDder);
    }
#endif // DBG

    if( lpDder->dd_hRouter )  {
        RouterDisassociateDder( lpDder->dd_hRouter, (HDDER) lpDder );
        lpDder->dd_hRouter = 0;
    }

    /*
     * unlink dde pkts created
     */
    if( lpDder->dd_lpDdePktInitAck )  {
        HeapFreePtr( lpDder->dd_lpDdePktInitAck );
        lpDder->dd_lpDdePktInitAck = NULL;
    }
    if( lpDder->dd_lpDdePktTermServer )  {
        HeapFreePtr( lpDder->dd_lpDdePktTermServer );
        lpDder->dd_lpDdePktTermServer = NULL;
    }
    if( lpDder->dd_lpDdePktInitiate )  {
        HeapFreePtr( lpDder->dd_lpDdePktInitiate );
        lpDder->dd_lpDdePktInitiate = NULL;
    }

    if (lpDder->dd_lpShareInfo) {
        HeapFreePtr( lpDder->dd_lpShareInfo);
        lpDder->dd_lpShareInfo = NULL;
    }

    /*
     * unlink from DDER list
     */
    lpDderPrev = lpDder->dd_prev;
    lpDderNext = lpDder->dd_next;
    if( lpDderPrev )  {
        lpDderPrev->dd_next = lpDderNext;
    } else {
        lpDderHead = lpDderNext;
    }
    if( lpDderNext )  {
        lpDderNext->dd_prev = lpDderPrev;
    }

    HeapFreePtr( lpDder );
}

#ifdef  BYTE_SWAP
VOID
ConvertDdePkt(
    LPDDEPKT    lpDdePkt,
    BOOL        bIncoming )
{
    LPDDEPKTCMN         lpDdePktCmn;
    LPDDEPKTINIT        lpDdePktInit;
    LPDDEPKTIACK        lpDdePktInitAck;
    LPDDEPKTGACK        lpDdePktGack;
    LPDDEPKTTERM        lpDdePktTerm;
    LPDDEPKTEXEC        lpDdePktExec;
    LPDDEPKTEACK        lpDdePktEack;
    LPDDEPKTRQST        lpDdePktRqst;
    LPDDEPKTUNAD        lpDdePktUnad;
    LPDDEPKTPOKE        lpDdePktPoke;
    LPDDEPKTDATA        lpDdePktData;
    LPDDEPKTADVS        lpDdePktAdvs;

    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    lpDdePkt->dp_hDstDder = HostToPcLong( lpDdePkt->dp_hDstDder );

    if( bIncoming )  {
        lpDdePktCmn->dc_message = HostToPcWord( lpDdePktCmn->dc_message );
    }
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_INITIATE:
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        lpDdePktInit->dp_init_fromDder =
            HostToPcLong( lpDdePktInit->dp_init_fromDder );
        lpDdePktInit->dp_init_offsFromNode =
            HostToPcWord( lpDdePktInit->dp_init_offsFromNode );
        lpDdePktInit->dp_init_offsFromApp =
            HostToPcWord( lpDdePktInit->dp_init_offsFromApp );
        lpDdePktInit->dp_init_offsToNode =
            HostToPcWord( lpDdePktInit->dp_init_offsToNode );
        lpDdePktInit->dp_init_offsToApp =
            HostToPcWord( lpDdePktInit->dp_init_offsToApp );
        lpDdePktInit->dp_init_offsToTopic =
            HostToPcWord( lpDdePktInit->dp_init_offsToTopic );
        lpDdePktInit->dp_init_hSecurityKey =
            HostToPcLong( lpDdePktInit->dp_init_hSecurityKey );
        lpDdePktInit->dp_init_dwSecurityType =
            HostToPcLong( lpDdePktInit->dp_init_dwSecurityType );
        lpDdePktInit->dp_init_sizePassword =
            HostToPcLong( lpDdePktInit->dp_init_sizePassword );
        break;

    case WM_DDE_ACK_INITIATE:
        lpDdePktInitAck = (LPDDEPKTIACK) lpDdePkt;
        lpDdePktInitAck->dp_iack_fromDder =
            HostToPcLong( lpDdePktInitAck->dp_iack_fromDder );
        lpDdePktInitAck->dp_iack_reason =
            HostToPcLong( lpDdePktInitAck->dp_iack_reason );
        lpDdePktInitAck->dp_iack_offsFromNode =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromNode );
        lpDdePktInitAck->dp_iack_offsFromApp =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromApp );
        lpDdePktInitAck->dp_iack_offsFromTopic =
            HostToPcWord( lpDdePktInitAck->dp_iack_offsFromTopic );
        lpDdePktInitAck->dp_iack_hSecurityKey =
            HostToPcLong( lpDdePktInitAck->dp_iack_hSecurityKey );
        lpDdePktInitAck->dp_iack_dwSecurityType =
            HostToPcLong( lpDdePktInitAck->dp_iack_dwSecurityType );
        lpDdePktInitAck->dp_iack_sizeSecurityKey =
            HostToPcLong( lpDdePktInitAck->dp_iack_sizeSecurityKey );
        break;

    case WM_DDE_TERMINATE:
    case WM_DDE_EXECUTE:
    case WM_DDE_ACK_EXECUTE:
    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
    case WM_DDE_WWTEST:
        break;

    case WM_DDE_REQUEST:
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        lpDdePktRqst->dp_rqst_cfFormat =
            HostToPcWord( lpDdePktRqst->dp_rqst_cfFormat );
        lpDdePktRqst->dp_rqst_offsFormat =
            HostToPcWord( lpDdePktRqst->dp_rqst_offsFormat );
        lpDdePktRqst->dp_rqst_offsItemName =
            HostToPcWord( lpDdePktRqst->dp_rqst_offsItemName );
        break;

    case WM_DDE_UNADVISE:
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        lpDdePktUnad->dp_unad_cfFormat =
            HostToPcWord( lpDdePktUnad->dp_unad_cfFormat );
        lpDdePktUnad->dp_unad_offsFormat =
            HostToPcWord( lpDdePktUnad->dp_unad_offsFormat );
        lpDdePktUnad->dp_unad_offsItemName =
            HostToPcWord( lpDdePktUnad->dp_unad_offsItemName );
        break;

    case WM_DDE_DATA:
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        lpDdePktData->dp_data_cfFormat =
            HostToPcWord( lpDdePktData->dp_data_cfFormat );
        lpDdePktData->dp_data_offsFormat =
            HostToPcWord( lpDdePktData->dp_data_offsFormat );
        lpDdePktData->dp_data_offsItemName =
            HostToPcWord( lpDdePktData->dp_data_offsItemName );
        lpDdePktData->dp_data_sizeData =
            HostToPcLong( lpDdePktData->dp_data_sizeData );
        lpDdePktData->dp_data_offsData =
            HostToPcWord( lpDdePktData->dp_data_offsData );
        break;

    case WM_DDE_POKE:
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        lpDdePktPoke->dp_poke_cfFormat =
            HostToPcWord( lpDdePktPoke->dp_poke_cfFormat );
        lpDdePktPoke->dp_poke_offsFormat =
            HostToPcWord( lpDdePktPoke->dp_poke_offsFormat );
        lpDdePktPoke->dp_poke_offsItemName =
            HostToPcWord( lpDdePktPoke->dp_poke_offsItemName );
        lpDdePktPoke->dp_poke_sizeData =
            HostToPcLong( lpDdePktPoke->dp_poke_sizeData );
        lpDdePktPoke->dp_poke_offsData =
            HostToPcWord( lpDdePktPoke->dp_poke_offsData );
        break;

    case WM_DDE_ADVISE:
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        lpDdePktAdvs->dp_advs_cfFormat =
            HostToPcWord( lpDdePktAdvs->dp_advs_cfFormat );
        lpDdePktAdvs->dp_advs_offsFormat =
            HostToPcWord( lpDdePktAdvs->dp_advs_offsFormat );
        lpDdePktAdvs->dp_advs_offsItemName =
            HostToPcWord( lpDdePktAdvs->dp_advs_offsItemName );
        break;

    default:
        InternalError( "DDER: must handle conversion for message: %04X",
            lpDdePktCmn->dc_message );
    }

    if( !bIncoming ) {
        lpDdePktCmn->dc_message = HostToPcWord( lpDdePktCmn->dc_message );
    }
}
#endif


VOID FAR PASCAL IpcFillInConnInfo(
        HIPC            hIpc,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd );

HDDER
FAR PASCAL
DderFillInConnInfo(
        HDDER           hDder,
        LPCONNENUM_CMR  lpConnEnum,
        LPSTR           lpDataStart,
        LPWORD          lpcFromBeginning,
        LPWORD          lpcFromEnd
)
{
    HDDER               hDderNext = (HDDER) 0;
    LPDDER              lpDder;

    if( hDder )  {
        lpDder = (LPDDER)hDder;
        hDderNext = (HDDER)lpDder->dd_next;
        if( lpDder->dd_type == DDTYPE_NET_LOCAL )  {
            IpcFillInConnInfo( lpDder->dd_hIpcServer, lpConnEnum,
                    lpDataStart, lpcFromBeginning, lpcFromEnd );
        }
    }
    return( hDderNext );
}

#if DBG
VOID
DumpDder(LPDDER lpDder)
{
    DPRINTF(( "%Fp:\n"
              "  dd_prev              %Fp\n"
              "  dd_next              %Fp\n"
              "  dd_state             %d\n"
              "  dd_type              %d\n"
              "  dd_hDderRemote       %Fp\n"
              "  dd_hRouter           %Fp\n"
              "  dd_hIpcClient        %Fp\n"
              "  dd_hIpcServer        %Fp\n"
              "  dd_dderPrevForRouter %Fp\n"
              "  dd_dderNextForRouter %Fp\n"
              "  dd_bAdvisePermitted  %d\n"
              "  dd_bRequestPermitted %d\n"
              "  dd_bPokePermitted    %d\n"
              "  dd_bExecutePermitted %d\n"
              "  dd_bSecurityViolated %d\n"
              "  dd_sent              %ld\n"
              "  dd_rcvd              %ld\n"
              ,
            lpDder,
            lpDder->dd_prev,
            lpDder->dd_next,
            lpDder->dd_state,
            lpDder->dd_type,
            lpDder->dd_hDderRemote,
            lpDder->dd_hRouter,
            lpDder->dd_hIpcClient,
            lpDder->dd_hIpcServer,
            lpDder->dd_dderPrevForRouter,
            lpDder->dd_dderNextForRouter,
            lpDder->dd_bAdvisePermitted,
            lpDder->dd_bRequestPermitted,
            lpDder->dd_bPokePermitted,
            lpDder->dd_bExecutePermitted,
            lpDder->dd_bSecurityViolated,
            lpDder->dd_sent,
            lpDder->dd_rcvd ));
}

VOID
FAR PASCAL
DebugDderState( void )
{
    LPDDER      lpDder;

    lpDder = lpDderHead;
    DPRINTF(( "DDER State:" ));
    while( lpDder )  {
        DumpDder(lpDder);
        lpDder = lpDder->dd_next;
    }
}
#endif // DBG

typedef struct seckey_tag {
    struct seckey_tag FAR       *sk_prev;
    struct seckey_tag FAR       *sk_next;
    time_t                       sk_creationTime;
    DWORD                        sk_handle;
    LPVOID                       sk_key;
    DWORD                        sk_size;
} SECKEY;
typedef SECKEY FAR *LPSECKEY;

LPSECKEY        lpSecKeyHead;
DWORD           dwHandle = 1L;

LPSECKEY
FAR PASCAL
DdeSecKeyFind( DWORD hSecurityKey )
{
    LPSECKEY    lpSecKey;

    lpSecKey = lpSecKeyHead;
    while( lpSecKey )  {
        if( lpSecKey->sk_handle == hSecurityKey )  {
            return( lpSecKey );
        }
        lpSecKey = lpSecKey->sk_next;
    }
    return( (LPSECKEY) 0 );
}

VOID
FAR PASCAL
DdeSecKeyFree( LPSECKEY lpSecKeyFree )
{
    LPSECKEY    prev;
    LPSECKEY    next;

    prev = lpSecKeyFree->sk_prev;
    next = lpSecKeyFree->sk_next;
    if( prev )  {
        prev->sk_next = next;
    } else {
        lpSecKeyHead = next;
    }
    if( next )  {
        next->sk_prev = prev;
    }
    HeapFreePtr( lpSecKeyFree->sk_key );
    HeapFreePtr( lpSecKeyFree );
}


VOID
FAR PASCAL
DdeSecKeyObtainNew(
            LPDWORD lphSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey
)
{
    LPSECKEY    lpSecKey;
    LPVOID      lpKey;
    DWORD       dwSize;
    UINT        uSize;

    *lphSecurityKey = (DWORD) 0;
    *lplpSecurityKey = (LPSTR) NULL;
    *lpsizeSecurityKey = 0;

    lpSecKey = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
        (DWORD)sizeof(SECKEY) );
    if( lpSecKey )  {
        dwSize = 8;
        lpKey = HeapAllocPtr( hHeap, GMEM_MOVEABLE | GMEM_ZEROINIT,
            (DWORD)dwSize );
        if( lpKey )  {
            if( !NDDEGetChallenge( lpKey, dwSize, &uSize ) )  {
                _fmemcpy( lpKey, "12345678", (int)dwSize );
            }

            lpSecKey->sk_creationTime   = time(NULL);
            lpSecKey->sk_handle         = dwHandle++;
            lpSecKey->sk_key            = lpKey;
            lpSecKey->sk_size           = dwSize;

            /* put into the list */
            lpSecKey->sk_prev           = NULL;
            lpSecKey->sk_next           = lpSecKeyHead;
            if( lpSecKeyHead )  {
                lpSecKeyHead->sk_prev = lpSecKey;
            }
            lpSecKeyHead = lpSecKey;

            *lphSecurityKey = (DWORD) lpSecKey->sk_handle;
            *lplpSecurityKey = (LPSTR) lpSecKey->sk_key;
            *lpsizeSecurityKey = lpSecKey->sk_size;
        } else {
            HeapFreePtr( lpKey );
        }
    }
}

BOOL
FAR PASCAL
DdeSecKeyRetrieve(
            DWORD hSecurityKey,
            LPSTR FAR *lplpSecurityKey,
            LPDWORD lpsizeSecurityKey
)
{
    LPSECKEY    lpSecKey;

    lpSecKey = DdeSecKeyFind( hSecurityKey );
    if( lpSecKey )  {
        *lplpSecurityKey = lpSecKey->sk_key;
        *lpsizeSecurityKey = lpSecKey->sk_size;
        return( TRUE );
    } else {
        return( FALSE );
    }
}


VOID
FAR PASCAL
DdeSecKeyAge( void )
{
    LPSECKEY    lpSecKey;
    LPSECKEY    lpSecKeyNext;
    time_t      curTime;

    curTime = time(NULL);
    lpSecKey = lpSecKeyHead;
    while( lpSecKey )  {
        lpSecKeyNext = lpSecKey->sk_next;
        if( (curTime - lpSecKey->sk_creationTime) > (long) dwSecKeyAgeLimit )  {
            DdeSecKeyFree( lpSecKey );
        }
        lpSecKey = lpSecKeyNext;
    }
}


VOID
FAR PASCAL
DdeSecKeyRelease( DWORD hSecurityKey )
{
    LPSECKEY    lpSecKey;

    lpSecKey = DdeSecKeyFind( hSecurityKey );
    if( lpSecKey )  {
        DdeSecKeyFree( lpSecKey );
    }
}

BOOL
SecurityValidate( LPDDER lpDder, LPSTR lpszActualItem, BOOL bAllowed )
{
    LPSTR       lpszItem;
    LONG        n;
    BOOL        ok = FALSE;

    if( !bAllowed) {
        DPRINTF(("SecurityValidate: Not allowed to access share info."));
        return( FALSE );
    } else if (!lpDder->dd_lpShareInfo )  {
        DPRINTF(("SecurityValidate: No share info. exists."));
        return( FALSE );        /* no share info, no access */
    } else if ((n = lpDder->dd_lpShareInfo->cNumItems) == 0 )  {
        /* any item allowed */
        ok = TRUE;
    } else {
        lpszItem = lpDder->dd_lpShareInfo->lpszItemList;
        while( n-- && (*lpszItem != '\0') )  {
            if( lstrcmpi( lpszActualItem, lpszItem ) == 0 )  {
                    ok = TRUE;
                    break;
            } else {
                    lpszItem += lstrlen(lpszItem) + 1;
            }
        }
        if (!ok) {
            DPRINTF(("SecurityValidate: Item not in itemlist."));
        }
    }
    return( ok );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\lsaval.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"
#include "ntmsv1_0.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>


#define SKIP_DEBUG_WIN32
#include "debug.h"

void    DumpWhoIAm( char * lpszMsg );

typedef int BOOL;
typedef unsigned int UINT;
typedef unsigned int *PUINT;
typedef unsigned char *LPBYTE;
HANDLE  LsaHandle;
ULONG   AuthenticationPackage;

#define BUF_SIZ 512
char    prtbuf[BUF_SIZ];


void
replstar(
    IN char *  starred,
    OUT LPWSTR UnicodeOut
    )
/*++ replstar

Routine Description:

    replaces the '*' in the string with either spaces or NULL
    if it's the only memeber of the string.  Used by parse().

    Converts the resultant string to unicode.

Arguments:

    char *  starred -

Return Value:

    void -
Warnings:
--*/
{
    char *cp;
    STRING AnsiString;
    UNICODE_STRING UnicodeString;

    if ( !strcmp(starred,"*") ) {
        *starred = '\0';
    } else {
        for ( cp = starred; *cp; ++cp )
            if (*cp == '*')
                *cp = ' ';
    }

    //
    // Convert the result to unicode
    //

    AnsiString.Buffer = starred;
    AnsiString.Length = AnsiString.MaximumLength =
        (USHORT) strlen( starred );

    UnicodeString.Buffer = UnicodeOut;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = BUF_SIZ * sizeof(WCHAR);

    (VOID) RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    return;
}

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )
/*++ NlpPutString

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);

    if ( InString->Length > 0 )
    {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = InString->Length;
        *Where += OutString->MaximumLength;

        RtlCopyString( (PSTRING) OutString, (PSTRING) InString );

    }
    else
    {
        RtlInitUnicodeString(OutString, NULL);
    }

    return;
}


char *
PrintWCS(
    IN  PWCH    pwc,
    IN  ULONG   Length
    )
/*++ PrintWCS

Routine Description:

    return an ANSI type character string given a Unicode string and length
    used in printing out the buffers since our wide strings aren't null
    terminated.

Arguments:
        IN  PWCH    pwc     - unicode string.buffer
        IN  ULONG   Length  - length

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    ULONG   i;
    char *bufp    = prtbuf;

    if ( Length == 0 || pwc == NULL ) {
        return "(NULL)";
    }

    Length /= sizeof(WCHAR);

    for ( i = 0; i < Length; ++i, pwc++ )
    {
        sprintf(bufp,"%wc", *pwc );
        ++bufp;
    }
    return prtbuf;
}

char *
PrintLogonId(
    IN  PLUID   LogonId
    )
/*++ PrintLogonId

Routine Description:

    return an ANSI type character string given a logon Id

Arguments:
    IN  PLUID   LogonId - LUID to return in ANSI

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    sprintf( prtbuf, "%lX.%lX", LogonId->HighPart, LogonId->LowPart );
    return prtbuf;
}
/* end of "char * PrintLogonId()" */



char *
PrintBytes(
     IN PVOID Buffer,
     IN ULONG Size
 )
/*++ PrintBytes

Routine Description:

    return an ANSI type character string given several binary bytes.

Arguments:
    IN  PVOID   Buffer - Pointer to binary bytes
    IN  ULONG   Size   - Number of bytes to print

Return Value:

    char * - pointer to an ANSI string

Warnings:

    probably not a good idea to use it twice in the same Printf call,
    since it uses the same prtbuf for static storage

--*/
{
    ULONG   i;
    char *bufp    = prtbuf;

    for ( i = 0; i < Size; ++i )
    {
        if ( i != 0 ) {
            *(bufp++) = '.';
        }
        sprintf(bufp,"%2.2x", ((PUCHAR)Buffer)[i] );
        bufp+=2;
    }
    return prtbuf;
}



BOOL
LogonNetwork(
    IN  LPWSTR      Username,
    IN  PUCHAR      ChallengeToClient,
    IN  PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponse,
    IN  UINT        cbChallengeResponse,
    IN  LPWSTR      Domain,
    OUT PLUID       LogonId,
    OUT PHANDLE     TokenHandle
    )
/*++ LogonNetwork

Routine Description:

    Logs a user onto the network

Arguments:
        IN  LPWSTR  Username    - self explanatory
        IN  ChallengeToClient   -  The challenge sent to the client
        IN  ChallengeResponse   -  The response sent from the client
        IN  LPWSTR  Domain      - Logon Domain Name
        OUT PLUID   LogonId     - Unique generated logon id
        OUT PHANDLE TokenHandle - handle to the logon token

Return Value:

    BOOL -

Warnings:

--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      TempString;
    UNICODE_STRING      TempString2;
    UNICODE_STRING      OriginName;
    PMSV1_0_LM20_LOGON  Auth;
    PCHAR               Auth1[BUF_SIZ*5]; /* lots o' space */
    PUCHAR              Strings;
    PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
    ULONG               ProfileBufferSize;
    NTSTATUS            SubStatus;
    TOKEN_SOURCE        SourceContext;
    QUOTA_LIMITS        QuotaLimits;


    /*
     *  Fill in the Authentication structure.
     */
    Auth = (PMSV1_0_LM20_LOGON) Auth1;

    Strings = (PUCHAR)(Auth + 1);

    Auth->MessageType = MsV1_0Lm20Logon;
    RtlMoveMemory( Auth->ChallengeToClient,
                   ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    /* Init Strings
     *  username
     */
    RtlInitUnicodeString( &TempString, Username );
    NlpPutString( &Auth->UserName, &TempString, &Strings );

    /*
     *  workstation name
     */
    RtlInitUnicodeString( &TempString, L"NetDDE" );
    NlpPutString( &Auth->Workstation, &TempString, &Strings );

    /*
     *  Challenge Response
     */

    Auth->CaseSensitiveChallengeResponse.Length = 0;
    Auth->CaseSensitiveChallengeResponse.MaximumLength = 0;
    Auth->CaseSensitiveChallengeResponse.Buffer = NULL;


#ifdef OLD
    RtlInitUnicodeString(
        (PUNICODE_STRING)&TempString2,
        (PCWSTR)ChallengeResponse );
#else
    TempString2.Buffer = (PWSTR)ChallengeResponse;
    TempString2.Length = (USHORT)cbChallengeResponse;
    TempString2.MaximumLength = TempString2.Length;
#endif
    if( TempString2.Length > 24 )  {
        TempString2.Length = 24;
    }
    NlpPutString(
        (PUNICODE_STRING)&Auth->CaseInsensitiveChallengeResponse,
        (PUNICODE_STRING)&TempString2,
        &Strings );
    /*
     *  domain
     */
    RtlInitUnicodeString( &TempString, Domain );
    NlpPutString( &Auth->LogonDomainName, &TempString, &Strings );


    RtlInitUnicodeString( &OriginName, L"NetDDE" );

    //
    // Initialize source context structure
    //
    strncpy(SourceContext.SourceName, "NetDDE  ", sizeof(SourceContext.SourceName));

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaLogonUser(
                    LsaHandle,
                    (PSTRING)&OriginName,
                    Network,
                    AuthenticationPackage,
                    Auth,
                    (ULONG)(Strings - (PUCHAR)Auth),
                    NULL,
                    &SourceContext,
                    (PVOID *)&ProfileBuffer,
                    &ProfileBufferSize,
                    LogonId,
                    TokenHandle,
                    &QuotaLimits,
                    &SubStatus );
    }


    if ( !NT_SUCCESS( Status ) )
    {
        *TokenHandle = NULL;
        return( FALSE );
    }

    LsaFreeReturnBuffer( ProfileBuffer );
    return( TRUE );
}


BOOL
Challenge(
    UCHAR *ChallengeToClient
    )
/*++ Challenge

Routine Description:

    get a challenge

Arguments:
        OUT  ChallengeToClient -  Returns the challenge to send to the client

Return Value:
    NTSTATUS -
Warnings:
--*/
{
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    MSV1_0_LM20_CHALLENGE_REQUEST Request;
    PMSV1_0_LM20_CHALLENGE_RESPONSE Response;

#ifdef HARD_CODE_CHALLENGE
    { int i;
        for( i=0; i<8; i++ )  {
            ChallengeToClient[i] = 0;
        }
    }
    return STATUS_SUCCESS;
#endif

    /*
     *  Fill in the Authentication structure.
     */

    Request.MessageType = MsV1_0Lm20ChallengeRequest;

    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    &Request,
                    sizeof(Request),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );

    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
        return( FALSE );
    }

    RtlMoveMemory( ChallengeToClient,
                   Response->ChallengeToClient,
                   MSV1_0_CHALLENGE_LENGTH );

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}

BOOL
LocalLSAInit( void )
{
    STRING      LogonProcessName;
    STRING      PackageName;
    NTSTATUS    Status;
    LSA_OPERATIONAL_MODE SecurityMode;
    static BOOL bInit = FALSE;
    static BOOL bOk = FALSE;

    if( bInit )  {
        return( bOk );
    }
    bInit = TRUE;
    RtlInitAnsiString( &LogonProcessName, "NetDDE" );
    Status = LsaRegisterLogonProcess(
                &LogonProcessName,
                &LsaHandle,
                &SecurityMode );

    if ( !NT_SUCCESS( Status ) )
    {
        return( FALSE );
    }

    RtlInitAnsiString( &PackageName,  MSV1_0_PACKAGE_NAME );

    Status = LsaLookupAuthenticationPackage(
                LsaHandle,
                &PackageName,
                &AuthenticationPackage );

    if ( !NT_SUCCESS( Status ) )
    {
        return( FALSE );
    }

    bOk = TRUE;
    return( TRUE );
}


BOOL NDDEGetChallenge(
    LPBYTE lpChallenge,
    UINT cbSize,
    PUINT lpcbChallengeSize
    )
{
    if( LocalLSAInit() )  {
        *lpcbChallengeSize = 8;
        Challenge( lpChallenge );
        return( TRUE );
    } else {
        return( FALSE );
    }
}

BOOL
NDDEValidateLogon(
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    PHANDLE phLogonToken
    )
{
    WCHAR       wcUser[ BUF_SIZ ];
    WCHAR       wcDomain[ BUF_SIZ ];
    LUID        LogonId;
    BOOL        nlRet;

    if( !LocalLSAInit() )  {
        return( FALSE );
    }
    replstar( lpszUserName, wcUser );
    replstar( lpszDomainName, wcDomain );
    nlRet = LogonNetwork( wcUser, lpChallenge,
        (PMSV1_0_GETCHALLENRESP_RESPONSE)lpResponse,
        cbResponseSize, wcDomain, &LogonId, phLogonToken );
    return( nlRet );
}

BOOL
NDDEGetChallengeResponse(
    LUID        LogonId,
    LPSTR       lpszPasswordK1,
    int         cbPasswordK1,
    LPSTR       lpszChallenge,
    int         cbChallenge,
    int         *pcbPasswordK1,
    BOOL        *pbHasPasswordK1 )
{
    BOOL        ok = TRUE;
    NTSTATUS Status;
    NTSTATUS ProtocolStatus;
    ULONG    ResponseSize;
    PMSV1_0_GETCHALLENRESP_RESPONSE Response;
    PMSV1_0_GETCHALLENRESP_REQUEST Request;

    PCHAR          Auth1[BUF_SIZ];
    PUCHAR         Strings;


    if( !LocalLSAInit() )  {
        *pbHasPasswordK1 = FALSE;
        return( FALSE );
    }
    Request = (PMSV1_0_GETCHALLENRESP_REQUEST) Auth1;
    Request->MessageType = MsV1_0Lm20GetChallengeResponse;
    Request->ParameterControl = 0;
    Request->ParameterControl |= USE_PRIMARY_PASSWORD;
    Request->LogonId = LogonId;
    Strings = (PUCHAR)(Request + 1);
    RtlMoveMemory( Request->ChallengeToClient,
                   lpszChallenge,
                   MSV1_0_CHALLENGE_LENGTH );

    RtlInitUnicodeString( &Request->Password, NULL );
    Status = LsaCallAuthenticationPackage (
                    LsaHandle,
                    AuthenticationPackage,
                    Request,
                    sizeof(MSV1_0_GETCHALLENRESP_REQUEST),
                    (PVOID *)&Response,
                    &ResponseSize,
                    &ProtocolStatus );
    if ( !NT_SUCCESS( Status ) || !NT_SUCCESS( ProtocolStatus) )
    {
        return( FALSE );
    }

    *pcbPasswordK1 = (Response)->CaseInsensitiveChallengeResponse.Length;
    memcpy( lpszPasswordK1,
        (Response)->CaseInsensitiveChallengeResponse.Buffer,
        (Response)->CaseInsensitiveChallengeResponse.Length );
    *pbHasPasswordK1 = TRUE;

    LsaFreeReturnBuffer( Response );

    return( TRUE );
}

HANDLE
OpenCurrentUserKey(ULONG DesiredAccess)
{
    NTSTATUS    Status;
    HANDLE      CurrentUserKey;

    Status = RtlOpenCurrentUser( DesiredAccess, &CurrentUserKey);
    if (NT_SUCCESS( Status) ) {
        return(CurrentUserKey);
    } else {
        DPRINTF(("Unable to open current user key: %d", Status));
        return(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\csv.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "CSV.C;1  16-Dec-92,10:20:18  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.                *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "host.h"
#include "windows.h"
#include "csv.h"

static PSTR     pszLastIn;
static PSTR     pszLastOut;
static char     szToken[ 1024 ];        /* max token 1024 long */

PSTR
FAR PASCAL
CsvToken( PSTR pszBuf )
{
    PSTR        pszCur;
    PSTR        pszOut;
    PSTR        pszReturn;
    BOOL        fDone = FALSE;
    BOOL        fQuote = FALSE;

    if( pszBuf )  {
        pszLastIn = pszBuf;
        pszLastOut = szToken;
    }
    
    pszCur = pszLastIn;
    pszOut = pszLastOut;

    switch( *pszCur )  {
    case '\0':
    case '\n':
        /* check for empty string */
        return( (PSTR)NULL );
    case '"':
        fQuote = TRUE;
        pszCur++;       /* past the quote */
        break;
    }
    while( !fDone && (*pszCur != '\0') && (*pszCur != '\n') )  {
        if( fQuote && (*pszCur == '"') )  {
            if( *(pszCur+1) == '"' )  {
                /* escaped quote */
                *pszOut++ = '"';
                pszCur += 2;    /* past both quotes */
            } else {
                /* done with string */
                fDone = TRUE;
                pszCur++;       /* past quote */
                
                if( (*pszCur == '\n') || (*pszCur == ',') )  {
                    /* past comma or newline */
                    pszCur++;
                }
            }
        } else if( !fQuote && (*pszCur == ',') )  {
            fDone = TRUE;
            /* go past comma */
            pszCur++;
        } else {
            *pszOut++ = *pszCur++;
        }
    }
    *pszOut++ = '\0';
    pszLastIn = pszCur;
    pszReturn = pszLastOut;
    pszLastOut = pszOut;
    
    return( pszReturn );
}

BOOL
FAR PASCAL
TokenBool( PSTR pszToken, BOOL bDefault )
{
    if( pszToken )  {
        if( lstrcmpi( pszToken, "1" ) == 0 )  {
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( bDefault );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\pktz.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "PKTZ.C;1  16-Dec-92,10:20:56  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

/*
        PktzNetHdrWithinAck() doesn't handle wrap-around case!  Neither does
            PktzOkToXmit() when looking for packet id to send
 */

#include    "host.h"

#ifdef _WINDOWS
#include    <memory.h>
#include    <string.h>
#endif

#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "pktz.h"
#include    "router.h"
#include    "timer.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hmemcpy.h"
#include    "host.h"
#include    "security.h"
#include    "rerr.h"
#include    "ddepkts.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "api1632.h"
#include    "netddesh.h"

USES_ASSERT

#ifdef BYTE_SWAP
VOID     ConvertDdePkt( LPDDEPKT lpDdePkt );
#else
#define ConvertDdePkt(x)
#endif


/*
    External variables used
 */
#if DBG
extern BOOL     bDebugInfo;
#endif // DBG

extern  BOOL    bLogRetries;
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  DWORD   dflt_timeoutRcvConnCmd;
extern  DWORD   dflt_timeoutRcvConnRsp;
extern  DWORD   dflt_timeoutMemoryPause;
extern  DWORD   dflt_timeoutKeepAlive;
extern  DWORD   dflt_timeoutXmtStuck;
extern  DWORD   dflt_timeoutSendRsp;
extern  WORD    dflt_wMaxNoResponse;
extern  WORD    dflt_wMaxXmtErr;
extern  WORD    dflt_wMaxMemErr;


/*
    Local variables
 */
LPPKTZ  lpPktzHead      = NULL;
static  char    OurDialect[]    = "CORE1.0";


/*
    Local routines
 */
VOID    PktzClose( HPKTZ hPktz );
VOID    PktzGotPktOk( LPPKTZ lpPktz, PKTID pktid );
VOID    PktzFreeDdePkt( LPPKTZ lpPktz, LPDDEPKT lpDdePkt );
VOID    PktzFree( LPPKTZ lpPktz );
BOOL    PktzProcessControlInfo( LPPKTZ lpPktz, LPNETPKT lpPacket );
BOOL    PktzProcessPkt( LPPKTZ lpPktz, LPNETPKT lpPacket );
VOID    PktzTimerExpired( HPKTZ hPktz, DWORD dwTimerId, DWORD_PTR lpExtra );
BOOL    PktzConnectionComplete( HPKTZ hPktz, BOOL fOk );
VOID    PktzOkToXmit( HPKTZ hPktz );
BOOL    PktzRcvdPacket( HPKTZ hPktz );
VOID    PktzConnectionBroken( HPKTZ hPktz );
BOOL    PktzXmitErrorOnPkt( LPPKTZ lpPktz, PKTID pktIdToRexmit, BYTE pktStatus );
VOID    PktzLinkToXmitList( LPPKTZ lpPktz, LPNETHDR lpNetHdr );
BOOL    PktzNetHdrWithinAck( LPPKTZ lpPktz, LPNETHDR lpNetHdr, PKTID pktId );
LPNETHDR PktzGetFreePacket( LPPKTZ lpPktz );
VOID    FAR PASCAL DebugPktzState( void );



/*
    PktzNew()

        This function is called by CONNMGR when we get a new connection from
        a netintf (bClient is FALSE), and called by CONNMGR when we need to
        create a new physical connection (bClient is TRUE)
 */
HPKTZ
PktzNew(
    LPNIPTRS    lpNiPtrs,
    BOOL        bClient,
    LPSTR       lpszNodeName,
    LPSTR       lpszNodeInfo,
    CONNID      connId,
    BOOL        bDisconnect,
    int         nDelay )
{
    HPKTZ       hPktz;
    LPPKTZ      lpPktz;
    LPNETHDR    lpNetCur;
    LPNETHDR    lpNetPrev;
    int         i;
    BOOL        ok;

    hPktz = (HPKTZ) HeapAllocPtr( hHeap, GMEM_MOVEABLE, (DWORD)sizeof(PKTZ) );
    if( hPktz )  {
        ok = TRUE;
        lpPktz = (LPPKTZ) hPktz;
        lpPktz->pk_connId                   = connId;
        lpPktz->pk_fControlPktNeeded= FALSE;
        lpPktz->pk_pktidNextToSend      = (PKTID) 0;
        lpPktz->pk_pktidNextToBuild     = (PKTID) 1;
        lpPktz->pk_lastPktStatus        = 0;
        lpPktz->pk_lastPktRcvd          = (PKTID) 0;
        lpPktz->pk_lastPktOk            = (PKTID) 0;
        lpPktz->pk_lastPktOkOther       = (PKTID) 0;
        lpPktz->pk_pktidNextToRecv      = (PKTID) 1;
        lpPktz->pk_pktOffsInXmtMsg      = 0;
        lpPktz->pk_lpDdePktSave         = (LPDDEPKT) NULL;

        lstrcpyn( lpPktz->pk_szAliasName, lpszNodeName,
            sizeof(lpPktz->pk_szAliasName) );
        lpPktz->pk_szAliasName[ sizeof(lpPktz->pk_szAliasName)-1 ] = '\0';

        lstrcpyn( lpPktz->pk_szDestName, lpszNodeName,
            sizeof(lpPktz->pk_szDestName) );
        lpPktz->pk_szDestName[ sizeof(lpPktz->pk_szDestName)-1 ] = '\0';

        lpPktz->pk_lpNiPtrs             = lpNiPtrs;
        lpPktz->pk_sent                 = 0;
        lpPktz->pk_rcvd                 = 0;
        lpPktz->pk_hTimerKeepalive      = (HTIMER) NULL;
        lpPktz->pk_hTimerXmtStuck       = (HTIMER) NULL;
        lpPktz->pk_hTimerRcvNegCmd      = (HTIMER) NULL;
        lpPktz->pk_hTimerRcvNegRsp      = (HTIMER) NULL;
        lpPktz->pk_hTimerMemoryPause    = (HTIMER) NULL;
        lpPktz->pk_hTimerCloseConnection= (HTIMER) NULL;
        lpPktz->pk_pktUnackHead         = NULL;
        lpPktz->pk_pktUnackTail         = NULL;
        lpPktz->pk_controlPkt           = NULL;
        lpPktz->pk_rcvBuf               = NULL;
        lpPktz->pk_pktFreeHead          = NULL;
        lpPktz->pk_pktFreeTail          = NULL;
        lpPktz->pk_ddePktHead           = NULL;
        lpPktz->pk_ddePktTail           = NULL;
        lpPktz->pk_prevPktz             = NULL;
        lpPktz->pk_nextPktz             = NULL;
        lpPktz->pk_prevPktzForNetintf   = NULL;
        lpPktz->pk_nextPktzForNetintf   = NULL;
        lpPktz->pk_hRouterHead          = 0;
        lpPktz->pk_hRouterExtraHead     = 0;
        lpPktz->pk_timeoutRcvNegCmd     = dflt_timeoutRcvConnCmd;
        lpPktz->pk_timeoutRcvNegRsp     = dflt_timeoutRcvConnRsp;
        lpPktz->pk_timeoutMemoryPause   = dflt_timeoutMemoryPause;
        lpPktz->pk_timeoutKeepAlive     = dflt_timeoutKeepAlive;
        lpPktz->pk_timeoutXmtStuck      = dflt_timeoutXmtStuck;
        lpPktz->pk_timeoutSendRsp       = dflt_timeoutSendRsp;
        lpPktz->pk_wMaxNoResponse       = dflt_wMaxNoResponse;
        lpPktz->pk_wMaxXmtErr           = dflt_wMaxXmtErr;
        lpPktz->pk_wMaxMemErr           = dflt_wMaxMemErr;
        lpPktz->pk_fDisconnect          = bDisconnect;
        lpPktz->pk_nDelay               = nDelay;

        /* link into list of packetizers */
        if( lpPktzHead )  {
            lpPktzHead->pk_prevPktz = lpPktz;
        }
        lpPktz->pk_nextPktz     = lpPktzHead;
        lpPktzHead              = lpPktz;

        (*lpPktz->pk_lpNiPtrs->GetConnectionConfig) ( lpPktz->pk_connId,
            &lpPktz->pk_maxUnackPkts, &lpPktz->pk_pktSize,
            &lpPktz->pk_timeoutRcvNegCmd, &lpPktz->pk_timeoutRcvNegRsp,
            &lpPktz->pk_timeoutMemoryPause, &lpPktz->pk_timeoutKeepAlive,
            &lpPktz->pk_timeoutXmtStuck, &lpPktz->pk_timeoutSendRsp,
            &lpPktz->pk_wMaxNoResponse, &lpPktz->pk_wMaxXmtErr,
            &lpPktz->pk_wMaxMemErr );

        /* allocate packet buffer space for the max # of unack packets.
            This way, we know we won't run out of memory
         */
        lpNetPrev = NULL;
        ok = TRUE;
        for( i=0; ok && (i<(int)lpPktz->pk_maxUnackPkts); i++ )  {
            lpNetCur = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                (DWORD)(sizeof(NETHDR) + lpPktz->pk_pktSize) );
            if( lpNetCur )  {
                lpNetCur->nh_prev               = lpNetPrev;
                lpNetCur->nh_next               = (LPNETHDR) NULL;
                lpNetCur->nh_noRsp              = 0;
                lpNetCur->nh_xmtErr             = 0;
                lpNetCur->nh_memErr             = 0;
                lpNetCur->nh_timeSent           = 0;
                lpNetCur->nh_hTimerRspTO        = (HTIMER) NULL;

                /* link onto list of free packets */
                if( lpNetPrev )  {
                    lpNetPrev->nh_next          = lpNetCur;
                } else {
                    lpPktz->pk_pktFreeHead      = lpNetCur;
                }
                lpPktz->pk_pktFreeTail  = lpNetCur;
                lpNetPrev = lpNetCur;
            } else {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocate buffer for rcv packet */
            lpPktz->pk_rcvBuf = (LPVOID) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                (DWORD)(lpPktz->pk_pktSize) );
            if( lpPktz->pk_rcvBuf == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocate buffer for control packet */
            lpPktz->pk_controlPkt = (LPNETPKT) HeapAllocPtr( hHeap,
                GMEM_MOVEABLE, (DWORD)(sizeof(NETPKT)) );
            if( lpPktz->pk_controlPkt == NULL )  {
                ok = FALSE;
            }
        }
        if( ok )  {
            /* allocated all memory, ready to move on */
            if( bClient )  {
                /* wait for netintf connect() to succeed */
                lpPktz->pk_state                = PKTZ_WAIT_PHYSICAL_CONNECT;

                /* actually start the connect */
                lpPktz->pk_connId =
                    (*lpPktz->pk_lpNiPtrs->AddConnection) (
#ifdef _WINDOWS
                        lpszNodeInfo );
#else
                        lpszNodeInfo, hPktz );
#endif
                if( lpPktz->pk_connId == (CONNID) 0 )  {
                    /* not enough memory or resources for connection,
                        or in some cases, we immediately know if
                        connection failed */
                    ok = FALSE;
                }
            } else {
                /* server */

                /* wait for other side to send us the connect cmd */
                lpPktz->pk_state                = PKTZ_WAIT_NEG_CMD;

                /* set up timer for how long to wait for the connect
                    command from the other side */
                lpPktz->pk_hTimerRcvNegCmd = TimerSet(
                    lpPktz->pk_timeoutRcvNegCmd, PktzTimerExpired,
                    (DWORD_PTR)hPktz, TID_NO_RCV_CONN_CMD, (DWORD_PTR)NULL );
                if( lpPktz->pk_hTimerRcvNegCmd == (HTIMER) NULL )  {
                    /* no timers left */
                    ok = FALSE;
                }
            }
        }

        if( !ok )  {
            PktzFree( lpPktz );
            hPktz = 0;
        }
    }

    return( hPktz );
}



/*
    link onto the list of routers associated with this pktz
 */
VOID
PktzAssociateRouter(
    HPKTZ   hPktz,
    HROUTER hRouter,
    WORD    hRouterExtra )
{
    LPPKTZ      lpPktz;

    lpPktz = (LPPKTZ) hPktz;

    if( (lpPktz->pk_hRouterHead == 0) && lpPktz->pk_hTimerCloseConnection){
        TimerDelete( lpPktz->pk_hTimerCloseConnection );
        lpPktz->pk_hTimerCloseConnection = 0;
    }

    /* link router into head of list */
    if( lpPktz->pk_hRouterHead )  {
        RouterSetPrevForPktz(
            lpPktz->pk_hRouterHead, lpPktz->pk_hRouterExtraHead,
            hRouter, hRouterExtra );
    }
    RouterSetNextForPktz(
        hRouter, hRouterExtra,
        lpPktz->pk_hRouterHead, lpPktz->pk_hRouterExtraHead );
    lpPktz->pk_hRouterHead = hRouter;
    lpPktz->pk_hRouterExtraHead = hRouterExtra;

    switch( lpPktz->pk_state )  {
    case PKTZ_CONNECTED:
    case PKTZ_PAUSE_FOR_MEMORY:
        /* connected ... tell him already */
        RouterConnectionComplete( hRouter, hRouterExtra, (HPKTZ) lpPktz );
        break;
    }
}



/*
    unlink from the list of routers associated with this pktz
 */
VOID
PktzDisassociateRouter(
    HPKTZ   hPktz,
    HROUTER hRouter,
    WORD    hRouterExtra )
{
    LPPKTZ      lpPktz;
    HROUTER     hRouterPrev;
    WORD        hRouterExtraPrev;
    HROUTER     hRouterNext;
    WORD        hRouterExtraNext;

    lpPktz = (LPPKTZ) hPktz;
    RouterGetNextForPktz( hRouter, hRouterExtra,
        &hRouterNext, &hRouterExtraNext );

    RouterGetPrevForPktz( hRouter, hRouterExtra,
        &hRouterPrev, &hRouterExtraPrev );

    if( hRouterPrev )  {
        RouterSetNextForPktz( hRouterPrev, hRouterExtraPrev,
            hRouterNext, hRouterExtraNext );
    } else {
        lpPktz->pk_hRouterHead = hRouterNext;
        lpPktz->pk_hRouterExtraHead = hRouterExtraNext;
    }
    if( hRouterNext )  {
        RouterSetPrevForPktz( hRouterNext, hRouterExtraNext,
            hRouterPrev, hRouterExtraPrev );
    }
    if( lpPktz->pk_fDisconnect && (lpPktz->pk_hRouterHead == 0) )  {
        lpPktz->pk_hTimerCloseConnection = TimerSet(
            lpPktz->pk_nDelay * 1000L, PktzTimerExpired,
            (DWORD_PTR)lpPktz, TID_CLOSE_PKTZ, (DWORD_PTR)NULL );
        if( lpPktz->pk_hTimerCloseConnection == (HTIMER) NULL )  {
            /*  %1 will not auto-close ... not enough timers    */
            NDDELogError(MSG105, "Connection", NULL);
        }
    }
}



/*
    PktzOkToXmit

        Called when the netintf is ready to xmit another packet
 */
VOID
PktzOkToXmit( HPKTZ hPktz )
{
    LPPKTZ      lpPktz;
    LPNETHDR    lpSend;
    LPNETPKT    lpPacket;
    LPDDEPKT    lpDdePktFrom;
    LPDDEPKT    lpDdePktFromNext;
    LPDDEPKT    lpDdePktTo;
    BOOL        bControlPktOnly;
    BOOL        donePkt;
    BOOL        done;
    BOOL        found;
    DWORD       dwThis;
    DWORD       dwLeft;
    DWORD       msgSize;
    DWORD       dwStatus;
    int         nDone = 0;

    /* general init */
    lpPktz = (LPPKTZ) hPktz;
    lpSend = NULL;
    bControlPktOnly = FALSE;

    /* don't proceed if netintf isn't ready to xmit */
    dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
        ( lpPktz->pk_connId );
    if( !(dwStatus & NDDE_CONN_OK) || !(dwStatus & NDDE_READY_TO_XMT) )  {
        return;
    }

    /* if we got here, the netintf is ready to xmit ... delete xmt stuck
        timer
     */
    if( lpPktz->pk_hTimerXmtStuck )  {
        TimerDelete( lpPktz->pk_hTimerXmtStuck );
        lpPktz->pk_hTimerXmtStuck = 0;
    }

    /* check for odd states */
    if( lpPktz->pk_state == PKTZ_PAUSE_FOR_MEMORY )  {
        if( lpPktz->pk_fControlPktNeeded )  {
            bControlPktOnly = TRUE;
        } else {
            /* when waiting for memory problems to clear, don't send
                anything except control packets */
            return;
        }
    } else if( lpPktz->pk_state == PKTZ_CLOSE )  {
        return;
    }

    /* used to try to keep # lpPktz->pk_curOutstanding ...
        we now calculate this as idToSend - lastIdOtherSideSawOk - 1.
        Of course, this calculation is only OK if
        idToSend > lastIdOtherSideSawOk!
     */
    if( (lpPktz->pk_pktidNextToSend > lpPktz->pk_lastPktOkOther)
        && ((lpPktz->pk_pktidNextToSend - 1 - lpPktz->pk_lastPktOkOther)
                >= (DWORD)lpPktz->pk_maxUnackPkts) )  {
        /* nothing to do until other side gives us some info
            regarding the packets we have outstanding or we time out
            waiting for a response for them */
        if( lpPktz->pk_fControlPktNeeded )  {
            /*  However, we must send a control packet here or the possibility
                of deadlock exists */
            bControlPktOnly = TRUE;
        } else {
            return;
        }
    }

    if( !bControlPktOnly )  {
        /* find next pkt id to send */
        found = FALSE;
        done = FALSE;
        lpSend = lpPktz->pk_pktUnackTail;

        /* if the packet that we're supposed to send has already been seen
            OK by the other side, let's try to send the one after this.

            This check prevents a hole when the no-response timer expires,
            we set nextToSend to x, then we process a control packet saying
            that x was rcvd OK (this deletes x from unack list), then we get
            to the send state and if x isn't found ... we don't xmit!
         */
        if( lpPktz->pk_pktidNextToSend <= lpPktz->pk_lastPktOkOther )  {
            DIPRINTF(( "Adjusting next to send from %08lX to %08lX",
                    lpPktz->pk_pktidNextToSend, lpPktz->pk_lastPktOkOther+1 ));
            lpPktz->pk_pktidNextToSend = lpPktz->pk_lastPktOkOther+1;
        }
        while( lpSend && !done )  {
            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
            if( lpPacket->np_pktID == lpPktz->pk_pktidNextToSend )  {
                found = TRUE;
                done = TRUE;
            } else if( lpPacket->np_pktID < lpPktz->pk_pktidNextToSend )  {
                /* this packet in the list is before the one we should send,
                    therefore we know that the one we want is not in the list
                 */
                done = TRUE;
            } else {
                /* move on to the previous packet */
                lpSend = lpSend->nh_prev;
            }
        }

        if( !found )  {
            /* didn't find the packet on the xmit list */

            /* is there anything to send? */
            if( lpPktz->pk_ddePktHead == NULL )  {
                /* no DDE Packets to send ... any control packets needed? */
                if( lpPktz->pk_fControlPktNeeded )  {
                    bControlPktOnly = TRUE;
                    found = TRUE;
                } else {
                    /* nothing to send! */
                    return;
                }
            }
        }

        if( !found )  {
            /* double-check that the id we're looking for is 1 greater than
                the last one we sent */
            if( lpPktz->pk_pktUnackTail )  {
                lpPacket = (LPNETPKT)
                    ( ((LPSTR)lpPktz->pk_pktUnackTail) + sizeof(NETHDR) );
                assert( lpPktz->pk_pktidNextToSend == (lpPacket->np_pktID+1) );
                assert( lpPktz->pk_pktidNextToSend == lpPktz->pk_pktidNextToBuild );
            }

            /* get a nethdr packet from free list */
            lpSend = PktzGetFreePacket( lpPktz );
            assert( lpSend );   /* we checked max outstanding */

            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
            lpDdePktTo = (LPDDEPKT) ( ((LPSTR)lpPacket) + sizeof(NETPKT) );

            /* check if we were in the middle of a DDE packet */
            if( lpPktz->pk_pktOffsInXmtMsg != 0L ) {
                /* we were in the middle of a DDE Packet */
                lpDdePktFrom = lpPktz->pk_ddePktHead;
                if( (lpDdePktFrom->dp_size - lpPktz->pk_pktOffsInXmtMsg)
                    > (lpPktz->pk_pktSize-sizeof(NETPKT)) )  {
                    dwThis = lpPktz->pk_pktSize - sizeof(NETPKT);
                    donePkt = FALSE;
                } else {
                    dwThis =
                        (lpDdePktFrom->dp_size - lpPktz->pk_pktOffsInXmtMsg);
                    donePkt = TRUE;
                }

                /* copy this portion of data in */
                hmemcpy( (LPSTR)lpDdePktTo,
                    ( ((LPHSTR)lpDdePktFrom) + lpPktz->pk_pktOffsInXmtMsg ),
                    dwThis );
                lpPacket->np_pktSize            = (WORD) dwThis;
                lpPacket->np_pktOffsInMsg       = lpPktz->pk_pktOffsInXmtMsg;
                lpPacket->np_msgSize            = lpDdePktFrom->dp_size;
                lpPacket->np_type               = NPKT_ROUTER;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpSend );

                /* get rid of DDE packet if done */
                if( donePkt )  {
                    PktzFreeDdePkt( lpPktz, lpDdePktFrom );
                    lpPktz->pk_pktOffsInXmtMsg = 0L;
                } else {
                    lpPktz->pk_pktOffsInXmtMsg += dwThis;
                }
            } else {
                /* not in middle of packet ... lets do a new one */
                done = FALSE;
                nDone = 0;
                dwLeft = lpPktz->pk_pktSize - sizeof(NETPKT);
                dwThis = 0;
                msgSize = 0L;
                lpDdePktFrom = lpPktz->pk_ddePktHead;
                while( !done && lpDdePktFrom )  {
                    if( lpDdePktFrom->dp_size <= (DWORD)dwLeft )  {
                        /* fits completely in network packet */

                        /* copy it in */
                        hmemcpy( (LPSTR)lpDdePktTo, (LPSTR)lpDdePktFrom,
                            lpDdePktFrom->dp_size );

                        /* byte-ordering problems if any */
                        ConvertDdePkt( lpDdePktTo );

                        /* adjust number in packet and number left */
                        dwThis   += lpDdePktFrom->dp_size;
                        msgSize += lpDdePktFrom->dp_size;
                        dwLeft   -= lpDdePktFrom->dp_size;

                        /* advance lpDdePktTo pointer past this info */
                        lpDdePktTo = (LPDDEPKT) ( ((LPHSTR)lpDdePktTo) +
                            lpDdePktFrom->dp_size );

                        /* free DDE Packet and move on to next DDE pkt */
                        lpDdePktFromNext = lpDdePktFrom->dp_next;
                        PktzFreeDdePkt( lpPktz, lpDdePktFrom );
                        lpDdePktFrom = lpDdePktFromNext;

                        /* mark that we did another DDE packet */
                        nDone++;
                    } else {
                        /* doesn't fit cleanly into packet */
                        if( nDone == 0 )  {
                            /* needs to be split across many pkts */
                            msgSize = lpDdePktFrom->dp_size;
                            dwThis = lpPktz->pk_pktSize - sizeof(NETPKT);

                            /* copy first bit of DDE packet into net pkt */
                            hmemcpy( (LPSTR)lpDdePktTo, (LPSTR)lpDdePktFrom,
                                dwThis );

                            /* byte-ordering problems if any */
                            ConvertDdePkt( lpDdePktTo );

                            lpPktz->pk_pktOffsInXmtMsg += dwThis;
                            done = TRUE;
                        } else {
                            /* we've done some ... this is enough for now */
                            done = TRUE;
                        }
                    }
                }

                /* packet is built */
                lpPacket->np_pktSize            = (WORD) dwThis;
                lpPacket->np_pktOffsInMsg       = 0;
                lpPacket->np_msgSize            = msgSize;
                lpPacket->np_type               = NPKT_ROUTER;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpSend );
            }
        }
    }

    /* by this time, we've checked all the odd cases, and lpSend points to
        a packet that is either a control packet or a packet on the unack
        list that needs to be transmitted.  All we need to do is xmit it. */
    if( lpSend || bControlPktOnly )  {
        if( bControlPktOnly )  {
            lpPacket = (LPNETPKT) lpPktz->pk_controlPkt;
            lpPacket->np_pktID          = 0;
            lpPacket->np_type           = NPKT_CONTROL;
            lpPacket->np_pktSize        = 0;
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = 0;
        } else {
            lpPacket = (LPNETPKT) ( ((LPSTR)lpSend) + sizeof(NETHDR) );
        }
        lpPacket->np_magicNum           = NDDESignature;
        lpPacket->np_lastPktOK          = lpPktz->pk_lastPktOk;
        lpPacket->np_lastPktRcvd        = lpPktz->pk_lastPktRcvd;
        lpPacket->np_lastPktStatus      = lpPktz->pk_lastPktStatus;

        lpPktz->pk_sent++;

        DIPRINTF(( "PKTZ Transmitting %08lX ...", lpPacket->np_pktID ));

        /* actually transmit the packet */
        (*lpPktz->pk_lpNiPtrs->XmtPacket) ( lpPktz->pk_connId, lpPacket,
            (WORD) (lpPacket->np_pktSize + sizeof(NETPKT)) );

        /* reset needing a control packet */
        lpPktz->pk_fControlPktNeeded = FALSE;

        /* start a timer for xmt stuck */
        if( lpPktz->pk_timeoutXmtStuck )  {
            assert( lpPktz->pk_hTimerXmtStuck == 0 );
            lpPktz->pk_hTimerXmtStuck = TimerSet( lpPktz->pk_timeoutXmtStuck,
                PktzTimerExpired, (DWORD_PTR)lpPktz, TID_XMT_STUCK, (DWORD)0 );
        }

        /* kill the keepalive timer and restart it */
        if( lpPktz->pk_hTimerKeepalive )  {
            TimerDelete( lpPktz->pk_hTimerKeepalive );
            lpPktz->pk_hTimerKeepalive = 0;
        }
        if( lpPktz->pk_timeoutKeepAlive )  {
            lpPktz->pk_hTimerKeepalive = TimerSet(
                lpPktz->pk_timeoutKeepAlive, PktzTimerExpired,
                (DWORD_PTR)lpPktz, TID_KEEPALIVE, (DWORD)0 );
        }

        if( lpPacket->np_type != NPKT_CONTROL )  {
            /* bump pkt id that we should send */
            lpPktz->pk_pktidNextToSend++;

            /* if not a control packet, start a send response timeout */
            assert( lpSend->nh_hTimerRspTO == 0 );
            lpSend->nh_hTimerRspTO = TimerSet( lpPktz->pk_timeoutSendRsp,
                PktzTimerExpired, (DWORD_PTR)lpPktz, TID_NO_RESPONSE,
                (DWORD_PTR)lpSend );
        }
    }
}



/*
    PktzRcvdPacket()

        Called when we know there is a packet available from the netintf
        If this returns FALSE, the hPktz may no longer be valid!
 */
BOOL
PktzRcvdPacket( HPKTZ hPktz )
{
    DWORD       wProcessed;     /* how many bytes of pkt processed */
    LPNETPKT    lpPacket;
    LPDDEPKT    lpDdePktFrom;
    DDEPKT      ddePktAligned;
    NETPKT      netPktAligned;
    LPDDEPKT    lpDdePktNew;
    LPDDEPKT    lpDdePktNext;
    LPDDEPKT    lpDdePktHead;
    LPDDEPKT    lpDdePktLast;
    LPPKTZ      lpPktz = (LPPKTZ) hPktz;
    WORD        len;
    WORD        status;
    BOOL        ok;
    BOOL        done;
    BOOL        fPartial;

    /* get the packet from the network interface */
    ok = (*lpPktz->pk_lpNiPtrs->RcvPacket)
        ( lpPktz->pk_connId, lpPktz->pk_rcvBuf, &len, &status );
    if( !ok )  {
        return( FALSE );
    }

    lpPktz->pk_rcvd++;

    /* set lpPacket to point to what we just rcvd */
    lpPacket = (LPNETPKT)lpPktz->pk_rcvBuf;

    DIPRINTF(( "PKTZ: Rcvd Packet %08lX", lpPacket->np_pktID ));

    /* process control information */
    ok = PktzProcessControlInfo( lpPktz, lpPacket );
    /* hPktz may be invalid after this call */
    if( !ok )  {
        return( FALSE );
    }

    /* is this the packet we were expecting to see? */
    if( lpPacket->np_pktID != lpPktz->pk_pktidNextToRecv )  {
        /* ignore the contents of the message */
        if( lpPacket->np_pktID != 0L )  {
            if (bLogRetries) {
                /*  Packet out of sequence from "%1"
                    Received: %2, Expecting %3, Status: %4  */
                NDDELogWarning(MSG106, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpPacket->np_pktID),
                    LogString("0x%0X", lpPktz->pk_pktidNextToRecv),
                    LogString("0x%0X", (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
                                            (lpPktz->pk_connId)), NULL);
            }
            /* mark that we must send info back to the other side */
            lpPktz->pk_fControlPktNeeded = TRUE;

            if( lpPacket->np_pktID > lpPktz->pk_pktidNextToRecv )  {
                /* received a packet beyond the one that we expected ...
                    ask the other side to retransmit this one */
                lpPktz->pk_lastPktStatus = PS_DATA_ERR;
                lpPktz->pk_lastPktRcvd = lpPktz->pk_pktidNextToRecv;
            }
        }
    } else {
        /* was the packet that we were expecting */
        if( status & NDDE_PKT_DATA_ERR )  {
            lpPktz->pk_lastPktStatus = PS_DATA_ERR;
            lpPktz->pk_lastPktRcvd = lpPacket->np_pktID;

            /* mark that we must send info back to the other side */
            lpPktz->pk_fControlPktNeeded = TRUE;
        } else {
            assert( status & NDDE_PKT_HDR_OK );
            assert( status & NDDE_PKT_DATA_OK );
            if( lpPacket->np_type == NPKT_PKTZ )  {
                if( !PktzProcessPkt( lpPktz, lpPacket ) )  {
                    /**** NOTE: lpPktz could be invalid after this call ****/
                    return( FALSE );
                }
            } else {
                lpDdePktFrom = (LPDDEPKT)(((LPSTR)lpPacket) + sizeof(NETPKT));
                /* make sure we're aligned */
                hmemcpy( (LPVOID)&netPktAligned, (LPVOID)lpPacket,
                    sizeof(netPktAligned) );
                if( netPktAligned.np_pktOffsInMsg == 0 )  {
                    /* first packet of msg */

                    lpDdePktHead = NULL;
                    lpDdePktLast = NULL;
                    ok = TRUE;
                    done = FALSE;
                    fPartial = FALSE;
                    wProcessed = 0;
                    do {
                        /* make sure we're aligned */
                        hmemcpy( (LPVOID)&ddePktAligned,
                            (LPVOID)lpDdePktFrom, sizeof(ddePktAligned) );

                        /* byte-ordering problems if any */
                        ConvertDdePkt( lpDdePktFrom );

                        lpDdePktNew = HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                            ddePktAligned.dp_size );
                        if( lpDdePktNew )  {
                            /* copy in at least first portion of packet */
                            hmemcpy( lpDdePktNew, lpDdePktFrom,
                                min(ddePktAligned.dp_size,
                                    (DWORD)netPktAligned.np_pktSize) );

                            if( ddePktAligned.dp_size >
                                    (DWORD)netPktAligned.np_pktSize){
                                /* partial DDE packet in */
                                fPartial = TRUE;

                                /* remember where we should start */
                                lpPktz->pk_lpDdePktSave = lpDdePktNew;
                                done = TRUE;
                            } else {
                                /* full packet */
                                wProcessed += lpDdePktNew->dp_size;

                                /* link onto end of temporary list */
                                lpDdePktNew->dp_next = NULL;
                                lpDdePktNew->dp_prev = lpDdePktLast;
                                if( lpDdePktLast )  {
                                    lpDdePktLast->dp_next = lpDdePktNew;
                                } else {
                                    lpDdePktHead = lpDdePktNew;
                                }
                                lpDdePktLast = lpDdePktNew;
                            }
                        } else {
                            ok = FALSE; /* memory error */
                        }
                        if( ok && !done )  {
                            if( (int)wProcessed >= netPktAligned.np_pktSize )  {
                                done = TRUE;
                            } else {
                                /* move onto the next DDE packet in msg */
                                lpDdePktFrom = (LPDDEPKT)
                                    ( ((LPHSTR)lpDdePktFrom)
                                        + lpDdePktNew->dp_size );
                            }
                        }
                    } while( ok && !done );
                    if( !ok )  {
                        /* memory error */
                        lpPktz->pk_lastPktRcvd = netPktAligned.np_pktID;
                        lpPktz->pk_lastPktStatus = PS_MEMORY_ERR;

                        /* mark that we must send info back to the other side
                         */
                        lpPktz->pk_fControlPktNeeded = TRUE;
                    } else {
                        /* got memory for all DDE packets */

                        /* mark that we got this pkt OK */
                        PktzGotPktOk( lpPktz, netPktAligned.np_pktID );

                        /* don't distribute if partial packet */
                        if( !fPartial )  {
                            /* distribute each packet */
                            lpDdePktNew = lpDdePktHead;
                            while( lpDdePktNew )  {
                                /* save dp_next, since distributing it could
                                    change dp_next */
                                lpDdePktNext = lpDdePktNew->dp_next;

                                /* distribute this packet */
                                RouterPacketFromNet( (HPKTZ)lpPktz,
                                    lpDdePktNew );

                                /* move on to next */
                                lpDdePktNew = lpDdePktNext;
                            }
                        }
                    }
                } else {
                    /* second or later packet of msg */
                    hmemcpy( (LPHSTR)lpPktz->pk_lpDdePktSave
                        + netPktAligned.np_pktOffsInMsg,
                        lpDdePktFrom,
                        netPktAligned.np_pktSize );

                    /* mark that we got this packet OK */
                    PktzGotPktOk( lpPktz, netPktAligned.np_pktID );

                    if( (netPktAligned.np_pktOffsInMsg +
                            netPktAligned.np_pktSize)
                                == netPktAligned.np_msgSize )  {
                        /* done with message */
                        /* distribute this packet */
                        RouterPacketFromNet( (HPKTZ)lpPktz,
                            lpPktz->pk_lpDdePktSave );
                    }
                }
            }
        }
    }
    /**** NOTE: lpPktz could be invalid after this call ****/
    return ok;
}



/*
    PktzConnectionComplete()

        Called when the netintf has completed the connection one way or
        another
 */
BOOL
PktzConnectionComplete(
    HPKTZ   hPktz,
    BOOL    fOk )
{
    LPPKTZ      lpPktz;
    LPNEGCMD    lpNegCmd;
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    WORD        cmdSize;
    WORD        wProtocolBytes;
    LPSTR       lpszNextString;
    WORD        offsNextString;
    BOOL        ok = TRUE;

    lpPktz = (LPPKTZ) hPktz;

    if( fOk )  {
        /* connection was fine */

        /* note that we're waiting for the connect rsp */
        lpPktz->pk_state = PKTZ_WAIT_NEG_RSP;

        lpNetHdr = PktzGetFreePacket( lpPktz );
        if( lpNetHdr == NULL )  {
            /* should be first message we sent! */
            assert( FALSE );
        } else {
            /* build packet for response */
            lpNegCmd = (LPNEGCMD)
                (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
            lpNegCmd->nc_type                   =
                PcToHostWord( PKTZ_NEG_CMD );
            lpNegCmd->nc_pktSize                =
                PcToHostWord( lpPktz->pk_pktSize );
            lpNegCmd->nc_maxUnackPkts           =
                PcToHostWord( lpPktz->pk_maxUnackPkts );
            lpszNextString = (LPSTR) lpNegCmd->nc_strings;
            offsNextString = 0;

            /* copy in source node name */
            lstrcpyn( lpszNextString, ourNodeName, 20 );
            lpNegCmd->nc_offsSrcNodeName = offsNextString;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* copy in dest node name */
            lstrcpyn( lpszNextString, lpPktz->pk_szDestName, MAX_NODE_NAME+1 );
            lpNegCmd->nc_offsDstNodeName = offsNextString;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* copy in the protocol dialects that we are interested in */
            wProtocolBytes = 0;
            lpNegCmd->nc_offsProtocols = offsNextString;

            /* copy these 4 lines for each new protocol dialect added */
            lstrcpyn( lpszNextString, OurDialect, 8 );
            wProtocolBytes += lstrlen(lpszNextString) + 1;
            offsNextString += lstrlen(lpszNextString) + 1;
            lpszNextString += lstrlen(lpszNextString) + 1;

            /* packet is filled in, just need to remember the size
                and do appropriate byte-swaps
             */
            cmdSize = (WORD) (sizeof(NEGCMD) + offsNextString - 1);

            lpNegCmd->nc_offsSrcNodeName =
                PcToHostWord( lpNegCmd->nc_offsSrcNodeName );
            lpNegCmd->nc_offsDstNodeName =
                PcToHostWord( lpNegCmd->nc_offsDstNodeName );
            lpNegCmd->nc_offsProtocols =
                PcToHostWord( lpNegCmd->nc_offsProtocols );
            lpNegCmd->nc_protocolBytes =
                PcToHostWord( wProtocolBytes );

            assert( lpPktz->pk_pktidNextToBuild == 1 );
            lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
            lpPacket->np_pktSize        = cmdSize;
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = lpPacket->np_pktSize;
            lpPacket->np_type           = NPKT_PKTZ;
            lpPacket->np_pktID          = lpPktz->pk_pktidNextToBuild;

            /* bump id of next pkt to build */
            lpPktz->pk_pktidNextToBuild++;

            /* link into list to send */
            PktzLinkToXmitList( lpPktz, lpNetHdr );
        }
    } else {
        /* connection failed */

        lpPktz->pk_state = PKTZ_CLOSE;

        /* tell all routers of failure */
        RouterConnectionComplete( lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead, (HPKTZ) NULL );

        /* disconnect the connection ... this tells netintf that we're
            through with this connId, etc. */
        (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

        /* free us ... we're no longer needed */
        PktzFree( lpPktz );
        ok = FALSE;
    }

    return( ok );
}



/*
    PktzFree()

        Called when we are completely done with a pktz
 */
VOID
PktzFree( LPPKTZ lpPktz )
{
    LPPKTZ      lpPktzPrev;
    LPPKTZ      lpPktzNext;

    LPNETHDR    lpNetCur;
    LPNETHDR    lpNetPrev;

    LPDDEPKT    lpDdeCur;
    LPDDEPKT    lpDdePrev;

    DIPRINTF(( "PktzFree( %08lX )", lpPktz ));

    /* delete any timers */
    TimerDelete( lpPktz->pk_hTimerKeepalive );
    lpPktz->pk_hTimerKeepalive = 0;
    TimerDelete( lpPktz->pk_hTimerXmtStuck );
    lpPktz->pk_hTimerXmtStuck = 0;
    TimerDelete( lpPktz->pk_hTimerRcvNegCmd );
    lpPktz->pk_hTimerRcvNegCmd = 0;
    TimerDelete( lpPktz->pk_hTimerRcvNegRsp );
    lpPktz->pk_hTimerRcvNegRsp = 0;
    TimerDelete( lpPktz->pk_hTimerMemoryPause );
    lpPktz->pk_hTimerMemoryPause = 0;
    TimerDelete( lpPktz->pk_hTimerCloseConnection );
    lpPktz->pk_hTimerCloseConnection = 0;

    /* free unack packet buffers */
    lpNetCur = lpPktz->pk_pktFreeTail;
    while( lpNetCur )  {
        lpNetPrev = lpNetCur->nh_prev;
        HeapFreePtr( lpNetCur );
        lpNetCur = lpNetPrev;
    }

    /* free rcv buffer */
    if( lpPktz->pk_rcvBuf )  {
        HeapFreePtr( lpPktz->pk_rcvBuf );
        lpPktz->pk_rcvBuf = NULL;
    }

    /* free Net Control Packet */
    if (lpPktz->pk_controlPkt) {
        HeapFreePtr(lpPktz->pk_controlPkt);
    }

    /* free outstanding unack packet buffers */
    lpNetCur = lpPktz->pk_pktUnackTail;
    while( lpNetCur )  {
        TimerDelete( lpNetCur->nh_hTimerRspTO );
        lpNetCur->nh_hTimerRspTO = 0;
        lpNetPrev = lpNetCur->nh_prev;
        HeapFreePtr( lpNetCur );
        lpNetCur = lpNetPrev;
    }

    /* free remaining DDE packets */
    lpDdeCur = lpPktz->pk_ddePktTail;
    while( lpDdeCur )  {
        lpDdePrev = lpDdeCur->dp_prev;
        HeapFreePtr( lpDdeCur );
        lpDdeCur = lpDdePrev;
    }

    /* unlink from list of packetizers */
    lpPktzPrev = lpPktz->pk_prevPktz;
    lpPktzNext = lpPktz->pk_nextPktz;
    if( lpPktzPrev )  {
        lpPktzPrev->pk_nextPktz = lpPktzNext;
    } else {
        lpPktzHead = lpPktzNext;
    }
    if( lpPktzNext )  {
        lpPktzNext->pk_prevPktz = lpPktzPrev;
    }

    /* free pktz */
    HeapFreePtr( lpPktz );
}



VOID
PktzTimerExpired(
    HPKTZ   hPktz,
    DWORD   dwTimerId,
    DWORD_PTR lpExtra )
{
    LPPKTZ      lpPktz;
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    LPPKTZCMD   lpPktzCmd;

    DIPRINTF(( "PktzTimerExpired( %08lX, %08lX, %08lX )",
            hPktz, dwTimerId, lpExtra ));

    lpPktz = (LPPKTZ) hPktz;
    switch( (int)dwTimerId )  {

    case TID_KEEPALIVE:
        DIPRINTF(( " KEEPALIVE Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerKeepalive = (HTIMER) NULL;

        /* mark that at least we should send a control packet just to keep the
           other guy around
         */
        lpPktz->pk_fControlPktNeeded = TRUE;

        /* no packets outstanding and no packets waiting to be built ...
            try to build one just to keep connection alive
         */
        if( (lpPktz->pk_pktUnackHead == NULL)
            && (lpPktz->pk_ddePktHead == NULL) )  {
            lpNetHdr = PktzGetFreePacket( lpPktz );
            if( lpNetHdr )  {
                /* build packet for keepalive */
                lpPktzCmd = (LPPKTZCMD)
                    (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
                lpPktzCmd->pc_type              = PKTZ_KEEPALIVE;

                lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
                lpPacket->np_pktSize            = sizeof(PKTZCMD);
                lpPacket->np_pktOffsInMsg       = 0;
                lpPacket->np_msgSize            = lpPacket->np_pktSize;
                lpPacket->np_type               = NPKT_PKTZ;
                lpPacket->np_pktID              = lpPktz->pk_pktidNextToBuild;

                /* bump id of next pkt to build */
                lpPktz->pk_pktidNextToBuild++;

                /* link into list to send */
                PktzLinkToXmitList( lpPktz, lpNetHdr );
            }
        }
        break;

    case TID_XMT_STUCK:
        DIPRINTF(( " XMT_STUCK Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerXmtStuck = (HTIMER) NULL;

        /* the other side must be dead if we can't transmit for this long */
        /* Transmit timeout (%2 secs) to "%1" ... closing connection    */
        NDDELogError(MSG107, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutXmtStuck/1000L), NULL );

        /* close this packetizer */
        PktzClose( (HPKTZ) lpPktz );
        break;

    case TID_CLOSE_PKTZ:
        /* note that timer went off */
         DIPRINTF(( "TID_CLOSE_PKTZ ... closing pktz %lx", lpPktz ));
        lpPktz->pk_hTimerCloseConnection = (HTIMER) NULL;

        /* close the connection */
        PktzClose( hPktz );
        break;

    case TID_NO_RCV_CONN_CMD:
        DIPRINTF(( " NO_RCV_CONN_CMD Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerRcvNegCmd = (HTIMER) NULL;

        /*  No connect command for (%2 secs) from "%1"
            ... closing connection   */
        NDDELogError(MSG108, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutRcvNegCmd/1000L), NULL);

        /* close this packetizer */
        PktzClose( hPktz );
        break;

    case TID_NO_RCV_CONN_RSP:
        DIPRINTF(( " NO_RCV_CONN_RSP Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerRcvNegRsp = (HTIMER) NULL;

        /*  No connect command response for (%2 secs) from "%1"
            ... closing connection  */
        NDDELogError(MSG109, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutRcvNegRsp/1000L), NULL);

        /* close this packetizer */
        PktzClose( hPktz );
        break;

    case TID_MEMORY_PAUSE:

        DIPRINTF(( " MEMORY_PAUSE Timer" ));
        /* note that the timer went off */
        lpPktz->pk_hTimerMemoryPause = (HTIMER) NULL;

        /*  Pausing (%2 secs) for remote side to get memory ... retrying    */
        NDDELogInfo(MSG110, lpPktz->pk_szDestName,
            LogString("%d", lpPktz->pk_timeoutMemoryPause/1000L), NULL);

        assert( lpPktz->pk_state == PKTZ_PAUSE_FOR_MEMORY );

        /* just set state to connected and try again */
        lpPktz->pk_state = PKTZ_CONNECTED;
        break;

    case TID_NO_RESPONSE:
        DIPRINTF(( " No Response Timer" ));
        lpNetHdr = (LPNETHDR) lpExtra;
        /* note that the timer went off */
        lpNetHdr->nh_hTimerRspTO = 0;

        lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
        if (bLogRetries) {
            /*  No response %2/%3 from remote side "%1" for pktid %4    */
            NDDELogWarning(MSG111, lpPktz->pk_szDestName,
                LogString("%d", lpNetHdr->nh_noRsp),
                LogString("%d", lpPktz->pk_wMaxNoResponse),
                LogString("%d", lpPacket->np_pktID), NULL);
        }
        lpNetHdr->nh_noRsp++;
        if( lpNetHdr->nh_noRsp > lpPktz->pk_wMaxNoResponse )  {
            /*  Too many no response retries (%2) for same packet from "%1"
                ... closing connection  */
            NDDELogError(MSG112, lpPktz->pk_szDestName,
                LogString("%d", lpNetHdr->nh_noRsp), NULL);
            PktzClose( hPktz );
        } else {
            lpPktz->pk_pktidNextToSend = lpPacket->np_pktID;
            lpNetHdr = lpNetHdr->nh_next;
            while( lpNetHdr )  {
                /* this packet was sent after the one that needs
                    to be retransmitted.  We should pretend we never
                    sent this packet. */
            if (lpNetHdr->nh_hTimerRspTO) {
                TimerDelete( lpNetHdr->nh_hTimerRspTO );
                lpNetHdr->nh_hTimerRspTO = 0;
            }
                lpNetHdr = lpNetHdr->nh_next;
            }
        }
        break;
    default:
        InternalError( "Unexpected pktz timer id: %08lX", dwTimerId );
    }
}



/*
    PktzSlice()

        Must be called frequently to assure timely response
 */
VOID
PktzSlice( void )
{
    LPPKTZ      lpPktz;
    LPPKTZ      lpPktzNext;
    DWORD       dwStatus;
    BOOL        ok;

    lpPktz = lpPktzHead;
    while( lpPktz )  {
        /* save this in case pktz gets deleted inside */
        lpPktzNext = lpPktz->pk_nextPktz;
        ok = TRUE;

        /* get current state of netintf */
        dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
            ( lpPktz->pk_connId );

        switch( lpPktz->pk_state )  {
        case PKTZ_WAIT_PHYSICAL_CONNECT:
            /* check to see if we're done */
            if( dwStatus & NDDE_CONN_CONNECTING )  {
                /* continue to wait */
            } else if( dwStatus & NDDE_CONN_OK )  {
                ok = PktzConnectionComplete( (HPKTZ)lpPktz, TRUE );
                if( ok )  {
                    /* try to xmit starting pkt, if appropriate */
                    PktzOkToXmit( (HPKTZ)lpPktz );
                }
            } else {
                PktzConnectionComplete( (HPKTZ)lpPktz, FALSE );
            }
            break;
        case PKTZ_CONNECTED:
        case PKTZ_WAIT_NEG_CMD:
        case PKTZ_WAIT_NEG_RSP:
            /* check to see if we're done */
            if( (dwStatus & NDDE_CONN_STATUS_MASK) == 0 )  {
                PktzConnectionBroken( (HPKTZ)lpPktz );
            } else {
                if( (dwStatus & NDDE_CONN_OK)
                        && (dwStatus & NDDE_CALL_RCV_PKT) ) {
                    ok = PktzRcvdPacket( (HPKTZ)lpPktz );
                    /* lpPktz may be invalid after this call */
                }
                if( ok && (dwStatus & NDDE_CONN_OK)
                        && (dwStatus & NDDE_READY_TO_XMT) )  {
                    PktzOkToXmit( (HPKTZ)lpPktz );
                }
            }
            break;
        case PKTZ_PAUSE_FOR_MEMORY:
            if( (dwStatus & NDDE_CONN_STATUS_MASK) == 0 )  {
                PktzConnectionBroken( (HPKTZ)lpPktz );
            }
            break;
        case PKTZ_CLOSE:
            break;
        default:
            InternalError( "PKTZ %08lX in unknown state: %ld",
                (HPKTZ)lpPktz, (DWORD)lpPktz->pk_state );
            break;
        }
        lpPktz = lpPktzNext;
    }
}



/*
    PktzProcessControlInfo()

        Called for each packet that we receive ... this is where we process
        all the "control" information in the rcvd packet, such as which packet
        the other side has received OK thru, etc.

        NOTE: lpPktz may be invalid after this call if it returns FALSE

 */
BOOL
PktzProcessControlInfo(
    LPPKTZ      lpPktz,
    LPNETPKT    lpPacket )
{
    LPNETHDR    lpNetHdr;
    LPNETHDR    lpNetHdrNext;
    LPNETHDR    lpNetHdrPrev;
    BOOL        ok = TRUE;

    /* if we got an acknowledgment and we have some outstanding packets... */
    if( lpPacket->np_lastPktOK != 0 )  {
        /* this represenets an acknowledgment from the other side of packets
           that we have transmitted.
         */
        lpNetHdr = lpPktz->pk_pktUnackHead;
        while( lpNetHdr &&
            PktzNetHdrWithinAck( lpPktz, lpNetHdr, lpPacket->np_lastPktOK )) {

            /* this unack packet was ACKed by this message */

            /* kill the send response timer for this packet */
            TimerDelete( lpNetHdr->nh_hTimerRspTO );
            lpNetHdr->nh_hTimerRspTO = 0;

            /* free the packet, by moving it from the unack list to
                the pkt available list */
            lpNetHdrPrev = lpNetHdr->nh_prev;
            lpNetHdrNext = lpNetHdr->nh_next;

            /* unlink from pktUnack list */
            assert( lpNetHdrPrev == NULL );     /* should be unlinking head */
            if( lpNetHdrNext )  {
                lpNetHdrNext->nh_prev = NULL;
            } else {
                lpPktz->pk_pktUnackTail = NULL;
            }
            lpPktz->pk_pktUnackHead = lpNetHdrNext;

            /* link into head of pktFree list */
            lpNetHdr->nh_prev = NULL;
            lpNetHdr->nh_next = lpPktz->pk_pktFreeHead;
            if( lpPktz->pk_pktFreeHead )  {
                lpPktz->pk_pktFreeHead->nh_prev = lpNetHdr;
            } else {
                lpPktz->pk_pktFreeTail = lpNetHdr;
            }
            lpPktz->pk_pktFreeHead = lpNetHdr;

            /* go on to the next packet */
            lpNetHdr = lpNetHdrNext;
        }
    }

    /* note that the other side has rcvd OK through this */
    lpPktz->pk_lastPktOkOther = lpPacket->np_lastPktOK;

    if( lpPacket->np_lastPktOK != lpPacket->np_lastPktRcvd )  {
        /* a packet that we transmitted had an error in it */
        ok = PktzXmitErrorOnPkt( lpPktz, lpPacket->np_lastPktRcvd,
            lpPacket->np_lastPktStatus );
        /* lpPktz may be invalid after this call */
    }

    /* lpPktz may be invalid after this call */
    return( ok );
}



/*
    PktzProcessPkt()

        This is called for pktz-pktz packets only which for now is either
        PKTZ_NEG_CMD or PKTZ_NEG_RSP or PKTZ_KEEPALIVE
 */
BOOL
PktzProcessPkt(
    LPPKTZ      lpPktz,
    LPNETPKT    lpPacket )
{
    LPNEGRSP    lpNegRsp;
    LPNEGCMD    lpNegCmd;
    LPPKTZCMD   lpPktzCmd;
    LPSTR       lpProtocol;
    WORD        oldPkState;
    LPNETHDR    lpNetHdr;
    WORD        wErrorClass;
    WORD        wErrorNum;
    char        szNetintf[ MAX_NI_NAME+1 ];
    char        szConnInfo[ MAX_CONN_INFO+1 ];
    int         i = 0;
    WORD        wProtocol;
    WORD        wBytesConsumed;
    BOOL        ok = TRUE;

#define GetLPSZNegCmdString(lpNegCmd,offs)      \
    (LPSTR)(((lpNegCmd)->nc_strings)+offs)

    /* set up pointer to data portion of packet */
    lpPktzCmd = (LPPKTZCMD) (((LPSTR)lpPacket) + sizeof(NETPKT));

    /* convert byte-ordering */
    lpPktzCmd->pc_type = PcToHostWord( lpPktzCmd->pc_type );

    /* mark that we got this pkt OK */
    PktzGotPktOk( lpPktz, lpPacket->np_pktID );

    if( lpPktzCmd->pc_type == PKTZ_KEEPALIVE )  {
        /* ignore keepalive packets */
    } else if( lpPktzCmd->pc_type == PKTZ_NEG_CMD )  {
        lpNegCmd = (LPNEGCMD) lpPktzCmd;
        lpNegCmd->nc_pktSize =
            PcToHostWord( lpNegCmd->nc_pktSize );
        lpNegCmd->nc_maxUnackPkts =
            PcToHostWord( lpNegCmd->nc_maxUnackPkts );
        lpNegCmd->nc_offsSrcNodeName =
            PcToHostWord( lpNegCmd->nc_offsSrcNodeName );
        lpNegCmd->nc_offsDstNodeName =
            PcToHostWord( lpNegCmd->nc_offsDstNodeName );
        lpNegCmd->nc_offsProtocols =
            PcToHostWord( lpNegCmd->nc_offsProtocols );
        lpNegCmd->nc_protocolBytes =
            PcToHostWord( lpNegCmd->nc_protocolBytes );

        /* got the neg cmd from the other side that we were waiting for */

        oldPkState = lpPktz->pk_state;
        /* kill the timer associated with this */
        TimerDelete( lpPktz->pk_hTimerRcvNegCmd );
        lpPktz->pk_hTimerRcvNegCmd = 0;

        /* copy in node name of other side */
        lstrcpyn( lpPktz->pk_szDestName,
            GetLPSZNegCmdString( lpNegCmd, lpNegCmd->nc_offsSrcNodeName ),
            MAX_NODE_NAME+1 );

        /* set up timeouts based on other side's name */
        GetConnectionInfo( lpPktz->pk_szDestName, szNetintf,
            szConnInfo, sizeof(szConnInfo),
            &lpPktz->pk_fDisconnect, &lpPktz->pk_nDelay );

        if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
            /* if other side wants lesser # of max unack pkts, so be it */
            if( lpNegCmd->nc_maxUnackPkts < lpPktz->pk_maxUnackPkts )  {
                lpPktz->pk_maxUnackPkts = lpNegCmd->nc_maxUnackPkts;
            }

            /* if other side wants smaller packets, so be it */
            if( lpNegCmd->nc_pktSize < lpPktz->pk_pktSize )  {
                lpPktz->pk_pktSize = lpNegCmd->nc_pktSize;
            }

            /* tell the network interface about these changes,
                in case he cares */
            (*lpPktz->pk_lpNiPtrs->SetConnectionConfig) ( lpPktz->pk_connId,
                lpPktz->pk_maxUnackPkts, lpPktz->pk_pktSize,
                lpPktz->pk_szDestName );
        }

        /* figure out which protocol */
        wProtocol = NEGRSP_PROTOCOL_NONE;
        wErrorClass = NEGRSP_ERRCLASS_NONE;
        wErrorNum = 0;
        wBytesConsumed = 0;
        lpProtocol = GetLPSZNegCmdString( lpNegCmd,
            lpNegCmd->nc_offsProtocols );

        i = 0;
        while( (wProtocol==NEGRSP_PROTOCOL_NONE)
            && (wBytesConsumed < lpNegCmd->nc_protocolBytes) )  {
            if( lstrcmpi( lpProtocol, OurDialect ) == 0 )  {
                wProtocol = (WORD) i;
            } else {
                /* advance to next string */
                wBytesConsumed += lstrlen( lpProtocol ) + 1;
                lpProtocol += lstrlen( lpProtocol ) + 1;
                i++;
            }
        }

        /* make sure the names matched */
        if( lstrcmpi( ourNodeName, GetLPSZNegCmdString(
                lpNegCmd, lpNegCmd->nc_offsDstNodeName ) ) != 0 )  {
            wErrorClass = NEGRSP_ERRCLASS_NAME;
            wErrorNum = NEGRSP_ERRNAME_MISMATCH;
        } else { /* make sure they are not us */
            if ( lstrcmpi( ourNodeName, GetLPSZNegCmdString(
                    lpNegCmd, lpNegCmd->nc_offsSrcNodeName ) ) == 0 ) {
                wErrorClass = NEGRSP_ERRCLASS_NAME;
                wErrorNum = NEGRSP_ERRNAME_DUPLICATE;
            }
        }

        /* create the response to send back */
        /* get a packet */
        lpNetHdr = PktzGetFreePacket( lpPktz );
        if( lpNetHdr == NULL )  {
            /* should be first message we sent! */
            assert( FALSE );
        } else {
            /* build packet for response */
            lpNegRsp = (LPNEGRSP)
                (((LPSTR)lpNetHdr) + sizeof(NETHDR) + sizeof(NETPKT));
            lpNegRsp->nr_type           =
                                    PcToHostWord( PKTZ_NEG_RSP );
            lpNegRsp->nr_pktSize        =
                                    PcToHostWord( lpPktz->pk_pktSize );
            lpNegRsp->nr_maxUnackPkts   =
                                    PcToHostWord( lpPktz->pk_maxUnackPkts );
            lpNegRsp->nr_protocolIndex  =
                                    PcToHostWord( wProtocol );
            lpNegRsp->nr_errorClass     =
                                    PcToHostWord( wErrorClass );
            lpNegRsp->nr_errorNum       =
                                    PcToHostWord( wErrorNum );

            lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
            lpPacket->np_pktSize        = sizeof(NEGRSP);
            lpPacket->np_pktOffsInMsg   = 0;
            lpPacket->np_msgSize        = lpPacket->np_pktSize;
            lpPacket->np_type           = NPKT_PKTZ;
            lpPacket->np_pktID          = lpPktz->pk_pktidNextToBuild;

            /* note that the connection is completed */
            if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
                lpPktz->pk_state = PKTZ_CONNECTED;
            }

            /* bump id of next pkt to build */
            lpPktz->pk_pktidNextToBuild++;

            /* link into list to send */
            PktzLinkToXmitList( lpPktz, lpNetHdr );

            if( oldPkState == PKTZ_WAIT_NEG_CMD )  {
                /* notify all routers that were waiting */
                RouterConnectionComplete( lpPktz->pk_hRouterHead,
                    lpPktz->pk_hRouterExtraHead, (HPKTZ) lpPktz );
            }
        }
    } else if( (lpPktz->pk_state == PKTZ_WAIT_NEG_RSP)
        && (lpPktzCmd->pc_type == PKTZ_NEG_RSP) )  {
        /* got the neg rsp from the other side that we were waiting for */

        /* kill the timer associated with this */
        TimerDelete( lpPktz->pk_hTimerRcvNegRsp );
        lpPktz->pk_hTimerRcvNegRsp = 0;

        lpNegRsp = (LPNEGRSP) lpPktzCmd;

        /* convert byte-order */
        lpNegRsp->nr_pktSize =
                            PcToHostWord( lpNegRsp->nr_pktSize );
        lpNegRsp->nr_maxUnackPkts =
                            PcToHostWord( lpNegRsp->nr_maxUnackPkts );
        lpNegRsp->nr_protocolIndex =
                            PcToHostWord( lpNegRsp->nr_protocolIndex );
        lpNegRsp->nr_errorClass =
                            PcToHostWord( lpNegRsp->nr_errorClass );
        lpNegRsp->nr_errorNum =
                            PcToHostWord( lpNegRsp->nr_errorNum );

        if( (lpNegRsp->nr_errorClass == NEGRSP_ERRCLASS_NONE)
            && (lpNegRsp->nr_protocolIndex != NEGRSP_PROTOCOL_NONE)
            && (lpNegRsp->nr_protocolIndex == 0) )  {
            /* connection OK */

            /* if other side wants lesser # of max unack pkts, so be it */
            if( lpNegRsp->nr_maxUnackPkts < lpPktz->pk_maxUnackPkts )  {
                lpPktz->pk_maxUnackPkts = lpNegRsp->nr_maxUnackPkts;
            }

            /* if other side wants smaller packets, so be it */
            if( lpNegRsp->nr_pktSize < lpPktz->pk_pktSize )  {
                lpPktz->pk_pktSize = lpNegRsp->nr_pktSize;
            }

            /* tell the network interface about these changes,
                in case he cares */
            (*lpPktz->pk_lpNiPtrs->SetConnectionConfig) ( lpPktz->pk_connId,
                lpPktz->pk_maxUnackPkts, lpPktz->pk_pktSize,
                lpPktz->pk_szDestName );

            /* note that the connection is completed */
            lpPktz->pk_state = PKTZ_CONNECTED;

            /* notify all routers that were waiting */
            RouterConnectionComplete( lpPktz->pk_hRouterHead,
                lpPktz->pk_hRouterExtraHead, (HPKTZ) lpPktz );
        } else {
            /* connection failed */
            if( lpNegRsp->nr_protocolIndex == NEGRSP_PROTOCOL_NONE )  {
                /*  "%1" node does not speak any of our protocols    */
                NDDELogError(MSG113, lpPktz->pk_szDestName, NULL);
            } else if( lpNegRsp->nr_protocolIndex != 0 )  {
                /*  "%1" node selected an invalid protocol: %2  */
                NDDELogError(MSG114, lpPktz->pk_szDestName,
                    LogString("%d", lpNegRsp->nr_protocolIndex), NULL );
            } else switch( lpNegRsp->nr_errorClass )  {
            case NEGRSP_ERRCLASS_NAME:
                switch( lpNegRsp->nr_errorClass )  {
                case NEGRSP_ERRNAME_MISMATCH:
                    /*  "%1" their name was not "%2"    */
                    NDDELogError(MSG115,
                        lpPktz->pk_szDestName,
                        lpPktz->pk_szDestName, NULL );
                    break;
                case NEGRSP_ERRNAME_DUPLICATE:
                    /*  "%1" their name was same as ours "%2"    */
                    NDDELogError(MSG142,
                        lpPktz->pk_szDestName,
                        ourNodeName, NULL );
                    break;
                default:
                    /*  Unusual connect name error %2 from %1   */
                    NDDELogError(MSG116, lpPktz->pk_szDestName,
                        LogString("0x%0X", lpNegRsp->nr_errorNum), NULL );
					break;
                }
                break;
            default:
                /*  Unusual connect error from %1. Class: %2, Error: %3 */
                NDDELogError(MSG117, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpNegRsp->nr_errorClass),
                    LogString("0x%0X", lpNegRsp->nr_errorNum), NULL );
                break;
            }

            /* notify all routers that were waiting */
            RouterConnectionComplete( lpPktz->pk_hRouterHead,
                lpPktz->pk_hRouterExtraHead, (HPKTZ) NULL );

            /* disconnect from connId */
            (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

            /* free this packetizer */
            PktzFree( lpPktz );
            ok = FALSE;
        }
    } else {
        /* ignore the packet if it wasn't sent during the correct mode
            or we have the wrong version # interface */
    }
    return( ok );
}



/*
    PktzNetHdrWithinAck

        PktzNetHdrWithinAck() determines if the packet specified in lpNetHdr
        is in the range to be considered ACKed by the packet id "pktid".

        Generically, this could be as simple as:
            Is lpPacket->np_pktid <= pktid?

        However, because of wraparound, we must make the check a bit more
        sophisticated.
 */
BOOL
PktzNetHdrWithinAck(
    LPPKTZ      lpPktz,
    LPNETHDR    lpNetHdr,
    PKTID       pktId )
{
    LPNETPKT    lpPacket;

    lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );

    if( lpPacket->np_pktID <= pktId )  {
        return( TRUE );
    } else {
        return( FALSE );
    }
}



/*
    PktzGetFreePacket()

        Returns a packet to be sent from the free list
 */
LPNETHDR
PktzGetFreePacket( LPPKTZ lpPktz )
{
    LPNETHDR    lpCur;

    lpCur = lpPktz->pk_pktFreeHead;
    if( lpCur )  {
        lpPktz->pk_pktFreeHead = lpCur->nh_next;
        if( lpPktz->pk_pktFreeHead )  {
            lpPktz->pk_pktFreeHead->nh_prev = NULL;
        } else {
            lpPktz->pk_pktFreeTail = NULL;
        }

        /* init fields of nethdr */
        lpCur->nh_prev          = NULL;
        lpCur->nh_next          = NULL;
        lpCur->nh_noRsp         = 0;
        lpCur->nh_xmtErr        = 0;
        lpCur->nh_memErr        = 0;
        lpCur->nh_timeSent      = 0;
        lpCur->nh_hTimerRspTO   = 0;
    }

    return( lpCur );
}



/*
    PktzXmitErrorOnPkt

        A packet that we transmitted had an error in it.  We must reset the
        pkt xmit side to ensure that this is the next packet that we send,
        and consider that all packets that were sent after this have
        never been sent (so we must kill timers associated with them, etc.)

        The "pktStatus" field tells us why we need to retransmit that packet,
        and we need to increment the count of how many times this packet has
        been rejected for this reason.  If we exceed the max count, we should
        kill the connection.
 */
BOOL
PktzXmitErrorOnPkt(
    LPPKTZ  lpPktz,
    PKTID   pktIdToRexmit,
    BYTE    pktStatus )
{
    LPNETHDR    lpNetHdr;
    LPNETPKT    lpPacket;
    BOOL        found;
    BOOL        ok = TRUE;

    lpNetHdr = lpPktz->pk_pktUnackHead;

    found = FALSE;
    ok = TRUE;
    while( lpNetHdr && ok )  {
        lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );
        if( lpPacket->np_pktID == pktIdToRexmit )  {
            found = TRUE;
            switch( pktStatus )  {
            case PS_NO_RESPONSE:
                lpNetHdr->nh_noRsp++;
                if( lpNetHdr->nh_noRsp > lpPktz->pk_wMaxNoResponse )  {
                    /*  Too many transmit retries (%2) for same packet to "%1"
                        ... closing connection  */
                    NDDELogError(MSG118, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_noRsp), NULL);
                    ok = FALSE;
                }
                break;
            case PS_DATA_ERR:
                if (bLogRetries) {
                    /*  Transmit error on pktid %2 to "%1"  */
                    NDDELogError(MSG119, lpPktz->pk_szDestName,
                        LogString("0x%0X", pktIdToRexmit), NULL);
                }
                lpNetHdr->nh_xmtErr++;
                if( lpNetHdr->nh_xmtErr > lpPktz->pk_wMaxXmtErr )  {
                    /*  Too many retries to "%1" for xmit errs (%2)
                        ... closing connection  */
                    NDDELogError(MSG120, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_xmtErr), NULL);
                    ok = FALSE;
                }
                break;
            case PS_MEMORY_ERR:
                /*  Memory error on pktid %2 xmitted to "%1"    */
                NDDELogError(MSG121, lpPktz->pk_szDestName,
                    LogString("0x%0X", lpNetHdr->nh_xmtErr), NULL);
                lpNetHdr->nh_memErr++;
                if( lpNetHdr->nh_memErr > lpPktz->pk_wMaxMemErr )  {
                    /*  Too many xmit retries to "%1" for memory errors (%2)
                        ... closing connection  */
                    NDDELogError(MSG122, lpPktz->pk_szDestName,
                        LogString("%d", lpNetHdr->nh_memErr), NULL);
                    ok = FALSE;
                } else {
                    lpPktz->pk_hTimerMemoryPause =
                        TimerSet( lpPktz->pk_timeoutMemoryPause,
                                  PktzTimerExpired,
                                  (DWORD_PTR)lpPktz,
                                  TID_MEMORY_PAUSE,
                                  (DWORD_PTR)lpNetHdr );
                    if( lpPktz->pk_hTimerMemoryPause == (HTIMER) NULL )  {
                        /* Out of timers to start a memory pause for a xmit to "%1" */
                        NDDELogError(MSG123, lpPktz->pk_szDestName, NULL );
                        ok = FALSE;
                    } else {
                        /* change state to waiting for memory.  Shouldn't
                           send anything but control packets until memory
                           condition clears
                         */
                        lpPktz->pk_state = PKTZ_PAUSE_FOR_MEMORY;
                    }
                }
                break;
            default:
                InternalError(
                    "PktzXmitErrorOnPkt( %08lX, %08lX, %d ) unkn status",
                    lpPktz, pktIdToRexmit, pktStatus );
            }
        }
        if( found )  {
            /* this packet was the one that needed to be retransmitted, or
                was sent after the one that needs to be retransmitted.  Either
                way, we should pretend we never sent this packet */
            TimerDelete( lpNetHdr->nh_hTimerRspTO );
            lpNetHdr->nh_hTimerRspTO = 0;
        }
        lpNetHdr = lpNetHdr->nh_next;
    }

    assert( found );
    lpPktz->pk_pktidNextToSend = pktIdToRexmit;
    if( !ok )  {
        /* must close the connection */
        PktzClose( (HPKTZ) lpPktz );
    }
    /* lpPktz may be invalid after this call */
    return( ok );
}



/*
    PktzLinkToXmitList()

        This routine makes sure that the packet is on the list to get sent.
        Packet is already not on free list ... just needs linked to xmt list.
 */
VOID
PktzLinkToXmitList(
    LPPKTZ      lpPktz,
    LPNETHDR    lpNetHdr )
{
    LPNETPKT    lpPacket;

    DIPRINTF(( "PktzLinkToXmitList( %08lX, %08lX ) before linking",
            lpPktz, lpNetHdr ));
    lpPacket = (LPNETPKT) ( ((LPSTR)lpNetHdr) + sizeof(NETHDR) );

    lpNetHdr->nh_prev = lpPktz->pk_pktUnackTail;
    lpNetHdr->nh_next = NULL;
    if( lpPktz->pk_pktUnackTail )  {
        lpPktz->pk_pktUnackTail->nh_next = lpNetHdr;
    } else {
        lpPktz->pk_pktUnackHead = lpNetHdr;
    }
    lpPktz->pk_pktUnackTail = lpNetHdr;

    /* set up so xmit will send this packet next */
    lpPktz->pk_pktidNextToSend = lpPacket->np_pktID;
}



/*
    PktzClose()

        Only called internally when we need to break the connection or the
        connection is already broken
 */
VOID
PktzClose( HPKTZ hPktz )
{
    LPPKTZ      lpPktz;

    DIPRINTF(( "PktzClose( %08lX )", hPktz ));

    lpPktz = (LPPKTZ) hPktz;

    if( lpPktz )  {
        /* Notify all routers of closure */
        RouterConnectionBroken( lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead, hPktz, TRUE /*from PKTZ*/ );

        /* disconnect from connId */
        (*lpPktz->pk_lpNiPtrs->DeleteConnection) ( lpPktz->pk_connId );

        /* free this packetizer */
        PktzFree( lpPktz );
    }
}



/*
    Called (in essence) by the netintf when the connection has been broken
    abnormally
 */
VOID
PktzConnectionBroken( HPKTZ hPktz )
{
    DIPRINTF(( "PktzConnectionBroken( %08lX )", hPktz ));
    PktzClose( hPktz );
}



/*
    PktzFreeDdePkt()

        Frees a packet that we already transmitted.  Frees from list of DDE
        packets to be sent as well as freeing the memory associated with the
        packet
 */
VOID
PktzFreeDdePkt(
    LPPKTZ      lpPktz,
    LPDDEPKT    lpDdePkt )
{
    assert( lpDdePkt == lpPktz->pk_ddePktHead );
    lpPktz->pk_ddePktHead = lpDdePkt->dp_next;
    if( lpPktz->pk_ddePktHead )  {
        ( (LPDDEPKT)(lpPktz->pk_ddePktHead) )->dp_prev = NULL;
    } else {
        lpPktz->pk_ddePktTail = NULL;
    }
    HeapFreePtr( lpDdePkt );
}



/*
    PktzGetPktzForRouter()

        Called by the router when we need to establish a connection to another
        node.  If we already have the connection, we just return that
        connection ... otherwise we use the specified netintf to connect
 */
BOOL
PktzGetPktzForRouter(
    LPNIPTRS    lpNiPtrs,
    LPSTR       lpszNodeName,
    LPSTR       lpszNodeInfo,
    HROUTER     hRouter,
    WORD        hRouterExtra,
    WORD FAR   *lpwHopErr,
    BOOL        bDisconnect,
    int         nDelay,
    HPKTZ       hPktzDisallowed )
{
    LPPKTZ      lpPktz;
    HPKTZ       hPktz;
    BOOL        found;
    BOOL        ok;

    lpPktz = lpPktzHead;
    found = FALSE;
    ok = FALSE;
    while( !found && lpPktz )  {
        if ( (lpPktz->pk_state != PKTZ_CLOSE)
			   && ((lstrcmpi( lpszNodeName, lpPktz->pk_szDestName ) == 0)
            || (lstrcmpi( lpszNodeName, lpPktz->pk_szAliasName ) == 0)) )  {
            found = TRUE;

            /* for a NET-NET connection, we must disallow the same PKTZ
                for both sides of the NET-NET, since the router uses
                the PKTZ to determine which leg of the NET-NET connection
                the packet came in on.

                The error case that this catches is on node "D" for a route
                like:  A+C+D+C+B, since "C" is the "in" and "out" pktz
                for "D".
             */
            if( lpPktz == (LPPKTZ)hPktzDisallowed )  {
                *lpwHopErr = RERR_DIRECT_LOOP;
                return( FALSE );
            }
            /* tell this pktz that this router should be associated with him
             */
            PktzAssociateRouter( (HPKTZ)lpPktz, hRouter, hRouterExtra );
            ok = TRUE;
        }
        lpPktz = lpPktz->pk_nextPktz;
    }
    if( !found )  {
        /* create a pktz for this node connection */
        hPktz = PktzNew( lpNiPtrs, TRUE /* client */,
            lpszNodeName, lpszNodeInfo, (CONNID)0, bDisconnect, nDelay );
        if( hPktz )  {
            lpPktz = (LPPKTZ) hPktz;

            /* tell this pktz that this router should be associated with him
             */
            PktzAssociateRouter( (HPKTZ)lpPktz, hRouter, hRouterExtra );
            ok = TRUE;
        } else {
            ok = FALSE;
            *lpwHopErr = RERR_NEXT_NODE_CONN_FAILED;
        }
    }
    return( ok );
}



/*
    PktzLinkDdePktToXmit()

        This is called by the router when it has a packet for us to transmit
 */
VOID
PktzLinkDdePktToXmit(
    HPKTZ       hPktz,
    LPDDEPKT    lpDdePkt )
{
    LPPKTZ      lpPktz;
    BOOL        bWasEmpty = FALSE;
#ifndef _WINDOWS
    DWORD       dwStatus;
#endif

    lpPktz = (LPPKTZ) hPktz;

    /* link this packet onto the end of the list */
    lpDdePkt->dp_prev = lpPktz->pk_ddePktTail;
    lpDdePkt->dp_next = NULL;
    if( lpPktz->pk_ddePktTail )  {
        ((LPDDEPKT)lpPktz->pk_ddePktTail)->dp_next = lpDdePkt;
    }
    lpPktz->pk_ddePktTail = lpDdePkt;
    if( lpPktz->pk_ddePktHead == NULL )  {
        lpPktz->pk_ddePktHead = lpDdePkt;
        bWasEmpty = TRUE;
    }

#ifdef _WINDOWS
    {
        MSG     msg;

        if (ptdHead != NULL) {
            /* kick off pktz slice at next opportunity, if a timer message
                isn't already waiting */
            if( !PeekMessage( &msg, ptdHead->hwndDDE, WM_TIMER, WM_TIMER,
                    PM_NOREMOVE | PM_NOYIELD ) )  {
                PostMessage( ptdHead->hwndDDE, WM_TIMER, 0, 0L );
            }
        }
    }
#else
    /* if lpPktz->pk_ddePktHead was == NULL, tell pktz to get going */
    if( bWasEmpty )  {
        dwStatus = (*lpPktz->pk_lpNiPtrs->GetConnectionStatus)
            ( lpPktz->pk_connId );
        if( (dwStatus & NDDE_CONN_OK) && (dwStatus & NDDE_READY_TO_XMT) )  {
            PktzOkToXmit( (HPKTZ)lpPktz );
        }
    }
#endif
}



/*
    PktzGotPktOk()

        Called when we know this pkt id has been rcvd OK
 */
VOID
PktzGotPktOk(
    LPPKTZ  lpPktz,
    PKTID   pktid )
{
    assert( pktid == lpPktz->pk_pktidNextToRecv );
    lpPktz->pk_lastPktRcvd      = pktid;
    lpPktz->pk_lastPktStatus    = PS_OK;
    lpPktz->pk_lastPktOk        = pktid;
    lpPktz->pk_pktidNextToRecv++;

    /* mark that we must send info back to the other side
     */
    lpPktz->pk_fControlPktNeeded = TRUE;
}



#if DBG

VOID
FAR PASCAL
DebugPktzState( void )
{
    LPPKTZ      lpPktz;
    char        name[ 50 ];

    lpPktz = lpPktzHead;
    DPRINTF(( "PKTZ State:" ));
    while( lpPktz )  {
        /* get layer name */
        lstrcpyn( name, lpPktz->pk_lpNiPtrs->dllName, 50 );
        DPRINTF(( "  %Fp:\n"
                  "  name                 %Fs\n"
                  "  pk_connId            %Fp\n"
                  "  pk_state             %d\n"
                  "  pk_fControlPktNeeded %d\n"
                  "  pk_pktidNextToSend   %08lX\n"
                  "  pk_pktidNextToBuild  %08lX\n"
                  "  pk_lastPktStatus     %02X\n"
                  "  pk_lastPktRcvd       %08lX\n"
                  "  pk_lastPktOk         %08lX\n"
                  "  pk_lastPktOkOther    %08lX\n"
                  ,
            lpPktz,
            (LPSTR) name,
            lpPktz->pk_connId,
            lpPktz->pk_state,
            lpPktz->pk_fControlPktNeeded,
            lpPktz->pk_pktidNextToSend,
            lpPktz->pk_pktidNextToBuild,
            lpPktz->pk_lastPktStatus,
            lpPktz->pk_lastPktRcvd,
            lpPktz->pk_lastPktOk,
            lpPktz->pk_lastPktOkOther ));
        DPRINTF(( "    %08lX %ld \"%Fs\" \"%Fs\" %d %d %ld %ld %ld %ld %ld %ld",
            lpPktz->pk_pktidNextToRecv,
            lpPktz->pk_pktOffsInXmtMsg,
            lpPktz->pk_szDestName,
            lpPktz->pk_szAliasName,
            lpPktz->pk_pktSize,
            lpPktz->pk_maxUnackPkts,
            lpPktz->pk_timeoutRcvNegCmd,
            lpPktz->pk_timeoutRcvNegRsp,
            lpPktz->pk_timeoutMemoryPause,
            lpPktz->pk_timeoutKeepAlive,
            lpPktz->pk_timeoutXmtStuck,
            lpPktz->pk_timeoutSendRsp ));
        DPRINTF(( "    %d %d %d %d %d %ld %ld %Fp %Fp %Fp %Fp %Fp %Fp",
            lpPktz->pk_wMaxNoResponse,
            lpPktz->pk_wMaxXmtErr,
            lpPktz->pk_wMaxMemErr,
            lpPktz->pk_fDisconnect,
            lpPktz->pk_nDelay,
            lpPktz->pk_sent,
            lpPktz->pk_rcvd,
            lpPktz->pk_hTimerKeepalive,
            lpPktz->pk_hTimerXmtStuck,
            lpPktz->pk_hTimerRcvNegCmd,
            lpPktz->pk_hTimerRcvNegRsp,
            lpPktz->pk_hTimerMemoryPause,
            lpPktz->pk_hTimerCloseConnection ));
        DPRINTF(( "    %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %Fp %d",
            lpPktz->pk_pktUnackHead,
            lpPktz->pk_pktUnackTail,
            lpPktz->pk_pktFreeHead,
            lpPktz->pk_pktFreeTail,
            lpPktz->pk_ddePktHead,
            lpPktz->pk_ddePktTail,
            lpPktz->pk_prevPktz,
            lpPktz->pk_nextPktz,
            lpPktz->pk_prevPktzForNetintf,
            lpPktz->pk_nextPktzForNetintf,
            lpPktz->pk_hRouterHead,
            lpPktz->pk_hRouterExtraHead ));
        lpPktz = lpPktz->pk_nextPktz;
    }
}
#endif // DBG


#ifdef BYTE_SWAP
VOID
ConvertDdePkt( LPDDEPKT lpDdePkt )
{
    lpDdePkt->dp_size = HostToPcLong( lpDdePkt->dp_size );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\router.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "ROUTER.C;1  16-Dec-92,10:21:02  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#define NO_DEBUG

#include    "host.h"
#ifdef _WINDOWS
#include    <memory.h>
#include    <stdio.h>
#endif
#include    <string.h>

#include    "windows.h"
#include    "netbasic.h"
#include    "netintf.h"
#include    "netpkt.h"
#include    "ddepkt.h"
#include    "pktz.h"
#include    "dder.h"
#include    "router.h"
#include    "internal.h"
#include    "wwassert.h"
#include    "hexdump.h"
#include    "host.h"
#include    "ddepkts.h"
#include    "security.h"
#include    "rerr.h"
#include    "timer.h"
#include    "nddemsg.h"
#include    "nddelog.h"
#define STRSAFE_NO_DEPRECATE
#include    <strsafe.h>

#ifdef _WINDOWS
#include    "nddeapi.h"
#include    "nddeapis.h"
#include    "winmsg.h"
#endif

#ifdef WIN32
#include    "api1632.h"
#endif

USES_ASSERT


/*
    States for router
 */
#define ROUTER_WAIT_PKTZ                        (1)
#define ROUTER_WAIT_MAKE_HOP_RSP                (2)
#define ROUTER_CONNECTED                        (3)
#define ROUTER_DISCONNECTED                     (4)

/*
    Types of routers
 */
#define RTYPE_LOCAL_NET         (1)
#define RTYPE_NET_NET           (2)

/*
    Router Commands
 */
#define RCMD_MAKE_HOP_CMD       (1)
#define RCMD_MAKE_HOP_RSP       (2)
#define RCMD_HOP_BROKEN         (3)
#define RCMD_ROUTE_TO_DDER      (4)


/*
    MAKE_HOP_CMD

        This is sent from the originating node to the next node along the
        chain.
 */
typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      mhc_ddePktHdr;

    /* this is the hRouter for the hop immediately preceding this hop */
    HROUTER     mhc_hRouterPrevHop;

    /* this is the number of hops processed.  This prevents circular routes
        from becoming infinite */
    short       mhc_nHopsLeft;

    /* this is the name of the node that started the whole chain of hops */
    short       mhc_offsNameOriginator;

    /* this is the final destination name that we are trying to get to */
    short       mhc_offsNameFinalDest;

    /* this is additional routing information passed on from the previous
        hop.  If ourNodeName == mhc_nameFinalDest, this should be empty. */
    short       mhc_offsAddlInfo;

    DWORD       mhc_pad1;
} MAKEHOPCMD;
typedef MAKEHOPCMD FAR *LPMAKEHOPCMD;


/*
    MAKE_HOP_RSP

        This is sent in response for each node along the path.
 */
typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      mhr_ddePktHdr;

    /* this is the router that is sending the response */
    HROUTER     mhr_hRouterSendingRsp;

    /* this is the router that the response is for */
    HROUTER     mhr_hRouterForRsp;

    /* this is the byte that tells of success(1) or failure(0) */
    WORD        mhr_success;

    /* this is an error message in case mhr_success == 0 */
    WORD        mhr_errCode;

    /* node name with error (only applicable if mhr_success == 0) */
    short       mhr_offsErrNode;
} MAKEHOPRSP;
typedef MAKEHOPRSP FAR *LPMAKEHOPRSP;


/*
    HOP_BROKEN_CMD
        This is sent when the connection is broken
 */

typedef struct {
    /* this is the DDE packet overhead */
    DDEPKT      hbc_ddePktHdr;

    /* this is the router that the response is for */
    HROUTER     hbc_hRouterForRsp;
} HOPBRKCMD;
typedef HOPBRKCMD FAR *LPHOPBRKCMD;


/*
    RTINFO
        Info for routing
 */
typedef struct {
    /* ri_hPktz: hPktz associated with this route */
    HPKTZ       ri_hPktz;

    /* ri_hRouterDest: hRouter on other side of connection */
    HROUTER     ri_hRouterDest;

    /* these 4 fields are links for associating router with packetizers */
    HROUTER     ri_hRouterPrev;
    WORD        ri_hRouterExtraPrev;
    HROUTER     ri_hRouterNext;
    WORD        ri_hRouterExtraNext;

    /* ri_lpHopBrkCmd: always have memory for hop broken cmd */
    LPHOPBRKCMD ri_lpHopBrkCmd;

    unsigned    ri_hopRspProcessed      : 1;
    unsigned    ri_hopBrokenSent        : 1;
    unsigned    ri_hopBrokenRcvd        : 1;
} RTINFO;
typedef RTINFO FAR *LPRTINFO;


/*
    ROUTER
        Structure per router.
 */
typedef struct s_router {
    /* prev/next for all routers */
    struct s_router FAR        *rt_prev;
    struct s_router FAR        *rt_next;

    /* rt_state */
    WORD                        rt_state;

    /* rt_type: one of RTYPE_LOCAL_NET or RTYPE_NET_NET */
    WORD                        rt_type;

    /* rt_origName: originating node name */
    char                        rt_origName[ MAX_NODE_NAME+1 ];

    /* rt_destName: destination node name */
    char                        rt_destName[ MAX_NODE_NAME+1 ];

    /* rt_startNode: starting node name for connect */
    char                        rt_startNode[ MAX_NODE_NAME+1 ];

    /* rt_sent,rt_rcvd: counts of packets */
    DWORD                       rt_sent;
    DWORD                       rt_rcvd;

    /* disconnect when not in use and what the delay should be */
    BOOL                        rt_fDisconnect; /* leave this BOOL!! */
    int                         rt_nDelay;
    BOOL                        rt_fSpecificNetintf;
    int                         rt_nLastNetintf;
    int                         rt_nHopsLeft;

    /* save some information for trying successive netintfs */
    BOOL                        rt_pktz_bDisconnect;
    int                         rt_pktz_nDelay;

    /* rt_routeInfo: addl info necessary for routing */
    char                        rt_routeInfo[ MAX_ROUTE_INFO+1 ];

    /* rt_rinfo: information for each of 2 possible connections */
    RTINFO                      rt_rinfo[ 2 ];

    /* rt_hDderHead: head of list of associated DDERs */
    HDDER                       rt_hDderHead;

    /* rt_lpMakeHopRsp: response for MakeHopCmd */
    LPMAKEHOPRSP                rt_lpMakeHopRsp;

    /* rt_hTimerClose: timer for closing this route */
    HTIMER                      rt_hTimerCloseRoute;
} ROUTER;
typedef ROUTER FAR *LPROUTER;


/*
    External variables used
 */
#if DBG
extern BOOL     bDebugInfo;
#endif // DBG
extern HHEAP    hHeap;
extern char     ourNodeName[ MAX_NODE_NAME+1 ];
extern BOOL     bDefaultRouteDisconnect;
extern int      nDefaultRouteDisconnectTime;
extern char     szDefaultRoute[];

/* Timer IDs */
#define TID_CLOSE_ROUTE                 1


/*
    Local variables
 */
static  LPROUTER        lpRouterHead;


/*
    Local routines
 */
VOID    RouterTimerExpired( HROUTER hRouter, DWORD dwTimerId, DWORD_PTR lpExtra );
BOOL    RouterStripStartingNode( LPSTR lpszAddlInfo, LPSTR lpszNode, WORD FAR *lpwHopErr );
VOID    RouterCloseBeforeConnected( LPROUTER lpRouter, WORD hRouterExtra );
VOID    RouterSendHopRsp( LPMAKEHOPRSP lpMakeHopRsp, HPKTZ hPktz,
         HROUTER hRouterSrc, HROUTER hRouterDest, BYTE bSucc,
         WORD wHopErr, LPSTR lpszErrNode );
VOID    RouterSendHopBroken( LPROUTER lpRouter, LPRTINFO lpRtInfo );
HROUTER RouterCreateLocalToNet( const LPSTR lpszNodeName );
VOID    RouterProcessHopCmd( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessHopRsp( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessHopBroken( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
VOID    RouterProcessDderPacket( HPKTZ hPktzFrom, LPDDEPKT lpDdePkt );
HROUTER RouterCreate( void );
VOID    RouterFree( LPROUTER lpRouter );
BOOL    RouterConnectToNode( LPROUTER lpRouter, WORD hRouterExtra, WORD FAR *lpwHopErr );
BOOL    RouterExpandFirstNode( LPROUTER lpRouter, WORD FAR *lpwHopErr );
#if	DBG
VOID    RouterDisplayError( LPROUTER lpRouter, LPSTR lpszNode, WORD wHopErr );
#endif // DBG
VOID    FAR PASCAL DebugRouterState( void );
#define GetLPSZFromOffset(lpptr,offs)   (((LPSTR)(lpptr))+offs)

#ifdef WIN32
HDDER FAR PASCAL DderFillInConnInfo( HDDER hDder, LPCONNENUM_CMR lpConnEnum,
              LPSTR lpDataStart, LPWORD lpcFromBeginning, LPWORD lpcFromEnd );
#endif

#ifndef WIN32
#ifdef _WINDOWS
int     RouterDraw( BOOL bShowThru, HDC hDC, int x, int vertPos, int lineHeight );
#pragma alloc_text(GUI_TEXT,RouterDraw,DebugRouterState)
#endif
#endif

#ifdef  BYTE_SWAP
VOID     ConvertDdePkt( LPDDEPKT lpDdePkt );
#else
#define ConvertDdePkt(x)
#endif

HROUTER
RouterCreate( void )
{
    HROUTER     hRouter;
    LPROUTER    lpRouter;
    int         i;
    BOOL        ok;

    ok = TRUE;
    lpRouter = (LPROUTER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD)sizeof(ROUTER) );
    if( lpRouter )  {
        hRouter = (HROUTER) lpRouter;
        lpRouter->rt_prev               = NULL;
        lpRouter->rt_next               = NULL;
        lpRouter->rt_state              = 0;
        lpRouter->rt_type               = 0;
        lpRouter->rt_sent               = 0;
        lpRouter->rt_rcvd               = 0;
        lpRouter->rt_fDisconnect        = FALSE;
        lpRouter->rt_nDelay             = 0;
        lpRouter->rt_fSpecificNetintf   = FALSE;
        lpRouter->rt_nLastNetintf       = 0;
        lpRouter->rt_nHopsLeft          = 100;
        lpRouter->rt_origName[0]        = '\0';
        lpRouter->rt_startNode[0]       = '\0';
        lpRouter->rt_destName[0]        = '\0';
        lpRouter->rt_routeInfo[0]       = '\0';
        lpRouter->rt_hDderHead          = 0;
        lpRouter->rt_lpMakeHopRsp       = NULL;
        lpRouter->rt_hTimerCloseRoute   = 0;
        for( i=0; i<2; i++ )  {
            lpRouter->rt_rinfo[i].ri_hPktz              = 0;
            lpRouter->rt_rinfo[i].ri_hRouterDest        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterPrev        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterExtraPrev   = 0;
            lpRouter->rt_rinfo[i].ri_hRouterNext        = 0;
            lpRouter->rt_rinfo[i].ri_hRouterExtraNext   = 0;
            lpRouter->rt_rinfo[i].ri_hopRspProcessed    = FALSE;
            lpRouter->rt_rinfo[i].ri_hopBrokenSent      = FALSE;
            lpRouter->rt_rinfo[i].ri_hopBrokenRcvd      = FALSE;
            lpRouter->rt_rinfo[i].ri_lpHopBrkCmd        =
                (LPHOPBRKCMD) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
                    (DWORD) sizeof(HOPBRKCMD) );
            if( lpRouter->rt_rinfo[i].ri_lpHopBrkCmd == NULL )  {
                ok = FALSE;
            }
        }

        lpRouter->rt_lpMakeHopRsp = (LPMAKEHOPRSP) HeapAllocPtr( hHeap,
            GMEM_MOVEABLE, (DWORD) sizeof(MAKEHOPRSP) + MAX_NODE_NAME + 1 );
        if( lpRouter->rt_lpMakeHopRsp == NULL )  {
            ok = FALSE;
        }
        if( ok )  {
            /* link into list of routers */
            if( lpRouterHead )  {
                lpRouterHead->rt_prev = lpRouter;
            }
            lpRouter->rt_next = lpRouterHead;
            lpRouterHead = lpRouter;
        }
        if( !ok )  {
            RouterFree( lpRouter );
            hRouter = (HROUTER) 0;
        }
    } else {
        hRouter = (HROUTER) 0;
    }
    return( hRouter );
}



VOID
RouterProcessHopCmd(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPMAKEHOPCMD        lpMakeHopCmd;
    BOOL                ok;
    HROUTER             hRouter;
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfo;
    LPSTR               lpszAddlInfo;
    LPSTR               lpszNameFinalDest;
    LPSTR               lpszNameOriginator;
    WORD                wHopErr;

    ok = TRUE;
    DIPRINTF(( "RouterProcessHopCmd( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpMakeHopCmd = (LPMAKEHOPCMD) lpDdePkt;
    lpMakeHopCmd->mhc_hRouterPrevHop =
        HostToPcLong( lpMakeHopCmd->mhc_hRouterPrevHop );
    lpMakeHopCmd->mhc_nHopsLeft =
        HostToPcWord( lpMakeHopCmd->mhc_nHopsLeft );
    lpMakeHopCmd->mhc_offsNameOriginator =
        HostToPcWord( lpMakeHopCmd->mhc_offsNameOriginator );
    lpMakeHopCmd->mhc_offsNameFinalDest =
        HostToPcWord( lpMakeHopCmd->mhc_offsNameFinalDest );
    lpMakeHopCmd->mhc_offsAddlInfo =
        HostToPcWord( lpMakeHopCmd->mhc_offsAddlInfo );

    lpszAddlInfo = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsAddlInfo );
    lpszNameFinalDest = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsNameFinalDest );
    lpszNameOriginator = GetLPSZFromOffset( lpMakeHopCmd,
        lpMakeHopCmd->mhc_offsNameOriginator );

    hRouter = RouterCreate();
    if( hRouter == 0 )  {
        ok = FALSE;
        wHopErr = RERR_NO_MEMORY;
    }

    if( ok )  {
        lpRouter = (LPROUTER) hRouter;

        /* do not disconnect routes that were created by other side */
        lpRouter->rt_fDisconnect = FALSE;

        lpRouter->rt_rcvd++;

        /* check if we are the final destination */
        if( lstrcmpi( ourNodeName, lpszNameFinalDest ) == 0 ) {
            DIPRINTF(( "We are final dest" ));
            /* we are the final destination */
            if( lpszAddlInfo[0] != '\0' )  {
                /* routeInfo should always be NULL if we are the final dest */
                wHopErr = RERR_ADDL_INFO;
                ok = FALSE;
            }
            if( ok )  {
                lpRouter->rt_type = RTYPE_LOCAL_NET;
                lpRouter->rt_state = ROUTER_CONNECTED;
                StringCchCopy( lpRouter->rt_destName, MAX_NODE_NAME+1, lpszNameOriginator );

                /* retrieve disconnect and delay information */
                GetRoutingInfo( lpRouter->rt_destName,
                    lpRouter->rt_routeInfo,
                    sizeof(lpRouter->rt_routeInfo),
                    &lpRouter->rt_fDisconnect, &lpRouter->rt_nDelay );

                lpRtInfo = &lpRouter->rt_rinfo[ 0 ];
                lpRtInfo->ri_hPktz = hPktzFrom;
                lpRtInfo->ri_hRouterDest = lpMakeHopCmd->mhc_hRouterPrevHop;
                assert( lpRtInfo->ri_hRouterDest );

                /* associate us with this pktz */
                /* Note that this call will result in a call to
                    RouterConnectionComplete() */
                PktzAssociateRouter( hPktzFrom, hRouter, 0 );

                lpRtInfo->ri_hopRspProcessed = TRUE;

                /* tell the packetizer of the success */
                RouterSendHopRsp( lpRouter->rt_lpMakeHopRsp,
                    lpRtInfo->ri_hPktz,
                    (HROUTER) lpRouter,
                    lpRtInfo->ri_hRouterDest,
                    1 /* success */,
                    0 /* no err msg */,
                    (LPSTR) NULL );
                lpRouter->rt_lpMakeHopRsp = NULL;       /* just used it */
            }
        } else {
            DIPRINTF(( "We are NOT final dest, just hop along the way" ));
            /* we are not the final destination ... need more hops */
            if( lpszAddlInfo[0] == '\0' )  {
                /* should always have addl routing info if we're not the
                    final node */
                wHopErr = RERR_NO_ADDL_INFO;
                ok = FALSE;
            }
            if( --lpMakeHopCmd->mhc_nHopsLeft <= 0 )  {
                wHopErr = RERR_TOO_MANY_HOPS;
                ok = FALSE;
            }
            if( ok )  {
                lpRouter->rt_type = RTYPE_NET_NET;
                /* for net-net routers, we leave destName blank */
                lpRouter->rt_destName[0] = '\0';
                /* remember how many hops were left */
                lpRouter->rt_nHopsLeft = lpMakeHopCmd->mhc_nHopsLeft;
                StringCchCopy( lpRouter->rt_origName,  MAX_NODE_NAME +1, lpszNameOriginator );
                StringCchCopy( lpRouter->rt_destName,  MAX_NODE_NAME +1, lpszNameFinalDest );
                StringCchCopy( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, lpszAddlInfo );
                lpRtInfo = &lpRouter->rt_rinfo[ 0 ];
                lpRtInfo->ri_hPktz = hPktzFrom;
                lpRtInfo->ri_hRouterDest = lpMakeHopCmd->mhc_hRouterPrevHop;
                assert( lpRtInfo->ri_hRouterDest );

                /* associate us with this pktz */
                /* Note that this call will result in a call to
                    RouterConnectionComplete().  This is why we fool it
                    by saying we're connected, we ignore that call */
                lpRouter->rt_state = ROUTER_CONNECTED;
                PktzAssociateRouter( hPktzFrom, hRouter, 0 );
                lpRouter->rt_state = ROUTER_WAIT_PKTZ;

                /* get us our pktz for the other side */
                ok = RouterConnectToNode( lpRouter, 1, &wHopErr );
            }
        }
    }

    if( ok )  {
        HeapFreePtr( lpDdePkt );
    } else {
        /* send back a failure response, using the incoming packet as memory
         */
        assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
        RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
            hPktzFrom,
            hRouter,
            lpMakeHopCmd->mhc_hRouterPrevHop,
            0 /* failure */,
            wHopErr,
            ourNodeName );

        if( hRouter )  {
            RouterFree( (LPROUTER) hRouter );
        }
    }
}



VOID
RouterProcessHopRsp(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPMAKEHOPRSP        lpMakeHopRsp;
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfo;

    DIPRINTF(( "RouterProcessHopRsp( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpMakeHopRsp = (LPMAKEHOPRSP) lpDdePkt;
    lpMakeHopRsp->mhr_hRouterSendingRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterSendingRsp );
    lpMakeHopRsp->mhr_hRouterForRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterForRsp );
    lpMakeHopRsp->mhr_success =
        HostToPcWord( lpMakeHopRsp->mhr_success );
    lpMakeHopRsp->mhr_errCode =
        HostToPcWord( lpMakeHopRsp->mhr_errCode );
    lpMakeHopRsp->mhr_offsErrNode =
        HostToPcWord( lpMakeHopRsp->mhr_offsErrNode );

    assert( lpMakeHopRsp->mhr_hRouterForRsp );
    lpRouter = (LPROUTER) lpMakeHopRsp->mhr_hRouterForRsp;

    lpRouter->rt_rcvd++;

    if( lpMakeHopRsp->mhr_success )  {
        /* hop was successful! */
        assert( lpMakeHopRsp->mhr_hRouterSendingRsp != 0 );
        assert( lpRouter->rt_state == ROUTER_WAIT_MAKE_HOP_RSP );

        /* note that we are connected */
        lpRouter->rt_state = ROUTER_CONNECTED;

        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            /* local-net connection */
            lpRtInfo = &lpRouter->rt_rinfo[0];
            lpRtInfo->ri_hopRspProcessed = TRUE;
            assert( lpRtInfo->ri_hPktz == hPktzFrom );

            /* remember the router */
            lpRtInfo->ri_hRouterDest = lpMakeHopRsp->mhr_hRouterSendingRsp;
            assert( lpRtInfo->ri_hRouterDest );

            /* tell all the associated DDERs */
            DderConnectionComplete( lpRouter->rt_hDderHead,
                (HROUTER)lpRouter );

            /* free the packet */
            HeapFreePtr( lpDdePkt );
        } else {
            assert( lpRouter->rt_type == RTYPE_NET_NET );
            /* net-net connection */
            lpRtInfo = &lpRouter->rt_rinfo[1];
            lpRtInfo->ri_hopRspProcessed = TRUE;
            assert( lpRtInfo->ri_hPktz == hPktzFrom );

            /* remember the router */
            lpRtInfo->ri_hRouterDest = lpMakeHopRsp->mhr_hRouterSendingRsp;
            assert( lpRtInfo->ri_hRouterDest );

            /* send back a success response using incoming */
            lpRouter->rt_rinfo[0].ri_hopRspProcessed = TRUE;
            assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
            RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
                lpRouter->rt_rinfo[0].ri_hPktz,
                (HROUTER) lpRouter,
                lpRouter->rt_rinfo[0].ri_hRouterDest,
                1 /* success */,
                0 /* no err msg */,
                (LPSTR) NULL );
        }
    } else {
        /* hop connection failed! */
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            /* notify all DDERs of problem */
#if DBG
            RouterDisplayError( lpRouter, GetLPSZFromOffset( lpMakeHopRsp,
                    lpMakeHopRsp->mhr_offsErrNode ), lpMakeHopRsp->mhr_errCode );
#endif // DBG
            DderConnectionBroken( lpRouter->rt_hDderHead );

            /* free the packet */
            HeapFreePtr( lpDdePkt );
        } else {
            assert( lpRouter->rt_type == RTYPE_NET_NET );

            /* send back a failure response, using the incoming packet as memory */
            lpRouter->rt_rinfo[0].ri_hopRspProcessed = TRUE;
            assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );
            RouterSendHopRsp( (LPMAKEHOPRSP)lpDdePkt,
                lpRouter->rt_rinfo[0].ri_hPktz,
                (HROUTER) NULL,
                lpRouter->rt_rinfo[0].ri_hRouterDest,
                0 /* failure */,
                lpMakeHopRsp->mhr_errCode,
                GetLPSZFromOffset( lpMakeHopRsp,
                    lpMakeHopRsp->mhr_offsErrNode ) );
        }

        /* free the router */
        RouterFree( lpRouter );
    }
}


VOID
RouterProcessHopBroken(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER            lpRouter;
    LPHOPBRKCMD         lpHopBrkCmd;

    DIPRINTF(( "RouterProcessHopBroken( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpHopBrkCmd = (LPHOPBRKCMD) lpDdePkt;
    lpHopBrkCmd->hbc_hRouterForRsp =
        HostToPcLong( lpHopBrkCmd->hbc_hRouterForRsp );
    DIPRINTF(( "RouterForRsp:    \"%08lX\"", lpHopBrkCmd->hbc_hRouterForRsp ));

    if( lpHopBrkCmd->hbc_hRouterForRsp == 0 )  {
        /*  Unexpectedly got a NULL router in ProcessHopBroken! */
        NDDELogError(MSG124, NULL);
        return;
    }

    lpRouter = (LPROUTER) lpHopBrkCmd->hbc_hRouterForRsp;

    lpRouter->rt_rcvd++;

    /* hop connection failed! */
    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        assert( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom );
        RouterConnectionBroken( (HROUTER) lpRouter, 0, hPktzFrom,
            FALSE /* not from PKTZ */ );
    } else {
        if( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom )  {
            RouterConnectionBroken( (HROUTER) lpRouter, 0, hPktzFrom,
                FALSE /* not from PKTZ */ );
        } else {
            assert( lpRouter->rt_rinfo[1].ri_hPktz == hPktzFrom );
            RouterConnectionBroken( (HROUTER) lpRouter, 1, hPktzFrom,
                FALSE /* not from PKTZ */ );
        }
    }

    /* free the packet */
    HeapFreePtr( lpDdePkt );
}



VOID
RouterProcessDderPacket(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfoXfer;

    DIPRINTF(( "RouterProcessDderPacket( %08lX, %08lX )", hPktzFrom, lpDdePkt ));
    lpRouter = (LPROUTER) lpDdePkt->dp_hDstRouter;
    assert( lpRouter );

    lpRouter->rt_rcvd++;

    if( lpRouter->rt_state == ROUTER_CONNECTED )  {
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            DderPacketFromRouter( (HROUTER)lpRouter, lpDdePkt );
        } else {
            if( lpRouter->rt_rinfo[0].ri_hPktz == hPktzFrom )  {
                lpRtInfoXfer = &lpRouter->rt_rinfo[1];
            } else {
                assert( lpRouter->rt_rinfo[1].ri_hPktz == hPktzFrom );
                lpRtInfoXfer = &lpRouter->rt_rinfo[0];
            }

            /* modify the router for the next node */
            lpDdePkt->dp_hDstRouter = lpRtInfoXfer->ri_hRouterDest;
            assert( lpDdePkt->dp_hDstRouter );

            lpRouter->rt_sent++;

            /* byte-ordering */
            ConvertDdePkt( lpDdePkt );

            /* actually xmit the packet */
            if( lpRtInfoXfer->ri_hPktz )  {
                PktzLinkDdePktToXmit( lpRtInfoXfer->ri_hPktz, lpDdePkt );
            } else {
                /* link not around ... just dump it */
                HeapFreePtr( lpDdePkt );
            }
        }
    } else {
        /* destroy message */
        HeapFreePtr( lpDdePkt );
    }
}



VOID
RouterPacketFromNet(
    HPKTZ       hPktzFrom,
    LPDDEPKT    lpDdePkt )
{
    DIPRINTF(( "RouterPacketFromNet( hPktz:%08lX, %08lX )", hPktzFrom, lpDdePkt ));
    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    switch( lpDdePkt->dp_routerCmd )  {
    case RCMD_MAKE_HOP_CMD:
        assert( lpDdePkt->dp_hDstRouter == 0 );
        RouterProcessHopCmd( hPktzFrom, lpDdePkt );
        break;
    case RCMD_MAKE_HOP_RSP:
        RouterProcessHopRsp( hPktzFrom, lpDdePkt );
        break;
    case RCMD_HOP_BROKEN:
        RouterProcessHopBroken( hPktzFrom, lpDdePkt );
        break;
    case RCMD_ROUTE_TO_DDER:
        RouterProcessDderPacket( hPktzFrom, lpDdePkt );
        break;
    default:
        InternalError( "Router got unknown cmd %08lX from net",
            (DWORD) lpDdePkt->dp_routerCmd );
    }
}



/*
    RouterConnectionComplete()

        Called by PKTZ layer when the physical connection has been determined.
 */
VOID
RouterConnectionComplete(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HPKTZ   hPktz )
{
    LPROUTER            lpRouter;
    HROUTER             hRouterNext;
    HPKTZ               hPktzDisallow;
    DWORD               dwSize;
    WORD                hRouterExtraNext;
    LPMAKEHOPCMD        lpMakeHopCmd;
    LPDDEPKT            lpDdePkt;
    BOOL                ok;
    WORD                wHopErr;
    LPNIPTRS            lpNiPtrs;
    LPSTR               lpsz;
    WORD                offs;

    DIPRINTF(( "RouterConnectionComplete( %08lX, %04X, %08lX )",
            hRouter, hRouterExtra, hPktz ));

    if( hRouter == 0 )  {
        return;
    }
    lpRouter = (LPROUTER) hRouter;
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    /* remember next router to notify */
    hRouterNext = lpRouter->rt_rinfo[ hRouterExtra ].ri_hRouterNext;
    hRouterExtraNext = lpRouter->rt_rinfo[ hRouterExtra ].ri_hRouterExtraNext;

    /* only care about this if we are waiting for a pktz and haven't
        already got notified of this completion.
     */
    if( (lpRouter->rt_state == ROUTER_WAIT_PKTZ)
        && (lpRouter->rt_rinfo[ hRouterExtra ].ri_hPktz == 0) )  {

        /* save hPktz for future use */
        lpRouter->rt_rinfo[ hRouterExtra ].ri_hPktz = hPktz;

        DIPRINTF(( " Router %08lX waiting for pktz", lpRouter ));
        if( hPktz == 0 )  {
            /* physical connection failed */
            ok = FALSE;
            if( !lpRouter->rt_fSpecificNetintf )  {
                while (!ok) { /* try the next network interface */
                    if (!GetNextMappingNetIntf( &lpNiPtrs,
                        &lpRouter->rt_nLastNetintf ))
                            break;
                        if( hRouterExtra == 1 )  {
                    /* don't allow connection to same pktz as the input */
                            assert( lpRouter->rt_type == RTYPE_NET_NET );
                            hPktzDisallow = lpRouter->rt_rinfo[0].ri_hPktz;
                        } else {
                            hPktzDisallow = (HPKTZ) 0;
                        }
                ok = PktzGetPktzForRouter( lpNiPtrs, lpRouter->rt_startNode,
                            lpRouter->rt_startNode, hRouter, hRouterExtra, &wHopErr,
                            lpRouter->rt_pktz_bDisconnect, lpRouter->rt_pktz_nDelay,
                            hPktzDisallow );
            }
        }
            if( !ok )  {
                RouterCloseBeforeConnected( lpRouter, hRouterExtra );
            }
        } else {
            /* physical connection established OK */

            /* create a hop cmd */
            dwSize = sizeof(MAKEHOPCMD)
                + lstrlen(lpRouter->rt_origName) + 1
                + lstrlen(lpRouter->rt_destName ) + 1
                + lstrlen(lpRouter->rt_routeInfo ) + 1;
            lpMakeHopCmd = HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize );
            if( lpMakeHopCmd )  {
                lpDdePkt = &lpMakeHopCmd->mhc_ddePktHdr;
                lpDdePkt->dp_size = dwSize;
                lpDdePkt->dp_prev = NULL;
                lpDdePkt->dp_next = NULL;
                lpDdePkt->dp_hDstDder = 0;
                lpDdePkt->dp_hDstRouter = 0;
                lpDdePkt->dp_routerCmd = RCMD_MAKE_HOP_CMD;
                offs = sizeof(MAKEHOPCMD);

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsNameOriginator = offs;
                lstrcpy( lpsz, lpRouter->rt_origName);
                offs += lstrlen(lpsz)+1;

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsNameFinalDest = offs;
                lstrcpy( lpsz, lpRouter->rt_destName );
                offs += lstrlen(lpsz)+1;

                lpsz = ((LPSTR)lpMakeHopCmd)+offs;
                lpMakeHopCmd->mhc_offsAddlInfo = offs;
                lstrcpy( lpsz, lpRouter->rt_routeInfo );
                offs += lstrlen(lpsz)+1;

                lpMakeHopCmd->mhc_nHopsLeft = (short) lpRouter->rt_nHopsLeft;

                lpMakeHopCmd->mhc_hRouterPrevHop =
                    HostToPcLong( (HROUTER) lpRouter );
                lpMakeHopCmd->mhc_nHopsLeft =
                    HostToPcWord( lpMakeHopCmd->mhc_nHopsLeft );
                lpMakeHopCmd->mhc_offsNameOriginator =
                    HostToPcWord( lpMakeHopCmd->mhc_offsNameOriginator );
                lpMakeHopCmd->mhc_offsNameFinalDest =
                    HostToPcWord( lpMakeHopCmd->mhc_offsNameFinalDest );
                lpMakeHopCmd->mhc_offsAddlInfo =
                    HostToPcWord( lpMakeHopCmd->mhc_offsAddlInfo );

                /* set our new state */
                lpRouter->rt_state = ROUTER_WAIT_MAKE_HOP_RSP;

                DIPRINTF(( "Sending make hop cmd" ));
                /* actually xmit the packet */
                lpRouter->rt_sent++;
                /* byte-ordering */
                ConvertDdePkt( lpDdePkt );
                PktzLinkDdePktToXmit( hPktz, lpDdePkt );
            } else {
                /* no memory for next hop cmd ... fail this hop */
                RouterCloseBeforeConnected( lpRouter, hRouterExtra );
            }
        }
    }

    if( hRouterNext )  {
        RouterConnectionComplete( hRouterNext, hRouterExtraNext, hPktz );
    }
}



VOID
RouterCloseBeforeConnected(
    LPROUTER    lpRouter,
    WORD        hRouterExtra )
{
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        /* local->net */

        /* tell all DDERs of failure */
        DderConnectionComplete( lpRouter->rt_hDderHead, (HROUTER) NULL );

#if DBG
        RouterDisplayError( lpRouter, ourNodeName,
            RERR_NEXT_NODE_CONN_FAILED );
#endif // DBG
        /* close us */
        RouterFree( lpRouter );
    } else {
        /* net->net */

        /* send back NACK response to other net */
        assert( lpRouter->rt_lpMakeHopRsp );
        lpRouter->rt_rinfo[ !hRouterExtra ].ri_hopRspProcessed = TRUE;
        RouterSendHopRsp( lpRouter->rt_lpMakeHopRsp,
            lpRouter->rt_rinfo[ !hRouterExtra ].ri_hPktz,
            (HROUTER) lpRouter,
            lpRouter->rt_rinfo[ !hRouterExtra ].ri_hRouterDest,
            0 /* failure */,
            RERR_NEXT_NODE_CONN_FAILED,
            ourNodeName );
        lpRouter->rt_lpMakeHopRsp = NULL;       /* just sent it */

        /* close us */
        RouterFree( lpRouter );
    }
}

VOID
RouterSendHopRsp(
    LPMAKEHOPRSP    lpMakeHopRsp,
    HPKTZ           hPktz,
    HROUTER         hRouterSrc,
    HROUTER         hRouterDest,
    BYTE            bSucc,
    WORD            wHopErr,
    LPSTR           lpszErrNode )
{
    LPDDEPKT            lpDdePkt;
    LPSTR               lpsz;
    DWORD               dwSize;

    assert( lpMakeHopRsp );
    lpDdePkt = &lpMakeHopRsp->mhr_ddePktHdr;
    if( lpszErrNode )  {
        dwSize = sizeof(MAKEHOPRSP) + lstrlen(lpszErrNode) + 1;
    } else {
        dwSize = sizeof(MAKEHOPRSP) + 1;
    }
    lpDdePkt->dp_size = dwSize;
    lpDdePkt->dp_prev = NULL;
    lpDdePkt->dp_next = NULL;
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = hRouterDest;
    lpDdePkt->dp_routerCmd = RCMD_MAKE_HOP_RSP;
    lpMakeHopRsp->mhr_hRouterSendingRsp = hRouterSrc;
    lpMakeHopRsp->mhr_hRouterForRsp = hRouterDest;
    lpMakeHopRsp->mhr_success = bSucc;
    lpMakeHopRsp->mhr_errCode = wHopErr;
    lpMakeHopRsp->mhr_offsErrNode = sizeof(MAKEHOPRSP);
    lpsz = GetLPSZFromOffset(lpMakeHopRsp,sizeof(MAKEHOPRSP));
    if( lpszErrNode )  {
        lstrcpy( lpsz, lpszErrNode );
    } else {
        lpsz[0] = '\0';
    }

    lpMakeHopRsp->mhr_hRouterSendingRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterSendingRsp );
    lpMakeHopRsp->mhr_hRouterForRsp =
        HostToPcLong( lpMakeHopRsp->mhr_hRouterForRsp );
    lpMakeHopRsp->mhr_success =
        HostToPcWord( lpMakeHopRsp->mhr_success );
    lpMakeHopRsp->mhr_errCode =
        HostToPcWord( lpMakeHopRsp->mhr_errCode );
    lpMakeHopRsp->mhr_offsErrNode =
        HostToPcWord( lpMakeHopRsp->mhr_offsErrNode );

    /* actually xmit the packet */
    if( hRouterSrc )  {
        ((LPROUTER)hRouterSrc)->rt_sent++;
    }

    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    PktzLinkDdePktToXmit( hPktz, lpDdePkt );
}

VOID
RouterSendHopBroken(
    LPROUTER    lpRouter,
    LPRTINFO    lpRtInfo )
{
    LPHOPBRKCMD         lpHopBrkCmd;
    LPDDEPKT            lpDdePkt;

    lpHopBrkCmd = lpRtInfo->ri_lpHopBrkCmd;
    assert( lpHopBrkCmd );
    /* set to NULL to avoid being deleted twice */
    lpRtInfo->ri_lpHopBrkCmd = NULL;
    assert( lpHopBrkCmd );
    lpDdePkt = &lpHopBrkCmd->hbc_ddePktHdr;
    lpDdePkt->dp_size = sizeof(HOPBRKCMD);
    lpDdePkt->dp_prev = NULL;
    lpDdePkt->dp_next = NULL;
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = lpRtInfo->ri_hRouterDest;
    assert( lpRtInfo->ri_hRouterDest );
    lpDdePkt->dp_routerCmd = RCMD_HOP_BROKEN;
    lpHopBrkCmd->hbc_hRouterForRsp = HostToPcLong(lpRtInfo->ri_hRouterDest);
    DIPRINTF(( "Sending hop broken to %08lX", lpHopBrkCmd->hbc_hRouterForRsp ));
    assert( lpHopBrkCmd->hbc_hRouterForRsp );

    lpRouter->rt_sent++;

    /* byte-ordering */
    ConvertDdePkt( lpDdePkt );

    /* actually xmit the packet */
    assert( lpRtInfo->ri_hPktz );
    PktzLinkDdePktToXmit( lpRtInfo->ri_hPktz, lpDdePkt );
}



/*
    RouterBreak() causes the connection of a local-net to be broken
 */
VOID
RouterBreak( LPROUTER lpRouter )
{
    LPRTINFO            lpRtInfoToClose;

    assert( lpRouter );
    lpRouter->rt_state = ROUTER_DISCONNECTED;
    lpRtInfoToClose = &lpRouter->rt_rinfo[ 0 ];

    /* send a broken cmd
     */
    if( lpRtInfoToClose->ri_hPktz )  {
        if( !lpRtInfoToClose->ri_hopBrokenSent )  {
            if( lpRtInfoToClose->ri_hRouterDest )  {
                RouterSendHopBroken( lpRouter, lpRtInfoToClose );
                lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            } else {
                /* no route established - pretend we rcvd and sent */
                lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            }
        }
    } else {
        /* both sides rcvd hop broken */
        lpRtInfoToClose->ri_hopBrokenSent = TRUE;
        lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
    }

    /* free the router if we've rcvd other side */
    if( lpRtInfoToClose->ri_hopBrokenSent
        && lpRtInfoToClose->ri_hopBrokenRcvd )  {
        /* free the router */
        RouterFree( lpRouter );
    }
}



/*
    Called by PKTZ as well as internally when the connection has been
        broken.  When called by PKTZ, this means that we should no longer
        talk to that PKTZ.  If called internally, we should unlink ourselves
        from the pktz list.
 */
VOID
RouterConnectionBroken(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HPKTZ   hPktz,
    BOOL    bFromPktz )
{
    LPROUTER            lpRouter;
    LPRTINFO            lpRtInfoClosed;
    LPRTINFO            lpRtInfoToClose;
    HROUTER             hRouterNext;
    WORD                hRouterExtraNext;

    DIPRINTF(( "RouterConnectionBroken( %08lX, %04X, %08lX, %d )",
            hRouter, hRouterExtra, hPktz, bFromPktz ));
    if( hRouter == 0 )  {
        assert( bFromPktz );
        return;
    }
    lpRouter = (LPROUTER) hRouter;
#if DBG
    if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
        && (lpRouter->rt_state == ROUTER_WAIT_PKTZ) )  {

        /* show the error message */
        RouterDisplayError( lpRouter, ourNodeName,
            RERR_NEXT_NODE_CONN_FAILED );
    }
#endif // DBG

    lpRouter->rt_state = ROUTER_DISCONNECTED;

    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRtInfoClosed = &lpRouter->rt_rinfo[ hRouterExtra ];
    lpRtInfoToClose = &lpRouter->rt_rinfo[ !hRouterExtra ];

    /* remember next router to notify */
    hRouterNext = lpRtInfoClosed->ri_hRouterNext;
    hRouterExtraNext = lpRtInfoClosed->ri_hRouterExtraNext;

    if( bFromPktz )  {
        /* note that we shouldn't talk to this hPktz */
        lpRtInfoClosed->ri_hPktz = 0;
        lpRtInfoClosed->ri_hRouterPrev = 0;
        lpRtInfoClosed->ri_hRouterExtraPrev = 0;
        lpRtInfoClosed->ri_hRouterNext = 0;
        lpRtInfoClosed->ri_hRouterExtraNext = 0;
        lpRtInfoClosed->ri_hopBrokenSent = TRUE;
        lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
    } else {
        /* note that we rcvd the hop broken */
        lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;

        /* check if we already sent hop broken */
        if( !lpRtInfoClosed->ri_hopBrokenSent )  {
            /* send the hop broken back to the other side so he can close */
            if( lpRtInfoClosed->ri_hRouterDest )  {
                RouterSendHopBroken( lpRouter, lpRtInfoClosed );
                lpRtInfoClosed->ri_hopBrokenSent = TRUE;
                if( !lpRtInfoClosed->ri_hopRspProcessed )  {
                    /* we won't be hearing from this node if we never
                        sent the hop rsp
                     */
                    lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
                }
            } else {
                /* no route established - pretend we sent/rcvd */
                lpRtInfoClosed->ri_hopBrokenRcvd = TRUE;
                lpRtInfoClosed->ri_hopBrokenSent = TRUE;
            }
        }
    }


    if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
        /* notify all DDERs of problem */
        DderConnectionBroken( lpRouter->rt_hDderHead );

        /* free the router */
        RouterFree( lpRouter );
    } else {
        /* send back a broken cmd
         */
        if( lpRtInfoToClose->ri_hPktz )  {
            if( !lpRtInfoToClose->ri_hopBrokenSent )  {
                if( lpRtInfoToClose->ri_hRouterDest )  {
                    RouterSendHopBroken( lpRouter, lpRtInfoToClose );
                    lpRtInfoToClose->ri_hopBrokenSent = TRUE;
                    if( !lpRtInfoToClose->ri_hopRspProcessed )  {
                        /* we won't be hearing from this node if we never
                            sent the hop rsp
                         */
                        lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                    }
                } else {
                    /* no route established - pretend we sent/rcvd */
                    lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
                    lpRtInfoToClose->ri_hopBrokenSent = TRUE;
                }
            }
        } else {
            /* both sides rcvd hop broken */
            lpRtInfoToClose->ri_hopBrokenSent = TRUE;
            lpRtInfoToClose->ri_hopBrokenRcvd = TRUE;
        }

        /* free the router if we've rcvd other side */
        if( lpRtInfoToClose->ri_hopBrokenSent
            && lpRtInfoToClose->ri_hopBrokenRcvd )  {
            /* free the router */
            RouterFree( lpRouter );
        }
    }

    if( hRouterNext && bFromPktz )  {
        RouterConnectionBroken( hRouterNext, hRouterExtraNext,
            hPktz, bFromPktz );
    }
}



VOID
RouterGetNextForPktz(
    HROUTER         hRouter,
    WORD            hRouterExtra,
    HROUTER FAR    *lphRouterNext,
    WORD FAR       *lphRouterExtraNext )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    *lphRouterNext = lpRtInfo->ri_hRouterNext;
    *lphRouterExtraNext = lpRtInfo->ri_hRouterExtraNext;
}



VOID
RouterGetPrevForPktz(   HROUTER hRouter,
                        WORD hRouterExtra,
                        HROUTER FAR *lphRouterPrev,
                        WORD FAR *lphRouterExtraPrev )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    *lphRouterPrev = lpRtInfo->ri_hRouterPrev;
    *lphRouterExtraPrev = lpRtInfo->ri_hRouterExtraPrev;
}



VOID
RouterSetNextForPktz(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HROUTER hRouterNext,
    WORD    hRouterExtraNext )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    lpRtInfo->ri_hRouterNext            = hRouterNext;
    lpRtInfo->ri_hRouterExtraNext       = hRouterExtraNext;
}



VOID
RouterSetPrevForPktz(
    HROUTER hRouter,
    WORD    hRouterExtra,
    HROUTER hRouterPrev,
    WORD    hRouterExtraPrev )
{
    LPROUTER    lpRouter;
    LPRTINFO    lpRtInfo;

    assert( hRouter );
    assert( (hRouterExtra == 0) || (hRouterExtra == 1) );

    lpRouter = (LPROUTER) hRouter;
    lpRtInfo = &lpRouter->rt_rinfo[ hRouterExtra ];

    lpRtInfo->ri_hRouterPrev            = hRouterPrev;
    lpRtInfo->ri_hRouterExtraPrev       = hRouterExtraPrev;
}



VOID
RouterPacketFromDder(
    HROUTER     hRouter,
    HDDER       hDder,
    LPDDEPKT    lpDdePkt )
{
    LPROUTER    lpRouter;
    DIPRINTF(( "RouterPacketFromDder( %08lX, %08lX, %08lX )", hRouter, hDder, lpDdePkt ));

    lpRouter = (LPROUTER) hRouter;

    /* ignore packet if not connected */
    if( lpRouter->rt_state == ROUTER_CONNECTED )  {
        assert( lpRouter->rt_type == RTYPE_LOCAL_NET );
        lpDdePkt->dp_hDstRouter = lpRouter->rt_rinfo[0].ri_hRouterDest;
        assert( lpRouter->rt_rinfo[0].ri_hRouterDest );
        lpDdePkt->dp_routerCmd = RCMD_ROUTE_TO_DDER;

        DIPRINTF(( "Sending DDER cmd" ));
        lpRouter->rt_sent++;

        /* byte-ordering */
        ConvertDdePkt( lpDdePkt );

        /* actually xmit the packet */
        PktzLinkDdePktToXmit( lpRouter->rt_rinfo[0].ri_hPktz, lpDdePkt );
    } else {
        /* we aren't connected - destroy this msg */
        HeapFreePtr( lpDdePkt );
    }
}



VOID
RouterAssociateDder(
    HROUTER hRouter,
    HDDER   hDder )
{
    LPROUTER    lpRouter;

    DIPRINTF(( "RouterAssociateDder( %08lX, %08lX )", hRouter, hDder ));
    lpRouter = (LPROUTER) hRouter;
    if( hDder )  {
        if((lpRouter->rt_hDderHead == 0) && lpRouter->rt_hTimerCloseRoute){
            /* kill the timer for this route */
            TimerDelete( lpRouter->rt_hTimerCloseRoute );
            lpRouter->rt_hTimerCloseRoute = 0;
        }

        /* link into list of associated DDERs */
        if( lpRouter->rt_hDderHead )  {
            DderSetPrevForRouter( lpRouter->rt_hDderHead, hDder );
        }
        DderSetNextForRouter( hDder, lpRouter->rt_hDderHead );
        lpRouter->rt_hDderHead = hDder;

        switch( lpRouter->rt_state )  {
        case ROUTER_CONNECTED:
            /* already has connection set up */
            DderConnectionComplete( hDder, (HROUTER) lpRouter );
            break;
        }
    }
}



VOID
RouterDisassociateDder(
    HROUTER hRouter,
    HDDER   hDder )
{
    LPROUTER    lpRouter;
    HDDER       hDderPrev;
    HDDER       hDderNext;

    DIPRINTF(( "RouterDisassociateDder( %08lX, %08lX )", hRouter, hDder ));
    lpRouter = (LPROUTER) hRouter;
    DderGetNextForRouter( hDder, &hDderNext );
    DderGetPrevForRouter( hDder, &hDderPrev );
    if( hDderPrev )  {
        DderSetNextForRouter( hDderPrev, hDderNext );
    } else {
        lpRouter->rt_hDderHead = hDderNext;
    }
    if( hDderNext )  {
        DderSetPrevForRouter( hDderNext, hDderPrev );
    }
    if( lpRouter->rt_fDisconnect
        && (lpRouter->rt_type == RTYPE_LOCAL_NET)
        && (lpRouter->rt_hDderHead == 0) )  {
        lpRouter->rt_hTimerCloseRoute = TimerSet(
            lpRouter->rt_nDelay * 1000L, RouterTimerExpired,
            (DWORD_PTR)lpRouter, TID_CLOSE_ROUTE, (DWORD_PTR)NULL );
        if( lpRouter->rt_hTimerCloseRoute == (HTIMER) NULL )  {
            /*  %1 will not auto-close ... not enough timers    */
            NDDELogError(MSG105, "Route", NULL);
        }
    }
}



VOID
RouterTimerExpired(
    HROUTER hRouter,
    DWORD   dwTimerId,
    DWORD_PTR lpExtra )
{
    LPROUTER    lpRouter = (LPROUTER) hRouter;
    switch( (int)dwTimerId )  {
    case TID_CLOSE_ROUTE:
        /* note that timer went off */
        lpRouter->rt_hTimerCloseRoute = 0;

        /* close the route */
        RouterBreak( (LPROUTER) hRouter );
        break;
    default:
        InternalError( "Unexpected router timer id: %08lX", dwTimerId );
    }
}



/*
    RouterGetRouterForDder()

        Establishes a connection to the specified node name and tells the DDER
        of the result via a call to DderConnectionComplete() when done
 */
BOOL
RouterGetRouterForDder(
    const LPSTR lpszNodeName,
    HDDER       hDder )
{
    LPROUTER    lpRouter;
    HROUTER     hRouter;
    BOOL        found;
    BOOL        ok;

    lpRouter = lpRouterHead;
    found = FALSE;
    ok = FALSE;
    while( !found && lpRouter )  {
        if( (lpRouter->rt_type != RTYPE_NET_NET)
            && (lpRouter->rt_state != ROUTER_DISCONNECTED)
            && (lstrcmpi( lpszNodeName, lpRouter->rt_destName ) == 0) )  {
            found = TRUE;

            /* tell this router that this DDER should be associated */
            RouterAssociateDder( (HROUTER)lpRouter, hDder );
            ok = TRUE;
        }
        lpRouter = lpRouter->rt_next;
    }
    if( !found )  {
        /* create a new router for this connection */
        hRouter = RouterCreateLocalToNet( lpszNodeName );
        if( hRouter )  {
            lpRouter = (LPROUTER) hRouter;

            /* tell this router that this DDER should be associated */
            RouterAssociateDder( (HROUTER)lpRouter, hDder );

            ok = TRUE;
        } else {
            ok = FALSE;
        }
    }

    return( ok );
}



HROUTER
RouterCreateLocalToNet( const LPSTR lpszNodeName )
{
    HROUTER     hRouter;
    LPROUTER    lpRouter;
    BOOL        ok = TRUE;
    WORD        wHopErr;

    hRouter = RouterCreate();
    if( hRouter )  {
        lpRouter = (LPROUTER) hRouter;
        lpRouter->rt_type = RTYPE_LOCAL_NET;
        StringCchCopy( lpRouter->rt_origName, MAX_NODE_NAME+1, ourNodeName );
        StringCchCopy( lpRouter->rt_destName, MAX_NODE_NAME+1, lpszNodeName );

        if( GetRoutingInfo( lpszNodeName, lpRouter->rt_routeInfo,
            sizeof(lpRouter->rt_routeInfo),
            &lpRouter->rt_fDisconnect, &lpRouter->rt_nDelay ) )  {
            /* found an entry in the routing table */
        } else if( szDefaultRoute[0] != '\0' )  {
            /* there is a default route ... prepend the default route +
                this node name */
            if( (_fstrlen( szDefaultRoute ) + 1 + _fstrlen(lpszNodeName)) >
                MAX_ROUTE_INFO )  {
                wHopErr = RERR_ROUTE_TOO_LONG;
                ok = FALSE;
            } else {
                StringCchCopy( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, szDefaultRoute );
                if( lpszNodeName[0] != '\0' )  {
                    if (lstrcmpi( szDefaultRoute, lpszNodeName)) {
                        StringCchCat( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, "+" );
                        StringCchCat( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, lpszNodeName );
                    }
                }
            }
        } else {
            /* no entry in routing table and no default ... just use the
                node name as the route */
            StringCchCopy( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, lpszNodeName );
        }

        if( ok )  {
            ok = RouterConnectToNode( lpRouter, 0, &wHopErr );
        }
        if( !ok )  {
#if DBG
            RouterDisplayError( lpRouter, ourNodeName, wHopErr );
#endif // DBG
            RouterFree( (LPROUTER) hRouter );
            hRouter = (HROUTER) NULL;
        }
    }

    return( hRouter );
}



/*
    RouterConnectToNode()
 */
BOOL
RouterConnectToNode(
    LPROUTER    lpRouter,
    WORD        hRouterExtra,
    WORD FAR   *lpwHopErr )
{
    LPNIPTRS    lpNiPtrs;
    char        nodeStart[ MAX_NODE_NAME+1 ];
    char        szNetintf[ MAX_NI_NAME+1 ];
    char        szConnInfo[ MAX_CONN_INFO+1 ];
    BOOL        bDisconnect;
    int         nDelay;
    BOOL        ok = TRUE;
    BOOL        found;
    HPKTZ       hPktzDisallow;

    /* this is in here just to be sure that it's checked */
    assert( sizeof(MAKEHOPRSP) <= sizeof(MAKEHOPCMD) );

    /* expand the first node to it's fullest */
    ok = RouterExpandFirstNode( lpRouter, lpwHopErr );
    if( ok )  {
        lpRouter->rt_state = ROUTER_WAIT_PKTZ;

        /* strip off the starting node from the addl info */
        ok = RouterStripStartingNode( lpRouter->rt_routeInfo, nodeStart,
            lpwHopErr );
    }

    if( !ok )
        return(ok);
    ok = FALSE;

    lpRouter->rt_nLastNetintf = -1;
    while (!ok && !lpRouter->rt_fSpecificNetintf) {
        found = GetConnectionInfo( nodeStart, szNetintf, szConnInfo,
            sizeof(szConnInfo), &bDisconnect, &nDelay );
        if( found && (szNetintf[0] != '\0') )  {
            lpRouter->rt_fSpecificNetintf = TRUE;
            if( !NameToNetIntf( szNetintf, &lpNiPtrs ) )  {
                *lpwHopErr = RERR_CONN_NETINTF_INVALID;
                return(ok);
            }
        } else {
            lpRouter->rt_fSpecificNetintf = FALSE;
            StringCchCopy( szConnInfo, MAX_CONN_INFO+1, nodeStart );
            StringCchCopy( lpRouter->rt_startNode, MAX_NODE_NAME+1, nodeStart );
            if ( !GetNextMappingNetIntf( &lpNiPtrs,
                    &lpRouter->rt_nLastNetintf ) )  {
                *lpwHopErr = RERR_CONN_NO_MAPPING_NI;
                return(ok);
            }
        }

        assert( (hRouterExtra == 0) || (hRouterExtra == 1) );
        lpRouter->rt_pktz_bDisconnect = bDisconnect;
        lpRouter->rt_pktz_nDelay = nDelay;
        if( hRouterExtra == 1 )  {
            /* don't allow connection to same pktz as the input */
            assert( lpRouter->rt_type == RTYPE_NET_NET );
            hPktzDisallow = lpRouter->rt_rinfo[0].ri_hPktz;
        } else {
            hPktzDisallow = (HPKTZ) NULL;
        }
        ok = PktzGetPktzForRouter( lpNiPtrs, nodeStart, szConnInfo,
            (HROUTER)lpRouter, hRouterExtra, lpwHopErr,
            lpRouter->rt_pktz_bDisconnect, lpRouter->rt_pktz_nDelay,
            hPktzDisallow );
    }

    return( ok );
}



BOOL
RouterExpandFirstNode(
    LPROUTER    lpRouter,
    WORD FAR   *lpwHopErr )
{
    char        routeInfo[ MAX_ROUTE_INFO+1 ];
    char        expandedStartNodeInfo[ MAX_ROUTE_INFO+1 ];
    char        startNode[ MAX_NODE_NAME+1 ];
    char        lastRouteInfo[ MAX_ROUTE_INFO+1 ];
    BOOL        ok = TRUE;
    BOOL        done = FALSE;
    BOOL        bDisconnect;
    int         nDelay;
    int         nExpands = 0;   /* here just in case there is some odd
                                    case that we don't catch */

    StringCchCopy( lastRouteInfo, MAX_ROUTE_INFO+1, lpRouter->rt_routeInfo );

    while( ok && !done && (++nExpands < 100) )  {
        StringCchCopy( routeInfo, MAX_ROUTE_INFO+1, lpRouter->rt_routeInfo );
        ok = RouterStripStartingNode( routeInfo, startNode, lpwHopErr );
        if( ok )  {
            if( GetRoutingInfo( startNode, expandedStartNodeInfo,
                   sizeof(expandedStartNodeInfo), &bDisconnect, &nDelay ) )  {
                if( (_fstrlen( routeInfo ) + 1
                     + _fstrlen(expandedStartNodeInfo)) > MAX_ROUTE_INFO ) {
                    *lpwHopErr = RERR_ROUTE_TOO_LONG;
                    ok = FALSE;
                } else {
                    StringCchCopy( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, expandedStartNodeInfo );
                    if( routeInfo[0] != '\0' )  {
                        StringCchCat( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, "+" );
                        StringCchCat( lpRouter->rt_routeInfo, MAX_ROUTE_INFO+1, routeInfo );
                    }
                }
            } else {
                /* start node not found in routing table */
                done = TRUE;
            }
        }
        if( lstrcmpi( lpRouter->rt_routeInfo, lastRouteInfo ) == 0 ) {
            /* hasn't changed */
            done = TRUE;
        }
        if (ok) {
            StringCchCopy( lastRouteInfo, MAX_ROUTE_INFO+1, lpRouter->rt_routeInfo );
        }
    }

    if( nExpands >= 100 )  {
        /*  Exceeded 100 expands in routing lookup!
            Route info bogus: %1    */
        NDDELogError(MSG125, routeInfo, NULL);
    }
    return( ok );
}



/*
    RouterStripStartingNode()

        This routine will take the "routeInfo" as an input and will strip
        off 1 node name, returning that in lpszNode.  Thus, both
        lpszRouteInfo and lpszNode will be modified
 */
BOOL
RouterStripStartingNode(
    LPSTR       lpszRouteInfo,
    LPSTR       lpszNode,
    WORD FAR   *lpwHopErr )
{
    LPSTR       lpszTok;

    lpszTok = _fstrchr( lpszRouteInfo, '+' );
    if( lpszTok )  {
        *lpszTok = '\0';
        if( lstrlen( lpszRouteInfo ) > MAX_NODE_NAME )  {
            *lpwHopErr = RERR_NODE_NAME_TOO_LONG;
            return( FALSE );
        }
        StringCchCopy( lpszNode, MAX_NODE_NAME+1, lpszRouteInfo );
        StringCchCopy( lpszRouteInfo, MAX_ROUTE_INFO+1, lpszTok+1 );
    } else {
        /* all one token */
        if( lstrlen( lpszRouteInfo ) > MAX_NODE_NAME )  {
            *lpwHopErr = RERR_NODE_NAME_TOO_LONG;
            return( FALSE );
        }
        StringCchCopy( lpszNode, MAX_NODE_NAME+1, lpszRouteInfo );
        lpszRouteInfo[0] = '\0';
    }
    return( TRUE );
}



VOID
RouterFree( LPROUTER lpRouter )
{
    LPROUTER    lpRouterPrev;
    LPROUTER    lpRouterNext;
    int         i;
    LPRTINFO    lpRtInfo;

    DIPRINTF(( "RouterFree( %08lX )", lpRouter ));
    /* free response buffers */
    if( lpRouter->rt_lpMakeHopRsp )  {
        HeapFreePtr( lpRouter->rt_lpMakeHopRsp );
        lpRouter->rt_lpMakeHopRsp = NULL;
    }

    /* kill timer if it's alive */
    if( lpRouter->rt_hTimerCloseRoute )  {
        TimerDelete( lpRouter->rt_hTimerCloseRoute );
        lpRouter->rt_hTimerCloseRoute = 0;
    }

    /* unlink from Pktz lists */
    for( i=0; i<2; i++ )  {
        lpRtInfo = &lpRouter->rt_rinfo[i];
        if( lpRtInfo->ri_lpHopBrkCmd )  {
            HeapFreePtr( lpRtInfo->ri_lpHopBrkCmd );
            lpRtInfo->ri_lpHopBrkCmd = NULL;
        }

        if( lpRtInfo->ri_hPktz )  {
            PktzDisassociateRouter( lpRtInfo->ri_hPktz,
                (HROUTER) lpRouter, (WORD) i );
            lpRtInfo->ri_hPktz = 0;
        }
    }

    /* unlink from Router list */
    lpRouterPrev = lpRouter->rt_prev;
    lpRouterNext = lpRouter->rt_next;
    if( lpRouterPrev )  {
        lpRouterPrev->rt_next = lpRouterNext;
    } else {
        lpRouterHead = lpRouterNext;
    }
    if( lpRouterNext )  {
        lpRouterNext->rt_prev = lpRouterPrev;
    }

    HeapFreePtr( lpRouter );
}



#if DBG
VOID
FAR PASCAL
DebugRouterState( void )
{
    LPROUTER    lpRouter;

    lpRouter = lpRouterHead;
    DPRINTF(( "ROUTER State:" ));
    while( lpRouter )  {
        DPRINTF(( "  %Fp:\n"
                  "  rt_prev      %Fp\n"
                  "  rt_next      %Fp\n"
                  "  rt_state     %d\n"
                  "  rt_type      %d\n"
                  "  rt_origName  %Fs\n"
                  "  rt_destName  %Fs\n"
                  "  rt_startNode %Fs\n"
                  "  rt_sent      %ld\n"
                  "  rt_rcvd      %ld\n"
                  ,
            lpRouter,
            lpRouter->rt_prev,
            lpRouter->rt_next,
            lpRouter->rt_state,
            lpRouter->rt_type,
            lpRouter->rt_origName,
            lpRouter->rt_destName,
            lpRouter->rt_startNode,
            lpRouter->rt_sent,
            lpRouter->rt_rcvd ));
        DPRINTF(( "    %d %d %d %d %d %d %d \"%Fs\" %Fp",
            lpRouter->rt_fDisconnect,
            lpRouter->rt_nDelay,
            lpRouter->rt_fSpecificNetintf,
            lpRouter->rt_nLastNetintf,
            lpRouter->rt_nHopsLeft,
            lpRouter->rt_pktz_bDisconnect,
            lpRouter->rt_pktz_nDelay,
            lpRouter->rt_routeInfo,
            lpRouter->rt_hDderHead ));
        DPRINTF(( "    0: %Fp %Fp %Fp %d %Fp %d %d %d %d",
            lpRouter->rt_rinfo[0].ri_hPktz,
            lpRouter->rt_rinfo[0].ri_hRouterDest,
            lpRouter->rt_rinfo[0].ri_hRouterPrev,
            lpRouter->rt_rinfo[0].ri_hRouterExtraPrev,
            lpRouter->rt_rinfo[0].ri_hRouterNext,
            lpRouter->rt_rinfo[0].ri_hRouterExtraNext,
            lpRouter->rt_rinfo[0].ri_hopRspProcessed,
            lpRouter->rt_rinfo[0].ri_hopBrokenSent,
            lpRouter->rt_rinfo[0].ri_hopBrokenRcvd ));
        DPRINTF(( "    1: %Fp %Fp %Fp %d %Fp %d %d %d %d",
            lpRouter->rt_rinfo[1].ri_hPktz,
            lpRouter->rt_rinfo[1].ri_hRouterDest,
            lpRouter->rt_rinfo[1].ri_hRouterPrev,
            lpRouter->rt_rinfo[1].ri_hRouterExtraPrev,
            lpRouter->rt_rinfo[1].ri_hRouterNext,
            lpRouter->rt_rinfo[1].ri_hRouterExtraNext,
            lpRouter->rt_rinfo[0].ri_hopRspProcessed,
            lpRouter->rt_rinfo[1].ri_hopBrokenSent,
            lpRouter->rt_rinfo[1].ri_hopBrokenRcvd ));
        lpRouter = lpRouter->rt_next;
    }
}
#endif // DBG


#ifdef  _WINDOWS
VOID
RouterCloseByName( LPSTR lpszName )
{
    LPROUTER    lpRouter;
    LPROUTER    lpRouterNext;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpszName ) == 0) )  {
            RouterBreak( lpRouter );
            break;      // while loop
        }
        lpRouter = lpRouterNext;
    }
}



BOOL
FAR PASCAL
RouterCloseByCookie( LPSTR lpszName, DWORD_PTR dwCookie )
{
    LPROUTER    lpRouter;
    LPROUTER    lpRouterNext;
    BOOL	bKilled = FALSE;

    lpRouter = lpRouterHead;
    while( !bKilled && lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpszName ) == 0)
            && (dwCookie == (DWORD_PTR)lpRouter) )  {
            RouterBreak( lpRouter );
            bKilled = TRUE;
        }
        lpRouter = lpRouterNext;
    }
    return( bKilled );
}



int
FAR PASCAL
RouterCount( void )
{
    LPROUTER    lpRouter;
    int		nCount = 0;

    lpRouter = lpRouterHead;
    while( lpRouter )  {
        nCount++;
        lpRouter = lpRouter->rt_next;
    }
    return( nCount );
}



VOID
FAR PASCAL
RouterFillInEnum( LPSTR lpBuffer, DWORD cBufSize )
{
    LPROUTER    	lpRouter;
    int             nCount = 0;
    DWORD           cbDone = 0;
    LPDDESESSINFO	lpDdeSessInfo;

    lpRouter = lpRouterHead;
    lpDdeSessInfo = (LPDDESESSINFO)lpBuffer;
    /* as long as there are routers and memory available */
    while( lpRouter && ((cbDone + sizeof(DDESESSINFO)) <= cBufSize) )  {
        if( lpRouter->rt_type == RTYPE_LOCAL_NET )  {
            StringCchCopy( lpDdeSessInfo->ddesess_ClientName, UNCLEN+1,
                lpRouter->rt_destName );
            lpDdeSessInfo->ddesess_Status = lpRouter->rt_state;
            lpDdeSessInfo->ddesess_Cookie = (DWORD_PTR)lpRouter;
            cbDone += sizeof(DDESESSINFO);
            lpDdeSessInfo++;
        }
        lpRouter = lpRouter->rt_next;
    }
}



VOID
FAR PASCAL
RouterFillInConnInfo(
    LPROUTER 		lpRouter,
    LPCONNENUM_CMR 	lpConnEnum,
    LPSTR		lpDataStart,
    LPWORD		lpcFromBeginning,
    LPWORD		lpcFromEnd )
{
    HDDER		hDder;

    hDder = lpRouter->rt_hDderHead;
    /* as long as there are DDERs and memory available */
    while( hDder )  {
        hDder = DderFillInConnInfo( hDder, lpConnEnum,
            lpDataStart, lpcFromBeginning, lpcFromEnd );
    }
}



VOID
FAR PASCAL
RouterEnumConnectionsForApi( LPCONNENUM_CMR lpConnEnum )
{
    LPROUTER    	lpRouter;
    LPROUTER    	lpRouterNext;
    BOOL		bFound = FALSE;
    DWORD		cbDone;
    WORD		cFromBeginning;
    WORD		cFromEnd;

    lpConnEnum->lReturnCode = NDDE_INVALID_SESSION;
    lpRouter = lpRouterHead;
    while( !bFound && lpRouter )  {
        lpRouterNext = lpRouter->rt_next;
        if( (lpRouter->rt_type == RTYPE_LOCAL_NET)
            && (lpRouter->rt_state == ROUTER_CONNECTED)
            && (lstrcmpi( lpRouter->rt_destName, lpConnEnum->clientName) == 0)
            && (lpConnEnum->cookie == (DWORD_PTR)lpRouter) )  {
            cbDone = 0;
            lpConnEnum->lReturnCode = NDDE_NO_ERROR;
            lpConnEnum->nItems = 0;
            lpConnEnum->cbTotalAvailable = 0;
            cFromBeginning = 0;
            cFromEnd = (WORD)lpConnEnum->cBufSize;
            bFound = TRUE;
            RouterFillInConnInfo( lpRouter, lpConnEnum,
                (((LPSTR)lpConnEnum) + sizeof(CONNENUM_CMR)),
                &cFromBeginning,
                &cFromEnd );
        }
        lpRouter = lpRouterNext;
    }
}

#endif // _WINDOWS



#ifdef  BYTE_SWAP
VOID
ConvertDdePkt( LPDDEPKT lpDdePkt )
{
    lpDdePkt->dp_hDstRouter = HostToPcLong( lpDdePkt->dp_hDstRouter );
    lpDdePkt->dp_routerCmd = HostToPcLong( lpDdePkt->dp_routerCmd );
}
#endif // BYTE_SWAP



#if DBG
VOID
RouterDisplayError(
    LPROUTER    lpRouter,
    LPSTR       lpszNode,
    WORD        wHopErr )
{
    DWORD       EventId = MSG130;

    if (wHopErr < RERR_MAX_ERR ) {
        EventId += wHopErr;
    }
    NDDELogError(EventId, LogString("%d", wHopErr),
        lpRouter->rt_origName, lpRouter->rt_destName, lpszNode, NULL );
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\timer.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "TIMER.C;1  16-Dec-92,10:21:24  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include <time.h>

#include    "host.h"
#include    "windows.h"
#include    "netbasic.h"
#include    "timer.h"
#include    "debug.h"
#include    "internal.h"
#include    "wwassert.h"

USES_ASSERT

#define TM_MAGIC 0x72732106

typedef struct s_timer {
    struct s_timer FAR  *tm_prev;
    struct s_timer FAR  *tm_next;
    long                 tm_magic;
    time_t               tm_expireTime;
    FP_TimerCallback     tm_timerCallback;
    DWORD_PTR            tm_dwUserInfo1;
    DWORD                tm_dwUserInfo2;
    DWORD_PTR            tm_dwUserInfo3;
} TIMER;
typedef TIMER FAR *LPTIMER;

#ifdef  DEBUG_TIMERS
VOID DebugTimerList( void );
#endif

/*
    Local variables
 */
LPTIMER         lpTimerHead = NULL;
LPTIMER         lpTimerTail = NULL;

#ifdef  DEBUG_TIMERS
static int  TimerLock = 0;
#endif


#ifdef  DEBUG_TIMERS
VOID
VerifyTimerList( void )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerPrev, lpTimerNext;

    if( lpTimerHead )  {
        if (lpTimer = lpTimerHead->tm_prev) {
            DebugTimerList();
        }
        assert( lpTimerHead->tm_prev == NULL );
    } else {
        assert( lpTimerTail == NULL );
    }
    if( lpTimerTail )  {
        assert( lpTimerTail->tm_next == NULL );
    } else {
        assert( lpTimerHead == NULL );
    }

    lpTimer = lpTimerHead;
    lpTimerPrev = NULL;
    while( lpTimer )  {
        assert( lpTimer->tm_magic == TM_MAGIC );
        assert( lpTimerPrev == lpTimer->tm_prev );
        if( !lpTimer->tm_prev )  {
            assert( lpTimer == lpTimerHead );
        }
        if( !lpTimer->tm_next )  {
            assert( lpTimer == lpTimerTail );
        }
        lpTimerPrev = lpTimer;
        lpTimer = lpTimer->tm_next;
    }
    assert( lpTimerTail == lpTimerPrev );
}
#endif

#if DBG
#ifdef DEBUG_TIMERS
VOID DebugTimerList( void )
{
    LPTIMER     lpTimer;

    DPRINTF(( "Timer List @ %ld: ", time(NULL) ));
    if (!(lpTimer = lpTimerHead)) {
        return;
    }
    if (lpTimer->tm_prev) {
        DPRINTF(("Timer list going backwards from: %p!", lpTimer));
        lpTimer = lpTimer->tm_prev;
    while( lpTimer )  {
        DPRINTF(( "%08lX mg: %08X, pr:%08lX, nxt:%08lX, expTime:%ld %08lX %08lX %08lX",
            lpTimer, lpTimer->tm_magic,
            lpTimer->tm_prev, lpTimer->tm_next, lpTimer->tm_expireTime,
            lpTimer->tm_timerCallback, lpTimer->tm_dwUserInfo1,
            lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 ));
        lpTimer = lpTimer->tm_prev;
    }
    lpTimer = lpTimerHead;
    DPRINTF(("Timer list now going forward starting at: %p.", lpTimer));
    }
    while( lpTimer )  {
        DPRINTF(( "%08lX mg: %08X, pr:%08lX, nxt:%08lX, expTime:%ld %08lX %08lX %08lX",
            lpTimer, lpTimer->tm_magic,
            lpTimer->tm_prev, lpTimer->tm_next, lpTimer->tm_expireTime,
            lpTimer->tm_timerCallback, lpTimer->tm_dwUserInfo1,
            lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 ));
        lpTimer = lpTimer->tm_next;
    }
    DPRINTF(( "" ));
}
#endif // DEBUG_TIMERS
#endif // DBG

HTIMER
TimerSet(
    long                timeoutPeriod,          /* msec */
    FP_TimerCallback    TimerCallback,
    DWORD_PTR           dwUserInfo1,
    DWORD               dwUserInfo2,
    DWORD_PTR           dwUserInfo3 )
{
    LPTIMER     lpTimer;
    long        timeInSecs;

    timeInSecs = (timeoutPeriod + 999L ) / 1000L;

#ifdef  DEBUG_TIMERS
    assert( TimerLock++ == 0);
    VerifyTimerList();
#endif

    lpTimer = (LPTIMER) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        (DWORD) sizeof( TIMER ) );
    if( lpTimer )  {
        lpTimer->tm_magic               = TM_MAGIC;
        lpTimer->tm_prev                = lpTimerTail;
        lpTimer->tm_next                = NULL;
        lpTimer->tm_expireTime          = time(NULL) + timeInSecs;
        lpTimer->tm_timerCallback       = TimerCallback;
        lpTimer->tm_dwUserInfo1         = dwUserInfo1;
        lpTimer->tm_dwUserInfo2         = dwUserInfo2;
        lpTimer->tm_dwUserInfo3         = dwUserInfo3;

        if( lpTimerTail )  {
            lpTimerTail->tm_next = lpTimer;
        } else {
            lpTimerHead = lpTimer;
        }
        lpTimerTail = lpTimer;
#ifdef  DEBUG_TIMERS
        VerifyTimerList();
#endif
    }
#ifdef  DEBUG_TIMERS
    TimerLock--;
#endif
    return( (HTIMER) lpTimer );
}

BOOL
TimerDelete( HTIMER hTimer )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerPrev;
    LPTIMER     lpTimerNext;

#ifdef  DEBUG_TIMERS
    assert( TimerLock++ == 0 );
#endif
    if( hTimer )  {
        lpTimer = (LPTIMER) hTimer;
#ifdef  DEBUG_TIMERS
        assert( lpTimer->tm_magic == TM_MAGIC );
        VerifyTimerList();
#endif
        /* delete from list */
        lpTimerPrev = lpTimer->tm_prev;
        lpTimerNext = lpTimer->tm_next;

        if( lpTimerPrev )  {
            lpTimerPrev->tm_next = lpTimerNext;
        } else {
            lpTimerHead = lpTimerNext;
        }
        if( lpTimerNext )  {
            lpTimerNext->tm_prev = lpTimerPrev;
        } else {
            lpTimerTail = lpTimerPrev;
        }
        lpTimer->tm_magic = 0;
        HeapFreePtr( lpTimer );
    }
#ifdef  DEBUG_TIMERS
    VerifyTimerList();
    TimerLock--;
#endif
    return( TRUE );
}

VOID
TimerSlice( void )
{
    LPTIMER     lpTimer;
    LPTIMER     lpTimerNext;
    LPTIMER     lpTimerPrev;
    time_t      timeNow;
    BOOL        bAnyTimersHit = TRUE;
    static time_t LastTime = 0;

#ifdef  DEBUG_TIMERS
    VerifyTimerList();
#endif

    timeNow = time( NULL );

// the following is an optimization: if we
// get called in the same second as the last call we exit
// without checking the whole list of timers with predictable
// results.

	if ( timeNow == LastTime )
		return;
	else
		LastTime = timeNow;
    while( bAnyTimersHit )  {
        bAnyTimersHit = FALSE;
        lpTimer = lpTimerHead;
        while( lpTimer && !bAnyTimersHit )  {
            assert( lpTimer->tm_magic == TM_MAGIC );
            lpTimerNext = lpTimer->tm_next;
            lpTimerPrev = lpTimer->tm_prev;
            if( timeNow >= lpTimer->tm_expireTime )  {
                (*lpTimer->tm_timerCallback)( lpTimer->tm_dwUserInfo1,
                    lpTimer->tm_dwUserInfo2, lpTimer->tm_dwUserInfo3 );
#ifdef  DEBUG_TIMERS
                DPRINTF(("TimerSlice return: %p<-%p->%p", lpTimerPrev, lpTimer, lpTimerNext));
#endif
                TimerDelete( (HTIMER) lpTimer );
#ifdef  DEBUG_TIMERS
                DPRINTF(("TimerHead: %p", lpTimerHead));
#endif

                /* since many timers may be deleted when we call this routine
                    we mark that we hit a timer and then we start over from
                    the beginning of the list
                 */
                bAnyTimersHit = TRUE;
            }
            lpTimer = lpTimerNext;
        }
    }
#ifdef  DEBUG_TIMERS
    VerifyTimerList();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\userdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "USERDDE.C;2  4-Dec-92,12:23:48  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    "host.h"

#include    <memory.h>
#include    <string.h>

#include    "windows.h"
#include    "dde.h"
#include    "netbasic.h"
#include    "wwdde.h"
#include    "ddepkt.h"
#include    "ddepkts.h"
#include    "userdde.h"
#include    "debug.h"
#include    "hexdump.h"
#include    "api1632.h"
#include    "nddemsg.h"
#include    "nddelog.h"



#define MAX_CF_NAME     128

/*
    External variables used
 */
#if DBG
extern  BOOL    bDebugDdePkts;
#endif // DBG
extern  HHEAP   hHeap;
extern  char    ourNodeName[ MAX_NODE_NAME+1 ];
extern  DWORD   dwReasonInitFail;
extern  DWORD   dwSecurityType;

/*
    Local routines
 */
WORD GetFormatForXfer( WORD cfFormat, LPSTR lpszFormatName );
WORD    FAR PASCAL XRegisterClipboardFormat( LPSTR lpszFormatName );

LPDDEPKT
CreateInitiatePkt(
    LPSTR   lpszToNode,
    LPSTR   lpszToApp,
    LPSTR   lpszToTopic,
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    DWORD   dwSecurityType,
    PQOS    pqosClient,
    LPBYTE  lpPassword,
    DWORD   dwPasswordSize,
    DWORD   hSecurityKey)
{
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    LPSTR           lpszPktItem;
    LPDDEPKTSEC     lpSecItem;
    LPDDEPKTSEC     lpSecAligned;
    int             lenFromNode;
    int             lenFromApp;
    int             lenToNode;
    int             lenToApp;
    int             lenToTopic;
    DWORD           dwSize;
    DWORD           dwSecSize;
    DWORD           dwQosSize;
    WORD            nextOffset;

    if ((lenFromNode = lstrlen(lpszFromNode)) == 0)
        lenFromNode = MAX_NODE_NAME;
    if ((lenFromApp = lstrlen(lpszFromApp)) == 0)
        lenFromApp = MAX_APP_NAME;
    if ((lenToNode = lstrlen(lpszToNode)) == 0)
        lenToNode = MAX_NODE_NAME;
    if ((lenToApp = lstrlen(lpszToApp)) == 0)
        lenToApp = MAX_APP_NAME;
    if ((lenToTopic = lstrlen(lpszToTopic)) == 0)
        lenToTopic = MAX_TOPIC_NAME;
    if( dwSecurityType == NT_SECURITY_TYPE )  {
        dwQosSize = sizeof(QOS);
    } else {
        dwQosSize = 0;
    }
    dwSecSize =  dwPasswordSize + dwQosSize +
        sizeof(DDEPKTSEC) + lstrlen(lpszUserName) + 1 +
        lstrlen(lpszDomainName) + 1;

    nextOffset = sizeof(DDEPKTINIT);
    dwSize = nextOffset + ++lenFromNode + ++lenFromApp +
        ++lenToNode + ++lenToApp + ++lenToTopic + dwSecSize;

    lpDdePktInit = (LPDDEPKTINIT) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize );
    lpSecAligned = (LPDDEPKTSEC) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSecSize );
    if( lpDdePktInit && lpSecAligned )  {
        lpDdePkt = (LPDDEPKT) lpDdePktInit;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktInit;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_INITIATE;
        lpDdePktInit->dp_init_dwSecurityType = dwSecurityType;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromNode = nextOffset );
        lstrcpy( lpszPktItem, lpszFromNode);
        nextOffset += (WORD)lenFromNode;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromApp = nextOffset );
        lstrcpy( lpszPktItem, lpszFromApp);
        nextOffset += (WORD)lenFromApp;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToNode = nextOffset );
        lstrcpy( lpszPktItem, lpszToNode);
        nextOffset += (WORD)lenToNode;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToApp = nextOffset );
        lstrcpy( lpszPktItem, lpszToApp);
        nextOffset += (WORD)lenToApp;

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToTopic = nextOffset );
        lstrcpy( lpszPktItem, lpszToTopic);
        nextOffset += (WORD)lenToTopic;

        lpSecItem = (LPDDEPKTSEC) GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsPassword = nextOffset );
        lpDdePktInit->dp_init_sizePassword = dwSecSize;

        /* create the sec pkt aligned, then do it */
        nextOffset = sizeof(DDEPKTSEC);
        lpszPktItem = GetStringOffset( lpSecAligned,
            lpSecAligned->dp_sec_offsUserName = nextOffset);
        lstrcpy(lpszPktItem, lpszUserName);
        lpSecAligned->dp_sec_sizeUserName = (WORD)lstrlen(lpszUserName);
        nextOffset += lstrlen(lpszUserName) + 1;

        lpszPktItem = GetStringOffset( lpSecAligned,
            lpSecAligned->dp_sec_offsDomainName = nextOffset);
        lstrcpy(lpszPktItem, lpszDomainName);
        lpSecAligned->dp_sec_sizeDomainName = (WORD)lstrlen(lpszDomainName);
        nextOffset += lstrlen(lpszDomainName) + 1;

        if (lpSecAligned->dp_sec_sizePassword = (WORD) dwPasswordSize) {
            lpszPktItem = GetStringOffset( lpSecAligned,
                lpSecAligned->dp_sec_offsPassword = nextOffset);
            hmemcpy( lpszPktItem, lpPassword, dwPasswordSize );
            nextOffset += (INT) dwPasswordSize;
        } else {
            lpSecAligned->dp_sec_offsPassword = 0;
        }

        if( dwSecurityType == NT_SECURITY_TYPE )  {
            lpszPktItem = GetStringOffset( lpSecAligned,
                lpSecAligned->dp_sec_offsQos = nextOffset);
            hmemcpy( lpszPktItem, pqosClient,
                lpSecAligned->dp_sec_sizeQos = (WORD) dwQosSize );
        } else {
            lpSecAligned->dp_sec_offsQos = 0;
            lpSecAligned->dp_sec_sizeQos = 0;
        }

        hmemcpy( lpSecItem, lpSecAligned, dwSecSize );
        HeapFreePtr( lpSecAligned );
        lpDdePktInit->dp_init_hSecurityKey = hSecurityKey;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_INITIATE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
        HeapFreePtr(lpDdePktInit);
        HeapFreePtr(lpSecAligned);
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateAckInitiatePkt(
    LPSTR   lpszFromNode,
    LPSTR   lpszFromApp,
    LPSTR   lpszFromTopic,
    LPBYTE  lpSecurityKey,
    DWORD   dwSecurityKeySize,
    DWORD   hSecurityKey,
    BOOL    bSuccess,
    DWORD   dwReason )
{
    LPDDEPKTIACK    lpDdePktIack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    LPSTR           lpszPktItem;
    int             lenFromNode;
    int             lenFromApp;
    int             lenFromTopic;
    DWORD           dwSize;
    WORD            nextOffset;

    if (lenFromNode = lstrlen(lpszFromNode))
        lenFromNode++;
    if (lenFromApp = lstrlen(lpszFromApp))
        lenFromApp++;
    if (lenFromTopic = lstrlen(lpszFromTopic))
        lenFromTopic++;
    nextOffset = sizeof(DDEPKTIACK);
    dwSize = nextOffset + lenFromNode + lenFromApp +
        lenFromTopic + dwSecurityKeySize;

    lpDdePktIack = (LPDDEPKTIACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize );
    if( lpDdePktIack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktIack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktIack;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ACK_INITIATE;

        if (lenFromNode) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromNode = nextOffset );
            lstrcpy( lpszPktItem, lpszFromNode);
            nextOffset += (WORD)lenFromNode;
        } else
            lpDdePktIack->dp_iack_offsFromNode = 0;

        if (lenFromApp) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromApp = nextOffset );
            lstrcpy( lpszPktItem, lpszFromApp);
            nextOffset += (WORD)lenFromApp;
        } else
            lpDdePktIack->dp_iack_offsFromApp = 0;

        if (lenFromTopic) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsFromTopic = nextOffset );
            lstrcpy( lpszPktItem, lpszFromTopic);
            nextOffset += (WORD)lenFromTopic;
        } else
            lpDdePktIack->dp_iack_offsFromTopic = 0;

        if (lpDdePktIack->dp_iack_sizeSecurityKey = dwSecurityKeySize) {
            lpszPktItem = GetStringOffset( lpDdePkt,
                lpDdePktIack->dp_iack_offsSecurityKey = nextOffset );
            hmemcpy( lpszPktItem, lpSecurityKey, dwSecurityKeySize);
            lpDdePktIack->dp_iack_hSecurityKey = hSecurityKey;
            lpDdePktIack->dp_iack_dwSecurityType = dwSecurityType;
        } else {
            lpDdePktIack->dp_iack_offsSecurityKey = 0;
            lpDdePktIack->dp_iack_hSecurityKey = 0xFFFFFFFF;       /* compatibility */
            lpDdePktIack->dp_iack_dwSecurityType = 0xFFFFFFFF;     /* compatibility */
        }

        lpDdePktIack->dp_iack_fromDder = bSuccess;
        lpDdePktIack->dp_iack_reason = dwReason;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_INITIATE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateAckExecutePkt(
    BOOL    fAck,
    BOOL    fBusy,
    BYTE    bAppRtn )
{
    LPDDEPKTEACK    lpDdePktEack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktEack = (LPDDEPKTEACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = sizeof(DDEPKTEACK) );
    if( lpDdePktEack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktEack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktEack;
        lpDdePkt->dp_size = sizeof(DDEPKTEACK);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ACK_EXECUTE;
        lpDdePktEack->dp_eack_fAck    = (BYTE) fAck;
        lpDdePktEack->dp_eack_fBusy   = (BYTE) fBusy;
        lpDdePktEack->dp_eack_bAppRtn = bAppRtn;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_EXECUTE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateGenericAckPkt(
    WORD    wDdeMsg,
    LPSTR   lpszItem,
    BOOL    fAck,
    BOOL    fBusy,
    BYTE    bAppRtn )
{
    LPDDEPKTGACK    lpDdePktGack;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktGack = (LPDDEPKTGACK) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = sizeof(DDEPKTGACK) + lstrlen(lpszItem) );
    if( lpDdePktGack )  {
        lpDdePkt = (LPDDEPKT) lpDdePktGack;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktGack;
        lpDdePkt->dp_size = sizeof(DDEPKTGACK) + lstrlen(lpszItem);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = wDdeMsg;
        lpDdePktGack->dp_gack_fAck    = (BYTE) fAck;
        lpDdePktGack->dp_gack_fBusy   = (BYTE) fBusy;
        lpDdePktGack->dp_gack_bAppRtn = bAppRtn;
        lstrcpy( lpDdePktGack->dp_gack_itemName, lpszItem );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_ACK",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateExecutePkt( LPSTR lpszCommand )
{
    LPDDEPKTEXEC    lpDdePktExec;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    DWORD           dwSize;

    lpDdePktExec = (LPDDEPKTEXEC) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = (DWORD)sizeof(DDEPKTEXEC) + lstrlen(lpszCommand) );
    if( lpDdePktExec )  {
        lpDdePkt = (LPDDEPKT) lpDdePktExec;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktExec;
        lpDdePkt->dp_size = sizeof(DDEPKTEXEC) + lstrlen(lpszCommand);
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_EXECUTE;
        lstrcpy( lpDdePktExec->dp_exec_string, lpszCommand );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_EXECUTE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateTerminatePkt( void )
{
    LPDDEPKT        lpDdePkt;
    DWORD           dwSize;

    lpDdePkt = (LPDDEPKT) HeapAllocPtr( hHeap,
        GMEM_MOVEABLE, dwSize = (DWORD)sizeof(DDEPKTTERM) );
    if( lpDdePkt )  {
        FillTerminatePkt( lpDdePkt );
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_TERMINATE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



VOID
FillTerminatePkt( LPDDEPKT lpDdePkt )
{
    LPDDEPKTCMN     lpDdePktCmn;

    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    lpDdePkt->dp_size = sizeof(DDEPKTTERM);
    lpDdePkt->dp_hDstDder = 0;
    lpDdePkt->dp_hDstRouter = 0;
    lpDdePkt->dp_routerCmd = 0;
    lpDdePktCmn->dc_message = WM_DDE_TERMINATE;
}



LPDDEPKT
CreateRequestPkt(
    LPSTR   lpszItem,
    WORD    cfFormat )
{
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    WORD            nextOffset;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTRQST) + lenCf + lenItem;
    lpDdePktRqst = (LPDDEPKTRQST) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktRqst )  {
        lpDdePkt = (LPDDEPKT) lpDdePktRqst;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktRqst;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_REQUEST;
        nextOffset = sizeof(DDEPKTRQST);

        /* put in item name */
        lpDdePktRqst->dp_rqst_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktRqst->dp_rqst_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktRqst->dp_rqst_offsFormat = 0;
        } else {
            lpDdePktRqst->dp_rqst_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktRqst->dp_rqst_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_REQUEST",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateUnadvisePkt(
    LPSTR   lpszItem,
    WORD    cfFormat )
{
    LPDDEPKTUNAD    lpDdePktUnad;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTRQST) + lenCf + lenItem;
    lpDdePktUnad = (LPDDEPKTUNAD) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktUnad )  {
        lpDdePkt = (LPDDEPKT) lpDdePktUnad;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktUnad;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_UNADVISE;
        nextOffset = sizeof(DDEPKTUNAD);

        /* put in item name */
        lpDdePktUnad->dp_unad_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktUnad->dp_unad_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktUnad->dp_unad_offsFormat = 0;
        } else {
            lpDdePktUnad->dp_unad_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktUnad->dp_unad_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_UNADVISE",
            LogString("%d", dwSize), NULL);
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateDataPkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fResponse,
    BOOL    fAckReq,
    BOOL    fRelease,
    LPVOID  lpData,
    DWORD   dwSizeOfData )
{
    LPDDEPKTDATA    lpDdePktData;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    int             align;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    LPSTR           lpszPktData;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    /* add 1 DWORD to size to allow for DWORD alignment of lpData */
    dwSize = sizeof(DDEPKTDATA) + lenCf + lenItem + dwSizeOfData + sizeof(DWORD);
    lpDdePktData = (LPDDEPKTDATA) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktData )  {
        lpDdePkt = (LPDDEPKT) lpDdePktData;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktData;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_DATA;
        nextOffset = sizeof(DDEPKTDATA);

        /* put in item name */
        lpDdePktData->dp_data_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktData->dp_data_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktData->dp_data_offsFormat = 0;
        } else {
            lpDdePktData->dp_data_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }

        /* put in data */
        lpDdePktData->dp_data_sizeData = dwSizeOfData;
        if( dwSizeOfData == 0 )  {
            lpDdePktData->dp_data_offsData = 0;
        } else {
            if (align = (nextOffset & 0x3)) { /* is it on a double word boundary? */
                align = (~align + 1) & 0x3;
                nextOffset += (WORD)align;
                lpDdePkt->dp_size += align;
            }
            lpDdePktData->dp_data_offsData = nextOffset;
            lpszPktData = GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsData );
            hmemcpy( lpszPktData, lpData, dwSizeOfData );
        }

        /* put in flags */
        lpDdePktData->dp_data_fResponse = (BYTE) fResponse;
        lpDdePktData->dp_data_fAckReq = (BYTE) fAckReq;
        lpDdePktData->dp_data_fRelease = (BYTE) fRelease;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_DATA",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreateAdvisePkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fAckReq,
    BOOL    fNoData )
{
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTADVS) + lenCf + lenItem;
    lpDdePktAdvs = (LPDDEPKTADVS) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktAdvs )  {
        lpDdePkt = (LPDDEPKT) lpDdePktAdvs;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktAdvs;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_ADVISE;
        nextOffset = sizeof(DDEPKTADVS);

        /* put in flags */
        lpDdePktAdvs->dp_advs_fAckReq = (BYTE)fAckReq;
        lpDdePktAdvs->dp_advs_fNoData = (BYTE)fNoData;

        /* put in item name */
        lpDdePktAdvs->dp_advs_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktAdvs->dp_advs_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktAdvs->dp_advs_offsFormat = 0;
        } else {
            lpDdePktAdvs->dp_advs_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktAdvs->dp_advs_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_ADVISE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
CreatePokePkt(
    LPSTR   lpszItem,
    WORD    cfFormat,
    BOOL    fRelease,
    LPVOID  lpData,
    DWORD   dwSizeOfData )
{
    LPDDEPKTPOKE    lpDdePktPoke;
    LPDDEPKT        lpDdePkt = NULL;
    LPDDEPKTCMN     lpDdePktCmn;
    char            cfName[ MAX_CF_NAME+1 ];
    DWORD           dwSize;
    int             lenCf;
    int             lenItem;
    WORD            nextOffset;
    LPSTR           lpszPktItem;
    LPSTR           lpszPktCf;
    LPSTR           lpszPktData;

    cfFormat = GetFormatForXfer( cfFormat, cfName );
    lenCf = lstrlen( cfName );
    if( lenCf != 0 )  {
        lenCf++;        /* add 1 for the NULL */
    }
    lenItem = lstrlen(lpszItem) + 1;
    dwSize = sizeof(DDEPKTPOKE) + lenCf + lenItem + dwSizeOfData;
    lpDdePktPoke = (LPDDEPKTPOKE) HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize);
    if( lpDdePktPoke )  {
        lpDdePkt = (LPDDEPKT) lpDdePktPoke;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktPoke;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_POKE;
        nextOffset = sizeof(DDEPKTPOKE);

        /* put in item name */
        lpDdePktPoke->dp_poke_offsItemName = nextOffset;
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName );
        lstrcpy( lpszPktItem, lpszItem );
        nextOffset += (WORD)lenItem;

        /* put in format */
        lpDdePktPoke->dp_poke_cfFormat = cfFormat;
        if( lenCf == 0 )  {
            lpDdePktPoke->dp_poke_offsFormat = 0;
        } else {
            lpDdePktPoke->dp_poke_offsFormat = nextOffset;
            lpszPktCf = GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsFormat );
            lstrcpy( lpszPktCf, cfName );
            nextOffset += (WORD)lenCf;
        }

        /* put in data */
        lpDdePktPoke->dp_poke_sizeData = dwSizeOfData;
        if( dwSizeOfData == 0 )  {
            lpDdePktPoke->dp_poke_offsData = 0;
        } else {
            lpDdePktPoke->dp_poke_offsData = nextOffset;
            lpszPktData = GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsData );
            hmemcpy( lpszPktData, lpData, dwSizeOfData );
        }

        /* put in flags */
        lpDdePktPoke->dp_poke_fRelease = (BYTE) fRelease;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_POKE",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



#if DBG

VOID
DebugDdePkt( LPDDEPKT lpDdePkt )
{
    LPDDEPKTCMN     lpDdePktCmn;
    LPDDEPKTINIT    lpDdePktInit;
    LPDDEPKTIACK    lpDdePktIack;
    LPDDEPKTGACK    lpDdePktGack;
    LPDDEPKTEXEC    lpDdePktExec;
    LPDDEPKTEACK    lpDdePktEack;
    LPDDEPKTRQST    lpDdePktRqst;
    LPDDEPKTUNAD    lpDdePktUnad;
    LPDDEPKTADVS    lpDdePktAdvs;
    LPDDEPKTPOKE    lpDdePktPoke;
    LPDDEPKTDATA    lpDdePktData;
    LPDDEPKTTEST    lpDdePktTest;
    LPSTR           lpszPktItem;

    if( !bDebugDdePkts )  {
        return;
    }
    DPRINTF(( "DDEPKT: %08lX", lpDdePkt ));
    lpDdePktCmn = (LPDDEPKTCMN) lpDdePkt;
    switch( lpDdePktCmn->dc_message )  {
    case WM_DDE_WWTEST:
        DPRINTF(( "  WM_DDE_WWTEST" ));
        lpDdePktTest = (LPDDEPKTTEST) lpDdePkt;
        DPRINTF(( "   Test #: %d", lpDdePktTest->dp_test_nTestNo ));
        DPRINTF(( "   Pkt #: %d of %d", lpDdePktTest->dp_test_nPktNo,
            lpDdePktTest->dp_test_nTotalPkts ));
        DPRINTF(( "   Size: %ld", lpDdePkt->dp_size ));
        break;
    case WM_DDE_INITIATE:
        DPRINTF(( "  WM_DDE_INITIATE" ));
        lpDdePktInit = (LPDDEPKTINIT) lpDdePkt;
        DPRINTF(( "   fromDder: %08lX", lpDdePktInit->dp_init_fromDder ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromNode );
        DPRINTF(( "   fromNode: \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsFromApp );
        DPRINTF(( "   fromApp:  \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToNode );
        DPRINTF(( "   toNode:   \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToApp );
        DPRINTF(( "   toApp:    \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktInit->dp_init_offsToTopic );
        DPRINTF(( "   toTopic:  \"%Fs\"", lpszPktItem ));
        if (lpDdePktInit->dp_init_offsFromNode == sizeof(DDEPKTINIT)) {
            if (lpDdePktInit->dp_init_offsPassword) {
                DPRINTF(( "    Password: "));
                HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktInit->dp_init_offsPassword),
                    (int)lpDdePktInit->dp_init_sizePassword );
            }
        }
        DPRINTF(( "" ));
        break;
    case WM_DDE_ACK_INITIATE:
        DPRINTF(( "  WM_DDE_ACK_INITIATE" ));
        lpDdePktIack = (LPDDEPKTIACK) lpDdePkt;
        DPRINTF(( "   fromDder: %08lX, dp_iack_reason: %08lx",
            lpDdePktIack->dp_iack_fromDder, lpDdePktIack->dp_iack_reason));

        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromNode );
        DPRINTF(( "   fromNode: \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromApp );
        DPRINTF(( "   fromApp:  \"%Fs\"", lpszPktItem ));
        lpszPktItem = GetStringOffset( lpDdePkt,
            lpDdePktIack->dp_iack_offsFromTopic );
        DPRINTF(( "   toNode:   \"%Fs\"", lpszPktItem ));
        if (lpDdePktIack->dp_iack_offsFromNode == sizeof(DDEPKTIACK)) {
            if (lpDdePktIack->dp_iack_offsSecurityKey) {
                DPRINTF(( "    Security Key: "));
                HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktIack->dp_iack_offsSecurityKey),
                    (int)lpDdePktIack->dp_iack_sizeSecurityKey );
            }
        }
        DPRINTF(( "" ));
        break;
    case WM_DDE_ACK_EXECUTE:
        DPRINTF(( "  WM_DDE_ACK_EXECUTE" ));
        lpDdePktEack = (LPDDEPKTEACK) lpDdePkt;
        DPRINTF(( "   fAck:    %02X", lpDdePktEack->dp_eack_fAck ));
        DPRINTF(( "   fBusy:   %02X", lpDdePktEack->dp_eack_fBusy ));
        DPRINTF(( "   bAppRtn: %02X", lpDdePktEack->dp_eack_bAppRtn ));
        break;
    case WM_DDE_ACK_ADVISE:
    case WM_DDE_ACK_REQUEST:
    case WM_DDE_ACK_UNADVISE:
    case WM_DDE_ACK_POKE:
    case WM_DDE_ACK_DATA:
        switch( lpDdePktCmn->dc_message )  {
        case WM_DDE_ACK_ADVISE:
            DPRINTF(( "  WM_DDE_ACK_ADVISE" ));
            break;
        case WM_DDE_ACK_REQUEST:
            DPRINTF(( "  WM_DDE_ACK_REQUEST" ));
            break;
        case WM_DDE_ACK_UNADVISE:
            DPRINTF(( "  WM_DDE_ACK_UNADVISE" ));
            break;
        case WM_DDE_ACK_POKE:
            DPRINTF(( "  WM_DDE_ACK_POKE" ));
            break;
        case WM_DDE_ACK_DATA:
            DPRINTF(( "  WM_DDE_ACK_DATA" ));
            break;
        }
        lpDdePktGack = (LPDDEPKTGACK) lpDdePkt;
        DPRINTF(( "   fAck:    %02X", lpDdePktGack->dp_gack_fAck ));
        DPRINTF(( "   fBusy:   %02X", lpDdePktGack->dp_gack_fBusy ));
        DPRINTF(( "   bAppRtn: %02X", lpDdePktGack->dp_gack_bAppRtn ));
        DPRINTF(( "   item:    \"%Fs\"", lpDdePktGack->dp_gack_itemName ));
        break;
    case WM_DDE_EXECUTE:
        DPRINTF(( "  WM_DDE_EXECUTE" ));
        lpDdePktExec = (LPDDEPKTEXEC) lpDdePkt;
        DPRINTF(( "   cmd: \"%Fs\"", lpDdePktExec->dp_exec_string ));
        break;
    case WM_DDE_REQUEST:
        DPRINTF(( "  WM_DDE_REQUEST" ));
        lpDdePktRqst = (LPDDEPKTRQST) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktRqst->dp_rqst_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktRqst->dp_rqst_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktRqst->dp_rqst_offsItemName ));
        if( lpDdePktRqst->dp_rqst_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktRqst->dp_rqst_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktRqst->dp_rqst_offsItemName ) ));
        break;
    case WM_DDE_UNADVISE:
        DPRINTF(( "  WM_DDE_UNADVISE" ));
        lpDdePktUnad = (LPDDEPKTUNAD) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktUnad->dp_unad_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktUnad->dp_unad_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktUnad->dp_unad_offsItemName ));
        if( lpDdePktUnad->dp_unad_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktUnad->dp_unad_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktUnad->dp_unad_offsItemName ) ));
        break;
    case WM_DDE_ADVISE:
        DPRINTF(( "  WM_DDE_ADVISE" ));
        lpDdePktAdvs = (LPDDEPKTADVS) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktAdvs->dp_advs_cfFormat ));
        DPRINTF(( "   fAckReq:    %02X", lpDdePktAdvs->dp_advs_fAckReq ));
        DPRINTF(( "   fNoData:    %02X", lpDdePktAdvs->dp_advs_fNoData ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktAdvs->dp_advs_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktAdvs->dp_advs_offsItemName ));
        if( lpDdePktAdvs->dp_advs_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktAdvs->dp_advs_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktAdvs->dp_advs_offsItemName ) ));
        break;
    case WM_DDE_DATA:
        DPRINTF(( "  WM_DDE_DATA" ));
        lpDdePktData = (LPDDEPKTDATA) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktData->dp_data_cfFormat ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktData->dp_data_offsFormat ));
        DPRINTF(( "   fResponse:  %02X", lpDdePktData->dp_data_fResponse ));
        DPRINTF(( "   fAckReq:    %02X", lpDdePktData->dp_data_fAckReq ));
        DPRINTF(( "   fRelease:   %02X", lpDdePktData->dp_data_fRelease ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktData->dp_data_offsItemName ));
        if( lpDdePktData->dp_data_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktData->dp_data_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktData->dp_data_offsItemName ) ));
        DPRINTF(( "   offsData:   %04X", lpDdePktData->dp_data_offsData ));
        DPRINTF(( "   sizeData:   %08lX", lpDdePktData->dp_data_sizeData ));
        HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktData->dp_data_offsData),
            (int)lpDdePktData->dp_data_sizeData );
        break;
    case WM_DDE_POKE:
        DPRINTF(( "  WM_DDE_POKE" ));
        lpDdePktPoke = (LPDDEPKTPOKE) lpDdePkt;
        DPRINTF(( "   format:     %04X", lpDdePktPoke->dp_poke_cfFormat ));
        DPRINTF(( "   fRelease:   %02X", lpDdePktPoke->dp_poke_fRelease ));
        DPRINTF(( "   offsFormat: %04X", lpDdePktPoke->dp_poke_offsFormat ));
        DPRINTF(( "   offsItem:   %04X", lpDdePktPoke->dp_poke_offsItemName ));
        if( lpDdePktPoke->dp_poke_offsFormat )  {
            DPRINTF(( "   format:     \"%Fs\"", GetStringOffset( lpDdePkt,
                lpDdePktPoke->dp_poke_offsFormat ) ));
        }
        DPRINTF(( "   item:       \"%Fs\"", GetStringOffset( lpDdePkt,
            lpDdePktPoke->dp_poke_offsItemName ) ));
        DPRINTF(( "   offsData:   %04X", lpDdePktPoke->dp_poke_offsData ));
        DPRINTF(( "   sizeData:   %08lX", lpDdePktPoke->dp_poke_sizeData ));
        HEXDUMP( GetStringOffset( lpDdePkt, lpDdePktPoke->dp_poke_offsData),
            (int)lpDdePktPoke->dp_poke_sizeData );
        break;
    case WM_DDE_TERMINATE:
        DPRINTF(( "  WM_DDE_TERMINATE" ));
        break;
    default:
        DPRINTF(( "DebugDdePkt: UNKNOWN CMD: %04X", lpDdePktCmn->dc_message ));
    }
    DPRINTF(( "" ));
}
#endif // DBG



WORD
GetClipFormat(
    LPDDEPKT    lpDdePkt,
    WORD        cfFormat,
    WORD        wOffsFormat )
{
    LPSTR       lpszCfName;
    extern WORD wClipFmtInTouchDDE;

    if( cfFormat == CF_INTOUCH_SPECIAL )  {
        cfFormat = wClipFmtInTouchDDE;
    } else if( cfFormat >= 0xC000 )  {
        lpszCfName = GetStringOffset( lpDdePkt, wOffsFormat );
        cfFormat = XRegisterClipboardFormat( lpszCfName );
    }
    return( cfFormat );
}



typedef struct {
    char        cfName[ MAX_CF_NAME+1 ];
    WORD        cfFormat;
} CFSTRUCT;


#ifdef NOINTERNALCFS
#define MAX_CFSTRUCTS   50
CFSTRUCT        cfStructs[ MAX_CFSTRUCTS ];
int             nCfStructs;
#endif // NOINTERNALCFS

WORD
FAR PASCAL
XRegisterClipboardFormat( LPSTR lpszCfName )
{
#ifdef NOINTERNALCFS
    int         i;
    CFSTRUCT   *pCfStruct;
#endif

    if( lstrcmpi( lpszCfName, "text" ) == 0 )  {
        return( CF_TEXT );
    } else if( lstrcmpi( lpszCfName, "bitmap" ) == 0 )  {
        return( CF_BITMAP );
    } else if( lstrcmpi( lpszCfName, "metafilepict" ) == 0 )  {
        return( CF_METAFILEPICT );
    } else if( lstrcmpi( lpszCfName, "sylk" ) == 0 )  {
        return( CF_SYLK );
    } else if( lstrcmpi( lpszCfName, "dif" ) == 0 )  {
        return( CF_DIF );
    } else if( lstrcmpi( lpszCfName, "tiff" ) == 0 )  {
        return( CF_TIFF );
    } else if( lstrcmpi( lpszCfName, "oemtext" ) == 0 )  {
        return( CF_OEMTEXT );
    } else if( lstrcmpi( lpszCfName, "dib" ) == 0 )  {
        return( CF_DIB );
    } else if( lstrcmpi( lpszCfName, "palette" ) == 0 )  {
        return( CF_PALETTE );
    }

// the following WW code caches format strings, seems to be only
// to support platforms w/out cf atom table...

#ifdef NOINTERNALCFS
    pCfStruct = cfStructs;
    for( i=0; i<nCfStructs; i++,pCfStruct++ )  {
        if( lstrcmpi( pCfStruct->cfName, lpszCfName ) == 0 )  {
            return( pCfStruct->cfFormat );
        }
    }
    nCfStructs++;
    if( nCfStructs > MAX_CFSTRUCTS )  {
        DPRINTF(( "Too many private clipboard formats (%d max)", MAX_CFSTRUCTS ));
        return( 0 );
    } else {
        pCfStruct->cfFormat = (WORD) RegisterClipboardFormat( lpszCfName );
        lstrcpyn( pCfStruct->cfName, lpszCfName, MAX_CF_NAME+1 );
        return( pCfStruct->cfFormat );

    }
#else // (#ifndef NOINTERNALCFS)
	return (WORD)RegisterClipboardFormat ( lpszCfName );
#endif
}



WORD
GetFormatForXfer(
    WORD    cfFormat,
    LPSTR   lpszFormatName )
{
    extern WORD wClipFmtInTouchDDE;

    if( cfFormat == 0 )  {
        lpszFormatName[0] = '\0';
        return( 0 );
    }

    if( cfFormat == wClipFmtInTouchDDE )  {
        lpszFormatName[0] = '\0';
        return( CF_INTOUCH_SPECIAL );
    } else if( cfFormat >= 0xC000 )  {
        GetClipboardFormatName( cfFormat, lpszFormatName, MAX_CF_NAME );
        return( cfFormat );
    } else {
        lpszFormatName[0] = '\0';
        return( cfFormat );
    }
}



LPDDEPKT
FAR PASCAL
CreateTestPkt(
    int     nTestNo,
    int     nPacket,
    int     nNum,
    DWORD   dwSize )
{
    LPDDEPKTTEST        lpDdePktTest;
    LPDDEPKT            lpDdePkt = NULL;
    LPDDEPKTCMN         lpDdePktCmn;

    lpDdePktTest = (LPDDEPKTTEST)HeapAllocPtr( hHeap, GMEM_MOVEABLE, dwSize );
    if( lpDdePktTest )  {
        lpDdePkt = (LPDDEPKT) lpDdePktTest;
        lpDdePktCmn = (LPDDEPKTCMN) lpDdePktTest;
        lpDdePkt->dp_size = dwSize;
        lpDdePkt->dp_hDstDder = 0;
        lpDdePkt->dp_hDstRouter = 0;
        lpDdePkt->dp_routerCmd = 0;
        lpDdePktCmn->dc_message = WM_DDE_WWTEST;
        lpDdePktTest->dp_test_nTestNo           = (BYTE) nTestNo;
        lpDdePktTest->dp_test_nPktNo            = (BYTE) nPacket;
        lpDdePktTest->dp_test_nTotalPkts        = (BYTE) nNum;
    } else {
        /*  Unable to allocate enough (%2) memory for a %1 packet   */
        NDDELogError(MSG100, "DDE_TEST",
            LogString("%d", dwSize), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }

    return( lpDdePkt );
}



LPDDEPKT
DdePktCopy( LPDDEPKT lpDdePktOld )
{
    LPDDEPKT    lpDdePktNew;

    lpDdePktNew = (LPDDEPKT) HeapAllocPtr( hHeap, GMEM_MOVEABLE,
        lpDdePktOld->dp_size );
    if( lpDdePktNew )  {
        hmemcpy( lpDdePktNew, lpDdePktOld, lpDdePktOld->dp_size );
    } else {
        /*  Unable to allocate enough (%1) memory for packet copy   */
        NDDELogError(MSG101, LogString("%d", lpDdePktOld->dp_size), NULL);
        dwReasonInitFail = RIACK_LOCAL_MEMORY_ERR;
    }
    return( lpDdePktNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\ntddecmn\verify.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "VERIFY.C;1  16-Dec-92,10:21:36  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.		*
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "host.h"
#include "windows.h"
#include "netbasic.h"
#include "netpkt.h"
#include "netintf.h"
#include "verify.h"
#include "crc.h"
#include "cks32.h"
#include "debug.h"
#include "internal.h"
#include "hexdump.h"

BOOL
FAR PASCAL VerifyHdr( LPNETPKT lpPacket )
{
    DWORD	chksum;
    WORD	crc;

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	if( crc != (WORD)PcToHostLong(lpPacket->np_cksHeader) )  {
	    DPRINTF(( "Header CRC Err: %08lX vs. %08lX", (DWORD)crc, lpPacket->np_cksHeader ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	    return( FALSE );
	}
	break;
    case VERMETH_CKS32:
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	if( chksum != PcToHostLong(lpPacket->np_cksHeader) )  {
	    DPRINTF(( "Header CKS Err: %08lX vs. %08lX", chksum, lpPacket->np_cksHeader ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	    return( FALSE );
	}
	break;
    default:
	DPRINTF(( "VerifyHdr: VerifyMethod incorrect: %08lX", (DWORD)lpPacket->np_verifyMethod ));
	HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT) );
	/* if the verifyMethod isn't set properly - throw the header out */
	return( FALSE );
    }

    return( TRUE );
}

BOOL
FAR PASCAL VerifyData( LPNETPKT lpPacket )
{
    WORD	crc;
    DWORD	chksum;

    if( lpPacket->np_pktSize == 0 )  {
	/* no data, just return OK */
	return( TRUE );
    }

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksData)
		+ sizeof(lpPacket->np_cksData),
	    lpPacket->np_pktSize );
	if( crc != (WORD)PcToHostLong(lpPacket->np_cksData) )  {
	    DPRINTF(( "Data CRC Err: %08lX vs. %08lX", (DWORD)crc, lpPacket->np_cksData ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	    return( FALSE );
	}
	break;
    case VERMETH_CKS32:
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksData)
		+ sizeof(lpPacket->np_cksData),
	    lpPacket->np_pktSize );
	if( chksum != PcToHostLong(lpPacket->np_cksData) )  {
	    DPRINTF(( "Data CKS Err: %08lX vs. %08lX", (DWORD)chksum, lpPacket->np_cksData ));
	    HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	    return( FALSE );
	}
	break;
    default:
	DPRINTF(( "VerifyData: VerifyMethod incorrect: %08lX", (DWORD)lpPacket->np_verifyMethod ));
	HEXDUMP( (LPSTR)lpPacket, sizeof(NETPKT)+lpPacket->np_pktSize );
	/* if the verifyMethod isn't set properly - throw the header out */
	return( FALSE );
    }
    return( TRUE );
}

VOID
FAR PASCAL PreparePktVerify( BYTE verifyMethod, LPNETPKT lpPacket )
{
    WORD	crc;
    DWORD	chksum;

    lpPacket->np_verifyMethod = verifyMethod;

    switch( lpPacket->np_verifyMethod )  {
    case VERMETH_CRC16:
	/* verify data */
	if( HostToPcWord( lpPacket->np_pktSize ) != 0 )  {
	    crc = 0xFFFF;
	    crc_16( &crc,
		((BYTE FAR *)&lpPacket->np_cksData)
		    + sizeof(lpPacket->np_cksData),
		HostToPcWord( lpPacket->np_pktSize ) );
	    lpPacket->np_cksData = HostToPcLong( (DWORD)crc );
	} else {
	    lpPacket->np_cksData = 0;
	}

	/* verify hdr */
	crc = 0xFFFF;
	crc_16( &crc,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	lpPacket->np_cksHeader = HostToPcLong( (DWORD)crc );
	break;
    case VERMETH_CKS32:
	/* verify data */
	if( HostToPcWord( lpPacket->np_pktSize ) != 0 )  {
	    Checksum32( &chksum,
		((BYTE FAR *)&lpPacket->np_cksData)
		    + sizeof(lpPacket->np_cksData),
		HostToPcWord( lpPacket->np_pktSize ) );
	    lpPacket->np_cksData = HostToPcLong( chksum );
	} else {
	    lpPacket->np_cksData = 0;
	}
	
	/* verify hdr */
	Checksum32( &chksum,
	    ((BYTE FAR *)&lpPacket->np_cksHeader)
		+ sizeof(lpPacket->np_cksHeader),
	    sizeof(NETPKT) - sizeof(lpPacket->np_cksHeader) );
	lpPacket->np_cksHeader = HostToPcLong( chksum );
	break;
    default:
	InternalError( "PreparePkt: VerifyMethod incorrect: %08lX",
	    (DWORD)lpPacket->np_verifyMethod );
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\dbgdde.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DBGDDE.C;1  16-Dec-92,10:22:16  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "windows.h"
#include "dde.h"

#define LINT_ARGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"
#include "dbgdde.h"

int     dbgDdeDataDisplayMax = 20;

VOID    FAR PASCAL GetFormatName( WORD, PSTR, int );

#if DBG
VOID
FAR PASCAL
DebugDDEMessage(
    PSTR            szType,
    HWND            hWnd,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam)
{
    BOOL        bShowAtomHi;
    BOOL        bShowAtomLo;
    char        atomName[ 256 ];
    char        atomNameLo[ 256 ];
    char        formatName[ 256 ];
    char        value[ 256 ];
    char        msgName[ 50 ];
    DDEDATA*    lpDdeData;
    WORD        cfFormat;
    HANDLE      hData;
    UINT_PTR    uLo, uHi;

    bShowAtomHi = TRUE;
    bShowAtomLo = FALSE;
    formatName[0] = '\0';
    value[0] = '\0';

    if( InSendMessage() && (message == WM_DDE_ACK) ) {
    	uLo = (UINT)(LOWORD(lParam));
    	uHi = (UINT)(HIWORD(lParam));
    } else {
    	if( !UnpackDDElParam( message, lParam, &uLo, &uHi ) ) {
    	    DPRINTF(("UnpackDDElParam() failed in DebugDDEMessage()"));
    	    return;
    	}
    }
    switch( message )  {
    case WM_DDE_ACK:
        strcpy( msgName, "WM_DDE_ACK" );
        break;

    case WM_DDE_DATA:
    case WM_DDE_POKE:
    case WM_DDE_ADVISE:
        switch( message )  {
        case WM_DDE_DATA:
            strcpy( msgName, "WM_DDE_DATA" );
            break;

        case WM_DDE_POKE:
            strcpy( msgName, "WM_DDE_POKE" );
            break;

        case WM_DDE_ADVISE:
            strcpy( msgName, "WM_DDE_ADVISE" );
            break;
        }
        hData = (HANDLE)uLo;
        if( hData )  {
            lpDdeData = (DDEDATA*)GlobalLock( hData );
            if( lpDdeData )  {
                cfFormat = lpDdeData->cfFormat;
                if( (dbgDdeDataDisplayMax != 0) && (cfFormat == CF_TEXT) )  {
                    if( message == WM_DDE_DATA )  {
                        sprintf( value, " \"%.*Fs\" %d/%d",
                            dbgDdeDataDisplayMax,
                            lpDdeData->Value,
                            lpDdeData->fResponse,
                            lpDdeData->fAckReq );
                    } else if( message == WM_DDE_POKE )  {
                        sprintf( value, " \"%.*Fs\"",
                            dbgDdeDataDisplayMax, lpDdeData->Value );
                    }
                } else {
                    if( message == WM_DDE_DATA )  {
                        sprintf( value, " %d/%d",
                            lpDdeData->fResponse,
                            lpDdeData->fAckReq );
                    }
                }
                GlobalUnlock( hData );
                GetFormatName( cfFormat, formatName, sizeof(formatName) );
            } else {
                strcpy( value, " NULL-Lock" );
            }
        }
        break;

    case WM_DDE_REQUEST:
        strcpy( msgName, "WM_DDE_REQUEST" );
        GetFormatName( (WORD)uLo, formatName, sizeof(formatName) );
        break;

    case WM_DDE_EXECUTE:
        bShowAtomHi = FALSE;
        hData = (HANDLE)uHi;
        if( hData )  {
            lpDdeData = (DDEDATA*)GlobalLock( hData );
            if( lpDdeData )  {
                value[0] = '\"';
                strncpy( value + 1, (LPSTR)lpDdeData, sizeof(formatName) - 2);
                value[sizeof(formatName) - 2] = '\0';
                strcat(value, "\"");
                GlobalUnlock( hData );
            }
        }
        strcpy( msgName, "WM_DDE_EXECUTE" );
        break;

    case WM_DDE_UNADVISE:
        strcpy( msgName, "WM_DDE_UNADVISE" );
        break;

    case WM_DDE_TERMINATE:
        bShowAtomHi = FALSE;
        strcpy( msgName, "WM_DDE_TERMINATE" );
        break;

    case WM_DDE_INITIATE:
        bShowAtomLo = TRUE;
        strcpy( msgName, "WM_DDE_INITIATE" );
        break;

    default:
        bShowAtomHi = FALSE;
        sprintf( msgName, "UNK(%04X)", message );
    }

    atomName[0] = '\0';
    if( bShowAtomHi )  {
        if( uHi )  {
            GlobalGetAtomName( (ATOM)uHi, atomName, sizeof(atomName) );
        } else {
            strcpy( atomName, "NULL!" );
        }
    }
    atomNameLo[0] = '\0';
    if( bShowAtomLo )  {
        if( uHi )  {
            GlobalGetAtomName( (ATOM)uLo, atomNameLo, sizeof(atomNameLo) );
        } else {
            strcpy( atomNameLo, "NULL!" );
        }
        strcat(atomNameLo, "|");
    }
    DPRINTF(( "%Fs %-16Fs %08X %08X %04X %04X [%Fs%Fs%Fs]%Fs",
        (LPSTR)szType, (LPSTR)msgName,
        hWnd, wParam, uLo, uHi, (LPSTR)atomNameLo, (LPSTR)atomName,
        (LPSTR)formatName, (LPSTR)value ));
}
#endif // DBG




VOID
FAR PASCAL
GetFormatName(
    WORD    cfFormat,
    PSTR    pszFormat,
    int     nMax)
{
    wsprintf( pszFormat, ":Format#%04X", cfFormat );

    switch( cfFormat )  {
    case CF_TEXT:
        lstrcpy( pszFormat, ":TEXT" );
        break;
    case CF_BITMAP:
        lstrcpy( pszFormat, ":BITMAP" );
        break;
    case CF_METAFILEPICT:
        lstrcpy( pszFormat, ":METAFILEPICT" );
        break;
    case CF_SYLK:
        lstrcpy( pszFormat, ":SYLK" );
        break;
    case CF_DIF:
        lstrcpy( pszFormat, ":DIF" );
        break;
    case CF_TIFF:
        lstrcpy( pszFormat, ":TIFF" );
        break;
    case CF_OEMTEXT:
        lstrcpy( pszFormat, ":OEMTEXT" );
        break;
    case CF_DIB:
        lstrcpy( pszFormat, ":DIB" );
        break;
    case CF_PALETTE:
        lstrcpy( pszFormat, ":PALETTE" );
        break;
    default:
        if( cfFormat >= 0xC000 )  {
            GetClipboardFormatName( cfFormat, &pszFormat[1], nMax-1 );
            pszFormat[0] = ':';
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\hexdump.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "HEXDUMP.C;1  16-Dec-92,10:22:30  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define LINT_ARGS
#include        <stdio.h>
#include        <string.h>
#include        <ctype.h>
#include        "windows.h"
#include        "hexdump.h"
#include        "debug.h"

#if DBG

static char     buffer[200];		// 1 line of output which is max 81 characters (2+9+16*3+4+17+NULL)
static char     buf1[50];		// used as 2 temps : 1 char; and later 1 hex value of that char; max len is 4
static char     buf2[50];               // accumulate the characters from the string (max len is 17+NULL)

/*
 *   output contents of string in the format :
 *     <addr of string>: B1 B2 B3 B4 B5 B6 B7-B8 B9 B10 B11 B12 B13 B14 B15    <Text rep of string>
 *
 *     e.g. if string is "ABCD012345123456" and len is 16, output is :
 *             0100109C: 41 42 43 44 30 31 32 33-34 35 31 32 33 34 35 36    ABCD0123-45123456
 *
 *     buf2 is the text string on the right (max 17); buffer is the whole string; buf1 is just used as a small temp
 */
VOID
FAR PASCAL
hexDump(
    LPSTR    string,
    int      len)
{
    int         i;
    int         first = TRUE;

    buffer[0] = '\0';
    buf2[0] = '\0';

    for( i=0; i<len;  )  {

        // print out 1 line for every 16 characters
        if( (i++ % 16) == 0 )  {

            //  add the text representation of the string and output it
            if( !first )  {
                strcat( buffer, buf2 );
                DPRINTF(( buffer ));
            }

            // every newline starts with the address
            wsprintf( buffer, "  %08lX: ", string );
            strcpy( buf2, "   " );
            first = FALSE;
        }

        // put the next character at the end of buf2
        wsprintf( buf1, "%c", isprint((*string)&0xFF) ? *string&0xFF : '.' );
        strcat( buf2, buf1 );
        if( (i % 16) == 8 )  {
            strcat( buf2, "-" );
        }

        // put the next hex value for that char at the end of buffer
        wsprintf( buf1, "%02X%c", *string++ & 0xFF,
            ((i % 16) == 8) ? '-' : ' ' );
        strcat( buffer, buf1 );
    }

    // merge the strings and print out the last line
    strcat( buffer, buf2 );
    DPRINTF(( buffer ));
    DPRINTF(( "" ));
}


#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\dump.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "DUMP.C;1  16-Dec-92,10:22:22  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include "windows.h"
#include "debug.h"
#include <string.h>

/*  Functions declared in 'debug.h' */

BOOL
DumpDacl( LPTSTR szDumperName, PSECURITY_DESCRIPTOR pSD )
{
    PACCESS_ALLOWED_ACE	pAce;
    PACCESS_DENIED_ACE	pDAce;
    TCHAR			szAceType[ 50 ];
    DWORD			i;
    PSID			pSid;
    PACL			pAcl;
    BOOL			OK, bDaclDefaulted, bDaclPresent;

    /* Dump Dacl entries. */
    DPRINTF(("======================="));
    OK = GetSecurityDescriptorDacl( pSD, &bDaclPresent,
				    &pAcl, &bDaclDefaulted );
    if( OK ) {
	DPRINTF(("%s - AceCount = %d", szDumperName, pAcl->AceCount));
	for( i=0; i < (DWORD)pAcl->AceCount; i++ ) {
	    OK = GetAce( pAcl, i, (LPVOID *)&pAce );
	    if( !OK ) {
		return FALSE;
	    }
	    pDAce = (ACCESS_DENIED_ACE *)pAce;
	    pSid = (PSID)&pAce->SidStart;
	    switch( pAce->Header.AceType ) {
	    case ACCESS_ALLOWED_ACE_TYPE:
		strcpy( szAceType, "ACCESS_ALLOWED_ACE_TYPE" );
		break;
	    case ACCESS_DENIED_ACE_TYPE:
		strcpy( szAceType, "ACCESS_DENIED_ACE_TYPE" );
		break;
	    case SYSTEM_AUDIT_ACE_TYPE:
		strcpy( szAceType, "SYSTEM_AUDIT_ACE_TYPE" );
		break;
	    case SYSTEM_ALARM_ACE_TYPE:
		strcpy( szAceType, "SYSTEM_ALARM_ACE_TYPE" );
		break;
	    default:
		strcpy( szAceType, "Unknown ACE type" );
		break;
	    }
	    DPRINTF(("%s - pAce     = (%p)", szDumperName, pAce));
	    DPRINTF(("%s - AceType  = (%s)", szDumperName, szAceType));
	    DPRINTF(("%s - AceFlags = (%x)", szDumperName, pAce->Header.AceFlags));
	    DPRINTF(("%s - AceSize  = (%d)", szDumperName, pAce->Header.AceSize));
	    DPRINTF(("%s - AceMask  = (%x)", szDumperName, pAce->Mask));
	    DPRINTF(("%s - pSid     = (%p)", szDumperName, pSid));
	    DumpSid( szDumperName, pSid );
	}
    }

    return OK;
}

BOOL
DumpSid( LPTSTR szDumperName, PSID pSid )
{
    SID_NAME_USE	snu;
    TCHAR		szNull[ 50 ];
    TCHAR		szAccountName[ 5000 ];
    TCHAR		szDomainName[ 5000 ];
    DWORD		dwAccountName;
    DWORD		dwDomainName;
    BOOL		OK;
    DWORD		dwSidLen;
    DWORD		dwSsaCount;
    int			i;
    PSID_IDENTIFIER_AUTHORITY pSidAuthority;

    szNull[0] = '\0';
    OK        = FALSE;

    if( IsValidSid( pSid ) ) {
	dwSidLen      = GetLengthSid( pSid );
	dwSsaCount    = (DWORD) *GetSidSubAuthorityCount( pSid );
	pSidAuthority = GetSidIdentifierAuthority( pSid );
	DPRINTF(("%s - Sid Length        = (%d)", szDumperName, dwSidLen));
	DPRINTF(("%s - Sid SA Count      = (%d)", szDumperName, dwSsaCount));
	DPRINTF(("%s - Sid ID Authority  = {%x,%x,%x,%x,%x,%x}", szDumperName,
	    pSidAuthority->Value[0],
	    pSidAuthority->Value[1],
	    pSidAuthority->Value[2],
	    pSidAuthority->Value[3],
	    pSidAuthority->Value[4],
	    pSidAuthority->Value[5]));
	for( i=0; i<(int)dwSsaCount; i++ ) {
	    DPRINTF(("%s - Sid Sub Authority = {%x}", szDumperName,
		    *GetSidSubAuthority( pSid, i )));
	}
	dwAccountName = 5000;
	dwDomainName  = 5000;
	OK = LookupAccountSid( szNull, pSid,
			       szAccountName, &dwAccountName,
			       szDomainName,  &dwDomainName, &snu);
	if( OK ) {
	    DPRINTF(("%s - AccountName       = (%s)", szDumperName,
		szAccountName));
	    DPRINTF(("%s - DomainName        = (%s)", szDumperName,
		szDomainName));
	    DPRINTF(("%s - Name Use          = (%d)", szDumperName,
		snu));
	} else {
	    /* Do other types of checking -- SidPrefix? Authority? */
	    DPRINTF(("%s - No Sid Account    = (%d)", szDumperName,
		GetLastError()));
	}
    } else {
	DPRINTF(("%s - IsValidSid        = (%d)", szDumperName, GetLastError()));
    }

    return OK;
}

VOID
DumpToken( HANDLE hToken )
{
    char	buf[ 5000 ];
    DWORD	dwSize;
    BOOL	ok;
    PTOKEN_USER pTU = (PTOKEN_USER)buf;

    ok = GetTokenInformation( hToken, TokenUser, buf, sizeof(buf), &dwSize );
    if( ok )  {
        DumpSid( "LoggedOn Token User", pTU->User.Sid );
        ok = GetTokenInformation( hToken, TokenOwner, buf, sizeof(buf), &dwSize );
        if( ok )  {
            DumpSid( "LoggedOn Token Owner", pTU->User.Sid );
        } else {
            DPRINTF(( "GetTokenInfo Owner failed: %d", GetLastError() ));
        }
    } else {
        DPRINTF(( "GetTokenInfo User failed: %d", GetLastError() ));
    }
}

BOOL
GetTokenUserDomain( HANDLE hToken, PSTR user, DWORD nUser,
    PSTR domain, DWORD nDomain )
{
    BOOL            ok = TRUE;
    HANDLE          hMemory = 0;
    TOKEN_USER    * pUserToken = NULL;
    char            pComputerName[] = "";
    DWORD           UserTokenLen;
    PSID            pUserSID;
    SID_NAME_USE    UserSIDType;

    user[0] = '\0';
    domain[0] = '\0';

    ok = GetTokenInformation( hToken, TokenUser,
        pUserToken, 0, &UserTokenLen);
    if (!ok && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        hMemory = LocalAlloc(LPTR, UserTokenLen);
        if (hMemory) {
            pUserToken = (TOKEN_USER *)LocalLock(hMemory);
            ok = GetTokenInformation( hToken, TokenUser,
                pUserToken, UserTokenLen, &UserTokenLen );
        } else {
            // MEMERROR();
        }
    }
    if (ok) {
        pUserSID = pUserToken->User.Sid;
        ok = LookupAccountSid(pComputerName,
            pUserSID,
            user,
            &nUser,
            domain,
            &nDomain,
            &UserSIDType);
    }

    return( ok );
}

void
DumpWhoIAm( LPSTR lpszMsg )
{
    HANDLE      hToken;
    char        user[100], domain[100];

    if( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE,
            &hToken )) {
        GetTokenUserDomain( hToken, user, 100, domain, 100 );
        DPRINTF(( "%s: THREAD: %s\\%s", lpszMsg, domain, user ));
    } else if( OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken )) {
        GetTokenUserDomain( hToken, user, 100, domain, 100 );
        DPRINTF(( "%s: PROCESS: %s\\%s", lpszMsg, domain, user ));
    } else {
        DPRINTF(( "%s: PROCESS: couldn't open tokens", lpszMsg ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\makefile.inc ===
$(O)\setup_netdde.c : nscommn.c ..\..\incs\shrtrust.h
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    setup_netdde.c

Abstract:

    This is used by syssetup to enable netdde.  It's generated from various files under
    windows\netdde.  Do not edit by hand.

Revision History:

--*/

<<
    type ..\..\incs\shrtrust.h >> $@
    hextract -o $@ -lt setup -bt begin_setup end_setup nscommn.c
    $(PUBLISH_CMD) {$@=$(PROJECT_INC_PATH)\setup_netdde.c}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\nddelog.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NDDELOG.C;2  27-Jan-93,15:51:56  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Begin
   $History: End */

#include    <windows.h>
#include    <stdio.h>
#include    <stdarg.h>
#include    "nddemsg.h"
#include    "nddelog.h"
#include    "debug.h"


extern BOOL	bNDDELogInfo;
extern BOOL bNDDELogWarnings;
extern BOOL bNDDELogErrors;


VOID
NDDELogEventA(
    DWORD  EventId,                // message id
    WORD   fwEventType,            // event type
    WORD   cStrings,               // how many strings
    LPSTR *aszMsg)                 // pointer to strings
{
    HANDLE  hLog;
    BOOL    ok;

    hLog = RegisterEventSourceA(NULL, "NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventA(hLog, fwEventType,
            0, EventId, NULL, cStrings, 0,
            aszMsg, NULL);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}


VOID
NDDELogEventW(
    DWORD  EventId,                // message id
    WORD   fwEventType,            // event type
    WORD   cStrings,               // how many strings
    LPWSTR *aszMsg)                // pointer to strings
{
    HANDLE  hLog;
    BOOL    ok;

    hLog = RegisterEventSourceW(NULL, L"NetDDE");
    if (hLog == NULL) {
        DPRINTF(( "Unable to register event source. (%d) msg:%d",
            GetLastError(), EventId ));
    } else {
        ok = ReportEventW(hLog, fwEventType,
            0, EventId, NULL, cStrings, 0,
            aszMsg, NULL);
        if (!ok) {
            DPRINTF(( "Error logging event. (%d) msg:%d",
                GetLastError(), EventId ));
        }
        DeregisterEventSource(hLog);
    }
}



VOID
NDDELogErrorA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogErrors) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR);

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventA(EventId, EVENTLOG_ERROR_TYPE, count, (LPSTR *) aszMsg);
    } else {
        NDDELogEventA(EventId, EVENTLOG_ERROR_TYPE, 0, NULL);
    }
}

VOID
NDDELogErrorW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogErrors) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR);

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventW(EventId, EVENTLOG_ERROR_TYPE, count, (LPWSTR *) aszMsg);
    } else {
        NDDELogEventW(EventId, EVENTLOG_ERROR_TYPE, 0, NULL);
    }
}

VOID
NDDELogWarningA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogWarnings) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventA(EventId, EVENTLOG_WARNING_TYPE, count, (LPSTR *)aszMsg);
    } else {
        NDDELogEventA(EventId, EVENTLOG_WARNING_TYPE, 0, NULL);
    }
}

VOID
NDDELogWarningW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;

    if (!bNDDELogWarnings) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
        NDDELogEventW(EventId, EVENTLOG_WARNING_TYPE, count,(LPWSTR *)aszMsg);
    } else {
        NDDELogEventW(EventId, EVENTLOG_WARNING_TYPE, 0, NULL);
    }
}

VOID
NDDELogInfoA(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPSTR   aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;


    if (!bNDDELogInfo) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPSTR );
    }

    va_end(arg_ptr);

    if (count) {
       NDDELogEventA(EventId,EVENTLOG_INFORMATION_TYPE,count,(LPSTR *)aszMsg);
    } else {
       NDDELogEventA(EventId, EVENTLOG_INFORMATION_TYPE, 0, NULL);
    }
}

VOID
NDDELogInfoW(
    DWORD EventId, ... )
{
    WORD    count = 0;
    LPWSTR  aszMsg[MAX_VAR_ARGS];
    va_list arg_ptr;


    if (!bNDDELogInfo) {
        return;
    }
    va_start(arg_ptr, EventId);
    aszMsg[count] = va_arg( arg_ptr, LPWSTR );

    while (aszMsg[count] && (count < MAX_VAR_ARGS)) {
        count++;
        aszMsg[count] = va_arg( arg_ptr, LPWSTR );
    }

    va_end(arg_ptr);

    if (count) {
      NDDELogEventW(EventId,EVENTLOG_INFORMATION_TYPE,count,(LPWSTR *)aszMsg);
    } else {
      NDDELogEventW(EventId, EVENTLOG_INFORMATION_TYPE, 0, NULL);
    }
}

LPSTR
LogStringA( LPSTR   lpFormat, ...)
{
    static char szStringBuf[MAX_VAR_ARGS][MAX_LOG_STRING];
    static int  nextString = 0;
    va_list	marker;

    LPSTR   lpCurrent = (LPSTR) szStringBuf[nextString++];

    va_start(marker, lpFormat);
    _vsnprintf(lpCurrent, MAX_LOG_STRING, lpFormat, marker);
    if (nextString == MAX_VAR_ARGS) {
        nextString = 0;
    }
    va_end(marker);
    return(lpCurrent);
}

LPWSTR
LogStringW( LPWSTR   lpFormat, ...)
{
    static wchar_t szStringBufW[MAX_VAR_ARGS][MAX_LOG_STRING];
    static int   nextStringW = 0;
    va_list	 marker;

    LPWSTR   lpCurrent = (LPWSTR) szStringBufW[nextStringW++];

    va_start(marker, lpFormat);
    _vsnwprintf(lpCurrent, MAX_LOG_STRING, lpFormat, marker);
    if (nextStringW == MAX_VAR_ARGS) {
        nextStringW = 0;
    }
    va_end(marker);
    return(lpCurrent);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\nscommn.c ===
/*
 * NSCOMMN.C    (Netdde-Setup COMMoN code)
 *
 * Code common to NetDDE setup utilities and NT setup
 */
#include    <windows.h>   // required for all Windows applications
#include    <string.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <time.h>

#include    "shrtrust.h"

// begin_setup

#include    <strsafe.h>

#if DBG
#define KdPrint(_x_) DbgPrint _x_
#else
#define KdPrint(_x_)
#endif

ULONG DbgPrint(PCH Format, ...);

BOOL GetDBSerialNumber(DWORD *lpdwId);
BOOL GetDBInstance(char *lpszBuf);

TCHAR    szShareKey[] = DDE_SHARES_KEY;
CHAR    szSetup[] = "NetDDE Setup";

#define	SHARES_TO_INIT 3

CHAR *szShareNames[SHARES_TO_INIT] = {
    "Chat$"     ,
    "Hearts$"   ,
    "CLPBK$"
};

BOOL
CreateShareDBInstance()
{
    HKEY            hKey;
    LONG            lRtn;
    BOOL            bOK = TRUE;
    DWORD           InstanceId;
    time_t          time_tmp;

    /*  Create the DDE Share database in the registry if it does not exist. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		  szShareKey,
		  0,
		  KEY_SET_VALUE,
		  &hKey );

    if( lRtn == ERROR_SUCCESS ) {
        /*
         * create data base instance value
         */
        srand((int) time(&time_tmp));
        InstanceId = rand() * rand();
        lRtn = RegSetValueEx( hKey,
            KEY_DB_INSTANCE, 0,
            REG_DWORD,
            (LPBYTE)&InstanceId,
            sizeof( DWORD ) );
        if( lRtn == ERROR_SUCCESS ) {
        } else {
            KdPrint(("SETUPDLL: CreateShareDBInstnace: RegSetValueEx %x failed (%u)\n",InstanceId,lRtn));
            bOK = FALSE;
        }
        RegCloseKey( hKey );
    } else {
    /* Share DB key should have been created from default hives */
        KdPrint(("SETUPDLL: CreateShareDBInstnace: RegOpenKey %s failed (%u)\n",szShareKey,lRtn));
        bOK = FALSE;
    }
    return(bOK);
}

BOOL
CreateDefaultTrust(
HKEY hKeyUserRoot)
{
    HKEY    hKey;
    DWORD   dwDisp;
    DWORD   ret;
    BOOL    bOK;
    char    szTrustedShareKey[TRUSTED_SHARES_KEY_MAX];
    char    szShareKey[DDE_SHARE_KEY_MAX];
    char    szDBInstance[TRUSTED_SHARES_KEY_SIZE + 1];
    DWORD   dwId[2];
    DWORD   dwFlag;
    int	    nLoop;


    if (!GetDBInstance(szDBInstance)) {
        return(FALSE);
    }

    if (!GetDBSerialNumber(dwId)) {
        KdPrint(("SETUPDLL: CreateDefaultTrust: GetDBSerialNumber failed.\n"));
        return(FALSE);
    }

    for (nLoop = 0, bOK = TRUE;
        (nLoop < SHARES_TO_INIT) && bOK ;
            nLoop++) {
        /*
         * For each share to init...
         */

        KdPrint(("Shareing %s\n", szShareNames[nLoop]));

        /*
         * Build up szTrustedSharesKey IAW the DBInstance sring.
         */
        StringCchPrintfA( szTrustedShareKey,
                TRUSTED_SHARES_KEY_MAX,
                "%s\\%s\\%s",
                TRUSTED_SHARES_KEY_A,
                szDBInstance,
                szShareNames[nLoop] );

        /*
         * Create the trusted share key (hKey)
         */
        ret = RegCreateKeyExA( hKeyUserRoot, szTrustedShareKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hKey,
                &dwDisp );

        if( ret != ERROR_SUCCESS )  {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegCreateKeyEx failed on HKEY_CURRENT_USER\\%s. (%u)\n",
                    szTrustedShareKey, ret));
            return(FALSE);
        }

        /*
         * Get the serial number of the database.  Note that the SN of each
         * trust share must == the SN of the database.  Since the non-trusted
         * shares may not have the latest database SN, update all of them to
         * the current database SN as well.  This allows apps like winchat to
         * work when they are called from outside the machine even though they
         * have never been run - which would fix the SNs of their trusts because
         * they automatically set up their trusts.
         */

        /*
         * Set the SN of the trusted share
         */
        ret = RegSetValueEx( hKey,
		       KEY_MODIFY_ID,
		       0,
		       REG_BINARY,
		       (LPBYTE)&dwId,
		       KEY_MODIFY_ID_SIZE );

        if (ret == ERROR_SUCCESS) {
            /*
             * set the StartApp flag to 1
             */
            dwFlag = 1;
            ret = RegSetValueEx( hKey,
                KEY_START_APP,
                0,
                REG_DWORD,
                (LPBYTE)&dwFlag,
                sizeof( DWORD ) );

            if (ret == ERROR_SUCCESS) {
                /*
                 * Set the InitAllowed flag to 1 too.
                 */
   	            ret = RegSetValueEx( hKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwFlag,
                    sizeof( DWORD ) );
            }
        }

        RegCloseKey(hKey);

        if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx failed (%u)\n",ret));
            return(FALSE);
        }

        /*
         * Build up szShareKey
         */
        StringCchPrintfA( szShareKey,
            DDE_SHARE_KEY_MAX,
            "%s\\%s",
            DDE_SHARES_KEY_A,
            szShareNames[nLoop] );

        /*
         * Now open up the base share
         */
        ret = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szShareKey,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                &hKey);

        if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegOpenKeyEx failed on HKEY_LOCAL_MACHINE\\%s. (%u)\n",
                    szShareKey, ret));
            if (ret != ERROR_ACCESS_DENIED) {
                return(FALSE);
            }
        }

        if (ret == ERROR_SUCCESS) {
            ret = RegSetValueEx( hKey,
    		       KEY_MODIFY_ID,
    		       0,
    		       REG_BINARY,
    		       (LPBYTE)&dwId,
    		       KEY_MODIFY_ID_SIZE );

            RegCloseKey(hKey);

            if (ret != ERROR_SUCCESS) {
                KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx on HKEY_LOCAL_MACHINE\\%s failed (%u)\n",
                        KEY_MODIFY_ID, ret));
                return(FALSE);
            }
        }

    } // end for

    return(TRUE);
}



BOOL
GetDBInstance(char *lpszBuf)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwInstance;
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(DWORD);

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegOpenKeyEx %s failed (%u)\n",szShareKey,lRtn));
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegQueryValueEx failed (%u)\n",lRtn));
        return(FALSE);
    }
    StringCchPrintfA(lpszBuf, TRUSTED_SHARES_KEY_SIZE + 1, "%s%08X", TRUSTED_SHARES_KEY_PREFIX, dwInstance);
    return(TRUE);
}


BOOL
GetDBSerialNumber(
DWORD *lpdwId)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwType = REG_BINARY;
    DWORD   cbData = KEY_MODIFY_ID_SIZE;

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_MODIFY_ID,
                NULL,
                &dwType,
                (LPBYTE)lpdwId, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    return(TRUE);
}

// end_setup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\udspt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "UDSPT.C;1  16-Dec-92,10:23:14  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define LINT_ARGS
#include <stdio.h>
#include "windows.h"
#include "debug.h"

extern char     szAppName[];

PSTR
FAR PASCAL
GetAppName(void)
{
    return( szAppName );
}


/*
    This routine is a general way to get memory.
 */

HANDLE
FAR PASCAL
GetGlobalAlloc(
    WORD    wFlags,
    DWORD   lSize)
{
    HANDLE      hMem;

    /* try the regular alloc first */
    hMem = GlobalAlloc( wFlags, lSize );
    if( hMem == (HANDLE) NULL )  {

        /* try compacting the global heap */
        GlobalCompact( (DWORD)0x7FFFFFFFL );
        hMem = GlobalAlloc( wFlags, lSize );
    }

    if( hMem == (HANDLE) NULL )  {
        DPRINTF(("Out of Memory (%d bytes needed)", lSize));
    }

    return( hMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\proflspt.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "PROFLSPT.C;2  23-Dec-92,17:54:44  LastEdit=IGOR  Locker=IGOR" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#define NOCOMM
#include <stdlib.h>
#include <string.h>
#include "windows.h"
#include "tmpbuf.h"
#include "proflspt.h"
#include <stdio.h>
#include <strsafe.h>

#define NDDE_REG_PARAMETERS "Software\\Microsoft\\NetDDE\\Parameters"

BOOL
WINAPI
TestPrivateProfile(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszFile )
{
    HKEY        hKey;
    LONG        ret;
    char        szKeySpec[ 1024 ];
    DWORD       cbId = 1024;
    DWORD       dwType = 0;

    StringCchPrintf( szKeySpec, sizeof(szKeySpec), "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
        szKeySpec,
        0,
        KEY_READ,
        &hKey );
    if( ret == ERROR_SUCCESS )  {
        ret = RegQueryValueEx( hKey,
            (LPSTR)lpszKey,
            NULL,
            &dwType,
            (LPBYTE)szKeySpec,
            &cbId );
        RegCloseKey( hKey );
    }
    return(ret == ERROR_SUCCESS);
}



BOOL
WINAPI
MyWritePrivateProfileString(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszString,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret = -1;
    char    szKeySpec[ 1024 ];
    WCHAR   szValueBuf[512];
    WCHAR   szKeyBuf[256];
    DWORD   cbSize;
    DWORD   dwDisposition;

    StringCchPrintf( szKeySpec, sizeof(szKeySpec), "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    cbSize = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
        lpszString, -1,
        (LPWSTR)szValueBuf, 512);

    if (cbSize) {
        ret = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
            szKeySpec,
            0,
            "NetDDEParameter",
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            (LPSECURITY_ATTRIBUTES) NULL,
            &hKey,
            &dwDisposition );

        if( ret == ERROR_SUCCESS )  {
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                lpszKey, -1,
                (LPWSTR)szKeyBuf, 256);

            ret = RegSetValueExW( hKey,
                (LPWSTR)szKeyBuf,
                (DWORD_PTR)NULL,
                REG_SZ,
                (LPBYTE)szValueBuf,
                cbSize * sizeof(WCHAR) );

            RegCloseKey( hKey );
        }
    }

    return( ret == ERROR_SUCCESS );
}


BOOL
FAR PASCAL
MyWritePrivateProfileInt(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
	int     nValue,
    LPSTR   lpFileName )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    DWORD   dwDisposition;

    StringCchPrintf( szKeySpec, sizeof(szKeySpec), "%s\\%s", NDDE_REG_PARAMETERS, lpAppName );

    ret = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                          szKeySpec,
                          0,
                          "NetDDEParameter",
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          (LPSECURITY_ATTRIBUTES) NULL,
                          &hKey,
                          &dwDisposition );

    if( ret == ERROR_SUCCESS )  {

        ret = RegSetValueEx( hKey,
                             (LPSTR)lpKeyName,
                             (DWORD_PTR)NULL,
                             REG_DWORD,
                             (LPBYTE)&nValue,
                             sizeof(nValue) );
        RegCloseKey( hKey );
    }

    return( ret == ERROR_SUCCESS );
}



BOOL
FAR PASCAL
WritePrivateProfileLong(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
    LONG    lValue,
    LPSTR   lpFileName )
{
    return( MyWritePrivateProfileInt( lpAppName, lpKeyName,
        lValue, lpFileName ) );
}


UINT
WINAPI
MyGetPrivateProfileInt(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    INT     dwDefault,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    BOOL    bRetrieved = FALSE;
    DWORD   dwValue;
    DWORD   cbId = sizeof(dwValue);
    DWORD   dwType = 0;

    StringCchPrintf( szKeySpec, sizeof(szKeySpec), "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
        szKeySpec,
        0,
        KEY_READ,
        &hKey );

    if( ret == ERROR_SUCCESS )  {
	    ret = RegQueryValueEx( hKey,
            (LPSTR)lpszKey,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &cbId );

        if( ret == ERROR_SUCCESS )  {
            if( dwType == REG_DWORD )  {
                bRetrieved = TRUE;
            }
        }
	RegCloseKey( hKey );
    }
    if( bRetrieved )  {
        return( dwValue );
    } else {
        return( dwDefault );
    }
}




DWORD
WINAPI
MyGetPrivateProfileString(
    LPCSTR  lpszSection,
    LPCSTR  lpszKey,
    LPCSTR  lpszDefault,
    LPSTR   lpszReturnBuffer,
    DWORD   cbReturnBuffer,
    LPCSTR  lpszFile )
{
    HKEY    hKey;
    int     ret;
    char    szKeySpec[ 1024 ];
    WCHAR   szKeyBuf[256];
    WCHAR   szValueBuf[512];
    BOOL    bRetrieved = FALSE;
    DWORD   cbId = 512*sizeof(WCHAR);
    DWORD   dwType = 0;
    BOOL    fWide;

    StringCchPrintf( szKeySpec, sizeof(szKeySpec), "%s\\%s", NDDE_REG_PARAMETERS, lpszSection );

    ret = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szKeySpec,
                        0,
                        KEY_READ,
                        &hKey );

    if( ret == ERROR_SUCCESS )  {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                             lpszKey, -1,
                             (LPWSTR)szKeyBuf, 256);

        ret = RegQueryValueExW( hKey,
                                (LPWSTR)szKeyBuf,
                                NULL,
                                &dwType,
                                (LPBYTE)szValueBuf,
                                &cbId );

        if (ret == ERROR_SUCCESS) {

            if( dwType == REG_SZ )  {
                cbId = WideCharToMultiByte(
                           CP_ACP,
                           WC_COMPOSITECHECK,
                           (LPWSTR) szValueBuf,
                           cbId / sizeof(WCHAR),
                           lpszReturnBuffer,
                           cbReturnBuffer,
                           NULL,
                           &fWide );
                if (cbId) {
                    bRetrieved = TRUE;
                }
            }
        }

        RegCloseKey( hKey );
    }

    if( !bRetrieved )  {
        strncpy( lpszReturnBuffer, lpszDefault, cbReturnBuffer );
    }

    if( cbReturnBuffer > 0 )  {
        lpszReturnBuffer[cbReturnBuffer-1] = '\0';
    }

    return( lstrlen(lpszReturnBuffer) );
}



LONG
FAR PASCAL
GetPrivateProfileLong(
    LPSTR   lpAppName,
    LPSTR   lpKeyName,
    LONG    lDefault,
    LPSTR   lpFileName )
{
    return( MyGetPrivateProfileInt( lpAppName, lpKeyName,
        lDefault, lpFileName ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\netdde\src\toolkit\ntdebug.c ===
/* $Header: "%n;%v  %f  LastEdit=%w  Locker=%l" */
/* "NTDEBUG.C;1  16-Dec-92,10:22:54  LastEdit=IGOR  Locker=***_NOBODY_***" */
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
/* $History: Beg
   $History: End */

#include "api1632.h"

#include <time.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "windows.h"
#include "hardware.h"
#include "proflspt.h"

char szDebugFileName[256] = "netdde.log";
static char szAppName[128] = "NetDDE";
static BOOL bDebugEnabled;
BOOL fPrintToDebugger = FALSE;

#define MAX_LINE_LEN1    1024
#define MAX_LINE_LEN2    1280

void
print_buf(char *pbuf)
{
    FILE    *fp;

    fp = fopen(szDebugFileName, "at");
    if( fp )  {
    	fputs(pbuf, fp);
    	fclose(fp);
    }
    if (fPrintToDebugger)
        OutputDebugStringA(pbuf);
}

VOID
_cdecl
debug( LPSTR name1, ...)

{
    char       *buf1;
    char       *buf2;
    char        stime[ 27 ];
    char       *p;
    time_t      curtime;
    va_list	marker;


    if( !bDebugEnabled )  {
	    return;
    }

    if ( NULL == (buf1 = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    if ( NULL == (buf2 = LocalAlloc(GPTR, MAX_LINE_LEN2)) )  {
        LocalFree(buf1);
        return;
    }

    time( &curtime );
    strncpy( stime, ctime(&curtime),sizeof(stime) );
    stime[24] = '\0';

    strncpy(buf2, name1, MAX_LINE_LEN2);
    p = buf2;

    //  Remove all F's from any format specifications
    //  must use memmove for overlapping buffers
    while (p = strstr(p, "%F")) {
        memmove(p+1, p+2, strlen(p+2)+1);
    }

    va_start(marker, name1);
    _vsnprintf( buf1, MAX_LINE_LEN1, buf2,  marker );
    _snprintf(  buf2, MAX_LINE_LEN2, "%s %-8s %s\n", stime, szAppName, buf1 );
    print_buf(buf2);
    va_end(marker);

    LocalFree(buf1);
    LocalFree(buf2);
}

void
_cdecl
InternalError( LPSTR   name1, ... )
{
    char       *buf1;
    char       *buf2;
    char        stime[ 27 ];
    time_t      curtime;
    va_list	marker;

    if ( NULL == (buf1 = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    if ( NULL == (buf2 = LocalAlloc(GPTR, MAX_LINE_LEN2)) )  {
        LocalFree(buf1);
        return;
    }

    time( &curtime );
    strncpy( stime, ctime(&curtime), sizeof(stime));
    stime[24] = '\0';

    va_start(marker, name1);
    _vsnprintf( buf1, MAX_LINE_LEN1, name1, marker );
    _snprintf(  buf2, MAX_LINE_LEN2, "INTERNAL ERROR: %s %s\n", stime, buf1 );
    print_buf(buf2);

    LocalFree(buf1);
    LocalFree(buf2);
}

void
FAR PASCAL
AssertLog(
    LPSTR   filename,
    int     len )
{
    char       *buf;
    char        stime[ 27 ];
    time_t      curtime;

    if ( NULL == (buf = LocalAlloc(GPTR, MAX_LINE_LEN1)) )  {
        return;
    }
    time( &curtime );
    strncpy( stime, ctime(&curtime), sizeof(stime));
    stime[24] = '\0';

    _snprintf( buf, MAX_LINE_LEN1, "ASSERTION: %s %s Line %d\n", stime, filename, len );
    print_buf( buf );

    LocalFree(buf);
}


VOID
FAR PASCAL
DebugInit( LPSTR lpszDebugName )
{
    char szDebugDir[256] = "C:\\";

    GetSystemDirectory( szDebugDir, sizeof(szDebugDir) );
    MyGetPrivateProfileString( "General", "DebugPath",
        szDebugDir, szDebugFileName, sizeof(szDebugFileName), "netdde.ini");

    if (strlen(szDebugFileName) < sizeof(szDebugFileName) - 11 )   {
        strcat( szDebugFileName, "\\netdde.log" );
    }

    bDebugEnabled = MyGetPrivateProfileInt( "General", "DebugEnabled",
	    TRUE, "netdde.ini" );

    lstrcpyn( szAppName, lpszDebugName, sizeof(szAppName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\inc\fwd_macros.h ===
#ifndef _FWD_MACROS_H_
#define _FWD_MACROS_H_


#define AS_DECL_0
#define AS_CALL_0

#define AS_DECL_1(t1,a1) (t1 a1)
#define AS_CALL_1(t1,a1) (a1)

#define AS_DECL_2(t1,a1,t2,a2) (t1 a1,t2 a2)
#define AS_CALL_2(t1,a1,t2,a2) (a1,a2)

#define AS_DECL_3(t1,a1,t2,a2,t3,a3) (t1 a1,t2 a2,t3 a3)
#define AS_CALL_3(t1,a1,t2,a2,t3,a3) (a1,a2,a3)

#define AS_DECL_4(t1,a1,t2,a2,t3,a3,t4,a4) (t1 a1,t2 a2,t3 a3,t4 a4)
#define AS_CALL_4(t1,a1,t2,a2,t3,a3,t4,a4) (a1,a2,a3,a4)

#define AS_DECL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5)
#define AS_CALL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (a1,a2,a3,a4,a5)

#define AS_DECL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6)
#define AS_CALL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (a1,a2,a3,a4,a5,a6)

#define AS_DECL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7)
#define AS_CALL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (a1,a2,a3,a4,a5,a6,a7)

#define AS_DECL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8)
#define AS_CALL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (a1,a2,a3,a4,a5,a6,a7,a8)

#define AS_DECL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9)
#define AS_CALL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (a1,a2,a3,a4,a5,a6,a7,a8,a9)

#define AS_DECL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10)
#define AS_CALL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

#define AS_DECL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10,t11 a11)
#define AS_CALL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)


#define AS_DECL( n, p )  AS_DECL_ ## n p
#define AS_CALL( n, p )  AS_CALL_ ## n p


#endif // _FWD_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\inc\msctfx.h ===
DEFINE_GUID( IID_ITfSource,                 0x4ea48a35, 0x60ae, 0x446f, 0x8f, 0xd6, 0xe6, 0xa8, 0xd8, 0x24, 0x59, 0xf7);
DEFINE_GUID( IID_ITfKeystrokeMgr,           0xaa80e7f0, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfThreadMgr,              0xaa80e801, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfServiceProvider,        0xaa80e806, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfActivateInputProcessor, 0x32239201, 0xbbab, 0x47e5, 0xa5, 0x10, 0x66, 0x5f, 0xa3, 0xbd, 0x62, 0x64);
DEFINE_GUID( IID_ITfHotKeyMgr,              0xa998fa53, 0x6ada, 0x4f5a, 0x84, 0xed, 0xc2, 0x67, 0x0f, 0xbd, 0x0b, 0xdd);

DEFINE_GUID( IID_ITextStoreACPServices,     0xaa80e901, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITextStoreAnchorServices,  0xaa80e9fe, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( CLSID_ThreadMgr,               0xaa80e7f1, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( IID_ITfTextStoreACP,           0xaa80e800, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);
DEFINE_GUID( IID_ITfTextStoreAnchor,		0xaa80e9ff, 0x2021, 0x11d2, 0x93, 0xe0, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e);

DEFINE_GUID( IID_ITfCompartmentMgr,         0x7dcf57ac, 0x18ad, 0x438b, 0x82, 0x4d, 0x97, 0x9b, 0xff, 0xb7, 0x4b, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\common\debug.cpp ===
#include <windows.h>

#include <debug.h>
#include <crtdbg.h>
#include <tstr.h>

#include <stdarg.h>


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define TRACE_HRESULT   0x01
#define TRACE_Win32     0x02


void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ...);

void WriteFilename( TSTR & msg, LPCTSTR pFile );

void StackTrace( TSTR & str );


LPCTSTR g_pLevelStrs [ ] = 
{
    TEXT("DBG"),
    TEXT("INF"),
    TEXT("WRN"),
    TEXT("ERR"),
    TEXT("PRM"),
    TEXT("PRW"),
    TEXT("IOP"),
    TEXT("ASD"),
    TEXT("ASR"),
    TEXT("CAL"),
    TEXT("RET"),
    TEXT("???"),
};


static
void InternalTrace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, DWORD dwFlags, const void * pThis, HRESULT hr, LPCTSTR pStr )
{
    if( dwLevel >= ARRAYSIZE( g_pLevelStrs ) )
        dwLevel = ARRAYSIZE( g_pLevelStrs ) - 1; // "???" unknown entry

    // Basic message stuff - pid, tid... (also pass this and use object ptr?)
    // TODO - allow naming of threads?

    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();
    
    // Module:file:line pid:tid str
    TSTR msg(512);
    msg << g_pLevelStrs[ dwLevel ] << TEXT(" ");

    if( ! pFile )
	    WriteFilename( msg, TEXT("[missing file]") );
	else
	    WriteFilename( msg, pFile );

    msg << TEXT(":")
        << uLineNo << TEXT(" ")
        << WriteHex( pid ) << TEXT(":")
        << WriteHex( tid ) << TEXT(" ");

    if( pThis )
    {
        msg << TEXT("this=") << WriteHex( pThis, 8 ) << TEXT(" ");
    }

    if( dwFlags & TRACE_HRESULT )
    {
        msg << WriteError( hr ) << TEXT(" ");
    }

    if( dwFlags & TRACE_Win32 )
    {
        msg << WriteError( GetLastError() ) << TEXT(" ");
    }

    if( ! pStr )
	    msg << TEXT("[missing string]") << TEXT("\r\n");
	else
	    msg << pStr << TEXT("\r\n");

    // For the moment, just send to DBWIN...
//	OutputDebugString( msg );
    OutputDebugStringDBWIN( msg );

#ifdef DEBUG
    if( dwLevel == _TRACE_ASSERT_D || dwLevel == _TRACE_ERR )
    {
    	_ASSERT(0);
//        DebugBreak();
    }
#endif // DEBUG
}


void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pStr );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, HRESULT hr, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pStr );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pStr );
}



// Add just the 'filename' part of the full path, minus base and extention.
// So for "g:\dev\vss\msaa\common\file.cpp", write "file".
// The start of this string is that last found ':', '\', or start of string if those are not present.
// The end of this string is the last '.' found after the start position, otherwise the end of the string.
void WriteFilename( TSTR & str, LPCTSTR pPath )
{
    LPCTSTR pScan = pPath;
    LPCTSTR pStart = pPath;
    LPCTSTR pEnd = NULL;

    // Scan till we hit the end, or a '.'...
    while( *pScan != '\0' )
    {
        if( *pScan == '.' )
        {
            pEnd = pScan;
            pScan++;
        }
        if( *pScan == '\\' || *pScan == ':'  )
        {
            pScan++;
            pStart = pScan;
            pEnd = NULL;
        }
        else
        {
            pScan++;
        }
    }

    if( pEnd == NULL )
        pEnd = pScan;

    str.append( pStart, pEnd - pStart );
}









void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ... )
{
    // create the output buffer
    TCHAR achBuffer[500];
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);


    // make sure DBWIN is open and waiting
    HANDLE heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if( !heventDBWIN )
    {
        //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
        return;            
    }

    // get a handle to the data synch object
    HANDLE heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
        CloseHandle(heventDBWIN);
        return;            
    }
    
    HANDLE hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    LPSTR lpszSharedMem = (LPSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // wait for buffer event
    WaitForSingleObject(heventDBWIN, INFINITE);

    // write it to the shared memory
    *((LPDWORD)lpszSharedMem) = GetCurrentProcessId();
#ifdef UNICODE
	CHAR szBuf[500];
	wcstombs(szBuf, achBuffer, sizeof( szBuf ) );
    sprintf(lpszSharedMem + sizeof(DWORD), "%s", szBuf);
#else
    sprintf(lpszSharedMem + sizeof(DWORD), "%s", achBuffer);
#endif

    // signal data ready event
    SetEvent(heventData);

    // clean up handles
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}












// Prototype stack trace code...





typedef struct _IMAGEHLP_SYMBOL {
    DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD                       Address;                // virtual address including dll base address
    DWORD                       Size;                   // estimated size of symbol, can be zero
    DWORD                       Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef enum {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64 {
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

typedef struct _tagADDRESS {
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

typedef struct _KDHELP {
    DWORD   Thread;
    DWORD   ThCallbackStack;
    DWORD   NextCallback;
    DWORD   FramePointer;
    DWORD   KiCallUserMode;
    DWORD   KeUserCallbackDispatcher;
    DWORD   SystemRangeStart;
    DWORD   ThCallbackBStore;
    DWORD  Reserved[8];
} KDHELP, *PKDHELP;

typedef struct _tagSTACKFRAME {
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;

typedef
BOOL
(__stdcall *PREAD_PROCESS_MEMORY_ROUTINE)(
    HANDLE  hProcess,
    LPCVOID lpBaseAddress,
    PVOID   lpBuffer,
    DWORD   nSize,
    PDWORD  lpNumberOfBytesRead
    );

typedef
PVOID
(__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef
DWORD
(__stdcall *PGET_MODULE_BASE_ROUTINE)(
    HANDLE  hProcess,
    DWORD   Address
    );

typedef
DWORD
(__stdcall *PTRANSLATE_ADDRESS_ROUTINE)(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS lpaddr
    );






typedef BOOL (WINAPI * PFN_SymInitialize)( HANDLE, LPSTR, BOOL );
typedef BOOL (WINAPI * PFN_StackWalk)( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
                                       PREAD_PROCESS_MEMORY_ROUTINE,
                                       PFUNCTION_TABLE_ACCESS_ROUTINE,
                                       PGET_MODULE_BASE_ROUTINE,
                                       PTRANSLATE_ADDRESS_ROUTINE );
typedef LPVOID (WINAPI * PFN_SymFunctionTableAccess)( HANDLE, DWORD );
typedef DWORD (WINAPI * PFN_SymGetModuleBase)( HANDLE, DWORD );
typedef BOOL (WINAPI * PFN_SymGetSymFromAddr)( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL (WINAPI * PFN_SymCleanup)( HANDLE hProcess );


PFN_SymInitialize           pfnSymInitialize;
PFN_StackWalk               pfnStackWalk;
PFN_SymFunctionTableAccess  pfnSymFunctionTableAccess;
PFN_SymGetModuleBase        pfnSymGetModuleBase;
PFN_SymGetSymFromAddr       pfnSymGetSymFromAddr;
PFN_SymCleanup              pfnSymCleanup;


#ifdef _ALPHA_
#define CH_MACHINE IMAGE_FILE_MACHINE_ALPHA
#else
#define CH_MACHINE IMAGE_FILE_MACHINE_I386
#endif


#define MAX_SYM_LEN 128

void StackTrace1( EXCEPTION_POINTERS *exp, TSTR & str );

#define MY_DBG_EXCEPTION 3

void StackTrace( TSTR & str )
{
    __try {
        // raise an exception to get the exception record to start the stack walk
        RaiseException(MY_DBG_EXCEPTION, 0, 0, NULL);
    }
    __except( StackTrace1( GetExceptionInformation(), str ), EXCEPTION_CONTINUE_EXECUTION ) {
    }
}



void StackTrace1( EXCEPTION_POINTERS *exp, TSTR & str )
{
#ifdef DBG

    // don't load debug libraries in retail builds
    
    CONTEXT * context = exp->ContextRecord;


HMODULE hModule = LoadLibrary( TEXT( "dbghelp" ) );
pfnSymInitialize =          (PFN_SymInitialize)             GetProcAddress( hModule, "SymInitialize" );
pfnStackWalk =              (PFN_StackWalk)                 GetProcAddress( hModule, "StackWalk" );
pfnSymFunctionTableAccess = (PFN_SymFunctionTableAccess)    GetProcAddress( hModule, "SymFunctionTableAccess" );
pfnSymGetModuleBase =       (PFN_SymGetModuleBase)          GetProcAddress( hModule, "SymGetModuleBase" );
pfnSymGetSymFromAddr =      (PFN_SymGetSymFromAddr)         GetProcAddress( hModule, "SymGetSymFromAddr" );
pfnSymCleanup =             (PFN_SymCleanup)                GetProcAddress( hModule, "SymCleanup" );



    HANDLE hProcess = GetCurrentProcess();
    HANDLE hThread = GetCurrentThread();

    pfnSymInitialize( hProcess, NULL, TRUE );

    IMAGEHLP_SYMBOL * psym = (IMAGEHLP_SYMBOL *) new char[ sizeof(IMAGEHLP_SYMBOL) + MAX_SYM_LEN ];

    STACKFRAME frame;
    memset( &frame, 0, sizeof( frame ) );

#if defined (_M_IX86)
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    frame.AddrPC.Offset       = context->Eip;
    frame.AddrPC.Mode         = AddrModeFlat;
    frame.AddrFrame.Offset    = context->Ebp;
    frame.AddrFrame.Mode      = AddrModeFlat;
    frame.AddrStack.Offset    = context->Esp;
    frame.AddrStack.Mode      = AddrModeFlat;
#endif // _M_IX86

    for( ; ; )
    {
        BOOL bSWRet = pfnStackWalk( CH_MACHINE,
                                    hProcess,
                                    hThread,
                                    & frame,
                                    NULL, // CONTEXT - NULL for i386
                                    NULL, // Use ReadProcessMemory
                                    pfnSymFunctionTableAccess,
                                    pfnSymGetModuleBase,
                                    NULL );
        if( ! bSWRet )
        {
            break;
        }
/*
        frame.AddrPC
        frame.AddrReturn
        frame.AddrFrame
        frame.AddrStack
        frame.Params[ 4 ]
*/
        psym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        psym->MaxNameLength = MAX_SYM_LEN;

        DWORD dwDisplacement;
        if( pfnSymGetSymFromAddr( hProcess, frame.AddrPC.Offset, & dwDisplacement, psym ) )
        {
        }
        else
        {
        }

    }

    delete [] psym;

    pfnSymCleanup( hProcess );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\inc\list_dl.h ===
template <class T> class List_dl;
template <class T> class Iter_dl;


template <class T>
class Link_dl
{
    Link_dl<T> *  m_pPrev;
    Link_dl<T> *  m_pNext;

    friend class List_dl<T>;
    friend class Iter_dl<T>;

public:

    Link_dl()
        : m_pPrev( NULL ),
          m_pNext( NULL )
    {
        // Do nothing
    }

    ~Link_dl()
    {
        AssertMsg( m_pNext == NULL && m_pPrev == NULL,
                   TEXT("~Link_dl(), link still on a list?") );
    }

    T * getNext() const
    {
        return (T *) m_pNext;
    }

    T * getPrev() const
    {
        return (T *) m_pPrev;
    }
};


template <class T>
class List_dl
{
    Link_dl<T> *  m_pHead;
    Link_dl<T> *  m_pTail;

    friend class Iter_dl<T>;

public:

    List_dl()
        : m_pHead( NULL ),
          m_pTail( NULL )
    {
        // Do nothing
    }

    ~List_dl()
    {
        AssertMsg( m_pHead == NULL && m_pTail == NULL, TEXT("~List_dl(), list not empty?") );
    }

    void AddToHead( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                        TEXT("dl-addToHead(), link still on some other list?") );

        pEl->m_pPrev = NULL;
        pEl->m_pNext = m_pHead;
        if( m_pHead )
            m_pHead->m_pPrev = pEl;
        else
            m_pTail = pEl;
        m_pHead = pEl;
    }

    void AddToTail( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-addToTail(), link still on some other list?") );

        pEl->m_pPrev = m_pTail;
        pEl->m_pNext = NULL;
        if( m_pTail )
            m_pTail->m_pNext = pEl;
        else
            m_pHead = pEl;
        m_pTail = pEl;
    }

    void InsertBefore( Link_dl<T> * pRef, Link_dl<T> * pEl )
    {
        AssertMsg( ! pRef || pRef->m_pNext != NULL || pRef->m_pPrev != NULL || m_pHead == pRef,
                TEXT("dl-InsertBefore(), pRef is not on the list?") );
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-InsertBefore(), pEl is still on some other list?") );

        if( ! pRef )
            AddToTail( pEl );
        else
        {
            pEl->m_pNext = pRef;
            pEl->m_pPrev = pRef->m_pPrev;

            if( pRef->m_pPrev )
                pRef->m_pPrev->m_pNext = pEl;
            else
                m_pHead = pEl;

            pRef->m_pPrev = pEl;
        }
    }

    void InsertAfter( Link_dl<T> * pRef, Link_dl<T> * pEl )
    {
        AssertMsg( ! pRef || pRef->m_pNext != NULL || pRef->m_pPrev != NULL || m_pHead == pRef,
                TEXT("dl-InsertAfter(), pRef is not on the list?") );
        AssertMsg( pEl->m_pNext == NULL && pEl->m_pPrev == NULL,
                TEXT("dl-InsertAfter(), pEl is still on some other list?") );

        if( ! pRef )
            AddToHead( pEl );
        else
        {
            pEl->m_pNext = pRef->m_pPref;
            pEl->m_pPrev = pRef;

            if( pRef->m_pNext )
                pRef->m_pNext->m_pPrev = pEl;
            else
                m_pTail = pEl;

            pRef->m_pNext = pEl;
        }
    }

    void remove( Link_dl<T> * pEl )
    {
        AssertMsg( pEl->m_pNext != NULL || pEl->m_pPrev != NULL || m_pHead == pEl,
                TEXT("dl-remove(), pEl is not on the list") );

        if( pEl->m_pPrev )
            pEl->m_pPrev->m_pNext = pEl->m_pNext;
        else
            m_pHead = pEl->m_pNext;
        if( pEl->m_pNext )
            pEl->m_pNext->m_pPrev = pEl->m_pPrev;
        else
            m_pTail = pEl->m_pNext;

        pEl->m_pPrev = NULL;
        pEl->m_pNext = NULL;
    }

    bool empty() const
    {
        return m_pHead == NULL;
    }

    T * getHead() const
    {
        return (T *) m_pHead;
    }

    T * getTail() const
    {
        return (T *) m_pTail;
    }
};



template <class T>
class Iter_dl
{

    Link_dl<T> *  m_pPos;

public:

    Iter_dl( const List_dl<T> & l )
    {
        m_pPos = l.m_pHead;
    }

    BOOL AtEnd() const
    {
        return m_pPos == NULL;
    }

    T * operator ++ (int) 
    {
        m_pPos = m_pPos->m_pNext;
        return (T *) m_pPos;
    }

    T * operator ++ () 
    {
        m_pPos = m_pPos->m_pNext;
        return (T *) m_pPos;
    }

    T * operator -- (int) 
    {
        m_pPos = m_pPos->m_pPrev;
        return (T *) m_pPos;
    }

    T * operator -- () 
    {
        m_pPos = m_pPos->m_pPrev;
        return (T *) m_pPos;
    }

    T * operator -> () const
    {
        return (T *) m_pPos;
    }

    T * operator () () const
    {
        return (T *) m_pPos;
    }


    operator T * () const
    {
        return (T *) m_pPos;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\inc\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_



// Debug     - used to track specific problems during debugging. Debug's are temporary,
//             and should be removed (or promoted to Info/Warning's) before check-in.
// Info      - general information during normal operation
// Warning   - warnings, recoverable errors
// Error     - things that shouldn't happen
// Param     - incorect params passed in, etc.
// Interop   - unexpected return codes/behavior from other (external) components
// Assert    - Assert-level really-shouldn't-happen errors.


#define _TRACE_DEBUG    0
#define _TRACE_INFO     1
#define _TRACE_WARNING  2
#define _TRACE_ERROR    3

#define _TRACE_PARAM    4
#define _TRACE_PARAWARN 5
#define _TRACE_INTEROP  6

#define _TRACE_ASSERT_D 7   // Debug-build assert - really does assert
#define _TRACE_ASSERT_R 8   // Release-build assert - only logs error, doesn't halt program

#define _TRACE_CALL     9
#define _TRACE_RET      10



void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void *  pThis, LPCTSTR pStr );
// Also adds message corresponding to HRESULT...
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, HRESULT hr, LPCTSTR pStr );
// Also adds message corresponding to GetLastError()...
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pStr );


//
// _DTrace* is debug-only, while _Trace is debug and release...
//

#ifdef _DEBUG

#define _DTrace( pFile, uLineNo, dwLevel, pThis, pStr )         _Trace( pFile, uLineNo, dwLevel, pThis, pStr )
#define _DTraceHR( pFile, uLineNo, dwLevel, pThis, hr, pStr )   _TraceHR( pFile, uLineNo, dwLevel, pThis, hr, pStr )
#define _DTraceW32( pFile, uLineNo, dwLevel, pThis, pStr )      _TraceW32( pFile, uLineNo, dwLevel, pThis, pStr )

#define _TRACE_ASSERT _TRACE_ASSERT_D


class DebugCallRetTracker
{
    const void *    m_pThis;
    LPCTSTR         m_pMethodName;
    LPCTSTR         m_pFile;
    ULONG           m_Line;

public:

    DebugCallRetTracker( const void * pThis, LPCTSTR pMethodName, LPCTSTR pFile, ULONG Line )
        : m_pThis( pThis ),
          m_pMethodName( pMethodName ),
          m_pFile( pFile ),
          m_Line( Line )
    {
        _Trace( m_pFile, m_Line, _TRACE_CALL, m_pThis, m_pMethodName ); 
    }

    ~DebugCallRetTracker( )
    {
        _Trace( m_pFile, m_Line, _TRACE_RET, m_pThis, m_pMethodName ); 
    }
};


#define IMETHOD( name )     DebugCallRetTracker IMETHOD_temp_var( this, TEXT( # name ), TEXT( __FILE__ ), __LINE__ )


#else // _DEBUG

#define _DTrace( pFile, uLineNo, dwLevel, pThis, pStr )
#define _DTraceHR( pFile, uLineNo, dwLevel, hr, pThis, pStr )
#define _DTraceW32( pFile, uLineNo, dwLevel, pThis, pStr )

#define IMETHOD( name )

#define _TRACE_ASSERT _TRACE_ASSERT_R

#endif // _DEBUG


#define Assert( cond )          if( cond ) { } else _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ASSERT, NULL, TEXT( # cond ) )
#define AssertMsg( cond, str )  if( cond ) { } else _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ASSERT, NULL, str )

#define TraceDebug( str )           _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, str )
#define TraceInfo( str )            _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, str )
#define TraceWarning( str )         _DTrace( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, str )
#define TraceError( str )           _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, str )
#define TraceParam( str )           _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, str )
#define TraceParamWarn( str )       _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, str )
#define TraceInterop( str )         _Trace( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, str )

#define TraceDebugHR( hr, str )     _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, hr, str )
#define TraceInfoHR( hr, str )      _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, hr, str )
#define TraceWarningHR( hr, str )   _DTraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, hr, str )
#define TraceErrorHR( hr, str )     _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, hr, str )
#define TraceParamHR( hr, str )     _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, hr, str )
#define TraceParamWarnHR( hr, str ) _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, hr, str )
#define TraceInteropHR( hr, str )   _TraceHR( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, hr, str )

#define TraceDebugW32( str )        _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_DEBUG, NULL, str )
#define TraceInfoW32( str )         _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_INFO, NULL, str )
#define TraceWarningW32( str )      _DTraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_WARNING, NULL, str )
#define TraceErrorW32( str )        _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_ERROR, NULL, str )
#define TraceParamW32( str )        _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_PARAM, NULL, str )
#define TraceParamWarnW32( str )    _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_PARAMWARN, NULL, str )
#define TraceInteropW32( str )      _TraceW32( TEXT( __FILE__ ), __LINE__, _TRACE_INTEROP, NULL, str )



#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\common_src.cpp ===
// this is acting like a lib untile we make one

#include "..\common\debug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\dict.cpp ===
// Dict.cpp : Implementation of CDict
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAAdapter.h"
#include "Dict.h"

#include <initguid.h>
#include <tsattrs.h>
#include <math.h>


const int STR_RESOURCE_OFFSET				= 4000;
const int STR_WEIGHT_RESOURCE_OFFSET		= 4400;
const int STR_COLOR_RESOURCE_OFFSET			= 4500;
const int STR_BOOL_TRUE						= 4421;
const int STR_BOOL_FALSE					= 4422;

#define ARRAYSIZE( a )  (sizeof(a)/sizeof(a[0]))

DEFINE_GUID(GUID_NULL, 0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00);

TermInfo g_Terms [ ] = 
{
    {&TSATTRID_Font,							NULL,								L"font",				0,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_FaceName,					&TSATTRID_Font,						L"facename",			1,	CDict::ConvertBSTRToString },
    {&TSATTRID_Font_SizePts,					&TSATTRID_Font,						L"sizePts",				2,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style,						&TSATTRID_Font,						L"style",				3,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Bold,					&TSATTRID_Font_Style,				L"bold",				4,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Italic,				&TSATTRID_Font_Style,				L"italic",				5,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_SmallCaps,			&TSATTRID_Font_Style,				L"smallcaps",			6,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Capitalize,			&TSATTRID_Font_Style,				L"capitalize",			7,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Uppercase,			&TSATTRID_Font_Style,				L"uppercase",			8,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Lowercase,			&TSATTRID_Font_Style,				L"lowercase",			9,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation,			NULL,								L"animation",			10,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_LasVegasLights,		&TSATTRID_Font_Style_Animation,	L"LasVegas_lights",	11,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_BlinkingBackground,	&TSATTRID_Font_Style_Animation,	L"blinking_background",12,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_SparkleText,		&TSATTRID_Font_Style_Animation,	L"sparkle_text",	13,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_MarchingBlackAnts,	&TSATTRID_Font_Style_Animation,	L"marching_black_ants",14,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_MarchingRedAnts,	&TSATTRID_Font_Style_Animation,	L"marching_red_ants",15,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_Shimmer,	&TSATTRID_Font_Style_Animation,		L"shimmer",				16,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_WipeDown,	&TSATTRID_Font_Style_Animation,		L"wipeDown",			17,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Animation_WipeRight,	&TSATTRID_Font_Style_Animation,		L"wipeRight",			18,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Emboss,				&TSATTRID_Font_Style,				L"emboss",				19,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Engrave,				&TSATTRID_Font_Style,				L"engrave",				20,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Kerning,				&TSATTRID_Font_Style,				L"kerning",				21,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Outlined,				&TSATTRID_Font_Style,				L"outlined",			22,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Position,				&TSATTRID_Font_Style,				L"position",			23,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Protected,			&TSATTRID_Font_Style,				L"potected",			24,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Shadow,				&TSATTRID_Font_Style,				L"shadow",				25,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Spacing,				&TSATTRID_Font_Style,				L"spacing",				26,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style_Weight,				&TSATTRID_Font_Style,				L"weight",				27,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Height,				&TSATTRID_Font_Style,				L"height",				28,	CDict::ConvertPtsToString },
    {&TSATTRID_Font_Style_Underline,			&TSATTRID_Font_Style,				L"underline",			29,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Underline_Single,		&TSATTRID_Font_Style_Underline,		L"single",				30,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Underline_Double,		&TSATTRID_Font_Style_Underline,		L"double",				31,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough,		&TSATTRID_Font_Style,				L"strike_through",		32,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough_Single,	&TSATTRID_Font_Style_Strikethrough,	L"strike_through_single",33,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Strikethrough_Double,	&TSATTRID_Font_Style_Strikethrough,	L"strike_through_double",34,CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline,				&TSATTRID_Font_Style,				L"overline",			35,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline_Single,		&TSATTRID_Font_Style,				L"overline_single",		36,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Overline_Double,		&TSATTRID_Font_Style,				L"overline_double",		37,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Blink,				&TSATTRID_Font_Style,				L"blink",				38,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Subscript,			&TSATTRID_Font_Style,				L"subscript",			39,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Superscript,			&TSATTRID_Font_Style,				L"superscript",			40,	CDict::ConvertBoolToString },
    {&TSATTRID_Font_Style_Color,				&TSATTRID_Font_Style,				L"color",				41,	CDict::ConvertColorToString },
    {&TSATTRID_Font_Style_BackgroundColor,		&TSATTRID_Font_Style,				L"background_color",	42,	CDict::ConvertColorToString },
    {&TSATTRID_Text,							NULL,								L"text",				43,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_VerticalWriting,			&TSATTRID_Text,						L"vertical writing",	44,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_RightToLeft,				&TSATTRID_Text,						L"righttoleft",			45,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Orientation,				&TSATTRID_Text,						L"orientation",			46,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Language,					&TSATTRID_Text,						L"language",			47,	CDict::ConvertLangIDToString },
    {&TSATTRID_Text_ReadOnly,					&TSATTRID_Text,						L"read only",			48,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_EmbeddedObject,				&TSATTRID_Text,						L"embedded_object",		49,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Link,						&TSATTRID_Text,						L"link",				50,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment,					NULL,								L"alignment",			51,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Left,   			&TSATTRID_Text,						L"left",				52,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Right,  			&TSATTRID_Text,						L"right",				53,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Center, 			&TSATTRID_Text,						L"center",				54,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Alignment_Justify,			&TSATTRID_Text,						L"justify",				55,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Hyphenation,				&TSATTRID_Text,						L"hyphenation",			56,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para,						&TSATTRID_Text,						L"paragraph",			57,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_FirstLineIndent,		&TSATTRID_Text_Para,				L"first_line_indent",	58,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_LeftIndent,			&TSATTRID_Text_Para,				L"left-indent",			59,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_RightIndent,			&TSATTRID_Text_Para,				L"right_indent",		60,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_SpaceAfter,			&TSATTRID_Text_Para,				L"space_after",			61,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_SpaceBefore,			&TSATTRID_Text_Para,				L"space_before",		62,	CDict::ConvertPtsToString },
    {&TSATTRID_Text_Para_LineSpacing,			NULL,								L"line_spacing",		63,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Single,   	&TSATTRID_Text_Para,				L"single",				64,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_OnePtFive,	&TSATTRID_Text_Para,				L"one_pt_five",			65,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Double, 	&TSATTRID_Text_Para,				L"double",				66,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_AtLeast,	&TSATTRID_Text_Para,				L"at_least",			67,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Exactly,	&TSATTRID_Text_Para,				L"exactly",				68,	CDict::ConvertBoolToString },
    {&TSATTRID_Text_Para_LineSpacing_Multiple, 	&TSATTRID_Text_Para,				L"multiple",			69,	CDict::ConvertBoolToString },
    {&TSATTRID_List,							NULL,								L"list",				70,	CDict::ConvertBoolToString },
    {&TSATTRID_List_LevelIndel,					&TSATTRID_List,						L"indent level",		71,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type,             			NULL,								L"type",				72,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_Bullet,      			&TSATTRID_List,						L"bullet",				73,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_Arabic,      			&TSATTRID_List,						L"arabic",				74,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_LowerLetter, 			&TSATTRID_List,						L"lower_letter",		75,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_UpperLetter, 			&TSATTRID_List,						L"upper_letter",		76,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_LowerRoman,  			&TSATTRID_List,						L"lower_roman",			77,	CDict::ConvertBoolToString },
    {&TSATTRID_List_Type_UpperRoman,  			&TSATTRID_List,						L"upper_roman",			78,	CDict::ConvertBoolToString },
    {&TSATTRID_App,								NULL,								L"Application",			79,	CDict::ConvertBoolToString },
    {&TSATTRID_App_IncorrectSpelling,			&TSATTRID_App,						L"incorrect spelling",	80, CDict::ConvertBoolToString },
    {&TSATTRID_App_IncorrectGrammar,			&TSATTRID_App,						L"incorrect grammar",	81, CDict::ConvertBoolToString },
};

COLORREF g_ColorArray [] =
{
	RGB( 0xF0, 0xF8, 0xFF ),   // rgb 240,248,255	AliceBlue  		
	RGB( 0xFA, 0xEB, 0xD7 ),   // rgb 250,235,215	AntiqueWhite  	
	RGB( 0x00, 0xFF, 0xFF ),   // rgb 0,255,255		Aqua  			
	RGB( 0x7F, 0xFF, 0xD4 ),   // rgb 127,255,212	Aquamarine  	
	RGB( 0xF0, 0xFF, 0xFF ),   // rgb 240,255,255	Azure  			
	RGB( 0xF5, 0xF5, 0xDC ),   // rgb 245,245,220	Beige  			
	RGB( 0xFF, 0xE4, 0xC4 ),   // rgb 255,228,196	Bisque  		
	RGB( 0x00, 0x00, 0x00 ),   // rgb 0,0,0			Black  			
	RGB( 0xFF, 0xEB, 0xCD ),   // rgb 255,235,205	BlanchedAlmond  
	RGB( 0x00, 0x00, 0xFF ),   // rgb 0,0,255		Blue  			
	RGB( 0x8A, 0x2B, 0xE2 ),   // rgb 138,43,226	BlueViolet  	
	RGB( 0xA5, 0x2A, 0x2A ),   // rgb 165,42,42		Brown  			
	RGB( 0xDE, 0xB8, 0x87 ),   // rgb 222,184,135	BurlyWood  		
	RGB( 0x5F, 0x9E, 0xA0 ),   // rgb 95,158,160	CadetBlue  		
	RGB( 0x7F, 0xFF, 0x00 ),   // rgb 127,255,0		Chartreuse  	
	RGB( 0xD2, 0x69, 0x1E ),   // rgb 210,105,30	Chocolate  		
	RGB( 0xFF, 0x7F, 0x50 ),   // rgb 255,127,80	Coral  			
	RGB( 0x64, 0x95, 0xED ),   // rgb 100,149,237	CornflowerBlue  
	RGB( 0xFF, 0xF8, 0xDC ),   // rgb 255,248,220	Cornsilk  		
	RGB( 0xDC, 0x14, 0x3C ),   // rgb 220,20,60		Crimson  		
	RGB( 0x00, 0xFF, 0xFF ),   // rgb 0,255,255		Cyan  			
	RGB( 0x00, 0x00, 0x8B ),   // rgb 0,0,139		DarkBlue  		
	RGB( 0x00, 0x8B, 0x8B ),   // rgb 0,139,139		DarkCyan  		
	RGB( 0xB8, 0x86, 0x0B ),   // rgb 184,134,11	DarkGoldenrod  	
	RGB( 0xA9, 0xA9, 0xA9 ),   // rgb 169,169,169	DarkGray  		
	RGB( 0x00, 0x64, 0x00 ),   // rgb 0,100,0		DarkGreen 	 	
	RGB( 0xBD, 0xB7, 0x6B ),   // rgb 189,183,107	DarkKhaki  		
	RGB( 0x8B, 0x00, 0x8B ),   // rgb 139,0,139		DarkMagenta  	
	RGB( 0x55, 0x6B, 0x2F ),   // rgb 85,107,47		DarkOliveGreen  
	RGB( 0xFF, 0x8C, 0x00 ),   // rgb 255,140,0		DarkOrange  	
	RGB( 0x99, 0x32, 0xCC ),   // rgb 153,50,204	DarkOrchid  	
	RGB( 0x8B, 0x00, 0x00 ),   // rgb 139,0,0		DarkRed  		
	RGB( 0xE9, 0x96, 0x7A ),   // rgb 233,150,122	DarkSalmon  	
	RGB( 0x8F, 0xBC, 0x8F ),   // rgb 143,188,143	DarkSeaGreen  	
	RGB( 0x48, 0x3D, 0x8B ),   // rgb 72,61,139		DarkSlateBlue  	
	RGB( 0x2F, 0x4F, 0x4F ),   // rgb 47,79,79		DarkSlateGray  	
	RGB( 0x00, 0xCE, 0xD1 ),   // rgb 0,206,209		DarkTurquoise  	
	RGB( 0x94, 0x00, 0xD3 ),   // rgb 148,0,211		DarkViolet  	
	RGB( 0xFF, 0x14, 0x93 ),   // rgb 255,20,147	DeepPink  		
	RGB( 0x00, 0xBF, 0xFF ),   // rgb 0,191,255		DeepSkyBlue  	
	RGB( 0x69, 0x69, 0x69 ),   // rgb 105,105,105	DimGray  		
	RGB( 0x1E, 0x90, 0xFF ),   // rgb 30,144,255	DodgerBlue  	
	RGB( 0xB2, 0x22, 0x22 ),   // rgb 178,34,34		FireBrick  		
	RGB( 0xFF, 0xFA, 0xF0 ),   // rgb 255,250,240	FloralWhite  	
	RGB( 0x22, 0x8B, 0x22 ),   // rgb 34,139,34		ForestGreen  	
	RGB( 0xFF, 0x00, 0xFF ),   // rgb 255,0,255		Fuchsia  		
	RGB( 0xDC, 0xDC, 0xDC ),   // rgb 220,220,220	Gainsboro  		
	RGB( 0xF8, 0xF8, 0xFF ),   // rgb 248,248,255	GhostWhite  	
	RGB( 0xFF, 0xD7, 0x00 ),   // rgb 255,215,0		Gold  			
	RGB( 0xDA, 0xA5, 0x20 ),   // rgb 218,165,32	Goldenrod  		
	RGB( 0x80, 0x80, 0x80 ),   // rgb 128,128,128	Gray  			
	RGB( 0x00, 0x80, 0x00 ),   // rgb 0,128,0		Green  			
	RGB( 0xAD, 0xFF, 0x2F ),   // rgb 173,255,47	GreenYellow  	
	RGB( 0xF0, 0xFF, 0xF0 ),   // rgb 240,255,240	Honeydew  		
	RGB( 0xFF, 0x69, 0xB4 ),   // rgb 255,105,180	HotPink  		
	RGB( 0xCD, 0x5C, 0x5C ),   // rgb 205,92,92		IndianRed  		
	RGB( 0x4B, 0x00, 0x82 ),   // rgb 75,0,130		Indigo  		
	RGB( 0xFF, 0xFF, 0xF0 ),   // rgb 255,255,240	Ivory  			
	RGB( 0xF0, 0xE6, 0x8C ),   // rgb 240,230,140	Khaki  			
	RGB( 0xE6, 0xE6, 0xFA ),   // rgb 230,230,250	Lavender  		
	RGB( 0xFF, 0xF0, 0xF5 ),   // rgb 255,240,245	LavenderBlush  	
	RGB( 0x7C, 0xFC, 0x00 ),   // rgb 124,252,0		LawnGreen  		
	RGB( 0xFF, 0xFA, 0xCD ),   // rgb 255,250,205	LemonChiffon  	
	RGB( 0xAD, 0xD8, 0xE6 ),   // rgb 173,216,230	LightBlue  		
	RGB( 0xF0, 0x80, 0x80 ),   // rgb 240,128,128	LightCoral  	
	RGB( 0xE0, 0xFF, 0xFF ),   // rgb 224,255,255	LightCyan  		
	RGB( 0xFA, 0xFA, 0xD2 ),   // rgb 250,250,210	LightGoldenrodYellow
	RGB( 0x90, 0xEE, 0x90 ),   // rgb 144,238,144	LightGreen  	
	RGB( 0xD3, 0xD3, 0xD3 ),   // rgb 211,211,211	LightGrey  		
	RGB( 0xFF, 0xB6, 0xC1 ),   // rgb 255,182,193	LightPink  		
	RGB( 0xFF, 0xA0, 0x7A ),   // rgb 255,160,122	LightSalmon  	
	RGB( 0x20, 0xB2, 0xAA ),   // rgb 32,178,170	LightSeaGreen  	
	RGB( 0x87, 0xCE, 0xFA ),   // rgb 135,206,250	LightSkyBlue  	
	RGB( 0x77, 0x88, 0x99 ),   // rgb 119,136,153	LightSlateGray  
	RGB( 0xB0, 0xC4, 0xDE ),   // rgb 176,196,222	LightSteelBlue  
	RGB( 0xFF, 0xFF, 0xE0 ),   // rgb 255,255,224	LightYellow  	
	RGB( 0x00, 0xFF, 0x00 ),   // rgb 0,255,0		Lime  			
	RGB( 0x32, 0xCD, 0x32 ),   // rgb 50,205,50		LimeGreen  		
	RGB( 0xFA, 0xF0, 0xE6 ),   // rgb 250,240,230	Linen  			
	RGB( 0xFF, 0x00, 0xFF ),   // rgb 255,0,255		Magenta  		
	RGB( 0x80, 0x00, 0x00 ),   // rgb 128,0,0		Maroon  		
	RGB( 0x66, 0xCD, 0xAA ),   // rgb 102,205,170	MediumAquamarine
	RGB( 0x00, 0x00, 0xCD ),   // rgb 0,0,205		MediumBlue  	
	RGB( 0xBA, 0x55, 0xD3 ),   // rgb 186,85,211	MediumOrchid  	
	RGB( 0x93, 0x70, 0xDB ),   // rgb 147,112,219	MediumPurple  	
	RGB( 0x3C, 0xB3, 0x71 ),   // rgb 60,179,113	MediumSeaGreen  
	RGB( 0x7B, 0x68, 0xEE ),   // rgb 123,104,238	MediumSlateBlue 
	RGB( 0x00, 0x00, 0xFA ),   // rgb 0,0,154		MediumSpringGreen
	RGB( 0x48, 0xD1, 0xCC ),   // rgb 72,209,204	MediumTurquoise 
	RGB( 0xC7, 0x15, 0x85 ),   // rgb 199,21,133	MediumVioletRed 
	RGB( 0x19, 0x19, 0x70 ),   // rgb 25,25,112		MidnightBlue  	
	RGB( 0xF5, 0xFF, 0xFA ),   // rgb 245,255,250	MintCream  		
	RGB( 0xFF, 0xE4, 0xE1 ),   // rgb 255,228,225	MistyRose  		
	RGB( 0xFF, 0xE4, 0xB5 ),   // rgb 255,228,181	Moccasin  		
	RGB( 0xFF, 0xDE, 0xAD ),   // rgb 255,222,173	NavajoWhite  	
	RGB( 0x00, 0x00, 0x80 ),   // rgb 0,0,128		Navy  			
	RGB( 0xFD, 0xF5, 0xE6 ),   // rgb 253,245,230	OldLace  		
	RGB( 0x80, 0x80, 0x00 ),   // rgb 128,128,0		Olive  			
	RGB( 0x6B, 0x8E, 0x23 ),   // rgb 107,142,35	OliveDrab  		
	RGB( 0xFF, 0xA5, 0x00 ),   // rgb 255,165,0		Orange  		
	RGB( 0xFF, 0x45, 0x00 ),   // rgb 255,69,0		OrangeRed  		
	RGB( 0xDA, 0x70, 0xD6 ),   // rgb 218,112,214	Orchid  		
	RGB( 0xEE, 0xE8, 0xAA ),   // rgb 238,232,170	PaleGoldenrod  	
	RGB( 0x98, 0xFB, 0x98 ),   // rgb 152,251,152	PaleGreen  		
	RGB( 0xAF, 0xEE, 0xEE ),   // rgb 175,238,238	PaleTurquoise  	
	RGB( 0xDB, 0x70, 0x93 ),   // rgb 219,112,147	PaleVioletRed  	
	RGB( 0xFF, 0xEF, 0xD5 ),   // rgb 255,239,213	PapayaWhip  	
	RGB( 0xFF, 0xDA, 0xB9 ),   // rgb 255,218,185	PeachPuff  		
	RGB( 0xCD, 0x85, 0x3F ),   // rgb 205,133,63	Peru  			
	RGB( 0xFF, 0xC0, 0xCB ),   // rgb 255,192,203	Pink  			
	RGB( 0xDD, 0xA0, 0xDD ),   // rgb 221,160,221	Plum  			
	RGB( 0xB0, 0xE0, 0xE6 ),   // rgb 176,224,230	PowderBlue  	
	RGB( 0x80, 0x00, 0x80 ),   // rgb 128,0,128		Purple  		
	RGB( 0xFF, 0x00, 0x00 ),   // rgb 255,0,0		Red  			
	RGB( 0xBC, 0x8F, 0x8F ),   // rgb 188,143,143	RosyBrown  		
	RGB( 0x41, 0x69, 0xE1 ),   // rgb 65,105,225	RoyalBlue  		
	RGB( 0x8B, 0x45, 0x13 ),   // rgb 139,69,19		SaddleBrown  	
	RGB( 0xFA, 0x80, 0x72 ),   // rgb 250,128,114	Salmon  		
	RGB( 0xF4, 0xA4, 0x60 ),   // rgb 244,164,96	SandyBrown  	
	RGB( 0x2E, 0x8B, 0x57 ),   // rgb 46,139,87		SeaGreen  		
	RGB( 0xFF, 0xF5, 0xEE ),   // rgb 255,245,238	Seashell  		
	RGB( 0xA0, 0x52, 0x2D ),   // rgb 160,82,45		Sienna  		
	RGB( 0xC0, 0xC0, 0xC0 ),   // rgb 192,192,192	Silver  		
	RGB( 0x87, 0xCE, 0xEB ),   // rgb 135,206,235	SkyBlue  		
	RGB( 0x6A, 0x5A, 0xCD ),   // rgb 106,90,205	SlateBlue  		
	RGB( 0x70, 0x80, 0x90 ),   // rgb 112,128,144	SlateGray  		
	RGB( 0xFF, 0xFA, 0xFA ),   // rgb 255,250,250	Snow  			
	RGB( 0x00, 0xFF, 0x7F ),   // rgb 0,255,127		SpringGreen  	
	RGB( 0x46, 0x82, 0xB4 ),   // rgb 70,130,180	SteelBlue  		
	RGB( 0xD2, 0xB4, 0x8C ),   // rgb 210,180,140	Tan  			
	RGB( 0x00, 0x80, 0x80 ),   // rgb 0,128,128		Teal  			
	RGB( 0xD8, 0xBF, 0xD8 ),   // rgb 216,191,216	Thistle  		
	RGB( 0xFF, 0x63, 0x47 ),   // rgb 255,99,71		Tomato  		
	RGB( 0x40, 0xE0, 0xD0 ),   // rgb 64,224,208	Turquoise  		
	RGB( 0xEE, 0x82, 0xEE ),   // rgb 238,130,238	Violet  		
	RGB( 0xF5, 0xDE, 0xB3 ),   // rgb 245,222,179	Wheat  			
	RGB( 0xFF, 0xFF, 0xFF ),   // rgb 255,255,255	White  			
	RGB( 0xF5, 0xF5, 0xF5 ),   // rgb 245,245,245	WhiteSmoke  	
	RGB( 0xFF, 0xFF, 0x00 ),   // rgb 255,255,0		Yellow  		
	RGB( 0x9A, 0xCD, 0x32 )	// rgb 154,205,50		YellowGreen  	
};




BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id, WORD langid, LCID & lcid );


CDict::CDict()
{
    IMETHOD( CDict );

    for (int i = 0;i < ARRAYSIZE( g_Terms ); i++)
    {
		m_mapDictionary[*g_Terms[i].pTermID] = &g_Terms[i];
    	m_mapMnemonicDictionary[g_Terms[i].pszMnemonic] = &g_Terms[i];
    }
}

CDict::~CDict()
{
    IMETHOD( ~CDict );
	if( m_hinstResDll )
		FreeLibrary( m_hinstResDll );
}



HRESULT STDMETHODCALLTYPE
CDict::GetLocalizedString (
	REFGUID			Term,
	LCID			lcid,
	BSTR *			pResult,
	LCID *			plcid			
)
{
    IMETHOD( GetLocalizedString );

	*plcid = lcid;
	
	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pResult = BStrFromStringResource( m_hinstResDll, 
										   STR_RESOURCE_OFFSET + pInfo.idString, 
										   LANGIDFROMLCID( lcid ),
										   *plcid );
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::GetParentTerm (
	REFGUID			Term,
	GUID *			pParentTerm
)
{
    IMETHOD( GetParentTerm );

	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
		*pParentTerm = GUID_NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pParentTerm = *pInfo.pParentID;
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::GetMnemonicString (
	REFGUID			Term,
	BSTR *			pResult
)
{
    IMETHOD( GetMnemonicString );
    

	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pResult = SysAllocString( pInfo.pszMnemonic );
	}

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CDict::LookupMnemonicTerm (
	BSTR			bstrMnemonic,
	GUID *			pTerm
)
{
    IMETHOD( LookupMnemonicTerm );

	const DictMnemonicMap::iterator it = m_mapMnemonicDictionary.find(bstrMnemonic);
	if (it == m_mapMnemonicDictionary.end())
	{
		*pTerm = GUID_NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pTerm = *pInfo.pTermID;
	}

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CDict::ConvertValueToString (
	REFGUID			Term,
	LCID			lcid,
	VARIANT			varValue,
	BSTR *			pbstrResult,
	LCID *			plcid			
)
{
    IMETHOD( ConvertValue );

	*plcid = lcid;
	
	const DictMap::iterator it = m_mapDictionary.find(Term);
	if (it == m_mapDictionary.end())
	{
	    *pbstrResult = NULL;
	}
	else
	{
		const TermInfo pInfo = *it->second;
		*pbstrResult = (this->*pInfo.mfpConvertToString)( varValue, *plcid );
	}
	
    return S_OK;
}

// Methods Convert????ToString are called by ConvertValueToString via a 
// member funtion pointer in the TerInfo struct that is stored in the map

BSTR CDict::ConvertPtsToString( const VARIANT & value, LCID & lcid )
{
	TCHAR data[5];

	// see if we using metric
	GetLocaleInfo( lcid, LOCALE_IMEASURE, data, ARRAYSIZE( data ) );

	WCHAR result[16];

	// convert to centementers or inches
	if ( lstrcmp( data, TEXT("0") ) == 0 )
	{
		swprintf( result, L"%.2f", value.lVal / 72.0 * 2.54 );
		wcscat(result, L" cm" );
	}
	else
	{
		swprintf( result, L"%.2f", value.lVal / 72.0 );
		wcscat(result, L" in" );
	}

	return SysAllocString( result );
}

BSTR CDict::ConvertBoolToString( const VARIANT & value, LCID & lcid )
{
	const WORD lang = LANGIDFROMLCID( lcid );
	if ( value.boolVal )
		return BStrFromStringResource( m_hinstResDll, STR_BOOL_TRUE, lang, lcid );
	else
		return BStrFromStringResource( m_hinstResDll, STR_BOOL_FALSE, lang, lcid );
}

BSTR CDict::ConvertColorToString( const VARIANT & value, LCID & lcid )
{
	const COLORREF cr = value.lVal;
	double MinDistance = 450.0;  //  larger than the max distance
	int color = -1;

	// Go thru all the colors we have names for and find the closest one
	for ( int i = 0; i < ARRAYSIZE( g_ColorArray ); i++ )
	{
		double distance = ColorDistance( cr, g_ColorArray[i] );
		if ( distance <= MinDistance )
		{
			MinDistance = distance;
			color = i;
			if ( distance == 0.0 )
				break;
		}
	}

    if (color >= 0)
    {
        return BStrFromStringResource( m_hinstResDll, 
								   STR_COLOR_RESOURCE_OFFSET + color, 
								   LANGIDFROMLCID( lcid ),
								   lcid );
	}
    else
    {
        return NULL;
	}
}

BSTR CDict::ConvertWeightToString( const VARIANT & value, LCID & lcid )
{
	_ASSERTE( ( (value.lVal / 100) < 9 ) && ( (value.lVal / 100) ) > 0 );

	return BStrFromStringResource( m_hinstResDll, 
								   STR_WEIGHT_RESOURCE_OFFSET + (value.lVal / 100), 
								   LANGIDFROMLCID( lcid ),
								   lcid );
}

BSTR CDict::ConvertLangIDToString( const VARIANT & value, LCID & lcid )
{
	TCHAR data[128];

	GetLocaleInfo( lcid, LOCALE_SLANGUAGE, data, ARRAYSIZE( data ) );

	return T2BSTR(data);
}

BSTR CDict::ConvertBSTRToString( const VARIANT & value, LCID & lcid )
{

	return value.bstrVal;
}

// Distance is calculated the same as 3 dimensional cartesion distance.
// This will find how far away the two colors are
double CDict::ColorDistance(COLORREF crColor1, COLORREF crColor2)
{
    DWORD   dwDeltaRed;
    DWORD   dwDeltaGreen;
    DWORD   dwDeltaBlue;
    double  dfDistance;


    dwDeltaRed = abs(GetRValue(crColor1) - GetRValue(crColor2));
    dwDeltaGreen = abs(GetGValue(crColor1) - GetGValue(crColor2));
    dwDeltaBlue = abs(GetBValue(crColor1) - GetBValue(crColor2));
    dfDistance = sqrt(dwDeltaRed * dwDeltaRed + dwDeltaGreen * dwDeltaGreen + dwDeltaBlue * dwDeltaBlue);

    return dfDistance;
}

BOOL CALLBACK EnumResLangProc( HINSTANCE hModule, 
							   LPCTSTR lpszType, 
							   LPCTSTR lpszName, 
							   WORD wIDLanguage,  
							   LONG_PTR lParam )
{
	WORD Langid = *( WORD * )lParam;

	if ( Langid == wIDLanguage )
	{
		*( WORD * )lParam = 0;  // indicate we found it
		return FALSE;
	}
	
	if ( PRIMARYLANGID( Langid ) == PRIMARYLANGID( wIDLanguage ) )
		*( WORD * )lParam = wIDLanguage;

	return TRUE;
}


/*
 *  BStrFromStringResource
 *
 *  See KB Q196899 for details on how this works.
 *  A problem with LoadStringW is that it returns NULL on 9x - even
 *  though the string is available as UNICODE in the resource file.
 *
 *  (Another problem with LoadString is that there's no way
 *  to determine the length of the string in advance, so you have
 *  to guess the length of buffer to allocate.)
 *  This technique uses Find/Load/LockResource to get to the
 *  string in memory, and creates the BSTR direcly from that.
 *
 */

BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id )
{
	LCID lcid;
    // MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) causes lang associted with calling thread to be used...
    return BStrFromStringResource( hInstance, id, LANGIDFROMLCID( GetThreadLocale() ), lcid );
}


BSTR BStrFromStringResource( HINSTANCE hInstance, UINT id, WORD lcid, LCID & Actuallcid)
{
    // String resources are stored in blocks of 16,
    // with the resource ID being the string ID / 16.
    // See KB Q196899 for more information.
    UINT block = (id >> 4) + 1;   // Compute block number.
    UINT offset = id & 0xf;      // Compute offset into block.

	WORD langid = LANGIDFROMLCID( lcid );
    WORD RealLangid = langid;
    WORD SortID = SORTIDFROMLCID( lcid  );

    // Make sure the language they want in in the resource file
    // if not use the one the matches the best
	EnumResourceLanguages( hInstance, RT_STRING, MAKEINTRESOURCE( block ), EnumResLangProc, ( DWORD_PTR )&RealLangid );

	if ( RealLangid )
	{
		// if the language they asked for is not in the resource file use the language of the thread
		if ( RealLangid == langid )
		{
			WORD ThreadLang = LANGIDFROMLCID( GetThreadLocale() );
			SortID = SORT_DEFAULT;

			RealLangid = ThreadLang;
			EnumResourceLanguages( hInstance, 
								   RT_STRING, 
								   MAKEINTRESOURCE( block ), 
								   EnumResLangProc, 
								   ( DWORD_PTR )&RealLangid );
			
			if ( RealLangid == ThreadLang )
				return NULL;	// we can't find any language that makes sence 
				
			if ( RealLangid == 0 )
				RealLangid = LANGIDFROMLCID( ThreadLang );
		}
		
		Actuallcid = MAKELCID( RealLangid, SortID );
	}
	else		// we found it 
	{
		RealLangid = langid;
		Actuallcid = lcid;
	}
	
    HRSRC hrsrc = FindResourceEx( hInstance, RT_STRING, MAKEINTRESOURCE( block ), langid );
    if( ! hrsrc )
	{
		DWORD err = GetLastError();

		// this is here until I figure out why FindResourceEx does not work
		hrsrc = FindResource( hInstance, MAKEINTRESOURCE( block ), RT_STRING );
		if( ! hrsrc )
			return NULL;
	}

    HGLOBAL hglobal = LoadResource( hInstance, hrsrc );
    if( ! hglobal )
        return NULL;

    LPWSTR pstr = (LPWSTR) LockResource( hglobal );
    if( ! pstr )
        return NULL;

    // Block contains 16 [<len><string...>] pairs.
    // Skip over as many strings (using the len header) as needed...
    for( UINT i = 0; i < offset; i++ )
    {
        pstr += *pstr + 1;
    }

    // Got the string we want - now use it to create a BStr.
    // (Note that the string is not NUL-terminated - but it
    // does have a length prefix, so we use that instead.)
    return SysAllocStringLen( pstr + 1, *pstr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "com_external_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\docwrap.h ===
// DocWrap.h : Declaration of the CDocWrap

#ifndef __DOCWRAP_H_
#define __DOCWRAP_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDocWrap


class IWrapMgr;


class ATL_NO_VTABLE CDocWrap : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDocWrap, &CLSID_DocWrap>,
	public IDocWrap
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_DOCWRAP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDocWrap)
	COM_INTERFACE_ENTRY(IDocWrap)
END_COM_MAP()


	CDocWrap();
	~CDocWrap();

    // IDocWrap

    HRESULT STDMETHODCALLTYPE SetDoc (
        REFIID      riid,
        IUnknown *  punk
    );
    
    HRESULT STDMETHODCALLTYPE GetWrappedDoc (
        REFIID      riid,
        IUnknown ** ppunk
    );
        
private:

    IID         m_iid;
    IUnknown *  m_punkDoc;
    IWrapMgr *  m_pWrapMgr;

    void _Clear();
};

#endif //__DOCWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\docwrap.cpp ===
// DocWrapImpl.cpp : Implementation of CDocWrap
#include "stdafx.h"
#include "MSAAText.h"
#include "DocWrap.h"

#include <list_dl.h>
#include "VersionInfo.h"

#include <msctf.h>
#include <msctfp.h>
#define INITGUID
#include <msctfx.h>

#include <tStr.h>

#include <fwd_macros.h> // currently in the DocModel\inc dir... adjust appropriately if porting...


/*
 *  IDoc   - the variant of the ITextStoreACP we're using (ACP/Anchor)
 *  ISink  - the corresponding Sink interface (ACP/Anchor)
 *
 *  ICicDoc - the Cicero doc interface, which extends IDoc
 *  ICicSink - the Cicero sink interface, which extends ISink
 *
 *  CDocWrap - the document wrapper class, implements ICicDoc (which includes IDoc)
 *  CSinkWrap - the sink wrapper class, implements ICicSink (which includes ISink)
 *
 */


class BasicDocTraitsAnchor
{
public:
    typedef struct ITextStoreAnchor         IDoc;
    typedef struct ITextStoreAnchorSink     ISink;

    typedef struct ITextStoreAnchor         ICicDoc;
    typedef struct ITextStoreAnchorServices ICicSink;

    typedef class  CDocWrapAnchor           CDocWrap;
    typedef class  CSinkWrapAnchor          CSinkWrap;

    typedef struct ITextStoreAnchorEx       IDocEx;
    typedef struct ITextStoreSinkAnchorEx   ISinkEx;

    typedef IAnchor * PosType;
};


class BasicDocTraitsACP
{
public:
    typedef struct ITextStoreACP            IDoc;
    typedef struct ITextStoreACPSink        ISink;

    typedef struct ITextStoreACP            ICicDoc;
    typedef struct ITextStoreACPServices    ICicSink;

    typedef class  CDocWrapACP              CDocWrap;
    typedef class  CSinkWrapACP             CSinkWrap;


    typedef struct ITextStoreACPEx          IDocEx;
    typedef struct ITextStoreACPSinkEx      ISinkEx;

    typedef LONG PosType;
};


// DocWrapExcept contains exception wrapper classes for
// some of the above interfaces...
#include "DocWrapExcept.h"


// Add the appropriate exception wrappers to the set of
// doc traits.

class DocTraitsAnchor: public BasicDocTraitsAnchor
{
public:

    typedef SEHWrapPtr_TextStoreAnchor IDocSEHWrap;
};


class DocTraitsACP: public BasicDocTraitsACP
{
public:

    typedef SEHWrapPtr_TextStoreACP IDocSEHWrap;
};


/////////////////////////////////////////////////////////////////




// Create an instance of a local non-externally-createable class.
// Just a wrapper for CComObject::CreateInstance, but also AddRef's so that
// the returned object has a ref of 1.
template< class C >
HRESULT CreateLocalInstance( C ** p )
{
    CComObject< C > * p2 = NULL;

    HRESULT hr = CComObject< C >::CreateInstance( & p2 );

    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("CreateLocalInstance") );
        return hr;
    }
    
    if( p2 == NULL || hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("CreateLocalInstance returned NULL") );
        return E_UNEXPECTED;
    }

    p2->AddRef();
    *p = p2;
    return S_OK;
}



// Check hr and condition - return appropriate error if not S_OK and ! cond.
#define CHECK_HR_RETURN( hr, cond ) /**/ \
    if( (hr) != S_OK ) \
        return FAILED( (hr) ) ? (hr) : E_UNEXPECTED; \
    if( (hr) == S_OK && ! ( cond ) ) \
        return E_UNEXPECTED;



template < class T >
inline 
void SafeReleaseClear( T * & ptr )
{
    if( ptr )
    {
        ptr->Release();
        ptr = NULL;
    }
}

class CPrivateAddRef
{
public:
	CPrivateAddRef( long &rc ) : m_refcount( rc ) { m_refcount++; }
	~CPrivateAddRef() { m_refcount--; }
private:
	long &m_refcount;
};


class _declspec(uuid("{54D5D291-D8D7-4870-ADE1-331D86FD9430}")) IWrapMgr: public IUnknown
{
public:
    virtual void    STDMETHODCALLTYPE SetDoc( IUnknown * pDoc ) = 0;
    virtual HRESULT STDMETHODCALLTYPE CreateWrappedDoc( IUnknown ** ppDoc ) = 0;
};




template < class DocTraits >
class ATL_NO_VTABLE CWrapMgr :
	public CComObjectRootEx< CComSingleThreadModel >,
    public IWrapMgr
{
public:

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CWrapMgr< DocTraits > )
	COM_INTERFACE_ENTRY( IWrapMgr )
END_COM_MAP()

private:

    // Ptr to the original document.
    // Each DocWrapper also has a copy of this ptr - but only we have a refcount on it.
//    DocTraits::IDoc *               m_pDoc;
    typename DocTraits::IDocSEHWrap            m_pDoc;

    // Used to remember who requested a sync lock...
    typename DocTraits::CDocWrap *           m_pLockRequestedBy;

    BOOL                            m_fInSyncLockRequest;

    // Used to remember currently requested lock (ro vs rw)
    DWORD                           m_dwPendingLock;

    // Our sink - called by the doc
    typename DocTraits::CSinkWrap *          m_pSinkWrap;

    // Current sink event mask - all client sink masks or'd together.
    DWORD                           m_dwSinkMask;
    BOOL                            m_fSinkActive;

public:


    // List of DocWraps (one per client)
    List_dl< typename DocTraits::CDocWrap >  m_DocWraps;

    LONG m_lIterationRefCount;
    
    //
    // Ctor, Dtor...
    //

    CWrapMgr()
        : m_pDoc( NULL ),
          m_pSinkWrap( NULL ),
          m_dwSinkMask( 0 ),
          m_fSinkActive( FALSE ),
          m_pLockRequestedBy( NULL ),
          m_fInSyncLockRequest( FALSE ),
          m_dwPendingLock( 0 ),
          m_lIterationRefCount( 0 )

    {
        // Done.
        TraceInfo( TEXT("WrapMgr ctor") );
    }



    ~CWrapMgr()
    {
        TraceInfo( TEXT("WrapMgr dtor") );

        AssertMsg( m_pDoc, TEXT("CWrapMgr::SetDoc never called?") );
        
        m_pDoc->Release();
        
        Assert( m_DocWraps.empty() );
        Assert( m_pSinkWrap == NULL );
        Assert( m_dwSinkMask == 0 );
    }


    //
    // IWrapMgr interface - used by the DocWrap holder to give us a doc and ask for wrappers for it...
    //

    void STDMETHODCALLTYPE SetDoc( IUnknown * pDoc )
    {
        _SetDoc( static_cast< DocTraits::IDoc * >( pDoc ) );
    }


    HRESULT STDMETHODCALLTYPE CreateWrappedDoc( IUnknown ** ppDoc )
    {
        return _CreateWrappedDoc( reinterpret_cast< DocTraits::IDoc ** >( ppDoc ) );
    }

	void RemoveDeadDocs()
	{
        for( Iter_dl < DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; )
        {
			Iter_dl < DocTraits::CDocWrap > dead = i;

			i++;
        	
        	if (dead->m_bUnadvised && m_lIterationRefCount == 0)
			    m_DocWraps.remove( dead );
        }
	}

    //
    // Called by DocWrap, to tell us when it's been released, and to get us (the wrapper manager)
    // to handle a call that affects other wrappers on the same doc - advise/unadvise and lock calls.
    //

    void DocWrap_NotifyDisconnect( typename DocTraits::CDocWrap * pFrom )
    {
        // A DocWrap has been released by a client and is going away...

        // TODO - if using locks, check pFrom for lock, if it has it, release, broadcast relase.
        // - how can this scenario occur?
        // - doc is released in callback. Weird, but valid?

    }
    
    HRESULT DocWrap_HandleRequestLock( typename DocTraits::CDocWrap * pFrom, DWORD dwLockFlags, HRESULT * phrSession )
    {
        // Other clients may request a lock while it's being held by someone else, but the
        // current holder should not request a lock.
        // (This can happen when client1 is holding a lock, and issues an editing operation.
        // The wrapper broadcasts a OnTextChange event to other clients, and they may request locks.)
        AssertMsg( m_pLockRequestedBy != pFrom, TEXT("Lock owner re-request held lock? (Reentrancy?)") );

        if( dwLockFlags == 0 ||
            dwLockFlags & ~ ( TS_LF_SYNC | TS_LF_READ | TS_LF_READWRITE ) )  // check that only these bits present
        {
            AssertMsg( FALSE, TEXT("Bad lock flags") );
            return E_INVALIDARG;
        }


        if( dwLockFlags & TS_LF_SYNC )
        {
            // Can't process a SYNC call while someone else is holding the lock...
            if( m_pLockRequestedBy )
            {
                return E_FAIL;
            }

            // Sync lock - can just pass through - need to set up m_pLockRequestedBy so that the
            // sink can pass it onto the correct client.
            m_pLockRequestedBy = pFrom;
            m_fInSyncLockRequest = TRUE;
            HRESULT hr = m_pDoc->RequestLock( dwLockFlags, phrSession );
            m_fInSyncLockRequest = FALSE;
            m_pLockRequestedBy = NULL;
            return hr;
        } // sync lock
        else
        {
            // if async lock, update/upgrade the wrap's pending lock mask if necessary...
            // This test (which assumes that dwLockFlags != 0) upgrades to r/w if necessary.

            // TODO - should this update only be done conditionally if RequestLock succeeds?
            // (or no upgrade necessary?)
            Assert( dwLockFlags != 0 );
            if( pFrom->m_dwPendingLock != TS_LF_READWRITE )
                pFrom->m_dwPendingLock = dwLockFlags;
            
            if( m_pLockRequestedBy )
            {
                // someone else is currently holding the lock.
                // All we have to do is update the doc's PendingLock flags (see above)  - they will
                // be picked up and handled by the loop in Handle_OnLockGranted when the current
                // lock holder returns.
                // Nothing else to do here.
                
                // But send it on the doc anyway if it's the same person
                if ( m_pLockRequestedBy == pFrom )
                {
                    return m_pDoc->RequestLock( m_dwPendingLock, phrSession );
                }
                
                return S_OK;
            }
            else
            {
                // We don't have a lock yet.

                // Check our current request, if any, and if necessary, request a write,
                // even if we've already requested a read.

                
                // Update combined mask if necessary...
                DWORD dwNewLock = m_dwPendingLock;
                // Calculate required lock...
                if( dwNewLock != TS_LF_READWRITE )
                    dwNewLock = dwLockFlags;

                HRESULT hr = E_FAIL;

                // Do we need to request a new lock/upgrade?
                if( dwNewLock != m_dwPendingLock )
                {
                    // May get an immediate response even for an async request, so need to set this up
                    // event if not a sync request...
                    m_pLockRequestedBy = pFrom;

                    DWORD OldPendingLock = m_dwPendingLock;
                    m_dwPendingLock = dwNewLock;

                    HRESULT hrOut = E_FAIL;
                    hr = m_pDoc->RequestLock( m_dwPendingLock, & hrOut );

                    m_pLockRequestedBy = NULL;

                    if( hr != S_OK )
                    {
                        // After all that, the request failed...
                        // Revert to previous pending lock...
                        m_dwPendingLock = OldPendingLock;

                        // fall out...
                    }
                    else
                    {
                        // Regardless of fail/success, copy the outgoing hr.
                        // Clearing of the pending flags is done in OnLockgranted, not here.

                        // Shouldn't get this for an async request...
                        Assert( hrOut !=  TS_E_SYNCHRONOUS );

                        *phrSession = hrOut;
                    }
                }
                else
                {
                    // Our existing pending lock covers this request - success.
                    *phrSession = TS_S_ASYNC;
                    hr = S_OK;
                }

                return hr;
            }
        } // async lock
    }


    HRESULT DocWrap_UpdateSubscription()
    {
        Assert( ( m_dwSinkMask & ~ TS_AS_ALL_SINKS ) == 0 );
        // If there are no active sinks, then SinkMask should be 0.
        Assert( m_fSinkActive || m_dwSinkMask == 0 );

        // Work out required mask - by or'ing masks of all doc's sinks...
        DWORD NewMask = 0;
        BOOL NewfSinkActive = FALSE;
        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            if( i->m_Sink.m_pSink != NULL )
            {
                Assert( ( i->m_Sink.m_dwMask & ~ TS_AS_ALL_SINKS ) == 0 );
                NewMask |= i->m_Sink.m_dwMask;
                NewfSinkActive = TRUE;
            }
        }

        Assert( ( NewMask & ~ TS_AS_ALL_SINKS ) == 0 );
        // If there are no active sinks, then NewMask should be 0.
        Assert( NewfSinkActive || NewMask == 0 );


        // Tricky bit:
        // NewMask==0 does not mean that there's no sinks - some may have
        // dwMask == 0 to receive LockGranted calls.
        // So to check if the status has changed, we need to take whether
        // there are any active sinks (not just the masks) into account.

        if( NewfSinkActive == m_fSinkActive && NewMask == m_dwSinkMask )
        {
            // No change - nothing to do.
            return S_OK;
        }

        // Three possibilities:
        // (a) free to unregister,
        // (b) need to register
        // (c) need to update existing registration.
        // We handle (b) and (c) as the same case.

        if( ! NewfSinkActive )
        {
            // No sinks - can unregister...

            m_fSinkActive = FALSE;
            m_dwSinkMask = 0;

            if( ! m_pSinkWrap )
            {
                Assert( FALSE );
                // Odd - where did our sink wrap go - we didn't unregister it yet, so it should
                // still be around...
                // (Possible that server pre-emptively released us - so not an error.)
            }
            else
            {
                // Don't do anything else with m_pSinkWrap - the doc should release it.
                HRESULT hr = m_pDoc->UnadviseSink( static_cast< DocTraits::ICicSink * >( m_pSinkWrap ) );
                // shouldn't fail...
                Assert( hr == S_OK );

                // Doc should have released the sink (which would have called us back to NULL out
                // m_pSinkWrap...)
                Assert( m_pSinkWrap == NULL );
            }
            return S_OK;
        }
        else
        {
            // Update existing / add new...

            // If we already had an existing sink, there should be a sinkwrap...
            // (unless doc let it go prematurely...)
            Assert( ! m_fSinkActive || m_pSinkWrap  );

            BOOL NeedRelease = FALSE;
            if( ! m_pSinkWrap )
            {
                HRESULT hr = CreateLocalInstance( & m_pSinkWrap );
                if( hr != S_OK )
                    return hr;
                
                m_pSinkWrap->Init( this, & m_DocWraps );

                // After doing the Advise, release our ref on the sink, so that only
                // the doc holds a ref and controls its liftetime.
                // We still keep a pointer, but it's a "weak reference" - if the 
                // sink goes away (because the doc releases its reference), the sink
                // notifies us so we can NULL-out the ptr. (see SinkWrap_NotifyDisconnect)
                NeedRelease = TRUE;
            }

            

            // Always try advising with the Cicero sink first - if that
            // doesn't work, fall back to the ITextStoreACP one.
            //
            // (Use of static_cast is necessary here to avoid ambiguity over
            // which IUnknown we convert to - the ICicSink one, or the
            // IServiceProvider one. We want the ICicSink one, to match the
            // IID passed in.)

            HRESULT hr = m_pDoc->AdviseSink( __uuidof( DocTraits::ICicSink ), static_cast< DocTraits::ICicSink * >( m_pSinkWrap ), NewMask );
            if( hr != S_OK )
            {
                hr = m_pDoc->AdviseSink( __uuidof( DocTraits::ISink ), static_cast< DocTraits::ISink * >( m_pSinkWrap ), NewMask );
            }

            if( NeedRelease )
            {
                m_pSinkWrap->Release();
            }

            if( hr == S_OK )
            {
                m_fSinkActive = TRUE;
                m_dwSinkMask = NewMask;
            }
            else
            {
                AssertMsg( FALSE, TEXT("AdviseSink failed") );
            }

            return hr;
        }
    }


    void  DocWrap_NotifyRevoke()
    {

        // Send OnDisconnect to any SinkEx sinks,
		CPrivateAddRef MyAddRef(m_lIterationRefCount);

        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            // Is this the SinkExt sink?
            if( i->m_Sink.m_iid == __uuidof( DocTraits::ISinkEx ) )
            {
                DocTraits::ISinkEx * pSink = static_cast< DocTraits::ISinkEx * >( i->m_Sink.m_pSink );

				if ( pSink )
					pSink->OnDisconnect();
            }
        }

        for( Iter_dl < DocTraits::CDocWrap > j ( m_DocWraps ) ; ! j.AtEnd() ; )
        {
			Iter_dl < DocTraits::CDocWrap > DocToDelete = j;
	        j++;

	        m_DocWraps.remove( DocToDelete );
	        DocToDelete->Release();
       }
        

    }


    //
    // Called by SinkWrap to let us know when its been released...
    //

    void SinkWrap_NotifyDisconnect()
    {
        // The sink has been released by the application - it's now deleteing itself,
        // so we NULL-out our weak reference to it. (If we need another one in future,
        // we'll create a new one.)
        
        // Clear our sinks to reflect this...
        for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
        {
            i->m_Sink.ClearAndRelease();
        }
        
        m_pSinkWrap = NULL;
    }

    HRESULT SinkWrap_HandleOnLockGranted ( DWORD dwLockFlags )
    {
        // Is this servicing a sync or async request?
        Assert( ( dwLockFlags & ~ ( TS_LF_SYNC | TS_LF_READ | TS_LF_READWRITE ) ) == 0 );

		CPrivateAddRef MyAddRef(m_lIterationRefCount);

        if( m_fInSyncLockRequest )
        {
            // Sync lock - just pass it straight through to whoever requested it...
            Assert( dwLockFlags & TS_LF_SYNC );
            Assert( m_pLockRequestedBy && m_pLockRequestedBy->m_Sink.m_pSink );

            if( ! m_pLockRequestedBy || ! m_pLockRequestedBy->m_Sink.m_pSink )
                return E_UNEXPECTED;
            
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * > ( m_pLockRequestedBy->m_Sink.m_pSink );

            HRESULT hr = pSink->OnLockGranted( dwLockFlags );
            return hr;
        }
        else
        {
            // Async lock - hand it out to whoever wanted it...
            Assert( ! ( dwLockFlags & TS_LF_SYNC ) );

            // If we're waiting for a r/w lock, the lock granted should be r/w too...
            Assert( ! ( m_dwPendingLock & TS_LF_READWRITE ) || ( dwLockFlags & TS_LF_READWRITE ) );


            // Clear the pending lock, since we're now servicing them...
            m_dwPendingLock = 0;

            // Keep looking through the docs, servicing locks. We loop because some docs may
            // request locks while another holds the lock, so we have to come back an service them.
            // When we loop through all docs without seeing any locks, then we know all locks
            // have been serviced.
            //
            // If this is a read lock, then we can only service read locks now - we'll have to
            // ask for a separate write lock later if we need one.
            BOOL fNeedWriteLock = FALSE;
            for( ; ; )
            {
                BOOL fWorkDone = FALSE;

                // Forward to all clients who had requested a lock...
                for( Iter_dl< DocTraits::CDocWrap > i ( m_DocWraps ) ; ! i.AtEnd() ; i++ )
                {
                    // Is the mask we've been granted sufficient for the client's request (if any)?
                    DWORD ReqdLock = i->m_dwPendingLock;
                    if( ReqdLock )
                    {
                        if( ( ReqdLock | dwLockFlags ) == dwLockFlags )
                        {
                            // tell the doc wrapper that it is in OnLockGranted and what kind of lock it has
                            i->m_dwGrantedLock = ReqdLock;
                            
                            // Clear the mask...
                            i->m_dwPendingLock = 0;

                            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * > ( i->m_Sink.m_pSink );

// How about...
// (a) also call Next before callback.
// (b) store current value of iter in mgr - in doc's release, it can check, and bump if necessary;
                            pSink->OnLockGranted( ReqdLock );

                            // tell the doc wrapper that it is no longer in OnLockGranted
                            i->m_dwGrantedLock = 0;
                            
                            fWorkDone = TRUE;
                        }
                        else
                        {
                            // This client wants a write lock, but we've only got a read lock...
                            fNeedWriteLock = TRUE;
                        }
                    }
                }

                // If we didn't need to handle any lock requests the last time around the loop,
                // then our work is done. (If we did handle any lock requests, we should go back
                // and re-check all docs, in case one of them requested a lock while one of the
                // locks we serviced was holding it.)
                if( ! fWorkDone )
                    break;
            }


            if( fNeedWriteLock )
            {
// TODO - need to find a way to handle this. Can we call the doc's RequestLock again now?
                AssertMsg( FALSE, TEXT("Write lock requested while holding read lock - not implemented yet") );
            }

            // All done!
            return S_OK;
        }
    }



private:
    
    //
    // Internal functions...
    //


    void _SetDoc( typename DocTraits::IDoc * pDoc )
    {
        AssertMsg( ! m_pDoc, TEXT("CWrapMgr::SetDoc should be called once when m_pDoc is NULL") );
        m_pDoc = pDoc;
        m_pDoc->AddRef();
    }



    HRESULT _CreateWrappedDoc( typename DocTraits::IDoc ** ppDoc )
    {
        *ppDoc = NULL;

        // Create a doc wrapper...
        DocTraits::CDocWrap * pCDocWrap;
        HRESULT hr = CreateLocalInstance( & pCDocWrap );
        CHECK_HR_RETURN( hr, pCDocWrap != NULL );

        pCDocWrap->Init( this, m_pDoc );

        // Add to our list...
        m_DocWraps.AddToHead( pCDocWrap );
        
        // And return it...
        *ppDoc = pCDocWrap;
        return S_OK;
    }
};








struct SinkInfo
{
    IUnknown *      m_pSink;
    IID             m_iid;
    DWORD           m_dwMask;
    IUnknown *      m_pCanonicalUnk; // IUnknown used for identity comparisons
    


    void Validate()
    {
#ifdef DEBUG
        if( m_pSink )
        {           
            Assert( m_pCanonicalUnk != NULL );
            // Check that mask contains only valid bits
            Assert( ( m_dwMask & ~ TS_AS_ALL_SINKS ) == 0 );
        }        
        else        
        {            
            Assert( m_pCanonicalUnk == NULL );
            Assert( m_dwMask == 0 );       
        }
#endif    
    }



    SinkInfo()
        : m_pSink( NULL ),
          m_pCanonicalUnk( NULL ),
          m_dwMask( 0 )
    {
        Validate();
        // Done.
    }

    ~SinkInfo()
    {
        Validate();
        AssertMsg( m_pSink == NULL && m_pCanonicalUnk == NULL, TEXT("Sink not cleared" ) );
    }

    void Set( IUnknown * pSink, REFIID iid, DWORD dwMask, IUnknown * pCanonicalUnk )
    {
        Validate();

        AssertMsg( m_pSink == NULL, TEXT("Set() sink that's already in use" ) );

        m_pSink = pSink;
        m_pSink->AddRef();
        m_iid = iid;
        m_dwMask = dwMask;
        m_pCanonicalUnk = pCanonicalUnk;
        m_pCanonicalUnk->AddRef();

        Validate();
    }

    void UpdateMask( DWORD dwMask )
    {
        Validate();

        AssertMsg( m_pSink != NULL, TEXT("UpdateMask() on empty sink") );

        m_dwMask = dwMask;

        Validate();
    }

    void ClearAndRelease()
    {
        Validate();

        if( m_pSink )
        {
            m_pSink->Release();
            m_pSink = NULL;
            m_pCanonicalUnk->Release();
            m_pCanonicalUnk = NULL;
            m_dwMask = 0;
        }
    }
};






// Fwd. decl for the sink-wrap class, needed since we grant it frienship in the 
// DocWrap class...
template< class DocTraits >
class CSinkWrapBase;



//
//  CDocWrapBase
//
//  - Base from which Anchor and ACP document wrappers are derived.
//
//  This class contains ACP/Anchor-neutral wrapping code - anything that is
//  ACP/Anchor-specific is handled in the derived ..ACP or ...Anchor class
//  instead.
//
//  This class derives from the full Cicero doc interface (DocTraits::ICicDoc -
//  which is a typedef for ITfTextStore[Anchor]), which in turn includes the
//  ITextStoreACP doc interface. Currently the Cicero interface doesn't add any
//  additional methods.
//
//  This class is also on a list of document wrappers - so we're derived from
//  Link_dl. (The list is managed by the wrapper manager.) The list will be a
//  list of derived classes, so the type of the link is of the derived class
//  (DocTraits::CDocWrap - which is a typedef for CDocWrapACP/Anchor), instead
//  of being based on this class.
//  (At the moment we don't actually use any of the derived-class functionality,
//  but may do so in future.)

// {B5DCFDAF-FBAD-4ef6-A5F8-E7CC0833A3B1}
static const GUID DOCWRAP_IMPLID = { 0xb5dcfdaf, 0xfbad, 0x4ef6, { 0xa5, 0xf8, 0xe7, 0xcc, 0x8, 0x33, 0xa3, 0xb1 } };

template< class _DocTraits >
class ATL_NO_VTABLE CDocWrapBase :
	public CComObjectRootEx< CComSingleThreadModel >,
    public Link_dl< typename _DocTraits::CDocWrap >,
    public _DocTraits::ICicDoc,

    public _DocTraits::IDocEx,

    public IClonableWrapper,
    public IInternalDocWrap,
    public ICoCreateLocally,
    public CVersionInfo,
    public IServiceProvider
{
public:

    // This typedef makes the DocTraits type visible in this and in the
    // Anchor/ACP-specific derived classes. (Otherwise, as a template
    // parameter in this class, it would not be available to them.)
    typedef _DocTraits DocTraits;

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CDocWrapBase< DocTraits > )
    COM_INTERFACE_ENTRY( DocTraits::IDoc )
	COM_INTERFACE_ENTRY( DocTraits::ICicDoc )
    COM_INTERFACE_ENTRY( DocTraits::IDocEx )
    COM_INTERFACE_ENTRY( IClonableWrapper )
    COM_INTERFACE_ENTRY( IInternalDocWrap )
    COM_INTERFACE_ENTRY( ICoCreateLocally )
    COM_INTERFACE_ENTRY( IVersionInfo )
    COM_INTERFACE_ENTRY( IServiceProvider )
END_COM_MAP()



private:

    // WrapMgr uses the Link_dl base when adding this to its list.
    friend CWrapMgr< DocTraits >;

    // Used by WrapMgr to track what type of lock was requested. 
    DWORD                   m_dwPendingLock;

    // Used by WrapMgr to track what type of lock granted. 
    DWORD                   m_dwGrantedLock;

    // SinkWrapBase - and its derived Anchor/ACP-specific class - uses the list
    // and the members of SinkInfo when broadcasting
    friend CSinkWrapBase< DocTraits >;
    friend DocTraits::CSinkWrap;


protected:

    // Each doc can have a corresponding sink:
    SinkInfo                m_Sink;

    // Link back to the wrapper manager - so we can tell it when we're going
    // away. We also get it to handle calls which affect other wrappers on the
    // same document - especially sinks and locks.
    CWrapMgr< DocTraits > * m_pMgr;

    // Used by derived classes to forward calls to doc...
//    DocTraits::IDoc *       m_pDoc;
    typename DocTraits::IDocSEHWrap  m_pDoc;

    // TEMP  BUGBUG - used to access the attribute extentions for the moment...
    typename DocTraits::IDocEx *     m_pDocEx;

    bool m_bUnadvised;



    HRESULT STDMETHODCALLTYPE VerifyLock( DWORD dwLockFlags)
    {
        IMETHOD( VerifyLock );

        if ( m_dwGrantedLock )
        {
            // We have a lock, make sure it's the right kind
            if ( (dwLockFlags & TS_LF_READWRITE) == m_dwGrantedLock || (dwLockFlags & TS_LF_READWRITE) == TS_LF_READ )
                return S_OK;
        }

        TraceDebug( TEXT("Lock rejected") );

        return S_FALSE;
    }
    
    // This macro just forwards the call directly to the doc...
#define DocWrap_FORWARD( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        return m_pDoc-> fname AS_CALL( c, params ) ;\
    }

    // This macro just forwards the call directly to the doc after checking for the correct lock
#define DocWrap_FORWARD_READLOCK( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )\
            return TS_E_NOLOCK;\
        return m_pDoc-> fname AS_CALL( c, params ) ;\
    }


#define DocWrap_FORWARDEXT( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        IMETHOD( fname );\
        if( ! m_pDocEx )\
            return E_NOTIMPL;\
        return m_pDocEx-> fname AS_CALL( c, params ) ;\
    }


    // This slightly more complicated one (!) forwards to the doc,
    // and if the call succeeds, then broadcasts to all sinks except the one
    // for this document.
    // So if one client does a SetText, that SetText goes through, and
    // all other clietns with callbacks for the TS_AS_TEXT_CHANGE event will
    // also get an OnTextChange event.
#define DocWrap_FORWARD_AND_SINK( fname, c, params, mask, callsink )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr );\
        if ( VerifyLock( TS_LF_READWRITE ) == S_FALSE )\
            return TS_E_NOLOCK;\
        m_pMgr->RemoveDeadDocs();\
        CPrivateAddRef MyAddRef(m_pMgr->m_lIterationRefCount);\
        HRESULT hr = m_pDoc-> fname AS_CALL( c, params );\
        if( hr != S_OK )\
        {\
			TraceDebugHR( hr, TEXT("failed") );\
            return hr;\
        }\
        for( Iter_dl < DocTraits::CDocWrap > i ( m_pMgr->m_DocWraps ) ; ! i.AtEnd() ; i++ )\
        {\
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * >( i->m_Sink.m_pSink );\
            DWORD dwMask = i->m_Sink.m_dwMask;\
            DocTraits::CDocWrap * pTheDoc = i;\
            if( pTheDoc != this && pSink && ( dwMask & mask ) )\
            {\
                callsink ;\
            }\
        }\
        return S_OK ;\
    }

public:


    //
    // Ctor, Dtor, and initialization...
    //

    CDocWrapBase()
        : m_pDoc( NULL ),
          m_pMgr( NULL ),
          m_dwPendingLock( 0 ),
          m_dwGrantedLock( 0 ),
          m_pDocEx( NULL ),
          m_bUnadvised( false )
    {

    }

    ~CDocWrapBase()
    {
        AssertMsg( m_pMgr != NULL, TEXT("CDocWrapBase::Init never got called?") );

        // Clear up sink...
        if( m_Sink.m_pSink )
        {
            m_Sink.ClearAndRelease();

            // Manager will unadvise, if we were the last to go...
            m_pMgr->DocWrap_UpdateSubscription();
        }

        m_pMgr->DocWrap_NotifyDisconnect( static_cast< DocTraits::CDocWrap * >( this ) );
        m_pMgr->Release();

        if( m_pDocEx )
            m_pDocEx->Release();
    }

    void Init( CWrapMgr< DocTraits > *  pMgr, typename DocTraits::IDoc * pDoc )
    {
        AssertMsg( m_pMgr == NULL, TEXT("CDocWrapBase::Init should only be called once when m_pMgr is NULL") );
        m_pMgr = pMgr;
        m_pMgr->AddRef();

        m_pDoc = pDoc;
        AddRef();			// Keep our own ref count so it dosn't go away until we remove from the list
        
        CVersionInfo::Add( DOCWRAP_IMPLID, 1, 0, L"Microsoft MSAA Wrapper 1.0", L"na", NULL);
        
        m_pDoc->QueryInterface( __uuidof( DocTraits::IDocEx ), (void **) & m_pDocEx );
    }


    //
    // Implementation of ACP/Anchor-neutral methods...
    // These ones require special handling...
    //

    HRESULT STDMETHODCALLTYPE AdviseSink( REFIID riid, IUnknown *punk, DWORD dwMask )
    {
        IMETHOD( AdviseSink );

        Assert( m_pMgr );

        if( punk == NULL )
        {
            return E_INVALIDARG;
        }

        // Accept the following sinks:
        // * Original ITextStoreACPSink,
        // * Cicero sink (ITextStoreACP + Cicero extentions)
        // * ITextStoreACPSinkEx sink (ITextStoreACP + OnDisconnect method)
        if( riid != __uuidof( DocTraits::ISink )
         && riid != __uuidof( DocTraits::ICicSink )
         && riid != __uuidof( DocTraits::ISinkEx ) )
        {
            return E_NOINTERFACE;
        }

        // check mask contains only valid bits
        if( dwMask & ~ ( TS_AS_ALL_SINKS ) )
        {
            return E_INVALIDARG;
        }
        
        // Get canonical unknown (for interface comparing...)
        IUnknown * pCanonicalUnk = NULL;
        HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
        if( hr != S_OK || pCanonicalUnk == NULL )
        {
            return E_FAIL;
        }

        // If this is first, set it...
        if( m_Sink.m_pSink == NULL )
        {
            // Allow the doc to work out the update cumulative mask and re-advise the doc if necessary...
            m_Sink.Set( punk, riid, dwMask, pCanonicalUnk );

            // Manager will scan through all sink masks, and re-Advise if necessary.
            hr = m_pMgr->DocWrap_UpdateSubscription();

            if( hr != S_OK )
            {
                // advising didn't work, or something else went wrong - revert back to empty sink...
                m_Sink.ClearAndRelease();
            }
        }
        else
        {
            // Not the first time - check if we're updating the existing mask...
            if( pCanonicalUnk != m_Sink.m_pCanonicalUnk )
            {
                // Attempt to register a different sink - error...
                hr = CONNECT_E_ADVISELIMIT;
            }
            else
            {
                // Remember the old mask - if the update doesn't work, revert back to this.
                DWORD OldMask = m_Sink.m_dwMask;
                m_Sink.UpdateMask( dwMask );

                // Manager will scan through all dwMasks, and re-Advise if necessary.
                hr = m_pMgr->DocWrap_UpdateSubscription();

                if( hr != S_OK )
                    m_Sink.UpdateMask( OldMask );
            }
        }

        pCanonicalUnk->Release();
        return hr;
    }



    HRESULT STDMETHODCALLTYPE UnadviseSink( IUnknown *punk )
    {
        IMETHOD( UnadviseSink );

        Assert( m_pMgr );

        if( punk == NULL )
        {
            return E_POINTER;
        }

        // Get canonical unknown (for interface comparing...)
        IUnknown * pCanonicalUnk = NULL;
        HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );

        if( hr != S_OK || pCanonicalUnk == NULL )
        {
            return E_FAIL;
        }
    
        if( pCanonicalUnk != m_Sink.m_pCanonicalUnk )
        {
            // Sink doesn't match!
            return E_INVALIDARG;
        }

        m_Sink.ClearAndRelease();

        // Manager will scan through all dwMasks, and re-Advise if necessary.
        hr = m_pMgr->DocWrap_UpdateSubscription();

        // Not much we can do if the update fails - but even if it does fail,
        // we want to disconnect this sink, and not fail the Unadvise.
        Assert( hr == S_OK );

        pCanonicalUnk->Release();

        m_bUnadvised = true;

		return S_OK;  // NOT hr, since this should always succeed.
    }




    HRESULT STDMETHODCALLTYPE RequestLock( DWORD dwLockFlags, HRESULT * phrSession )
    {
        IMETHOD( RequestLock );

        Assert( m_pMgr );
        // The cast here is safe, since we'll only be used as a derived class
        DocTraits::CDocWrap * pThisAsDerived = static_cast< DocTraits::CDocWrap * >( this );

        return m_pMgr->DocWrap_HandleRequestLock( pThisAsDerived, dwLockFlags, phrSession );
    }


    //
    // These Anchor/ACP-neutral methods can just be forwarded directly to the real doc...
    //

    DocWrap_FORWARD( GetStatus,                 1,  ( TS_STATUS *,               pdcs ) )

    DocWrap_FORWARD_READLOCK( QueryInsert,   	5,  ( typename DocTraits::PosType,       InsertStart,
    												  typename DocTraits::PosType,       InsertEnd,
    												  ULONG,					cch,
                                                      typename DocTraits::PosType *,     ppaInsertStart,
                                                      typename DocTraits::PosType *,     ppaInsertEnd ) )

    DocWrap_FORWARD_READLOCK( QueryInsertEmbedded,		3,	( const GUID *,				pguidService,
													  const FORMATETC *,		pFormatEtc,
													  BOOL *,					pfInsertable ) )
       
    DocWrap_FORWARD( GetScreenExt,              2,  ( TsViewCookie,				vcView,
    												  RECT *,                   prc ) )

    DocWrap_FORWARD( GetWnd,                    2,  ( TsViewCookie,				vcView,
													  HWND *,                   phwnd ) )

    DocWrap_FORWARD_READLOCK( GetFormattedText, 3,  ( typename DocTraits::PosType,       Start,
                                                      typename DocTraits::PosType,       End,
                                                      IDataObject **,           ppDataObject ) )

    DocWrap_FORWARD_READLOCK( GetTextExt,                5,  ( TsViewCookie,				vcView,
													  typename DocTraits::PosType,       Start,
                                                      typename DocTraits::PosType,       End,
                                                      RECT *,                   prc,
                                                      BOOL *,                   pfClipped ) )

    DocWrap_FORWARDEXT( ScrollToRect,           4,  ( typename DocTraits::PosType,       Start,
                                                      typename DocTraits::PosType,       End,
                                                      RECT,                     rc,
                                                      DWORD,                    dwPosition ) )

    DocWrap_FORWARD( GetActiveView,				1,  ( TsViewCookie *,			pvcView ) )
    
    // IClonableWrapper

	HRESULT STDMETHODCALLTYPE CloneNewWrapper( REFIID	riid, void ** ppv )
    {
        IMETHOD( CloneNewWrapper );

        // Just call through to CWrapMgr's CreateWrappedDoc...

        Assert( m_pMgr );

        IUnknown * punk;
        HRESULT hr = m_pMgr->CreateWrappedDoc( & punk );
        if( hr != S_OK )
            return hr;

        hr = punk->QueryInterface( riid, ppv );
        punk->Release();
        return hr;
    }

    // IInternalDocWrap

	HRESULT STDMETHODCALLTYPE NotifyRevoke()
    {
        // Just pass on to the CWrapMgr...
        Assert( m_pMgr );

        m_pMgr->DocWrap_NotifyRevoke();

        return S_OK;
    }
    
    // ICoCreateLocally
	#include <Rpcdce.h>
	HRESULT STDMETHODCALLTYPE CoCreateLocally (
		REFCLSID		rclsid,
		DWORD			dwClsContext,
		REFIID			riid,
		IUnknown **		punk,
		REFIID			riidParam,
		IUnknown *		punkParam,
		VARIANT			varParam
	)
	{ 
	    IMETHOD( CoCreateLocally );

        // If hooking is disabled then we won't be able to open the input
        // desktop with DESKTOP_HOOKCONTROL access.
        // ISSUE: This call always succeeds until related bug #471894 is resolved by USER
        HDESK hDesk = OpenInputDesktop(0, FALSE, DESKTOP_HOOKCONTROL);
        if (!hDesk)
        {
            return E_ACCESSDENIED;
        }
        CloseDesktop(hDesk);

		LPCTSTR pPrivs = NULL;				//Pointer to handle to privilege information

		HRESULT hrSec = CoQueryClientBlanket( 0, 0, 0, 0, 0, (void **)&pPrivs, 0 );
		if ( hrSec != S_OK )
			return hrSec;

		TSTR strUser(128);
		DWORD nSize = strUser.left();
		if ( !GetUserName( strUser.ptr(), &nSize ) )
		    return E_ACCESSDENIED;
		    
		strUser.advance( nSize - 1 );
		
		TSTR strClientUser( pPrivs );
		const int nSlashPos = strClientUser.find( TEXT("\\") );
		if ( nSlashPos > 0 )
			strClientUser = strClientUser.substr( nSlashPos + 1, strClientUser.size() - nSlashPos );

		TraceDebug( TSTR() << TEXT("Current user = ") << strUser << TEXT(", Client user = ") << strClientUser );
		if ( strClientUser.compare( strUser ) != 0 )
			if ( strClientUser.compare( TEXT("SYSTEM") ) != 0 )
				return E_ACCESSDENIED;

		HRESULT hr = CoCreateInstance(rclsid, NULL, dwClsContext, riid, (void **)punk);
 		if (hr != S_OK)
 			return hr;

		CComPtr<ICoCreatedLocally> pICoCreatedLocally;
		hr = (*punk)->QueryInterface(IID_ICoCreatedLocally, (void **)&pICoCreatedLocally);
 		if (hr != S_OK)
 			return hr;

		hr = pICoCreatedLocally->LocalInit(m_pDoc, riidParam, punkParam, varParam);
 		if (hr != S_OK)
 			return hr;

	    return S_OK;
	}

    //
    // IServiceProvider - Cicero uses this to 'drill through' to the original anchor to pull out
    // internal information. Just pass it through...
    //
    HRESULT STDMETHODCALLTYPE QueryService( REFGUID guidService, REFIID riid, void **ppvObject )
    {
        IMETHOD( QueryService );

        *ppvObject = NULL;

        CComPtr<IServiceProvider> pISP;
        HRESULT hr = m_pDoc->QueryInterface( IID_IServiceProvider, (void **) & pISP );
        if( hr != S_OK || pISP == NULL )
            return E_FAIL;

        hr = pISP->QueryService( guidService, riid, ppvObject );

        return hr;
    }
};


//
// CTextStoreWrapACP - ACP version of ITextStoreACP wrapper...
//

class ATL_NO_VTABLE CDocWrapACP : 
    public CDocWrapBase< DocTraitsACP >
{
public:

    // ITextStoreACP
    DocWrap_FORWARD_READLOCK( GetSelection,              4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ACP *, pSelection, ULONG *, pcFetched ) )
    DocWrap_FORWARD_READLOCK( GetText,                   9,  ( LONG, acpStart, 
													  LONG, acpEnd,
													  WCHAR *, pchPlain, 
													  ULONG, cchPlainReq, 
													  ULONG *, pcchPlainRet, 
													  TS_RUNINFO *, prgRunInfo, 
													  ULONG, cRunInfoReq, 
													  ULONG *, pcRunInfoRet, 
													  LONG *, pacpNext ) )
    DocWrap_FORWARD_READLOCK( GetEmbedded,       4,  ( LONG, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    DocWrap_FORWARD_READLOCK( GetEndACP,         1,  ( LONG *, pacp ) )
    DocWrap_FORWARD_READLOCK( GetACPFromPoint,    4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, LONG *, pacp ) )
    DocWrap_FORWARD( RequestSupportedAttrs, 3,  ( DWORD,                    dwFlags,
    												  ULONG, 					cFilterAttrs,
													  const TS_ATTRID *,		paFilterAttrs ) )
    DocWrap_FORWARD_READLOCK( RequestAttrsAtPosition, 4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,        paFilterAttrs,
                                                      DWORD,                    dwFlags ) )
    DocWrap_FORWARD_READLOCK( RequestAttrsTransitioningAtPosition,
                                                4,  ( DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,        paFilterAttrs,
                                                      DWORD,                    dwFlags ) )
    DocWrap_FORWARD_READLOCK( FindNextAttrTransition,    8,  ( LONG, acpStart, LONG, acpEnd, ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, LONG *, pacpNext, BOOL *, pfFound, LONG *, plFoundOffset ) )
    DocWrap_FORWARD( RetrieveRequestedAttrs,    3,  ( ULONG,                    ulCount,
                                                      TS_ATTRVAL *,             paAttrVals,
                                                      ULONG *,                  pcFetched ) )
    DocWrap_FORWARD_AND_SINK( SetSelection,     2,  ( ULONG, ulCount, const TS_SELECTION_ACP *, pSelection ),
                              TS_AS_SEL_CHANGE,   pSink->OnSelectionChange() )

    DocWrap_FORWARD_AND_SINK( SetText,          6,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, const WCHAR *, pchText, ULONG, cch, TS_TEXTCHANGE *, pChange ),
                             TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertEmbedded,   5,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, IDataObject *, pDataObject, TS_TEXTCHANGE *, pChange ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertTextAtSelection, 6, ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )

    DocWrap_FORWARD_AND_SINK( InsertEmbeddedAtSelection, 5, ( DWORD, dwFlags, IDataObject *, pDataObject, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, pChange )  )


};

//
// CTextStoreWrapAnchor - Anchor version of ITextStoreACP wrapper
//

class ATL_NO_VTABLE CDocWrapAnchor : 
    public CDocWrapBase< DocTraitsAnchor >
{
/*
    // Used when generating OnTextChange events in response to InsertEmbedded.
    // See forwarding macro for InsertEmbedded below...
    void ProcessInsertEmbeddedOnTextChange( DocTraits::ISink * pSink, DWORD dwFlags, IAnchor * paPos )
    {
        // Want to send a TextChange with anchors before and after the insert position -
        // we have the before position - clone and move it to get the after position.
        IAnchor * pAnchorAfter = NULL;
        HRESULT hr = paPos->Clone( & pAnchorAfter );
        if( hr != S_OK || pAnchorAfter == NULL )
        {
            TraceInteropHR( hr, TEXT("IAnchor::Clone failed") );
            return;
        }

        LONG cchShifted = 0;
        hr = pAnchorAfter->Shift( 1, & cchShifted, NULL );
        if( hr != S_OK || cchShifted != 1 )
        {
            TraceInteropHR( hr, TEXT("IAnchor::Shift failed?") );
            return;
        }

        pSink->OnTextChange( dwFlags, paPos, pAnchorAfter );

        pAnchorAfter->Release();
    }
*/

public:

	CDocWrapAnchor() : m_cMaxAttrs(0), 
					   m_cAttrsTAP(0), 
					   m_iAttrsTAP(0), 
					   m_cAttrsTAPSize(0), 
					   m_paAttrsTAP(NULL),
					   m_paAttrsSupported(NULL)

	{

	}

	~CDocWrapAnchor()
	{
		ResetAttrs();
		if ( m_paAttrsTAP )
		{
			delete [] m_paAttrsTAP;
			m_paAttrsTAP = NULL;
		}
		if ( m_paAttrsSupported )
		{
			delete [] m_paAttrsSupported;
			m_paAttrsSupported = NULL;
		}
	}

    // ITextStoreAnchor
    DocWrap_FORWARD_READLOCK( GetSelection,              4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ANCHOR *, pSelection, ULONG *, pcFetched ) )
    DocWrap_FORWARD_READLOCK( GetText,                   7,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, WCHAR *, pchText, ULONG, cchReq, ULONG *, pcch, BOOL, fUpdateAnchor ) )
    DocWrap_FORWARD_READLOCK( GetEmbedded,               5,  ( DWORD,					dwFlags,
													  IAnchor *,				Pos,
                                                      REFGUID,                  rguidService,
                                                      REFIID,                   riid,
                                                      IUnknown **,              ppunk ) )
    DocWrap_FORWARD_READLOCK( GetStart,                  1,  ( IAnchor **, ppaStart ) )
    DocWrap_FORWARD_READLOCK( GetEnd,                    1,  ( IAnchor **, ppaEnd ) )
    DocWrap_FORWARD_READLOCK( GetAnchorFromPoint,        4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, IAnchor **, ppaSite ) )
//	DocWrap_FORWARD( RequestSupportedAttrs,     3,  ( DWORD,                    dwFlags,
//													  ULONG, 					cFilterAttrs,
//													  const TS_ATTRID *,		paFilterAttrs ) )
//	DocWrap_FORWARD_READLOCK( RequestAttrsAtPosition,    4,  ( DocTraits::PosType,       Pos,
//													  ULONG,                    cFilterAttrs,
//													  const TS_ATTRID *,        paFilterAttrs,
//													  DWORD,                    dwFlags ) )
//	DocWrap_FORWARD_READLOCK( RequestAttrsTransitioningAtPosition,
//												4,  ( DocTraits::PosType,       Pos,
//													  ULONG,                    cFilterAttrs,
//													  const TS_ATTRID *,         paFilterAttrs,
//													  DWORD,                    dwFlags ) )
//	DocWrap_FORWARD_READLOCK( FindNextAttrTransition,    7,  ( IAnchor *, paStart, IAnchor *, paEnd,  ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, BOOL *, pfFound, LONG *, plFoundOffset ) )


    DocWrap_FORWARD_AND_SINK( SetSelection,     2,  ( ULONG, ulCount, const TS_SELECTION_ANCHOR *, pSelection ),
                              TS_AS_SEL_CHANGE,   pSink->OnSelectionChange() )

    DocWrap_FORWARD_AND_SINK( SetText,          5,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, const WCHAR *, pchText, ULONG, cch ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, paStart, paEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertEmbedded,   4,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, IDataObject *, pDataObject ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, paStart, paEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertTextAtSelection, 5, ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch,  IAnchor **, ppaStart, IAnchor **, ppaEnd ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, *ppaStart, *ppaEnd ) )

    DocWrap_FORWARD_AND_SINK( InsertEmbeddedAtSelection, 4, ( DWORD, dwFlags, IDataObject *, pDataObject,  IAnchor **, ppaStart, IAnchor **, ppaEnd ),
                              TS_AS_TEXT_CHANGE,  pSink->OnTextChange( dwFlags, *ppaStart, *ppaEnd ) )

    HRESULT STDMETHODCALLTYPE RequestSupportedAttrs ( DWORD				dwFlags,
													  ULONG 			cFilterAttrs,
													  const TS_ATTRID *	paFilterAttrs )
    {
        IMETHOD( RequestSupportedAttrs );
       	ResetAttrs();
        return m_pDoc->RequestSupportedAttrs( dwFlags, cFilterAttrs, paFilterAttrs ) ;
    }
    
    HRESULT STDMETHODCALLTYPE RequestAttrsAtPosition ( DocTraits::PosType	Pos,
													   ULONG				cFilterAttrs,
													   const TS_ATTRID *	paFilterAttrs,
													   DWORD				dwFlags ) 
    {
        IMETHOD( RequestAttrsAtPosition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
       	ResetAttrs();
        return m_pDoc->RequestAttrsAtPosition( Pos, cFilterAttrs, paFilterAttrs, dwFlags ) ;
    }

	HRESULT STDMETHODCALLTYPE RequestAttrsTransitioningAtPosition ( IAnchor * paStart,
																	ULONG cFilterAttrs,
																	const TS_ATTRID * paFilterAttrs,
																	DWORD dwFlags )
	{
        IMETHOD( RequestAttrsTransitioningAtPosition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
       	ResetAttrs();

		// call through to the doc
        HRESULT hr  = m_pDoc->RequestAttrsTransitioningAtPosition( paStart, cFilterAttrs, paFilterAttrs, dwFlags );
        if ( hr != E_NOTIMPL )
        	return hr;
        	
        // if the server does not support this do it ourselves
		// make sure there is really something to do
        if ( paStart == NULL )
        	return S_OK;
		
		// make sure we can hold the attributes we find
        hr = AllocateAttrs( cFilterAttrs );
        if ( FAILED(hr) )
        	return hr;

		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;

		TS_ATTRVAL * paCurrent = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		if ( !paCurrent )
			return E_OUTOFMEMORY;

		hr = GetAttr ( paStart, cFilterAttrs, paFilterAttrs, dwFlags, paCurrent);
        if ( FAILED(hr) )
        	return hr;

		LONG cchShifted;
		ULONG iAttrs = 0;
		TS_ATTRVAL * paComp = NULL;
		CComPtr <IAnchor> paPos;
		paStart->Clone( &paPos );
		hr = paPos->Shift( 0, -1, &cchShifted, NULL );	// TODO fix hidden text
		if ( SUCCEEDED(hr) && cchShifted == -1 )
		{
			paComp = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
			if ( !paComp )
				return E_OUTOFMEMORY;
			hr = GetAttr ( paPos, cFilterAttrs, paFilterAttrs, dwFlags, paComp);
	        if ( FAILED(hr) )
	        	return hr;
    		if ( dwFlags & TS_ATTR_FIND_WANT_END )
				CompareAttrs ( paCurrent, paComp, cAlloAttrs, iAttrs, TRUE );
            else
				CompareAttrs ( paComp, paCurrent, cAlloAttrs, iAttrs, TRUE );
	    }

		if ( !( dwFlags & TS_ATTR_FIND_WANT_VALUE ) )
		{
			for ( int i= 0; i < cFilterAttrs; i++ )
			{
				VariantClear( &m_paAttrsTAP[i].varValue );
			}
		}

		m_cAttrsTAP = iAttrs;
		
		return S_OK;
	}

	
	HRESULT STDMETHODCALLTYPE FindNextAttrTransition ( IAnchor * paStart, 
													   IAnchor * paEnd, 
													   ULONG cFilterAttrs, 
													   const TS_ATTRID * paFilterAttrs, 
													   DWORD dwFlags, 
													   BOOL * pfFound, 
													   LONG * plFoundOffset )
	{
        IMETHOD( FindNextAttrTransition );
        if ( VerifyLock( TS_LF_READ ) == S_FALSE )
            return TS_E_NOLOCK;
        
        HRESULT hr  = m_pDoc->FindNextAttrTransition( paStart, paEnd, cFilterAttrs, paFilterAttrs, dwFlags, pfFound, plFoundOffset );
        if ( hr != E_NOTIMPL )
        	return hr;

		*pfFound = FALSE;
		*plFoundOffset = 0;
		
        // if the server does not support this do it ourselves
		// make sure there is really something to do
        if ( paStart == NULL )
        	return S_OK;

		// make sure we can hold the attributes we find
        hr = AllocateAttrs( cFilterAttrs );
        if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("AllocateAttrs failed ") );
        	return hr;
		}
        ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
 
		TS_ATTRVAL * paCurrent = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		TS_ATTRVAL * paNext = reinterpret_cast<TS_ATTRVAL *>( alloca( sizeof( TS_ATTRVAL ) * cAlloAttrs ) );
		if ( !paCurrent || !paNext )
			return E_OUTOFMEMORY;

		hr = GetAttr ( paStart, cFilterAttrs, paFilterAttrs, dwFlags, paCurrent);
        if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("Current GetAttr failed ") );
		    return hr;
		}

		LONG cchShifted;
		ULONG iAttrs = 0;
		BOOL fDone = TRUE;
		const LONG cchShift = ( dwFlags & TS_ATTR_FIND_BACKWARDS ) ? -1 : 1;
				
		CComPtr <IAnchor> paPos, paEndOfDoc;
		hr = paStart->Clone( &paPos );
		if ( FAILED(hr) )
		{
			TraceDebugHR( hr, TEXT("Clone failed ") );
        	return hr;
		}
		if ( paEnd == NULL )
		{
			if ( dwFlags & TS_ATTR_FIND_BACKWARDS )
			{
				m_pDoc->GetStart( &paEndOfDoc );
			}
			else
			{
			    BOOL fRegion = FALSE;
        		hr = paStart->Clone( &paEndOfDoc );
        		while ( fRegion )
        		{
				    paEndOfDoc->Shift( 0, LONG_MAX, &cchShifted, NULL );
				    paEndOfDoc->ShiftRegion( 0, TS_SD_FORWARD, &fRegion );
        		}
			}
		}
		
		while ( iAttrs == 0 )
		{
			hr = paPos->Shift( 0, cchShift, &cchShifted, NULL );	// TODO fix hidden text
			if ( SUCCEEDED(hr) && cchShifted == cchShift )
			{			
				*plFoundOffset += 1;
				hr = paPos->IsEqual( paEnd ? paEnd : paEndOfDoc, &fDone );
		        if ( FAILED(hr) )
				{
					TraceDebugHR( hr, TEXT("IsEqual failed ") );
		        	return hr;
				}
				if ( fDone )
					break;
					
				hr = GetAttr ( paPos, cFilterAttrs, paFilterAttrs, dwFlags, paNext);
		        if ( FAILED(hr) )
				{
					TraceDebugHR( hr, TEXT("Next GetAttr failed ") );
		        	return hr;
				}
		        CompareAttrs ( paCurrent, paNext, cFilterAttrs, iAttrs, FALSE );
				if ( iAttrs )
				{
					*pfFound = TRUE;
				}
	        }
	        else
	        {
				TraceDebugHR( hr, TEXT("Shift failed ") );
		       	return hr;
	        }
        }

		return S_OK;
	}
	
	HRESULT STDMETHODCALLTYPE RetrieveRequestedAttrs ( ULONG ulCount,
													   TS_ATTRVAL * paAttrVals,
													   ULONG * pcFetched )
	{
		// if there is no outstanding requests we satisfy then call through to the doc
		if ( m_cAttrsTAP == 0 )
			return m_pDoc->RetrieveRequestedAttrs( ulCount, paAttrVals, pcFetched );
	
		if ( ( m_cAttrsTAP - m_iAttrsTAP ) < ulCount )
			*pcFetched = m_cAttrsTAP - m_iAttrsTAP;
		else
			*pcFetched = ulCount;
			
		memcpy(paAttrVals, &m_paAttrsTAP[m_iAttrsTAP], *pcFetched * sizeof(TS_ATTRVAL));
		memset(&m_paAttrsTAP[m_iAttrsTAP], 0, *pcFetched * sizeof(TS_ATTRVAL));
		m_iAttrsTAP += *pcFetched;

		if ( m_iAttrsTAP == m_cAttrsTAP )
			ResetAttrs();
			
		return S_OK;
	}
	
private:
	ULONG m_cMaxAttrs;
	ULONG m_iAttrsTAP;
	ULONG m_cAttrsTAP;
	ULONG m_cAttrsTAPSize;
	TS_ATTRVAL * m_paAttrsTAP;
	TS_ATTRID * m_paAttrsSupported;

private:

	HRESULT STDMETHODCALLTYPE CompareAttrs ( TS_ATTRVAL * paAttr1, 
											 TS_ATTRVAL * paAttr2, 
											 ULONG cAttrs,
											 ULONG &iAttrs,
											 BOOL fCopy)
	{
	    cAttrs = cAttrs ? cAttrs : m_cMaxAttrs;
	    
		for ( int i = 0; i < cAttrs; i++ )
		{
			for ( int j = 0; j < cAttrs; j++ )
			{
				if ( paAttr1[i].idAttr == paAttr2[j].idAttr )
				{
					if ( CComVariant( paAttr1[i].varValue ) != CComVariant( paAttr2[j].varValue ) )
					{
						if ( fCopy )
						{
							char * cBuf = ( char * )&m_paAttrsTAP[iAttrs];
							memcpy( cBuf, ( char * )&paAttr2[j], sizeof(TS_ATTRVAL) );
						}
						iAttrs++;
					}
					break;
				}
			}
		}

		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetAttr ( IAnchor * paStart,
										ULONG cFilterAttrs,
										const TS_ATTRID * paFilterAttrs,
										DWORD dwFlags,
										TS_ATTRVAL * paAttrVals) 
	{
		ULONG cFetched;
        HRESULT hr;
	
		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
		const TS_ATTRID * paActualFilterAttrs = paFilterAttrs ? paFilterAttrs : m_paAttrsSupported;

        hr = m_pDoc->RequestAttrsAtPosition( paStart, cAlloAttrs, paActualFilterAttrs, 0 );
        if ( FAILED(hr) )
        	return hr;

        hr = m_pDoc->RetrieveRequestedAttrs( cAlloAttrs, paAttrVals, &cFetched );
        if ( FAILED(hr) )
        	return hr;

		return S_OK;

	}

	HRESULT STDMETHODCALLTYPE AllocateAttrs ( ULONG cFilterAttrs ) 
	{
		if ( cFilterAttrs == 0 && m_cMaxAttrs == 0 )
		{
			const LONG cAttrs = 512;
			
	        HRESULT hr = m_pDoc->RequestSupportedAttrs( 0, 0, NULL );
	        if ( FAILED(hr) )
	        	return hr;

			TS_ATTRVAL * paSupported = new TS_ATTRVAL[ cAttrs ];
			if ( !paSupported )
				return E_OUTOFMEMORY;
				
	        hr = m_pDoc->RetrieveRequestedAttrs( cAttrs, paSupported, &m_cMaxAttrs );
	        if ( SUCCEEDED(hr) )
	        {
    	        m_paAttrsSupported = new TS_ATTRID[ m_cMaxAttrs ];
                if ( m_paAttrsSupported )
                {
        	        for ( int i = 0; i < m_cMaxAttrs; i++ )
        	        {
                        m_paAttrsSupported[i] = paSupported[i].idAttr;
        	        }
                }
	        }
	        
			delete [] paSupported;

			if ( FAILED(hr) )
			    return hr;
			if ( !m_paAttrsSupported )
			    return E_OUTOFMEMORY;
		}

		ULONG cAlloAttrs = cFilterAttrs ? cFilterAttrs : m_cMaxAttrs;
		if ( m_cAttrsTAPSize < cAlloAttrs )
		{
			if ( m_paAttrsTAP )
				delete [] m_paAttrsTAP;

			m_paAttrsTAP =  new TS_ATTRVAL[ cAlloAttrs ];
			if ( !m_paAttrsTAP )
			{
				m_cAttrsTAPSize = 0;
				return E_OUTOFMEMORY;
			}	
			m_cAttrsTAPSize = cAlloAttrs;
		}
		
		return S_OK;
	}

	void ResetAttrs()
	{
		m_cAttrsTAP = 0;
		m_iAttrsTAP = 0;
	}
};






/* 12e53b1b-7d7f-40bd-8f88-4603ee40cf58 */
const IID IID_PRIV_CINPUTCONTEXT = { 0x12e53b1b, 0x7d7f, 0x40bd, {0x8f, 0x88, 0x46, 0x03, 0xee, 0x40, 0xcf, 0x58} };

/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_CTF = { 0xaabf7f9a, 0x4487, 0x4b2e, {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04} };


//
//  CDocSinkWrapBase
//
//  - Base from which Anchor and ACP sink wrappers are derived.
//
//  This class contains ACP/Anchor-neutral wrapping code - anything that is
//  ACP/Anchor-specific is handled in the derived ..ACP or ...Anchor class
//  instead.
//
//  Since this class is the sink for the wrapper, it derives from the full Cicero
//  sink (DocTraits::ICicSink - which is a typedef for ITfTextStoreSink[Anchor]),
//  and that in turn includes the ITextStoreACP sink.
//

template < class _DocTraits >
class ATL_NO_VTABLE CSinkWrapBase :
	public CComObjectRootEx<CComSingleThreadModel>,
    public _DocTraits::ISink,
    public _DocTraits::ICicSink,
    public IServiceProvider
{
public:

    // This typedef makes the DocTraits type visible in this and in the
    // Anchor/ACP-specific derived classes. (Otherwise, as a template
    // parameter in this class, it would not be available to them.)
    typedef _DocTraits DocTraits;

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP( CSinkWrapBase<DocTraits> )
    COM_INTERFACE_ENTRY( DocTraits::ISink )
	COM_INTERFACE_ENTRY( DocTraits::ICicSink )
	COM_INTERFACE_ENTRY( IServiceProvider )
END_COM_MAP()

/*
    static HRESULT InternalQueryInterface( void* pThis, const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject )
    {
        // Hack for cicero - they expect to be able to QI for IID_PRIV_CINPUTCONTEXT and get
        // a ptr to one of ther internal class types (ick!)
        // This breaks COM identity, but hey, it's a private IID, and is only ever used
        // locally.
        // We can't do that sort of goo using the interface map (above), so have to hijack InternalQI instead.
        if( iid == IID_PRIV_CINPUTCONTEXT )
        {
            CSinkWrapBase<DocTraits> * pTHIS = (CSinkWrapBase<DocTraits> *)pThis;

            // Look for the cicero sink...
            // recognize it by the iid - it will have reg'd with a ITf (not TextStore) IID...
            for( Iter_dl< DocTraits::CDocWrap > i ( pTHIS->m_pMgr->m_DocWraps ) ; ! i.AtEnd(); i++ )
            {
                if( i->m_Sink.m_pSink && i->m_Sink.m_iid == __uuidof( DocTraits::ICicSink ) )
                {
                    return i->m_Sink.m_pSink->QueryInterface( iid, ppvObject );
                }
            }

            return E_NOINTERFACE;
        }

        return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface( pThis, pEntries, iid, ppvObject );
    }
*/
protected:

    // Protected stuff - used in this class, and by the ACP/Anchor-specific
    // derived classes.

    // Link back to the wrap manager. Used to tell it when we are going
    // away...
    CWrapMgr< DocTraits > *   m_pMgr;

    // Ptr to the manager's list of docs (which contain sinks)...
    List_dl< typename DocTraits::CDocWrap > *  m_pDocs;


    // This macro forwards a call by iterating all the sinks in the manager,
    // and forwarding if their mask has the right bit set.
    // Note - this CANNOT be used for OnLockGranted.
#define CSinkWrap_FORWARD( mask, fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr && m_pDocs );\
        m_pMgr->RemoveDeadDocs();\
        CPrivateAddRef MyAddRef(m_pMgr->m_lIterationRefCount);\
        for( Iter_dl < DocTraits::CDocWrap > i ( *m_pDocs ) ; ! i.AtEnd() ; i++ )\
        {\
            DocTraits::ISink * pSink = static_cast< DocTraits::ISink * >( i->m_Sink.m_pSink );\
            DWORD dwMask = i->m_Sink.m_dwMask;\
            if( pSink && ( mask == 0 || ( dwMask & mask ) ) )\
            {\
                pSink-> fname AS_CALL( c, params );\
            }\
        }\
        return S_OK ;\
    }




    // This macro forwards Cicero's TextStoreSink calls - they're not really sinks since
    // the return values are significant - true broadcast is not supported; only the
    // first sink in the manager which supports the interface is used - and its
    // return value gets returned.

#define CSinkWrap_FORWARD_CICERO( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params )\
    {\
        IMETHOD( fname );\
        Assert( m_pMgr && m_pDocs );\
        for( Iter_dl < DocTraits::CDocWrap > i ( *m_pDocs ) ; ! i.AtEnd() ; i++ )\
        {\
        	if ( i->m_Sink.m_pSink )\
			{\
				CComPtr< DocTraits::ICicSink > pTheSink;\
        		HRESULT hr = i->m_Sink.m_pSink->QueryInterface( __uuidof(DocTraits::ICicSink), (void **)&pTheSink );\
				if( hr == S_OK )\
				{\
					return pTheSink-> fname AS_CALL( c, params );\
				}\
			}\
        }\
        return E_FAIL ;\
    }


public:

    //
    // Ctor, Dtor and initialization...
    //

    CSinkWrapBase()
        : m_pMgr( NULL ),
          m_pDocs( NULL )
    {
        
    }

    ~CSinkWrapBase()
    {
        AssertMsg( m_pMgr != NULL && m_pDocs != NULL, TEXT("CSinkWrapBase::Init never got called?") );
        m_pMgr->SinkWrap_NotifyDisconnect();
        m_pMgr->Release();
    }

    void Init( CWrapMgr< DocTraits > * pMgr, List_dl< typename DocTraits::CDocWrap > * pDocs )
    {
        AssertMsg( m_pMgr == NULL && m_pDocs == NULL, TEXT("CSinkWrapBase::Init should only be called once when m_pMgr is NULL") );
        m_pMgr = pMgr;
        m_pMgr->AddRef();

        m_pDocs = pDocs;
    }

    //
    // IServiceProvider - Cicero uses this to 'drill through' to the original anchor to pull out
    // internal information. Just pass it through...
    //
    HRESULT STDMETHODCALLTYPE QueryService( REFGUID guidService, REFIID riid, void **ppvObject )
    {
        IMETHOD( QueryService );

        // Find the cicero sink...

        DocTraits::ICicSink * pTheSink = NULL;

        // Look for the cicero sink...
        // The cicero sink supports the Services interfaces and other don't
		for( Iter_dl< DocTraits::CDocWrap > i ( m_pMgr->m_DocWraps ) ; ! i.AtEnd(); i++ )
        {
        	if ( i->m_Sink.m_pSink )
            {
                if( i->m_Sink.m_pSink->QueryInterface( __uuidof(DocTraits::ICicSink), (void **)&pTheSink ) == S_OK )
                {
				    break;
                }
            } 
        }

        if( pTheSink == NULL )
            return E_FAIL;

        CComPtr<IServiceProvider> pISP;
        HRESULT hr = pTheSink->QueryInterface( IID_IServiceProvider, (void **) & pISP );
        if( hr != S_OK || pISP == NULL )
            return E_FAIL;

        hr = pISP->QueryService( guidService, riid, ppvObject );

        return hr;
    }

    //
    // ACP/Anchor-neutral sinks - just broadcast these...
    //

    CSinkWrap_FORWARD( TS_AS_SEL_CHANGE,     OnSelectionChange,		0, () )
    CSinkWrap_FORWARD( TS_AS_LAYOUT_CHANGE,  OnLayoutChange,		2, ( TsLayoutCode, lcode, TsViewCookie, vcView ) )
    CSinkWrap_FORWARD( 0,                    OnStatusChange,		1, ( DWORD, dwFlags ) )
    CSinkWrap_FORWARD( 0,					 OnStartEditTransaction,0, () )
    CSinkWrap_FORWARD( 0,					 OnEndEditTransaction,  0, () )

    
    //
    // Special case for OnLockGranted...
    // Handle single-client sync requests, and multiple queued async requests...
    //

    HRESULT STDMETHODCALLTYPE OnLockGranted ( DWORD dwLockFlags )
    {
        IMETHOD( OnLockGranted );

        Assert( m_pMgr );
        return m_pMgr->SinkWrap_HandleOnLockGranted( dwLockFlags );
    }
};







//
// CSinkWrapACP
//
// - ACP sink wrapper
//
// Derived from the CSinkWrapBase, this adds ACP-specific methods; including
// those from both ITextStoreACP and the cicero-specific ITfTextStoreSink
// interfaces.
//

class ATL_NO_VTABLE CSinkWrapACP : 
    public CSinkWrapBase< DocTraitsACP >
{

public:
    //
    // ITextStoreACPSink ACP/Anchor-specific methods - broadcast to all interested sinks...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD( TS_AS_TEXT_CHANGE,  OnTextChange,       2, ( DWORD, dwFlags, const TS_TEXTCHANGE *, pChange ) )
    CSinkWrap_FORWARD( 0,                  OnAttrsChange,      4, ( LONG, acpStart, LONG, acpEnd, ULONG, cAttrs, const TS_ATTRID *, paAttrs ) )


    //
    // Cicero-specific sink methods - forward these to the first available sink that implements the cicero interface...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD_CICERO( Serialize,     	4, (ITfProperty *, pProp, ITfRange *, pRange, TF_PERSISTENT_PROPERTY_HEADER_ACP *, pHdr, IStream *, pStream) )
    CSinkWrap_FORWARD_CICERO( Unserialize,   	4, (ITfProperty *, pProp, const TF_PERSISTENT_PROPERTY_HEADER_ACP *, pHdr, IStream *, pStream, ITfPersistentPropertyLoaderACP *, pLoader) )
    CSinkWrap_FORWARD_CICERO( ForceLoadProperty,1, (ITfProperty *, pProp) )
    CSinkWrap_FORWARD_CICERO( CreateRange,   	3, (LONG, acpStart, LONG, acpEnd, ITfRangeACP **, ppRange) )

};




//
// CSinkWrapAnchor
//
// - Anchor sink wrapper
//
// Derived from the CSinkWrapBase, this adds Anchor-specific methods; including
// those from both ITextStoreACP and the cicero-specific ITfTextStoreSink
// interfaces.
//

class ATL_NO_VTABLE CSinkWrapAnchor : 
    public CSinkWrapBase< DocTraitsAnchor >
{

public:
    //
    // ITextStoreACPSink ACP/Anchor-specific methods - broadcast to all interested sinks...
    // (See CSinkWrapBase for the forwarding macro.)
    //

    CSinkWrap_FORWARD( TS_AS_TEXT_CHANGE,  OnTextChange,       3, ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd ) )
    CSinkWrap_FORWARD( 0,                  OnAttrsChange,      4, ( IAnchor *, paStart, IAnchor *, paEnd, ULONG, cAttrs, const TS_ATTRID *, paAttrs ) )


    //
    // Cicero-specific sink methods - forward these to the first available sink that implements the cicero interface...
    // (See CSinkWrapBase for the forwarding macro.)
    //
    
    CSinkWrap_FORWARD_CICERO( Serialize,     	4, (ITfProperty *, pProp, ITfRange *, pRange, TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *, pHdr, IStream *, pStream) )
    CSinkWrap_FORWARD_CICERO( Unserialize,   	4, (ITfProperty *, pProp, const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *, pHdr, IStream *, pStream, ITfPersistentPropertyLoaderAnchor *, pLoader) )
    CSinkWrap_FORWARD_CICERO( ForceLoadProperty,1, (ITfProperty *, pProp) )
    CSinkWrap_FORWARD_CICERO( CreateRange,   	3, (IAnchor *, paStart, IAnchor *, paEnd, ITfRangeAnchor **, ppRange) )


};













CDocWrap::CDocWrap()
    : m_punkDoc( NULL ),
      m_pWrapMgr( NULL )
{
    IMETHOD( CDocWrap );
    // Done.
}

CDocWrap::~CDocWrap()
{
    IMETHOD( ~CDocWrap );

    _Clear();
}


HRESULT STDMETHODCALLTYPE CDocWrap::SetDoc( REFIID riid, IUnknown * pDocIn )
{
    IMETHOD( SetDoc );

    _Clear();

    if( pDocIn == NULL )
    {
        TraceInfo( TEXT("CDocWrapp::SetDoc( NULL ) - doc cleared") );
        return S_OK;
    }

    HRESULT hr;
    if( riid == IID_ITextStoreACP || riid == IID_ITfTextStoreACP )
    {
        CWrapMgr< DocTraitsACP > * pWrapMgrACP;
        hr = CreateLocalInstance( & pWrapMgrACP );
        m_pWrapMgr = pWrapMgrACP;
    }
    else if( riid == IID_ITextStoreAnchor || riid == IID_ITfTextStoreAnchor )
    {
        CWrapMgr< DocTraitsAnchor > * pWrapMgrAnchor;
        hr = CreateLocalInstance( & pWrapMgrAnchor );
        m_pWrapMgr = pWrapMgrAnchor;
    }
    else
    {
        TraceParam( TEXT("CDocWrapp::SetDoc - given unknown IID") );
        return E_NOINTERFACE;
    }

    CHECK_HR_RETURN( hr, m_pWrapMgr != NULL );

    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("Couldn't create CWrapMgr") );
        return FAILED( (hr) ) ? (hr) : E_UNEXPECTED;
    }
    if( hr == S_OK && ! m_pWrapMgr )
    {
        TraceErrorHR( hr, TEXT("Couldn't create CWrapMgr") );
        return E_UNEXPECTED;
    }


    m_pWrapMgr->SetDoc( pDocIn );
    m_iid = riid;
    m_punkDoc = pDocIn;
    m_punkDoc->AddRef();

    TraceInfo( TEXT("CDocWrap::SetDoc - new doc set.") );
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CDocWrap::GetWrappedDoc( REFIID riid, IUnknown ** pWrappedDocOut )
{
    IMETHOD( GetWrappedDoc );

    if( ! m_punkDoc || ! m_pWrapMgr )
    {
        TraceParam( TEXT("GetWrappedDoc called without prior successful call to SetDoc") );
        return E_FAIL;
    }
    if( ! pWrappedDocOut )
    {
        TraceParam( TEXT("GetWrappedDoc called without NULL pWrappedDocOut param") );
        return E_POINTER;
    }

    // Check that requested iid matches...
    // We allow Doc/ITf mixes, provided the interfaces match ACP/Anchor-wise.
    if( m_iid == IID_ITextStoreAnchor || m_iid == IID_ITfTextStoreAnchor )
    {
        if( riid != IID_ITextStoreAnchor && riid != IID_ITfTextStoreAnchor )
        {
            TraceParam( TEXT("Interface requested by GetWrappedDoc doesn't match that suplied by SetDoc") );
            return E_NOINTERFACE;
        }
    }
    else
    {
        if( riid != IID_ITextStoreACP && riid != IID_ITfTextStoreACP )
        {
            TraceParam( TEXT("Interface requested by GetWrappedDoc doesn't match that suplied by SetDoc") );
            return E_NOINTERFACE;
        }
    }


    TraceInfo( TEXT("GetWrappedDoc succeeded") );

    return m_pWrapMgr->CreateWrappedDoc( pWrappedDocOut );
}



void CDocWrap::_Clear()
{
    SafeReleaseClear( m_pWrapMgr );
    SafeReleaseClear( m_punkDoc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\dict.h ===
// DictImpl.h : Declaration of the CDict

#ifndef __DICT_H_
#define __DICT_H_

#include "resource.h"       // main symbols
#include <map>
/////////////////////////////////////////////////////////////////////////////
// CDict

class CDict;

struct TermInfo
{
    const TS_ATTRID *	pTermID;
    const TS_ATTRID *   pParentID;
    WCHAR *             pszMnemonic;
    ULONG               idString;
    BSTR ( CDict::*mfpConvertToString ) ( const VARIANT &, LCID & );
};


struct GUIDLess
{
	bool operator ()(const GUID& g1, const GUID& g2) const
	{
		const ULONG *lpGUID1 = (ULONG *)&g1;
		const ULONG *lpGUID2 = (ULONG *)&g2;
		for (int i = 0; i < 4; i++)
		{
			if (lpGUID1[i] < lpGUID2[i])
				return true;
			if (lpGUID1[i] > lpGUID2[i])
				return false;
		}
						
		return false; 
	}
};

struct WCHARLess
{
	bool operator ()(const WCHAR* s1, const WCHAR* s2) const
	{
		if (wcscmp(s1, s2) < 0)
			return true;
		else
			return false; 
	}
};

typedef std::map<const TS_ATTRID, const TermInfo*, GUIDLess> DictMap;
typedef std::map<const WCHAR *, const TermInfo*, WCHARLess> DictMnemonicMap;


class ATL_NO_VTABLE CDict : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDict, &CLSID_AccDictionary>,
	public IAccDictionary
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MSAADICT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDict)
	COM_INTERFACE_ENTRY(IAccDictionary)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
#ifdef DEBUG
		m_hinstResDll = LoadLibraryEx( TEXT("C:\\tools\\OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
		if( m_hinstResDll )
		{
			// load it from where I put it for debug purposes
			return S_OK;
		}
#endif
		m_hinstResDll = LoadLibraryEx( TEXT("OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
		if( ! m_hinstResDll )
		{
			return E_FAIL;
		}

		return S_OK;
	}

    CDict();
    ~CDict();
    // IAccDictionary

	HRESULT STDMETHODCALLTYPE GetLocalizedString (
								REFGUID			Term,
								LCID			lcid,
								BSTR *			pResult,
								LCID *			plcid			
	);
	
	HRESULT STDMETHODCALLTYPE GetParentTerm (
								REFGUID			Term,
								GUID *			pParentTerm
	);

	HRESULT STDMETHODCALLTYPE GetMnemonicString (
								REFGUID			Term,
								BSTR *			pResult
	);

	HRESULT STDMETHODCALLTYPE LookupMnemonicTerm (
								BSTR			bstrMnemonic,
								GUID *			pTerm
	);
	
	HRESULT STDMETHODCALLTYPE ConvertValueToString (
								REFGUID			Term,
								LCID			lcid,
								VARIANT			varValue,
								BSTR *			pbstrResult,
								LCID *			plcid			
	);
	
	// The following convert member functions are called from ConvertValueToString
	// by accessing a member function pointer in the dictionary
	BSTR ConvertPtsToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertBoolToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertColorToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertWeightToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertLangIDToString( const VARIANT & value, LCID & lcid );
	BSTR ConvertBSTRToString( const VARIANT & value, LCID & lcid );

private:
	double CDict::ColorDistance(COLORREF crColor1, COLORREF crColor2);

private:
    DictMap m_mapDictionary;
    DictMnemonicMap m_mapMnemonicDictionary;
	HINSTANCE m_hinstResDll;
};

#endif //__DICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_)
#define AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C3CDDC0F_06F6_44FD_B799_8F9F366B2F14__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\inc\tstr.h ===
//
// TSTR - represents a writable position in a string.
//
// Has methods to safely append to the string. Will not overrun buffer,
// truncates if reaches the end.
//
//
// Sample usage:
//
//     void SomeFunc( TSTR & str )
//     {
//         int i = 42;
//         str << TEXT("Value is: ") << i;
//     }
//
// Can be used with TCHAR*-style APIs, by using the ptr(), left() and
// advance() members. ptr() returns pointer to current write position,
// left() returns number of chars left, and advance() updates the write
// position.
//
//     void MyGetWindowText( StrWrPos & str )
//     {
//         int len = GetWindowText( hWnd, str.ptr(), str.left() );
//         str.advance( len );
//     }
//
// This makes sure that the text will not be truncated
//     void MyGetWindowText( StrWrPos & str )
//     {
//			str.anticipate( GetWindowTextLength( hWnd );  
//     		int len = GetWindowText( hWnd, str.ptr(), str.left() );
//         	str.advance( len );
//     }
//
// Sample usage:
//
//     void Func( TSTR & str );
//
//     TSTR s(128);
//     s << TEXT("Text added: [");
//     Func( s ); // add more text to string
//     s << TEXT("]");
//
//     SetWindowText( hwnd, s );
//

//
// WriteHex - helper class to output hex values:
//
// Sample usage:
//
//    str << TEXT("Value is:") << WriteHex( hwnd, 8 );
//
// Can optionally specify number of digits to output. (result will be
// 0-padded.)
//

//
// WriteError - helper class to output COM error values:
//
// Sample usage:
//
//    hr = ProcessData();
//    if( hr != S_OK )
//    {
//        str << WriteError( hr, TEXT("in ProcessData()");
//        LogError( str.str() );
//    }
//

#ifndef _TSTR_H_
#define _TSTR_H_

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )
// These allow us to compile with the pre-Win64 SDK (eg. using visual studio)
typedef unsigned long UINT_PTR;
typedef DWORD DWORD_PTR;
#define PtrToInt  (int)

#endif
#define LONG_TEXT_LENGTH 40

#include <oaidl.h>
#include <crtdbg.h>
#include <string>
typedef std::basic_string<TCHAR> tstring;
typedef std::string ASTR;			// save these names for where we expand
typedef std::wstring WSTR;			// the usage of this stuff to include them

class TSTR : public tstring
{
	// this is only used for ptr, left and advance functions.  
	ULONG m_lTheRealSize;

public:

	TSTR() : m_lTheRealSize(-1) { }

	TSTR(const TCHAR *s) : tstring(s, static_cast<size_type>(lstrlen(s))), m_lTheRealSize(-1) { }

	TSTR(const TCHAR *s, size_type n) : tstring(s, n), m_lTheRealSize(-1) { }

	TSTR(const tstring& rhs) : tstring(rhs), m_lTheRealSize(-1) { }
	
	TSTR(const tstring& rhs, size_type pos, size_type n) : tstring(rhs, pos, n), m_lTheRealSize(-1) { }
	
	TSTR(size_type n, TCHAR c) : tstring(n, c), m_lTheRealSize(-1) { }

	TSTR(size_type n) : tstring(), m_lTheRealSize(-1) { reserve( n + 1 ); }

	TSTR(const_iterator first, const_iterator last) : tstring(first, last), m_lTheRealSize(-1) { }

    operator const TCHAR * () 
    {
        return c_str();
    }

	TCHAR * ptr()              
	{
		_ASSERT(m_lTheRealSize == -1);
		m_lTheRealSize = size();

		TCHAR *pEnd = &(*end());
		resize(capacity());

		return pEnd; 
	}

	unsigned int left()	
	{
		unsigned int left;

		if (m_lTheRealSize == -1)
			left = ( capacity() - size() ) - 1;
		else
			left =  ( capacity() - m_lTheRealSize ) - 1;

		return left;
	}

	void advance( unsigned int c )
	{
		_ASSERT(m_lTheRealSize != -1);  // ptr has not been called so we should not need to advance
		if (m_lTheRealSize != -1)
		{
			at( m_lTheRealSize + c ) = NULL;	// make sure this stays null terminated
			resize(m_lTheRealSize + c);

			m_lTheRealSize = -1;
		}
	}

	void reset()
	{
		resize(0);
		m_lTheRealSize = -1;
	}

	void anticipate( unsigned int c )
	{
		if ( c > 0 )
		{
			unsigned int cSize;

			if ( m_lTheRealSize == -1 )
				cSize = size();
			else
				cSize = m_lTheRealSize;

			const unsigned int i = capacity() - cSize;

			if ( i < c )
				reserve( cSize + c + 1 );
		}
	}

};

inline 
TSTR & operator << ( TSTR & str, const TCHAR * obj )
{
	if ( obj )
		str.append( obj );
	return str;
}

inline 
TSTR & operator << ( TSTR & str, TCHAR obj )
{
	str.append( &obj, 1 );
	return str;
}

inline 
TSTR & operator << ( TSTR & str, long obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ltow( obj, sz, 10 ));	
	return str;
#else
	str.append(_ltoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, unsigned long obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ultow( obj, sz, 10 ));
	return str;
#else
	str.append(_ultoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, int obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_itow( obj, sz, 10 ));
	return str;
#else
	str.append(_itoa( obj, sz, 10 ));
	return str;
#endif
}

inline 
TSTR & operator << ( TSTR & str, unsigned int obj )
{
	TCHAR sz[LONG_TEXT_LENGTH];
#ifdef UNICODE
	str.append(_ultow( static_cast<unsigned long>(obj), sz, 10 ));
	return str;
#else
	str.append(_ultoa( static_cast<unsigned long>(obj), sz, 10 ));
	return str;
#endif

}

#ifndef UNICODE
inline 
TSTR & operator << ( TSTR & str, const WCHAR * obj )
{
	if ( obj )
	{
		str.anticipate( wcslen( obj ) + 1 );
		
		int len = WideCharToMultiByte( CP_ACP, 0, obj, -1, str.ptr(), str.left(), NULL, NULL );
    
		// Len, in this case, includes the terminating NUL - so subtract it, if
		// we got one...
		if( len > 0 )
			len--;

		str.advance( len );
	}
	return str;
}
#endif

//
// WriteHex - helper class to output hex values:
//
// See top of file for usage notes.
//

class WriteHex
{
    DWORD_PTR m_dw;
	int   m_Digits;
public:

    // If Digits not specified, uses only as many as needed.
	WriteHex( DWORD dw, int Digits = -1 ) : m_dw( dw ), m_Digits( Digits ) { }

    // For pointer, pads if necessary to get std. ptr size.
    // (sizeof(ptr)*2, since 2 digits per byte in ptr).
	WriteHex( const void * pv, int Digits = sizeof(void*)*2 ) : m_dw( (DWORD_PTR)pv ), m_Digits( Digits ) { }

	void Write( TSTR & str ) const
	{
		static const TCHAR * HexChars = TEXT("0123456789ABCDEF");

		//str << TEXT("0x");


		int Digit;
		if( m_Digits == -1 )
		{
			// Work out number of digits...
			Digit = 0;
			DWORD test = m_dw;
			while( test )
			{
				Digit++;
				test >>= 4;
			}

			// Special case for 0 - still want one digit.
			if( Digit == 0 )
				Digit = 1;
		}
		else
			Digit = m_Digits;

		while( Digit )
		{
			Digit--;
			str << HexChars[ ( m_dw >> (Digit * 4) ) & 0x0F ];
		}
	}
};

inline
TSTR & operator << ( TSTR & s, const WriteHex & obj )
{
	obj.Write( s );
	return s;
}

//
// WriteError - helper class to output COM error values:
//
// See top of file for usage notes.
//

class WriteError
{
    HRESULT m_hr;
	LPCTSTR m_pWhere;
public:
	WriteError( HRESULT hr, LPCTSTR pWhere = NULL )
		: m_hr( hr ),
		  m_pWhere( pWhere )
	{ }

	void Write( TSTR & str ) const
	{
		str << TEXT("[Error");
		if( m_pWhere )
			str << TEXT(" ") << m_pWhere;
		str << TEXT(": hr=0x") << WriteHex( m_hr ) << TEXT(" - ");
		if( m_hr == S_FALSE )
		{
			str << TEXT("S_FALSE");
		}
		else
		{
			int len = FormatMessage( 
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					m_hr,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
					str.ptr(),
					str.left(),
					NULL );
			if( len > 2 )
				len -= 2; // Ignore trailing /r/n that FmtMsg() adds...
			str.advance( len );
		}
		str << TEXT("]");
	}
};

inline
TSTR & operator << ( TSTR & s, const WriteError & obj )
{
	obj.Write( s );
	return s;
}

inline
TSTR & operator << ( TSTR & s, const GUID & guid )
{
    s << TEXT("{") << WriteHex( guid.Data1, 8 )  // DWORD
      << TEXT("-") << WriteHex( guid.Data2, 4 )  // WORD
      << TEXT("-") << WriteHex( guid.Data3, 4 )  // WORD
      << TEXT("-")
      << WriteHex( guid.Data4[ 0 ], 2 )
      << WriteHex( guid.Data4[ 1 ], 2 )
      << TEXT("-");

    for( int i = 2 ; i < 8 ; i++ )
    {
        s << WriteHex( guid.Data4[ i ], 2 ); // BYTE
    }
    s << TEXT("}");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const VARIANT & var )
{
    s << TEXT("[");
    switch( var.vt )
    {
        case VT_EMPTY:
        {
            s << TEXT("VT_EMPTY");
            break;
        }

        case VT_I4:
        {
            s << TEXT("VT_I4=0x");
            s << WriteHex( var.lVal );
            break;
        }

        case VT_I2:
        {
            s << TEXT("VT_I2=0x");
            s << WriteHex( var.iVal );
            break;
        }

        case VT_BOOL:
        {
            s << TEXT("VT_BOOL=");
            if( var.boolVal == VARIANT_TRUE )
                s << TEXT("TRUE");
            else if( var.boolVal == VARIANT_FALSE )
                s << TEXT("FALSE");
            else
                s << TEXT("?") << var.boolVal;
            break;
        }

        case VT_R4:
        {
            float fltval = var.fltVal;
            int x = (int)(fltval * 100);

            s << TEXT("VT_R4=") << x/100 << TEXT(".") 
                                << x/10 % 10 
                                << x % 10;
            break;
        }

        case VT_BSTR:
        {
            s << TEXT("VT_BSTR=\"") << var.bstrVal << TEXT("\"");
            break;
        }

        case VT_UNKNOWN:
        {
            s << TEXT("VT_UNKNOWN=0x") << WriteHex( var.punkVal, 8 );
            break;
        }

        case VT_DISPATCH:
        {
            s << TEXT("VT_DISPATCH=0x") << WriteHex( var.pdispVal, 8 );
            break;
        }

        default:
        {
            s << TEXT("VT_? ") << (long)var.vt;
            break;
        }
    }

    s << TEXT("]");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const POINT & pt )
{
    s << TEXT("{x:") << pt.x
      << TEXT(" y:") << pt.y
      << TEXT("}");
    return s;
}

inline
TSTR & operator << ( TSTR & s, const RECT & rc )
{
    s << TEXT("{l:") << rc.left
      << TEXT(" t:") << rc.top
      << TEXT(" r:") << rc.right
      << TEXT(" b:") << rc.bottom
      << TEXT("}");
    return s;
}


#endif // _TSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaaadapter.cpp ===
// MSAAAdapter.cpp : Implementation of CAccServerDocMgr
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAAdapter.h"

#define INITGUID
#include <msctfx.h>

#include "MSAAStore.h"

// - in AnchorWrap.cpp
HRESULT WrapACPToAnchor( ITextStoreACP * pDocAcp, ITextStoreAnchor ** ppDocAnchor );



CAccServerDocMgr::CAccServerDocMgr()
    : m_pAccStore( NULL )
{
    IMETHOD( CAccServerDocMgr );
}

CAccServerDocMgr::~CAccServerDocMgr()
{
    IMETHOD( ~CAccServerDocMgr );

    if( m_pAccStore )
    {
        m_pAccStore->Release();
    }
}


BOOL CheckForWrapper( ITextStoreAnchor ** ppDoc )
{
    // Is this a cloneable wrapper? If not, need to wrap it...

    IClonableWrapper * pClonableWrapper = NULL;
    HRESULT hr = (*ppDoc)->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );

    if( hr == S_OK && pClonableWrapper )
    {
        // It already supports IClonableWrapper - nothing else to do...
        pClonableWrapper->Release();
        return TRUE;
    }

    // Need to use doc wrapper to get clonable (multi-client) support

    IDocWrap * pDocWrap = NULL;
    hr = CoCreateInstance( CLSID_DocWrap, NULL, CLSCTX_SERVER, IID_IDocWrap, (void **) & pDocWrap );
    if( hr != S_OK || ! pDocWrap )
        return FALSE;

    hr = pDocWrap->SetDoc( IID_ITextStoreAnchor, *ppDoc );
    if( hr != S_OK )
    {
        pDocWrap->Release();
        return FALSE;
    }

    ITextStoreAnchor * pNewDoc = NULL;
    hr = pDocWrap->GetWrappedDoc( IID_ITextStoreAnchor, (IUnknown **) & pNewDoc );
    pDocWrap->Release();

    if( hr != S_OK || ! pNewDoc )
        return FALSE;

    // This time round, QI should work (since we're talking to a wrapper)...

    pClonableWrapper = NULL;
    hr = pNewDoc->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );
    if( hr != S_OK || ! pClonableWrapper )
    {
        pNewDoc->Release();
        return FALSE;
    }

    // Yup, it worked - replace the input doc with the new wrapped doc...
    pClonableWrapper->Release();
    (*ppDoc)->Release();
    *ppDoc = pNewDoc;
    return TRUE;
}




HRESULT STDMETHODCALLTYPE CAccServerDocMgr::NewDocument ( 
    REFIID		riid,
	IUnknown *	punk
)
{
    IMETHOD( NewDocument );

    // Check for known IIDs...

    CComPtr<ITextStoreAnchor> pDoc;
    if( riid == IID_ITextStoreAnchor || riid == IID_ITfTextStoreAnchor )
    {
        pDoc = (ITextStoreAnchor *) punk;
    }
    else if( riid == IID_ITextStoreACP || riid == IID_ITfTextStoreACP )
    {
        TraceParam( TEXT("Got ACP doc, but ACP->Anchor wrapping not currently supported") );
        return E_NOTIMPL;
/*
// We don't currently support ACP- interfaces directly - cicero always gives us
// Anchor interfaces, wrapping ACPs if necesary.
        HRESULT hr = WrapACPToAnchor( static_cast<ITextStoreACP *>( punk ), & pDoc );
        if( hr != S_OK )
            return hr;
*/
    }
    else
    {
        TraceParam( TEXT("Got unknown interface - wasn't ITextStoreAnchor/ITfTextStoreAnchor") );
        return E_NOINTERFACE;
    }


    // Wrap the doc if necessary, to get multi-client support (via IClonableWrapper)...
    if( ! CheckForWrapper( & pDoc.p ) )
    {
        return E_FAIL;
    }


    if( ! m_pAccStore )
    {
        m_pAccStore = NULL;
        HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );
        if( ! m_pAccStore )
        {
            TraceErrorHR( hr, TEXT("CoCreate(AccStore)") );
            return hr;
        }
    }

    // TODO - what IID here?
    HRESULT hr = m_pAccStore->Register( IID_ITextStoreAnchor, pDoc.p );

    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("m_pAccStore->Register()") );
        return hr;
    }


    IUnknown * pCanonicalUnk = NULL;
    hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr == S_OK && pCanonicalUnk != NULL )
    {
        DocAssoc * pDocAssoc = new DocAssoc;
        if ( !pDocAssoc )
        {
            return E_OUTOFMEMORY;
        }
        
        pDocAssoc->m_pdocAnchor = pDoc;
        pDocAssoc->m_pdocOrig = pCanonicalUnk;
        m_Docs.AddToHead( pDocAssoc );
    }
    else
    {
        AssertMsg( FALSE, TEXT("QI(IUnknown) failed") );
        return hr;
    }

    pDoc.p->AddRef(); 

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccServerDocMgr::RevokeDocument (
    IUnknown *	punk
)
{
    IMETHOD( RevokeDocument );

	if ( !punk )
		return E_INVALIDARG;

    // Get the canonical IUnknown for comparison purposes...
    IUnknown * pCanonicalUnk = NULL;
    if( punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk ) != S_OK || pCanonicalUnk == NULL )
    {
        return E_FAIL;
    }


    // Do we recognise this doc?
    DocAssoc * pDocAssoc = NULL;
    for( Iter_dl< DocAssoc > i ( m_Docs ) ; ! i.AtEnd() ; i++ )
    {
        if( i->m_pdocOrig == pCanonicalUnk )
        {
            pDocAssoc = i;
            break;
        }
    }

    pCanonicalUnk->Release();

    if( ! pDocAssoc )
    {
        // Not found
        return E_INVALIDARG;
    }

    // Unregister with the store...
    HRESULT hr = m_pAccStore->Unregister( pDocAssoc->m_pdocAnchor );
    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("m_pAccStore->Unregister()") );
    }


    // Try calling IInternalDocWrap::NotifyRevoke() to tell the DocWrapper that the doc is
    // going away. (It will forward this to any interested clients.)
    IInternalDocWrap * pInternalDocWrap = NULL;
    hr = pDocAssoc->m_pdocAnchor->QueryInterface( IID_IInternalDocWrap, (void **) & pInternalDocWrap );

    if( hr == S_OK && pInternalDocWrap )
    {
        pInternalDocWrap->NotifyRevoke();
        pInternalDocWrap->Release();
    }
    else
    {
        TraceErrorHR( hr, TEXT("pdocAnchor didn't support IInternalDocWrap - was it wrapped properly?") );
    }


    // Remove from internal list...
    m_Docs.remove( pDocAssoc );
    pDocAssoc->m_pdocOrig->Release();
    pDocAssoc->m_pdocAnchor->Release();
    delete pDocAssoc;

    // Done.
    return hr;
}

HRESULT STDMETHODCALLTYPE CAccServerDocMgr::OnDocumentFocus (
    IUnknown *	punk
)
{
    IMETHOD( OnDocumentFocus );

    if( ! m_pAccStore )
    {
        m_pAccStore = NULL;
        HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );
        if( ! m_pAccStore )
        {
            TraceErrorHR( hr, TEXT("CoCreate(AccStore)") );
            return hr;
        }
    }
	return m_pAccStore->OnDocumentFocus( punk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\docwrapexcept.h ===
// DocWrapExcept
//
// Classes that wrap interface pointers. All methods are passed through, but any
// SEH-type exceptions are caught, logged, and result in an error.
//
// Note that COM interfaces are not supposed to throw exceptions - this code exists
// as a robustness/preventative measure.
//
// This file in #included by DocWrapImpl.cpp. It exists as a separate file just to
// avoid clutter - this code is not currently reused anywhere else.

// Code below assumes the following have already beein defined (in DocWrapImpl.cpp):
//     class BasicDocTraitsAnchor
//     class BasicDocTraitsACP

#include <tStr.h>

void HandleException( DWORD dwException, LPCTSTR pFName )
{
    TraceError( TSTR() << TEXT("Exception 0x") << WriteHex( dwException ) << TEXT(" thrown from ") << pFName );
}


// If we want to use the IMETHOD(name) call tracking macro here, we need to disable warning 4509,
// which warns against mixing object that have destructors (used by IMETHOD) and SEH.
//
// #pragma warning( disable : 4509 )

// Forwarding macro:
// Calls through the interface - assumes a member variable pThis of the correct type.
// Exceptions are logged (in HandleException), and a failure code returned.
#define EXCEPT_FORWARD( fname, c, params )  /**/ \
    HRESULT STDMETHODCALLTYPE fname AS_DECL( c, params ) \
    {\
        __try {\
            return m_pThis-> fname AS_CALL( c, params ) ;\
        }\
        __except( HandleException( GetExceptionCode(), TEXT( # fname ) ), EXCEPTION_EXECUTE_HANDLER ) {\
            return E_FAIL;\
        }\
    }


// This class acts as a 'holder' for the class that actually does the forwarding.
// Template parameter I is the original interface being wrapped, template parameter
// W is the wrapping/forwarding interface.
// This class just takes care of basic 'smart pointer' housekeeping - assignment,
// operator->, etc.
//
// Assumes that the wrapper class will have an accessible member pThis of type I*.

template < class I, class W >
class SEHWrapPtr
{
    W   m_SEHWrap;
public:

    SEHWrapPtr( I * pThis )
    {
        m_SEHWrap.m_pThis = pThis;
    }

    operator I * ( )
    {
        return m_SEHWrap.m_pThis;
    }

    W * operator -> () 
    {
        return & m_SEHWrap;
    }

    operator & ()
    {
        return & m_SEHWrap.m_pThis;
    }

    void operator = ( I * pI )
    {
        m_SEHWrap.m_pThis = pI;
    }
};


// SEH Wrapper for IUnknown. Other SEH wrappers that wrap COM interfaces derive from this.

template < class I >
struct SEHWrap_IUnknown
{
public:
    I * m_pThis;

    EXCEPT_FORWARD( AddRef,                     0,  ( ) )
    EXCEPT_FORWARD( Release,                    0,  ( ) )
    EXCEPT_FORWARD( QueryInterface,             2,  ( REFIID, riid, void **, ppv ) )
};


// This wrapper wraps methods which are common to ITextStoreACP and ITextStoreAnchor.
// Derived classes add in the ACP- and Anchor- specific methods.

template < class DocTraits >
struct SEHWrap_TextStoreBase : public SEHWrap_IUnknown < typename DocTraits::IDoc >
{
public:

    EXCEPT_FORWARD( AdviseSink,                 3,  ( REFIID, riid, IUnknown *, punk, DWORD, dwMask ) )
    EXCEPT_FORWARD( UnadviseSink,               1,  ( IUnknown *, punk ) )
    EXCEPT_FORWARD( RequestLock,                2,  ( DWORD, dwLockFlags, HRESULT *, phrSession ) )

    EXCEPT_FORWARD( GetStatus,                  1,  ( TS_STATUS *,               pdcs ) )

    EXCEPT_FORWARD( QueryInsert,              	5,  ( typename DocTraits::PosType,       InsertStart,
    						      					  typename DocTraits::PosType,       InsertEnd,
    												  ULONG,					cch,
                                                      typename DocTraits::PosType *,     ppaInsertStart,
                                                      typename DocTraits::PosType *,     ppaInsertEnd ) )

    EXCEPT_FORWARD( QueryInsertEmbedded,		3,	( const GUID *,				pguidService,
													  const FORMATETC *,		pFormatEtc,
													  BOOL *,					pfInsertable ) )
       
        
    EXCEPT_FORWARD( GetScreenExt,               2,  ( TsViewCookie,				vcView,
    												  RECT *,                   prc ) )

    EXCEPT_FORWARD( GetWnd,                     2,  ( TsViewCookie, 			vcView,
													  HWND *,                   phwnd ) )

    EXCEPT_FORWARD( GetFormattedText,           3,  ( typename DocTraits::PosType,	Start,
                                                      typename DocTraits::PosType,	End,
                                                      IDataObject **,			ppDataObject ) )

    EXCEPT_FORWARD( GetTextExt,                 5,  ( TsViewCookie,				vcView,
												      typename DocTraits::PosType,       Start,
                                                      typename DocTraits::PosType,       End,
                                                      RECT *,                   prc,
                                                      BOOL *,                   pfClipped ) )

    EXCEPT_FORWARD( RequestSupportedAttrs,          3,  ( DWORD,                    dwFlags,
													  ULONG, 					cFilterAttrs,
													  const TS_ATTRID *,			paFilterAttrs ) )

    EXCEPT_FORWARD( RequestAttrsAtPosition,         4,  ( typename DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,         paFilterAttrs,
                                                      DWORD,                    dwFlags ) )

    EXCEPT_FORWARD( RequestAttrsTransitioningAtPosition,
                                                4,  ( typename DocTraits::PosType,       Pos,
                                                      ULONG,                    cFilterAttrs,
                                                      const TS_ATTRID *,         paFilterAttrs,
                                                      DWORD,                    dwFlags ) )

    EXCEPT_FORWARD( RetrieveRequestedAttrs,     3,  ( ULONG,                    ulCount,
                                                      TS_ATTRVAL *,              paAttrVals,
                                                      ULONG *,                  pcFetched ) )


    EXCEPT_FORWARD( GetActiveView,				1,  ( TsViewCookie *,			pvcView ) )

/*
    EXCEPT_FORWARDEXT( ScrollToRect,            4,  ( DocTraits::PosType,       Start,
                                                      DocTraits::PosType,       End,
                                                      RECT,                     rc,
                                                      DWORD,                    dwPosition ) )
*/
};


struct SEHWrap_TextStoreACP : public SEHWrap_TextStoreBase< BasicDocTraitsACP >
{
    EXCEPT_FORWARD( GetSelection,               4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ACP *, pSelection, ULONG *, pcFetched ) )
    EXCEPT_FORWARD( GetText,                    9, ( LONG, acpStart, LONG, acpEnd, WCHAR *, pchPlain, ULONG, cchPlainReq, ULONG *, pcchPlainRet, TS_RUNINFO *, prgRunInfo, ULONG, cRunInfoReq, ULONG *, pcRunInfoRet, LONG *, pacpNext ) )
    EXCEPT_FORWARD( GetEmbedded,                4,  ( LONG, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    EXCEPT_FORWARD( GetEndACP,                  1,  ( LONG *, pacp ) )
    EXCEPT_FORWARD( GetACPFromPoint,            4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, LONG *, pacp ) )
    EXCEPT_FORWARD( FindNextAttrTransition,     8,  ( LONG, acpStart, LONG, acpEnd, ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, LONG *, pacpNext, BOOL *, pfFound, LONG *, plFoundOffset ) )
    EXCEPT_FORWARD( SetSelection,               2,  ( ULONG, ulCount, const TS_SELECTION_ACP *, pSelection ) )
    EXCEPT_FORWARD( SetText,                    6,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, const WCHAR *, pchText, ULONG, cch, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertEmbedded,             5,  ( DWORD, dwFlags, LONG, acpStart, LONG, acpEnd, IDataObject *, pDataObject, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertTextAtSelection,		6,  ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange ) )
    EXCEPT_FORWARD( InsertEmbeddedAtSelection,	5,  ( DWORD, dwFlags, IDataObject *, pDataObject, LONG *, pacpStart, LONG *, pacpEnd, TS_TEXTCHANGE *, pChange ) )
};


struct SEHWrap_TextStoreAnchor : public SEHWrap_TextStoreBase< BasicDocTraitsAnchor >
{
    EXCEPT_FORWARD( GetSelection,               4,  ( ULONG, ulIndex, ULONG, ulCount, TS_SELECTION_ANCHOR *, pSelection, ULONG *, pcFetched ) )
    EXCEPT_FORWARD( GetText,                    7,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, WCHAR *, pchText, ULONG, cchReq, ULONG *, pcch, BOOL, fUpdateAnchor ) )
    EXCEPT_FORWARD( GetEmbedded,                5,  ( DWORD, dwFlags, IAnchor *, Pos, REFGUID, rguidService, REFIID, riid, IUnknown **, ppunk ) )
    EXCEPT_FORWARD( GetStart,                   1,  ( IAnchor **, ppaStart ) )
    EXCEPT_FORWARD( GetEnd,                     1,  ( IAnchor **, ppaEnd ) )
    EXCEPT_FORWARD( GetAnchorFromPoint,         4,  ( TsViewCookie, vcView, const POINT *, ptScreen, DWORD, dwFlags, IAnchor **, ppaSite ) )
    EXCEPT_FORWARD( FindNextAttrTransition,     7,  ( IAnchor *, paStart, IAnchor *, paEnd,  ULONG, cFilterAttrs, const TS_ATTRID *, paFilterAttrs, DWORD, dwFlags, BOOL *, pfFound, LONG *, plFoundOffset ) )
    EXCEPT_FORWARD( SetSelection,               2,  ( ULONG, ulCount, const TS_SELECTION_ANCHOR *, pSelection ) )
    EXCEPT_FORWARD( SetText,                    5,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, const WCHAR *, pchText, ULONG, cch ) )
    EXCEPT_FORWARD( InsertEmbedded,             4,  ( DWORD, dwFlags, IAnchor *, paStart, IAnchor *, paEnd, IDataObject *, pDataObject ) )
    EXCEPT_FORWARD( InsertTextAtSelection,		5,  ( DWORD, dwFlags, const WCHAR *, pchText, ULONG, cch,  IAnchor **, ppaStart, IAnchor **, ppaEnd ) )
    EXCEPT_FORWARD( InsertEmbeddedAtSelection,	4,  ( DWORD, dwFlags, IDataObject *, pDataObject,  IAnchor **, ppaStart, IAnchor **, ppaEnd ) )
};


// Finally, put the wrapper classes together with the holder classes to create 'smart pointer'-like
// SEH wrappers:
typedef SEHWrapPtr< ITextStoreACP, SEHWrap_TextStoreACP > SEHWrapPtr_TextStoreACP;
typedef SEHWrapPtr< ITextStoreAnchor, SEHWrap_TextStoreAnchor > SEHWrapPtr_TextStoreAnchor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaaadapter.h ===
// MSAAAdapter.h : Declaration of the CAccServerDocMgr

#ifndef __MSAAADAPTER_H_
#define __MSAAADAPTER_H_

#include "resource.h"       // main symbols
#include <list_dl.h>

/////////////////////////////////////////////////////////////////////////////
// CAccServerDocMgr

struct ITextStoreAnchor; // fwd. decl.
struct IAccStore; // fwd. decl.

class ATL_NO_VTABLE CAccServerDocMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccServerDocMgr, &CLSID_AccServerDocMgr>,
	public IAccServerDocMgr
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_ACCSERVERDOCMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccServerDocMgr)
	COM_INTERFACE_ENTRY(IAccServerDocMgr)
END_COM_MAP()



    CAccServerDocMgr();
    ~CAccServerDocMgr();

    // IAccServerDocMgr

    HRESULT STDMETHODCALLTYPE NewDocument ( 
        REFIID		riid,
		IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE RevokeDocument (
        IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE OnDocumentFocus (
        IUnknown *	punk
	);


private:
    
    struct DocAssoc: public Link_dl< DocAssoc >
    {
        IUnknown *          m_pdocOrig;     // original doc interface
        IUnknown *          m_pdocAnchor;   // wrapped anchor

        // How are pdocOrig and pdocAnchor related? 
        //
        // pdocOrig is the canonical IUnknown of the original doc ptr passed in to NewDocument.
        //
        // pdocAnchor is a wrapped version of the original doc ptr passed in.
        //
        // - if the original doc is ACP, an ACP->Anchor wrap layer is applied.
        //     (this shouldn't be used much, since Cicero hand us pre-wrapped IAnchor interfaces.)
        //
        // - if the original doc doesn't support multiple clients (via IClonableWrapper),
        //     a multi-client wrap layer is applied.
        //
        // If the passed in anchor supports IAnchor and IClonableWrapper (which is the
        // usual case when we get a doc from Cicero - it does the ACP wrapping, and uses
        // the DocWrap to allow it to share it with MSAA), then no further wrapping will
        // be applied.
    };

    List_dl< DocAssoc >     m_Docs;

    IAccStore *            m_pAccStore;
};

#endif //__MSAAADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaaclientadapter.h ===
// MSAAClientAdapter.h : Declaration of the CAccClientDocMgr

#ifndef __MSAACLIENTADAPTER_H_
#define __MSAACLIENTADAPTER_H_

#include "resource.h"       // main symbols
/////////////////////////////////////////////////////////////////////////////
// CAccClientDocMgr
class ATL_NO_VTABLE CAccClientDocMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccClientDocMgr, &CLSID_AccClientDocMgr>,
	public IAccClientDocMgr
{
public:
	CAccClientDocMgr();
	~CAccClientDocMgr();

DECLARE_REGISTRY_RESOURCEID(IDR_ACCCLIENTDOCMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccClientDocMgr)
	COM_INTERFACE_ENTRY(IAccClientDocMgr)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
        bool fInit = false;
        HANDLE hInit = OpenEvent( SYNCHRONIZE, FALSE, TEXT("MSAA_STORE_EVENT") );
        if ( hInit )
        {
            fInit = true;
            CloseHandle( hInit );
        }

		HRESULT hr = CoCreateInstance( CLSID_AccStore, NULL, CLSCTX_LOCAL_SERVER, IID_IAccStore, (void **) & m_pAccStore );

        // if this Event does not exist then the store is being created for the first time
        // so lets wait a little bit to let the store settle down.
        if ( !hInit )
            Sleep (500);

		return hr;
	}

// IAccClientDocMgr
public:

	HRESULT STDMETHODCALLTYPE GetDocuments (
		IEnumUnknown ** enumUnknown
	);

	HRESULT STDMETHODCALLTYPE LookupByHWND (
		HWND		hWnd,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE LookupByPoint (
		POINT		pt,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE GetFocused (
		REFIID	riid,
		IUnknown **	ppunk
	);

private:

	IAccStore * m_pAccStore;
};

#endif //__MSAACLIENTADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaaclientadapter.cpp ===
// MSAAClientAdapter.cpp : Implementation of AccClientDocMgr
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAClientAdapter.h"
#include "MSAAStore.h"


/////////////////////////////////////////////////////////////////////////////
// AccClientDocMgr

CAccClientDocMgr::CAccClientDocMgr()
{
    IMETHOD( CAccClientDocMgr );
}


CAccClientDocMgr::~CAccClientDocMgr()
{
    IMETHOD( ~CAccClientDocMgr );
	m_pAccStore->Release();
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::GetDocuments (
	IEnumUnknown ** enumUnknown
)
{
    IMETHOD( GetDocuments );
	return m_pAccStore->GetDocuments( enumUnknown );
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::LookupByHWND (
	HWND		hWnd,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );
	return m_pAccStore->LookupByHWND( hWnd, riid, ppunk );
}


HRESULT STDMETHODCALLTYPE CAccClientDocMgr::LookupByPoint (
	POINT		pt,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByPoint );
	return m_pAccStore->LookupByPoint( pt, riid, ppunk );
}

HRESULT STDMETHODCALLTYPE CAccClientDocMgr::GetFocused (
	REFIID	riid,
	IUnknown **	ppunk
)
{
    IMETHOD( GetFocused );
	return m_pAccStore->GetFocused( riid, ppunk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaastore.h ===
// MSAAStore.h : Declaration of the CAccStore

#ifndef __MSAASTORE_H_
#define __MSAASTORE_H_

#include "resource.h"       // main symbols
#include <list>

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )
// These allow us to compile with the pre-Win64 SDK (eg. using visual studio)
typedef unsigned long UINT_PTR;
typedef DWORD DWORD_PTR;
typedef BOOL BOOL_PTR;
#define PtrToInt  (int)
#else
typedef INT_PTR BOOL_PTR;

#endif



struct DocInfo
{
    DocInfo(IUnknown * pCanonicalUnk, ITextStoreAnchor * pDoc, IClonableWrapper * pClonableWrapper) : 
    		m_pCanonicalUnk(pCanonicalUnk), m_pDoc(pDoc), m_pClonableWrapper(pClonableWrapper)
    { 
		if ( FAILED( m_pDoc->GetWnd( NULL, &m_hWnd ) ) )
			m_hWnd = NULL;
	}

    ~DocInfo()
    {
		if (m_pCanonicalUnk)
			m_pCanonicalUnk->Release();
		if (m_pDoc)
			m_pDoc->Release();
		if (m_pClonableWrapper)
			m_pClonableWrapper->Release();
    }

    struct predCanonicalUnk 
	{
		predCanonicalUnk (const IUnknown *& punk) : m_punk(punk) { }
		bool operator ()(const DocInfo* d) 
		{ 
			return d->m_pCanonicalUnk == m_punk; 
		};
		const IUnknown *& m_punk;
	};

    struct predHWND
	{
		predHWND (const HWND &hwnd ) : m_hWnd(hwnd) { }
		bool operator ()(const DocInfo* d) 
		{ 
			if( m_hWnd == d->m_hWnd )
				return true;
			else
				return false;
		}
		const HWND &m_hWnd;
	};

	IUnknown *          m_pCanonicalUnk;    
	ITextStoreAnchor *  m_pDoc;             
	IClonableWrapper *  m_pClonableWrapper; 
	HWND                m_hWnd;
};

typedef std::list< DocInfo * > DocList;

//  this is my own copy class so I don't have to duplicate the list
template <class T>
class CopyDocs
{
public:
	static HRESULT copy(T** p1, DocInfo** p2)
	{
		*p1 = static_cast<T *>((*p2)->m_pDoc);
		if (*p1)
			(*p1)->AddRef();

		TraceDebug(TEXT("copy"));
		return S_OK;
	}
	static void init(T** ) 
	{ 
		TraceDebug(TEXT("init")); 
	}
	static void destroy(T** p) 
	{
		if (*p) (*p)->Release();  
		TraceDebug(TEXT("destroy"));
	}
};

typedef CComObject< CComEnumOnSTL< IEnumUnknown, &IID_IEnumUnknown, IUnknown *, CopyDocs<IUnknown>, DocList > > EnumDocs;

template <class T>
class CComDllClassFactorySingleton : public CComClassFactorySingleton<T>
{
public :
	void FinalRelease()
	{
	}
};


/////////////////////////////////////////////////////////////////////////////
// CAccStore
class ATL_NO_VTABLE CAccStore : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAccStore, &CLSID_AccStore>,
	public IAccStore
{
public:
	CAccStore();
	~CAccStore();

DECLARE_CLASSFACTORY_EX(CComDllClassFactorySingleton<CAccStore>)

DECLARE_REGISTRY_RESOURCEID(IDR_MSAASTORE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccStore)
	COM_INTERFACE_ENTRY(IAccStore)
END_COM_MAP()

// IAccStore
public:

	HRESULT STDMETHODCALLTYPE Register (
		REFIID		riid,
		IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE Unregister (
		IUnknown *	punk
	);


	HRESULT STDMETHODCALLTYPE GetDocuments (
		IEnumUnknown ** enumUnknown
	);

	HRESULT STDMETHODCALLTYPE LookupByHWND (
		HWND		hWnd,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE LookupByPoint (
		POINT		pt,
		REFIID		riid,
		IUnknown **	ppunk
	);

	HRESULT STDMETHODCALLTYPE OnDocumentFocus (
	    IUnknown *	punk
	);

	HRESULT STDMETHODCALLTYPE GetFocused (
		REFIID	riid,
		IUnknown **	ppunk
	);

	BOOL_PTR DialogProc ( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    HWND    m_hwndDlg;
    HWND    m_hList;
	DocList m_DocList;
#ifdef DBG
	bool	m_ShowDialog;
#endif
    HANDLE  m_hInit;

	IUnknown * m_punkFocused;
    ITfMSAAControl *	m_pCtl;
    
    void        DumpInfo( DocInfo * pInfo );
    void        DumpInfo();
    DocInfo *   _LookupDoc( IUnknown * pCanonicalUnk );
    DocInfo *   _LookupDoc( HWND hWnd );
    DocInfo *   _LookupDoc( POINT pt );
	void		EraseDeadDocuments();
	void		Log( LPCTSTR text );

};

#endif //__MSAASTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaastore.cpp ===
// MSAAStore.cpp : Implementation of CAccStore
#include "stdafx.h"
#include "MSAAText.h"
#include "MSAAStore.h"

#include <windowsx.h>

#include <algorithm>
#include <stack>
using namespace std;

#include <debug.h>
#include <TSTR.h>

#define ARRAYSIZE( a )  (sizeof(a)/sizeof(a[0]))

CAccStore * m_pTheStore = NULL;

POINT ptListOffset;
POINT ptDumpOffset;
BOOL fGotSize = FALSE;


#ifdef DBG
BOOL_PTR CALLBACK DialogProc ( HWND hwndDlg,
                           UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
	return m_pTheStore->DialogProc ( hwndDlg, uMsg, wParam, lParam );
}

BOOL_PTR CAccStore::DialogProc ( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_INITDIALOG:
        {
            RECT rcWnd;
            GetClientRect( hwndDlg, & rcWnd );

            RECT rcList;
            GetWindowRect( GetDlgItem( hwndDlg, IDC_LIST ), & rcList );
            MapWindowPoints( NULL, hwndDlg, (POINT *) & rcList, 2 );
            ptListOffset.x = rcWnd.right - ( rcList.right - rcList.left );
            ptListOffset.y = rcWnd.bottom - ( rcList.bottom - rcList.top );

            RECT rcDump;
            GetWindowRect( GetDlgItem( hwndDlg, ID_DUMP ), & rcDump );
            MapWindowPoints( NULL, hwndDlg, (POINT *) & rcDump, 2 );
            ptDumpOffset.x = rcWnd.right - rcDump.left;
            ptDumpOffset.y = rcWnd.bottom - rcDump.top;

            fGotSize = TRUE;
            break;
        }

        case WM_COMMAND:
        {
            if( LOWORD( wParam ) == ID_DUMP )
            {
                Assert( m_pTheStore );
                DumpInfo();
                break;
            }
            break;
        }

        case WM_SIZE:
        {
            if( wParam != SIZE_MINIMIZED && fGotSize )
            {
                int width = LOWORD( lParam );
                int height = HIWORD( lParam );

                SetWindowPos( GetDlgItem( hwndDlg, IDC_LIST ), NULL,
                              0, 0,
                              width - ptListOffset.x, height - ptListOffset.y, SWP_NOMOVE | SWP_NOZORDER );

                SetWindowPos( GetDlgItem( hwndDlg, ID_DUMP ), NULL,
                              width - ptDumpOffset.x, height - ptDumpOffset.y,
                              0, 0,
                              SWP_NOSIZE | SWP_NOZORDER );
            }
            break;
        }
    }

    return FALSE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CAccStore

CAccStore::CAccStore() : m_hwndDlg(NULL), m_hList(NULL), m_punkFocused(NULL), m_pCtl(NULL), m_hInit(NULL)
{
    IMETHOD( CAccStore );

    Assert( m_pTheStore == NULL );

    m_pTheStore = this;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_MSAAControl,
                     NULL, 
                     CLSCTX_INPROC_SERVER, 
                     IID_ITfMSAAControl, 
                     (void**)&m_pCtl);
    if ( hr != S_OK )
    {
        Log( TSTR() << TEXT("CoCreateInstance failed for CLSID_MSAAControl hr=") << WriteHex(hr) );
    }
    else
    {
        hr = m_pCtl->SystemEnableMSAA();
        if ( hr != S_OK )
            Log( TSTR() << TEXT("SystemEnableMSAA failed hr=") << WriteHex(hr) );
    }

    // this lets someone in another procces se if the store is up
    m_hInit = CreateEvent( NULL, FALSE, TRUE, TEXT("MSAA_STORE_EVENT") );
    
#ifdef DBG
	CRegKey crkShowDialog;
	DWORD dwShowDialog = 0;

    if ( ( crkShowDialog.Open(HKEY_CURRENT_USER, TEXT("Control Panel\\Accessibility"), KEY_READ) == ERROR_SUCCESS ) &&
    	 ( crkShowDialog.QueryValue( dwShowDialog, TEXT("ShowDialog") ) == ERROR_SUCCESS ) &&
    	 ( dwShowDialog ) )
   	{
		m_ShowDialog = true;
	}
	else
	{
		m_ShowDialog = false;
	}
	
	if ( m_ShowDialog )
	{
		m_hwndDlg = CreateDialog( _Module.GetModuleInstance(), MAKEINTRESOURCE( IDD_MAIN ), NULL, ::DialogProc );
		m_hList = GetDlgItem( m_hwndDlg, IDC_LIST );
		Log( TEXT("*** CAccStore ctor ***") );
        if ( m_pCtl == NULL )
    		Log( TEXT("m_pCtl is null") );
	}
#endif
}


CAccStore::~CAccStore()
{
    IMETHOD( ~CAccStore );

	EraseDeadDocuments();

    if ( m_punkFocused )
        m_punkFocused->Release();

    if ( m_pCtl )
    {
        m_pCtl->SystemDisableMSAA();
        m_pCtl->Release();
    }

    if ( m_hInit ) 
        CloseHandle( m_hInit );

    m_pTheStore = NULL;
    Log( TEXT("*** CAccStore dtor ***") );

#ifdef DBG
	if ( m_ShowDialog )
	{
	    EndDialog( m_hwndDlg, TRUE );
	}
#endif
}



HRESULT STDMETHODCALLTYPE CAccStore::Register (
	REFIID		riid,
	IUnknown *	punk
)
{
    IMETHOD( Register );

	EraseDeadDocuments();

    if( riid != IID_ITextStoreAnchor )
    {
        Log( TEXT("Register - unknown IID") );
        return E_NOINTERFACE;
    }

    // Get the canonical IUnknown - we use this to compare against the interface
    // passed to Unregister.
    // Note that this is from the original interface peassed in, not a wrapped
    // version...
    IUnknown * pCanonicalUnk = NULL;
    HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr != S_OK || ! pCanonicalUnk )
    {
        Log( TEXT("QueryInterface failed") );
        return E_FAIL;
    }

    // Now check that the doc pointer is a clonable wrapper - if not,
    // wrap it using DocWrap. We need a clonable wrapper so we can hand
    // out individual 'head' interfaces to multiple clients.

    ITextStoreAnchor * pDoc = reinterpret_cast< ITextStoreAnchor * >( punk );
    pDoc->AddRef();
    
    IClonableWrapper * pClonableWrapper = NULL;
    hr = pDoc->QueryInterface( IID_IClonableWrapper, (void **) & pClonableWrapper );
    if( hr != S_OK || ! pClonableWrapper )
    {
        // Uh-oh - we were supposed to be given a doc that (a) supports IDocAnchor, and (b)
        // supports IClonableWrapper (so is usable by multiple clients).
        // return failure...
        
    	TraceDebugHR( hr, TEXT( "QueryInterface for IID_IClonableWrapper failed") );

        pDoc->Release();
        pCanonicalUnk->Release();
        return E_FAIL;
    }


	// Add info to list...
    m_DocList.push_back( new DocInfo(pCanonicalUnk, pDoc, pClonableWrapper) );

    Log( TSTR() << TEXT("Register ") << WriteHex(pCanonicalUnk) << TEXT(", ") << WriteHex(pDoc) << TEXT(", ") << WriteHex(pClonableWrapper) );

    DumpInfo( m_DocList.back() );

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::Unregister (
	IUnknown *	punk
)
{
    IMETHOD( Unregister );
    
    Log( TEXT("Unregister") );

    IUnknown * pCanonicalUnk = NULL;
    HRESULT hr = punk->QueryInterface( IID_IUnknown, (void **) & pCanonicalUnk );
    if( hr != S_OK || ! pCanonicalUnk )
    {
        return E_FAIL;
    }

	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predCanonicalUnk(pCanonicalUnk) );
	if ( it != m_DocList.end() )
	{
	    DocInfo * pDocInfo = *it;

#ifdef DBG
        if ( m_ShowDialog )
            DumpInfo( pDocInfo );
#endif

        m_DocList.erase( it );
        delete pDocInfo;
    }
    else
    {
        Log( TSTR() << TEXT("Unregister of ") << WriteHex(pCanonicalUnk) << TEXT(" failed canonical unknown not found"));
    }

    pCanonicalUnk->Release();

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::GetDocuments (
	IEnumUnknown ** enumUnknown
)
{
	EraseDeadDocuments();

	EnumDocs * EnumDocuments = new EnumDocs;

	EnumDocuments->Init(NULL, m_DocList);

	HRESULT hr = EnumDocuments->QueryInterface(IID_IEnumUnknown, (void **)enumUnknown);

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CAccStore::LookupByHWND (
	HWND		hWnd,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );

    Log( TEXT("LookupByHWND") );

    *ppunk = NULL;
    DocInfo * pInfo = _LookupDoc( hWnd );
    if( ! pInfo )
        return E_FAIL;

    return pInfo->m_pClonableWrapper->CloneNewWrapper( riid, (void **) ppunk );
}


HRESULT STDMETHODCALLTYPE CAccStore::LookupByPoint (
	POINT		pt,
	REFIID		riid,
	IUnknown **	ppunk
)
{
    IMETHOD( LookupByHWND );

    Log( TEXT("LookupByPoint") );

    *ppunk = NULL;
    DocInfo * pInfo = _LookupDoc( pt );
    if( ! pInfo )
        return E_FAIL;

    return pInfo->m_pClonableWrapper->CloneNewWrapper( riid, (void **) ppunk );
}

HRESULT STDMETHODCALLTYPE CAccStore::OnDocumentFocus (
    IUnknown *	punk
)
{
    IMETHOD( OnDocumentFocus );

    if ( m_punkFocused )
        m_punkFocused->Release();
        
   	m_punkFocused = punk;
   	
    if ( m_punkFocused )
    	m_punkFocused->AddRef();

	Log( TSTR() << TEXT("OnDocumentFocus ") << WriteHex(punk) );

#ifdef DBG
	if ( m_ShowDialog )
    {
	    if ( punk )
	    {
		    ITextStoreAnchor * pITextStoreAnchor;
	        HRESULT hr = punk->QueryInterface( IID_ITextStoreAnchor, (void **) &pITextStoreAnchor );
	        Log( TSTR() << TEXT("QueryInterface for IID_ITextStoreAnchor hr=") << WriteHex(hr) << TEXT(" pITextStoreAnchor=") << pITextStoreAnchor );
#if(WINVER>=0x0500)
		    HWND hwnd;
		    TCHAR szWindowText[128];

            pITextStoreAnchor->GetWnd( NULL, & hwnd );
		    Log( TSTR() << TEXT("hwnd for focused doc is ") << WriteHex(hwnd) );
		    GetWindowText( GetAncestor( hwnd, GA_ROOT ), szWindowText, ARRAYSIZE( szWindowText ) );
	        Log( TSTR() << TEXT("OnDocumentFocus succeded for ") << szWindowText );
#endif
		    pITextStoreAnchor->Release();
	    }
    }	
#endif

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CAccStore::GetFocused (
	REFIID	riid,
	IUnknown **	ppunk
)
{
    IMETHOD( GetFocused );
    
    if( ! m_punkFocused )
    {
        *ppunk = NULL;
    	Log( TEXT("No document has focus") );
        return S_OK;
    }
    else
    {
		HRESULT hr;
		hr = m_punkFocused->QueryInterface( riid, (void **)ppunk );
		if ( hr != S_OK )
		{
			TraceDebugHR( hr, TSTR() << TEXT( "QueryInterface failed for ") << riid );
			return hr;
		}
        return S_OK;
    }
}



void CAccStore::DumpInfo( DocInfo * pInfo )
{
#ifdef DBG
    RECT rc = {-1,-1,-1,-1};
    HRESULT hr = pInfo->m_pDoc->GetScreenExt( NULL, & rc );

	TsViewCookie vcView;
	pInfo->m_pDoc->GetActiveView( &vcView );

    HWND hwnd = NULL;
    if( pInfo->m_pDoc->GetWnd( vcView, & hwnd ) != S_OK )
        hwnd = NULL;
    
    TCHAR str[128];
    if( hr == S_OK )
    {
        wsprintf( str, TEXT("Doc {%d,%d,%d,%d} 0x%08lX punk(0x%08lX)"), rc.left, rc.top, rc.right, rc.bottom, hwnd, pInfo->m_pCanonicalUnk );
    }
    else
    {
        wsprintf( str, TEXT("Doc {GetScreenExt failed: 0x%08lX} 0x%08lX punk(0x%08lX)"), hr, hwnd, pInfo->m_pCanonicalUnk );
    }

    Log( str );
#endif
}


void CAccStore::DumpInfo()
{
#ifdef DBG
    Log( TEXT("Dumping...") );
    EraseDeadDocuments();

    for( DocList::iterator i = m_DocList.begin(); i != m_DocList.end(); i++ )
    {
        DumpInfo( *i );
    }
#endif
}





DocInfo * CAccStore::_LookupDoc( IUnknown * pCanonicalUnk )
{
	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predCanonicalUnk(pCanonicalUnk) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

DocInfo * CAccStore::_LookupDoc( HWND hWnd )
{
	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predHWND(hWnd) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

DocInfo * CAccStore::_LookupDoc( POINT pt )
{
    HWND hWnd = WindowFromPoint( pt );

	DocList::iterator it = find_if( m_DocList.begin(), m_DocList.end(), DocInfo::predHWND(hWnd) );
	if ( it != m_DocList.end() )
		return *it;

    return NULL;
}

void CAccStore::EraseDeadDocuments()
{
	// get rid of any docs that are not here any more
	
    const int cDocList = m_DocList.size();
    int i = 1;
    for ( DocList::iterator it = m_DocList.begin(); it != m_DocList.end(); i++ )
	{
		TS_STATUS tsStatus;
		DocList::iterator DocToErase = it;

		it++;
		
		const DocInfo& di = **DocToErase;
		if ( di.m_pDoc->GetStatus( &tsStatus ) != S_OK )
		{
			m_DocList.erase( DocToErase );
	        Log( TEXT("Dead document erased") );
			TraceDebug( TEXT("Dead document erased") );
		}

        // make sure the list is OK 
        if ( i > cDocList )
        {
            Log( TEXT( "Doc list is invalid" ) );
            _ASSERT( 0 );
        }
	}
	

	return;
}

void CAccStore::Log( LPCTSTR text )
{
#ifdef DBG
	if ( m_ShowDialog )
	{
		ListBox_AddString( m_hList, text );
	}
#endif
}

/*
int CAccStore::_GetText( ITextStoreAnchor * pDoc, WCHAR * pText, DWORD cchText )
{
    HRESULT hr = pDoc->RequestLock( DCLT_READ );
    if( hr != S_OK || dcr != DC_OK )
    {
        Log( TEXT("RequestLock failed") );
        return 0;
    }

    IAnchor * paStart = NULL;
    hr = pDoc->GetStart( & paStart, & dcr );
    if( hr != S_OK || paStart == NULL )
    {
        pDoc->ReleaseLock();
        Log( TEXT("GetStart failed") );
        return 0;
    }

    DWORD cchGot = 0;
    hr = pDoc->GetText( paStart, NULL, pText, cchText, & cchGot, FALSE, & dcr );
    paStart->Release();
    pDoc->ReleaseLock();

    if( hr != S_OK || dcr != S_OK )
    {
        Log( TEXT("GetText failed") );
        return 0;
    }

    return cchGot;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\msaatext.cpp ===
// MSAAText.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for MSAAText.idl by adding the following 
//      files to the Outputs.
//          MSAAText_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSAATextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSAAText.h"
#include "dlldatax.h"

#include "MSAAStore.h"
#include "MSAAAdapter.h"
#include "MSAAClientAdapter.h"
#include "Dict.h"
#include "DocWrap.h"
#include <TextStor.h>
#include <msctfx.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AccStore, CAccStore)
OBJECT_ENTRY(CLSID_AccServerDocMgr, CAccServerDocMgr)
OBJECT_ENTRY(CLSID_AccClientDocMgr, CAccClientDocMgr)
OBJECT_ENTRY(CLSID_AccDictionary, CDict)
OBJECT_ENTRY(CLSID_DocWrap, CDocWrap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSAATEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSAAText.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSAASTORE                   101
#define IDR_ACCSERVERDOCMGR				102
#define IDR_MSAADICT					103
#define IDR_DOCWRAP						104
#define IDR_ACCCLIENTDOCMGR				105
#define IDD_MAIN                        201
#define IDC_LIST                        201
#define ID_DUMP                         202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED_)
#define AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

#include <assert.h>
#include "debug.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AB799976_2AD7_4B25_9490_75001E06B1C8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\tsattrs.h ===
/*
 *
 *  Copyright (C) Microsoft Corporation, 1999-2000
 *
 *  File: tsattrs.h
 *
 *  List of ITextStore standard attributes.
 *
 */
#ifndef _TSATTRS_H_
#define _TSATTRS_H_




DEFINE_GUID(TSATTRID_OTHERS,                            0xb3c32af9,0x57d0,0x46a9,0xbc,0xa8,0xda,0xc2,0x38,0xa1,0x30,0x57);

DEFINE_GUID(TSATTRID_Font,                              0x573ea825,0x749b,0x4f8a,0x9c,0xfd,0x21,0xc3,0x60,0x5c,0xa8,0x28);
DEFINE_GUID(TSATTRID_Font_FaceName,                     0xb536aeb6,0x053b,0x4eb8,0xb6,0x5a,0x50,0xda,0x1e,0x81,0xe7,0x2e);
DEFINE_GUID(TSATTRID_Font_SizePts,                      0xc8493302,0xa5e9,0x456d,0xaf,0x04,0x80,0x05,0xe4,0x13,0x0f,0x03);
DEFINE_GUID(TSATTRID_Font_Style,                        0x68b2a77f,0x6b0e,0x4f28,0x81,0x77,0x57,0x1c,0x2f,0x3a,0x42,0xb1);
DEFINE_GUID(TSATTRID_Font_Style_Bold,                   0x48813a43,0x8a20,0x4940,0x8e,0x58,0x97,0x82,0x3f,0x7b,0x26,0x8a);
DEFINE_GUID(TSATTRID_Font_Style_Italic,                 0x8740682a,0xa765,0x48e1,0xac,0xfc,0xd2,0x22,0x22,0xb2,0xf8,0x10);
DEFINE_GUID(TSATTRID_Font_Style_SmallCaps,              0xfacb6bc6,0x9100,0x4cc6,0xb9,0x69,0x11,0xee,0xa4,0x5a,0x86,0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Capitalize,				0x7d85a3ba, 0xb4fd, 0x43b3, 0xbe, 0xfc, 0x6b, 0x98, 0x5c, 0x84, 0x31, 0x41);
DEFINE_GUID(TSATTRID_Font_Style_Uppercase,				0x33a300e8, 0xe340, 0x4937, 0xb6, 0x97, 0x8f, 0x23, 0x40, 0x45, 0xcd, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Lowercase,				0x76d8ccb5, 0xca7b, 0x4498, 0x8e, 0xe9, 0xd5, 0xc4, 0xf6, 0xf7, 0x4c, 0x60);
DEFINE_GUID(TSATTRID_Font_Style_Animation,				0xdcf73d22, 0xe029, 0x47b7, 0xbb, 0x36, 0xf2, 0x63, 0xa3, 0xd0, 0x04, 0xcc);
DEFINE_GUID(TSATTRID_Font_Style_Animation_LasVegasLights,0xf40423d5, 0xf87, 0x4f8f, 0xba, 0xda, 0xe6, 0xd6, 0xc, 0x25, 0xe1, 0x52);
DEFINE_GUID(TSATTRID_Font_Style_Animation_BlinkingBackground,0x86e5b104, 0x0104, 0x4b10, 0xb5, 0x85, 0x00, 0xf2, 0x52, 0x75, 0x22, 0xb5);
DEFINE_GUID(TSATTRID_Font_Style_Animation_SparkleText,	0x533aad20, 0x962c, 0x4e9f, 0x8c, 0x09, 0xb4, 0x2e, 0xa4, 0x74, 0x97, 0x11);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingBlackAnts, 0x7644e067, 0xf186, 0x4902, 0xbf, 0xc6, 0xec, 0x81, 0x5a, 0xa2, 0x0e, 0x9d);
DEFINE_GUID(TSATTRID_Font_Style_Animation_MarchingRedAnts, 0x78368dad, 0x50fb, 0x4c6f, 0x84, 0x0b, 0xd4, 0x86, 0xbb, 0x6c, 0xf7, 0x81);
DEFINE_GUID(TSATTRID_Font_Style_Animation_Shimmer,		0x2ce31b58, 0x5293, 0x4c36, 0x88, 0x09, 0xbf, 0x8b, 0xb5, 0x1a, 0x27, 0xb3);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeDown,		0x5872e874, 0x367b, 0x4803, 0xb1, 0x60, 0xc9, 0x0f, 0xf6, 0x25, 0x69, 0xd0);
DEFINE_GUID(TSATTRID_Font_Style_Animation_WipeRight,	0xb855cbe3, 0x3d2c, 0x4600, 0xb1, 0xe9, 0xe1, 0xc9, 0xce, 0x02, 0xf8, 0x42);
DEFINE_GUID(TSATTRID_Font_Style_Emboss,					0xbd8ed742, 0x349e, 0x4e37, 0x82, 0xfb, 0x43, 0x79, 0x79, 0xcb, 0x53, 0xa7);
DEFINE_GUID(TSATTRID_Font_Style_Engrave,				0x9c3371de, 0x8332, 0x4897, 0xbe, 0x5d, 0x89, 0x23, 0x32, 0x23, 0x17, 0x9a);
DEFINE_GUID(TSATTRID_Font_Style_Hidden,					0xb1e28770, 0x881c, 0x475f, 0x86, 0x3f, 0x88, 0x7a, 0x64, 0x7b, 0x10, 0x90);
DEFINE_GUID(TSATTRID_Font_Style_Kerning,				0xcc26e1b4, 0x2f9a, 0x47c8, 0x8b, 0xff, 0xbf, 0x1e, 0xb7, 0xcc, 0xe0, 0xdd);
DEFINE_GUID(TSATTRID_Font_Style_Outlined,				0x10e6db31, 0xdb0d, 0x4ac6, 0xa7, 0xf5, 0x9c, 0x9c, 0xff, 0x6f, 0x2a, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Position,				0x15cd26ab, 0xf2fb, 0x4062, 0xb5, 0xa6, 0x9a, 0x49, 0xe1, 0xa5, 0xcc, 0x0b);
DEFINE_GUID(TSATTRID_Font_Style_Protected,				0x1c557cb2, 0x14cf, 0x4554, 0xa5, 0x74, 0xec, 0xb2, 0xf7, 0xe7, 0xef, 0xd4);
DEFINE_GUID(TSATTRID_Font_Style_Shadow,					0x5f686d2f, 0xc6cd, 0x4c56, 0x8a, 0x1a, 0x99, 0x4a, 0x4b, 0x97, 0x66, 0xbe);
DEFINE_GUID(TSATTRID_Font_Style_Spacing,				0x98c1200d, 0x8f06, 0x409a, 0x8e, 0x49, 0x6a, 0x55, 0x4b, 0xf7, 0xc1, 0x53);
DEFINE_GUID(TSATTRID_Font_Style_Weight,					0x12f3189c, 0x8bb0, 0x461b, 0xb1, 0xfa, 0xea, 0xf9, 0x07, 0x04, 0x7f, 0xe0);
DEFINE_GUID(TSATTRID_Font_Style_Height,					0x7e937477, 0x12e6, 0x458b, 0x92, 0x6a, 0x1f, 0xa4, 0x4e, 0xe8, 0xf3, 0x91);
DEFINE_GUID(TSATTRID_Font_Style_Underline,              0xc3c9c9f3,0x7902,0x444b,0x9a,0x7b,0x48,0xe7,0x0f,0x4b,0x50,0xf7);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Single,       0x1b6720e5,0x0f73,0x4951,0xa6,0xb3,0x6f,0x19,0xe4,0x3c,0x94,0x61);
DEFINE_GUID(TSATTRID_Font_Style_Underline_Double,       0x74d24aa6, 0x1db3, 0x4c69, 0xa1, 0x76, 0x31, 0x12, 0x0e, 0x75, 0x86, 0xd5);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough,          0x0c562193,0x2d08,0x4668,0x96,0x01,0xce,0xd4,0x13,0x09,0xd7,0xaf);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Single,   0x75d736b6,0x3c8f,0x4b97,0xab,0x78,0x18,0x77,0xcb,0x99,0x0d,0x31);
DEFINE_GUID(TSATTRID_Font_Style_Strikethrough_Double,   0x62489b31, 0xa3e7, 0x4f94, 0xac, 0x43, 0xeb, 0xaf, 0x8f, 0xcc, 0x7a, 0x9f);
DEFINE_GUID(TSATTRID_Font_Style_Overline,               0xe3989f4a,0x992b,0x4301,0x8c,0xe1,0xa5,0xb7,0xc6,0xd1,0xf3,0xc8);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Single,        0x8440d94c,0x51ce,0x47b2,0x8d,0x4c,0x15,0x75,0x1e,0x5f,0x72,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_Overline_Double,        0xdc46063a, 0xe115, 0x46e3, 0xbc, 0xd8, 0xca, 0x67, 0x72, 0xaa, 0x95, 0xb4);
DEFINE_GUID(TSATTRID_Font_Style_Blink,         		    0xbfb2c036, 0x7acf, 0x4532, 0xb7, 0x20, 0xb4, 0x16, 0xdd, 0x77, 0x65, 0xa8);
DEFINE_GUID(TSATTRID_Font_Style_Subscript,              0x5774fb84,0x389b,0x43bc,0xa7,0x4b,0x15,0x68,0x34,0x7c,0xf0,0xf4);
DEFINE_GUID(TSATTRID_Font_Style_Superscript,            0x2ea4993c,0x563c,0x49aa,0x93,0x72,0x0b,0xef,0x09,0xa9,0x25,0x5b);
DEFINE_GUID(TSATTRID_Font_Style_Color,                  0x857a7a37,0xb8af,0x4e9a,0x81,0xb4,0xac,0xf7,0x00,0xc8,0x41,0x1b);
DEFINE_GUID(TSATTRID_Font_Style_BackgroundColor,		0xb50eaa4e, 0x3091, 0x4468, 0x81, 0xdb, 0xd7, 0x9e, 0xa1, 0x90, 0xc7, 0xc7);

DEFINE_GUID(TSATTRID_Text,              				0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_VerticalWriting,              0x6bba8195,0x046f,0x4ea9,0xb3,0x11,0x97,0xfd,0x66,0xc4,0x27,0x4b);
DEFINE_GUID(TSATTRID_Text_RightToLeft,                  0xca666e71,0x1b08,0x453d,0xbf,0xdd,0x28,0xe0,0x8c,0x8a,0xaf,0x7a);
DEFINE_GUID(TSATTRID_Text_Orientation,                  0x6bab707f,0x8785,0x4c39,0x8b,0x52,0x96,0xf8,0x78,0x30,0x3f,0xfb);
DEFINE_GUID(TSATTRID_Text_Language,                     0xd8c04ef1,0x5753,0x4c25,0x88,0x87,0x85,0x44,0x3f,0xe5,0xf8,0x19);
DEFINE_GUID(TSATTRID_Text_ReadOnly,                     0x85836617,0xde32,0x4afd,0xa5,0x0f,0xa2,0xdb,0x11,0x0e,0x6e,0x4d);
DEFINE_GUID(TSATTRID_Text_EmbeddedObject,               0x7edb8e68, 0x81f9, 0x449d, 0xa1, 0x5a, 0x87, 0xa8, 0x38, 0x8f, 0xaa, 0xc0);
DEFINE_GUID(TSATTRID_Text_Alignment,               		0x139941e6, 0x1767, 0x456d, 0x93, 0x8e, 0x35, 0xba, 0x56, 0x8b, 0x5c, 0xd4);
DEFINE_GUID(TSATTRID_Text_Alignment_Left,          		0x16ae95d3, 0x6361, 0x43a2, 0x84, 0x95, 0xd0, 0x0f, 0x39, 0x7f, 0x16, 0x93);
DEFINE_GUID(TSATTRID_Text_Alignment_Right,        		0xb36f0f98, 0x1b9e, 0x4360, 0x86, 0x16, 0x03, 0xfb, 0x08, 0xa7, 0x84, 0x56);
DEFINE_GUID(TSATTRID_Text_Alignment_Center,        		0xa4a95c16, 0x53bf, 0x4d55, 0x8b, 0x87, 0x4b, 0xdd, 0x8d, 0x42, 0x75, 0xfc);
DEFINE_GUID(TSATTRID_Text_Alignment_Justify,       		0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Link,               			0x47cd9051, 0x3722, 0x4cd8, 0xb7, 0xc8, 0x4e, 0x17, 0xca, 0x17, 0x59, 0xf5);
DEFINE_GUID(TSATTRID_Text_Hyphenation,               	0xdadf4525, 0x618e, 0x49eb, 0xb1, 0xa8, 0x3b, 0x68, 0xbd, 0x76, 0x48, 0xe3);
DEFINE_GUID(TSATTRID_Text_Para,		               		0x5edc5822, 0x99dc, 0x4dd6, 0xae, 0xc3, 0xb6, 0x2b, 0xaa, 0x5b, 0x2e, 0x7c);
DEFINE_GUID(TSATTRID_Text_Para_FirstLineIndent,         0x07c97a13, 0x7472, 0x4dd8, 0x90, 0xa9, 0x91, 0xe3, 0xd7, 0xe4, 0xf2, 0x9c);
DEFINE_GUID(TSATTRID_Text_Para_LeftIndent,              0xfb2848e9, 0x7471, 0x41c9, 0xb6, 0xb3, 0x8a, 0x14, 0x50, 0xe0, 0x18, 0x97);
DEFINE_GUID(TSATTRID_Text_Para_RightIndent,             0x2c7f26f9, 0xa5e2, 0x48da, 0xb9, 0x8a, 0x52, 0x0c, 0xb1, 0x65, 0x13, 0xbf);
DEFINE_GUID(TSATTRID_Text_Para_SpaceAfter,              0x7b0a3f55, 0x22dc, 0x425f, 0xa4, 0x11, 0x93, 0xda, 0x1d, 0x8f, 0x9b, 0xaa);
DEFINE_GUID(TSATTRID_Text_Para_SpaceBefore,             0x8df98589, 0x194a, 0x4601, 0xb2, 0x51, 0x98, 0x65, 0xa3, 0xe9, 0x06, 0xdd);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing,             0x699b380d, 0x7f8c, 0x46d6, 0xa7, 0x3b, 0xdf, 0xe3, 0xd1, 0x53, 0x8d, 0xf3);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Single,   	0xed350740, 0xa0f7, 0x42d3, 0x8e, 0xa8, 0xf8, 0x1b, 0x64, 0x88, 0xfa, 0xf0);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_OnePtFive,	0x0428a021, 0x0397, 0x4b57, 0x9a, 0x17, 0x07, 0x95, 0x99, 0x4c, 0xd3, 0xc5);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Double,  	0x82fb1805, 0xa6c4, 0x4231, 0xac, 0x12, 0x62, 0x60, 0xaf, 0x2a, 0xba, 0x28);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_AtLeast, 	0xadfedf31, 0x2d44, 0x4434, 0xa5, 0xff, 0x7f, 0x4c, 0x49, 0x90, 0xa9, 0x05);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Exactly, 	0x3d45ad40, 0x23de, 0x48d7, 0xa6, 0xb3, 0x76, 0x54, 0x20, 0xc6, 0x20, 0xcc);
DEFINE_GUID(TSATTRID_Text_Para_LineSpacing_Multiple, 	0x910f1e3c, 0xd6d0, 0x4f65, 0x8a, 0x3c, 0x42, 0xb4, 0xb3, 0x18, 0x68, 0xc5);

DEFINE_GUID(TSATTRID_List,                              0x436d673b, 0x26f1, 0x4aee, 0x9e, 0x65, 0x8f, 0x83, 0xa4, 0xed, 0x48, 0x84);
DEFINE_GUID(TSATTRID_List_LevelIndel,            		0x7f7cc899, 0x311f, 0x487b, 0xad, 0x5d, 0xe2, 0xa4, 0x59, 0xe1, 0x2d, 0x42);
DEFINE_GUID(TSATTRID_List_Type,             			0xae3e665e, 0x4bce, 0x49e3, 0xa0, 0xfe, 0x2d, 0xb4, 0x7d, 0x3a, 0x17, 0xae);
DEFINE_GUID(TSATTRID_List_Type_Bullet,        			0xbccd77c5, 0x4c4d, 0x4ce2, 0xb1, 0x02, 0x55, 0x9f, 0x3b, 0x2b, 0xfc, 0xea);
DEFINE_GUID(TSATTRID_List_Type_Arabic,        			0x1338c5d6, 0x98a3, 0x4fa3, 0x9b, 0xd1, 0x7a, 0x60, 0xee, 0xf8, 0xe9, 0xe0);
DEFINE_GUID(TSATTRID_List_Type_LowerLetter,    			0x96372285, 0xf3cf, 0x491e, 0xa9, 0x25, 0x38, 0x32, 0x34, 0x7f, 0xd2, 0x37);
DEFINE_GUID(TSATTRID_List_Type_UpperLetter,             0x7987b7cd, 0xce52, 0x428b, 0x9b, 0x95, 0xa3, 0x57, 0xf6, 0xf1, 0x0c, 0x45);
DEFINE_GUID(TSATTRID_List_Type_LowerRoman,             	0x90466262, 0x3980, 0x4b8e, 0x93, 0x68, 0x91, 0x8b, 0xd1, 0x21, 0x8a, 0x41);
DEFINE_GUID(TSATTRID_List_Type_UpperRoman,          	0x0f6ab552, 0x4a80, 0x467f, 0xb2, 0xf1, 0x12, 0x7e, 0x2a, 0xa3, 0xba, 0x9e);

DEFINE_GUID(TSATTRID_App,                               0xa80f77df,0x4237,0x40e5,0x84,0x9c,0xb5,0xfa,0x51,0xc1,0x3a,0xc7);
DEFINE_GUID(TSATTRID_App_IncorrectSpelling,             0xf42de43c,0xef12,0x430d,0x94,0x4c,0x9a,0x08,0x97,0x0a,0x25,0xd2);
DEFINE_GUID(TSATTRID_App_IncorrectGrammar,              0xbd54e398,0xad03,0x4b74,0xb6,0xb3,0x5e,0xdb,0x19,0x99,0x63,0x88);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\msaatext\versioninfo.h ===
#include <vector>


class ATL_NO_VTABLE CVersionInfo : public IVersionInfo
{

public:

	class Info
	{
		Info () : 
			m_Implid(GUID_NULL), 
			m_MajorVer(0), 
			m_MinorVer(0), 
			m_cComponents(0), 
			m_ComponentDescription(NULL), 
			m_InstanceDescription(NULL),
			m_punk(NULL) { }
			
		Info (GUID Implid, DWORD MajorVer, DWORD MinorVer, LPCWSTR ComponentDescription, LPCWSTR InstanceDescription, IUnknown * punk) :
				m_Implid(Implid), 
				m_MajorVer(MajorVer), 
				m_MinorVer(MinorVer), 
				m_cComponents(0), 
				m_punk(punk)
		{
			m_ComponentDescription = SysAllocString( ComponentDescription ); 
			m_InstanceDescription = SysAllocString( InstanceDescription ); 
		}

		~Info()
		{
			SysFreeString( m_ComponentDescription );
			SysFreeString( m_InstanceDescription );
		}

	private:

		friend CVersionInfo;
		GUID m_Implid;
		DWORD m_MajorVer;
		DWORD m_MinorVer;
		BSTR m_ComponentDescription;
		BSTR m_InstanceDescription;
		ULONG m_cComponents;
		IUnknown * m_punk;
		
	};

public:
	CVersionInfo() { };
	~CVersionInfo()
	{ 
		for ( int i = 0; i < m_VersionInfos.size(); i++ )
		{
			delete m_VersionInfos[i];
		}
	};

	void Add(GUID Implid, DWORD MajorVer, DWORD MinorVer, LPCWSTR ComponentDescription, LPCWSTR InstanceDescription, IUnknown * punk)
	{
		Info * pInfo = new Info( Implid, MajorVer, MinorVer, ComponentDescription, InstanceDescription, punk );
		BuildVersionInfos( *pInfo );
		m_VersionInfos[0]->m_cComponents = m_VersionInfos.size() - 1;
	}
	
	STDMETHOD(GetSubcomponentCount)( ULONG ulSub, ULONG *ulCount )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		if (m_VersionInfos.empty())
			*ulCount = 0;
		else
			*ulCount = m_VersionInfos[ulSub]->m_cComponents;

	    return S_OK;
	}

	STDMETHOD(GetImplementationID)( ULONG ulSub, GUID * implid )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		*implid = m_VersionInfos[ulSub]->m_Implid;
	    return S_OK;
	}

	STDMETHOD(GetBuildVersion)( ULONG ulSub, DWORD * pdwMajor, DWORD * pdwMinor)
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;

		*pdwMajor = m_VersionInfos[ulSub]->m_MajorVer;
		*pdwMinor = m_VersionInfos[ulSub]->m_MinorVer;
	    return S_OK;
	}

	// Expect string of the form "Company suite component version"
	// for human consumption only - not expected to be parsed.
	STDMETHOD(GetComponentDescription)( ULONG ulSub, BSTR * pImplStr )
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;
			
		*pImplStr = SysAllocString( m_VersionInfos[ulSub]->m_ComponentDescription );
	    return S_OK;
	}

	// Implementation can put any useful string here. (eg. internal object state)
	STDMETHOD(GetInstanceDescription)( ULONG ulSub, BSTR * pImplStr)
	{
		if (ulSub > m_VersionInfos.size())
			return E_INVALIDARG;
			
		*pImplStr = SysAllocString( m_VersionInfos[ulSub]->m_InstanceDescription );
	    return S_OK;
	}

private:

	void BuildVersionInfos( Info& info )
	{
		IUnknown * punk = NULL;
		IVersionInfo * pIVer = NULL;
		HRESULT hr;

		m_VersionInfos.push_back(&info);
		
		if (!info.m_punk)
			return;
			
		hr = info.m_punk->QueryInterface( IID_IVersionInfo, (void **)&pIVer );
		if (hr != S_OK || pIVer == NULL)
			return;

		ULONG cCount = 0;
		pIVer->GetSubcomponentCount( 0, &cCount );
		if ( cCount )
		{
			info.m_cComponents = cCount;
			for ( int i = 1; i <= cCount; i++ )
			{
				
				Info * pInfo = new Info;
				
				pIVer->GetImplementationID( i, &pInfo->m_Implid );
				pIVer->GetBuildVersion( i, &pInfo->m_MajorVer, &pInfo->m_MinorVer );
				pIVer->GetComponentDescription( i, &pInfo->m_ComponentDescription );
				pIVer->GetInstanceDescription( i,&pInfo->m_InstanceDescription );
				BuildVersionInfos( *pInfo );
			}
		}
		pIVer->Release();
	}

private:
	std::vector < Info *> m_VersionInfos;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\accutil.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  accutil
//
//  IAccessible proxy helper routines
//
// --------------------------------------------------------------------------


HRESULT GetWindowObject( HWND ihwndChild, VARIANT* lpvar );

HRESULT GetNoncObject( HWND hwndFrame, LONG idObject, VARIANT * lpvar );

HRESULT GetParentToNavigate( long, HWND, long, long, VARIANT* );




//
// Validate and initialization macros
//
        
BOOL ValidateNavDir(long lFlags, long idChild);
BOOL ValidateSelFlags(long flags);

#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define ValidateRange(lValue, lMin, lMax)   (((lValue) > (lMin)) && ((lValue) < (lMax)))

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\accutil.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  accutil
//
//  IAccessible proxy helper routines
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
//#include "accutil.h" // already in oleacc_p.h


// --------------------------------------------------------------------------
//
//  GetWindowObject
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    HRESULT hr;
    IDispatch * pdispChild;

    pvar->vt = VT_EMPTY;

    pdispChild = NULL;

    hr = AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (! pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  GetNoncObject
//
// --------------------------------------------------------------------------
HRESULT GetNoncObject(HWND hwnd, LONG idFrameEl, VARIANT *pvar)
{
    IDispatch * pdispEl;
    HRESULT hr;

    pvar->vt = VT_EMPTY;

    pdispEl = NULL;

    hr = AccessibleObjectFromWindow(hwnd, idFrameEl, IID_IDispatch,
        (void **)&pdispEl);
    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispEl)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispEl;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  GetParentToNavigate()
//
//  Gets the parent IAccessible object, and forwards the navigation request
//  to it using the child's ID.
//
// --------------------------------------------------------------------------
HRESULT GetParentToNavigate(long idChild, HWND hwnd, long idParent, long dwNav,
    VARIANT* pvarEnd)
{
    HRESULT hr;
    IAccessible* poleacc;
    VARIANT varStart;

    //
    // Get our parent
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwnd, idParent, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    //
    // Ask it to navigate
    //
    VariantInit(&varStart);
    varStart.vt = VT_I4;
    varStart.lVal = idChild;

    hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

    //
    // Release our parent
    //
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  ValidateNavDir
//
//  Validates navigation flags.
//
// --------------------------------------------------------------------------
BOOL ValidateNavDir(long navDir, LONG idChild)
{
	
#ifdef MAX_DEBUG
    DBPRINTF (TEXT("Navigate "));
	switch (navDir)
	{
        case NAVDIR_RIGHT:
            DBPRINTF(TEXT("Right"));
			break;
        case NAVDIR_NEXT:
            DBPRINTF (TEXT("Next"));
			break;
        case NAVDIR_LEFT:
            DBPRINTF (TEXT("Left"));
			break;
        case NAVDIR_PREVIOUS:
            DBPRINTF (TEXT("Previous"));
			break;
        case NAVDIR_UP:
            DBPRINTF (TEXT("Up"));
			break;
        case NAVDIR_DOWN:
            DBPRINTF (TEXT("Down"));
			break;
		case NAVDIR_FIRSTCHILD:
            DBPRINTF (TEXT("First Child"));
			break;
		case NAVDIR_LASTCHILD:
            DBPRINTF (TEXT("Last Child"));
			break;
		default:
            DBPRINTF (TEXT("ERROR"));
	}
    if (idChild <= OBJID_WINDOW)
    {
    TCHAR szChild[50];

        switch (idChild)
        {
            case OBJID_WINDOW:
                lstrcpy (szChild,TEXT("SELF"));
                break;
            case OBJID_SYSMENU:
                lstrcpy (szChild,TEXT("SYS MENU"));
                break;
            case OBJID_TITLEBAR:
                lstrcpy (szChild,TEXT("TITLE BAR"));
                break;
            case OBJID_MENU:
                lstrcpy (szChild,TEXT("MENU"));
                break;
            case OBJID_CLIENT:
                lstrcpy (szChild,TEXT("CLIENT"));
                break;
            case OBJID_VSCROLL:
                lstrcpy (szChild,TEXT("V SCROLL"));
                break;
            case OBJID_HSCROLL:
                lstrcpy (szChild,TEXT("H SCROLL"));
                break;
            case OBJID_SIZEGRIP:
                lstrcpy (szChild,TEXT("SIZE GRIP"));
                break;
            default:
                wsprintf (szChild,TEXT("UNKNOWN 0x%lX"),idChild);
                break;
        }
        DBPRINTF(TEXT(" from child %s\r\n"),szChild);
    }
    else
        DBPRINTF(TEXT(" from child %ld\r\n"),idChild);
#endif

    if ((navDir <= NAVDIR_MIN) || (navDir >= NAVDIR_MAX))
        return(FALSE);

    switch (navDir)
    {
        case NAVDIR_FIRSTCHILD:
        case NAVDIR_LASTCHILD:
            return(idChild == 0);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\alttab.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ALTTAB.CPP
//
//  Switch window handler
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "alttab.h"



// --------------------------------------------------------------------------
//
//  CreateSwitchClient()
//
// --------------------------------------------------------------------------
HRESULT CreateSwitchClient(HWND hwnd, long idChild, REFIID riid, void** ppvSwitch)
{
    CAltTab* palttab;
    HRESULT hr;

    InitPv(ppvSwitch);

    palttab = new CAltTab(hwnd, idChild);
    if (!palttab)
        return(E_OUTOFMEMORY);

    hr = palttab->QueryInterface(riid, ppvSwitch);
    if (!SUCCEEDED(hr))
        delete palttab;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAltTab::CAltTab()
//
//  NOTE:  We initialize with the # of items at the start, not every time
//  someone makes a call.  People should never hang on to a pointer to one
//  of these babies.  On NT, the switch window is created and destroyed
//  repeatedly.
//
// --------------------------------------------------------------------------
CAltTab::CAltTab(HWND hwnd, long idChildCur)
    : CClient( CLASS_SwitchClient )
{
    ALTTABINFO  ati;

    Initialize(hwnd, idChildCur);

    if (MyGetAltTabInfo(hwnd, -1, &ati, NULL, 0))
    {
        m_cChildren = ati.cItems;
        m_cColumns = ati.cColumns;
        m_cRows = ati.cRows;
    }
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(HrCreateString(STR_ALTTAB_NAME, pszName));
    else
    {
        ALTTABINFO  ati;
        TCHAR   szItem[80];

        if (!MyGetAltTabInfo(m_hwnd, varChild.lVal-1, &ati, szItem,
            ARRAYSIZE(szItem)))
            return(S_FALSE);

        *pszName = TCharSysAllocString(szItem);
        if (! *pszName)
            return(E_OUTOFMEMORY);
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    ALTTABINFO  ati;

    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    // Get the item, is this the one with the focus?
    pvarState->vt = VT_I4;

    varChild.lVal--;

    if (! MyGetAltTabInfo(m_hwnd, varChild.lVal, &ati, NULL, 0))
        pvarState->lVal = STATE_SYSTEM_INVISIBLE;
    else
    {
        pvarState->lVal = 0;

        // If this item is off the end, pretend that it's 'clipped'.
        if( varChild.lVal >= ati.cColumns * ati.cRows )
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;


        if (((varChild.lVal % ati.cColumns) == ati.iColFocus) &&
            ((varChild.lVal / ati.cColumns) == ati.iRowFocus))
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accFocus(VARIANT * pvarFocus)
{
    ALTTABINFO  ati;

    InitPvar(pvarFocus);

    //
    // Get the alt-tab info
    //
    if (!MyGetAltTabInfo(m_hwnd, -1, &ati, NULL, 0))
        return(S_FALSE);

    pvarFocus->vt = VT_I4;
    pvarFocus->lVal = (ati.iRowFocus * m_cColumns) + ati.iColFocus + 1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::get_accDefaultAction()
//
//  The default action of a tasklist item is to switch to its window
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefA));

    return(HrCreateString(STR_TAB_SWITCH, pszDefA));
}



// --------------------------------------------------------------------------
//
//  CAltTab::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accSelect(long lSelFlags, VARIANT varChild)
{
    if (! ValidateChild(&varChild) ||
        ! ValidateSelFlags(lSelFlags))
        return(E_INVALIDARG);

    //
    // Bogus!  Manually change the focus in the alt-tab window.
    //
    return(E_NOTIMPL);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    ALTTABINFO  ati;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    --varChild.lVal;

    //
    // Figure out where the item is.
    //
    if (! MyGetAltTabInfo(m_hwnd, varChild.lVal, &ati, NULL, 0))
        return(S_FALSE);

    ClientToScreen(m_hwnd, &ati.ptStart);

    *pxLeft = ati.ptStart.x + ((varChild.lVal % m_cColumns)*ati.cxItem);
    *pyTop = ati.ptStart.y + ((varChild.lVal / m_cColumns)*ati.cyItem);

    *pcxWidth = ati.cxItem;
    *pcyHeight = ati.cyItem;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    int         iItem;
    int         delta;

    InitPvar(pvarEnd);

    //
    // Validate
    //
    if (!ValidateChild(&varStart)    ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    iItem = 0;

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        iItem = 1;
    else if (dwNavDir == NAVDIR_LASTCHILD)
        iItem = m_cChildren;
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
    else
    {
        switch (dwNavDir)
        {
            case NAVDIR_NEXT:
                iItem = varStart.lVal+1;
                if (iItem > m_cChildren)
                    iItem = 0;
                break;

            case NAVDIR_PREVIOUS:
                iItem = varStart.lVal - 1;
                break;

            case NAVDIR_LEFT:
                delta = -1;
                goto MultiColumnMove;

            case NAVDIR_RIGHT:
                delta = 1;
                goto MultiColumnMove;

            case NAVDIR_UP:
                delta = -m_cColumns;
                goto MultiColumnMove;

            case NAVDIR_DOWN:
                delta = m_cColumns;

MultiColumnMove:
                iItem = varStart.lVal + delta;
                if ((iItem < 1) || (iItem > m_cChildren))
                    iItem = 0;
                break;
        }
    }

    if (iItem)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = iItem;
    }

    return(iItem ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accHitTest(long x, long y, VARIANT* pvarHit)
{
    ALTTABINFO  ati;
    RECT        rc;
    POINT       pt;
    int         iColHit, iRowHit;

    InitPvar(pvarHit);

    if (!MyGetAltTabInfo(m_hwnd, -1, &ati, NULL, 0))
        return(S_FALSE);

    //
    // Is the point in our client at all?
    //
    MyGetRect(m_hwnd, &rc, FALSE);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    if (!PtInRect(&rc, pt) ||
        (pt.x < ati.ptStart.x)   ||
        (pt.y < ati.ptStart.y))
        return(S_FALSE);

    //
    // Does this lie in an item?
    //
    iColHit = (pt.x - ati.ptStart.x) / ati.cxItem;
    iRowHit = (pt.y - ati.ptStart.y) / ati.cyItem;
    if ((iColHit >= m_cColumns) ||
        (iRowHit >= m_cRows))
        return(S_FALSE);

    //
    // Phew.  Return it.
    //
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (iRowHit * m_cColumns) + iColHit + 1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAltTab::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAltTab::accDoDefaultAction(VARIANT varChild)
{
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\alttab.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ALTTAB.H
//
//  Switch window handler
//
// --------------------------------------------------------------------------


class CAltTab : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        CAltTab(HWND, long);

    protected:
        int     m_cColumns;
        int     m_cRows;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\animated.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ANIMATED.CPP
//
//  Wrapper for COMCTL32's animation control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "animated.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOPROGRESS
#include <commctrl.h>



// --------------------------------------------------------------------------
//
//  CreateAnimatedClient()
//
// --------------------------------------------------------------------------
HRESULT CreateAnimatedClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvAnimation)
{
    CAnimation* panimated;
    HRESULT     hr;

    InitPv(ppvAnimation);

    panimated = new CAnimation(hwnd, idChildCur);
    if (!panimated)
        return(E_OUTOFMEMORY);

    hr = panimated->QueryInterface(riid, ppvAnimation);
    if (!SUCCEEDED(hr))
        delete panimated;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAnimation::CAnimation()
//
// --------------------------------------------------------------------------
CAnimation::CAnimation(HWND hwnd, long idCurChild)
    : CClient( CLASS_SwitchClient )
{
    Initialize(hwnd, idCurChild);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CAnimation::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAnimation::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_ANIMATION;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAnimation::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAnimation::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    HRESULT hr;

    // Get the client's state and add on STATE_SYSTEM_ANIMATED
    // Remove STATE_SYSTEM_FOCUSABLE
    hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return(hr);

    Assert(pvarState->vt == VT_I4);
    pvarState->lVal &= ~STATE_SYSTEM_FOCUSABLE;
    // BOGUS! no way to tell if it is actually animated or not,
    // so we just say it is always. 
    pvarState->lVal |= STATE_SYSTEM_ANIMATED;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\api.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// ==========================================================================
// File: A P I . C P P
// 
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
// ==========================================================================

// Includes --------------------------------------------------------------
#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "verdefs.h"
#include "Win64Helper.h"
#include "w95trace.h"


#define CCH_ROLESTATEMAX     128

#ifndef WMOBJ_SAMETHREAD
#define WMOBJ_SAMETHREAD  0xFFFFFFFF
#endif

HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject);

STDAPI
ORIGINAL_AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);

HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv );

STDAPI
AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
    HRESULT hr = ORIGINAL_AccessibleObjectFromWindow(hwnd, dwId, riid, ppvObject);
    if( hr == S_OK && ppvObject && *ppvObject )
    {
        // Only wrap object if it supports IAccessible.
        // Some users of AOFW may want something other than an IAccessible -
        // eg some native OM interface - shouldn't wrap those. 
        IUnknown * punk = (IUnknown *) * ppvObject;

        IAccessible * pAcc = NULL;

        hr = punk->QueryInterface( IID_IAccessible, (void **) & pAcc );
        if( hr != S_OK || pAcc == NULL )
        {
            // Not an IAccessible - don't wrap, leave as-is...
            return S_OK;
        }
        pAcc->Release();

        // It's really an IAccessible - wrap the object...

        hr = WrapObject( punk, riid, ppvObject );
        punk->Release();
    }

    return hr;
}



// --------------------------------------------------------------------------
//
//  AccessibleObjectFromWindow()
//
//  This gets an interface pointer from the object specified by dwId inside
//  of the window.
//
//  ALL object creation takes place through this API, even for internally
//  used objects. Client-side wrapping takes place here.
//
// --------------------------------------------------------------------------
STDAPI
ORIGINAL_AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
DWORD_PTR    ref;
WPARAM      wParam = 0;

    if (IsBadWritePtr(ppvObject,sizeof(void*)))
        return (E_INVALIDARG);

    // clear out-param
    *ppvObject = NULL;
    ref = 0;

    //
    // Window can be NULL (cursor, alert, sound)
    // Window can also be bad (trying to talk to window that generated event and
    // client is getting events out of context, and window is gone)
    //
    if (IsWindow(hwnd))
    {
        if( GetWindowThreadProcessId( hwnd, NULL) == GetCurrentThreadId() )
        {
            wParam = WMOBJ_SAMETHREAD;
        }
        else
        {
            wParam = GetCurrentProcessId();
            // If, by some chance, this process's pid equals the magic 'samethread' value,
            // then fall back on the less efficient '0' technique instead.
            // (see oleacc.doc for more details...)
            if( wParam == WMOBJ_SAMETHREAD )
                wParam = 0;
        }

        SendMessageTimeout(hwnd, WM_GETOBJECT, wParam, dwId,
            SMTO_ABORTIFHUNG, 10000, &ref);

    }


    if (FAILED((HRESULT)ref))
        return (HRESULT)ref;
    else if (ref)
        return ObjectFromLresult(ref, riid, wParam, ppvObject);
    else
    {
        //
        // Is this the ID of an object we understand and a REFIID we can
        // handle?  BOGUS!  For now, we always create the object and QI
        // on it, only to fail if the riid isn't one we know.  
        //

        //-----------------------------------------------------------------
        // [v-jaycl, 5/15/97] Handle custom OBJIDs -- TODO: UNTESTED!!!
        //-----------------------------------------------------------------

//        if (fCreateDefObjs && ((LONG)dwId <= 0))
        if (fCreateDefObjs )
        {
            return CreateStdAccessibleObject(hwnd, dwId, riid, ppvObject);
        }
        
        return(E_FAIL);
    }
}


// --------------------------------------------------------------------------
//
//  GetRoleTextA()
//
//  Loads the string for the specified role.  If the role is bogus, we will
//  get nothing since the role area is at the end of the string table.  We
//  return the number of chars of the string.
//  
//  CWO: 12/3/96, we now return 0 if the string ptr passed in was bogus
//
//  The caller can pass in a NULL buffer, in which case we just return the
//  # of chars so that he can turn around and allocate something the right
//  size.
//
// --------------------------------------------------------------------------
#ifdef UNICODE
STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax)
#else
STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax)
#endif
{
    TCHAR    szRoleT[CCH_ROLESTATEMAX];

    // NULL string is valid, use our temporary string and return count
    if (!lpszRole)
    {
        lpszRole = szRoleT;
        cchRoleMax = CCH_ROLESTATEMAX;
    }
    else
    {
        // CWO: Added 12/3/96, Error checking of parameters
        if (IsBadWritePtr(lpszRole,(sizeof(TCHAR) * cchRoleMax)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    
    if( cchRoleMax == 1 )
    {
        // Special case for 1-len string - we expect it to copy nothing, but
        // NUL-terminate (for consistency with other cases) - but LoadString
        // just returns 0 w/o terminating...
        *lpszRole = '\0';
        return 0;
    }
    else
        return LoadString(hinstResDll, STR_ROLEFIRST+lRole, lpszRole, cchRoleMax);
}


// --------------------------------------------------------------------------
//
//  GetStateTextA()
//
//  Loads the string for ONE particular state bit.  We return the number of
//  characters in the string.
//
//  CWO: 12/3/96, we now return 0 if the string ptr passed in was bogus
//  CWO, 12/4/96, Added parameter checking and set last error to 
//                ERROR_INVALID_PARAMETER.
//
//  Like GetRoleTextA(), the caller can pass in a NULL buffer.  We will 
//  simply return the character count necessary in that case.
//
// --------------------------------------------------------------------------
#ifdef UNICODE
STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchStateMax)
#else
STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchStateMax)
#endif
{
    TCHAR   szStateT[CCH_ROLESTATEMAX];
    int     iStateBit;

    //
    // Figure out what state bit this is.
    //
    iStateBit = 0;
    while (lStateBit > 0)
    {
        lStateBit >>= 1;
        iStateBit++;
    }

    // NULL string is valid, use our temporary string and return count
    if (!lpszState)
    {
        lpszState = szStateT;
        cchStateMax = CCH_ROLESTATEMAX;
    }
    else
    {
        // CWO: Added 12/3/96, Error checking of parameters
        if (IsBadWritePtr(lpszState,(sizeof(TCHAR) * cchStateMax)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    if( cchStateMax == 1 )
    {
        // Special case for 1-len string - we expect it to copy nothing, but
        // NUL-terminate (for consistency with other cases) - but LoadString
        // just returns 0 w/o terminating...
        *lpszState = '\0';
        return 0;
    }
    else
        return LoadString(hinstResDll, STR_STATEFIRST+iStateBit, lpszState, cchStateMax);
}




// --------------------------------------------------------------------------
//
//  [INTERNAL]
//  GetRoleStateTextWCommon()
//
//  Calls GetRoleTextA or GetStateTextA (passed in through pfnGetRoleStateANSI
//  parameter), and converts resulting string to UNICODE.
//
//  Ensures that...
//  (1) return value equals number of chars copied, excluding terminating NUL.
//  (2) if buffer is too small, as much of string as possible will be
//      copied (truncation occurs).
//  (2) terminating NUL added, even when trucation occurs.
//
//  Eg. buffer of size 4 used when getting text for 'default'...
//  Buffer will contain  'def\0' (in unicode),
//  return value of 3, since 3 chars (excl. NUL) copied.
//
//  This ensures comsistency with the 'A' versions of GetXText().
//
//  (Note that MultiByteToWideChar is not a particularly boundary-case-
//  friendly API - if the buffer is too short, it doesn't truncate neatly -
//  it *does not* add a terminating NUL, and returns 0! - so it's effectively
//  all-or-nothing, with no way of getting partial strings, for piecemeal
//  conversion, for example. To get around this, we use MBtoWC to translate
//  into a stack allocated buf of CCH_ROLEMAX, and then copy as necessary
//  from that to the output string, terminating/truncating neatly.)
//
// --------------------------------------------------------------------------

typedef UINT (WINAPI FN_GetRoleOrStateTextT)( DWORD lVal, LPTSTR lpszText, UINT cchTextMax );


#ifdef UNICODE

STDAPI_(UINT) GetRoleStateTextACommon( FN_GetRoleOrStateTextT * pfnGetRoleStateThisCS,
                                       DWORD lVal, 
                                       LPSTR lpszTextOtherCS,
                                       UINT cchTextMax)
#else

STDAPI_(UINT) GetRoleStateTextWCommon( FN_GetRoleOrStateTextT * pfnGetRoleStateThisCS,
                                       DWORD lVal, 
                                       LPWSTR lpszTextOtherCS,
                                       UINT cchTextMax)

#endif
{
    TCHAR szTextThisCS[ CCH_ROLESTATEMAX ];
    if( pfnGetRoleStateThisCS( lVal, szTextThisCS, CCH_ROLESTATEMAX ) == 0 )
        return 0;

    // Note - cchPropLen includes the terminating nul...
#ifdef UNICODE
    CHAR szTextOtherCS[ CCH_ROLESTATEMAX ];
    int cchPropLen = WideCharToMultiByte( CP_ACP, 0, szTextThisCS, -1, szTextOtherCS, CCH_ROLESTATEMAX, NULL, NULL );
#else
    WCHAR szTextOtherCS[ CCH_ROLESTATEMAX ];
    int cchPropLen = MultiByteToWideChar( CP_ACP, 0, szTextThisCS, -1, szTextOtherCS, CCH_ROLESTATEMAX );
#endif

    // unexpected error...
    if( cchPropLen == 0 )
        return 0;

    // Ignore terminating NUL in length...
    cchPropLen--;

    // lpszRole == NULL means just return length...
    if( ! lpszTextOtherCS )
        return cchPropLen; // (number of TCHARS, not bytes)
    else
    {
        // string requested...
#ifdef UNICODE
        if( IsBadWritePtr( lpszTextOtherCS, ( sizeof(CHAR) * cchTextMax ) ) )
#else
        if( IsBadWritePtr( lpszTextOtherCS, ( sizeof(WCHAR) * cchTextMax ) ) )
#endif
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return 0;
        }

        // need space for at least terminating NUL...
        if( cchTextMax <= 0 )
        {
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return 0;
        }

        // Copy as much string as necessary (cchCopyLen excludes NUL)...
        // (-1 to reserve terminating NUL)
        int cchCopyLen = cchTextMax - 1;
        if( cchCopyLen > cchPropLen )
            cchCopyLen = cchPropLen;

#ifdef UNICODE
		// Copy/truncate the ANSI string...
		// TODO - is strncpy sufficient? Does it slice DBCS correctly?
        // +1 to add back space for terminating NUL, which lstrncpyA adds for us
		lstrcpynA( lpszTextOtherCS, szTextOtherCS, cchCopyLen + 1 );
#else
        // Since we're explicitly copying UNICODE, use of memcpy is safe...
        memcpy( lpszTextOtherCS, szTextOtherCS, cchCopyLen * sizeof( WCHAR ) );
        lpszTextOtherCS[ cchCopyLen ] = '\0';
#endif
        return cchCopyLen;
    }
}





// --------------------------------------------------------------------------
//
//  GetRoleTextW()
//
//  Like GetRoleTextA() but returns a UNICODE string.
//
//  Calls GetRoleStateTextWCommon, which just calls GetStateTextA and
//  converts the result to UNICODE.
//
// --------------------------------------------------------------------------
#ifdef UNICODE

STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax)
{
    return GetRoleStateTextACommon( GetRoleTextW, lRole, lpszRole, cchRoleMax );
}

#else

STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax)
{
    return GetRoleStateTextWCommon( GetRoleTextA, lRole, lpszRole, cchRoleMax );
}

#endif

// --------------------------------------------------------------------------
//
//  GetStateTextW()
//
//  Like GetStateTextA() but returns a UNICODE string.
//
//  Calls GetRoleStateTextWCommon, which just calls GetStateTextA and
//  converts the result to UNICODE.
//
//
// --------------------------------------------------------------------------
#ifdef UNICODE

STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchStateMax)
{
    return GetRoleStateTextACommon( GetStateTextW, lStateBit, lpszState, cchStateMax );
}

#else

STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchStateMax)
{
    return GetRoleStateTextWCommon( GetStateTextA, lStateBit, lpszState, cchStateMax );
}

#endif

// --------------------------------------------------------------------------
//
//  CreateStdAccessibleObject()
//
//  See Also: CreateStdAccessibleProxy() in default.cpp
//
//  This function takes an HWND and an OBJID.  If the OBJID is one of the
//  system reserved IDs (OBJID_WINDOW, OBJID_CURSOR, OBJID_MENU, etc.)
//  we create a default object that implements the interface whose IID we
//  ask for. This is usually IAccessible, but might also be IDispatch, IText,
//  IEnumVARIANT...
//
//  This function is used by both the AccessibleObjectFromWindow API
//  and apps that want to do a little of their own thing but let us
//  handle most of the work.
//
// --------------------------------------------------------------------------
STDAPI
CreateStdAccessibleObject(HWND hwnd, LONG idObject, REFIID riid,
    void **ppvObject)
{
    HRESULT hr;
    TCHAR   szClassName[128];
    BOOL    bFound = FALSE;

    if (IsBadWritePtr(ppvObject,sizeof(void *)))
        return (E_INVALIDARG);

    *ppvObject = NULL;

    if (!hwnd && (idObject != OBJID_CURSOR))
        return(E_FAIL);
        
    // We make an exception here for OBJID_SYSMENU and OBJID_MENU because they are bit
    // specific.  All the othe objects are bit agnostic except for OBJID_CLIENT and 
    // OBJID_WINDOW which are handled in FindAndCreateWindowClass.
    if ( idObject == OBJID_SYSMENU || idObject == OBJID_MENU )
    {
		BOOL fIsSameBitness;
		HRESULT hr = SameBitness(hwnd, &fIsSameBitness);
		if ( FAILED(hr) )
			return E_FAIL;	// this should never happen
        
		if (!fIsSameBitness)
			return CreateRemoteProxy6432( hwnd, idObject, riid, ppvObject );

        // If target window is of same bitness, fall through and create proxy locally...
    }
    
    switch(idObject)
    {
        case OBJID_SYSMENU:
            hr = CreateSysMenuBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_MENU:
            // HACK for IE4/Shell windows
            if( GetClassName (hwnd, szClassName,ARRAYSIZE(szClassName))
                && ( (0 == lstrcmp (szClassName,TEXT("IEFrame")))
                  || (0 == lstrcmp (szClassName,TEXT("CabinetWClass"))) ) )
            {
                HWND            hwndWorker;
                HWND            hwndRebar;
                HWND            hwndSysPager;
                HWND            hwndToolbar;
                VARIANT         varChild;
                VARIANT         varState;

                hwndWorker = NULL;
                while (!bFound)
                {
                    hwndWorker = FindWindowEx (hwnd,hwndWorker,TEXT("Worker"),NULL);
                    if (!hwndWorker)
                        break;

                    hwndRebar = FindWindowEx (hwndWorker,NULL,TEXT("RebarWindow32"),NULL);
                    if (!hwndRebar)
                        continue;
            
					hwndSysPager = NULL;
                    while (!bFound)
                    {
                        hwndSysPager = FindWindowEx (hwndRebar,hwndSysPager,TEXT("SysPager"),NULL);
                        if (!hwndSysPager)
                            break;
                        hwndToolbar = FindWindowEx (hwndSysPager,NULL,TEXT("ToolbarWindow32"),NULL);
                        hr = AccessibleObjectFromWindow (hwndToolbar,OBJID_MENU,
                                                         IID_IAccessible, ppvObject);
                        if (SUCCEEDED(hr))
                        {
                            varChild.vt=VT_I4;
                            varChild.lVal = CHILDID_SELF;

                            if (SUCCEEDED (((IAccessible*)*ppvObject)->get_accState(varChild,&varState)))
							{
								if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
									bFound = TRUE;
							}
                        }
						
						// If we got an IAccessible, but it's not needed here (doesn't
						// satisfy the above visibility test), then release it.
						if (!bFound && *ppvObject != NULL)
							((IAccessible*)*ppvObject)->Release ();
                    }
                }
            } // end if we are talking to an IE4/IE4 Shell window

            if (!bFound)
                hr = CreateMenuBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CLIENT:
            hr = CreateClientObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_WINDOW:
            hr = CreateWindowObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_HSCROLL:
        case OBJID_VSCROLL:
            hr = CreateScrollBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_SIZEGRIP:
            hr = CreateSizeGripObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_TITLEBAR:
            hr = CreateTitleBarObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CARET:
            hr = CreateCaretObject(hwnd, idObject, riid, ppvObject);
            break;

        case OBJID_CURSOR:
            hr = CreateCursorObject(hwnd, idObject, riid, ppvObject);
            break;

        default:
            //-----------------------------------------------------------------
            // [v-jaycl, 5/15/97] Handle custom OBJIDs -- 
            //  Second parameter to FindWindowClass() is irrelevant since 
            //  we're looking for a reg.handler, not an intrinsic window or client
            //-----------------------------------------------------------------

            return FindAndCreateWindowClass( hwnd, TRUE, CLASS_NONE,
                                           idObject, 0, riid, ppvObject );
    }

    return(hr);
}





// --------------------------------------------------------------------------
//
//  CreateStdAccessibleProxyA()
//
//  See Also: CreateStdAccessibleObject()
//
//  Similar to CreateStdAccessibleObject, but this version allows you to
//  give a classname to use to specify the type of proxy you want - 
//  eg. "Button" for a button proxy, and so on.
//
//  This function takes a class name and an OBJID.  If the OBJID is one of the
//  system reserved IDs (OBJID_WINDOW, OBJID_CURSOR, OBJID_MENU, etc.)
//  we create a default object that implements the interface whose IID we
//  ask for. This is usually IAccessible, but might also be IDispatch, IText,
//  IEnumVARIANT...
//
//
// --------------------------------------------------------------------------

#ifdef UNICODE

STDAPI
CreateStdAccessibleProxyW( HWND     hWnd,
                           LPCWSTR  pClassName, // UNICODE, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )

#else

STDAPI
CreateStdAccessibleProxyA( HWND     hWnd,
                           LPCSTR   pClassName, // ANSI, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )

#endif

{
    if( IsBadReadPtr( pClassName, sizeof(TCHAR) )
     || IsBadWritePtr( ppvObject, sizeof(void*) ) )
    {
        return E_INVALIDARG;
    }

    int RegHandlerIndex;
    CLASS_ENUM ceClass;

    // Try and find a native proxy or registered handler for this window/client...
    if( ! LookupWindowClassName( pClassName, FALSE, & ceClass, & RegHandlerIndex ) )
    {
        // Nope - fail!
        ppvObject = NULL;
        return E_FAIL;
    }

    // At this point, ceClass != CLASS_NONE means we've found a class above,
    // ceClass == CLASS_NONE means it's a registered handler class, using index
    // RegHandlerIndex...

    // Now create the object...
    if( ceClass != CLASS_NONE )
    {
        return g_ClassInfo[ ceClass ].lpfnCreate( hWnd, 0, riid, ppvObject );
    }
    else
    {
        return CreateRegisteredHandler( hWnd, idObject, RegHandlerIndex, riid, ppvObject );
    }
}



// --------------------------------------------------------------------------
//
//  CreateStdAccessibleProxyW/A()
//
//  UNICODE/ANSI wrappers for CreateStdAccessibleProxy above
//
// --------------------------------------------------------------------------

#ifdef UNICODE

STDAPI
CreateStdAccessibleProxyA( HWND     hWnd,
                           LPCSTR   pClassName, // ANSI, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )
{
    if( IsBadReadPtr( pClassName, sizeof(CHAR) ) )
        return E_INVALIDARG;

    WCHAR szClassNameW[ 256 ];

    if( ! MultiByteToWideChar( CP_ACP, 0, pClassName, -1, szClassNameW,
								ARRAYSIZE( szClassNameW ) ) )
        return E_FAIL;

    return CreateStdAccessibleProxyW( hWnd, szClassNameW, idObject, riid, ppvObject );
}

#else

STDAPI
CreateStdAccessibleProxyW( HWND     hWnd,
                           LPCWSTR  pClassName, // UNICODE, not TCHAR
                           LONG     idObject,
                           REFIID   riid,
                           void **  ppvObject )
{
    if( IsBadReadPtr( pClassName, sizeof(WCHAR) ) )
        return E_INVALIDARG;

    CHAR szClassNameA[ 256 ];

    if( ! WideCharToMultiByte( CP_ACP, 0, pClassName, -1, szClassNameA,
                    ARRAYSIZE( szClassNameA ), NULL, NULL ) )
        return E_FAIL;

    return CreateStdAccessibleProxyA( hWnd, szClassNameA, idObject, riid, ppvObject );
}

#endif



// --------------------------------------------------------------------------
//
//  AccessibleObjectFromEvent()
//
//  This takes care of getting the container and checking if the child
//  is an object in its own right.  Standard stuff that everyone would have
//  to do. Basically a wrapper that uses AccessibleObjectFromWindow and
//  then get_accChild().
//
// --------------------------------------------------------------------------
STDAPI AccessibleObjectFromEvent(HWND hwnd, DWORD dwId, DWORD dwChildId,
                                 IAccessible** ppacc, VARIANT* pvarChild)
{
HRESULT hr;
IAccessible* pacc;
IDispatch* pdispChild;
VARIANT varT;

    //CWO, 12/4/96, Added check for valid window handle
    //CWO, 12/6/96, Allow a NULL window handle
    if (IsBadWritePtr(ppacc,sizeof(void*)) || IsBadWritePtr (pvarChild,sizeof(VARIANT)) || (!IsWindow(hwnd) && hwnd != NULL))
        return (E_INVALIDARG);

    InitPv(ppacc);
    VariantInit(pvarChild);

    //
    // Try to get the object for the container
    //
    pacc = NULL;
    hr = AccessibleObjectFromWindow(hwnd, dwId, IID_IAccessible, (void**)&pacc);
    if (!SUCCEEDED(hr))
        return(hr);
    if (!pacc)
        return(E_FAIL);

    //
    // Now, is the child an object?
    //
    VariantInit(&varT);
    varT.vt = VT_I4;
    varT.lVal = dwChildId;

    pdispChild = NULL;
    hr = pacc->get_accChild(varT, &pdispChild);
    if (SUCCEEDED(hr) && pdispChild)
    {
        //
        // Yes, it is.
        //

        // Release the parent.
        pacc->Release();

        // Convert the child to an IAccessible*
        pacc = NULL;
        hr = pdispChild->QueryInterface(IID_IAccessible, (void**)&pacc);

        // Release the IDispatch* form of the child
        pdispChild->Release();

        // Did it succeed?
        if (!SUCCEEDED(hr))
            return(hr);
        if (!pacc)
            return(E_FAIL);

        // Yes.  Clear out the lVal (0 is 'container' child id)
        varT.lVal = 0;
    }

    //
    // We have something.  Return it.
    //
    *ppacc = pacc;
    VariantCopy(pvarChild, &varT);

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  AccessibleObjectFromPoint()
//
//  Walks down the OLEACC hierarchy to get the object/element that is
//  at the current screen point. Starts with AccessibleObjectFromWindow
//  using WindowFromPoint() and then uses acc_HitTest to get to the
//  innermost object.
//
// --------------------------------------------------------------------------
STDAPI AccessibleObjectFromPoint(POINT ptScreen, IAccessible **ppAcc,
                                 VARIANT * pvarChild)
{
    HRESULT hr;
    IAccessible * pAcc;
    VARIANT varChild;
    HWND    hwndPoint;

    if (IsBadWritePtr(ppAcc,sizeof(void*)) || IsBadWritePtr (pvarChild,sizeof(VARIANT)))
        return (E_INVALIDARG);
        
   
    *ppAcc = NULL;
    pvarChild->vt = VT_EMPTY;

    //
    // Is this a valid screen point?
    //
    hwndPoint = WindowFromPoint(ptScreen);
    if (!hwndPoint)
        return(E_INVALIDARG);
        
    //
    // Get the top level window of this one and work our way down.  We have
    // to do this because applications may implement Acc at an intermediate
    // level above the child window.  Our default implementation will let us
    // get there and mesh.
    //
    hwndPoint = MyGetAncestor(hwndPoint, GA_ROOT);
    if (!hwndPoint)
        return(E_FAIL);

    hr = AccessibleObjectFromWindow(hwndPoint, OBJID_WINDOW, IID_IAccessible,
        (void **)&pAcc);

    //
    // OK, now we are cooking.
    //
    while (SUCCEEDED(hr))
    {
        //
        // Get the child at this point in the container object.
        //
        VariantInit(&varChild);
        hr = pAcc->accHitTest(ptScreen.x, ptScreen.y, &varChild);
        if (!SUCCEEDED(hr))
        {
            // Uh oh, error.  This should never happen--something moved.
            pAcc->Release();
            return(hr);
        }

        //
        // Did we get back a VT_DISPATCH?  If so, there is a child object.
        // Otherwise, we have our thing (container object or child element
        // too small for object).
        //
        if (varChild.vt == VT_DISPATCH)
        {
            pAcc->Release();

            if (! varChild.pdispVal)
                return(E_POINTER);

            pAcc = NULL;
            hr = varChild.pdispVal->QueryInterface(IID_IAccessible,
                (void **)&pAcc);

            varChild.pdispVal->Release();
        }
        else if ((varChild.vt == VT_I4) || (varChild.vt == VT_EMPTY))
        {
            //
            // accHitTest should ALWAYS return an object if the child is
            // an object.  Unlike with accNavigate, where you usually
            // have to pick by-index or by_object only and intermixed means
            // get_accChild is needed.
            //
            *ppAcc = pAcc;
            VariantCopy(pvarChild, &varChild);
            return(S_OK);
        }
        else
        {
            //
            // Failure.  Shouldn't have been returned.
            //
            VariantClear(&varChild);
            pAcc->Release();
            hr = E_INVALIDARG;
        }
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  WindowFromAccessibleObject()
//
//  This walks UP the ancestor chain until we find something who responds to
//  IOleWindow().  Then we get the HWND from it.
//
// Returns E_INVALIDARG if object cannot be read or if HWND pointer is invalid
// (CWO, 12/4/96)
// --------------------------------------------------------------------------
STDAPI WindowFromAccessibleObject(IAccessible* pacc, HWND* phwnd)
{
IAccessible* paccT;
IOleWindow* polewnd;
IDispatch* pdispParent;
HRESULT     hr;

    //CWO: 12/4/96, Added check for NULL object
    //CWO: 12/13/96, Removed NULL check, replaced with IsBadReadPtr check (#10342)
    if (phwnd == NULL || IsBadWritePtr(phwnd,sizeof(HWND*)) || pacc == NULL || IsBadReadPtr(pacc, sizeof(void*)))
        return (E_INVALIDARG);

    *phwnd = NULL;
    paccT = pacc;
    hr = S_OK;

    while (paccT && SUCCEEDED(hr))
    {
        polewnd = NULL;
        hr = paccT->QueryInterface(IID_IOleWindow, (void**)&polewnd);
        if (SUCCEEDED(hr) && polewnd)
        {
            hr = polewnd->GetWindow(phwnd);
            polewnd->Release();
            //
            // Release an interface we obtained on our own, but not the one
            // passed in.
            //
            if (paccT != pacc)
            {
                paccT->Release();
                paccT = NULL;
            }
            break;
        }

        //
        // Get our parent.
        //
        pdispParent = NULL;
        hr = paccT->get_accParent(&pdispParent);

        //
        // Release an interface we obtained on our own, but not the one
        // passed in.
        //
        if (paccT != pacc)
        {
            paccT->Release();
        }

        paccT = NULL;

        if (SUCCEEDED(hr) && pdispParent)
        {
            hr = pdispParent->QueryInterface(IID_IAccessible, (void**)&paccT);
            pdispParent->Release();
        }
    }

    return(hr);
}


// --------------------------------------------------------------------------
//
//  AccessibleChildren()
//
//  This function fills in an array of VARIANTs that refer to all the chilren
//  of an IAccessible object. This should simplify many of the test 
//  applications lives, as well as lots of other people as well.
//
//  Parameters:
//      paccContainer   This is a pointer to the IAccessible interface of the
//                      container object - the one you want to get the 
//                      children of.
//      iChildStart     The INDEX (NOT ID!!!) of the first child to get. 
//                      Usually the caller will use 0 to get all the children.
//                      If the caller wants something else, they need to remember
//                      that this expects an INDEX (0 to n-1) and not an ID
//                      (1 to n, or some private ID).
//      cChildren       Count of how many children to get. Usually the
//                      caller will first call IAccessible::get_accChildCount
//                      and use that value.
//      rgvarChildren   The array of VARIANTs that will be filled in by the
//                      function. Each VARIANT can be used to get info 
//                      about the child it references. The caller should be
//                      careful if they didn't use 0 for iChildStart, because
//                      then the index of the array and the index of the 
//                      children won't match up. 
//                      Each VARIANT will be of type either VT_I4 or 
//                      VT_DISPATCH. For a VT_I4, the caller will just ask the 
//                      container for info about the child, using the 
//                      VARIANT.lVal as a child id. For a VT_DISPATCH, the 
//                      caller should do a QueryInterface on VARIANT.pdispVal 
//                      to get an IAccessible interface and then talk to the 
//                      child object directly. 
//                  *** The caller must also do a Release on any IDispatch 
//                      Interfaces, and free this array of variants when done!! ***
//      pcObtained      This value will be filled in by the function and
//                      will indicate the number of VARIANTs in the array 
//                      that were successfully filled in. May not be NULL.
//
//  Returns:
//      S_OK if the number of elements supplied is cChildren; S_FALSE if
//      it succeeded but fewer than the number of children requested was
//      returned, or if you try to skip more children than exist. 
//      Error return values are E_INAVLIDARG if rgvarChildren is not as
//      big as cChildren, or if pcObtained is not a valid pointer.
//
// --------------------------------------------------------------------------
STDAPI AccessibleChildren (IAccessible* paccContainer, LONG iChildStart, 
                           LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained)
{
HRESULT         hr;
IEnumVARIANT*   penum;
IDispatch*      pdisp;
LONG            ArrayIndex;
LONG            ChildIndex;
LONG            celtTotal;

    Assert(paccContainer);
    if ( IsBadWritePtr(paccContainer,sizeof(void*))
      || IsBadWritePtr(rgvarChildren,sizeof(VARIANT)*cChildren)
      || IsBadWritePtr(pcObtained,sizeof(LONG)))
    {
        return E_INVALIDARG;
    }

    // start by initializing the VARIANT array
    for (ArrayIndex = 0; ArrayIndex < cChildren; ArrayIndex++)
        VariantInit (&(rgvarChildren[ArrayIndex]));
  
    //
    // Try querying for IEnumVARIANT.  If that fails, use index+1 based IDs.
    //
    penum = NULL;
    hr = paccContainer->QueryInterface(IID_IEnumVARIANT, (void**)&penum);

    if (penum)
    {
        penum->Reset();
		// SMD 4/27/98 - fix 689 regression
		// if we are doing the case of getting everything (skipping 0)
		// then don't bother calling it. Fixes a problem in CClient::Skip
		// where it returned S_FALSE when skipping 0 items. Since others
		// may accidentally do this too, we'll "fix" it here to localize
		// the change
		if (iChildStart > 0)
		{
	        hr = penum->Skip(iChildStart);
			// hr should still be set to S_OK from QI call
		}
        if (hr == S_OK)
            hr = penum->Next(cChildren,rgvarChildren,(ULONG*)pcObtained);
        else
            *pcObtained = 0;

        penum->Release();
        if (FAILED(hr))
            return (hr);
    }
    else
    {
        // okay,so it doesn't support IEnumVARIANT. We'll just have to 
        // create an array of variants with sequential Child Id's.
        celtTotal = 0;
        paccContainer->get_accChildCount((LONG*)&celtTotal);

        if (iChildStart < celtTotal)
            *pcObtained = celtTotal - iChildStart;
        else
            *pcObtained = 0;

        ChildIndex = iChildStart+1;

        for (ArrayIndex = 0;ArrayIndex < *pcObtained;ArrayIndex++)
        {
            rgvarChildren[ArrayIndex].vt = VT_I4;
            rgvarChildren[ArrayIndex].lVal = ChildIndex;
            
            ChildIndex++;
        }
    } // end else - doesn't support IEnumVARIANT


    // Now that we've filled in the array of variants, let's check each
    // item to see if it is a real object or not.
    for (ArrayIndex = 0;ArrayIndex < *pcObtained;ArrayIndex++)
    {
        // check to see if this child is an IAccessible object or not
        if (rgvarChildren[ArrayIndex].vt == VT_I4)
        {
            pdisp = NULL;
            hr = paccContainer->get_accChild(rgvarChildren[ArrayIndex], &pdisp);
            if (SUCCEEDED(hr) && pdisp)
            {
                rgvarChildren[ArrayIndex].vt = VT_DISPATCH;
                rgvarChildren[ArrayIndex].pdispVal = pdisp; 
            } // end if child seems to be an object (has an IDispatch)
        } // end if child is VT_I4
    } // end for loop through 

    if (*pcObtained == cChildren)
        return(S_OK);
    else
        return (S_FALSE);
}



WORD g_VerInfo [ 4 ]= { BUILD_VERSION_INT };

STDAPI_(VOID) GetOleaccVersionInfo(DWORD* pVer, DWORD* pBuild)
{
    if ( IsBadWritePtr(pVer,sizeof(DWORD))
      || IsBadWritePtr(pBuild,sizeof(DWORD)))
    {
        return;
    }

    *pVer = MAKELONG( g_VerInfo[1], g_VerInfo[0] ); // MAKELONG(lo, hi)
    *pBuild = MAKELONG( g_VerInfo[3], g_VerInfo[2] ); // MAKELONG(lo, hi)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\animated.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ANIMATED.H
//
// --------------------------------------------------------------------------

class   CAnimation : public CClient
{        
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT* pvarState);

        CAnimation(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\button.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  BUTTON.CPP
//
//  This file has the implementation of the button client
//
//  BOGUS:  In theory, just override get_accRole() and get_accState().
//  In reality, have to also override other things, mainly for the Start
//  button. 
//
//  Implements:
//      get_accChildCount
//      get_accChild
//      get_accName
//      get_accRole
//      get_accState
//      get_accDefaultAction
//      get_accKeyboardShortcut
//      accNavigate
//      accDoDefaultAction
//      Next
//      Skip
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "button.h" 
#include "menu.h"   // because start button has a child that is a menu.


// SendMessageTimeout timeout of 1/4 sec - should be enough time for a
// program to respond, but short enough to not annoy the user if we do
// block that long.
//
// See comments in CButton::DoDefaultAction for details on how this is
// used and why it is needed.
#define  SENDMESSAGE_TIMEOUT    250


// --------------------------------------------------------------------------
//
//  CreateButtonClient()
//
// --------------------------------------------------------------------------
HRESULT CreateButtonClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvButtonC)
{
    CButton * pbutton;
    HRESULT hr;

    InitPv(ppvButtonC);

    pbutton = new CButton(hwnd, idChildCur);
    if (! pbutton)
        return(E_OUTOFMEMORY);

    hr = pbutton->QueryInterface(riid, ppvButtonC);
    if (!SUCCEEDED(hr))
        delete pbutton;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CButton::CButton()
//
// --------------------------------------------------------------------------
CButton::CButton(HWND hwnd, LONG idChildCur)
    : CClient( CLASS_ButtonClient )
{
    Initialize(hwnd, idChildCur);
}


// --------------------------------------------------------------------------
//
//  SetupChildren()
//
// --------------------------------------------------------------------------
void CButton::SetupChildren(void)
{
    HWND hwndFocus;
    HWND hwndChild;

    if (!InTheShell(m_hwnd, SHELL_TRAY))
    {
        m_cChildren = 0;
        return;
    }

    // check to see if the start button has focus and a menu is shown. if so,
    // then there is one child 
    hwndFocus = MyGetFocus();
    if (m_hwnd == hwndFocus)
    {
        hwndChild = FindWindow (TEXT("#32768"),NULL);
        if (IsWindowVisible(hwndChild))
            m_cChildren = 1;
    }

}

// --------------------------------------------------------------------------
//
//  CButton::get_accName()
//
//  HACK for start button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accName(varChild, pszName));

    return(HrCreateString(STR_STARTBUTTON, pszName));
}


// --------------------------------------------------------------------------
//
//  CButton::get_accKeyboardShortcut()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    return(HrCreateString(STR_STARTBUTTON_SHORTCUT, pszShortcut));
}

// --------------------------------------------------------------------------
//
//  CButton::get_accChildCount()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accChildCount(long *pcCount)
{
    SetupChildren();
    *pcCount = m_cChildren;
    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CButton::get_accChild()
//
//  HACK for start button. If the menu is visible then we'll give that 
//  back, otherwise we'll just fall back on CClient
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
HWND    hwndChild;

    InitPv(ppdispChild);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::get_accChild(varChild,ppdispChild));

    SetupChildren();
    
    if (m_cChildren > 0)
    {
        hwndChild = FindWindow (TEXT("#32768"),NULL);
        if (IsWindowVisible(hwndChild))
        {
            return (CreateMenuPopupWindow (hwndChild,0L,IID_IDispatch,(void **)ppdispChild));
        }
    }

    return S_FALSE;
}

// --------------------------------------------------------------------------
//
//  CButton::accNavigate()
//
//  HACK for start button
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd)
{
    HWND    hwndChild;
    HWND    hwndNext;

    InitPvar(pvarEnd);

    //
    // Validate--this accepts an HWND id.
    //
    if (!ValidateHwnd(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::accNavigate(dwNavDir,varStart,pvarEnd));

    // so this is only for the Start button.
    // We want to find the menu that is lowest in the z order
    SetupChildren();
    if ((m_cChildren > 0) && 
        (dwNavDir == NAVDIR_FIRSTCHILD || dwNavDir == NAVDIR_LASTCHILD))
    {
        hwndChild = FindWindow(TEXT("#32768"),NULL);
        if (!hwndChild)
            return(S_FALSE);

        for( ; ; )
        {
            hwndNext = FindWindowEx(NULL,hwndChild,TEXT("#32768"),NULL);
            if (hwndNext && IsWindowVisible(hwndNext))
                hwndChild = hwndNext;
            else
                break;
        }

        if (IsWindowVisible(hwndChild))
            return(GetWindowObject(hwndChild, pvarEnd));
    }

    return(CClient::accNavigate(dwNavDir,varStart,pvarEnd));
}

// --------------------------------------------------------------------------
//
//  CButton::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    long    lStyle;

    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    //
    // Get window style
    //
    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    switch (lStyle & BS_TYPEMASK)
    {
        default:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_3STATE:
        case BS_AUTO3STATE:
            pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            break;

        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            pvarRole->lVal = ROLE_SYSTEM_RADIOBUTTON;
            break;

        case BS_GROUPBOX:
            pvarRole->lVal = ROLE_SYSTEM_GROUPING;
            break;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    LRESULT lResult;
    HRESULT hr;

    InitPvar(pvarState);

    //
    // Validate parameters && get window client state.
    //
    hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return(hr);
    
    Assert(pvarState->vt == VT_I4);

    lResult = SendMessage(m_hwnd, BM_GETSTATE, 0, 0);

    if (lResult & BST_PUSHED)
        pvarState->lVal |= STATE_SYSTEM_PRESSED;

    if (lResult & BST_CHECKED)
        pvarState->lVal |= STATE_SYSTEM_CHECKED;

    if (lResult & BST_INDETERMINATE)
        pvarState->lVal |= STATE_SYSTEM_MIXED;

    if ((GetWindowLong(m_hwnd, GWL_STYLE) & BS_TYPEMASK) == BS_DEFPUSHBUTTON)
        pvarState->lVal |= STATE_SYSTEM_DEFAULT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::get_accDefaultAction()
//
//  This is the button's name if it is a push button and not disabled.
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    long    lStyle;

    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & WS_DISABLED)
        return(S_FALSE);

    switch (lStyle & BS_TYPEMASK)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
        case BS_OWNERDRAW:
        case BS_USERBUTTON:
            // Pushing a push button is the default
            return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));

        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
            // Toggling a checkbox is the default
            if (SendMessage(m_hwnd, BM_GETSTATE, 0, 0) & BST_CHECKED)
                return(HrCreateString(STR_BUTTON_UNCHECK, pszDefAction));
            else
                return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));
            break;

        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
            // Checking a radio button is the default
            return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));

        case BS_3STATE:
        case BS_AUTO3STATE:
            switch (SendMessage(m_hwnd, BM_GETCHECK, 0, 0))
            {
                case 0:
                    return(HrCreateString(STR_BUTTON_CHECK, pszDefAction));

                case 1:
                    return(HrCreateString(STR_BUTTON_HALFCHECK, pszDefAction));

                default:
                    return(HrCreateString(STR_BUTTON_UNCHECK, pszDefAction));
            }
            break;

    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CButton::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::accDoDefaultAction(VARIANT varChild)
{
    long    lStyle;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & WS_DISABLED)
        return(S_FALSE);

    switch (lStyle & BS_TYPEMASK)
    {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            if (InTheShell(m_hwnd, SHELL_TRAY))
            {
                //
                // You can't just click the start button; it won't do
                // anything if the tray isn't active except take focus
                //
                PostMessage(m_hwnd, WM_SYSCOMMAND, SC_TASKLIST, 0L);
                break;
            }
            // FALL THRU

        case BS_PUSHBOX:
        case BS_OWNERDRAW:
        case BS_USERBUTTON:
        case BS_CHECKBOX:
        case BS_AUTOCHECKBOX:
        case BS_RADIOBUTTON:
        case BS_AUTORADIOBUTTON:
        case BS_3STATE:
        case BS_AUTO3STATE:

            // This used to be a PostMessage, but that hung powerpoint on 9x.
            // (ADG#186)
            //
            // PPT has a PeekMessage-based message loop. The first time around,
            // they don't filter messages and use PM_NOREMOVE, and get the
            // message. The second time, they filter on the message that they've
            // just got, and use PM_REMOVE to remove it this time. However, on
            // 9x, this failed - so the message remained in the queue, and got
            // processed over and over again...
            //
            // Seems to be a 9x-only quirk - messages are fine, but
            // BM_CLICK and a couple of other BM_ messages (GETSTATE?) have
            // this problem.
            //
            // Anyhow, using a SendMessage variant instead of PostMessage
            // bypasses the message queue, so it's not a problem. The Timeout
            // version is used to stop oleacc clients blocking if the target
            // takes a long time to do its stuff (eg. if it starts a modal
            // dialog).

            
//So using PostMessage on 9x can hang powerpoint, but using SendMessageTimeout on NT can cause the report dialog to hang.
#ifdef NTONLYBUILD
            PostMessage( m_hwnd, BM_CLICK, 0, 0 );
#else
            DWORD_PTR dwResult;
            SendMessageTimeout( m_hwnd, BM_CLICK, 0, 0, SMTO_NORMAL, SENDMESSAGE_TIMEOUT, & dwResult );
#endif
            return S_OK;
    }

    return E_NOT_APPLICABLE;
}

// --------------------------------------------------------------------------
//
//  CButton::Next()
//
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
    HWND    hwndChild;
    VARIANT* pvar;
    long    cFetched;
    HRESULT hr;

    if (!InTheShell(m_hwnd, SHELL_TRAY))
        return(CClient::Next(celt,rgvar,pceltFetched));

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    SetupChildren();

    // we only ever have 1 child
    if (m_idChildCur > 1)
        return (S_FALSE);

    // we only have one child if we have the focus and the menu
    // is visible
    hwndChild = FindWindow(TEXT("#32768"),NULL);
    if (!hwndChild)
        return(S_FALSE);

    if (IsWindowVisible(hwndChild))
    {
        hr = GetWindowObject(hwndChild, pvar);
        if (SUCCEEDED(hr))
        {
            ++pvar;
            ++cFetched;
        }
    }

    //
    // Advance the current position
    //
    m_idChildCur = 1;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CButton::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CButton::Skip(ULONG celt)
{
    if (!InTheShell (m_hwnd,SHELL_TRAY))
        return (CClient::Skip(celt));

    return (CAccessible::Skip(celt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\button.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  BUTTON.H
//
//  Button object
//
// --------------------------------------------------------------------------

class   CButton :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP    get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);
		STDMETHODIMP	get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
		STDMETHODIMP	get_accChildCount(long *pcCount);
		STDMETHODIMP	get_accChild(VARIANT varChild, IDispatch ** ppdispChild);
		STDMETHODIMP	accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd);
        STDMETHODIMP    accDoDefaultAction(VARIANT varChild);
		// IEnumVariant
		STDMETHODIMP	Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched);
		STDMETHODIMP	Skip(ULONG celt);

		//Helpers
		void SetupChildren(void);

        CButton(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\calendar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CALENDAR.CPP
//
//  Knows how to talk to COMCTL32's calendar and date-picker controls.  These
//  are a lot like a multicolumn listbox and combobox respectively.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "calendar.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTABCONTROL
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTOOLBAR
#define NOANIMATE
#define NOHEADER
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\calendar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CALENDAR.H
//
//  Knows how to talk to COMCTL32's calendar and date-picker controls.
//
// --------------------------------------------------------------------------


class CCalendar : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        void SetupChildren(void);
        CCalendar(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\caret.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CARET.CPP
//
//  This file has the implementation of the caret system object.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "caret.h"

// --------------------------------------------------------------------------
// prototypes for local functions
// --------------------------------------------------------------------------
int AddInts (int Value1, int Value2);
BOOL GetDeviceRect (HDC hDestDC,RECT ClientRect,LPRECT lpDeviceRect);

BOOL GetEditCaretOffset( HWND hEdit, int nHeight, int * pnOffset );


BOOL Rect1IsOutsideRect2( RECT const & rc1, RECT const & rc2 );


// --------------------------------------------------------------------------
//
//  CreateCaretObject()
//
// --------------------------------------------------------------------------
HRESULT CreateCaretObject(HWND hwnd, long idObject, REFIID riid, void** ppvCaret)
{
    UNUSED(idObject);

    return(CreateCaretThing(hwnd, riid, ppvCaret));
}



// --------------------------------------------------------------------------
//
//  CreateCaretThing()
//
// --------------------------------------------------------------------------
HRESULT CreateCaretThing(HWND hwnd, REFIID riid, void **ppvCaret)
{
    CCaret * pcaret;
    HRESULT hr;

    InitPv(ppvCaret);

    pcaret = new CCaret();
    if (pcaret)
    {
        if (! pcaret->FInitialize(hwnd))
        {
            delete pcaret;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = pcaret->QueryInterface(riid, ppvCaret);
    if (!SUCCEEDED(hr))
        delete pcaret;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CCaret::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CCaret::FInitialize(HWND hwnd)
{
    // Is this an OK window?
    m_dwThreadId = GetWindowThreadProcessId(hwnd, NULL);
    if (! m_dwThreadId)
        return(FALSE);

    //
    // NOTE:  We always initialize, even if this window doesn't own the
    // caret.  We will treat it as invisible in that case.
    //
    m_hwnd = hwnd;
    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CCaret::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::Clone(IEnumVARIANT** ppenum)
{
    return(CreateCaretThing(m_hwnd, IID_IEnumVARIANT, (void **)ppenum));
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_CARETNAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CARET;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCaret::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    GUITHREADINFO   gui;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (! MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
          (gui.hwndCaret != m_hwnd))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_FALSE);
    }

    if (!(gui.flags & GUI_CARETBLINKING))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCaret::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
GUITHREADINFO   gui;
HDC             hDC;
RECT            rcDevice;
    

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
        (gui.hwndCaret != m_hwnd))
    {
        return(S_FALSE);
    }


    BOOL fWindowsXPOrGreater = FALSE;

    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    osvi.dwMajorVersion = 0;
    osvi.dwMinorVersion = 0;
    GetVersionEx( &osvi );

    if ( osvi.dwMajorVersion >= 5 && osvi.dwMinorVersion >= 1 )
        fWindowsXPOrGreater = TRUE;

    if( ! fWindowsXPOrGreater )
    {
        // Instead of using MapWindowPoints, we use a private
        // function called GetDeviceRect that takes private mapping
        // modes, etc. into account.

        hDC = GetDC (m_hwnd);
        if( !hDC )
            return E_OUTOFMEMORY;

        GetDeviceRect (hDC,gui.rcCaret,&rcDevice);
        ReleaseDC (m_hwnd,hDC);
    }
    else
    {
        // On Windows XP, GDI does all the necessary mapping when
        // SetCaretPos is called, so we only need to do screen->client
        // mapping here.
        rcDevice = gui.rcCaret;
        MapWindowPoints( m_hwnd, NULL, (POINT *) & rcDevice, 2 );
    }
    




    // TODO - only do this for EDITs...
    // Suggest using MyRealGetWindowClass, stricmp against "EDIT"
    // Also get width in addition to offset - for now, assume 0.
    int nOffset;
    TCHAR szWindowClass[128];
    MyGetWindowClass( m_hwnd, szWindowClass, ARRAYSIZE(szWindowClass) );
    if ( lstrcmpi( szWindowClass, TEXT("EDIT") ) == 0 )
    {
        if( GetEditCaretOffset( m_hwnd, rcDevice.bottom - rcDevice.top, & nOffset ) )
        {
            DBPRINTF( TEXT("GetEditCaretOffset nOffset=%d\r\n"), nOffset );

            rcDevice.left -= nOffset;
            rcDevice.right = rcDevice.left + 1;
        }
    }

    // For RichEdits, use an offset of 3???
    //
    if ( lstrcmpi( szWindowClass, TEXT("RICHEDIT20A") ) == 0 ||      // Win9x
        lstrcmpi( szWindowClass, TEXT("RICHEDIT20W") ) == 0 ||      // Win2k + 
        lstrcmpi( szWindowClass, TEXT("RICHEDIT") ) == 0)           // NT4 
    {
        DBPRINTF( TEXT("This is and richedit\r\n") );
        rcDevice.left += 3;
        rcDevice.right = rcDevice.left + 1;
    }




    // Sanity check against returned rect - sometimes we get back
    // gabage cursor coords (of the order of (FFFFB205, FFFFB3C5))
    // - eg. when in notepad, place cursor at top/bottom of doc,
    // click on scrollbar arrowheads to scroll cursor off top/bottom
    // of visible area.
    // We still get back a valid hwnd and a CURSORBLINKING flag fom
    // GetGUIThreadInfo, so they aren't much use to detect this.

    RECT rcWindow;
    GetWindowRect( m_hwnd, & rcWindow );
    if( Rect1IsOutsideRect2( rcDevice, rcWindow ) )
    {
        return S_FALSE;
    }


    *pxLeft = rcDevice.left;
    *pyTop = rcDevice.top;
    *pcxWidth = rcDevice.right - rcDevice.left;
    *pcyHeight = rcDevice.bottom - rcDevice.top;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CCaret::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCaret::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    GUITHREADINFO gui;
    POINT pt;

    InitPvar(pvarChild);

    if (! MyGetGUIThreadInfo(m_dwThreadId, &gui) ||
        (gui.hwndCaret != m_hwnd))
    {
        return(S_FALSE);
    }

    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    if (PtInRect(&gui.rcCaret, pt))
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = 0;
        return(S_OK);
    }
    else
        return(S_FALSE);
}


//============================================================================
// This function takes a destination DC, a rectangle in client coordinates,
// and a pointer to the rectangle structure that will hold the device 
// coordinates of the rectangle. The device coordinates can be used as screen
// coordinates.
//============================================================================
BOOL GetDeviceRect (HDC hDestDC,RECT ClientRect,LPRECT lpDeviceRect)
{
POINT   aPoint;
int	    temp;
    
    lpDeviceRect->left = ClientRect.left;
    lpDeviceRect->top = ClientRect.top;
    
    // just set the device rect to the rect given and then do LPtoDP for both points
    lpDeviceRect->right = ClientRect.right;
    lpDeviceRect->bottom = ClientRect.bottom;
    LPtoDP (hDestDC,(LPPOINT)lpDeviceRect,2);
    
    // Now we need to convert from client coords to screen coords. We do this by 
    // getting the DC Origin and then using the AddInts function to add the origin 
    // of the 'drawing area' to the client coordinates. This is safer and easier 
    // than using ClientToScreen, MapWindowPoints, and/or getting the WindowRect if
    // it is a WindowDC. 
    GetDCOrgEx(hDestDC,&aPoint);
    
    lpDeviceRect->left = AddInts (lpDeviceRect->left,aPoint.x);
    lpDeviceRect->top = AddInts (lpDeviceRect->top,aPoint.y);
    lpDeviceRect->right = AddInts (lpDeviceRect->right,aPoint.x);
    lpDeviceRect->bottom = AddInts (lpDeviceRect->bottom,aPoint.y);
    
    // make sure that the top left is less than the bottom right!!!
    if (lpDeviceRect->left > lpDeviceRect->right)
    {
        temp = lpDeviceRect->right;
        lpDeviceRect->right = lpDeviceRect->left;
        lpDeviceRect->left = temp;
    }
    
    if (lpDeviceRect->top > lpDeviceRect->bottom)
    {
        temp = lpDeviceRect->bottom;
        lpDeviceRect->bottom = lpDeviceRect->top;
        lpDeviceRect->top = temp;
    }
    
    return TRUE;
} // end GetDeviceRect

//============================================================================
// AddInts adds two integers and makes sure that the result does not overflow
// the size of an integer.
// Theory: positive + positive = positive
//         negative + negative = negative
//         positive + negative = (sign of operand with greater absolute value)
//         negative + positive = (sign of operand with greater absolute value)
// On the second two cases, it can't wrap, so I don't check those.
//============================================================================
int AddInts (int Value1, int Value2)
{
int result;
    
    result = Value1 + Value2;
    
    if (Value1 > 0 && Value2 > 0 && result < 0)
        result = INT_MAX;
    
    if (Value1 < 0 && Value2 < 0 && result > 0)
        result = INT_MIN;
    
    return result;
}




#define CURSOR_USA   0xffff
#define CURSOR_LTR   0xf00c
#define CURSOR_RTL   0xf00d
#define CURSOR_THAI  0xf00e

#define LANG_ID(x)      ((DWORD)(DWORD_PTR)x & 0x000003ff);

#ifndef SPI_GETCARETWIDTH
#define SPI_GETCARETWIDTH                   0x2006
#endif


// GetEditCaretOffset
//
// Determine the offset to the actual caret bar from the start
// of the caret bitmap.
//
// Only applies to EDIT controls, not RichEdits.
//
// This code is based on \windows\core\cslpk\lpk\lpk_edit.c, (EditCreateCaret)
// which does the actual caret processing for the edit control. We mimic that
// code, leaving out the bits that we don't need.


WCHAR GetEditCursorCode( HWND hEdit )
{
    DWORD idThread = GetWindowThreadProcessId( hEdit, NULL );

    UINT uikl = LANG_ID( GetKeyboardLayout( idThread ) );

    WCHAR wcCursorCode = CURSOR_USA;

    switch( uikl )
    {
        case LANG_THAI:    wcCursorCode = CURSOR_THAI;  break;

        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_URDU:
        case LANG_HEBREW:  wcCursorCode = CURSOR_RTL;   break;

        default:

            WCHAR wcBuf[ 80 ];   // Registry read buffer
            int cBuf;
            cBuf = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_FONTSIGNATURE, wcBuf, ARRAYSIZE( wcBuf ) );
            BOOL fUserBidiLocale = ( cBuf && wcBuf[7] & 0x0800 ) ? TRUE : FALSE;

            if( fUserBidiLocale )
            {
                // Other keyboards have a left-to-right pointing caret
                // in Bidi locales.
                wcCursorCode = CURSOR_LTR;
            }
    }

    return wcCursorCode;
}


BOOL GetEditCaretOffsetFromFont( HWND hEdit, WCHAR wcCursorCode, int nHeight, int * pnOffset )
{
    if( wcCursorCode != CURSOR_RTL )
    {
        *pnOffset = 0;
        return TRUE;
    }


    BOOL fGotIt = FALSE;

    HDC hDC = GetDC( hEdit );

    int nWidth;
    SystemParametersInfo( SPI_GETCARETWIDTH, 0, (LPVOID) & nWidth, 0 );

    HFONT hFont = CreateFont( nHeight, 0, 0, 0, nWidth > 1 ? 700 : 400,
                0L, 0L, 0L, 1L, 0L, 0L, 0L, 0L, TEXT("Microsoft Sans Serif") );

    if( hFont )
    {
        HFONT hfOld = SelectFont( hDC, hFont );

        ABC abcWidth;
        if( GetCharABCWidths( hDC, wcCursorCode, wcCursorCode, & abcWidth ) )
        {
            *pnOffset = 1 - (int) abcWidth.abcB;
            fGotIt = TRUE;
        }

        SelectFont( hDC, hfOld );
        DeleteFont( hFont );
    }

    ReleaseDC( hEdit, hDC );

    return fGotIt;
}


BOOL GetEditCaretOffset( HWND hEdit, int nHeight, int * pOffset )
{
    WCHAR wcCursorCode = GetEditCursorCode( hEdit );

    if( wcCursorCode != CURSOR_USA )
    {
        return GetEditCaretOffsetFromFont( hEdit, wcCursorCode, nHeight, pOffset );
    }
    else
    {
        *pOffset = 0;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\caret.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CARET.H
//
//  Caret OLE Accessibility implementation
//
// --------------------------------------------------------------------------


class   CCaret :    public  CAccessible
{
    public:

        CCaret()
            : CAccessible( CLASS_CaretObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP    get_accState(VARIANT varChild, VARIANT * lpState);
        STDMETHODIMP    accLocation(long* pxLeft, long* pyTop,
            long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP    accHitTest(long xLeft, long yTop, VARIANT* pvarChild);

        // IEnumVARIANT
        STDMETHODIMP    Clone(IEnumVARIANT** ppenum);

        BOOL            FInitialize(HWND hwnd);

    private:
        DWORD           m_dwThreadId;
};


HRESULT     CreateCaretThing(HWND, REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\classinfo.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  classinfo
//
//  Information about the individual proxy classes
//
//  We could put this information in each class; but that would mean that
//  changes would require touching all the class files.
//  Centralizing this means that we only have a couple of files to change
//  if we need to add more information across all classes.
//
// --------------------------------------------------------------------------


typedef HRESULT (* LPFNCREATE)(HWND, long, REFIID, void**);


//
// lpfnCreate and fBitAgnostic are only used by classes created via the classmap.
//

struct CLASSINFO
{
    LPFNCREATE  lpfnCreate;
    BOOL        fBitAgnostic;           // Works across 64/32 boundaries

    LPCTSTR     szClassName;            // Friendly name of class to use in version info


    BOOL        fSupportsAnnotation;    // Is annotation supported? 
    DWORD       dwObjId;                // Objid used when building annotation key.
};


extern CLASSINFO g_ClassInfo[ ];


// This list must be kept in sync with the array of classinfo's.
enum CLASS_ENUM
{
    CLASS_NONE = -1, // For classes that don't use the classinfo.

    // General non-client stuff

    CLASS_CaretObject = 0,
    CLASS_ClientObject,
    CLASS_CursorObject,
    CLASS_MenuBarObject,
    CLASS_ScrollBarObject,
    CLASS_SizeGripObject,
    CLASS_SysMenuBarObject,
    CLASS_TitleBarObject,
    CLASS_WindowObject,

    // Client types - USER

    CLASS_ButtonClient,
    CLASS_ComboClient,
    CLASS_DialogClient,
    CLASS_DesktopClient,
    CLASS_EditClient,
    CLASS_ListBoxClient,
    CLASS_MDIClient,
    CLASS_MenuPopupClient,
    CLASS_ScrollBarClient,
    CLASS_StaticClient,
    CLASS_SwitchClient,

    // Client types - ComCtl32

    CLASS_StatusBarClient,
    CLASS_ToolBarClient,
    CLASS_ProgressBarClient,
    CLASS_AnimatedClient,
    CLASS_TabControlClient,
    CLASS_HotKeyClient,
    CLASS_HeaderClient,
    CLASS_SliderClient,
    CLASS_ListViewClient,
    CLASS_UpDownClient,
    CLASS_ToolTipsClient,
    CLASS_TreeViewClient,
    CLASS_CalendarClient,
    CLASS_DatePickerClient,
    CLASS_IPAddressClient,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlClient,

    // SDM32

    CLASS_SdmClientA,
#endif OLEACC_NTBUILD

    // Window types

    CLASS_ListBoxWindow,
    CLASS_MenuPopupWindow,

    // Other classes - these are created directly - and don't appear in the classmaps
    CLASS_MenuObject,
    CLASS_MenuItemObject,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlImageMap,
    CLASS_SdmList,
#endif // OLEACC_NTBUILD

    CLASS_LAST // Must be last entry; value = # of classes.
};



// All classes up to (but excluding) this one can be referred to by index values
// when sending  WM_GETOBJECT/OBJID_QUERYCLASSNAMEIDX.
#define QUERYCLASSNAME_CLASSES     (CLASS_IPAddressClient+1)

// We actually use (index + 65536) - to keep the return value
// out of the way of apps which return small intergers for
// WM_GETOBJECT even though they shouldn't (ie. Notes)
#define QUERYCLASSNAME_BASE        65536
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\classmap.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ClassMap
//
//  Contains all the funcitons and data used for mapping a window class
//  to an OLEACC proxy.
//
// --------------------------------------------------------------------------



void InitWindowClasses();
void UnInitWindowClasses();


typedef HRESULT (* LPFNCREATE)(HWND, long, REFIID, void**);

CLASS_ENUM GetWindowClass( HWND hWnd );

HRESULT FindAndCreateWindowClass( HWND        hWnd,
                                  BOOL        fWindow,
                                  CLASS_ENUM  ecDefault,
                                  long        idObject,
                                  long        idCurChild,
                                  REFIID      riid,
                                  void **     ppvObject );

//-----------------------------------------------------------------
// [v-jaycl, 6/7/97] [brendanm 9/4/98]
//  loads and initializes registered handlers.
//	Called by FindAndCreatreWindowClass
//-----------------------------------------------------------------
HRESULT CreateRegisteredHandler( HWND      hwnd,
                                 long      idObject,
                                 int       iHandlerIndex,
                                 REFIID    riid,
                                 LPVOID *  ppvObject );

BOOL LookupWindowClass( HWND          hWnd,
                        BOOL          fWindow,
                        CLASS_ENUM *  pceClass,
                        int *         pRegHandlerIndex );

BOOL LookupWindowClassName( LPCTSTR       pClassName,
                            BOOL          fWindow,
                            CLASS_ENUM *  pceClass,
                            int *         pRegHandlerIndex );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\client.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CLIENT.H
//
//  Default window client OLE accessible object class
//
// --------------------------------------------------------------------------


class CClient : public CAccessible
{
        // internal ctor. Private so taht derived classes don't inadvertantly use this -
        // they should use the one below (*where they specify a CLASS_ENUM) instead.
        // CreateClient is a friend so it can create us (using new).

        CClient()
            : CAccessible( CLASS_ClientObject )
        {
            // Done.
        }

        friend HRESULT CreateClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject);

    public:

        // Used by derived classes
        CClient( CLASS_ENUM eclass )
            : CAccessible( eclass )
        {
            // Done.
        }

        // IAccessible
        virtual STDMETHODIMP        get_accChildCount(long * pcCount);

        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT * pvarFocus);

        virtual STDMETHODIMP        accLocation(long* pxLeft, long* pyTop,
            long *pcxWidth, long *pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP        accSelect(long lSelFlags, VARIANT varChild);
        virtual STDMETHODIMP        accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd);
        virtual STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT *pvarHit);

        // IEnumVARIANT
        virtual STDMETHODIMP        Next(ULONG celt, VARIANT *rgelt, ULONG *pceltFetched);
        virtual STDMETHODIMP        Skip(ULONG celt);
        virtual STDMETHODIMP        Reset(void);
        virtual STDMETHODIMP        Clone(IEnumVARIANT **);

        void    Initialize(HWND hwnd, long idCurChild);
        BOOL    ValidateHwnd(VARIANT* pvar);

    protected:
        BOOL    m_fUseLabel;
};


extern HRESULT CreateClient(HWND hwnd, long idChild, REFIID riid, void** ppvObject);


// See comments in client.cpp for details on these.
// (A HWNDID is a HWND encoded in a DWORD idChild, these do the checking, encoding
// and decoding.)
BOOL IsHWNDID( DWORD id );
DWORD HWNDIDFromHwnd( HWND hwndParent, HWND hwnd );
HWND HwndFromHWNDID( HWND hwndParent, DWORD id );


//
// When enumerating, we loop through non-hwnd items first, then hwnd-children.
//
extern TCHAR    StripMnemonic(LPTSTR lpsz);
extern LPTSTR   GetTextString(HWND, BOOL);
extern LPTSTR   GetLabelString(HWND);
extern HRESULT  HrGetWindowName(HWND, BOOL, BSTR*);
extern HRESULT  HrGetWindowShortcut(HWND, BOOL, BSTR*);
extern HRESULT  HrMakeShortcut(LPTSTR, BSTR*);

#define SHELL_TRAY      1
#define SHELL_DESKTOP   2
#define SHELL_PROCESS   3
extern BOOL     InTheShell(HWND, int);

extern BOOL     IsComboEx(HWND);
extern HWND     IsInComboEx(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\classmap.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  ClassMap
//
//  Contains all the funcitons and data used for mapping a window class
//  to an OLEACC proxy.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "classmap.h"
#include "ctors.h"
#include "default.h"
#include "Win64Helper.h"
#include "RemoteProxy6432.h"


//
// Internal types & Forward decls.
//

// TODO: At some stage in future, this should be made dynamic instead of hardwired.
#define TOTAL_REG_HANDLERS                      100




typedef struct tagREGTYPEINFO
{
    CLSID   clsid;  // CLSID for this registered handler
    BOOL    bOK;    // used if there is an error - set to false if so
    TCHAR   DllName [ MAX_PATH ];
    TCHAR   ClassName [ MAX_PATH ];
    LPVOID  pClassFactory;
} REGTYPEINFO;




HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject);








//
// Arrays & Class Map Data...
//


//
// These three arrays (rgAtomClasses, rgClientTypes, and rgWindowTypes)
// are used by the FindWindowClass function below. 
//
// The rgAtomClass array is filled in by the InitWindowClasses function.
// InitWindowClasses iterates through the resources, loading strings that 
// are the names of the window classes that we recognize, putting them in 
// the Global Atom Table, and putting the Atom numbers in rgAtomClass so
// that rgAtomClass[StringN] = GlobalAddAtom ("StringTable[StringN]")
//
// When FindWindowClass is called, it gets the "real" class name of the 
// window, does a GlobalFindAtom of that string, then walks though 
// rgAtomClasses to see if the atom is in the table. If it is, then we 
// use the index where we found the atom to index into either the 
// rgClientTypes or rgWindowTypes array, where a pointer to the object 
// creation function is stored. These two arrays are static arrays
// initialized below. The elements in the array must correspond to the
// elements in the string table. 
//
// The rgClientTypes array is where most of the classes are. Currently,
// all types of controls that we create have a parent control that is
// a CWindow object, except for Dropdowns and menu popups, which provide 
// a window handler as well since they do something nonstandard for 
// get_accParent().  The former returns the combobox it is in, the 
// latter returns the menu item it comes from.
//

//
// NB - ordering of these should be considered fixed - as an offset
// referring to Listbox through RichEdit20W can be returned in response
// to WM_GETOBJECT/OBJID_QUERYCLASSINDEX.
// (The index is currently used to index directly into this table,
// but if the table order must change, another mapping table can
// be created and it used instead.)
//
//


CLASS_ENUM g_ClientClassMap [ ] =
{
    CLASS_ListBoxClient,
    CLASS_MenuPopupClient,
    CLASS_ButtonClient,
    CLASS_StaticClient,
    CLASS_EditClient,
    CLASS_ComboClient,
    CLASS_DialogClient,
    CLASS_SwitchClient,
    CLASS_MDIClient,
    CLASS_DesktopClient,
    CLASS_ScrollBarClient,
    CLASS_StatusBarClient,
    CLASS_ToolBarClient,
    CLASS_ProgressBarClient,
    CLASS_AnimatedClient,
    CLASS_TabControlClient,
    CLASS_HotKeyClient,
    CLASS_HeaderClient,
    CLASS_SliderClient,
    CLASS_ListViewClient,
        CLASS_ListViewClient,
    CLASS_UpDownClient,     // msctls_updown
    CLASS_UpDownClient,     // msctls_updown32
    CLASS_ToolTipsClient,   // tooltips_class
    CLASS_ToolTipsClient,   // tooltips_class32
    CLASS_TreeViewClient,
    CLASS_NONE,             // SysMonthCal32
    CLASS_DatePickerClient, // SysDateTimePick32
    CLASS_EditClient,       // RichEdit
    CLASS_EditClient,       // RichEdit20A
    CLASS_EditClient,       // RichEdit20W
    CLASS_IPAddressClient,

#ifndef OLEACC_NTBUILD
    CLASS_HtmlClient,       // HTML_InternetExplorer
    CLASS_SdmClientA,       // Word '95 #1
    CLASS_SdmClientA,       // Word '95 #2
    CLASS_SdmClientA,       // Word '95 #3
    CLASS_SdmClientA,       // Word '95 #4
    CLASS_SdmClientA,       // Word '95 #5
    CLASS_SdmClientA,       // Excel '95 #1
    CLASS_SdmClientA,       // Excel '95 #2
    CLASS_SdmClientA,       // Excel '95 #3
    CLASS_SdmClientA,       // Excel '95 #4
    CLASS_SdmClientA,       // Excel '95 #5
    CLASS_SdmClientA,       // Word '97 #1
    CLASS_SdmClientA,       // Word '97 #2
    CLASS_SdmClientA,       // Word '97 #3
    CLASS_SdmClientA,       // Word '97 #4
    CLASS_SdmClientA,       // Word '97 #5
    CLASS_SdmClientA,       // Word 3.1 #1
    CLASS_SdmClientA,       // Word 3.1 #2
    CLASS_SdmClientA,       // Word 3.1 #3
    CLASS_SdmClientA,       // Word 3.1 #4
    CLASS_SdmClientA,       // Word 3.1 #5
    CLASS_SdmClientA,       // Office '97 #1
    CLASS_SdmClientA,       // Office '97 #2
    CLASS_SdmClientA,       // Office '97 #3
    CLASS_SdmClientA,       // Office '97 #4
    CLASS_SdmClientA,       // Office '97 #5
    CLASS_SdmClientA,       // Excel '97 #1
    CLASS_SdmClientA,       // Excel '97 #2
    CLASS_SdmClientA,       // Excel '97 #3
    CLASS_SdmClientA,       // Excel '97 #4
    CLASS_SdmClientA        // Excel '97 #5
#endif // OLEACC_NTBUILD
};

#define NUM_CLIENT_CLASSES  ARRAYSIZE( g_ClientClassMap )

CLASS_ENUM g_WindowClassMap [ ] =
{
    CLASS_ListBoxWindow,
    CLASS_MenuPopupWindow
};

#define NUM_WINDOW_CLASSES  ARRAYSIZE( g_WindowClassMap )



LPTSTR rgClassNames [ ] =
{
        TEXT( "ListBox" ),
        TEXT( "#32768" ),
        TEXT( "Button" ),
        TEXT( "Static" ),
        TEXT( "Edit" ),
        TEXT( "ComboBox" ),
        TEXT( "#32770" ),
        TEXT( "#32771" ),
        TEXT( "MDIClient" ),
        TEXT( "#32769" ),
        TEXT( "ScrollBar" ),
        TEXT( "msctls_statusbar32" ),
        TEXT( "ToolbarWindow32" ),
        TEXT( "msctls_progress32" ),
        TEXT( "SysAnimate32" ),
        TEXT( "SysTabControl32" ),
        TEXT( "msctls_hotkey32" ),
        TEXT( "SysHeader32" ),
        TEXT( "msctls_trackbar32" ),
        TEXT( "SysListView32" ),
        TEXT( "OpenListView" ),
        TEXT( "msctls_updown" ),
        TEXT( "msctls_updown32" ),
        TEXT( "tooltips_class" ),
        TEXT( "tooltips_class32" ),
        TEXT( "SysTreeView32" ),
        TEXT( "SysMonthCal32" ),
        TEXT( "SysDateTimePick32" ),
        TEXT( "RICHEDIT" ),
        TEXT( "RichEdit20A" ),
        TEXT( "RichEdit20W" ),
    TEXT( "SysIPAddress32" ),

// The above CSTR_QUERYCLASSNAME_CLASSES classes can be referred
// to by the WM_GETOBJECT/OBJID_QUERYCLASSNAMEIDX message.
// See LookupWindowClassName() for more details.

#ifndef OLEACC_NTBUILD
        TEXT( "HTML_Internet Explorer" ),

        TEXT( "bosa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "osa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "sa_sdm_Microsoft Word for Windows 95" ),
        TEXT( "a_sdm_Microsoft Word for Windows 95" ),
        TEXT( "_sdm_Microsoft Word for Windows 95" ),
        TEXT( "bosa_sdm_XL" ),
        TEXT( "osa_sdm_XL" ),
        TEXT( "sa_sdm_XL" ),
        TEXT( "a_sdm_XL" ),
        TEXT( "_sdm_XL" ),
        TEXT( "bosa_sdm_Microsoft Word 8.0" ),
        TEXT( "osa_sdm_Microsoft Word 8.0" ),
        TEXT( "sa_sdm_Microsoft Word 8.0" ),
        TEXT( "a_sdm_Microsoft Word 8.0" ),
        TEXT( "_sdm_Microsoft Word 8.0" ),
        TEXT( "bosa_sdm_Microsoft Word 6.0" ),
        TEXT( "osa_sdm_Microsoft Word 6.0" ),
        TEXT( "sa_sdm_Microsoft Word 6.0" ),
        TEXT( "a_sdm_Microsoft Word 6.0" ),
        TEXT( "_sdm_Microsoft Word 6.0" ),
        TEXT( "bosa_sdm_Mso96" ),
        TEXT( "osa_sdm_Mso96" ),
        TEXT( "sa_sdm_Mso96" ),
        TEXT( "a_sdm_Mso96" ),
        TEXT( "_sdm_Mso96" ),
        TEXT( "bosa_sdm_XL8" ),
        TEXT( "osa_sdm_XL8" ),
        TEXT( "sa_sdm_XL8" ),
        TEXT( "a_sdm_XL8" ),
        TEXT( "_sdm_XL8" )
#endif // OLEACC_NTBUILD
};



//-----------------------------------------------------------------
// [v-jaycl, 4/2/97] Table of registered handler CLSIDs.  
//      TODO:Make dynamic. Place at bottom of file w/ other data?
//-----------------------------------------------------------------

CLSID   rgRegisteredTypes[TOTAL_REG_HANDLERS];


//-----------------------------------------------------------------
// [v-jaycl, 4/1/97] Grow to accomodate registered handlers. 
//      TODO: Kludge!  Make this dynamic.
//-----------------------------------------------------------------

ATOM    rgAtomClasses [ ARRAYSIZE(rgClassNames) + TOTAL_REG_HANDLERS ] = { 0 };












// --------------------------------------------------------------------------
//
//  InitWindowClasses()
//
//  Adds a whole lot of classes into the Global atom table for comparison
//  purposes.
//
// --------------------------------------------------------------------------
void InitWindowClasses()
{
    int     istr;
    TCHAR   szClassName[128];

    for (istr = 0; istr < NUM_CLIENT_CLASSES; istr++)
    {
        if( rgClassNames[ istr ] == NULL )
        {
            rgAtomClasses[istr] = NULL;
        }
        else
        {
            rgAtomClasses[istr] = GlobalAddAtom( rgClassNames[ istr ] );
        }
    }

        //-----------------------------------------------------------------
        // [v-jaycl, 4/2/97] Retrieve info for registered handlers from 
        //       registry and add to global atom table. 
        //       TODO: remove hard-wired strings.
        //-----------------------------------------------------------------

        const TCHAR  szRegHandlers[]   = TEXT("SOFTWARE\\Microsoft\\Active Accessibility\\Handlers");
        TCHAR            szHandler[255], szHandlerClassKey[255];
    LONG                 lRetVal, lBuffSize;
        HKEY             hKey;


        lRetVal = RegOpenKey( HKEY_LOCAL_MACHINE, szRegHandlers, &hKey );

        if ( lRetVal != ERROR_SUCCESS )
                return;

        for ( istr = 0; istr < TOTAL_REG_HANDLERS; istr++ )
        {
                lRetVal = RegEnumKey( hKey, istr, szHandler, sizeof(szHandler)/sizeof(TCHAR));

                if ( lRetVal != ERROR_SUCCESS ) 
                        break;          

                //-----------------------------------------------------------------
                // [v-jaycl, 4/2/97] Translate string into CLSID, then get info
                //       on specific handler from HKEY_CLASSES_ROOT\CLSID  subkey.
                //-----------------------------------------------------------------

                // CLSIDFromString checks the format of szHandler including its size so
                // guarantees that the lstrcat below won't cause a buffer overrun.
                
                CLSID clsid;
        
                szHandler[254] = 0;  // Force null-termination (RegEnumKey doesn't guarantee it).  
#ifdef UNICODE
                if ( CLSIDFromString( szHandler, &clsid ) != NOERROR )
                {
                    continue;
                }
#else
                OLECHAR wszString[MAX_PATH];
                MultiByteToWideChar(CP_ACP, 0, szHandler, -1, wszString, ARRAYSIZE(wszString));

                if ( CLSIDFromString( wszString, &clsid) != NOERROR )
                {
                    continue;
                }
#endif
                
                //-----------------------------------------------------------------
                //      Get proxied window class name from 
                //      HKEY_CLASSES_ROOT\CLSID\{clsid}\AccClassName
                //-----------------------------------------------------------------

                lstrcpy( szHandlerClassKey, TEXT("CLSID\\"));
                lstrcat( szHandlerClassKey, szHandler ); // CLSIDFromString above ensures this won't overflow buffer
                lstrcat( szHandlerClassKey, TEXT("\\AccClassName"));

                lBuffSize = sizeof(szClassName)/sizeof(TCHAR);
                lRetVal = RegQueryValue( HKEY_CLASSES_ROOT, szHandlerClassKey, szClassName, &lBuffSize );

                if ( lRetVal == ERROR_SUCCESS )
                {

                        //-------------------------------------------------------------
                        // Add CLSID to registered types table and associated class
                        //      name to global atom table and class types table.
                        //-------------------------------------------------------------

                        rgRegisteredTypes[istr] = clsid;
                        szClassName[127] = 0; // RegQueryValue doesn't ensure null-termination
                        rgAtomClasses[istr + NUM_CLIENT_CLASSES] = GlobalAddAtom( szClassName );

                }
        }

        RegCloseKey( hKey );

        return;
}


// --------------------------------------------------------------------------
//
//  UnInitWindowClasses()
//
//  Cleans up the Global Atom Table.
//
// --------------------------------------------------------------------------
void UnInitWindowClasses()
{
        //-----------------------------------------------------------------
        // [v-jaycl, 4/2/97] Clean up registered handler atoms after
        //  class and window atoms have been removed.
        //-----------------------------------------------------------------

    for( int istr = 0 ; istr < NUM_CLIENT_CLASSES + TOTAL_REG_HANDLERS ; istr++ )
    {
        if( rgAtomClasses[ istr ] )
            GlobalDeleteAtom( rgAtomClasses[ istr ] );
    }
}


// --------------------------------------------------------------------------
//
//  FindWindowClass()
// - has been replaced by:
//
//  GetWindowClass
//  FindAndCreateWindowClass
//  LookupWindowClass
//  LookupWindowClassName
//
//  See comments on each function for more infotmation.
//
// --------------------------------------------------------------------------



// --------------------------------------------------------------------------
//
//  GetWindowClass()
//
//  Gets an enum for the window class of this hwnd
//
//  Paremeters:
//              hwnd        The window handle we are checking
//      CLASS_ENUM  enum for this window
//
//      Returns:
//              A HRESULT 
//
// --------------------------------------------------------------------------

CLASS_ENUM GetWindowClass( HWND hWnd )
{
    int RegHandlerIndex;
    CLASS_ENUM ceClass;
    
    // fWindow param is FALSE - only interested in client classes...
    if( ! LookupWindowClass( hWnd, FALSE, &ceClass, & RegHandlerIndex ) )
    {
        // CLASS_NONE means it's a registered handler 
        return CLASS_NONE;
    }

    return ceClass;
}


// --------------------------------------------------------------------------
//
//  FindAndCreateWindowClass()
//
//  Create an object of the appropriate class for given window.
//  If no suitable class found, use the default object creation given,
//  if any.
//  
//  Paremeters:
//              hwnd        Handle of window to create object to represent/proxy
//              fWindow     TRUE if we're interested in a window (as opposed to
//                  client) -type class
//      pfnDefault  Function to use to create object if no suitable class
//                  found.
//      riid        Interface to pass to object creation function
//      idObject    object id to pass to object creation function
//      ppvObject   Object is returned through this
//
//      Returns:
//              HRESULT resulting from object creation.
//      S_OK or other success value on success,
//      failure value on failure (surprise surprise!)
//
//      If no suitable class found, and no default creation function
//      supplied, returns E_FAIL.
//      (Note that return of E_FAIL doesn't necessarilly mean no suitable
//      class found, since it can be returned for other reasons - eg.
//      error during creation of object.)
//
// --------------------------------------------------------------------------

HRESULT FindAndCreateWindowClass( HWND        hWnd,
                                  BOOL        fWindow,
                                  CLASS_ENUM  ceDefault,
                                  long        idObject,
                                  long        idCurChild,
                                  REFIID      riid,
                                  void **     ppvObject )
{
    int RegHandlerIndex;
    CLASS_ENUM ceClass;

    // Try and find a native proxy or registered handler for this window/client...
    if( ! LookupWindowClass( hWnd, fWindow, & ceClass, & RegHandlerIndex ) )
    {
        // Unknown class - do we have a default fn to use instead?
        if( ceDefault != CLASS_NONE )
        {
            // Yup - use it...
            ceClass = ceDefault;
        }
        else
        {
            // Nope - fail!
            ppvObject = NULL;
            return E_FAIL;
        }
    }

        // If the window class cannot be handled in a bit-agnostic way then we may
        // need to call a proxy of the server's bitness to create the accessible
        // object.  CreateRemoteProxy6432 returns S_OK if ppvObject is successfully created
        // by the proxy factory.  Otherwise just try to create it the normal way.

        if( ! g_ClassInfo[ ceClass ].fBitAgnostic )
        {
                BOOL fIsSameBitness;
                if (FAILED(SameBitness(hWnd, &fIsSameBitness)))
                        return E_FAIL;  // this should never happen

                if (!fIsSameBitness)
                        return CreateRemoteProxy6432( hWnd, idObject, riid, ppvObject );

        // If target window is of same bitness, fall through and create proxy locally...
        }

    // At this point, ceClass != CLASS_NONE means we've either found a class above,
    // or we're using the supplied default.
    // ceClass == CLASS_NONE means it's a registered handler class, using index
    // RegHandlerIndex...

    // Now create the object...
    if( ceClass != CLASS_NONE )
    {
        return g_ClassInfo[ ceClass ].lpfnCreate( hWnd, idCurChild, riid, ppvObject );
    }
    else
    {
        return CreateRegisteredHandler( hWnd, idObject, RegHandlerIndex, riid, ppvObject );
    }
}


// --------------------------------------------------------------------------
//
//  CreateRemoteProxy6432()
//
//  If the client and server are not the same bitness this code gets the
//  accessible object from a proxy of the correct bitness.
//  
//  Paremeters:
//              hwnd        Handle of window to create object to represent/proxy
//      idObject    object id to pass to oleacc proxy
//      riid        Interface to QI for on returned proxy object
//      ppvObject   Object is returned through this
//
//      Returns:
//              HRESULT is S_OK if the proxy successfully creats the accessible object,
//      HRESULT if an intermediate call fails.
//
HRESULT CreateRemoteProxy6432(HWND hwnd, long idObject, REFIID riid, void ** ppvObject)
{
        HRESULT hr;

        // The server (hwnd) is not the same bitness so get a remote proxy
        // factory object and use it to return the IAccessible object

        IRemoteProxyFactory *p;
        hr = GetRemoteProxyFactory(&p);
        if (FAILED(hr))
                return hr;

        IUnknown *punk = NULL;
        hr = p->AccessibleProxyFromWindow( HandleToLong( hwnd ), idObject, &punk);
        p->Release();

        if (FAILED(hr))
                return hr;

        if (!punk)
                return E_OUTOFMEMORY;

        // TODO Performance improvement would be to do the QI on the other side
        // but that would require custom marshalling of the riid struct.

        hr = punk->QueryInterface(riid, ppvObject);
        punk->Release();

        return hr;
}


// --------------------------------------------------------------------------
//
//  LookupWindowClass()
//
//  Tries to find an internal proxy or a registered handler for the
//  window, based on class name.
//
//  If no suitable match found, it sends the window a WM_GETOBJECT
//  message with OBJID_QUERYCLASSNAMEIDX - window can respond to
//  indicate its real name. If so, a class name match is tried on
//  that new name.
//
//  If that fails, or the window doesn't respond to the QUERY message,
//  FALSE is returned.
//
//  Paremeters:
//              hwnd            The window handle we are checking
//              fWindow         This is true if...
//      pceClass        ptr to value to receive class enum
//      pRegHandlerIndex    ptr to value to receive reg.handler index
//
//      Returns:
//      Returns TRUE if match found, FALSE if none found.
//
//      When TRUE returned:
//      If internal proxy found, *pceClass points to index of class in
//      class info array (entry contains a ctor fn plus other info).
//      If reg handler found, *pceClass is set to CLASS_NONE, and
//      *pRegHandlerIndex is set to a value that can be passed to
//      CreateRegisteredHandler to create a suitable object.
//
// --------------------------------------------------------------------------

BOOL LookupWindowClass( HWND          hWnd,
                        BOOL          fWindow,
                        CLASS_ENUM *  pceClass,
                        int *         pRegHandlerIndex )
{
    TCHAR   szClassName[128];

    //  This works by looking at the class name.  It uses a private function in
    //  USER to get the "real" class name, so that we see superclassed controls
    //  like VB's 'ThunderButton' as a button. (This only works for USER controls,
    //  though...)
    if( ! MyGetWindowClass( hWnd, szClassName, ARRAYSIZE( szClassName ) ) )
        return NULL;

    // First do lookup on 'apparent' class name - this allows us to reg-handler
    // even subclassed comctrls...
    if( LookupWindowClassName( szClassName, fWindow, pceClass, pRegHandlerIndex ) )
    {
        // Found a match for the (possibly wrapped) class name - use it...
        return TRUE;
    }

    // Try sending a WM_GETOBJECT / OBJID_QUERYCLASSNAMEIDX...
    LPTSTR pClassName = szClassName;
    DWORD_PTR ref = 0;
    SendMessageTimeout( hWnd, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX,
                            SMTO_ABORTIFHUNG, 10000, &ref );

    if( ! ref )
    {
        // No response - no match found, then, so return FALSE...
        return FALSE;
    }

    // Valid / in-range response?
    // (Remember, that we go from base..base+numclasses-1 instead of
    // 0..numclasses-1 to avoid running afoul of Notes and other apps
    // that return small LRESULTS to WM_GETOBJECT...)
    if( ref >= QUERYCLASSNAME_BASE &&
         ref - QUERYCLASSNAME_BASE < QUERYCLASSNAME_CLASSES )
    {
        // Yup - valid:
        pClassName = rgClassNames[ ref - QUERYCLASSNAME_BASE ];

        if( ! pClassName )
        {
            DBPRINTF( TEXT("Warning: reply to OBJID_QUERYCLASSNAMEIDX refers to unsupported class") );
            return FALSE;
        }

        // Now try again, using 'real' COMCTRL class name.
        return LookupWindowClassName( pClassName, fWindow, pceClass, pRegHandlerIndex );
    }
    else
    {
        DBPRINTF( TEXT("Warning: out-of-range reply to OBJID_QUERYCLASSNAMEIDX received") );
        return FALSE; // TODO - add debug output
    }
}



// --------------------------------------------------------------------------
//
//  LookupWindowClassName()
//
//  Tries to find an internal proxy or a registered handler for the
//  window, based on class name.
//
//  Does so by converting class name to an 'atom', and looking through
//  our reg handler and proxy tables.
//
//  Paremeters:
//              pClassName          name of class to lookup
//              fWindow             This is true if...
//      pceClass            ptr to value to receive proxy class enum
//      pRegHandlerIndex    ptr to value to receive reg.handler index
//
//      Returns:
//      Returns TRUE if match found, FALSE if none found.
//
//      When TRUE returned:
//      If internal proxy found, *pceClass is set to class index for the
//      proxy. (Can index into classinfo table to get ctor fn.)
//      If reg handler found, *pceClass is set to CLASS_NONE, and
//      *pRegHandlerIndex is set to a value that can be passed to
//      CreateRegisteredHandler to create a suitable object.
//
// --------------------------------------------------------------------------


BOOL LookupWindowClassName( LPCTSTR       pClassName,
                            BOOL          fWindow,
                            CLASS_ENUM *  pceClass,
                            int *         pRegHandlerIndex )
{
    // Get atom from classname - use it to lookup name in registered and
    // internal proxy tables...
    ATOM atom = GlobalFindAtom( pClassName );
    if( ! atom )
        return FALSE;

    // Search registered handler table first...
    int istr;
    for( istr = NUM_CLIENT_CLASSES ; istr < NUM_CLIENT_CLASSES + TOTAL_REG_HANDLERS ; istr++ )
        {
                if( rgAtomClasses[ istr ] == atom )
                {
                        *pRegHandlerIndex = istr - NUM_CLIENT_CLASSES;
            *pceClass = CLASS_NONE;
            return TRUE;
                }
        }

    // Search internal proxy client/window table...
    int cstr = (int)(fWindow ? NUM_WINDOW_CLASSES : NUM_CLIENT_CLASSES);

    for( istr = 0; istr < cstr ; istr++ )
    {
        if( rgAtomClasses[ istr ] == atom )
                {
            *pceClass = fWindow ? g_WindowClassMap[ istr ] : g_ClientClassMap[ istr ];
            // Only want to return TRUE if there is actually a proxy class for this window class...
            return *pceClass != CLASS_NONE;
                }
    }

    return FALSE;
}





// --------------------------------------------------------------------------
//
//  CreateRegisteredHandler()
//
//  This function takes an HWND, OBJID, RIID, and a PPVOID, same as the
//  other CreateXXX functions (like CreateButtonClient, etc.) This function
//  is used by calling FindWindowClass, which sees if a registered handler 
//  for the window class of HWND is installed. If so, it sets a global variable
//  s_iHandlerIndex that is an index into the global rgRegisteredTypes
//  array. That array contains CLSID's that are used to call CoCreateInstance,
//  to create an instance of an object that supports the interface
//  IAccessibleHandler. 
//  After creating this object, this function calls the object's
//  AccesibleObjectFromId method, using the HWND and the OBJID, and filling 
//  in the PPVOID to be an IAccessible interface.
//
//  [v-jaycl, 4/2/97] Special function returned by FindWindowClass()
//      for creating registered handlers.  
//
//  [v-jaycl, 5/15/97] Renamed second parameter from idChildCur to idObject
//      because I believe that what the parameter really is, or at least how I
//      intend to use it.
//
//  [v-jaycl, 8/7/97] Changed logic such that we now get an accessible
//      factory pointer back from CoCreateInstance() which supports
//      IAccessibleHandler. This interface provides the means for getting an
//      IAccessible ptr from a HWND/OBJID pair.
//      NOTE: To support any number of IIDs requested from the caller, we 
//      try QIing on the caller-specified riid parameter if our explicit QI on
//      IID_IAccessibleHandler fails.
// 
//  [BrendanM, 9/4/98]
//  Index now passed by parameter, so global var and mutex no longer needed.
//  Called by FindAndCreateWindowClass and CreateStdAccessibleProxyA.
//
//---------------------------------------------------------------------------

HRESULT CreateRegisteredHandler( HWND      hwnd,
                                 long      idObject,
                                 int       iHandlerIndex,
                                 REFIID    riid,
                                 LPVOID *  ppvObject )
{
    HRESULT             hr;
        LPVOID          pv;

        //------------------------------------------------------------
        // TODO: optimize by caching the proxy's object factory pointer.
        //      CoCreateInstance() only needs to be called once per
        //      proxy, not for each request for an object within a proxy.
        //      For satisfying the caller-specific IID, we can just QI
        //      on the cached object factory pointer.
        //------------------------------------------------------------


        //------------------------------------------------------------
        // First QI on IAccessibleHandler directly to retrieve
        // a pointer to the proxy object factory that
        // manufactures accessible objects from object IDs.
        //------------------------------------------------------------

        hr = CoCreateInstance( rgRegisteredTypes[ iHandlerIndex ], 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IAccessibleHandler, 
                           &pv );

        if ( SUCCEEDED( hr ) )
        {
                //------------------------------------------------------------
                // We must have a qualified proxy since it supports 
                //      IAccessibleHandler, so get the accessible object.
                //------------------------------------------------------------
#ifndef _WIN64
                hr = ((LPACCESSIBLEHANDLER)pv)->AccessibleObjectFromID( (UINT_PTR)hwnd, 
                                                                idObject, 
                                                                (LPACCESSIBLE *)ppvObject );
#else // _WIN64
        hr = E_NOTIMPL;
#endif // _WIN64
                ((LPACCESSIBLEHANDLER)pv)->Release();
        }
        else
        {
                //------------------------------------------------------------
                // Else try using the caller-specific IID
                //------------------------------------------------------------

                hr = CoCreateInstance( rgRegisteredTypes[ iHandlerIndex ], 
                               NULL, 
                               CLSCTX_INPROC_SERVER, 
                               riid, 
                               ppvObject );
        }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\client.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CLIENT.CPP
//
//  Window client class.
//
//  This handles navigation to other frame elements, and does its best
//  to manage the client area.  We recognize special classes, like listboxes,
//  and those have their own classes to do stuff.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "debug.h"


#define CH_PREFIX       ((TCHAR)'&')
#define CCH_WINDOW_SHORTCUTMAX  32
#define CCH_SHORTCUT            16


extern HRESULT  DirNavigate(HWND, long, VARIANT *);


// --------------------------------------------------------------------------
//
//  CreateClientObject()
//
//  EXTERNAL function for CreatStdOle...
//
// --------------------------------------------------------------------------
HRESULT CreateClientObject(HWND hwnd, long idObject, REFIID riid, void** ppvObject)
{
    UNUSED(idObject);

    InitPv(ppvObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateClient as default if none found.
    // (FALSE => use client, as opposed to window, classes)
    return FindAndCreateWindowClass( hwnd, FALSE, CLASS_ClientObject,
                                     OBJID_CLIENT, 0, riid, ppvObject );
}



// --------------------------------------------------------------------------
//
//  CreateClient()
//
//  INTERNAL function for CreateClientObject() and ::Clone()
//
// --------------------------------------------------------------------------
HRESULT CreateClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject)
{
    CClient * pclient;
    HRESULT hr;

    pclient = new CClient();
    if (!pclient)
        return(E_OUTOFMEMORY);

    pclient->Initialize(hwnd, idChildCur);

    hr = pclient->QueryInterface(riid, ppvObject);
    if (!SUCCEEDED(hr))
        delete pclient;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CClient::Initialize()
//
// --------------------------------------------------------------------------
void CClient::Initialize(HWND hwnd, long idChildCur)
{
    m_hwnd = hwnd;
    m_idChildCur = idChildCur;

    // If this is a comboex32, we want to pick up a preceeding
    // label, if one exists (just like we do for regular combos -
    // which set m_fUseLabel to TRUE in their own ::Initialize().
    // The combo will ask the parent comboex32 for its name, and
    // it in turn will look for a label.
    if( IsComboEx( m_hwnd ) )
    {
        m_fUseLabel = TRUE;
    }
}



// --------------------------------------------------------------------------
//
//  CClient::ValidateHwnd()
//
//  This will validate VARIANTs for both HWND-children clients and normal
//  clients.   If m_cChildren is non-zero, 
//
// --------------------------------------------------------------------------
BOOL CClient::ValidateHwnd(VARIANT* pvar)
{
    HWND    hwndChild;
    switch (pvar->vt)
    {
        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

#ifdef VT_I2_IS_VALID      // It should not be valid. That's why this is removed.
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if (pvar->lVal == 0)
                break;

            hwndChild = HwndFromHWNDID(m_hwnd, pvar->lVal);

            // This works for top-level AND child windows
            if (MyGetAncestor(hwndChild, GA_PARENT) != m_hwnd)
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}




// --------------------------------------------------------------------------
//
//  CClient::get_accChildCount()
//
//  This handles both non-HWND and HWND children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accChildCount(long *pcCount)
{
    HWND    hwndChild;
    HRESULT hr;

    hr = CAccessible::get_accChildCount(pcCount);
    if (!SUCCEEDED(hr))
        return hr;

    // popup menus (CMenuPopup) can have a NULL hwnd if created for an 'invisible'
    // menu. We probably shouldn't create them in the first place, but don't want
    // to change what objects we expose at this stage - so instead special case
    // NULL. This is to avoid calling GetWindow( NULL ), which would produce
    // debug output complaining, and those annoy the stress team.
    if( m_hwnd != NULL )
    {
        for (hwndChild = ::GetWindow(m_hwnd, GW_CHILD); hwndChild; hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT))
            ++(*pcCount);
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrGetWindowName(m_hwnd, m_fUseLabel, pszName));
}



// --------------------------------------------------------------------------
//
//  CClient::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CLIENT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;
    HWND       hwndActive;

    InitPvar(pvarState);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Are we the focus?  Are we enabled, visible, etc?
    //
    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    if (wi.dwStyle & WS_DISABLED)
        pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

    if (MyGetFocus() == m_hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;

    hwndActive = GetForegroundWindow();

    if (hwndActive == MyGetAncestor(m_hwnd, GA_ROOT))
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate--this does NOT accept a child ID
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    // reject child elements - shortcut key only applies to the overall
    // control.
    if ( varChild.lVal != 0 )
        return(E_NOT_APPLICABLE);

    return(HrGetWindowShortcut(m_hwnd, m_fUseLabel, pszShortcut));
}


// --------------------------------------------------------------------------
//
//  CClient::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::get_accFocus(VARIANT *pvarFocus)
{
    HWND    hwndFocus;

    InitPvar(pvarFocus);

    //
    // This RETURNS a child ID.
    //
    hwndFocus = MyGetFocus();

    //
    // Is the current focus a child of us?
    //
    if (m_hwnd == hwndFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else if (IsChild(m_hwnd, hwndFocus))
        return(GetWindowObject(hwndFocus, pvarFocus));

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate--this does NOT take a child ID
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetRect(m_hwnd, &rc, FALSE);
    MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

    *pxLeft = rc.left;
    *pyTop = rc.top;
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CClient::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accSelect( long lSelFlags, VARIANT varChild )
{
    if( ! ValidateChild( & varChild ) ||
        ! ValidateSelFlags( lSelFlags ) )
        return E_INVALIDARG;

    if( lSelFlags != SELFLAG_TAKEFOCUS )
        return E_NOT_APPLICABLE;

    if( varChild.lVal )
        return S_FALSE;

    MySetFocus( m_hwnd );

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accNavigate(long dwNavDir, VARIANT varStart, VARIANT * pvarEnd)
{
    HWND    hwndChild;
    int     gww;

    InitPvar(pvarEnd);

    //
    // Validate--this accepts an HWND id.
    //
    if (!ValidateHwnd(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        gww = GW_HWNDNEXT;
        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
        if (!hwndChild)
            return(S_FALSE);

        goto NextPrevChild;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        gww = GW_HWNDPREV;

        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
        if (!hwndChild)
            return(S_FALSE);

        // Start at the end and work backwards
        hwndChild = ::GetWindow(hwndChild, GW_HWNDLAST);

        goto NextPrevChild;
    }
    else if (!varStart.lVal)
        return(GetParentToNavigate(OBJID_CLIENT, m_hwnd, OBJID_WINDOW,
            dwNavDir, pvarEnd));

    hwndChild = HwndFromHWNDID(m_hwnd, varStart.lVal);

    if ((dwNavDir == NAVDIR_NEXT) || (dwNavDir == NAVDIR_PREVIOUS))
    {
        gww = ((dwNavDir == NAVDIR_NEXT) ? GW_HWNDNEXT : GW_HWNDPREV);

        while (hwndChild = ::GetWindow(hwndChild, gww))
        {
NextPrevChild:
            if (IsWindowVisible(hwndChild))
                return(GetWindowObject(hwndChild, pvarEnd));
        }
    }
    else
        return(DirNavigate(hwndChild, dwNavDir, pvarEnd));

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CClient::accHitTest()
//
//  This ALWAYS returns a real object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    HWND    hwndChild;
    POINT   pt;

    InitPvar(pvarHit);

    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    hwndChild = MyRealChildWindowFromPoint(m_hwnd, pt);
    if (hwndChild)
    {
        if (hwndChild == m_hwnd)
        {
            pvarHit->vt = VT_I4;
            pvarHit->lVal = 0;
            return(S_OK);
        }
        else
            return(GetWindowObject(hwndChild, pvarHit));
    }
    else
    {
        // Null window means point isn't in us at all...
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CClient::Next()
//
//  This loops through non-HWND children first, then HWND children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
    HWND    hwndChild;
    VARIANT* pvar;
    long    cFetched;
    HRESULT hr;

    if( m_idChildCur == -1 )
    {
        // If we're at the end, can't return any more...
        *pceltFetched = 0;
        return celt == 0 ? S_OK : S_FALSE;
    }

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // Grab the non-HWND dudes first.
    if (!IsHWNDID(m_idChildCur) && (m_idChildCur < m_cChildren))
    {
        cFetched = 0;

        hr = CAccessible::Next(celt, rgvar, (ULONG*)&cFetched);
        if (!SUCCEEDED(hr))
            return hr;

        celt -= cFetched;
        rgvar += cFetched;

        if (pceltFetched)
            *pceltFetched += cFetched;

        if (!celt)
            return S_OK;
    }


    pvar = rgvar;
    cFetched = 0;

    if (!IsHWNDID(m_idChildCur))
    {
        Assert(m_idChildCur == m_cChildren);
        hwndChild = ::GetWindow(m_hwnd, GW_CHILD);
    }
    else
    {
        hwndChild = HwndFromHWNDID(m_hwnd, m_idChildCur);
    }

    //
    // Loop through our HWND children now
    //
    while (hwndChild && (cFetched < (long)celt))
    {
        hr = GetWindowObject(hwndChild, pvar);
        if (SUCCEEDED(hr))
        {
            ++pvar;
            ++cFetched;
        }
        else
        {
            // Failed - skip this one - but keep going.
            TraceWarningHR( hr, TEXT("CClient::Next - GetWindowObject failed on hwnd 0x%p, skipping"), hwndChild );
        }

        hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
    }

    // Remember current position
    // Have to special-case NULL - GetWindow(...) returns NULL
    // when we reach the end - have to store a special value
    // so we know that we're at the end the next time we're
    // called.
    if( hwndChild == NULL )
        m_idChildCur = -1;
    else
        m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndChild);

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return (cFetched < (long)celt) ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Skip(ULONG celt)
{
    HWND    hwndT;

    if( m_idChildCur == -1 )
    {
        // If we're at the end, can't return any more...
        return celt == 0 ? S_FALSE : S_OK;
    }

    SetupChildren();

    // Skip non-HWND items
    if (!IsHWNDID(m_idChildCur) && (m_idChildCur < m_cChildren))
    {
        long    dAway;

        dAway = m_cChildren - m_idChildCur;
        if (celt >= (DWORD)dAway)
        {
            celt -= dAway;
            m_idChildCur = m_cChildren;
        }
        else
        {
            m_idChildCur += celt;
            return S_OK;
        }
    }

    // Skip the HWND children next
    if (!IsHWNDID(m_idChildCur))
    {
        Assert(m_idChildCur == m_cChildren);
        hwndT = ::GetWindow(m_hwnd, GW_CHILD);
    }
    else
        hwndT = HwndFromHWNDID(m_hwnd, m_idChildCur);

    while (hwndT && (celt-- > 0))
    {
        hwndT = ::GetWindow(hwndT, GW_HWNDNEXT);
    }

    // Remember current position
    // Have to special-case NULL - GetWindow(...) returns NULL
    // when we reach the end - have to store a special value
    // so we know that we're at the end the next time we're
    // called.
    if( hwndT == NULL )
        m_idChildCur = -1;
    else
        m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndT);

    return celt ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Reset(void)
{
    m_idChildCur = 0;
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CClient::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CClient::Clone(IEnumVARIANT** ppenum)
{
    InitPv(ppenum);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateClient as default if none found.
    // (FALSE => use client, as opposed to window, classes)
    return FindAndCreateWindowClass( m_hwnd, FALSE, CLASS_ClientObject,
                  OBJID_CLIENT, m_idChildCur, IID_IEnumVARIANT, (void **)ppenum );
}




// --------------------------------------------------------------------------
//
//  GetTextString()
//
//  Parameters: hwnd of the window to get the text from, and a boolean
//  that indicates whether or not we should always allocate memory to
//  return. I.E., if the window says the size of the text is 0, and
//  fAllocIfEmpty is TRUE, then we'll still allocate 1 byte (size+1).
//
// This contains a bit of a hack. The way it was originally written, this
// will try to get the ENTIRE text of say, a RichEdit control, even if that
// document is HUGE. Eventually we want to support that, but we are going to 
// need to do better than LocalAlloc. With a big document, we would page
// fault sometimes, because even though the memory is allocated, it
// may not be able to be paged in. JeffBog suggested that the way to
// check is to try to read/write both ends of the allocated space, and
// assume that if that works everything in between is OK too.
//
// So here's the temporary hack (BOGUS!)
// I am putting an artificial limit of 4096 bytes on the allocation.
// I am also going to do IsBadWritePtr on the thing, instead of just 
// checking if the pointer returned by alloc is null. duh.
// --------------------------------------------------------------------------
LPTSTR GetTextString(HWND hwnd, BOOL fAllocIfEmpty)
{
    UINT    cchText;
    LPTSTR  lpText;
#define MAX_TEXT_SIZE   4096

    //
    // Look for a name property!
    //

    lpText = NULL;

    if (!IsWindow(hwnd))
        return (NULL);
    //
    // Barring that, use window text.
    // BOGUS!  Strip out the '&'.
    //
    cchText = SendMessageINT(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // hack
    cchText = (cchText > MAX_TEXT_SIZE ? MAX_TEXT_SIZE : cchText);

    // Allocate a buffer
    if (cchText || fAllocIfEmpty)
    {
        lpText = (LPTSTR)LocalAlloc(LPTR, (cchText+1)*sizeof(TCHAR));
        if (IsBadWritePtr (lpText,cchText+1))
            return(NULL);


        if (cchText)
            SendMessage(hwnd, WM_GETTEXT, cchText+1, (LPARAM)lpText);
    }

    return(lpText);
}



// --------------------------------------------------------------------------
//
//  GetLabelString()
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
// --------------------------------------------------------------------------
LPTSTR GetLabelString(HWND hwnd)
{
    HWND    hwndLabel;
    LONG    lStyle;
    LRESULT lResult;
    LPTSTR  lpszLabel;

    lpszLabel = NULL;

    if (!IsWindow(hwnd))
        return (NULL);

    hwndLabel = hwnd;

    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        //
        // Is this a static dude?
        //
        lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            //
            // Great, we've found our label.
            //
            lpszLabel = GetTextString(hwndLabel, FALSE);
            break;
        }


        //
        // Skip if invisible
        // Note that we do this after checking if its a staic,
        // so that we give invisible statics a chance. Using invisible
        // statics is a easy workaround to add names to controls
        // without changing the visual UI.
        //
        if (!(lStyle & WS_VISIBLE))
            continue;

        
        //
        // Is this a tabstop or group?  If so, bail out now.
        //
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return(lpszLabel);
}



// --------------------------------------------------------------------------
//
//  HrGetWindowName()
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowName(HWND hwnd, BOOL fLookForLabel, BSTR* pszName)
{
    LPTSTR  lpText;

    lpText = NULL;
    if (!IsWindow(hwnd))
        return (E_INVALIDARG);

    //
    // Look for a name property!
    //

    //
    // If use a label, do that instead
    //
    if (!fLookForLabel)
    {
        // 
        // Try using a label anyway if this control has no window text
        // and the parent is a dialog.
        //
        lpText = GetTextString(hwnd, FALSE);
        if (!lpText)
        {
            HWND hwndParent = MyGetAncestor( hwnd, GA_PARENT );
            if( hwndParent && CLASS_DialogClient == GetWindowClass( hwndParent ) )
            {
                fLookForLabel = TRUE;
            }
        }
    }

    if (fLookForLabel)
        lpText = GetLabelString(hwnd);

    if (! lpText)
        return(S_FALSE);

    //
    // Strip out the mnemonic.
    //
    StripMnemonic(lpText);

    // Get a BSTR
    *pszName = TCharSysAllocString(lpText);

    // Free our buffer
    LocalFree((HANDLE)lpText);

    // Did the BSTR succeed?
    if (! *pszName)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  HrGetWindowShortcut()
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowShortcut(HWND hwnd, BOOL fUseLabel, BSTR* pszShortcut)
{
    //
    // Get the window text, and see if the '&' character is in it.
    //
    LPTSTR  lpText;
    TCHAR   chMnemonic;

    if (!IsWindow(hwnd))
        return (E_INVALIDARG);

    lpText = NULL;

    if (! fUseLabel)
    {
        //
        // Try using a label anyway if this control has no window text
        // and the parent is a dialog.
        //
        lpText = GetTextString(hwnd, FALSE);
        if (!lpText)
        {
            HWND  hwndParent = MyGetAncestor( hwnd, GA_PARENT );
            if( hwndParent && CLASS_DialogClient == GetWindowClass( hwndParent ) )
            {
                fUseLabel = TRUE;
            }
        }
    }

    if (fUseLabel)
        lpText = GetLabelString(hwnd);

    if (! lpText)
        return(S_FALSE);

    chMnemonic = StripMnemonic(lpText);
    LocalFree((HANDLE)lpText);

    //
    // Is there a mnemonic?
    //
    if (chMnemonic)
    {
        //
        // Make a string of the form "Alt+ch".
        //
        TCHAR   szKey[2];

        *szKey = chMnemonic;
        *(szKey+1) = 0;

        return(HrMakeShortcut(szKey, pszShortcut));
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  HrMakeShortcut()
//
//  This takes a string for the hotkey, then combines it with the "Alt+%s"
//  shortcut format to make the real string combination.  If asked, it will
//  free the hotkey string passed in.
//
// --------------------------------------------------------------------------
HRESULT HrMakeShortcut(LPTSTR lpszKey, BSTR* pszShortcut)
{
    TCHAR   szFormat[CCH_SHORTCUT];
    TCHAR   szResult[CCH_WINDOW_SHORTCUTMAX];

    // Get the format string
    LoadString(hinstResDll, STR_MENU_SHORTCUT_FORMAT, szFormat,
        ARRAYSIZE(szFormat));

    // Make the result
    wsprintf(szResult, szFormat, lpszKey);

    // Alloc a BSTR of the result
    *pszShortcut = TCharSysAllocString(szResult);

    // Should we free the key string?
    // Did the allocation fail?
    if (!*pszShortcut)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}



// 'Slide' string along by one char, in-place, to effectively remove the
// char pointed to be pStr.
// eg. if pStr points to the 'd' of 'abcdefg', the string
// will be transformed to 'abcefg'.
// Note: the char pointed to by pStr is assumed to be a single-byte
// char (if compiled under ANSI - not an issue if compiled inder UNICODE)
// Note: Makes use of the fact that no DBCS char has NUL as the trail byte.
void SlideStrAndRemoveChar( LPTSTR pStr )
{
    LPTSTR pLead = pStr + 1;
    // Checking the trailing pStr ptr means that we continue until we've
    // copied (not just encountered) the terminating NUL.
    while( *pStr )
        *pStr++ = *pLead++;
}



// --------------------------------------------------------------------------
//
//  StripMnemonic()
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
//
//  Modified to be DBCS 'aware' - uses CharNext() instead of ptr++ to
//  advance through the string. Will only return shortcut char if its a 
//  single byte char, though. (Would have to change all usages of this
//  function to allow return of a potentially DBCS char.) Will remove this
//  restriction in the planned-for-future fully-UNICODE OLEACC.
//  This restriction should not be much of a problem, because DBCS chars,
//  which typically require an IME to compose, are very unlikely to be
//  used as 'shortcut' chars. eg. Japanese Windows uses underlined roman
//  chars as shortcut chars.
//  (This will all be replaced by simpler code when we go UNICODE...)
// --------------------------------------------------------------------------
TCHAR StripMnemonic(LPTSTR lpszText)
{
    TCHAR   ch;
    TCHAR   chNext = 0;

    while( *lpszText == (TCHAR)' ' )
        lpszText = CharNext( lpszText );

    while( ch = *lpszText )
    {
        lpszText = CharNext( lpszText );

        if (ch == CH_PREFIX)
        {
            // Get the next character.
            chNext = *lpszText;

            // If it too is '&', then this isn't a mnemonic, it's the 
            // actual '&' character.  
            if (chNext == CH_PREFIX)
                chNext = 0;
            
            // Skip 'n' strip the '&' character
            SlideStrAndRemoveChar( lpszText - 1 );

#ifdef UNICODE
            CharLowerBuff(&chNext, 1);
#else
            if( IsDBCSLeadByte( chNext ) )
            {
                // We're ignoring DBCS chars as shortcut chars
                // - would need to change this func and all callers
                // to handle a returned DB char otherwise.
                // For the moment, we just ensure we don't return
                // an 'orphaned' lead byte...
                chNext = '\0';
            }
            else
            {
                CharLowerBuff(&chNext, 1);
            }
#endif
            break;
        }
    }

    return(chNext);
}



// --------------------------------------------------------------------------
//
//  DirNavigate()
//
//  Figures out which peer window is closest to us in the given direction.
//
// --------------------------------------------------------------------------
HRESULT DirNavigate(HWND hwndSelf, long dwNavDir, VARIANT* pvarEnd)
{
    HWND    hwndPeer;
    RECT    rcSelf;
    RECT    rcPeer;
    int     dwClosest;
    int     dwT;
    HWND    hwndClosest;

    if (!IsWindow(hwndSelf))
        return (E_INVALIDARG);

    MyGetRect(hwndSelf, &rcSelf, TRUE);

    dwClosest = 0x7FFFFFFF;
    hwndClosest = NULL;

    for (hwndPeer = ::GetWindow(hwndSelf, GW_HWNDFIRST); hwndPeer;
         hwndPeer = ::GetWindow(hwndPeer, GW_HWNDNEXT))
    {
        if ((hwndPeer == hwndSelf) || !IsWindowVisible(hwndPeer))
            continue;

        MyGetRect(hwndPeer, &rcPeer, TRUE);

        dwT = 0x7FFFFFFF;

        switch (dwNavDir)
        {
            case NAVDIR_LEFT:
                //
                // Bogus!  Only try this one if it intersects us vertically
                //
                if (rcPeer.left < rcSelf.left)
                    dwT = rcSelf.left - rcPeer.left;
                break;

            case NAVDIR_UP:
                //
                // Bogus!  Only try this one if it intersects us horizontally
                //
                if (rcPeer.top < rcSelf.top)
                    dwT = rcSelf.top - rcPeer.top;
                break;

            case NAVDIR_RIGHT:
                //
                // Bogus!  Only try this one if it intersects us vertically
                //
                if (rcPeer.right > rcSelf.right)
                    dwT = rcPeer.right - rcSelf.right;
                break;

            case NAVDIR_DOWN:
                //
                // Bogus!  Only try this one if it intersects us horizontally
                //
                if (rcPeer.bottom > rcSelf.bottom)
                    dwT = rcPeer.bottom - rcSelf.bottom;
                break;

            default:
                AssertStr( TEXT("INVALID NAVDIR") );
        }

        if (dwT < dwClosest)
        {
            dwClosest = dwT;
            hwndClosest = hwndPeer;
        }
    }

    if (hwndClosest)
        return(GetWindowObject(hwndClosest, pvarEnd));
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  InTheShell()
//
//  Returns TRUE if the object is on the shell tray, desktop, or process.
//
// --------------------------------------------------------------------------
BOOL InTheShell(HWND hwnd, int nPart)
{
    HWND    hwndShell;
    static  TCHAR szShellTray[] = TEXT("Shell_TrayWnd");
    DWORD   idProcessUs;
    DWORD   idProcessShell;

    hwndShell = GetShellWindow();

    switch (nPart)
    {
        case SHELL_TRAY:
            // Use the tray window instead.
            hwndShell = FindWindowEx(NULL, NULL, szShellTray, NULL);
            // Fall thru

        case SHELL_DESKTOP:
            if (!hwndShell)
                return(FALSE);
            return(MyGetAncestor(hwnd, GA_ROOT) == hwndShell);

        case SHELL_PROCESS:
            idProcessUs = NULL;
            idProcessShell = NULL;
            GetWindowThreadProcessId(hwnd, &idProcessUs);
            GetWindowThreadProcessId(hwndShell, &idProcessShell);
            return(idProcessUs && (idProcessUs == idProcessShell));
    }

    AssertStr( TEXT("GetShellWindow returned strange part") );
    return(FALSE);
}













// --- start of original comment ---
//
//   We need a way for HWND and non-HWND children to live in the same
//   namespace together.  Since children pass up peer-to-peer navigation to
//   their parent, we need a way for HWND children to identify themselves in
//   the navigate call.  Since HWND children are always objects, it is fine
//   for the client parent to not accept HWND ids in all other methods.  One
//   can do it, but it is a lot of work.
//
//   Examples to date of mixed:
//        (1) Comboboxes (dropdown always a window, cur item may or may not be,
//            button never is)
//        (2) Toolbars (dropdown is a window, buttons aren't)
//
//   We want the client manager to handle IEnumVARIANT, validation, etc.
//
// --- end of original comment ---
//
// A 'HWNDID' is basically a HWND squeezed (somehow) into a DWORD idChild.
//
// IsHWNDID checks if a idChild is one of these HWNDIDs, or just a regular
// idChild (ie. a 1-based child element index)
//
// HWNDIDFromHwnd and HwndFromHWNDID encode and decode HWNDs as idChilds.
//
// Previous versions of these didn't have a hwndParent parameter,
// and squeezed a HWND into bits 0..30, with bit31 set to 1 as the
// 'this is a HWND id' flag. That scheme doesn't work for HWNDs
// which have bt31 set... (these do exist on long-running systems -
// the top WORD of the HWND is a 'uniqueifier', which gets inc'd every
// time the slot - indicated by the bottom HWND - is reused. Of course,
// this implementation can change at any time in the furure, so we
// shouldn't rely on it, or rely on any bits being 'always 0' or
// otherwise.)
//
// The current sceheme still uses the high bit as a flag, but if set,
// the remaining bits are now a count into the parent window's children
// chain.
//
//
// It may be possible to remove these althogther - if the destination object
// corresponds to a full HWND, instead of returning a HWNDID, instead return
// the full IAccessible for that object. (Still have to figure out what happens
// when that IAccessible needs to navigate to one of its siblings, though.)

BOOL IsHWNDID( DWORD id )
{
    // hight bit indicates that it represents a HWND.
    return id & 0x80000000;
}

DWORD HWNDIDFromHwnd( HWND hwndParent, HWND hwnd )
{
    // Traverse the child list, counting as we go, till we hit the HWND we want...
    int i = 0;
    HWND hChild = GetWindow( hwndParent, GW_CHILD );

    while( hChild != NULL )
    {
        if( hChild == hwnd )
        {
            return i | 0x80000000;
        }

        i++;
        hChild = GetWindow( hChild, GW_HWNDNEXT );
    }

    return 0;
}

HWND HwndFromHWNDID( HWND hwndParent, DWORD id )
{
    // Traverse the child list, till we get to the one with this index...
    int i = id & ~ 0x80000000;

    HWND hChild = GetWindow( hwndParent, GW_CHILD );

    while( i != 0 && hChild != NULL )
    {
        i--;
        hChild = GetWindow( hChild, GW_HWNDNEXT );
    }

    return hChild;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\classinfo.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  classinfo
//
//  Information about the individual proxy classes
//
//  We could put this information in each class; but that would mean that
//  changes would require touching all the class files.
//  Centralizing this means that we only have a couple of files to change
//  if we need to add more information across all classes.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "ctors.h"
// #include "classinfo.h" - already in oleacc_p.h


CLASSINFO g_ClassInfo[ ] =
{
    // General non-client stuff
    // These ctors can be NULL, since they're never used. Only need them for
    // classes that are in the class map.

    // ctor and bit-agnostic fields are only used for classes that are in the class map.
    // Exceptions are CreateClient and CreateWindowThing - these are the 'default'
    // client and window proxies, which are used if no classname match is found.

    // ctor                  bit-agnostic       name             annotatble?   objid
    { NULL,                     FALSE,  TEXT("CaretObject"),        TRUE,   OBJID_CARET     },
    { CreateClient,             TRUE,   TEXT("ClientObject"),       TRUE,   OBJID_CLIENT    },
    { NULL,                     FALSE,  TEXT("CursorObject"),       TRUE,   OBJID_CURSOR    },
    { NULL,                     FALSE,  TEXT("MenuBarObject"),      TRUE,   OBJID_MENU      },

    // ScrollBarObject annotation support is handled explicitly in CScrollBar::GetIdentityString,
    // so the objid field is left empty here.
    { NULL,                     FALSE,  TEXT("ScrollBarObject"),    TRUE,   0               },
    { NULL,                     FALSE,  TEXT("SizeGripObject"),     TRUE,   OBJID_SIZEGRIP  },
    { NULL,                     FALSE,  TEXT("SysMenuBarObject"),   TRUE,   OBJID_SYSMENU   },
    { NULL,                     FALSE,  TEXT("TitleBarObject"),     TRUE,   OBJID_TITLEBAR  },
    { CreateWindowThing,        TRUE,   TEXT("WindowObject"),       TRUE,   OBJID_WINDOW    },

    // Client types - USER

    { CreateButtonClient,       TRUE,   TEXT("ButtonClient"),       TRUE,   OBJID_CLIENT    },
    { CreateComboClient,        TRUE,   TEXT("ComboClient"),        TRUE,   OBJID_CLIENT    },
    { CreateDialogClient,       TRUE,   TEXT("DialogClient"),       TRUE,   OBJID_CLIENT    },
    { CreateDesktopClient,      TRUE,   TEXT("DesktopClient"),      TRUE,   OBJID_CLIENT    },
    { CreateEditClient,         TRUE,   TEXT("EditClient"),         TRUE,   OBJID_CLIENT    },
    { CreateListBoxClient,      TRUE,   TEXT("ListBoxClient"),      TRUE,   OBJID_CLIENT    },
    { CreateMDIClient,          TRUE,   TEXT("MDIClient"),          TRUE,   OBJID_CLIENT    },
    { CreateMenuPopupClient,   FALSE,   TEXT("MenuPopupClient"),    TRUE,   OBJID_CLIENT    },
    { CreateScrollBarClient,    TRUE,   TEXT("ScrollBarClient"),    TRUE,   OBJID_CLIENT    },
    { CreateStaticClient,       TRUE,   TEXT("StaticClient"),       TRUE,   OBJID_CLIENT    },
    { CreateSwitchClient,       TRUE,   TEXT("SwitchClient"),       TRUE,   OBJID_CLIENT    },

    // Client types - ComCtl32

    { CreateStatusBarClient,    TRUE,   TEXT("StatusBarClient"),    TRUE,   OBJID_CLIENT    },
    { CreateToolBarClient,      TRUE,   TEXT("ToolBarClient"),      TRUE,   OBJID_CLIENT    },
    { CreateProgressBarClient,  TRUE,   TEXT("ProgressBarClient"),  TRUE,   OBJID_CLIENT    },
    { CreateAnimatedClient,     TRUE,   TEXT("AnimatedClient"),     TRUE,   OBJID_CLIENT    },
    { CreateTabControlClient,   TRUE,   TEXT("TabControlClient"),   TRUE,   OBJID_CLIENT    },
    { CreateHotKeyClient,       TRUE,   TEXT("HotKeyClient"),       TRUE,   OBJID_CLIENT    },
    { CreateHeaderClient,       TRUE,   TEXT("HeaderClient"),       TRUE,   OBJID_CLIENT    },
    { CreateSliderClient,       TRUE,   TEXT("SliderClient"),       TRUE,   OBJID_CLIENT    },
    { CreateListViewClient,     TRUE,   TEXT("ListViewClient"),     TRUE,   OBJID_CLIENT    },
    { CreateUpDownClient,       TRUE,   TEXT("UpDownClient"),       TRUE,   OBJID_CLIENT    },
    { CreateToolTipsClient,     TRUE,   TEXT("ToolTipsClient"),     TRUE,   OBJID_CLIENT    },
    { CreateTreeViewClient,     FALSE,  TEXT("TreeViewClient"),     TRUE,   OBJID_CLIENT    },
    { NULL,                     FALSE,  TEXT("CalendarClient"),     TRUE,   OBJID_CLIENT    },
    { CreateDatePickerClient,   TRUE,   TEXT("DatePickerClient"),   TRUE,   OBJID_CLIENT    },
    { CreateIPAddressClient,    TRUE,   TEXT("IPAddressClient"),    TRUE,   OBJID_CLIENT    },


#ifndef OLEACC_NTBUILD
    { CreateHtmlClient,         FALSE,  TEXT("HtmlClient"),         TRUE,   OBJID_CLIENT    },

    // SDM32

    { CreateSdmClientA,         FALSE,  TEXT("SdmClientA"),         TRUE,   OBJID_CLIENT    },
#endif // OLEACC_NTBUILD

    // Window types

    { CreateListBoxWindow,      TRUE,   TEXT("ListBoxWindow"),      TRUE,   OBJID_WINDOW    },
    { CreateMenuPopupWindow,    FALSE,  TEXT("MenuPopupWindow"),    TRUE,   OBJID_WINDOW    },

    // Other classes - these are created directly - and don't appear in the classmaps.
    // Since they're always created directly, their ctor fn.s are NULL here...
    { NULL,                     FALSE,  TEXT("MenuObject"),         TRUE,   0               },
    { NULL,                     FALSE,  TEXT("MenuItemObject"),     TRUE,   0               },
#ifndef OLEACC_NTBUILD
    { NULL,                     FALSE,  TEXT("HtmlImageMap"),       FALSE,  0               },
    { NULL,                     FALSE,  TEXT("SdmList"),            FALSE,  0               },
#endif // OLEACC_NTBUILD
};







#ifdef _DEBUG

class RunTimeCheck
{
public:
    RunTimeCheck()
    {
        Assert( ARRAYSIZE( g_ClassInfo ) == CLASS_LAST );
    }
};

RunTimeCheck g_RunTimeCheck;

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\combo.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  COMBO.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include <olectl.h>
#include "default.h"
#include "window.h"
#include "client.h"
#include "combo.h"


STDAPI_(LPTSTR) MyPathFindFileName(LPCTSTR pPath); // in listbox.cpp

HWND IsInComboEx(HWND hwnd); // in listbox.cpp
BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList ); // inlistbox.cpp

// Variation of HrGetWindowName which never uses a label
// (unlike the original HrGetWindowName which always uses a label if
// the text is an empty string - using label then is not approprite for
// combo value field.)
// Implemented near end of this file. Original is in client.cpp.
HRESULT HrGetWindowNameNoLabel(HWND hwnd, BSTR* pszName);


// --------------------------------------------------------------------------
//
//  CreateComboClient()
//
// --------------------------------------------------------------------------
HRESULT CreateComboClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvCombo)
{
    CCombo * pcombo;
    HRESULT hr;

    InitPv(ppvCombo);
    
    pcombo = new CCombo(hwnd, idChildCur);
    if (!pcombo)
        return(E_OUTOFMEMORY);

    hr = pcombo->QueryInterface(riid, ppvCombo);
    if (!SUCCEEDED(hr))
        delete pcombo;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CCombo::CCombo()
//
// --------------------------------------------------------------------------
CCombo::CCombo(HWND hwnd, long idChildCur)
    : CClient( CLASS_ComboClient )
{
    LONG    lStyle;

    Initialize(hwnd, idChildCur);

    m_cChildren = CCHILDREN_COMBOBOX;
    m_fUseLabel = TRUE;

    // If in a ComboEx, use its style, instead of our own.
    // Important, because the real Combo will be DROPDOWNLIST (doesn't
    // have edit) when the ComboEx is DROPDOWN (has edit) - the ComboEx
    // supplies an EDIT, but the Combo doesn't know about it.
    HWND hWndEx = IsInComboEx(hwnd);
    if (hWndEx)
    {
        lStyle = GetWindowLong(hWndEx, GWL_STYLE);
    }
    else
    {
        lStyle = GetWindowLong(hwnd, GWL_STYLE);
    }

    switch (lStyle & CBS_DROPDOWNLIST)
    {
        case 0:
            m_cChildren = 0;    // Window not valid!
            break;

        case CBS_SIMPLE:
            m_fHasButton = FALSE;
            m_fHasEdit = TRUE;
            break;

        case CBS_DROPDOWN:
            m_fHasButton = TRUE;
            m_fHasEdit = TRUE;
            break;

        case CBS_DROPDOWNLIST:
            m_fHasButton = TRUE;
            m_fHasEdit = FALSE;
            break;
    }
}


// --------------------------------------------------------------------------
//
//  CCombo::get_accChildCount()
//
//  Since this is a known constant, hand directly to CAccessible.  No
//  need to count up fixed + window children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accChildCount(long* pcCount)
{
    return(CAccessible::get_accChildCount(pcCount));
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accChild()
//
//  Succeeds for listbox, and for item if editable.  This is because we
//  manipulate our children by ID, since they are known.  
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
    COMBOBOXINFO cbi;
    HWND    hwndChild;

    InitPv(ppdisp);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    hwndChild = NULL;

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return(E_INVALIDARG);

        case INDEX_COMBOBOX_ITEM:
            hwndChild = cbi.hwndItem;
            break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = cbi.hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
            (void**)ppdisp));
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accName(VARIANT varChild, BSTR* pszName)
{
COMBOBOXINFO cbi;

    InitPv(pszName);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    //
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
    {
        HWND hwndComboEx = IsInComboEx(m_hwnd);
        if( ! hwndComboEx )
        {
            // combo/edit/dropdown all use the name of the client itself,
            // so call through with childid of CHILDID_SELF...
            varChild.lVal = CHILDID_SELF;
            return(CClient::get_accName(varChild, pszName));
        }
        else
        {
            // Special case if we're in a comboex - since we're one level deep,
            // reach up to parent for its name...
            IAccessible * pAcc;
            HRESULT hr = AccessibleObjectFromWindow( hwndComboEx, OBJID_CLIENT, IID_IAccessible, (void **) & pAcc );
            if( hr != S_OK )
                return hr;
            VARIANT varChild;
            varChild.vt = VT_I4;
            varChild.lVal = CHILDID_SELF;
            hr = pAcc->get_accName( varChild, pszName );
            pAcc->Release();
            return hr;
        }
    }
    else
    {
        if (! MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        if (IsWindowVisible(cbi.hwndList))
            return (HrCreateString(STR_DROPDOWN_HIDE,pszName));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszName));
    }
}





// --------------------------------------------------------------------------
//
//  CCombo::get_accValue()
//
//  The value of the combobox and the combobox item is the current text of
//  the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
        {
            // HACK ALERT
            // The IE4 combobox is a superclassed standard combobox,
            // but if I use SendMessageA (which I do) to get the
            // text, I get back garbage. They keep everything
            // in Unicode. It is a bug in the Trident MSHTML 
            // implementation, but even if they fixed it and gave me
            // back an ANSI string, I wouldn't know what code page to
            // use to convert the ANSI string to Unicode - web pages
            // can be in a different language than the one the user's
            // computer uses! Since they already have everything in 
            // Unicode, we decided on a private message that will fill
            // in the Unicode string, and I use that just like I would 
            // normally use WM_GETTEXT.
            // I was going to base this on the classname of the listbox
            // window, which is "Internet Explorer_TridentCmboBx", but
            // the list part of a combo doesn't have a special class
            // name, so instead I am going to base the special case on
            // the file name of the module that owns the window.
            
            // GetWindowModuleFileName(m_hwnd,szModuleName,ARRAYSIZE(szModuleName));
            // lpszModuleName = MyPathFindFileName (szModuleName);
            // if (0 == lstrcmp(lpszModuleName,TEXT("MSHTML.DLL")))
            
            // Update: (BrendanM)
            // GetWindowModuleFilename is broken on Win2k...
            // IsTridentControl goes back to using classnames, and knows
            // how to cope with ComboLBoxes...

            if( IsTridentControl( m_hwnd, TRUE, FALSE ) )
            {
                OLECHAR*    lpszUnicodeText = NULL;
                OLECHAR*    lpszLocalText = NULL;
                HANDLE      hProcess;
                UINT        cch;

                cch = SendMessageINT(m_hwnd, OCM__BASE + WM_GETTEXTLENGTH, 0, 0);

                lpszUnicodeText = (OLECHAR *)SharedAlloc((cch+1)*sizeof(OLECHAR),
                                                         m_hwnd,
                                                         &hProcess);
                lpszLocalText = (OLECHAR*)LocalAlloc(LPTR,(cch+1)*sizeof(OLECHAR));

                if (!lpszUnicodeText || !lpszLocalText)
                    return(E_OUTOFMEMORY);

                cch = SendMessageINT(m_hwnd, OCM__BASE + WM_GETTEXT, cch, (LPARAM)lpszUnicodeText);
                SharedRead (lpszUnicodeText,lpszLocalText,(cch+1)*sizeof(OLECHAR),hProcess);

                *pszValue = SysAllocString(lpszLocalText);

                SharedFree(lpszUnicodeText,hProcess);
                LocalFree(lpszLocalText);
                return (S_OK);
            }
            else
            {
                // If we're a comboex, ask the comboex instead of us...
                HWND hwnd;
                if( ! ( hwnd = IsInComboEx( m_hwnd ) ) )
                    hwnd = m_hwnd;
                    
                // uh-oh - don't want to use HrGetWindowName, since
                // it will look for a label (even though we specify FALSE)
                // if we are in a dialog and out text is "".
                if( ! IsComboEx( hwnd ) )
                {
                    // Regular combo - gettext works for both edit and droplist...
                    return HrGetWindowNameNoLabel( hwnd, pszValue);
                }
                else
                {
                    // comboex - special case for droplist...
                    DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
                    if( ! ( dwStyle & CBS_DROPDOWNLIST ) )
                    {
                        // Not a droplist - can use normal technique...
                        return HrGetWindowNameNoLabel( hwnd, pszValue);
                    }
                    else
                    {
                        // Get the selected item, and get its text...
                        int iSel = SendMessageINT( hwnd, CB_GETCURSEL, 0, 0 );
                        if( iSel == CB_ERR )
                            return S_FALSE; // no item selected

                        int cch = SendMessageINT( hwnd, CB_GETLBTEXTLEN, iSel, 0);

                        // Some apps do not handle CB_GETTEXTLEN correctly, and
                        // always return a small number, like 2.
		                if (cch < 1024)
			                cch = 1024;

                        LPTSTR lpszText;
                        lpszText = (LPTSTR)LocalAlloc(LPTR, (cch+1)*sizeof(TCHAR));
                        if (!lpszText)
                            return(E_OUTOFMEMORY);

                        SendMessage( hwnd, CB_GETLBTEXT, iSel, (LPARAM)lpszText);
                        *pszValue = TCharSysAllocString(lpszText);

                        LocalFree((HANDLE)lpszText);

                        return S_OK;
                    }
                }
            }
        }
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (m_fHasEdit)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of combo box") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accState()
//
//  The state of the combo is the state of the client.
//  The state of the item is the state of the edit field if present; 
//      read-only if static.
//  The state of the button is pushed and/or hottracked.
//  The state of the dropdown is floating (if not simple) and the state
//      of the list window.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    COMBOBOXINFO    cbi;
    VARIANT         var;
    IAccessible* poleacc;
    HRESULT         hr;
    HWND            hwndActive;

    InitPvar(pvarState);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = STATE_SYSTEM_INVISIBLE;
        return(S_FALSE);
    }

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return(CClient::get_accState(varChild, pvarState));

        case INDEX_COMBOBOX_BUTTON:
            pvarState->vt = VT_I4;
            pvarState->lVal = cbi.stateButton;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (!cbi.hwndItem)
            {
                pvarState->vt = VT_I4;
                pvarState->lVal = 0;
                hwndActive = GetForegroundWindow();
                if (hwndActive == MyGetAncestor(m_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (MyGetFocus() == m_hwnd)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }
            else
            {
                // Forward state to edit field.
                VariantInit(&var);
                hr = GetWindowObject(cbi.hwndItem, &var);
                goto AskTheChild;
            }
            break;

        case INDEX_COMBOBOX_LIST:
            // Forward state to listbox
            VariantInit(&var);
            hr = GetWindowObject(cbi.hwndList, &var);

AskTheChild:
            if (!SUCCEEDED(hr))
                return(hr);

            Assert(var.vt == VT_DISPATCH);

            //
            // Get the child acc object
            //
            poleacc = NULL;
            hr = var.pdispVal->QueryInterface(IID_IAccessible,
                (void**)&poleacc);
            var.pdispVal->Release();

            if (!SUCCEEDED(hr))
                return(hr);

            //
            // Ask the child its state
            //
            VariantInit(&var);
            hr = poleacc->get_accState(var, pvarState);
            poleacc->Release();
            if (!SUCCEEDED(hr))
                return(hr);
            break;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    TCHAR   szKey[20];

    //
    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
    //

    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == INDEX_COMBOBOX || varChild.lVal == INDEX_COMBOBOX_ITEM)
    {
        HWND hwndComboEx = IsInComboEx(m_hwnd);
        if( ! hwndComboEx )
        {
            // combo/edit/dropdown all use the name of the client itself,
            // so call through with childid of CHILDID_SELF...
            varChild.lVal = CHILDID_SELF;
            return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
        }
        else
        {
            // Special case if we're in a comboex - since we're one level deep,
            // reach up to parent for its name...
            IAccessible * pAcc;
            HRESULT hr = AccessibleObjectFromWindow( hwndComboEx, OBJID_CLIENT, IID_IAccessible, (void **) & pAcc );
            if( hr != S_OK )
                return hr;
            VARIANT varChild;
            varChild.vt = VT_I4;
            varChild.lVal = CHILDID_SELF;
            hr = pAcc->get_accKeyboardShortcut( varChild, pszShortcut );
            pAcc->Release();
            return hr;
        }
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        if (m_fHasButton)
        {
            LoadString(hinstResDll, STR_COMBOBOX_LIST_SHORTCUT, szKey,
                ARRAYSIZE(szKey));
            return(HrMakeShortcut(szKey, pszShortcut));
        }
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::get_accDefaultAction(VARIANT varChild, BSTR* pszDef)
{
    COMBOBOXINFO cbi;

    InitPv(pszDef);

    //
    // Validate parameters
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON) || !m_fHasButton)
        return(E_NOT_APPLICABLE);

    //
    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    //
    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    if (IsWindowVisible(cbi.hwndList))
        return(HrCreateString(STR_DROPDOWN_HIDE, pszDef));
    else
        return(HrCreateString(STR_DROPDOWN_SHOW, pszDef));
}



// --------------------------------------------------------------------------
//
//  CCombo::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    COMBOBOXINFO    cbi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (!m_fHasButton)
                return(S_FALSE);

            *pcxWidth = cbi.rcButton.right - cbi.rcButton.left;
            *pcyHeight = cbi.rcButton.bottom - cbi.rcButton.top;

            ClientToScreen(m_hwnd, (LPPOINT)&cbi.rcButton);

            *pxLeft = cbi.rcButton.left;
            *pyTop = cbi.rcButton.top;
            break;

        case INDEX_COMBOBOX_ITEM:
            *pcxWidth = cbi.rcItem.right - cbi.rcItem.left;
            *pcyHeight = cbi.rcItem.bottom - cbi.rcItem.top;
            
            ClientToScreen(m_hwnd, (LPPOINT)&cbi.rcItem);

            *pxLeft = cbi.rcItem.left;
            *pyTop = cbi.rcItem.top;
            break;

        case INDEX_COMBOBOX_LIST:
            MyGetRect(cbi.hwndList, &cbi.rcItem, TRUE);
            *pxLeft = cbi.rcItem.left;
            *pyTop = cbi.rcItem.top;
            *pcxWidth = cbi.rcItem.right - cbi.rcItem.left;
            *pcyHeight = cbi.rcItem.bottom - cbi.rcItem.top;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of combo box") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::accNavigate()
//
//  Navigates among children of combobox.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    COMBOBOXINFO    cbi;
    long            lEnd;

    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNav, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    lEnd = 0;

    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNav, varStart, pvarEnd));

    //
    // Map HWNDID to normal ID.  We work with both (it is easier).
    //
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(m_hwnd, varStart.lVal);

        if (hWndTemp == cbi.hwndItem)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == cbi.hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) &&
                IsWindowVisible(cbi.hwndList))
            {
                lEnd = INDEX_COMBOBOX_LIST;
            }
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM) &&
               !(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
            {
               lEnd = INDEX_COMBOBOX_BUTTON;
            }   
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !IsWindowVisible(cbi.hwndList))
                --lEnd;
            if ((lEnd == INDEX_COMBOBOX_BUTTON) && !m_fHasButton)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            else
            {
                if ((lEnd == INDEX_COMBOBOX_BUTTON) && !m_fHasButton)
                    lEnd++;
                if ((lEnd == INDEX_COMBOBOX_LIST) && !IsWindowVisible(cbi.hwndList))
                    lEnd = 0;
            }
            break;
    }

GetTheChild:
    if (lEnd)
    {
        if ((lEnd == INDEX_COMBOBOX_ITEM) && cbi.hwndItem)
            return(GetWindowObject(cbi.hwndItem, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST) && cbi.hwndList)
            return(GetWindowObject(cbi.hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CCombo::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accHitTest(long x, long y, VARIANT* pvarEnd)
{
    POINT   pt;
    COMBOBOXINFO cbi;
    RECT    rc;

    InitPvar(pvarEnd);

    if (!MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    pt.x = x;
    pt.y = y;

    // Check list first, in case it is a dropdown.
    MyGetRect(cbi.hwndList, &rc, TRUE);
    if (PtInRect(&rc, pt) && IsWindowVisible(cbi.hwndList))
        return(GetWindowObject(cbi.hwndList, pvarEnd));
    else
    {
        ScreenToClient(m_hwnd, &pt);
        MyGetRect(m_hwnd, &rc, FALSE);
        if (! PtInRect(&rc, pt))
            return(S_FALSE);

        if (PtInRect(&cbi.rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else if (PtInRect(&cbi.rcItem, pt))
        {
            if (m_fHasEdit)
                return(GetWindowObject(cbi.hwndItem, pvarEnd));
            else
            {
                pvarEnd->vt = VT_I4;
                pvarEnd->lVal = INDEX_COMBOBOX_ITEM;
            }
        }
        else
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::accDoDefaultAction()
//
//  The default action of the button is to toggle the dropdown list up or 
//  down.  Note that we don't just pop up the listbox, we pop it up AND
//  accept amu changes in the selected item..
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::accDoDefaultAction(VARIANT varChild)
{
    COMBOBOXINFO    cbi;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON) && m_fHasButton)
    {
        if (!MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        if (IsWindowVisible(cbi.hwndList))
            PostMessage(m_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(m_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CCombo::put_accValue()
//
//  This works if (1) the combo is editable or (2) the text matches a list
//  item exactly.
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::put_accValue(VARIANT varChild, BSTR szValue)
{
    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// On unicode, no conversion needed...
	lpszValue = szValue;

#else

	// On non-unicode, need to convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif

    //
    // If this is editable, set the text directly.  If this is a dropdown
    // list, select the exact match for this text.
    //
    if (m_fHasEdit)
        SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);
    else
        SendMessage(m_hwnd, CB_SELECTSTRING, (UINT)-1, (LPARAM)lpszValue);

#ifndef UNICODE
	// On non-unicode, free the temp string we alloc'd above...
    LocalFree((HANDLE)lpszValue);
#endif

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCombo::Next()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    return(CAccessible::Next(celt, rgvar, pceltFetched));
}


// --------------------------------------------------------------------------
//
//  CCombo::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCombo::Skip(ULONG celt)
{
    return(CAccessible::Skip(celt));
}








// --------------------------------------------------------------------------
//
//  HrGetWindowNameNoLabel()
//
//  This variation of HrGetWindowName (originally from client.cpp)
//  never uses a label. (HrGetWindowName would alway use a label
//  if window text was "" and window was in a dialog. That's not
//  appropriate for getting combo value text, though...)
//
// --------------------------------------------------------------------------
HRESULT HrGetWindowNameNoLabel(HWND hwnd, BSTR* pszName)
{
    LPTSTR  lpText = NULL;

    if( ! IsWindow( hwnd ) )
        return E_INVALIDARG;

    // Look for a name property!
    lpText = GetTextString( hwnd, FALSE );
    if( ! lpText )
        return S_FALSE;

    // Strip out the mnemonic.
    StripMnemonic(lpText);

    // Get a BSTR
    *pszName = TCharSysAllocString( lpText );

    // Free our buffer
    LocalFree( (HANDLE)lpText );

    // Did the BSTR succeed?
    if( ! *pszName )
        return E_OUTOFMEMORY;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\combo.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  COMBO.H
//
//  Combobox object
//
// --------------------------------------------------------------------------

//
// NOTE:
// Since a combobox has a known # of children (elements and objects), we
// can simplify our life a lot by not deferring to CClient for things like
// the child count property.  We accept IDs for all relevant properties
// even if the ID is of a child object.
//
class   CCombo: public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accChildCount(long* pcCount);
        virtual STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        virtual STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP        accHitTest(long, long, VARIANT*);
        virtual STDMETHODIMP        accDoDefaultAction(VARIANT);

        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);

        // IEnumVARIANT
        STDMETHODIMP        Next(ULONG, VARIANT*, ULONG*);
        STDMETHODIMP        Skip(ULONG);

        CCombo(HWND, long);

    private:
        BOOL    m_fHasButton:1;
        BOOL    m_fHasEdit:1;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\cursor.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CURSOR.H
//
//  Cursor OLE Accessibility implementation
//
// --------------------------------------------------------------------------


class   CCursor :   public  CAccessible
{
    public:

        CCursor()
            : CAccessible( CLASS_CursorObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        accLocation(long* pxLeft, long* pyTop,
            long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT * pvarChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT * * ppenum);
};


long    MapCursorIndex(HCURSOR hCur);
HRESULT CreateCursorThing(REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\com_atlmain.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// com_atlmain.cpp : Implementation of DLL Exports.
//
// This handles all COM-based entry points - eg.
// requests for the external CAccPropServices, or the
// internal CRemoteProxyFactory.
//
// This file is a modified ATL "mainline". The main
// exports (eg. DllGetclassObject) have had "ComATLMain_"
// prepended to their names, and are chained by the real
// entrypoints in oleacc.cpp.
//
// Note that the DllGetClassObject in this file also
// calls InitOleacc(), to ensure that OLEACC is init'd
// before it is used by the object.


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

extern CComModule _Module;
#include <atlcom.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "resource.h"
#include "RemoteProxy6432.h"

#include "RemoteProxyFactory.h"

#include "PropMgr_Impl.h"


CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
#ifdef _WIN64
	OBJECT_ENTRY(CLSID_RemoteProxyFactory64, CRemoteProxyFactory)
#else
	OBJECT_ENTRY(CLSID_RemoteProxyFactory32, CRemoteProxyFactory)
#endif
	OBJECT_ENTRY(CLSID_AccPropServices, CPropMgr)
END_OBJECT_MAP()



extern "C"
BOOL WINAPI ComATLMain_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_REMOTEPROXY6432Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllRegisterServer()
//
// Handles registering the proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllRegisterServer()
{
	// By default, ATL only registers/unregisters the first tlb in the DLL's
    // resource, but we need to explicitly reg/unreg the second one - the
    // bitness proxy factory. (The first one is the oleacc/IAccessible tlb.)
	ITypeLib *pTypeLib = NULL;
    OLECHAR	wszProxyFactoryTlb[] = L"oleacc.dll\\2";
	HRESULT hr;

	hr = LoadTypeLib( wszProxyFactoryTlb, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
		hr = RegisterTypeLib( pTypeLib, wszProxyFactoryTlb, NULL );
        pTypeLib->Release();

		// let ATL do the rest of the registration stuff.
        // FALSE here means don't register TLBs - we've done that above.
		hr = _Module.RegisterServer(FALSE);
	}

    return hr;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllDllUnregisterServer()
//
// Handles unregistering the proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllUnregisterServer()
{
	// By default, ATL only registers/unregisters the first tlb in the DLL's
    // resource, but we need to explicitly reg/unreg the second one - the
    // bitness proxy factory. (The first one is the oleacc/IAccessible tlb.)
	ITypeLib *pTypeLib = NULL;
    OLECHAR	wszProxyFactoryTlb[] = L"oleacc.dll\\2";
	HRESULT hr;

	hr = LoadTypeLib( wszProxyFactoryTlb, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
        TLIBATTR * ptla;
        hr = pTypeLib->GetLibAttr( & ptla );
        if( SUCCEEDED( hr ) )
        {
    		hr = UnRegisterTypeLib( ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind );
            pTypeLib->ReleaseTLibAttr( ptla );
        }

        pTypeLib->Release();

		// let ATL do the rest of the unregistration stuff...
        // FALSE here means don't unregister TLBs - we've done that above.
		hr = _Module.UnregisterServer(FALSE);
	}

    return hr;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllCanUnloadNow()
//
// Handles returning whether the proxy factory can be unloaded or not
//
extern "C"
HRESULT WINAPI ComATLMain_DllCanUnloadNow()
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

// ----------------------------------------------------------------------------
// ProxyFactoryDllGetClassObject()
//
// The is the class factory for the bitness proxy factory
//
extern "C"
HRESULT WINAPI ComATLMain_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // guarrantee that oleacc is initialized prior to using it
    InitOleacc();
    return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\cursor.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  CURSOR.CPP
//
//  This file has the implementations of the cursor system objects.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "cursor.h"

long        fCursorDataInit = FALSE;
HCURSOR     rghcurSystem[CCURSOR_SYSTEM] =
{
    (HCURSOR)IDC_ARROW,
    (HCURSOR)IDC_IBEAM,
    (HCURSOR)IDC_WAIT,
    (HCURSOR)IDC_CROSS,
    (HCURSOR)IDC_UPARROW,
    (HCURSOR)IDC_SIZENWSE,
    (HCURSOR)IDC_SIZENESW,
    (HCURSOR)IDC_SIZEWE,
    (HCURSOR)IDC_SIZENS,
    (HCURSOR)IDC_SIZEALL,
    (HCURSOR)IDC_NO,
    (HCURSOR)IDC_APPSTARTING,
    (HCURSOR)IDC_HELP,
    (HCURSOR)MAKEINTRESOURCE(32631)
};


// --------------------------------------------------------------------------
//
//  MapCursorIndex()
//
// --------------------------------------------------------------------------
long MapCursorIndex(HCURSOR hcur)
{
    long iIndex;
    int iCur;

    iIndex = CURSOR_SYSTEM_UNKNOWN;

    for (iCur = 0; iCur < CCURSOR_SYSTEM; iCur++)
    {
        if (rghcurSystem[iCur] == hcur)
        {
            iIndex = iCur+1;
            break;
        }
    }

    return(iIndex);
}



// --------------------------------------------------------------------------
//
//  CreateCursorObject()
//
// --------------------------------------------------------------------------
HRESULT CreateCursorObject(HWND hwnd, long idObject, REFIID riid, void** ppvCursor)
{
    UNUSED(hwnd);
    UNUSED(idObject);

    if (! InterlockedExchange(&fCursorDataInit, TRUE))
    {
        int icur;

        for (icur = 0; icur < CCURSOR_SYSTEM; icur++)
        {
            rghcurSystem[icur] = LoadCursor(NULL, (LPTSTR)rghcurSystem[icur]);
        }
    }

    return(CreateCursorThing(riid, ppvCursor));
}



// --------------------------------------------------------------------------
//
//  CCursor::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::Clone(IEnumVARIANT** ppenum)
{
    return(CreateCursorThing(IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CreateCursorThing()
//
// --------------------------------------------------------------------------
HRESULT CreateCursorThing(REFIID riid, void** ppvCursor)
{
    CCursor * pcursor;
    HRESULT hr;

    InitPv(ppvCursor);

    pcursor = new CCursor();
    if (!pcursor)
        return(E_OUTOFMEMORY);

    hr = pcursor->QueryInterface(riid, ppvCursor);
    if (!SUCCEEDED(hr))
        delete pcursor;

    return(hr);
}

                                                                      

// --------------------------------------------------------------------------
//
//  CCursor::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accName(VARIANT varChild, BSTR* pszName)
{
    CURSORINFO   ci;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetCursorInfo(&ci);

    return(HrCreateString(STR_CURSORNAMEFIRST+MapCursorIndex(ci.hCursor),
        pszName));
}



// --------------------------------------------------------------------------
//
//  CCursor::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_CURSOR;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCursor::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    CURSORINFO  ci;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    MyGetCursorInfo(&ci);

    if (!(ci.flags & CURSOR_SHOWING))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    pvarState->lVal |= STATE_SYSTEM_FLOATING;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CCursor::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    CURSORINFO  ci;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    MyGetCursorInfo(&ci);

    *pxLeft = ci.ptScreenPos.x;
    *pyTop = ci.ptScreenPos.y;
    *pcxWidth = 1;
    *pcyHeight = 1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CCursor::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CCursor::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    CURSORINFO  ci;

    InitPvar(pvarChild);

    MyGetCursorInfo(&ci);

    if ((xLeft == ci.ptScreenPos.x) && (yTop == ci.ptScreenPos.y))
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = 0;
        return(S_OK);
    }

    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\ctors.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  Ctors
//
//  Contains prototypes for all the CreateXXXObject functions.
//
// --------------------------------------------------------------------------


// These look up the classmap to create the appropriate proxy type.
// (CreateClient and CreateWindowThing create just the raw client/window
// proxies.)
HRESULT CreateClientObject(HWND, long, REFIID, void**);
HRESULT CreateWindowObject(HWND, long, REFIID, void**);



//
// General non-client stuff
//
HRESULT CreateCaretObject(HWND, long, REFIID, void**);
HRESULT CreateClient(HWND, long, REFIID, void**);
HRESULT CreateCursorObject(HWND, long, REFIID, void**);
HRESULT CreateMenuBarObject(HWND, long, REFIID, void**);
HRESULT CreateScrollBarObject(HWND, long, REFIID, void**);
HRESULT CreateSizeGripObject(HWND, long, REFIID, void**);
HRESULT CreateSysMenuBarObject(HWND, long, REFIID, void**);
HRESULT CreateTitleBarObject(HWND, long, REFIID, void**);
HRESULT CreateWindowThing(HWND, long, REFIID, void**);


//
// Client types
//

// USER
HRESULT CreateButtonClient(HWND, long, REFIID, void**);
HRESULT CreateComboClient(HWND, long, REFIID, void**);
HRESULT CreateDialogClient(HWND, long, REFIID, void**);
HRESULT CreateDesktopClient(HWND, long, REFIID, void**);
HRESULT CreateEditClient(HWND, long, REFIID, void**);
HRESULT CreateListBoxClient(HWND, long, REFIID, void**);
HRESULT CreateMDIClient(HWND, long, REFIID, void**);
HRESULT CreateMenuPopupClient(HWND, long, REFIID, void**);
HRESULT CreateScrollBarClient(HWND, long, REFIID, void**);
HRESULT CreateStaticClient(HWND, long, REFIID, void**);
HRESULT CreateSwitchClient(HWND, long, REFIID, void**);

// COMCTL32
HRESULT CreateStatusBarClient(HWND, long, REFIID, void**);
HRESULT CreateToolBarClient(HWND, long, REFIID, void**);
HRESULT CreateProgressBarClient(HWND, long, REFIID, void**);
HRESULT CreateAnimatedClient(HWND, long, REFIID, void**);
HRESULT CreateTabControlClient(HWND, long, REFIID, void**);
HRESULT CreateHotKeyClient(HWND, long, REFIID, void**);
HRESULT CreateHeaderClient(HWND, long, REFIID, void**);
HRESULT CreateSliderClient(HWND, long, REFIID, void**);
HRESULT CreateListViewClient(HWND, long, REFIID, void**);
HRESULT CreateUpDownClient(HWND, long, REFIID, void**);
HRESULT CreateToolTipsClient(HWND, long, REFIID, void**);
HRESULT CreateTreeViewClient(HWND, long, REFIID, void**);
HRESULT CreateCalendarClient(HWND, long, REFIID, void**);
HRESULT CreateDatePickerClient(HWND, long, REFIID, void**);
HRESULT CreateIPAddressClient(HWND, long, REFIID, void**);

#ifndef OLEACC_NTBUILD
HRESULT CreateHtmlClient(HWND, long, REFIID, void**);

// SDM32
HRESULT CreateSdmClientA(HWND, long, REFIID, void**);
#endif // OLEACC_NTBUILD


//
// Window types
//
HRESULT CreateListBoxWindow(HWND, long, REFIID, void**);
HRESULT CreateMenuPopupWindow(HWND, long, REFIID, void**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\datepicker.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DatePicker.CPP
//
//  DatePicker client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "window.h"
#include "DatePicker.h"


// --------------------------------------------------------------------------
//
//  CreateDatePickerClient()
//
//  EXTERNAL for CClient.
//
// --------------------------------------------------------------------------
HRESULT CreateDatePickerClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvDatePicker)
{
    CDatePicker * pDatePicker;
    HRESULT hr;

    InitPv(ppvDatePicker);

    pDatePicker = new CDatePicker( hwnd, idChildCur );
    if ( !pDatePicker )
        return(E_OUTOFMEMORY);

    hr = pDatePicker->QueryInterface( riid, ppvDatePicker );
    if ( !SUCCEEDED(hr) )
        delete ppvDatePicker;

    return hr;
}



// --------------------------------------------------------------------------
//
//  CDatePicker::CDatePicker()
//
// --------------------------------------------------------------------------
CDatePicker::CDatePicker(HWND hwnd, long idChildCur)
    : CClient( CLASS_DatePickerClient )
{
    Initialize( hwnd, idChildCur );

	m_fUseLabel = TRUE;

}


// --------------------------------------------------------------------------
//
//  CDatePicker::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDatePicker::get_accValue( VARIANT varChild, BSTR* pszValue )
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;


    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CDatePicker::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDatePicker::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
	pvarRole->lVal = ROLE_SYSTEM_DROPLIST;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\datepicker.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DatePicker.H
//
//  Default DatePicker OLE ACC Client
//
// --------------------------------------------------------------------------


class CDatePicker : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accRole( VARIANT varChild, VARIANT* pvarRole );
		STDMETHODIMP		get_accValue( VARIANT varChild, BSTR* pszValue );

        CDatePicker( HWND, long );

    protected:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\debug.h ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  debug
//
//  Assert, OutputDebugString-like replacements
//
//
//  On NT, these use OutputDebugString; on 9x, the DBWIN32 mutex is used.
//
//  These all compile away to nothing in release builds.
//  (In future releases, some of the parameter errors may remain on release
//  builds.)
//
//  On release builds, ouput is only produces if the mutex
//  "oleacc-msaa-use-dbwin" exists. (A small applet can be used to create
//  this mutex.) This prevents our debug code from annoying the NT test and
//  stress people who only want to see critical messages.
//
// --------------------------------------------------------------------------
//
//  Trace functionality - these output debug strings.
//
//
//  To log an error, use:
//
//      TraceError( format string, optional-args... );
//
//  uses printf-like format string with variable number of args.
//
//  If a HRESULT is known, use:
//      TraceErrorHR( hr, format string, args... );
//
//  If the error is the result of a failed Win32 API call, use...
//      TraceErrorW32( format string, args... );
//
//  This will call GetLastError internally.
//
//  Flavors available: (eg. TraceXXXX)
//  
//    Debug     - temporary printf debugging. Should be removed before checkin.
//    Info      - for displaying useful information during normal operation.
//    Warning   - when an unexpected recoverable error happens.
//    Error     - when system API or method calls fail unexpectedly
//    Param     - when bad parameters are passed in which result in an error
//    ParamWarn - when bad parameters are passed in which we accept for compat
//                reasons; or when soon-to-be-deprecated values are used.
//    Interop   - when API or method of some other component which we rely on 
//                fails unexpectedly
//
// --------------------------------------------------------------------------
//
//  Call/Return tracking
//
//  To track when a particular method is called and returns, use:
//
//      void Class::Method( args )
//      {
//          IMETHOD( methodname, optional-fmt-string, optional-args... );
//
//  Use SMETHOD for static methods and functions. (IMETHOD also reports the
//  value of the 'this' pointer.)
//
// --------------------------------------------------------------------------
//
//  Asserts
//
//  Assert( cond )
//    - Traditional assert.
//
//  AssertMsg( cond, fmt-string, args... )
//    - Assert which reports message. Uses printf-style format.
//
//  AssertStr( str )
//    - This exists for compat reasons - it was already used in oleacc code.
//      This is an unconditional assert, equivalent to
//      AssertMsg( FALSE, str )
//
// --------------------------------------------------------------------------
//
//  Note that all strings - format strings and method names - need TEXT()
//  to compile as Unicode.
//
// --------------------------------------------------------------------------

#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <stdarg.h>


#define _TRACE_DEBUG    0
#define _TRACE_INFO     1
#define _TRACE_WARNING  2
#define _TRACE_ERROR    3

#define _TRACE_PARAM    4
#define _TRACE_PARAWARN 5
#define _TRACE_INTEROP  6

#define _TRACE_ASSERT_D 7   // Debug-build assert - really does assert
#define _TRACE_ASSERT_R 8   // Release-build assert - only logs error, doesn't halt program

#define _TRACE_CALL     9
#define _TRACE_RET      10


// These are implemented in debug.cpp, and do the real work of outputting the
// debug message, and calling DebugBreak, if appropriate.
// 
// HR, W32 versions add messages corresponding to HRESULT or GetLastError().

void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist );
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr, va_list alist );
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist );

void _Trace     ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr );
void _TraceHR   ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr );
void _TraceW32  ( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr );




// Prototypes for the macros defined here.
//
// These are not actually used - they are only here to give VC's autocomplete some
// prototypes to work with for autocomplete.
//
// The real work is done by the #defines below.
//
// Note that these must appear *before* their #defines in this file.
//
void IMETHOD( LPCTSTR pszMethodName, LPCTSTR pszStr = TEXT(""), ... );

void Assert( bool cond );
void AssertMsg( bool cond, LPCTSTR str, ... );
void AssertStr( LPCTSTR str );

void TraceDebug( LPCTSTR str, ... );
void TraceInfo( LPCTSTR str, ... );
void TraceWarning( LPCTSTR str, ... );
void TraceError( LPCTSTR str, ... );
void TraceParam( LPCTSTR str, ... );
void TraceParamWarn( LPCTSTR str, ... );
void TraceInterop( LPCTSTR str, ... );

void TraceDebugHR( HRESULT hr, LPCTSTR str, ... );
void TraceInfoHR( HRESULT hr, LPCTSTR str, ... );
void TraceWarningHR( HRESULT hr, LPCTSTR str, ... );
void TraceErrorHR( HRESULT hr, LPCTSTR str, ... );
void TraceParamHR( HRESULT hr, LPCTSTR str, ... );
void TraceParamWarnHR( HRESULT hr, LPCTSTR str, ... );
void TraceInteropHR( HRESULT hr, LPCTSTR str, ... );

void TraceDebugW32( LPCTSTR str, ... );
void TraceInfoW32( LPCTSTR str, ... );
void TraceWarningW32( LPCTSTR str, ... );
void TraceErrorW32( LPCTSTR str, ... );
void TraceParamW32( LPCTSTR str, ... );
void TraceParamWarnW32( LPCTSTR str, ... );
void TraceInteropW32( LPCTSTR str, ... );




#ifdef _DEBUG

    //  Problem - #define's can't handle variable number of arguments - so you can't do:
    //
    //      #define TraceError( str, ... )   RealTrace( __FILE__, __LINE__, str, ... )
    //
    //  Instead, we use a helper class. Its ctor takes as arguments __FILE__,
    //  __LINE__, and any other 'out of band' data. This class also has a
    //  method that takes a variable number of params. So we get something like:
    //
    //      #define TraceError               TraceClass( __FILE__, __LINE__ ).Method
    //
    //
    //  This method ends up being called with the variable list of params:
    //
    //      TraceError( "count is %d", count )
    //
    //  ...gets expanded to...
    //
    //      TraceClass( __FILE__, __LINE__ ).Method( "count is %d", count )
    //
    //  The basic idea is the we use ctor params to capture any 'out-of-band'
    //  data that's not specified in the macro parameters; and then use the
    //  method call to add in the variable-length macro params.
    //
    //  The method can use the <stdarg.h> ,acros to get a va_list for these params,
    //  and then pass that to the RealTrace function, along with the __FILE__ and
    //  __LINE__ which were collected in the ctor.

    class _TraceHelper
    {
        LPCTSTR         m_pszFile;
        ULONG           m_uLineNo;
        DWORD           m_dwLevel;
        const void *    m_pThis;
    public:

        _TraceHelper( LPCTSTR pszFile, ULONG uLineNo, DWORD dwLevel, const void * pThis )
            : m_pszFile( pszFile ),
              m_uLineNo( uLineNo ),
              m_dwLevel( dwLevel ),
              m_pThis( pThis )
        {
            // Done.
        }

        // Can't use plain "BOOL cond" here, since ptr types don't convert to BOOL
        // (which is an int), even though you can use them in an if statement.
        template < typename T >
        void TraceIfCondFails ( T cond, LPCTSTR pszStr, ... )
        {
            if( ! cond )
            {
                va_list alist;
                va_start( alist, pszStr );
                _Trace( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
                va_end( alist );
            }
        }

        void Trace ( LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _Trace( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
            va_end( alist );
        }

        void TraceHR ( HRESULT hr, LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _TraceHR( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, hr, pszStr, alist );
            va_end( alist );
        }

        void TraceW32 ( LPCTSTR pszStr, ... )
        {
            va_list alist;
            va_start( alist, pszStr );
            _TraceW32( m_pszFile, m_uLineNo, m_dwLevel, m_pThis, NULL, pszStr, alist );
            va_end( alist );
        }
    };




    class _DebugCallRetTracker
    {
        const void *    m_pThis;
        LPCTSTR         m_pszMethodName;
        LPCTSTR         m_pszFile;
        ULONG           m_uLineNo;

    public:

        _DebugCallRetTracker( const void * pThis, LPCTSTR pszFile, ULONG uLineNo )
            : m_pThis( pThis ),
              m_pszMethodName( NULL ),
              m_pszFile( pszFile ),
              m_uLineNo( uLineNo )
        {
            // Done.
        }

        void Trace( LPCTSTR pszMethodName, LPCTSTR pszStr = NULL, ... )
        {
            m_pszMethodName = pszMethodName;

            va_list alist;
            va_start( alist, pszStr );
            _Trace( m_pszFile, m_uLineNo, _TRACE_CALL, m_pThis, m_pszMethodName, pszStr, alist );
            va_end( alist );
        }

        ~_DebugCallRetTracker( )
        {
            _Trace( m_pszFile, m_uLineNo, _TRACE_RET, m_pThis, m_pszMethodName, NULL ); 
        }
    };



#define IMETHOD                           _DebugCallRetTracker _CallTrack_temp_var( this, TEXT( __FILE__ ), __LINE__ ); _CallTrack_temp_var.Trace
#define SMETHOD                           _DebugCallRetTracker _CallTrack_temp_var( NULL, TEXT( __FILE__ ), __LINE__ ); _CallTrack_temp_var.Trace
#define _TraceM( file, line, level, fn )  _TraceHelper( TEXT( file ), line, level, NULL ).fn
#define _TRACE_ASSERT                     _TRACE_ASSERT_D

#else // _DEBUG

// This inline allows us to swallow a variable number of args (including 0).
// The "while(0)" in front of it stops those args from even being evaluated.
// Using _ReurnZero() avoids "conditional expression is constant" warning. 
inline void _DoNothingWithArgs( ... ) { }
inline int _ReturnZero() { return 0; }

#define IMETHOD                            while( _ReturnZero() ) _DoNothingWithArgs
#define SMETHOD                            while( _ReturnZero() ) _DoNothingWithArgs
#define _TraceM( file, line, level, fn )   while( _ReturnZero() ) _DoNothingWithArgs
#define _TRACE_ASSERT                      _TRACE_ASSERT_R

#endif // _DEBUG




// These expand as follows:
//
// Sample usage:
//
//      TraceInfo( TEXT("count = %d"), count );
//
// In debug mode, this gets expanded to:
//
//      _TraceHelper( TEXT( "filename.cpp" ), 234, _TRACE_INFO, NULL ).Trace ( TEXT("count = %d"), count );
//
// In release mode, this gets expanded to:
//
//      while( 0 ) _DoNothing ( TEXT("count = %d"), count );

#define TraceDebug          _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     Trace )
#define TraceInfo           _TraceM( __FILE__, __LINE__, _TRACE_INFO,      Trace )
#define TraceWarning        _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   Trace )
#define TraceError          _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     Trace )
#define TraceParam          _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     Trace )
#define TraceParamWarn      _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, Trace )
#define TraceInterop        _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   Trace )

#define TraceDebugHR        _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     TraceHR )
#define TraceInfoHR         _TraceM( __FILE__, __LINE__, _TRACE_INFO,      TraceHR )
#define TraceWarningHR      _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   TraceHR )
#define TraceErrorHR        _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     TraceHR )
#define TraceParamHR        _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     TraceHR )
#define TraceParamWarnHR    _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, TraceHR )
#define TraceInteropHR      _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   TraceHR )

#define TraceDebugW32       _TraceM( __FILE__, __LINE__, _TRACE_DEBUG,     TraceW32 )
#define TraceInfoW32        _TraceM( __FILE__, __LINE__, _TRACE_INFO,      TraceW32 )
#define TraceWarningW32     _TraceM( __FILE__, __LINE__, _TRACE_WARNING,   TraceW32 )
#define TraceErrorW32       _TraceM( __FILE__, __LINE__, _TRACE_ERROR,     TraceW32 )
#define TraceParamW32       _TraceM( __FILE__, __LINE__, _TRACE_PARAM,     TraceW32 )
#define TraceParamWarnW32   _TraceM( __FILE__, __LINE__, _TRACE_PARAMWARN, TraceW32 )
#define TraceInteropW32     _TraceM( __FILE__, __LINE__, _TRACE_INTEROP,   TraceW32 )


#define Assert( cond )      _TraceM(  __FILE__, __LINE__, _TRACE_ASSERT,   TraceIfCondFails ) ( cond, TEXT( # cond ) )
#define AssertMsg           _TraceM(  __FILE__, __LINE__, _TRACE_ASSERT,   TraceIfCondFails )

// Unconditional Assert with message...
#define AssertStr( str )    AssertMsg( FALSE, str )



#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\debug.cpp ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  debug
//
//  Assert, OutputDebugString-like replacements
//
//  See debug.h for usage details.
//
//
// --------------------------------------------------------------------------


#include <windows.h>

#include "debug.h"
#include <tchar.h>

#include <stdarg.h>

#include "types6432.h"
#include "stdio.h" // for _vsnwprintf

#define ARRAYLEN(a)    (sizeof(a)/sizeof(a[0]))


#define TRACE_HRESULT   0x01
#define TRACE_Win32     0x02


void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ...);

void WriteFilename( LPCTSTR pPath, LPTSTR szBuf, int cbBuf );


LPCTSTR g_pLevelStrs [ ] = 
{
    TEXT("DBG"),
    TEXT("INF"),
    TEXT("WRN"),
    TEXT("ERR"),
    TEXT("PRM"),
    TEXT("PRW"),
    TEXT("IOP"),
    TEXT("AST"),
    TEXT("AST"),
    TEXT("CAL"),
    TEXT("RET"),
    TEXT("???"),
};


DWORD g_dwTLSIndex = 0;

// enough for 10 4-space indents - 10*4 spaces
LPCTSTR g_szIndent = TEXT("                                        ");




static
void InternalTrace( LPCTSTR pszFile, ULONG uLineNo, DWORD dwLevel, DWORD dwFlags, const void * pThis, HRESULT hr, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    // Only produce output if this mutex exists...
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return;
    CloseHandle( hTestMutex );


    if( dwLevel >= ARRAYLEN( g_pLevelStrs ) )
        dwLevel = ARRAYLEN( g_pLevelStrs ) - 1; // "???" unknown entry

    if( ! pszFile )
        pszFile = TEXT("[missing file]");;

    LPCTSTR pszWhereSep = ( pszWhere && pszStr ) ? TEXT(": ") : TEXT("");

    if( ! pszStr && ! pszWhere )
        pszStr = TEXT("[missing string]");
    else
    {
        if( ! pszWhere )
            pszWhere = TEXT("");

        if( ! pszStr )
            pszStr = TEXT("");
    }

    // Basic message stuff - pid, tid... (also pass this and use object ptr?)
    // TODO - allow naming of threads?

    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();

    // Generate indent for call/ret...

    // TODO - make this thread safe + atomic
    if( g_dwTLSIndex == 0 )
    {
        g_dwTLSIndex = TlsAlloc();
    }
    DWORD dwIndent = PtrToInt( TlsGetValue( g_dwTLSIndex ) );

    if( dwLevel == _TRACE_RET )
    {
        dwIndent--;
        TlsSetValue( g_dwTLSIndex, IntToPtr( dwIndent ) );
    }

    DWORD dwDisplayIndent = dwIndent;
    if( dwDisplayIndent > 10 )
        dwDisplayIndent = 10;

    if( dwLevel == _TRACE_CALL )
    {
        dwIndent++;
        TlsSetValue( g_dwTLSIndex, IntToPtr( dwIndent ) );
    }


    // Step to the end of the canned indent string, then back dwIndent*4 spaces.
    // (Don't use sizeof(), since it will include the terminating NUL)
    LPCTSTR pszIndent = (g_szIndent + 40) - (dwDisplayIndent * 4);


    // Extract filename from path:
    TCHAR szFN[ 64 ];
    WriteFilename( pszFile, szFN, ARRAYLEN( szFN ) );


    TCHAR msg[ 1025 ];
    if( pThis )
    {
        if( dwFlags & TRACE_HRESULT )
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d this=0x%lx hr=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pThis, hr,
                                pszWhere, pszWhereSep, pszStr );
        }
        else
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d this=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pThis,
                                pszWhere, pszWhereSep, pszStr );
        }
    }
    else
    {
        if( dwFlags & TRACE_HRESULT )
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d hr=0x%lx %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                hr,
                                pszWhere, pszWhereSep, pszStr );
        }
        else
        {
            wsprintf( msg, TEXT("%d:%d %s%s %s:%d %s%s%s\r\n"),
                                pid, tid,
                                pszIndent, g_pLevelStrs[ dwLevel ], szFN, uLineNo,
                                pszWhere, pszWhereSep, pszStr );
        }
    }


    // 
	OutputDebugString( msg );

    // On w9x, also use the DBWIN mutex technique...
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( VerInfo );
    if( GetVersionEx( & VerInfo )
     && VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
    {
        OutputDebugStringDBWIN( msg );
    }



#ifdef DEBUG

    if( dwLevel == _TRACE_ASSERT_D || dwLevel == _TRACE_ERR )
    {
        DebugBreak();
    }

#endif // DEBUG

}



void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pszWhere, pszStr );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pszWhere, pszStr );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr )
{
    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pszWhere, pszStr );
}



void _Trace( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, 0, pThis, 0, pszWhere, pszBuf );
}

void _TraceHR( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, HRESULT hr, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, TRACE_HRESULT, pThis, hr, pszWhere, pszBuf );
}

void _TraceW32( LPCTSTR pFile, ULONG uLineNo, DWORD dwLevel, const void * pThis, LPCTSTR pszWhere, LPCTSTR pszStr, va_list alist )
{
    TCHAR szBuf[ 1025 ];
    LPCTSTR pszBuf;
    if( pszStr )
    {
        wvsprintf( szBuf, pszStr, alist );
        pszBuf = szBuf;
    }
    else
    {
        pszBuf = NULL;
    }

    InternalTrace( pFile, uLineNo, dwLevel, TRACE_Win32, pThis, 0, pszWhere, pszBuf );
}





// Add just the 'filename' part of the full path, minus base and extention.
// So for "g:\dev\vss\msaa\common\file.cpp", write "file".
// The start of this string is that last found ':', '\', or start of string if those are not present.
// The end of this string is the last '.' found after the start position, otherwise the end of the string.

void WriteFilename( LPCTSTR pPath, LPTSTR szBuf, int cBuf )
{
    LPCTSTR pScan = pPath;
    LPCTSTR pStart = pPath;
    LPCTSTR pEnd = NULL;

    // Scan through the filename till we hit the end...
    while( *pScan != '\0' )
    {
        // Found a dot - remember it - if we don't hit a directory separator,
        // then this marks the end of the name part of the path.
        if( *pScan == '.' )
        {
            pEnd = pScan;
            pScan++;
        }
        // Found a directory separator - reset markers for start and end of
        // name part...
        if( *pScan == '\\' || *pScan == '/' || *pScan == ':'  )
        {
            pScan++; // skip over separator char
            pStart = pScan;
            pEnd = NULL;
        }
        else
        {
            pScan++;
        }
    }

    if( pEnd == NULL )
        pEnd = pScan;

    // Copy as much as we can (leaving space for NUL) to out buffer
    // (int) cast keeps 64bit compiler happy
    int cToCopy = (int)(pEnd - pStart);
    if( cToCopy > cBuf - 1 )
        cToCopy = cBuf - 1;

    memcpy( szBuf, pStart, cToCopy * sizeof( TCHAR ) );
    szBuf[ cToCopy ] = '\0';
}






void OutputDebugStringDBWIN( LPCTSTR lpOutputString, ... )
{
    // create the output buffer
    TCHAR achBuffer[1025];
    int cchMax = ARRAYLEN(achBuffer) - 1; // leave room for null
    va_list args;
    va_start(args, lpOutputString);
   _vsnwprintf(achBuffer, cchMax, lpOutputString, args);
   achBuffer[cchMax] = L'\0'; // null terminate the string in case > cchMax would have been written
    va_end(args);


    // make sure DBWIN is open and waiting
    HANDLE heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if( !heventDBWIN )
    {
        return;            
    }

    // get a handle to the data synch object
    HANDLE heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        CloseHandle(heventDBWIN);
        return;            
    }
    
    HANDLE hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // Note - this is an ANSI CHAR pointer, not a TCHAR one.
    LPSTR lpszSharedMem = (LPSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    // wait for buffer event
    WaitForSingleObject(heventDBWIN, INFINITE);

#ifdef UNICODE
    CHAR achANSIBuffer[ 1025 ];
    WideCharToMultiByte( CP_ACP, 0, achBuffer, -1, achANSIBuffer, ARRAYLEN( achANSIBuffer ), NULL, NULL );
#else
    LPCSTR achANSIBuffer = achBuffer;
#endif

    // write it to the shared memory
    *((LPDWORD)lpszSharedMem) = GetCurrentProcessId();
    wsprintfA(lpszSharedMem + sizeof(DWORD), "%s", achANSIBuffer);

    // signal data ready event
    SetEvent(heventData);

    // clean up handles
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\default.h ===
// --------------------------------------------------------------------------
//
//  DEFAULT.H
//
//  Standard OLE accessible object class
//
// --------------------------------------------------------------------------


class   CAccessible :
        public IAccessible,
        public IEnumVARIANT,
        public IOleWindow,
        public IServiceProvider,
        public IAccIdentity
{
    public:

        //
        // Ctor, Dtor
        //

                CAccessible( CLASS_ENUM eclass );

        // Virtual dtor ensures that dtors of derived classes
		// are called correctly when objects are deleted
        virtual ~CAccessible();


        //
        // IUnknown
        //

        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        //
        // IDispatch
        //

        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                            DISPPARAMS* pdispparams, VARIANT* pvarResult,
                                            EXCEPINFO* pexcepinfo, UINT* puArgErr);

        //
        // IAccessible
        //

        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName) = 0;
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole) = 0;
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState) = 0;
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP			get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP			get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP			accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild) = 0;
        virtual STDMETHODIMP			accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint) = 0;
        virtual STDMETHODIMP			accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP			put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);


        //
        // IEnumVARIANT
        //

        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum) = 0;


        //
        // IOleWindow
        //

        virtual STDMETHODIMP            GetWindow(HWND* phwnd);
        virtual STDMETHODIMP            ContextSensitiveHelp(BOOL fEnterMode);


        //
        // IServiceProvider
        //

        virtual STDMETHODIMP            QueryService( REFGUID guidService, REFIID riid, void **ppv );


        //
        // IAccIdentity
        //

        virtual STDMETHODIMP            GetIdentityString ( DWORD     dwIDChild,
                                                            BYTE **   ppIDString,
                                                            DWORD *   pdwIDStringLen );


        //
        // CAccessible
        //

        virtual void SetupChildren();
        virtual BOOL ValidateChild(VARIANT*);

    protected:

        HWND        m_hwnd;
        ULONG       m_cRef;
        long        m_cChildren;        // Count of index-based children
        long        m_idChildCur;       // ID of current child in enum (may be index or hwnd based)

    private:

        // TODO - make the typeinfo a global (static), so we don't init it for each and every object.
        //      - have to be careful, since we'd need one per thread.
        ITypeInfo*  m_pTypeInfo;        // TypeInfo for IDispatch junk
        CLASSINFO * m_pClassInfo;       // ptr to this object's class info - may be NULL in some cases.

        HRESULT InitTypeInfo();
        void    TermTypeInfo();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\default.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DEFAULT.CPP
//
//  This is the default implementation for CAccessible. All other objects
//	usually inherit from this one.
//
//	Implements:
//		IUnknown
//			QueryInterface
//			AddRef
//			Release
//		IDispatch
//			GetTypeInfoCount
//			GetTypeInfo
//			GetIDsOfNames
//			Invoke
//		IAccessible
//			get_accParent
//			get_accChildCount
//			get_accChild
//			get_accName
//			get_accValue
//			get_accDescription
//			get_accRole
//			get_accState
//			get_accHelp
//			get_accHelpTopic
//			get_accKeyboardShortcut
//			get_accFocus
//			get_accSelection
//			get_accDefaultAction
//			accSelect
//			accLocation
//			accNavigate
//			accHitTest
//			accDoDefaultAction
//			put_accName
//			put_accValue
//		IEnumVARIANT
//			Next
//			Skip
//			Reset
//			Clone
//		IOleWindow
//			GetWindow
//			ContextSensitiveHelp
//
//		Helper Functions
//			SetupChildren
//			ValidateChild
//			InitTypeInfo
//			TermTypeInfo
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"

#include "PropMgr_Util.h"

CAccessible::CAccessible( CLASS_ENUM eclass )
{
    // NOTE: we rely on the fact that operator new (see memchk.cpp) uses LocalAlloc
    // with a flag specifying zero-inited memory to initialize our variables.
    // (If we want ot used cached memoey slots, we should change this to explicitly
    // init; or make sure cache slots are cleared before use.)

    if( eclass == CLASS_NONE )
        m_pClassInfo = NULL;
    else
        m_pClassInfo = & g_ClassInfo[ eclass ];
}



CAccessible::~CAccessible()
{
	// Nothing to do
	// (Dtor only exists so that the base class has a virtual dtor, so that
	// derived class dtors work properly when deleted through a base class ptr)
}


// --------------------------------------------------------------------------
//
//  CAccessible::GetWindow()
//
//  This is from IOleWindow, to let us get the HWND from an IAccessible*.
//
// ---------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetWindow(HWND* phwnd)
{
    *phwnd = m_hwnd;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::ContextSensitiveHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
	UNUSED(fEnterMode);
    return(E_NOTIMPL);
}


// --------------------------------------------------------------------------
//
//  CAccessible::InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT CAccessible::InitTypeInfo(void)
{
    HRESULT     hr;
    ITypeLib    *piTypeLib;

    if (m_pTypeInfo)
        return(S_OK);

    // Try getting the typelib from the registry
    hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];

        // Try loading directly.
#ifdef UNICODE
        MyGetModuleFileName(NULL, wszPath, ARRAYSIZE(wszPath));
#else
        TCHAR   szPath[MAX_PATH];

        MyGetModuleFileName(NULL, szPath, ARRAYSIZE(szPath));
        MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE(wszPath));
#endif

        hr = LoadTypeLib(wszPath, &piTypeLib);
    }

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &m_pTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            m_pTypeInfo = NULL;
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::TermTypeInfo()
//
//  This frees the type info if it is around
//
// --------------------------------------------------------------------------
void CAccessible::TermTypeInfo(void)
{
    if (m_pTypeInfo)
    {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    }
}



// --------------------------------------------------------------------------
//
//  CAccessible::QueryInterface()
//
//  This responds to 
//          * IUnknown 
//          * IDispatch 
//          * IEnumVARIANT
//          * IAccessible
//
//  The following comment is somewhat old and obsolte:
//    Some code will also respond to IText.  That code must override our
//    QueryInterface() implementation.
//  No current plans to support IText anywhere; but derived classes that
//  want to implement other interfaces will have to override QI.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;

    if( riid == IID_IUnknown  ||
        riid == IID_IDispatch ||
        riid == IID_IAccessible )
    {
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IEnumVARIANT )
    {
        *ppv = static_cast< IEnumVARIANT * >( this );
    }
    else if( riid == IID_IOleWindow )
    {
        *ppv = static_cast< IOleWindow * >( this );
    }
    else if( riid == IID_IServiceProvider )
    {
        *ppv = static_cast< IServiceProvider * >( this );
    }
    else if( riid == IID_IAccIdentity
                && m_pClassInfo
                && m_pClassInfo->fSupportsAnnotation )
    {
        // Only allow to QI to this interface if this
        // proxy type supports it...
        
        *ppv = static_cast< IAccIdentity * >( this );
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN) *ppv)->AddRef();

    return NOERROR;
}


// --------------------------------------------------------------------------
//
//  CAccessible::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    return(++m_cRef);
}


// --------------------------------------------------------------------------
//
//  CAccessible::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    if ((--m_cRef) == 0)
    {
        TermTypeInfo();
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr;

    InitPv(pctInfo);

    hr = InitTypeInfo();

    if (SUCCEEDED(hr))
        *pctInfo = 1;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused

    if (ppITypeInfo == NULL)
        return(E_POINTER);

    InitPv(ppITypeInfo);

    if (itInfo != 0)
        return(TYPE_E_ELEMENTNOTFOUND);

    hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        m_pTypeInfo->AddRef();
        *ppITypeInfo = m_pTypeInfo;
    }

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CAccessible::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused
	UNUSED(riid);	// riid is unused

    hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(m_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CAccessible::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr;

	UNUSED(lcid);	// locale id is unused
	UNUSED(riid);	// riid is unused

    hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(m_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}




// --------------------------------------------------------------------------
//
//  CAccessible::get_accParent()
//
//  NOTE:  Not only is this the default handler, it can also serve as
//  parameter checking for overriding implementations.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accParent(IDispatch ** ppdispParent)
{
    InitPv(ppdispParent);

    if (m_hwnd)
        return(AccessibleObjectFromWindow(m_hwnd, OBJID_WINDOW,
            IID_IDispatch, (void **)ppdispParent));
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accChildCount()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accChildCount(long* pChildCount)
{
    SetupChildren();
    *pChildCount = m_cChildren;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accChild()
//
//  No children.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
    InitPv(ppdispChild);

    if (! ValidateChild(&varChild) || !varChild.lVal)
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR * pszValue)
{
    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR * pszDescription)
{
    InitPv(pszDescription);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    InitPv(pszHelp);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accHelpTopic()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile,
    VARIANT varChild, long* pidTopic)
{
    InitPv(pszHelpFile);
    InitPv(pidTopic);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild,
    BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accFocus(VARIANT *pvarFocus)
{
    InitPvar(pvarFocus);
    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accSelection(VARIANT* pvarSelection)
{
    InitPvar(pvarSelection);
    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CAccessible::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild,
    BSTR* pszDefaultAction)
{
    InitPv(pszDefaultAction);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accSelect(long flagsSel, VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


#if 0
// --------------------------------------------------------------------------
//
//  CAccessible::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_OK);
}
#endif


// --------------------------------------------------------------------------
//
//  CAccessible::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accNavigate(long navFlags, VARIANT varStart,
    VARIANT *pvarEnd)
{
    InitPvar(pvarEnd);

    if (! ValidateChild(&varStart))
        return(E_INVALIDARG);

    if (!ValidateNavDir(navFlags, varStart.lVal))
        return(E_INVALIDARG);

    return(S_FALSE);
}


#if 0
// --------------------------------------------------------------------------
//
//  CAccessible::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop,
    VARIANT* pvarChild)
{
    InitPvar(pvarChild);
    return(S_FALSE);
}
#endif


// --------------------------------------------------------------------------
//
//  CAccessible::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::put_accName()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)
{
	UNUSED(szName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::put_accValue()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR szValue)
{
	UNUSED(szValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CAccessible::Next
//
//  Handles simple Next, where we return back indeces for child elements.
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Next(ULONG celt, VARIANT* rgvar,
    ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cChildren))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us (index)+1 because we incremented iCur
        //
        pvar->vt = VT_I4;
        pvar->lVal = iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Skip(ULONG celt)
{
    SetupChildren();

    m_idChildCur += celt;
    if (m_idChildCur > m_cChildren)
        m_idChildCur = m_cChildren;

    //
    // We return S_FALSE if at the end
    //
    return((m_idChildCur >= m_cChildren) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CAccessible::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CAccessible::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}




STDMETHODIMP CAccessible::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    if( guidService == IIS_IsOleaccProxy )
    {
        return QueryInterface( riid, ppv );
    }
    else
    {
        // MSDN mentions SVC_E_UNKNOWNSERVICE as the return code, but that's not in any of the headers.
        // Returning E_INVALIDARG instead. (Don't want to use E_NOINTERFACE, since that clashes with
        // QI's return value, making it hard to distinguish between valid service+invalid interface vs
        // invalid service.
        return E_INVALIDARG;
    }
}



STDMETHODIMP CAccessible::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    if( ! m_pClassInfo || ! m_pClassInfo->fSupportsAnnotation  )
    {
        // Shouldn't get here - shouldn't QI to this interface if the above are false.
        Assert( FALSE );
        return E_FAIL;
    }

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    MakeHwndKey( pKeyData, m_hwnd, m_pClassInfo->dwObjId, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}





// --------------------------------------------------------------------------
//
//  CAccessible::ValidateChild()
//
// --------------------------------------------------------------------------
BOOL CAccessible::ValidateChild(VARIANT *pvar)
{
    //
    // This validates a VARIANT parameter and translates missing/empty
    // params.
    //
    SetupChildren();

    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

// remove this! VT_I2 is not valid!!
#ifdef  VT_I2_IS_VALID  // it isn't now...
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > m_cChildren))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  SetupChildren()
//
//  Default implementation of SetupChildren, does nothing.
//
// --------------------------------------------------------------------------
void CAccessible::SetupChildren(void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\desktop.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DESKTOP.CPP
//
//  Desktop class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "desktop.h"




// --------------------------------------------------------------------------
//
//  CreateDesktopClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateDesktopClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvDesktop)
{
    CDesktop* pdesktop;
    HRESULT   hr;

    InitPv(ppvDesktop);

    pdesktop = new CDesktop(hwnd, idChildCur);
    if (! pdesktop)
        return(E_OUTOFMEMORY);

    hr = pdesktop->QueryInterface(riid, ppvDesktop);
    if (!SUCCEEDED(hr))
        delete pdesktop;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDesktop::CDesktop()
//
// --------------------------------------------------------------------------
CDesktop::CDesktop(HWND hwnd, long idChildCur)
    : CClient( CLASS_DesktopClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_DESKTOP_NAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accFocus(VARIANT* pvarFocus)
{
    return(get_accSelection(pvarFocus));
}



// --------------------------------------------------------------------------
//
//  CDesktop::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDesktop::get_accSelection(VARIANT* pvar)
{
    HWND    hwnd;

    InitPvar(pvar);

    hwnd = GetForegroundWindow();
    if (! hwnd)
        return(S_FALSE);

    return(GetWindowObject(hwnd, pvar));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\dialog.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DIALOG.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "dialog.h"




// --------------------------------------------------------------------------
//
//  CreateDialogClient()
//
//  EXTERNAL function for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateDialogClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject)
{
    CDialog * pdialog;
    HRESULT hr;

    InitPv(ppvObject);

    pdialog = new CDialog(hwnd, idChildCur);
    if (!pdialog)
        return(E_OUTOFMEMORY);

    hr = pdialog->QueryInterface(riid, ppvObject);
    if (!SUCCEEDED(hr))
        delete pdialog;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDialog::CDialog()
//
// --------------------------------------------------------------------------
CDialog::CDialog(HWND hwnd, long idChildCur)
    : CClient( CLASS_DialogClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CDialog::get_accRole()
//
//  Currently does NOT accept child IDs
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    long    lStyle;

    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if ((lStyle & WS_CHILD) && (lStyle & DS_CONTROL))
        pvarRole->lVal = ROLE_SYSTEM_PROPERTYPAGE;
    else
        pvarRole->lVal = ROLE_SYSTEM_DIALOG;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CDialog::get_accDefaultAction()
//
//  The default action is the name of the default push button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    HRESULT hr;
    long    idDef;
    HWND    hwndDef;
    IAccessible * poleacc;

    InitPv(pszDefAction);

    //
    // Validate--use ValidateChild so only 0 is allowed.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Get the default ID
    //
    idDef = SendMessageINT(m_hwnd, DM_GETDEFID, 0, 0);
    if (HIWORD(idDef) == DC_HASDEFID)
        idDef &= 0x0000FFFF;
    else
        idDef = IDOK;

    //
    // Get the item with this ID
    //
    hwndDef = GetDlgItem(m_hwnd, idDef);
    if (!hwndDef)
        return(S_FALSE);

    //
    // Get this thing's name.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwndDef, OBJID_CLIENT, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    //
    // varChild is empty of course
    //
    hr = poleacc->get_accName(varChild, pszDefAction);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDialog::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::accDoDefaultAction(VARIANT varChild)
{
    HRESULT hr;
    long    idDef;
    HWND    hwndDef;
    IAccessible * poleacc;

    //
    // Validate 
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Get the default ID
    //
    idDef = SendMessageINT(m_hwnd, DM_GETDEFID, 0, 0);
    if (HIWORD(idDef) == DC_HASDEFID)
        idDef &= 0x0000FFFF;
    else
        idDef = IDOK;

    //
    // Get the child with this ID
    //
    hwndDef = GetDlgItem(m_hwnd, idDef);
    if (!hwndDef)
        return(S_FALSE);

    //
    // Ask the child to do its default action.  Yes, we could send a 
    // WM_COMMAND message directly, but this lets non-push buttons hook
    // into the action.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwndDef, OBJID_CLIENT, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    hr = poleacc->accDoDefaultAction(varChild);
    poleacc->Release();

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\desktop.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DESKTOP.H
//
//  (Real not shell) Desktop client support
//
// --------------------------------------------------------------------------


class CDesktop : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT*);
        virtual STDMETHODIMP        get_accSelection(VARIANT*);

        CDesktop(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\fwd_macros.h ===
#ifndef _FWD_MACROS_H_
#define _FWD_MACROS_H_


#define AS_DECL_0
#define AS_CALL_0

#define AS_DECL_1(t1,a1) (t1 a1)
#define AS_CALL_1(t1,a1) (a1)

#define AS_DECL_2(t1,a1,t2,a2) (t1 a1,t2 a2)
#define AS_CALL_2(t1,a1,t2,a2) (a1,a2)

#define AS_DECL_3(t1,a1,t2,a2,t3,a3) (t1 a1,t2 a2,t3 a3)
#define AS_CALL_3(t1,a1,t2,a2,t3,a3) (a1,a2,a3)

#define AS_DECL_4(t1,a1,t2,a2,t3,a3,t4,a4) (t1 a1,t2 a2,t3 a3,t4 a4)
#define AS_CALL_4(t1,a1,t2,a2,t3,a3,t4,a4) (a1,a2,a3,a4)

#define AS_DECL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5)
#define AS_CALL_5(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5) (a1,a2,a3,a4,a5)

#define AS_DECL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6)
#define AS_CALL_6(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6) (a1,a2,a3,a4,a5,a6)

#define AS_DECL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7)
#define AS_CALL_7(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7) (a1,a2,a3,a4,a5,a6,a7)

#define AS_DECL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8)
#define AS_CALL_8(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8) (a1,a2,a3,a4,a5,a6,a7,a8)

#define AS_DECL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9)
#define AS_CALL_9(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9) (a1,a2,a3,a4,a5,a6,a7,a8,a9)

#define AS_DECL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10)
#define AS_CALL_10(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)

#define AS_DECL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (t1 a1,t2 a2,t3 a3,t4 a4,t5 a5,t6 a6,t7 a7,t8 a8,t9 a9,t10 a10,t11 a11)
#define AS_CALL_11(t1,a1,t2,a2,t3,a3,t4,a4,t5,a5,t6,a6,t7,a7,t8,a8,t9,a9,t10,a10,t11,a11) (a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)


#define AS_DECL( n, p )  AS_DECL_ ## n p
#define AS_CALL( n, p )  AS_CALL_ ## n p


#endif // _FWD_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\dialog.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DIALOG.H
//
//  Dialog object
//
// --------------------------------------------------------------------------

class   CDialog :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);
        STDMETHODIMP    accDoDefaultAction(VARIANT varChild);
        
        CDialog(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\header.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HEADER.H
//
//  Knows how to talk to COMCTL32's header control
//
// --------------------------------------------------------------------------

class CHeader32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT, BSTR*);
        STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
		STDMETHODIMP	get_accState(VARIANT, VARIANT*);
        STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP    accDoDefaultAction(VARIANT);
        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP    accHitTest(long, long, VARIANT*);

        CHeader32(HWND, long);
        void        SetupChildren(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\guids.c ===
// Copyright (c) 1996-1999 Microsoft Corporation

// ===========================================================================
// File: G U I D S . C
// 
// Used to define all MSAA GUIDs for OLEACC.  By compiling this file w/o 
// precompiled headers, we are allowing the MSAA GUIDs to be defined and stored
// in OLEACC.DLLs data or code segments.  This is necessary for OLEACC.DLL to 
// be built.
// 
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
// ===========================================================================

// disable warnings to placate compiler wjen compiling included ole headers
#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional
#pragma warning(disable:4214)	// ignore nonstandard extensions
#pragma warning(disable:4115)	// named type definition in parenthesis

#include <objbase.h>

#include <initguid.h>

// All the GUIDs we want are in oleacc.h as DEFINE_GUID's...
#include "com_external.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\header.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HEADER.CPP
//
//  This knows how to talk to COMCTL32's header control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "header.h"
#include "Win64Helper.h"

#define MAX_HEADER_TEXT 80

// --------------------------------------------------------------------------
//
//  CreateHeaderClient()
//
// --------------------------------------------------------------------------
HRESULT CreateHeaderClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvHeader)
{
    CHeader32 * pheader;
    HRESULT     hr;

    InitPv(ppvHeader);

    pheader = new CHeader32(hwnd, idChildCur);
    if (!pheader)
        return(E_OUTOFMEMORY);

    hr = pheader->QueryInterface(riid, ppvHeader);
    if (!SUCCEEDED(hr))
        delete pheader;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CHeader32::CHeader32()
//
// --------------------------------------------------------------------------
CHeader32::CHeader32(HWND hwnd, long idChildCur)
    : CClient( CLASS_HeaderClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CHeader32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

	TCHAR tchText[MAX_HEADER_TEXT + 1] = {0};
	HDITEM hdi;
	memset(&hdi, 0, sizeof(HDITEM));
	hdi.mask = HDI_TEXT;
	hdi.pszText = tchText;
	hdi.cchTextMax = MAX_HEADER_TEXT;

	if (SUCCEEDED(XSend_HeaderCtrl_GetItem(m_hwnd, HDM_GETITEM, varChild.lVal-1, &hdi)))
	{
        if (*hdi.pszText)
            *pszName = TCharSysAllocString(hdi.pszText);

    }
    //
    // BOGUS!  On failure, use tooltip trick like toolbar.
    //
    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CHeader32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (!varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LIST;
    else
        pvarRole->lVal = ROLE_SYSTEM_COLUMNHEADER;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CHeader32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

	pvarState->lVal |= STATE_SYSTEM_READONLY;

    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }
    
	if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

	if (wi.dwStyle & HDS_HIDDEN)
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    // Check for clipped, but only if this is a child item, and it's not
    // already invisible...
    if( varChild.lVal != CHILDID_SELF
     && ! ( pvarState->lVal & STATE_SYSTEM_INVISIBLE )
     && IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

	if (wi.dwStyle & HDS_BUTTONS)
        pvarState->lVal |= 0;		// BOGUS! Indicate whether you can click or not.

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CHeader32::get_accDefaultAction()
//
//  Since the default action for a header is really determined by the
//  creator of the header control, the best we can do is click on
//  the thing, and return "click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
WINDOWINFO wi;

    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi))
    {
    	if (wi.dwStyle & WS_VISIBLE)
        {
            if (!(wi.dwStyle & HDS_HIDDEN))
            {
                if (wi.dwStyle & HDS_BUTTONS)
                    return (HrCreateString(STR_CLICK, pszDefAction));
            }
        }
    }

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CHeader32::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a 
//  header is, so unless the parent overrides us, we'll just do a
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accDoDefaultAction(VARIANT varChild)
{
WINDOWINFO wi;
RECT		rcLoc;
HRESULT		hr;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi))
    {
    	if (wi.dwStyle & WS_VISIBLE)
        {
            if (!(wi.dwStyle & HDS_HIDDEN))
            {
                if (wi.dwStyle & HDS_BUTTONS)
                {
	                hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	                if (!SUCCEEDED (hr))
		                return (hr);

	                if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		                return (S_OK);
                }
            }
        }
    }
    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CHeader32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
LPRECT  lprc;
HANDLE  hProcess;
RECT    rcItem;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Allocate a shared memory LPRECT and get the item's rectangle.
    //
    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprc)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, HDM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcItem,sizeof(RECT),hProcess);

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcItem, 2);

        *pxLeft = rcItem.left;
        *pyTop = rcItem.top;
        *pcxWidth = rcItem.right - rcItem.left;
        *pcyHeight = rcItem.bottom - rcItem.top;
    }

    SharedFree(lprc,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
LPINT   lpiShared;
LPINT   lpiLocal;
long    lPosition = 0;
int     iOrder;
HANDLE  hProcess;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    Assert(NAVDIR_LASTCHILD > NAVDIR_FIRSTCHILD);
    Assert(NAVDIR_MAX == NAVDIR_LASTCHILD+1);

    // Peer navigation among frame elements
    if ((!varStart.lVal) && (dwNavDir < NAVDIR_FIRSTCHILD))
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Get the order array.
    //
    lpiShared = (LPINT)SharedAlloc((m_cChildren*sizeof(INT)),m_hwnd,&hProcess);
    if (!lpiShared)
        return(E_OUTOFMEMORY);

    lpiLocal = (LPINT)LocalAlloc (LPTR,(m_cChildren*sizeof(INT)));
    if (!lpiLocal)
    {
        SharedFree (lpiShared,hProcess);
        return(E_OUTOFMEMORY);
    }

    SendMessage(m_hwnd, HDM_GETORDERARRAY, m_cChildren, (LPARAM)lpiShared);

    //
    // BOGUS!  Only works for column headers (horizontal), not row
    // headers (vertical).
    // 
    SharedRead (lpiShared,lpiLocal,(m_cChildren*sizeof(INT)),hProcess);

    // Get the position of the item we want to move to
    switch (dwNavDir)
    {
        case NAVDIR_FIRSTCHILD:
            lPosition = 0;
            break;

        case NAVDIR_LASTCHILD:
            if (!m_cChildren)
                goto NavigateEnd;
            lPosition = m_cChildren - 1;
            break;

        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lPosition = lpiLocal[varStart.lVal-1];
            ++lPosition;
            if (lPosition >= m_cChildren)
                goto NavigateEnd;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lPosition = lpiLocal[varStart.lVal-1];
            if (!lPosition)
                goto NavigateEnd;
            --lPosition;
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            goto NavigateEnd;
            break;
    }

    //
    // Find the item with this positional value
    //
    for (iOrder = 0; iOrder < m_cChildren; iOrder++)
    {
        if (lpiLocal[iOrder] == lPosition)
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = iOrder+1;
            break;
        }
    }

NavigateEnd:
    SharedFree(lpiShared,hProcess);
    LocalFree (lpiLocal);

    return((pvarEnd->vt == VT_EMPTY) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accHitTest(long x, long y, VARIANT* pvarEnd)
{
HRESULT         hr;
LPHDHITTESTINFO lphi;
HANDLE          hProcess;
POINT           ptTest;

    InitPvar(pvarEnd);
    SetupChildren();

    //
    // Is the point in our client?  If not, bail.
    //
    hr = CClient::accHitTest(x, y, pvarEnd);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarEnd->vt != VT_I4) || (pvarEnd->lVal != 0))
        return(hr);

    //
    // It is.  Do hit test stuff.
    //
    lphi = (LPHDHITTESTINFO)SharedAlloc(sizeof(HDHITTESTINFO),m_hwnd,&hProcess);
    if (!lphi)
        return(E_OUTOFMEMORY);

    ptTest.x = x;
    ptTest.y = y;
    ScreenToClient(m_hwnd, &ptTest);

    SharedWrite (&ptTest,&lphi->pt,sizeof(POINT),hProcess);

    if (SendMessage(m_hwnd, HDM_HITTEST, 0, (LPARAM)lphi) != -1)
    {
        SharedRead (&lphi->iItem,&pvarEnd->lVal,sizeof(int),hProcess);
        pvarEnd->lVal++;
    }

    SharedFree(lphi,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::SetupChildren()
//
// --------------------------------------------------------------------------
void CHeader32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, HDM_GETITEMCOUNT, 0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\hotkey.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HOTKEY.CPP
//
//  This knows how to talk to COMCTL32's HOTKEY control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "hotkey.h"


#define NOTOOLBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOSTATUSBAR
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>

// The following define allows us to replace only those string functions needing work
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"
#undef STRSAFE_NO_DEPRECATE


// --------------------------------------------------------------------------
//
//  CreateHotKeyClient()
//
//  Called by CreateClientObject() and Clone()
//
// --------------------------------------------------------------------------
HRESULT CreateHotKeyClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvHotKey)
{
    CHotKey32* photkey;
    HRESULT    hr;

    InitPv(ppvHotKey);

    photkey = new CHotKey32(hwnd, idChildCur);
    if (!photkey)
        return(E_OUTOFMEMORY);

    hr = photkey->QueryInterface(riid, ppvHotKey);
    if (!SUCCEEDED(hr))
        delete photkey;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CHotKey32::CHotKey32()
//
// --------------------------------------------------------------------------
CHotKey32::CHotKey32(HWND hwnd, long idChildCur)
    : CClient( CLASS_HotKeyClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CHotKey32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHotKey32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_HOTKEYFIELD;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHotKey32::get_accValue()
//
//  The value of the hotkey field control is the currently typed-in contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHotKey32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    DWORD   dwHotKey;
    long    lScan;
    LPTSTR  lpszMods;
    TCHAR   szModifiers[64];
    TCHAR   szKey[32];
    TCHAR   szResult[64];

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    // Get the hotkey and turn into a string.
    dwHotKey = SendMessageINT(m_hwnd, HKM_GETHOTKEY, 0, 0);
    if (!dwHotKey)
        return(HrCreateString(STR_HOTKEY_NONE, pszValue));

    //
    // The HIBYTE of the LOWORD is the HOTKEYF_ flags.
    // The LOBYTE of the LOWORD is the VK_.
    //

    // Get the VK_ name.
    lScan = ((LONG)MapVirtualKey(LOBYTE(dwHotKey), 0) << 16);
    if (HIBYTE(dwHotKey) & HOTKEYF_EXT)
        lScan |= 0x01000000L;

    if (!GetKeyNameText(lScan, szKey, ARRAYSIZE(szKey)))
        return(S_FALSE);

    //
    // Make a string of the modifiers.  Do it in the order the shell does.
    // Namely, Ctrl + Shift + Alt + key.
    //
    lpszMods = szModifiers;
    size_t cchLeft = ARRAYSIZE(szModifiers);
    
    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_CONTROL)
    {
        LoadString(hinstResDll, STR_CONTROL, szResult, ARRAYSIZE(szResult));
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, szResult, &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long CTRL resource string")); 
            return S_FALSE;
        }
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, TEXT("+"), &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long CTRL resource string"));
            return S_FALSE;
        }
    }

    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_SHIFT)
    {
        LoadString(hinstResDll, STR_SHIFT, szResult, ARRAYSIZE(szResult));
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, szResult, &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long SHIFT resource string")); 
            return S_FALSE;
        }
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, TEXT("+"), &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long SHIFT resource string"));
            return S_FALSE;
        }
    }

    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_ALT)
    {
        LoadString(hinstResDll, STR_ALT, szResult, ARRAYSIZE(szResult));
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, szResult, &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long ALT resource string")); 
            return S_FALSE;
        }
        if( FAILED( StringCchCopyEx( lpszMods, cchLeft, TEXT("+"), &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue due to long ALT resource string"));
            return S_FALSE;
        }
    }

    if (lpszMods == szModifiers)
        lstrcpy(szResult, szKey);
    else
    {
        if( FAILED(StringCchCopyEx( szResult, ARRAYSIZE(szResult), szModifiers, &lpszMods, &cchLeft, 0  ) ) )
        {
            return S_FALSE; // szResult and szModifiers are same size so this should never happen
        }
        if( FAILED(StringCchCopyEx( lpszMods, cchLeft, szKey, &lpszMods, &cchLeft, 0 ) ) )
        {
            TraceError(TEXT("Buffer overflow in CHotKey32::get_accValue appending key name"));
            return S_FALSE;
        }
    }

    *pszValue = TCharSysAllocString(szResult);
    if (! *pszValue)
        return(E_OUTOFMEMORY);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\hotkey.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HOTKEY.H
//
//  This knows how to talk to COMCTL32's hotkey control.
//
// --------------------------------------------------------------------------


class CHotKey32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accValue(VARIANT, BSTR*);

        CHotKey32(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\edit.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  EDIT.H
//
//  Edit field
//
// --------------------------------------------------------------------------

class   CEdit : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);
        virtual STDMETHODIMP        get_accDescription(VARIANT varChild, BSTR* pszDescription);

        CEdit(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\edit.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  EDIT.CPP
//
//  BOGUS!  This should support ITextDocument or something
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "edit.h"



BOOL GetRichEditText( HWND hwnd, LPWSTR pWStr, int cchWStrMax );

BOOL GetObjectText( IUnknown * punk, LPWSTR * ppWStr, int * pcchWStrMax );

HRESULT InvokeMethod( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult, int cArgs, ... );

HRESULT GetProperty( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult );



// --------------------------------------------------------------------------
//
//  CreateEditClient()
//
// --------------------------------------------------------------------------
HRESULT CreateEditClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvEdit)
{
    CEdit * pedit;
    HRESULT hr;

    InitPv(ppvEdit);

    pedit = new CEdit(hwnd, idChildCur);
    if (!pedit)
        return(E_OUTOFMEMORY);

    hr = pedit->QueryInterface(riid, ppvEdit);
    if (!SUCCEEDED(hr))
        delete pedit;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CEdit::CEdit()
//
// --------------------------------------------------------------------------
CEdit::CEdit(HWND hwnd, long idChildCur)
    : CClient( CLASS_EditClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    // Is this edit in a combo or an IP control? If so, use the parent's
    // name (which it gets from its label) as our own.

    // Using CompareWindowClasses is safer than checking the ES_COMBOBOX style bit,
    // since that bit is not used when the edit is in a combo in a comboex32.
    // was:   if (GetWindowLong(m_hwnd, GWL_STYLE) & ES_COMBOBOX)
    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    const CLASS_ENUM ceClass = GetWindowClass( hwndParent );
    
    if( hwndParent && ( CLASS_ComboClient == ceClass || CLASS_IPAddressClient == ceClass ) )
    {
        IAccessible* pacc = NULL;
        HRESULT hr = AccessibleObjectFromWindow( hwndParent,
                    OBJID_CLIENT, IID_IAccessible, (void**)&pacc );
        if( ! SUCCEEDED( hr ) || ! pacc )
            return S_FALSE;

        VariantInit(&varChild);
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        hr = pacc->get_accName(varChild, pszName);
        pacc->Release();

        return hr;
    }
    else
        return(CClient::get_accName(varChild, pszName));
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accValue()
//
//  Gets the text contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    // if this is a password edit control, return a NULL pointer
    DWORD dwPasswordChar = Edit_GetPasswordChar( m_hwnd );
    if( dwPasswordChar != '\0' )
    {
        return E_ACCESSDENIED;
    }


    // Try getting text (plus object text) using the RichEdit/TOM
    // technique...
    {
        WCHAR szText[ 4096 ];
        if( GetRichEditText( m_hwnd, szText, ARRAYSIZE( szText ) ) )
        {
            *pszValue = SysAllocString( szText );
            return S_OK;
        }
    }

    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_TEXT;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CEdit::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    // 
    // Get default client state
    //
    HRESULT hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Add on extra styles for edit field
    //
    Assert(pvarState->vt == VT_I4);

    LONG lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & ES_READONLY)
    {
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    }

    DWORD dwPasswordChar = Edit_GetPasswordChar( m_hwnd );
    if( dwPasswordChar != '\0' )
    {
        pvarState->lVal |= STATE_SYSTEM_PROTECTED;
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);


    // If in a combo or IP control, use its shortcut key...
    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    const CLASS_ENUM ceClass = GetWindowClass( hwndParent );
    
    if( hwndParent && ( CLASS_ComboClient == ceClass || CLASS_IPAddressClient == ceClass ) )
    {
        IAccessible* pacc = NULL;
        HRESULT hr = AccessibleObjectFromWindow( hwndParent,
                    OBJID_CLIENT, IID_IAccessible, (void**)&pacc );
        if( ! SUCCEEDED( hr ) || ! pacc )
            return S_FALSE;

        VariantInit(&varChild);
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        hr = pacc->get_accKeyboardShortcut(varChild, pszShortcut);
        pacc->Release();

        return hr;
    }
    else
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
}


// --------------------------------------------------------------------------
//
//  CEdit::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::put_accValue(VARIANT varChild, BSTR szValue)
{
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// If unicode, use the BSTR directly...
	lpszValue = szValue;

#else

	// If not UNICODE, allocate a temp string and convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif


    SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);

#ifndef UNICODE

	// If non-unicode, free the temp string we allocated above
    LocalFree((HANDLE)lpszValue);

#endif

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CEdit::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    InitPv(pszDescription);
	
    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    // Is this an IP control?  Add a description to specify whitch part it is

    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    if( hwndParent && CLASS_IPAddressClient == GetWindowClass( hwndParent ) ) 
    {
		HWND hwndChild = ::GetWindow( hwndParent, GW_CHILD );

		for ( int i = 4; i > 0 && hwndChild; i-- )
		{
			if ( hwndChild == m_hwnd )
			{
				TCHAR szIP[32], szPart[32];
				
				if ( !LoadString(hinstResDll, STR_DESC_IP_PART, szPart, ARRAYSIZE(szPart) - 1 ) )
				    return E_FAIL;
				    
				wsprintf( szIP, szPart, i );
				*pszDescription = TCharSysAllocString( szIP );
				break;
			}

			hwndChild = ::GetWindow( hwndChild, GW_HWNDNEXT );
		} 
    }

	return S_OK;
}



















// --------------------------------------------------------------------------
//
//  StrAddW
//
//  Helper function to append a string to another.
//  Ensures that it does not overrun target buffer.
//
//  ppStr is ptr to buffer ptr where string is to be appended. On exit, the
//  pointer-to-buffer is updated to point to one past the end of the newly
//  appended text (ie. at the terminating NUL character).
//
//  pchLeft is a ptr to a count of the available characters in the
//  destination buffer. On exit, this is updated to reflect the amount
//  of characters available after the string has been appended.
//
//  There are two versions of StrAddW - one takes a string pointer and a
//  length (in WCHARS), the other just takes a string pointer, and assumes
//  that the string is NUL-terminated.
//
// --------------------------------------------------------------------------


void StrAddW( LPWSTR * ppStr, int * pchLeft, LPCWSTR pStrAdd, int cchAddLen )
{
    // Make sure there's at least 1 char space (for NUL)
    if( *pchLeft <= 0 )
        return;
    // Get min of target string, space left...
    if( cchAddLen > *pchLeft - 1 )
        cchAddLen = *pchLeft - 1;
    // This copies up to but not including the NUL char in the terget string...
    memcpy( *ppStr, pStrAdd, cchAddLen * sizeof( WCHAR ) );
    // Advance pointer, devrement space remaining count...
    *ppStr += cchAddLen;
    *pchLeft -= cchAddLen;
    // Add terminating NUL...
    **ppStr = '\0';
}


void StrAddW( LPWSTR * ppStr, int * pchLeft, LPCWSTR pStrAdd )
{
    StrAddW( ppStr, pchLeft, pStrAdd, lstrlenW( pStrAdd ) );
}





// --------------------------------------------------------------------------
//
//  GetRichEditText
//
//  Gets full text - including text from objects - from a rich edit control.
//
//  hwnd is handle to the richedit control.
//  pWStr and cchWStrMax are the destination buffer and available space (in
//  WCHARs, includes space for terminating NUL).
//
//  Returns TRUE if text could be retrieved.
//
// --------------------------------------------------------------------------


BOOL GetRichEditText( HWND hwnd, LPWSTR pWStr, int cchWStrMax )
{
    BOOL fGot = FALSE;

    //
    //  Get a pointer to the TOM automation object...
    //
    IDispatch * pdispDoc = NULL;
    HRESULT hr = AccessibleObjectFromWindow( hwnd, OBJID_NATIVEOM, IID_IDispatch, (void **) & pdispDoc );
    if( hr != S_OK || pdispDoc == NULL )
    {
        TraceErrorHR( hr, TEXT("GetRichEditText: AccessibleObjectFromWindow failed") );
        return FALSE;
    }

    //
    // Get a range representing the entire doc...
    //

    // This gets an empty range at the start of the doc. We later Expand it to entire doc...

    VARIANT varRange;
    hr = InvokeMethod( pdispDoc, L"Range", & varRange, 2,
                       VT_I4, 0,
                       VT_I4, 0 );
    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("GetRichEditText: Range method failed") );
    }
    else if( varRange.vt != VT_DISPATCH || varRange.pdispVal == NULL )
    {
        VariantClear( & varRange );
        TraceError( TEXT("GetRichEditText: Range method failed returned non-disp, or NULL-disp") );
    }
    else
    {
        IDispatch * pdispRange = varRange.pdispVal;

        // Set range to entire story...
        VARIANT varDelta;
        hr = InvokeMethod( pdispRange, L"Expand", & varDelta, 1, VT_I4, 6 /*tomStory*/ );
        if( hr != S_OK )
        {
            TraceErrorHR( hr, TEXT("GetRichEditText: Range::GetStoryLength failed or returned non-VT_I4") );
        }
        else
        {
            //
            // Get all text from the range...
            //

            VARIANT varText;
            hr = GetProperty( pdispRange, L"Text", & varText );
            if( hr != S_OK || varText.vt != VT_BSTR || varText.bstrVal == NULL )
            {
                TraceError( TEXT("GetRichEditText: Text property failed / is non-BSTR / is NULL") );
            }
            else
            {
                // At this stage, we've got the text. We may not be able to expand
                // the objects, but we can at least use a '?' for those that don't
                // support the object->text technique.
                fGot = TRUE;

                //
                // Scan through the text - copy regular text to the output buffer,
                // also look for the object replacement char (0xFFFC), and attempt
                // to get the corresponding object and its text, and copy to
                // buffer.
                //

                LPCWSTR pScan = varText.bstrVal;
                for( ; ; )
                {
                    // Rember start of this block of plain text...
                    LPCWSTR pStart = pScan;

                    // Look for end of string, or object replacement char...
                    while( *pScan != '\0' && *pScan != 0xFFFC )
                    {                    
                        pScan++;
                    }

                    // Copy plain text so far to output buffer...
                    StrAddW( & pWStr, & cchWStrMax, pStart, (int)(pScan - pStart) );

                    // If this is the end of the string, bail out of loop...
                    if( *pScan == '\0' )
                    {
                        break;
                    }

                    //
                    //  Found an object replacement char - set a range to this
                    //  position, then use it to get the object...
                    //

                    // Set range to point to the obj repl char...
                    hr = InvokeMethod( pdispRange, L"SetRange", NULL, 2,
                                       VT_I4, pScan - varText.bstrVal,
                                       VT_I4, pScan - varText.bstrVal );

                    // Skip over the object replacement char...
                    pScan++;

                    // If we have problems getting the object's text, use a
                    // '?' character instead.
                    if( hr != S_OK )
                    {
                        StrAddW( & pWStr, & cchWStrMax, L"?" );
                        TraceErrorHR( hr, TEXT("GetRichEditText: SetRange failed") );
                    }
                    else
                    {
                        //
                        // Try to get the object...
                        //

                        VARIANT varObject;
                        hr = InvokeMethod( pdispRange, L"GetEmbeddedObject", & varObject, 0 );
                        if( hr != S_OK || varObject.vt != VT_UNKNOWN || varObject.punkVal == NULL )
                        {
                            StrAddW( & pWStr, & cchWStrMax, L"?" );
                            TraceError( TEXT("GetRichEditText: GetEmbeddedObject failed or returned NULL") );
                        }
                        else
                        {
                            //
                            // Got the object - now get its text...
                            //

                            if( ! GetObjectText( varObject.pdispVal, & pWStr, & cchWStrMax ) )
                            {
                                StrAddW( & pWStr, & cchWStrMax, L"?" );
                            }

                            varObject.pdispVal->Release();
                        }
                    }

                    // end of for(;;) loop, start over to look for next object replacement char.
                }
            }
        }

        pdispRange->Release();
    }

    pdispDoc->Release();

    return fGot;
}



// --------------------------------------------------------------------------
//
//  GetObjectText
//
//
//  Attempts to get text from an object, by asking for a IDataObject
//  and querying for text clipboard format.
//
// --------------------------------------------------------------------------

BOOL GetObjectText( IUnknown * punk, LPWSTR * ppWStr, int * pcchWStrMax )
{
    // Try IAccessible first...
    IAccessible * pAcc = NULL;
	HRESULT hr = punk->QueryInterface( IID_IAccessible, (void **) & pAcc );
    if( hr == S_OK && pAcc != NULL )
    {
        VARIANT varChild;
        varChild.vt = VT_EMPTY;
        varChild.lVal = CHILDID_SELF;
        BSTR bstrName = NULL;
        hr = pAcc->get_accName( varChild, & bstrName );
        pAcc->Release();

        if( SUCCEEDED( hr ) && bstrName )
        {
            StrAddW( ppWStr, pcchWStrMax, bstrName );
            SysFreeString( bstrName );

            return TRUE;
        }
    }

    // Didn't get IAccessible (or didn't get a name from it).
    // Try the IDataObject technique instead...

    IDataObject * pdataobj = NULL;
    IOleObject * poleobj = NULL;

    // Try IOleObject::GetClipboardData (which returns an IDataObject) first...
	hr = punk->QueryInterface( IID_IOleObject, (void **) & poleobj );
	if( hr == S_OK )
	{
		hr = poleobj->GetClipboardData( 0, & pdataobj );

        poleobj->Release();
	}

    // If that didn't work (either the QI or the GetClipboardData), try
    // to QI for IDataObject instead...
	if( FAILED( hr ) )
	{
		hr = punk->QueryInterface( IID_IDataObject, (void **)&pdataobj );
	    if( hr != S_OK )
	    {
            return FALSE;
		}
	}

    // Got the IDataObject. Now query it for text formats. Try Unicode first...

    BOOL fGotUnicode = TRUE;

    STGMEDIUM med;
	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

    FORMATETC fetc;
    fetc.cfFormat = CF_UNICODETEXT;
    fetc.ptd = NULL;
    fetc.dwAspect = DVASPECT_CONTENT;
    fetc.lindex = -1;
    fetc.tymed = TYMED_HGLOBAL;

    hr = pdataobj->GetData( & fetc, & med );

	if( hr != S_OK || med.hGlobal == NULL )
    {
        // If we didn't get Unicode, try for ANSI instead...
        fetc.cfFormat = CF_TEXT;
        fGotUnicode = FALSE;

	    hr = pdataobj->GetData( & fetc, & med );
    }

    // Did we get anything?
	if( hr != S_OK || med.hGlobal == NULL )
    {
        return FALSE;
    }

    // Got the text data. Lock the handle...
    void * pv = GlobalLock( med.hGlobal );

    // Copy the text (convert to Unicode if it's ANSI)...
    if( fGotUnicode )
    {
        StrAddW( ppWStr, pcchWStrMax, (LPWSTR) pv );
    }
    else
    {
        // Don't call MultiByteToWideChar if len is == 0, because then it will
        // return length required, not length copied.
        if( *pcchWStrMax > 0 )
        {
            int len = MultiByteToWideChar( CP_ACP, 0, (LPSTR) pv, -1, *ppWStr, *pcchWStrMax );
            // len includes terminating NUL, which we don't want to count...
            if( len > 0 )
                len--;
            if( len > *pcchWStrMax )
                len = *pcchWStrMax;
            *ppWStr += len;
            *pcchWStrMax += len;
        }
    }

    // Unlock resources and return...
    GlobalUnlock( med.hGlobal ); 

	ReleaseStgMedium( & med );

    pdataobj->Release();

    return TRUE;
}



// --------------------------------------------------------------------------
//
//  InvokeMethod
//
//  Helper for IDispatch::Invoke. Assumes exactly one [out,retval] param.
//  Currently only accepts VT_I4 args.
//
//  pDisp is IDispatch to call method on, pName is Unicode name of method.
//  pvarResult is set to the [out,retval] param.
//  cArgs is number of arguments, is followed by type-value pairs - eg.
//
//  Eg. This calls SetRange( 3, 4 )...
//      InvokeMethod( pdisp, L"SetRange", NULL, 2, VT_I4, 3, VT_I4, 4 );
//
// --------------------------------------------------------------------------


HRESULT InvokeMethod( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult, int cArgs, ... )
{
    // Get dispid for this method name...
    DISPID dispid;
    HRESULT hr = pDisp->GetIDsOfNames( IID_NULL, const_cast< LPWSTR * >( & pName ), 1, LOCALE_SYSTEM_DEFAULT, & dispid );
    if( hr != S_OK )
        return hr;

    // Fill in the arguments...

    VARIANT * pvarArgs = new VARIANT [ cArgs ];
    if( ! pvarArgs )
    {
        return E_OUTOFMEMORY;
    }

    va_list arglist;
    va_start( arglist, cArgs );

    for( int i = 0 ; i < cArgs ; i++ )
    {
        int type = va_arg( arglist, int );

        switch( type )
        {
            case VT_I4:
            {
                pvarArgs[ i ].vt = VT_I4;
                pvarArgs[ i ].lVal = va_arg( arglist, DWORD );
                break;
            }

            default:
            {
                TraceError( TEXT("InvokeMethod passed non-VT_I4 argument.") );
                // Since other args are just VT_I4, we don't need to VariantClear them.
                delete [ ] pvarArgs;
                va_end( arglist );
                return E_INVALIDARG;
            }
        }
    }

    va_end( arglist );


    if( pvarResult )
    {
        pvarResult->vt = VT_EMPTY;
    }

    // Make the call to Invoke...

    DISPPARAMS dispparams;
    dispparams.rgvarg = pvarArgs;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cArgs = cArgs;
    dispparams.cNamedArgs = 0;         

    hr = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                        & dispparams, pvarResult, NULL, NULL );

    // Cleanup. (Not much needed - VT_I4's dont need to be VariantClear'd.)

    delete [ ] pvarArgs;

    return hr;
}




// --------------------------------------------------------------------------
//
//  GetProperty
//
//  Helper for IDispatch::Invoke. Returns a property.
//
//  pDisp is IDispatch to call method on, pName is Unicode name of property.
//  pvarResult is set to value of property.
//
// --------------------------------------------------------------------------

HRESULT GetProperty( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult )
{
    // Get dispid for this method name...
    DISPID dispid;
    HRESULT hr = pDisp->GetIDsOfNames( IID_NULL, const_cast< LPWSTR * >( & pName ), 1, LOCALE_SYSTEM_DEFAULT, & dispid );
    if( hr != S_OK )
        return hr;

    pvarResult->vt = VT_EMPTY;

    // Make the call to Invoke...

    DISPPARAMS dispparams;
    dispparams.cArgs = 0;
    dispparams.cNamedArgs = 0;
    dispparams.rgvarg = NULL;
    dispparams.rgdispidNamedArgs = NULL;

    hr = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
                        & dispparams, pvarResult, NULL, NULL );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\imports.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  imports
//
//  GetProcAddress'd APIs
//
// --------------------------------------------------------------------------


void InitImports();

#ifdef _DEBUG

void ReportMissingImports( LPTSTR pStr );

#endif // _DEBUG


BOOL    MyGetGUIThreadInfo(DWORD, PGUITHREADINFO);
BOOL    MyGetCursorInfo(LPCURSORINFO);
BOOL    MyGetWindowInfo(HWND, LPWINDOWINFO);
BOOL    MyGetTitleBarInfo(HWND, LPTITLEBARINFO);
BOOL    MyGetScrollBarInfo(HWND, LONG, LPSCROLLBARINFO);
BOOL    MyGetComboBoxInfo(HWND, LPCOMBOBOXINFO);
BOOL    MyGetAltTabInfo(HWND, int, LPALTTABINFO, LPTSTR, UINT);
BOOL    MyGetMenuBarInfo(HWND, long, long, LPMENUBARINFO);
HWND    MyGetAncestor(HWND, UINT);
HWND    MyGetFocus(void);
HWND    MyRealChildWindowFromPoint(HWND, POINT);
UINT    MyGetWindowClass(HWND, LPTSTR, UINT);
DWORD   MyGetListBoxInfo(HWND);
void    MyGetRect(HWND, LPRECT, BOOL);
DWORD   MyGetModuleFileName(HMODULE hModule,LPTSTR lpFilename,DWORD nSize);
PVOID   MyInterlockedCompareExchange(PVOID *,PVOID,PVOID);
LPVOID  MyVirtualAllocEx(HANDLE,LPVOID,DWORD,DWORD,DWORD);
BOOL    MyVirtualFreeEx(HANDLE,LPVOID,DWORD,DWORD);
BOOL    MyBlockInput(BOOL);
BOOL    MySendInput(UINT cInputs, LPINPUT pInputs, INT cbSize);
LONG	MyNtQueryInformationProcess(HANDLE, INT, PVOID, ULONG, PULONG);


// These two are used directly in sdm.h - all other imports are used via the MyXXX wrappers.
typedef LPVOID (STDAPICALLTYPE* LPFNMAPLS)(LPVOID);
typedef VOID (STDAPICALLTYPE* LPFNUNMAPLS)(LPVOID);
extern LPFNMAPLS               lpfnMapLS;          // KERNEL32 MapLS()
extern LPFNUNMAPLS             lpfnUnMapLS;        // KERNEL32 UnMapLS()



void * Alloc_32BitCompatible( SIZE_T cbSize );
void Free_32BitCompatible( void * pv );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\imports.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  imports
//
//  GetProcAddress'd APIs
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

// #include "imports.h" - already in oleacc_p.h

#include "w95trace.h"

typedef BOOL (STDAPICALLTYPE *LPFNGETGUITHREADINFO)(DWORD, PGUITHREADINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETCURSORINFO)(LPCURSORINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETWINDOWINFO)(HWND, LPWINDOWINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETTITLEBARINFO)(HWND, LPTITLEBARINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETSCROLLBARINFO)(HWND, LONG, LPSCROLLBARINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETCOMBOBOXINFO)(HWND, LPCOMBOBOXINFO);
typedef HWND (STDAPICALLTYPE *LPFNGETANCESTOR)(HWND, UINT);
typedef HWND (STDAPICALLTYPE *LPFNREALCHILDWINDOWFROMPOINT)(HWND, POINT);
typedef UINT (STDAPICALLTYPE *LPFNREALGETWINDOWCLASS)(HWND, LPTSTR, UINT);
typedef BOOL (STDAPICALLTYPE *LPFNGETALTTABINFO)(HWND, int, LPALTTABINFO, LPTSTR, UINT);
typedef BOOL (STDAPICALLTYPE *LPFNGETMENUBARINFO)(HWND, LONG, LONG, LPMENUBARINFO);
typedef DWORD (STDAPICALLTYPE* LPFNGETLISTBOXINFO)(HWND);
typedef BOOL (STDAPICALLTYPE *LPFNSENDINPUT)(UINT, LPINPUT, INT);
typedef BOOL (STDAPICALLTYPE *LPFNBLOCKINPUT)(BOOL);
typedef DWORD (STDAPICALLTYPE* LPFNGETMODULEFILENAME)(HMODULE,LPTSTR,DWORD); 
typedef PVOID (STDAPICALLTYPE* LPFNINTERLOCKCMPEXCH)(PVOID *,PVOID,PVOID);
typedef LPVOID (STDAPICALLTYPE* LPFNVIRTUALALLOCEX)(HANDLE,LPVOID,DWORD,DWORD,DWORD);
typedef BOOL (STDAPICALLTYPE* LPFNVIRTUALFREEEX)(HANDLE,LPVOID,DWORD,DWORD);
typedef LONG (STDAPICALLTYPE* LPFNNTQUERYINFORMATIONPROCESS)(HANDLE,INT,PVOID,ULONG,PULONG);
typedef LONG (STDAPICALLTYPE* LPFNNTALLOCATEVIRTUALMEMORY)(HANDLE,PVOID *,ULONG_PTR,PSIZE_T,ULONG,ULONG);
typedef LONG (STDAPICALLTYPE* LPFNNTFREEVIRTUALMEMORY)(HANDLE,PVOID *,PSIZE_T,ULONG);




LPFNGETGUITHREADINFO    lpfnGuiThreadInfo;  // USER32 GetGUIThreadInfo()
LPFNGETCURSORINFO       lpfnCursorInfo;     // USER32 GetCursorInfo()
LPFNGETWINDOWINFO       lpfnWindowInfo;     // USER32 GetWindowInfo()
LPFNGETTITLEBARINFO     lpfnTitleBarInfo;   // USER32 GetTitleBarInfo()
LPFNGETSCROLLBARINFO    lpfnScrollBarInfo;  // USER32 GetScrollBarInfo()
LPFNGETCOMBOBOXINFO     lpfnComboBoxInfo;   // USER32 GetComboBoxInfo()
LPFNGETANCESTOR         lpfnGetAncestor;    // USER32 GetAncestor()
LPFNREALCHILDWINDOWFROMPOINT    lpfnRealChildWindowFromPoint;   // USER32 RealChildWindowFromPoint
LPFNREALGETWINDOWCLASS  lpfnRealGetWindowClass; // USER32 RealGetWindowClass()
LPFNGETALTTABINFO       lpfnAltTabInfo;     // USER32 GetAltTabInfo()
LPFNGETLISTBOXINFO      lpfnGetListBoxInfo; // USER32 GetListBoxInfo()
LPFNGETMENUBARINFO      lpfnMenuBarInfo;    // USER32 GetMenuBarInfo()
LPFNSENDINPUT           lpfnSendInput;      // USER32 SendInput()
LPFNBLOCKINPUT          lpfnBlockInput;      // USER32 BlockInput()
LPFNGETMODULEFILENAME   lpfnGetModuleFileName;	// KERNEL32 GetModuleFileName()

LPFNMAPLS               lpfnMapLS;          // KERNEL32 MapLS()
LPFNUNMAPLS             lpfnUnMapLS;        // KERNEL32 UnMapLS()

LPFNINTERLOCKCMPEXCH    lpfnInterlockedCompareExchange;  // NT KERNEL32 InterlockedCompareExchange
LPFNVIRTUALALLOCEX      lpfnVirtualAllocEx; // NT KERNEL32 VirtualAllocEx
LPFNVIRTUALFREEEX       lpfnVirtualFreeEx;  // NT KERNEL32 VirtualFreeEx

LPFNNTQUERYINFORMATIONPROCESS lpfnNtQueryInformationProcess; // NTDLL NtQueryInformationProcess
LPFNNTALLOCATEVIRTUALMEMORY   lpfnNtAllocateVirtualMemory; // NTDLL NtAllocateVirtualMemory
LPFNNTFREEVIRTUALMEMORY       lpfnNtFreeVirtualMemory; // NTDLL NtAllocateVirtualMemory



// Try getting pName1 first; if that fails, try pName2 instead.
// Both names are in ANSI, since GetProcAddress always takes ANSI names.
struct ImportInfo
{
    void *  ppfn;
    int     iModule;
    BOOL    fNTOnly;
    LPCSTR  pName1;
    LPCSTR  pName2;
};


enum {
    M_USER, // 0
    M_KERN, // 1
	M_NTDLL,// 2
};

// _AW_ means add the ...A or ...W suffix as appropriate, for Ansi or Unicode compiles.
// _AONLY_ means only do this on Ansi builds - evaluates to NULL on Unicode compiles.

#ifdef UNICODE
#define _AW_ "W"
#define _AONLY_( str ) NULL
#else
#define _AW_ "A"
#define _AONLY_( str ) str
#endif

ImportInfo g_Imports [ ] =
{
    // USER Imports...
    { & lpfnGuiThreadInfo,              M_USER,  FALSE,  "GetGUIThreadInfo"            },
    { & lpfnCursorInfo,                 M_USER,  FALSE,  "GetAccCursorInfo",           "GetCursorInfo"                 },
    { & lpfnWindowInfo,                 M_USER,  FALSE,  "GetWindowInfo"               },
    { & lpfnTitleBarInfo,               M_USER,  FALSE,  "GetTitleBarInfo"             },
    { & lpfnScrollBarInfo,              M_USER,  FALSE,  "GetScrollBarInfo"            },
    { & lpfnComboBoxInfo,               M_USER,  FALSE,  "GetComboBoxInfo"             },
    { & lpfnGetAncestor,                M_USER,  FALSE,  "GetAncestor"                 },
    { & lpfnRealChildWindowFromPoint,   M_USER,  FALSE,  "RealChildWindowFromPoint"    },
    { & lpfnRealGetWindowClass,         M_USER,  FALSE,  "RealGetWindowClass" _AW_,    _AONLY_( "RealGetWindowClass" ) },
    { & lpfnAltTabInfo,                 M_USER,  FALSE,  "GetAltTabInfo" _AW_,         _AONLY_( "GetAltTabInfo" )      },
    { & lpfnGetListBoxInfo,             M_USER,  FALSE,  "GetListBoxInfo"              },
    { & lpfnMenuBarInfo,                M_USER,  FALSE,  "GetMenuBarInfo"              },
    { & lpfnSendInput,                  M_USER,  FALSE,  "SendInput"                   },
    { & lpfnBlockInput,                 M_USER,  FALSE,  "BlockInput"                  },

    // KERNEL imports...
    { & lpfnMapLS,                      M_KERN,  FALSE,  "MapLS"                       },
    { & lpfnUnMapLS,                    M_KERN,  FALSE,  "UnMapLS"                     },
    { & lpfnGetModuleFileName,          M_KERN,  FALSE,  "GetModuleFileName" _AW_      },

    // KERNEL imports - NT only...
    { & lpfnInterlockedCompareExchange, M_KERN,  TRUE,   "InterlockedCompareExchange"  },
    { & lpfnVirtualAllocEx,             M_KERN,  TRUE,   "VirtualAllocEx"              },
    { & lpfnVirtualFreeEx,              M_KERN,  TRUE,   "VirtualFreeEx"               },

	// NTDLL imports - NT only...
	{ & lpfnNtQueryInformationProcess,  M_NTDLL, TRUE,   "NtQueryInformationProcess"   },
	{ & lpfnNtAllocateVirtualMemory,    M_NTDLL, TRUE,   "NtAllocateVirtualMemory"     },
	{ & lpfnNtFreeVirtualMemory,        M_NTDLL, TRUE,   "NtFreeVirtualMemory"         },
};




#ifdef _DEBUG
LPCTSTR g_ImportNames [ ] =
{
    // USER Imports...
    TEXT("GetGUIThreadInfo"),
    TEXT("GetAccCursorInfo"),
    TEXT("GetWindowInfo"),
    TEXT("GetTitleBarInfo"),
    TEXT("GetScrollBarInfo"),
    TEXT("GetComboBoxInfo"),
    TEXT("GetAncestor"),
    TEXT("RealChildWindowFromPoint"),
    TEXT("RealGetWindowClass"),
    TEXT("GetAltTabInfo"),
    TEXT("GetListBoxInfo"),
    TEXT("GetMenuBarInfo"),
    TEXT("SendInput"),
    TEXT("BlockInput"),

    // KERNEL imports...
    TEXT("MapLS"),
    TEXT("UnMapLS"),
    TEXT("GetModuleFileName"),

    // KERNEL imports - NT only...
    TEXT("InterlockedCompareExchange"),
    TEXT("VirtualAllocEx"),
    TEXT("VirtualFreeEx"),

	// NTDLL imports - NT only...
	TEXT("NtQueryInformationProcess"),
	TEXT("NtAllocateVirtualMemory"),
};
#endif // _DEBUG







void ImportFromModule( HMODULE * pahModule, ImportInfo * pInfo, int cInfo )
{
    for( ; cInfo ; pInfo++, cInfo-- )
    {
        HMODULE hModule = pahModule[ pInfo->iModule ];

        FARPROC pfnAddress = GetProcAddress( hModule, pInfo->pName1 );

        // If that didn't work, try the alternate name, if it exists...
        if( ! pfnAddress && pInfo->pName2 )
        {
            pfnAddress = GetProcAddress( hModule, pInfo->pName2 );
        }

        *( (FARPROC *) pInfo->ppfn ) = pfnAddress;
    }
}


void InitImports()
{
    HMODULE hModules[ 3 ];

    hModules[ 0 ] = GetModuleHandle( TEXT("USER32.DLL") );
    hModules[ 1 ] = GetModuleHandle( TEXT("KERNEL32.DLL") );
	hModules[ 2 ] = GetModuleHandle( TEXT("NTDLL.DLL") );

    ImportFromModule( hModules, g_Imports, ARRAYSIZE( g_Imports ) );
}


#ifdef _DEBUG

void ReportMissingImports( LPTSTR pStr )
{
    *pStr = '\0';

    for( int c = 0 ; c < ARRAYSIZE( g_Imports ) ; c++ )
    {
        if( * (FARPROC *) g_Imports[ c ].ppfn == NULL )
        {
            // Only report the NT-only ones when on 9x...
#ifdef _X86_
            if( ! g_Imports[ c ].fNTOnly || ! fWindows95 )
#endif // _X86_
            {
                lstrcat( pStr, g_ImportNames[ c ] );
                lstrcat( pStr, TEXT("\r\n") );
            }
        }
    }
}

#endif // _DEBUG



// --------------------------------------------------------------------------
//
//  MyGetGUIThreadInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetGUIThreadInfo(DWORD idThread, PGUITHREADINFO lpGui)
{
    if (! lpfnGuiThreadInfo)
        return(FALSE);

    lpGui->cbSize = sizeof(GUITHREADINFO);
    return((* lpfnGuiThreadInfo)(idThread, lpGui));
}


// --------------------------------------------------------------------------
//
//  MyGetCursorInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetCursorInfo(LPCURSORINFO lpci)
{
    if (! lpfnCursorInfo)
        return(FALSE);

    lpci->cbSize = sizeof(CURSORINFO);
    return((* lpfnCursorInfo)(lpci));
}


// --------------------------------------------------------------------------
//
//  MyGetWindowInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetWindowInfo(HWND hwnd, LPWINDOWINFO lpwi)
{
    if (!IsWindow(hwnd))
    {
        DBPRINTF (TEXT("OLEACC: warning - calling MyGetWindowInfo for bad hwnd 0x%x\r\n"),hwnd);
        return (FALSE);
    }

    if (! lpfnWindowInfo)
    {
        // BOGUS
        // beginning of a hack for NT4
        {
            GetWindowRect(hwnd,&lpwi->rcWindow);
            GetClientRect( hwnd, & lpwi->rcClient );
			// Convert client rect to screen coords...
			MapWindowPoints( hwnd, NULL, (POINT *) & lpwi->rcClient, 2 );
            lpwi->dwStyle = GetWindowLong (hwnd,GWL_STYLE);
            lpwi->dwExStyle = GetWindowLong (hwnd,GWL_EXSTYLE);
            lpwi->dwWindowStatus = 0; // should have WS_ACTIVECAPTION in here if active
            lpwi->cxWindowBorders = 0; // wrong
            lpwi->cyWindowBorders = 0; // wrong
            lpwi->atomWindowType = 0;  // wrong, but not used anyways
            lpwi->wCreatorVersion = 0; // wrong, only used in SDM proxy. The "WINVER"
            return (TRUE);

        } // end hack for NT4
        return(FALSE);
    }

    lpwi->cbSize = sizeof(WINDOWINFO);
    return((* lpfnWindowInfo)(hwnd, lpwi));
}



// --------------------------------------------------------------------------
//
//  MyGetMenuBarInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetMenuBarInfo(HWND hwnd, long idObject, long idItem, LPMENUBARINFO lpmbi)
{
    if( ! lpfnMenuBarInfo )
        return FALSE;

    // Get the hMenu, and then check that it is valid...
    // We can only do this for _MENU and _CLIENT.
    // Can't use GetSystemMenu for _SYSMENU, since that API *modifies* the
    // system menu of the given hwnd.
    if( idObject == OBJID_MENU || 
        idObject == OBJID_CLIENT )
    {
        HMENU hMenu;

        if( idObject == OBJID_MENU )
        {
            // GetMenu is not defined for child windows
            DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
            if( dwStyle & WS_CHILD )
            {
                hMenu = 0;
            }
            else
            {
        	    hMenu = GetMenu( hwnd );
            }
        }
        else
        {
		    hMenu = (HMENU)SendMessage( hwnd, MN_GETHMENU, 0, 0 );
        }


        if( ! hMenu || ! IsMenu( hMenu ) )
        {
            // If we didn't get a valid menu, quit now...
            return FALSE;
        }
    }
    else if( idObject != OBJID_SYSMENU )
    {
    	return FALSE;
    }


	lpmbi->cbSize = sizeof( MENUBARINFO );
	return lpfnMenuBarInfo( hwnd, idObject, idItem, lpmbi );
}



// --------------------------------------------------------------------------
//
//  MyGetTitleBarInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetTitleBarInfo(HWND hwnd, LPTITLEBARINFO lpti)
{
    if (! lpfnTitleBarInfo)
        return(FALSE);

    lpti->cbSize = sizeof(TITLEBARINFO);
    return((* lpfnTitleBarInfo)(hwnd, lpti));
}


// --------------------------------------------------------------------------
//
//  MyGetScrollBarInfo
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetScrollBarInfo(HWND hwnd, LONG idObject, LPSCROLLBARINFO lpsbi)
{
    if (! lpfnScrollBarInfo)
        return(FALSE);

    lpsbi->cbSize = sizeof(SCROLLBARINFO);
    return((* lpfnScrollBarInfo)(hwnd, idObject, lpsbi));
}


// --------------------------------------------------------------------------
//
//  MyGetComboBoxInfo()
//
//  Calls USER32 if present.  Fills in cbSize field for callers.
//
// --------------------------------------------------------------------------
BOOL MyGetComboBoxInfo(HWND hwnd, LPCOMBOBOXINFO lpcbi)
{
    if (! lpfnComboBoxInfo)
        return(FALSE);

    lpcbi->cbSize = sizeof(COMBOBOXINFO);
    BOOL b = ((* lpfnComboBoxInfo)(hwnd, lpcbi));

    // Some comboxes (eg. comctlV6 port) without edits return a hwndItem
    // equal to the combo hwnd instead of NULL (Their logic is that they are
    // using themselves as the edit...) We compensate for this here...
    if( lpcbi->hwndItem == lpcbi->hwndCombo )
    {
        // item == combo means this combo doesn't have an edit...
        lpcbi->hwndItem = NULL;
    }

    // ComboEx's have their own child edit that the real COMBO doesn't
    // know about - try and find it...
    // (This may also be called on a ComboLBox list - but we're safe here
    // since it won't have children anyway.)
    if( b && lpcbi->hwndItem == NULL )
    {
        lpcbi->hwndItem = FindWindowEx( hwnd, NULL, TEXT("EDIT"), NULL );
        if( lpcbi->hwndItem )
        {
            // Get real item area from area of Edit.
            // (In a ComboEx, there's a gap between the left edge of the
            // combo and the left edge of the Edit, where an icon is drawn)
            GetWindowRect( lpcbi->hwndItem, & lpcbi->rcItem );
            MapWindowPoints( HWND_DESKTOP, hwnd, (POINT*)& lpcbi->rcItem, 2 );
        }
    }

    return b;
}


// --------------------------------------------------------------------------
//
//  MyGetAncestor()
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)
//      GA_ROOTOWNER    gets the "real" top level parent owner
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//      * The _real_ owned root, caused by GetParent()ing up.
//
//  Note: On Win98, USER32's winable.c:GetAncestor(GA_ROOT) faults is called
//  on the invisible alt-tab or system pupop windows. To work-around, we're
//  simulating GA_ROOT by looping GA_PARENT (which is actually what winable.c
//  does, only we're more careful about checking for NULL handles...)
//  - see MSAA bug #891
// --------------------------------------------------------------------------
HWND MyGetAncestor(HWND hwnd, UINT gaFlags)
{
    if (! lpfnGetAncestor)
    {
        // BOGUS        
        // This block is here to work around the lack of this function in NT4.
        // It is modeled on the code in winable2.c in USER. 
        {
            HWND	hwndParent;
            HWND	hwndDesktop;
            DWORD   dwStyle;
            
            if (!IsWindow(hwnd))
            {
                //DebugErr(DBF_ERROR, "MyGetAncestor: Bogus window");
                return(NULL);
            }
            
            if ((gaFlags < GA_MIN) || (gaFlags > GA_MAX))
            {
                //DebugErr(DBF_ERROR, "MyGetAncestor: Bogus flags");
                return(NULL);
            }
            
            hwndDesktop = GetDesktopWindow();
            if (hwnd == hwndDesktop)
                return(NULL);
            dwStyle = GetWindowLong (hwnd,GWL_STYLE);
            
            switch (gaFlags)
            {
            case GA_PARENT:
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow (hwnd,GW_OWNER);
				hwnd = hwndParent;
                break;
                
            case GA_ROOT:
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow (hwnd,GW_OWNER);
                while (hwndParent != hwndDesktop &&
                    hwndParent != NULL)
                {
                    hwnd = hwndParent;
                    dwStyle = GetWindowLong(hwnd,GWL_STYLE);
                    if (dwStyle & WS_CHILD)
                        hwndParent = GetParent(hwnd);
                    else
                        hwndParent = GetWindow (hwnd,GW_OWNER);
                }
                break;
                
            case GA_ROOTOWNER:
                while (hwndParent = GetParent(hwnd))
                    hwnd = hwndParent;
                break;
            }
            
            return(hwnd);
        } // end of the workaround block for NT4
        
        return(FALSE);
    }
	else if( gaFlags == GA_ROOT )
	{
		// BOGUS
		// work-around for win98-user inability to handle GA_ROOT
		// correctly on alt-tab (WinSwitch) and Popup windows
		// - see MSAA bug #891

		// (Asise: we *could* special-case 98vs95 - ie. call
		// GA_ROOT as usual on 95 and special case only on 98...
		// Non special-case-ing may be slightly more inefficient, but
		// means that when testing, there's only *one* code path,
		// so we don't have to worry about ensuring that the
		// win95 version behaves the same as the win98 one.)
        HWND hwndDesktop = GetDesktopWindow();

        if( ! IsWindow( hwnd ) )
            return NULL;

		// Climb up through parents - stop if parent is desktop - or NULL...
		for( ; ; )
		{
			HWND hwndParent = lpfnGetAncestor( hwnd, GA_PARENT );
			if( hwndParent == NULL || hwndParent == hwndDesktop )
				break;
			hwnd = hwndParent;
		}

		return hwnd;
	}
	else
	{
        return lpfnGetAncestor(hwnd, gaFlags);
	}
}


// --------------------------------------------------------------------------
//
//  MyRealChildWindowFromPoint()
//
// --------------------------------------------------------------------------
#if 0
// Old version - called USER's 'RealChildWindowFromPoint'.
HWND MyRealChildWindowFromPoint(HWND hwnd, POINT pt)
{
    if (! lpfnRealChildWindowFromPoint)
    {
        // BOGUS
        // beginning of a hack for NT4
        {
            return (ChildWindowFromPoint(hwnd,pt));
        } // end of a hack for NT4
        return(NULL);
    }

    return((* lpfnRealChildWindowFromPoint)(hwnd, pt));
}
#endif

/*
 *  Similar to USER's ChildWindowFromPoint, except this
 *  checks the HT_TRANSPARENT bit.
 *  USER's ChildWindowFromPoint can't "see through" groupboxes or
 *      other HTTRANSPARENT things,
 *  USER's RealChildWindowFromPoint can "see through" groupboxes but
 *      not other HTTRANSPARENT things (it special cases only groupboxes!)
 *  This can see through anything that responds to WM_NCHITTEST with
 *      HTTRANSPARENT.
 */
HWND MyRealChildWindowFromPoint( HWND hwnd,
                                 POINT pt )
{
    HWND hBestFitTransparent = NULL;
    RECT rcBest;

    // Translate hwnd-relative points to screen-relative...
    MapWindowPoints( hwnd, NULL, & pt, 1 );

    // Infinite looping is 'possible' (though unlikely) when
    // using GetWindow(...NEXT), so we counter-limit this loop...
    int SanityLoopCount = 1024;
    for( HWND hChild = GetWindow( hwnd, GW_CHILD ) ;
         hChild && --SanityLoopCount ;
         hChild = GetWindow( hChild, GW_HWNDNEXT ) )
    {
        // Skip invisible...
        if( ! IsWindowVisible( hChild ) )
            continue;

        // Check for rect...
        RECT rc;
        GetWindowRect( hChild, & rc );
        if( ! PtInRect( & rc, pt ) )
            continue;

        // Try for transparency...
        LRESULT lr = SendMessage( hChild, WM_NCHITTEST, 0, MAKELPARAM( pt.x, pt.y ) );
        if( lr == HTTRANSPARENT )
        {
            // For reasons best known to the writers of USER, statics - used
            // as labels - claim to be transparent. So that we do hit-test
            // to these, we remember the hwnd here, so if nothing better
            // comes along, we'll use this.

            // If we come accross two or more of these, we remember the
            // one that fts inside the other - if any. That way,
            // we hit-test to siblings 'within' siblings - eg. statics in
            // a groupbox.

            if( ! hBestFitTransparent )
            {
                hBestFitTransparent = hChild;
                GetWindowRect( hChild, & rcBest );
            }
            else
            {
                // Is this child within the last remembered transparent?
                // If so, remember it instead.
                RECT rcChild;
                GetWindowRect( hChild, & rcChild );
                if( rcChild.left >= rcBest.left &&
                    rcChild.top >= rcBest.top &&
                    rcChild.right <= rcBest.right &&
                    rcChild.bottom <= rcBest.bottom )
                {
                    hBestFitTransparent = hChild;
                    rcBest = rcChild;
                }
            }

            continue;
        }

        // Got the window!
        return hChild;
    }

    if( SanityLoopCount == 0 )
        return NULL;

    // Did we find a transparent (eg. a static) on our travels? If so, since
    // we couldn't find anything better, may as well use it.
    if( hBestFitTransparent )
        return hBestFitTransparent;

    // Otherwise return the original window (not NULL!) if no child found...
    return hwnd;
}

// --------------------------------------------------------------------------
//
//  MyGetWindowClass()
//
//  Gets the "real" window type, works for superclassers like "ThunderEdit32"
//  and so on.
//
// --------------------------------------------------------------------------
UINT MyGetWindowClass(HWND hwnd, LPTSTR lpszName, UINT cchName)
{
    *lpszName = 0;

    if (! lpfnRealGetWindowClass)
	{
		// BOGUS 
        // Hack for NT 4
        {
		    return (GetClassName(hwnd,lpszName,cchName));
        } // end of hack for NT 4
        return(0);
	}

    return((* lpfnRealGetWindowClass)(hwnd, lpszName, cchName));
}


// --------------------------------------------------------------------------
//
//  MyGetAltTabInfo()
//
//  Gets the alt tab information
//
// --------------------------------------------------------------------------
BOOL MyGetAltTabInfo(HWND hwnd, int iItem, LPALTTABINFO lpati, LPTSTR lpszItem,
    UINT cchItem)
{
    if (! lpfnAltTabInfo)
        return(FALSE);

    lpati->cbSize = sizeof(ALTTABINFO);

    return((* lpfnAltTabInfo)(hwnd, iItem, lpati, lpszItem, cchItem));
}



// --------------------------------------------------------------------------
//
//  MyGetListBoxInfo()
//
//  Gets the # of items per column currently in a listbox
//
// --------------------------------------------------------------------------
DWORD MyGetListBoxInfo(HWND hwnd)
{
    if (! lpfnGetListBoxInfo)
        return(0);

    return((* lpfnGetListBoxInfo)(hwnd));
}
                                         

// --------------------------------------------------------------------------
//
//  MySendInput()
//
//  Calls USER32 function if present.
//
// --------------------------------------------------------------------------
BOOL MySendInput(UINT cInputs, LPINPUT pInputs, INT cbSize)
{
    if (! lpfnSendInput)
        return(FALSE);

    return((* lpfnSendInput)(cInputs,pInputs,cbSize));
}

//--------------------------------------------------------
// [v-jaycl, 6/7/97] Added MyBlockInput support for NT 4.0 
//--------------------------------------------------------

// --------------------------------------------------------------------------
//
//  MyBlockInput()
//
//  Calls USER32 function if present.
//
// --------------------------------------------------------------------------
BOOL MyBlockInput(BOOL bBlock)
{
    if (! lpfnBlockInput)
        return(FALSE);

    return((* lpfnBlockInput)( bBlock ) );
}

// --------------------------------------------------------------------------
//  MyInterlockedCompareExchange
//
//  Calls the function when we are running on NT
// --------------------------------------------------------------------------
PVOID MyInterlockedCompareExchange(PVOID *Destination,PVOID Exchange,PVOID Comperand)
{
    if (!lpfnInterlockedCompareExchange)
        return (NULL);

    return ((* lpfnInterlockedCompareExchange)(Destination,Exchange,Comperand));
}

// --------------------------------------------------------------------------
//  MyVirtualAllocEx
//
//  Calls the function when we are running on NT
// --------------------------------------------------------------------------
LPVOID MyVirtualAllocEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD flAllocationType,DWORD flProtect)
{
    if (!lpfnVirtualAllocEx)
        return (NULL);

    return ((* lpfnVirtualAllocEx)(hProcess,lpAddress,dwSize,flAllocationType,flProtect));
}

// --------------------------------------------------------------------------
//  MyVirtualFreeEx
//
//  Calls the function when we are running on NT.
// --------------------------------------------------------------------------
BOOL MyVirtualFreeEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD dwFreeType)
{
    if (!lpfnVirtualFreeEx)
        return (FALSE);

    return ((* lpfnVirtualFreeEx)(hProcess,lpAddress,dwSize,dwFreeType));
}

// --------------------------------------------------------------------------
//  MyGetModuleFileName
// --------------------------------------------------------------------------
DWORD MyGetModuleFileName(HMODULE hModule,LPTSTR lpFilename,DWORD nSize)
{
    if (!lpfnGetModuleFileName)
        return (0);

    return ((* lpfnGetModuleFileName)(hModule,lpFilename,nSize));
}

// --------------------------------------------------------------------------
//  MyNtQueryInformationProcess
//
//  Calls the function when we are running on NT.
// --------------------------------------------------------------------------
LONG MyNtQueryInformationProcess(HANDLE hProcess, INT iProcInfo, PVOID pvBuf, ULONG ccbBuf, PULONG pulRetLen)
{
	if (!lpfnNtQueryInformationProcess)
		return -1;

	return (* lpfnNtQueryInformationProcess)(hProcess, iProcInfo, pvBuf, ccbBuf, pulRetLen);
}




void * Alloc_32BitCompatible( SIZE_T cbSize )
{

#ifndef _WIN64

    return new BYTE [ cbSize ];

#else

    if( ! lpfnNtAllocateVirtualMemory
     || ! lpfnNtFreeVirtualMemory )
    {
        return new BYTE [ cbSize ];
    }

    // Note that the mask-style of the ZeroBits param only works on Win64. This
    // mask specifies which bits may be used in the address. 7FFFFFFF -> 31-bit
    // address

    // ISSUE-2000/08/11-brendanm
    // Since granularity of returned blocks is 64k, we should do some sort of
    // block suballocation to avoid wasting memory.

    PVOID pBaseAddress = NULL;
    LONG ret = lpfnNtAllocateVirtualMemory( GetCurrentProcess(),
                                            & pBaseAddress,
                                            0x7FFFFFFF,
                                            & cbSize,
                                            MEM_COMMIT,
                                            PAGE_READWRITE );

    if( ret < 0 )
    {
        return NULL;
    }

    return pBaseAddress;

#endif

}


void Free_32BitCompatible( void * pv )
{

#ifndef _WIN64

    delete [ ] (BYTE *) pv;

#else

    if( ! lpfnNtAllocateVirtualMemory
     || ! lpfnNtFreeVirtualMemory )
    {
        delete [ ] (BYTE *) pv;
    }

    DWORD_PTR cbSize = 0;
    lpfnNtFreeVirtualMemory( GetCurrentProcess(), & pv, & cbSize, MEM_RELEASE );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\ipaddress.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  IPAddress.H
//
//  IP Address control
//
// --------------------------------------------------------------------------

class   CIPAddress : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);

        CIPAddress(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\ipaddress.cpp ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  IPAddress.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "ipaddress.h"



// --------------------------------------------------------------------------
//
//  CreateIPAddressClient()
//
// --------------------------------------------------------------------------
HRESULT CreateIPAddressClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvIPAddr)
{
    CIPAddress * pipaddr;
    HRESULT hr;

    InitPv(ppvIPAddr);

    pipaddr = new CIPAddress(hwnd, idChildCur);
    if (!pipaddr)
        return(E_OUTOFMEMORY);

    hr = pipaddr->QueryInterface(riid, ppvIPAddr);
    if (!SUCCEEDED(hr))
        delete pipaddr;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CIPAddress::CIPAddress()
//
// --------------------------------------------------------------------------
CIPAddress::CIPAddress(HWND hwnd, long idChildCur)
    : CClient( CLASS_IPAddressClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}


// --------------------------------------------------------------------------
//
//  CIPAddress::get_accValue()
//
//  Gets the text contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CIPAddress::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_IPADDRESS; 

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CIPAddress::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::put_accValue(VARIANT varChild, BSTR szValue)
{
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// If unicode, use the BSTR directly...
	lpszValue = szValue;

#else

	// If not UNICODE, allocate a temp string and convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif


    SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);

#ifndef UNICODE

	// If non-unicode, free the temp string we allocated above
    LocalFree((HANDLE)lpszValue);

#endif

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\listbox.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTBOX.H
//
//  Default listbox OLE ACC Client
//
// --------------------------------------------------------------------------


class CListBox : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR *pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT * pvarFocus);
        STDMETHODIMP        get_accSelection(VARIANT *pvarSelection);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);

        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);
        STDMETHODIMP        accSelect(long flagsSel, VARIANT varChild);
        STDMETHODIMP        accLocation(long* pxLeft, long *pyTop, long *pcxWidth,
            long *pcyHeight, VARIANT varChild);
        STDMETHODIMP        accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT *pvarHit);

        void SetupChildren(void);
        CListBox(HWND, long);

    protected:
        BOOL    m_fComboBox;
        BOOL    m_fDropDown;
};


class CListBoxFrame : public CWindow
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch **ppdispParent);
        STDMETHODIMP        get_accState(VARIANT varStart, VARIANT* pvarState);

        // This has the wrong signature, and is never used.
        // STDMETHODIMP        accNavigate(VARIANT varStart, long dwNavDir, VARIANT* pvarEnd);

        CListBoxFrame(HWND, long);

    protected:
        BOOL    m_fComboBox;
        BOOL    m_fDropDown;
};



// --------------------------------------------------------------------------
//
//  Although CListBoxSelection() is based off of CAccessibleObject, it only
//  supports IDispatch and IEnumVARIANT.  It will hand back the proper IDs
//  so you can pass them to the real listbox parent object.
//
// --------------------------------------------------------------------------
class CListBoxSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListBoxSelection(int, int, LPINT);
        ~CListBoxSelection();

    protected:
        int     m_cRef;
        int     m_idChildCur;
        int     m_cSelected;
        LPINT   m_lpSelected;
};


extern HRESULT GetListBoxSelection(HWND hwnd, VARIANT * pvarSelection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\listview.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTVIEW.CPP
//
//  Wrapper for COMCTL32's listview control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "listview.h"
#include "RemoteProxy6432.h"
#include "propmgr_util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"


#ifndef LVM_GETSELECTEDCOLUMN

#define LVM_GETVIEW         (LVM_FIRST + 143)
#define ListView_GetView(hwnd) \
    SNDMSG((hwnd), LVM_GETVIEW, 0, 0)

#define LVM_GETSELECTEDCOLUMN   (LVM_FIRST + 174)
#define ListView_GetSelectedColumn(hwnd) \
    (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)

#define LV_VIEW_ICON        0x0000
#define LV_VIEW_DETAILS     0x0001
#define LV_VIEW_SMALLICON   0x0002
#define LV_VIEW_LIST        0x0003
#define LV_VIEW_TILE        0x0004

#endif








#define MAX_NAME_TEXT   256


enum
{
    LV_IMGIDX_Image,
    LV_IMGIDX_State,
    LV_IMGIDX_Overlay,
    LV_IMGIDX_COUNT
};

BOOL LVGetImageIndex( HWND hwnd, int id, int aKeys[ LV_IMGIDX_COUNT ] );

HRESULT LVBuildDescriptionString( HWND hwnd, int iItem, int * pCols, int cCols, BSTR * pszDesc );

HRESULT LVGetDescription_ReportView( HWND hwnd, int iItem, BSTR * pszDesc );

HRESULT LVGetDescription_TileView( HWND hwnd, int iItem, BSTR * pszDesc );


extern "C" {
// in outline.cpp...
BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole );
BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState );
}



// --------------------------------------------------------------------------
//
//  CreateListViewClient()
//
// --------------------------------------------------------------------------
HRESULT CreateListViewClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvList)
{
    CListView32 * plist;
    HRESULT     hr;

    InitPv(ppvList);

    plist = new CListView32(hwnd, idChildCur);
    if (!plist)
        return(E_OUTOFMEMORY);

    hr = plist->QueryInterface(riid, ppvList);
    if (!SUCCEEDED(hr))
        delete plist;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListView32::CListView32()
//
// --------------------------------------------------------------------------
CListView32::CListView32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ListViewClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CListView32::SetupChildren()
//
// --------------------------------------------------------------------------
void CListView32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, LVM_GETITEMCOUNT, 0, 0L);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_DESKTOP))
            return(HrCreateString(STR_DESKTOP_NAME, pszName));
        else
            return(CClient::get_accName(varChild, pszName));
    }

	TCHAR tchText[MAX_NAME_TEXT + 1] = {0};
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT;
	lvi.pszText = tchText;
	lvi.cchTextMax = MAX_NAME_TEXT;
	lvi.iItem = varChild.lVal - 1;

	if (SUCCEEDED(XSend_ListView_GetItem(m_hwnd, LVM_GETITEM, 0, &lvi)))
	{
		if (*lvi.pszText)
			*pszName = TCharSysAllocString(lvi.pszText);
	}

    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);
    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::get_accDescription(varChild, pszDesc);

    // Special cases for details (report) and tile views.
    

    DWORD dwView = ListView_GetView( m_hwnd );

    DWORD dwStyle = GetWindowLong( m_hwnd, GWL_STYLE );

    // Have to check for report/details view in two ways: 
    // - check the style for LVS_REPORT (pre-V6)
    // - check LVM_GETVIEW for LV_VIEW_DETAILS (V6+)
    if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
        || dwView == LV_VIEW_DETAILS )
    {
        return LVGetDescription_ReportView( m_hwnd, varChild.lVal - 1, pszDesc );
    }

    if( dwView == LV_VIEW_TILE )
    {
        return LVGetDescription_TileView( m_hwnd, varChild.lVal - 1, pszDesc );
    }

    return E_NOT_APPLICABLE;
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    if ( pszHelp == NULL )
        return E_POINTER;
    
    InitPv(pszHelp);
    if (!ValidateChild(&varChild))
        return E_INVALIDARG;
    
    if (!varChild.lVal)
        return(S_FALSE);

    LVITEM_V6 lvi;
    lvi.iItem = varChild.lVal -1;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_GROUPID;
    lvi.cColumns = 0;
    lvi.puColumns = NULL;

    HRESULT hr;
    
    hr = XSend_ListView_V6_GetItem( m_hwnd, LVM_GETITEM, 0, &lvi );
    if( hr != S_OK || lvi.iGroupId <= 0 )
    {
        DBPRINTF( TEXT("XSend_ListView_V6_GetItem hr = %x, lvi.iGroupId = %d\r\n"), hr,  lvi.iGroupId );
        return E_NOT_APPLICABLE;
    }

    
    LVGROUP_V6 grp;
	memset(&grp, 0, sizeof(LVGROUP_V6));
	TCHAR szHeader[MAX_NAME_TEXT + 1] = {0};
	
    grp.cbSize = sizeof(LVGROUP_V6);
    grp.mask = LVGF_HEADER;
	grp.pszHeader = szHeader;
	grp.cchHeader = MAX_NAME_TEXT;
	grp.iGroupId = lvi.iGroupId;

    hr = XSend_ListView_V6_GetGroupInfo( m_hwnd, LVM_GETGROUPINFO, lvi.iGroupId, &grp );
    if( FAILED( hr ) )
        return hr;
    
    *pszHelp = TCharSysAllocString( grp.pszHeader );
    
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
    {
        DWORD dwRole;
        BOOL fGotRole = FALSE;

        int aKeys[ LV_IMGIDX_COUNT ];
        if( LVGetImageIndex( m_hwnd, varChild.lVal - 1, aKeys ) )
        {
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_ROLEMAP,
                               aKeys, ARRAYSIZE( aKeys ),
                               & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
            else if( GetRoleFromStateImageMap( m_hwnd, aKeys[ LV_IMGIDX_Image ], & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
        }

        if( ! fGotRole )
        {
            //
            //  Note that just because the listview has LVS_EX_CHECKBOXES
            //  doesn't mean that every item is itself a checkbox.  We
            //  need to sniff at the item, too, to see if it has a state
            //  image.
            //
            DWORD dwExStyle = SendMessageINT(m_hwnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
            if ((dwExStyle & LVS_EX_CHECKBOXES) &&
                ListView_GetItemState(m_hwnd, varChild.lVal-1, LVIS_STATEIMAGEMASK))
            {
                pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
            else
            {
                pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
            }
        }
    }
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
long    lState;
DWORD   dwStyle;
DWORD   dwExStyle;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    lState = SendMessageINT(m_hwnd, LVM_GETITEMSTATE, varChild.lVal-1, 0xFFFFFFFF);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (lState & LVIS_FOCUSED)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }

    pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

    dwStyle = GetWindowLong (m_hwnd,GWL_STYLE);
    if (!(dwStyle & LVS_SINGLESEL))
        pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;

    if (lState & LVIS_SELECTED)
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    if (lState & LVIS_DROPHILITED)
        pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

    // If this is a checkbox listview, then look at the checkbox state.
    // State 0 = no checkbox, State 1 = unchecked, State 2 = checked
    dwExStyle = SendMessageINT(m_hwnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
    if ((dwExStyle & LVS_EX_CHECKBOXES) &&
        (lState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2))
        pvarState->lVal |= STATE_SYSTEM_CHECKED;

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    int aKeys[ LV_IMGIDX_COUNT ];
    if( LVGetImageIndex( m_hwnd, varChild.lVal - 1, aKeys ) )
    {
        DWORD dwState;
        if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                           PROPINDEX_STATEMAP,
                           aKeys, ARRAYSIZE( aKeys ),
                           & dwState ) )
        {
            pvarState->lVal |= dwState;
        }
        else if( GetStateFromStateImageMap( m_hwnd, aKeys[ LV_IMGIDX_Image ], & dwState ) )
        {
            pvarState->lVal |= dwState;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accFocus(VARIANT* pvarFocus)
{
    long    lFocus;
    HRESULT hr;

    //
    // Do we have the focus?
    //
    hr = CClient::get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr) || (pvarFocus->vt != VT_I4) || (pvarFocus->lVal != 0))
        return(hr);

    //
    // We do.  What item is focused?
    //
    lFocus = SendMessageINT(m_hwnd, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_FOCUSED);

    if (lFocus != -1)
        pvarFocus->lVal = lFocus+1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accDefaultAction()
//
//  Since the default action for a listview item is really determined by the
//  creator of the listview control, the best we can do is double click on
//  the thing, and return "double click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    DWORD dwExStyle = ListView_GetExtendedListViewStyle( m_hwnd );
    if (varChild.lVal)
    {
        if ( dwExStyle & LVS_EX_ONECLICKACTIVATE )
            return HrCreateString(STR_CLICK, pszDefAction);
        else
            return HrCreateString(STR_DOUBLE_CLICK, pszDefAction);
    }
    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CListView32::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a list
//  view item is, so unless the parent overrides us, we'll just do a double
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accDoDefaultAction(VARIANT varChild)
{
	LPRECT		lprcLoc;
    RECT        rcLocal;
    HANDLE      hProcess;
	
    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {
        // Can't just use accLocation, since that gives back the rectangle
        // for the whole line in details view, but you can only click on 
        // a certain part - icon and text. So we'll just ask the control
        // for that rectangle.
        lprcLoc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
        if (!lprcLoc)
            return(E_OUTOFMEMORY);

        //lprcLoc->left = LVIR_ICON;
        rcLocal.left = LVIR_ICON;
        SharedWrite (&rcLocal,lprcLoc,sizeof(RECT),hProcess);

        if (SendMessage(m_hwnd, LVM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprcLoc))
        {
            SharedRead (lprcLoc,&rcLocal,sizeof(RECT),hProcess);
            MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);
            // convert to width and height
            rcLocal.right = rcLocal.right - rcLocal.left;
            rcLocal.bottom = rcLocal.bottom - rcLocal.top;

            BOOL fDoubleClick = TRUE;
            DWORD dwExStyle = ListView_GetExtendedListViewStyle( m_hwnd );
            if ( dwExStyle & LVS_EX_ONECLICKACTIVATE )
                fDoubleClick = FALSE;
            
            // this will check if WindowFromPoint at the click point is the same
	        // as m_hwnd, and if not, it won't click. Cool!
	        if ( ClickOnTheRect( &rcLocal, m_hwnd, fDoubleClick ) )
            {
                SharedFree(lprcLoc,hProcess);
		        return (S_OK);
            }
        }
        SharedFree(lprcLoc,hProcess);
    }
    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accSelection(VARIANT* pvarSelection)
{
    return(GetListViewSelection(m_hwnd, pvarSelection));
}



// --------------------------------------------------------------------------
//
//  CListView32::accSelect()
//
// Selection Flags can be OR'ed together, with certain limitations. So we 
// need to check each flag and do appropriate action.
//
//  Selection flags:
//  SELFLAG_TAKEFOCUS               
//  SELFLAG_TAKESELECTION           
//  SELFLAG_EXTENDSELECTION         
//  SELFLAG_ADDSELECTION            
//  SELFLAG_REMOVESELECTION         
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accSelect(long selFlags, VARIANT varChild)
{
long     lState;
long     lStateMask;
long     lFocusedItem;

    if (!ValidateChild(&varChild) || !ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(selFlags, varChild));


    if (selFlags & SELFLAG_TAKEFOCUS) 
    {
        MySetFocus(m_hwnd);
    }

    // get the thing with focus (anchor point)
    // if no focus, use first one
    // have to get it here because we might clear it b4 we need it.
    lFocusedItem = ListView_GetNextItem(m_hwnd, -1,LVNI_FOCUSED);
    if (lFocusedItem == -1)
        lFocusedItem = 0;
        
    varChild.lVal--;

    // First check if there can be more than one item selected.
	if ((selFlags & SELFLAG_ADDSELECTION) || 
        (selFlags & SELFLAG_REMOVESELECTION) ||
        (selFlags & SELFLAG_EXTENDSELECTION))
	{
		// LVM_GETITEMSTATE doesn't compare 0xFFFFFFFF so don't worry about sign extension
		if (SendMessage(m_hwnd, LVM_GETITEMSTATE, varChild.lVal, 0xFFFFFFFF) & LVS_SINGLESEL)
			return (E_NOT_APPLICABLE);
	}

    // If the take focus flag is set, check if it can get focus &
    // remove focus from other items
	if (selFlags & SELFLAG_TAKEFOCUS)
	{
        if (MyGetFocus() != m_hwnd)
        {
            return(S_FALSE);
        }
        RemoveCurrentSelFocus(SELFLAG_TAKEFOCUS);
	}

    // If the take selection flag is set, remove selection from other items
    if (selFlags & SELFLAG_TAKESELECTION)
        RemoveCurrentSelFocus(SELFLAG_TAKESELECTION);

	lState = 0;
    lStateMask = 0;

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVM_SETITEMSTATE;

    // now is where the real work starts. If they are just taking
    // selection, adding a selection, or removing a selection, it is
    // pretty easy. But if they are extending the selection, we'll have
    // to loop through from where the focus is to this one and select or
    // deselect each one.
    if ((selFlags & SELFLAG_EXTENDSELECTION) == 0) // not extending (easy)
    {
        if (selFlags & SELFLAG_ADDSELECTION ||
            selFlags & SELFLAG_TAKESELECTION)
        {
            lState |= LVIS_SELECTED;
            lStateMask |= LVIS_SELECTED;
        }

        if (selFlags & SELFLAG_REMOVESELECTION)
            lStateMask |= LVIS_SELECTED;

        if (selFlags & SELFLAG_TAKEFOCUS)
        {
	        lState |= LVIS_FOCUSED;
            lStateMask |= LVIS_FOCUSED;
        }

		lvi.state = lState;
		lvi.stateMask  = lStateMask;

		// TODO (micw) Dumpty doesn't test this function
		XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, varChild.lVal, &lvi);
    }
    else // we are extending the selection (hard work)
    {
    long        i;
    long        nIncrement;

        // we are always selecting or deselecting, so statemask
        // always has LVIS_SELECTED.
        lStateMask = LVIS_SELECTED;

        // if neither ADDSELECTION or REMOVESELECTION is set, then we are
        // supposed to do something based on the selection state of whatever
        // has the focus.
        if (selFlags & SELFLAG_ADDSELECTION)
            lState |= LVIS_SELECTED;
        
        if (((selFlags & SELFLAG_REMOVESELECTION) == 0) &&
            ((selFlags & SELFLAG_ADDSELECTION) == 0))
        {
            // if focused item is selected, lState to have selected also
    		if (SendMessage(m_hwnd, LVM_GETITEMSTATE, lFocusedItem, 0xFFFFFFFF) 
                & LVIS_SELECTED)
                lState |= LVIS_SELECTED;
        }

		lvi.state = lState;
		lvi.stateMask  = lStateMask;

        // Now walk through from focused to current, setting the state.
        // Set increment and last one depending on direction
        if (lFocusedItem > varChild.lVal)
        {
            nIncrement = -1;
            varChild.lVal--;
        }
        else
        {
            nIncrement = 1;
            varChild.lVal++;
        }

        for (i=lFocusedItem; i!=varChild.lVal; i+=nIncrement)
			XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, i, &lvi);

        // focus the last one if needed
        if (selFlags & SELFLAG_TAKEFOCUS)
        {
            lStateMask |= LVIS_FOCUSED;
            lState |= LVIS_FOCUSED;

			lvi.state = lState;
			lvi.stateMask  = lStateMask;
			XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, i-nIncrement, &lvi);
        }
    }
    
	return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CListView32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprc;
    RECT    rcLocal;
    HANDLE  hProcess;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    // Get the listview item rect.
    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprc)
        return(E_OUTOFMEMORY);

    rcLocal.left = LVIR_BOUNDS;
    SharedWrite (&rcLocal,lprc,sizeof(RECT),hProcess);

    if (SendMessage(m_hwnd, LVM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcLocal,sizeof(RECT),hProcess);
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;
    }

    SharedFree(lprc,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd = 0;
    int     lvFlags;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    DWORD dwStyle = GetWindowLong(m_hwnd, GWL_STYLE); 


    //
    // Gotta love those listview dudes!  They have all the messages we need
    // to do hittesting, location, and navigation easily.  And those are
    // by far the hardest things to manually implement.  
    //
    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_LEFT:
            
            if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
                || ListView_GetView( m_hwnd ) == LV_VIEW_DETAILS )
            {
                break;  // in report view there is nothing to the left
            }

            lvFlags = LVNI_TOLEFT;
            goto Navigate;

        case NAVDIR_RIGHT:

            if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
                || ListView_GetView( m_hwnd ) == LV_VIEW_DETAILS )
            {
                break;  // in report view there is nothing to the right
            }

            lvFlags = LVNI_TORIGHT;
            goto Navigate;

        case NAVDIR_UP:
            lvFlags = LVNI_ABOVE;
            goto Navigate;

        case NAVDIR_DOWN:
            lvFlags = LVNI_BELOW;
Navigate:
            // Note that if nothing is there, COMCTL32 will return -1, and -1+1 is
            // zero, meaning nothing in our land also.
            lEnd = SendMessageINT(m_hwnd, LVM_GETNEXTITEM, varStart.lVal-1, lvFlags);
            ++lEnd;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListView32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT     hr;
    HANDLE      hProcess;
    int         nSomeInt;
    POINT       ptLocal;
    LPLVHITTESTINFO lpht;

    SetupChildren();
    
    //
    // Is the point in the listview at all?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    //
    // Now find out what item this point is on.
    //
    lpht = (LPLVHITTESTINFO)SharedAlloc(sizeof(LVHITTESTINFO),m_hwnd,&hProcess);
    if (!lpht)
        return(E_OUTOFMEMORY);

    //lpht->iItem = -1;
    nSomeInt = -1;
    SharedWrite (&nSomeInt,&lpht->iItem,sizeof(int),hProcess);
    ptLocal.x = x;
    ptLocal.y = y;
    ScreenToClient(m_hwnd, &ptLocal);
    SharedWrite (&ptLocal,&lpht->pt,sizeof(POINT),hProcess);

    //
    // LVM_SUBHITTEST will return -1 if the point isn't over an item.  And -1
    // + 1 is zero, which is self.  So that works great for us.
    //
    SendMessage(m_hwnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpht);
    SharedRead (&lpht->iItem,&pvarHit->lVal,sizeof(int),hProcess);
    pvarHit->lVal++;

    SharedFree(lpht,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  RemoveCurrentSelFocus()
//
//  This removes all selected/focused items.
//
// -------------------------------------------------------------------------
void CListView32::RemoveCurrentSelFocus(long lState)
{
	// Set up LVITEM struct

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.stateMask = lState;
	lvi.state = 0;

    //
    // Loop through all focused/selected items.
    //
    long lNext = ListView_GetNextItem(m_hwnd, -1,
        ((lState == LVIS_FOCUSED) ? LVNI_FOCUSED : LVNI_SELECTED));
    while (lNext != -1)
    {
		// TODO (micw) Dumpty doesn't call this function
		if (FAILED(XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, lNext, &lvi)))
			return;

        lNext = ListView_GetNextItem(m_hwnd, lNext,
            ((lState == LVIS_FOCUSED) ? LVNI_FOCUSED : LVNI_SELECTED));
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//  MULTIPLE SELECTION LISTVIEW SUPPORT
//
//  If a listview has more than one item selected, we create an object that
//  is a clone.  It supports merely IUnknown and IEnumVARIANT, and is a 
//  collection.  The caller should take the returned item IDs and pass them
//  in a VARIANT (VT_I4, ID as lVal) to the parent object.
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  GetListViewSelection()
//
// --------------------------------------------------------------------------
HRESULT GetListViewSelection(HWND hwnd, VARIANT* pvarSelection)
{
    int     cSelected;
    LPINT   lpSelected;
    long    lRet;
    int     iSelected;
    CListViewSelection * plvs;

    InitPvar(pvarSelection);

    cSelected = SendMessageINT(hwnd, LVM_GETSELECTEDCOUNT, 0, 0L);

    //
    // No selection.
    //
    if (!cSelected)
        return(S_FALSE);

    //
    // Single item.
    //
    if (cSelected == 1)
    {
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED) + 1;
        return(S_OK);
    }

    //
    // Multiple items, must make a collection object.
    //

    // Allocate the list.
    lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(INT));
    if (!lpSelected)
        return(E_OUTOFMEMORY);

    plvs = NULL;

    // Get the list of selected items.
    lRet = -1;
    for (iSelected = 0; iSelected < cSelected; iSelected++)
    {
        lRet = ListView_GetNextItem(hwnd, lRet, LVNI_SELECTED);
        if (lRet == -1)
            break;

        lpSelected[iSelected] = lRet;
    }

    //
    // Did something go wrong in the middle?
    //
    cSelected = iSelected;
    if (cSelected)
    {
        plvs = new CListViewSelection(0, cSelected, lpSelected);
        if (plvs)
        {
            pvarSelection->vt = VT_UNKNOWN;
            plvs->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
        }
    }

    //
    // Free the list memory no matter what, the constructor will make a copy.
    //
    if (lpSelected)
        LocalFree((HANDLE)lpSelected);

    if (!plvs)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::CListViewSelection()
//
// --------------------------------------------------------------------------
CListViewSelection::CListViewSelection(int iChildCur, int cTotal, LPINT lpItems)
{
    m_idChildCur = iChildCur;

    m_lpSelected = (LPINT)LocalAlloc(LPTR, cTotal*sizeof(int));
    if (!m_lpSelected)
        m_cSelected = 0;
    else
    {
        m_cSelected = cTotal;
        CopyMemory(m_lpSelected, lpItems, cTotal*sizeof(int));
    }
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::~CListViewSelection()
//
// --------------------------------------------------------------------------
CListViewSelection::~CListViewSelection()
{
    //
    // Free selection list
    //
    if (m_lpSelected)
    {
        LocalFree((HANDLE)m_lpSelected);
        m_cSelected = 0;
        m_lpSelected = NULL;
    }
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::QueryInterface()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::QueryInterface(REFIID riid, void** ppunk)
{
    InitPv(ppunk);

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListViewSelection::AddRef(void)
{
    return(++m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListViewSelection::Release(void)
{
    if ((--m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent ListView that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the ListView object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    //
    // Initialize VARIANTs
    // This is so bogus
    //
    pvar = rgvar;
    for (iCur = 0; iCur < (long)celt; iCur++, pvar++)
        VariantInit(pvar);

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cSelected))
    {
        pvar->vt = VT_I4;
        pvar->lVal = m_lpSelected[iCur] + 1;

        ++cFetched;
        ++iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Skip(ULONG celt)
{
    m_idChildCur += celt;
    if (m_idChildCur > m_cSelected)
        m_idChildCur = m_cSelected;

    //
    // We return S_FALSE if at the end.
    //
    return((m_idChildCur >= m_cSelected) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Clone(IEnumVARIANT **ppenum)
{
    CListViewSelection * plistselnew;

    InitPv(ppenum);

    plistselnew = new CListViewSelection(m_idChildCur, m_cSelected, m_lpSelected);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}



BOOL LVGetImageIndex( HWND hwnd, int id, int aKeys[ LV_IMGIDX_COUNT ] )
{
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_IMAGE | LVIF_STATE;
	lvi.iItem = id;

	// TODO (micw) Dumpty doesn't call this function
	if (SUCCEEDED(XSend_ListView_GetItem(hwnd, LVM_GETITEM, 0, &lvi)))
    {
        aKeys[ LV_IMGIDX_Image ]   = lvi.iImage;
        aKeys[ LV_IMGIDX_Overlay ] = ( lvi.state >> 8 ) & 0xF;
        aKeys[ LV_IMGIDX_State ]   = ( lvi.state >> 12 ) & 0xF;

		return TRUE;
    }
    else
    {
        return FALSE;
    }
}




















#define COLONSEP TEXT(": ")

HRESULT LVBuildDescriptionString( HWND hwnd, int iItem, int * pCols, int cCols, BSTR * pszDesc )
{
    // Declare ListView Structure plus a string to hold description.
	TCHAR tchText[81];

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT;
	lvi.pszText = tchText;
	lvi.cchTextMax = ARRAYSIZE( tchText ) - 1; // -1 for NUL
	lvi.iItem = iItem;

    TCHAR tchColText[81];
    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT;
    lvc.pszText = tchColText;
    lvc.cchTextMax = ARRAYSIZE( tchColText ) - 1; // -1 for NUL

    // Space for the locale-specific separator. (Usually ", " for English)
    TCHAR szSep[ 16 ];

    // Now allocate a local string to hold everything. Its length will be:
    // number of cols * ( coltext + ": " + text + separator )
    //
    // sizeof(COLONSEP) incluses the terminating NUL in that string; but it's ok
    // to overestimate. Because we use sizeof, we don't need to multiply by sizeof(TCHAR).
    int len = cCols * ( sizeof( tchColText ) + sizeof( COLONSEP )
                      + sizeof( tchText ) + sizeof( szSep ) );

    LPTSTR lpszLocal = (LPTSTR)LocalAlloc ( LPTR, len );
    if (!lpszLocal)
    {
        return E_OUTOFMEMORY;
    }

    // This points to the 'current write position' as we build up the string
    LPTSTR lpszTempLocal = lpszLocal;


    // Get the list separator string. The -1 allows us to append
    // a space char if we need it.
    int nSepLen = GetLocaleInfo( GetThreadLocale(), LOCALE_SLIST, szSep, ARRAYSIZE( szSep ) - 1 );
    if( ! nSepLen || szSep[ 0 ] == '\0' )
    {
        // Default to using ", "...
        lstrcpy( szSep, TEXT(", ") );
        nSepLen = 2;
    }
    else
    {
        // GetLocalInfo return value includes terminating NUL... don't want
        // to include that in our length.
        nSepLen = lstrlen( szSep );

        // Add extra space at end, if necessary.
        if( szSep[ nSepLen - 1 ] != ' ' )
        {
            lstrcat( szSep, TEXT(" ") );
            nSepLen++;
        }
    }

    //
    // Traverse the description order array sequentially to get each item
    //

    // Flag used to remember not to add separator when adding first item
    BOOL fFirstItem = TRUE;
    for ( int iOrder = 0; iOrder < cCols; iOrder++ )
    {
        INT iCol = pCols[iOrder];

        // Skip subitem 0, that is the 'name'.
        // Also skip negative numbers, just in case.
        if ( iCol <= 0 )
            continue;

        // Try and get the column value text...
		lvi.iSubItem = iCol;
		*lvi.pszText = '\0';
		if( FAILED(XSend_ListView_GetItem( hwnd, LVM_GETITEM, 0, &lvi ) ) )
            continue;

        // Skip empty strings...
		if( *lvi.pszText == '\0' )
            continue;


        // Add separator if necessary...
        if( ! fFirstItem )
        {
            lstrcpy(lpszTempLocal, szSep);
            lpszTempLocal += nSepLen;
        }
        else
        {
            fFirstItem = FALSE;
        }

        // Try to get column header string...
        lvc.iSubItem = iCol;
		*lvc.pszText = '\0';
		if( SUCCEEDED(XSend_ListView_GetColumn( hwnd, LVM_GETCOLUMN, iCol, &lvc ) )
            && *lvc.pszText != '\0' )
        {
			lstrcpy(lpszTempLocal, lvc.pszText);
            lpszTempLocal += lstrlen(lpszTempLocal);

			lstrcpy(lpszTempLocal, TEXT(": "));
            lpszTempLocal += 2;
        }

        // Now add the column value to string...
		lstrcpy(lpszTempLocal, lvi.pszText);
        lpszTempLocal += lstrlen(lpszTempLocal);
    }

    // Convert to BSTR...
    if (lpszTempLocal != lpszLocal)
    {
        *pszDesc = TCharSysAllocString(lpszLocal);
    }

    LocalFree (lpszLocal);

    return *pszDesc ? S_OK : S_FALSE;
}



HRESULT LVGetDescription_ReportView( HWND hwnd, int iItem, BSTR * pszDesc )
{
    //
    // Is there a header control?
    //
    HWND hwndHeader = ListView_GetHeader(hwnd);
    if (!hwndHeader)
        return E_NOT_APPLICABLE ;

    //
    // Is there more than one column?
    //
    int cColumns = SendMessageINT(hwndHeader, HDM_GETITEMCOUNT, 0, 0L);
    if (cColumns < 2)
        return E_NOT_APPLICABLE;

    //
    // Get the order to traverse these columns in.
    //
    HANDLE hProcess;
    LPINT lpColumnOrderShared = (LPINT)SharedAlloc( 2 * cColumns * sizeof(INT),
                                                    hwnd, & hProcess );
    if (!lpColumnOrderShared)
        return E_OUTOFMEMORY;

    // Now allocate a local array twice as big, so we can do our sorting 
    // in the second half.    
    LPINT lpColumnOrder = (LPINT)LocalAlloc (LPTR,2 * cColumns * sizeof(INT));
    if (!lpColumnOrder)
    {
        SharedFree (lpColumnOrderShared,hProcess);
        return E_OUTOFMEMORY;
    }

    LPINT lpDescOrder = lpColumnOrder + cColumns;

    if (!SendMessage(hwnd, LVM_GETCOLUMNORDERARRAY, cColumns, (LPARAM)lpColumnOrderShared))
    {
        SharedFree(lpColumnOrderShared,hProcess);
        LocalFree (lpColumnOrder);
        return(E_OUTOFMEMORY);
    }

    SharedRead (lpColumnOrderShared,lpColumnOrder,cColumns*sizeof(INT),hProcess);

    //
    // lpColumnOrder is currently an array where index == iSubItem, value == order.
    // Change this into an array where index == order, value == iSubItem.
    // That way we can sit in a loop using the value as the iSubItem,
    // knowing we are composing the pieces of the description in the proper
    // order.
    //              

    for (int iOrder = 0; iOrder < cColumns; iOrder++)
    {
        lpDescOrder[lpColumnOrder[iOrder]] = iOrder;
    }

    HRESULT hr = LVBuildDescriptionString( hwnd, iItem, lpDescOrder, cColumns, pszDesc );

    SharedFree(lpColumnOrderShared,hProcess);
    LocalFree (lpColumnOrder);

    return hr;
}


HRESULT LVGetDescription_TileView( HWND hwnd, int iItem, BSTR * pszDesc )
{
    // Get the 'sorted' column...
    int iColSorted = ListView_GetSelectedColumn( hwnd );

    // Normalize to 0 if negative. We don't use col 0, since that's the name.
    if( iColSorted < 0 )
        iColSorted = 0;

    // First, get number of cols...
    LVITEM_V6 lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_COLUMNS;
    lvi.cColumns = 0;
    lvi.puColumns = NULL;

    HRESULT hr = XSend_ListView_V6_GetItem( hwnd, LVM_GETITEM, 0, &lvi );

    if( FAILED( hr ) )
        return hr;

    int cCols = lvi.cColumns;
    if( cCols < 0 )
        cCols = 0;

    // If we get back 0 columns, we still have to display the sorted column, if there is one.
    // But if there are no cols, and no sorted col, then there's no description.
    if( cCols == 0 && iColSorted == 0 )
        return S_FALSE;


    // Allocate space for those cols - with space for the sorted column at the head.
    int * pCols = new int [ cCols + 1 ];
    if( ! pCols ) 
        return E_OUTOFMEMORY;

    pCols [ 0 ] = iColSorted;

    if( cCols )
    {
        // Now get them...
        lvi.puColumns = (UINT *)(pCols + 1);

        hr = XSend_ListView_V6_GetItem( hwnd, LVM_GETITEM, 0, &lvi );
        if( FAILED( hr ) )
        {
            delete [ ] pCols;
            return hr;
        }

        // Scan remainder of columns for the sorted column - if found, set that
        // entry to 0, so it will be skipped when building the string.
        // (Neater than moving all the entries down by one.)
        for( int iScan = 1 ; iScan < cCols + 1 ; iScan++ )
        {
            if( pCols[ iScan ] == iColSorted )
            {
                pCols[ iScan ] = 0;
            }
        }
    }

    // Finally, build the description string using those columns.
    // If we didn't get any cols above, this will end up using just the
    // sorted col - if there is one.
    hr = LVBuildDescriptionString( hwnd, iItem, pCols, cCols + 1, pszDesc );

    delete [ ] pCols;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\listbox.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTBOX.CPP
//
//  Listbox client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "window.h"
#include "listbox.h"

const TCHAR szComboExName[] = TEXT("ComboBoxEx32");

STDAPI_(LPTSTR) MyPathFindFileName(LPCTSTR pPath);


BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList );


// --------------------------------------------------------------------------
//
//  CreateListBoxClient()
//
//  EXTERNAL for CClient.
//
// --------------------------------------------------------------------------
HRESULT CreateListBoxClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvListBox)
{
    CListBox * plist;
    HRESULT hr;

    InitPv(ppvListBox);

    plist = new CListBox(hwnd, idChildCur);
    if (!plist)
        return(E_OUTOFMEMORY);

    hr = plist->QueryInterface(riid, ppvListBox);
    if (!SUCCEEDED(hr))
        delete plist;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListBox::CListBox()
//
// --------------------------------------------------------------------------
CListBox::CListBox(HWND hwnd, long idChildCur)
    : CClient( CLASS_ListBoxClient )
{
    Initialize(hwnd, idChildCur);

    //
    // Check both the style and the CBOX data--SQL srvr creates controls
    // with bogus styles sometimes and could fool us into thinking this
    // was a combo.  USER's listbox creation code does the same check.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & LBS_COMBOBOX)
    {
        COMBOBOXINFO    cbi;

        if (MyGetComboBoxInfo(hwnd, &cbi))
        {
            m_fComboBox = TRUE;
            if (!(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
                m_fDropDown = TRUE;
        }
    }

    m_fUseLabel = !m_fComboBox;
}


// --------------------------------------------------------------------------
//
//  CListBox::SetupChildren()
//
//  Sets the # of items we have.
//
// --------------------------------------------------------------------------
void CListBox::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, LB_GETCOUNT, 0, 0L);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (m_fComboBox)
        {
            IAccessible* pacc;
            HRESULT hr;
            COMBOBOXINFO    cbi;

            //
            // Forward request up to combobox to get its name.
            //
            if (!MyGetComboBoxInfo(m_hwnd, &cbi))
                return(S_FALSE);

            pacc = NULL;
            hr = AccessibleObjectFromWindow(cbi.hwndCombo, OBJID_CLIENT,
                IID_IAccessible, (void**)&pacc);
            if (!SUCCEEDED(hr) || !pacc)
                return(S_FALSE);

            Assert(varChild.lVal == 0);
            hr = pacc->get_accName(varChild, pszName);
            pacc->Release();

            return(hr);
        }
        else
            return(CClient::get_accName(varChild, pszName));
    }
    else
    {
        UINT    cch;
        COMBOBOXINFO    cbi;
        UINT    msgLen;
        UINT    msgText;
        HWND    hwndAsk;

        //
        // For a combobox, ask the COMBO for its text.  A lot of apps have
        // ownerdraw items, but actually subclass combos and return real
        // text for the items.
        //
        if (m_fComboBox && MyGetComboBoxInfo(m_hwnd, &cbi))
        {
            HWND    hwndT;

            hwndAsk = cbi.hwndCombo;
            if (hwndT = IsInComboEx(cbi.hwndCombo))
                hwndAsk = hwndT;

            msgLen = CB_GETLBTEXTLEN;
            msgText = CB_GETLBTEXT;
        }
        else
        {
            hwndAsk = m_hwnd;
            msgLen = LB_GETTEXTLEN;
            msgText = LB_GETTEXT;
        }

        //
        // Get the item text.
        //
        cch = SendMessageINT(hwndAsk, msgLen, varChild.lVal-1, 0);

        // Some apps do not handle LB_GETTEXTLEN correctly, and
        // always return a small number, like 2.
        if (cch < 1024)
            cch = 1024;

        if (cch)
        {
            // HACK ALERT
            // The IE4 listbox is a superclassed standard listbox,
            // but if I use SendMessageA (which I do) to get the
            // text, I just get back one character. They keep everything
            // in Unicode. It is a bug in the Trident MSHTML
            // implementation, but even if they fixed it and gave me
            // back an ANSI string, I wouldn't know what code page to
            // use to convert the ANSI string to Unicode - web pages
            // can be in a different language than the one the user's
            // computer uses! Since they already have everything in
            // Unicode, we decided on a private message that will fill
            // in the Unicode string, and I use that just like I would
            // normally use LB_GETTEXT.
            // I was going to base this on the classname of the listbox
            // window, which is "Internet Explorer_TridentLstBox", but
            // the list part of a combo doesn't have a special class
            // name, so instead I am going to base the special case on
            // the file name of the module that owns the window.

            // TCHAR   szModuleName[MAX_PATH];
            // LPTSTR  lpszModuleName;
            // GetWindowModuleFileName(hwndAsk,szModuleName,ARRAYSIZE(szModuleName));
            // lpszModuleName = MyPathFindFileName (szModuleName);
            // if (0 == lstrcmp(lpszModuleName,TEXT("MSHTML.DLL")))

            // Update: (BrendanM)
            // GetWindowModuleFilename is broken on Win2k...
            // IsTridentControl goes back to using classnames, and knows
            // how to cope with ComboLBoxes...

            if( IsTridentControl( m_hwnd, m_fComboBox, m_fComboBox ) )
            {
                OLECHAR*    lpszUnicodeText = NULL;
                OLECHAR*    lpszLocalText = NULL;
                HANDLE      hProcess;

                if (msgText == LB_GETTEXT)
                    msgText = WM_USER+LB_GETTEXT;
                else if (msgText == CB_GETLBTEXT)
                    msgText = WM_USER+CB_GETLBTEXT;

                lpszUnicodeText = (OLECHAR *)SharedAlloc((cch+1)*sizeof(OLECHAR),
                                                         hwndAsk,
                                                         &hProcess);
                lpszLocalText = (OLECHAR*)LocalAlloc(LPTR,(cch+1)*sizeof(OLECHAR));

                if (!lpszUnicodeText || !lpszLocalText)
                    return(E_OUTOFMEMORY);

                cch = SendMessageINT(hwndAsk, msgText, varChild.lVal-1, (LPARAM)lpszUnicodeText);
                SharedRead (lpszUnicodeText,lpszLocalText,(cch+1)*sizeof(OLECHAR),hProcess);

                *pszName = SysAllocString(lpszLocalText);

                SharedFree(lpszUnicodeText,hProcess);
                LocalFree(lpszLocalText);
            }
            else // normal, non IE4 code here:
            {
                LPTSTR lpszText;

                lpszText = (LPTSTR)LocalAlloc(LPTR, (cch+1)*sizeof(TCHAR));
                if (!lpszText)
                    return(E_OUTOFMEMORY);

                SendMessage(hwndAsk, msgText, varChild.lVal-1, (LPARAM)lpszText);
                *pszName = TCharSysAllocString(lpszText);

                LocalFree((HANDLE)lpszText);
            }
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    RECT    rcItem;
    long    lStyle;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accState(varChild, pvarState));


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Is this item selected?
    //
    if (SendMessage(m_hwnd, LB_GETSEL, varChild.lVal, 0))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    //
    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    //
    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (SendMessage(m_hwnd, LB_GETCARETINDEX, 0, 0) == varChild.lVal)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    else if (m_fComboBox)
    {
    COMBOBOXINFO    cbi;
        if (MyGetComboBoxInfo(m_hwnd, &cbi))
        {
            // if this list is part of a combo box, AND the list
            // is showing (m_fDropdown is true), then say we are
            // focusable.
            if (m_fDropDown)
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (MyGetFocus() == cbi.hwndCombo && IsWindowVisible( m_hwnd ) )
                {
                    if (SendMessage(m_hwnd, LB_GETCARETINDEX, 0, 0) == varChild.lVal)
                        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                }
            } // end if it is dropped
        } // end if we got combo box info
    } // end if this is a combox box list

    //
    // Is the listbox read-only?
    //
    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        //
        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        //
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    //
    // Is the item in view?
    //
    // SMD 09/16/97 Offscreen things are things never on the screen,
    // and that doesn't apply to this. Changed from OFFSCREEN to
    // INVISIBLE.
    if( ! IsWindowVisible( m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }
    else if( ! SendMessage(m_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
    {
        // LB_GETITEMRECT returns FALSE if the item is clipped...
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && !m_fComboBox)
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accFocus(VARIANT *pvarChild)
{
    InitPvar(pvarChild);

    //
    // Are we the focus?
    //
    if (MyGetFocus() == m_hwnd)
    {
        long    lCaret;

        pvarChild->vt = VT_I4;

        lCaret = SendMessageINT(m_hwnd, LB_GETCARETINDEX, 0, 0L);
        if (lCaret != LB_ERR)
            pvarChild->lVal = lCaret+1;
        else
            pvarChild->lVal = 0;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accSelection(VARIANT *pvarSelection)
{
    return(GetListBoxSelection(m_hwnd, pvarSelection));
}


// --------------------------------------------------------------------------
//
//  CListBox::get_accDefaultAction()
//
//  Since the default action for a listbox item is really determined by the
//  creator of the listbox control, the best we can do is double click on
//  the thing, and return "double click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (HrCreateString(STR_DOUBLE_CLICK, pszDefAction));

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CListBox::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a list
//  box item is, so unless the parent overrides us, we'll just do a double
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accDoDefaultAction(VARIANT varChild)
{
    RECT        rcLoc;
    HRESULT     hr;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {
        hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
        if (!SUCCEEDED (hr))
            return (hr);

        // this will check if WindowFromPoint at the click point is the same
        // as m_hwnd, and if not, it won't click. Cool!
        if (ClickOnTheRect(&rcLoc,m_hwnd,TRUE))
            return (S_OK);
    }
    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CListBox::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accSelect(long selFlags, VARIANT varChild)
{
    long    lStyle;
    int     nFocusedItem;

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild)   ||
        ! ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(selFlags, varChild));

    varChild.lVal--;

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return(E_NOT_APPLICABLE);


    if (selFlags & SELFLAG_TAKEFOCUS)
    {
        MySetFocus(m_hwnd);
    }


    // note that LB_SETCURSEL doesn't work for extended or multi-select
    // listboxes, have to use LB_SELITEMRANGE or LB_SETSEL.
    if ((lStyle & LBS_MULTIPLESEL) ||
        (lStyle & LBS_EXTENDEDSEL))
    {
        // get the focused item here in case we change it.
        nFocusedItem = SendMessageINT(m_hwnd,LB_GETCARETINDEX,0,0);

        if (selFlags & SELFLAG_TAKEFOCUS)
        {
            if (MyGetFocus() != m_hwnd)
                return(S_FALSE);
            SendMessage (m_hwnd, LB_SETCARETINDEX,varChild.lVal,0);
        }

        // These seem to be weird - when you tell it to set the selection, it
        // also sets the focus. So we remember focus and reset it at the end.
        if (selFlags & SELFLAG_TAKESELECTION)
        {
            // deselect the whole range of items
            SendMessage(m_hwnd, LB_SETSEL,FALSE,-1);
            // Select this one
            SendMessage(m_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
        BOOL    bSelected;

            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                SendMessage (m_hwnd,LB_SELITEMRANGE,(selFlags & SELFLAG_ADDSELECTION),MAKELPARAM(nFocusedItem,varChild.lVal));
            else
            {
                bSelected = SendMessageINT(m_hwnd,LB_GETSEL,nFocusedItem,0);
                SendMessage (m_hwnd,LB_SELITEMRANGE,bSelected,MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                SendMessage(m_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION),varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            SendMessage (m_hwnd, LB_SETCARETINDEX,nFocusedItem,0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION |
                        SELFLAG_REMOVESELECTION |
                        SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
        if ((selFlags & SELFLAG_TAKESELECTION) ||
            (selFlags & SELFLAG_TAKEFOCUS))
            SendMessage(m_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accLocation(long* pxLeft, long *pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Get item rect.
    //
    if (SendMessage(m_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
    {
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

        *pxLeft = rc.left;
        *pyTop = rc.top;
        *pcxWidth = rc.right - rc.left;
        *pcyHeight = rc.bottom - rc.top;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    long lEnd;
    long lRows;

    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    //
    // Is this something for the client (or combobox) to handle?
    //
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = 1;
        if (lEnd > m_cChildren)
            lEnd = 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = m_cChildren;
    else if (varStart.lVal == CHILDID_SELF)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
    else
    {
        long    lT;

        lRows = MyGetListBoxInfo(m_hwnd);
        if (!lRows)
            return(S_FALSE);

        lEnd = 0;

        lT = varStart.lVal - 1;

        switch (dwNavDir)
        {
            case NAVDIR_LEFT:
                //
                // Are there any items to the left of us?
                //
                if (lT >= lRows)
                    lEnd = varStart.lVal - lRows;
                break;

            case NAVDIR_RIGHT:
                //
                // Are there are any items to the right of us?
                //
                if (lT + lRows < m_cChildren)
                    lEnd = varStart.lVal + lRows;
                break;

            case NAVDIR_UP:
                //
                // Are we in the top-most row?
                //
                if ((lT % lRows) != 0)
                    lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_DOWN:
                //
                // Are we the last item or in the bottom-most row?
                //
                if (((lT+1) % lRows) != 0)
                {
                    lEnd = varStart.lVal + 1;
                    if (lEnd > m_cChildren)
                        lEnd = 0;
                }
                break;

            case NAVDIR_PREVIOUS:
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
                lEnd = varStart.lVal + 1;
                if (lEnd > m_cChildren)
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CListBox::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    POINT   pt;
    RECT    rc;
    long    l;

    InitPvar(pvarHit);

    //
    // Is the point in our client area?
    //
    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    MyGetRect(m_hwnd, &rc, FALSE);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    //
    // What item is here?
    //
    l = SendMessageINT(m_hwnd, LB_ITEMFROMPOINT, 0, MAKELONG(pt.x, pt.y));

    pvarHit->vt = VT_I4;

    if (HIWORD(l))
    {
        // Outside bounds, in white space.
        pvarHit->lVal = 0;
    }
    else
    {
        pvarHit->lVal = (int)(short)LOWORD(l) + 1;
    }


    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CreateListBoxWindow()
//
// --------------------------------------------------------------------------
HRESULT CreateListBoxWindow(HWND hwnd, long idChildCur, REFIID riid, void** ppvListBoxW)
{
    HRESULT hr;

    CListBoxFrame * plframe;

    InitPv(ppvListBoxW);

    plframe = new CListBoxFrame(hwnd, idChildCur);
    if (!plframe)
        return(E_OUTOFMEMORY);

    hr = plframe->QueryInterface(riid, ppvListBoxW);
    if (!SUCCEEDED(hr))
        delete plframe;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::CListBoxFrame()
//
// --------------------------------------------------------------------------
CListBoxFrame::CListBoxFrame(HWND hwnd, long iChildCur)
    : CWindow( CLASS_ListBoxWindow )
{
    Initialize(hwnd, iChildCur);

    if (GetWindowLong(hwnd, GWL_STYLE) & LBS_COMBOBOX)
    {
        COMBOBOXINFO    cbi;

        if (MyGetComboBoxInfo(hwnd, &cbi))
        {
            m_fComboBox = TRUE;
            if (!(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
                m_fDropDown = TRUE;
        }
    }
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::get_accParent()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::get_accParent(IDispatch** ppdispParent)
{
    InitPv(ppdispParent);

    //
    // We need to handle combo dropdowns specially, since they are made
    // children of the desktop for free floating.
    //
    if (m_fComboBox && m_fDropDown)
    {
        COMBOBOXINFO    cbi;

        if (!MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        //
        // Get the combo info and create our combobox parent.
        //
        return(AccessibleObjectFromWindow(cbi.hwndCombo, OBJID_CLIENT,
            IID_IDispatch, (void**)ppdispParent));
    }
    else
        return(CWindow::get_accParent(ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::get_accState(VARIANT varStart, VARIANT *pvarState)
{
    HRESULT hr;

    InitPvar(pvarState);

    if (! ValidateChild(&varStart))
        return(E_INVALIDARG);

    //
    // Get the window's state
    //
    hr = CWindow::get_accState(varStart, pvarState);
    if (SUCCEEDED(hr) && m_fComboBox && m_fDropDown && (varStart.lVal == 0))
    {
        pvarState->lVal |= STATE_SYSTEM_FLOATING;
    }
    return(hr);

}




// Note: this code was never used - the signature of accNavigate here is
// incorrect - it should be (long dwNavDir, VARIANT varStart, VARIANT *pVarEnd).
//
// However, while enabling this version does solve some problems, it introduces
// more of its own.
//
// eg. while navigating through top-level windows, if you hit a combolbox window,
// you get stuck, and can't navigate back out again.
//
// So, for the moment, it's being left disabled; but remains here for reference.
// It may be possible to re-enable it, but other code would have to be altered
// to make it work consistently.
#if 0

// --------------------------------------------------------------------------
//
//  CListBoxFrame::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::accNavigate(VARIANT varStart, long dwNavDir,
    VARIANT* pvarEnd)
{
    COMBOBOXINFO    cbi;

    InitPvar(pvarEnd);

    //
    // Validate.
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    //
    // Hand off to CWindow if (1) first child, (2) non-zero start.
    //
    Assert(NAVDIR_LASTCHILD > NAVDIR_FIRSTCHILD);

    if (!m_fComboBox || (dwNavDir >= NAVDIR_FIRSTCHILD) || varStart.lVal)
        return(CWindow::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Get our parent window
    //
    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    return(GetParentToNavigate(INDEX_COMBOBOX_LIST, cbi.hwndCombo,
        OBJID_CLIENT, dwNavDir, pvarEnd));
}
// Unused CListBoxFrame::accNavigate implementation
// See comment at top for more information.
#endif




/////////////////////////////////////////////////////////////////////////////
//
//  MULTIPLE SELECTION LISTBOX SUPPORT
//
//  If a listbox has more than one item selected, we create an object
//  that is a clone.  It keeps a list of the selected items.  Its sole
//  purpose is to respond to IEnumVARIANT, a collection.  The caller should
//  either
//      (a) Pass the child ID to the parent object to get acc info
//      (b) Call the child directly if VT_DISPATCH.
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  GetListBoxSelection()
//
// --------------------------------------------------------------------------
HRESULT GetListBoxSelection(HWND hwnd, VARIANT* pvarSelection)
{
    int cSelected;
    LPINT lpSelected;
    long lRet;
    CListBoxSelection * plbs;

    InitPvar(pvarSelection);

    cSelected = SendMessageINT(hwnd, LB_GETSELCOUNT, 0, 0);

    if (cSelected <= 1)
    {
        //
        // cSelected is -1, 0, or 1.
        //      -1 means this is a single sel listbox.
        //      0 or 1 means this is multisel
        //
        lRet = SendMessageINT(hwnd, LB_GETCURSEL, 0, 0);
        if (lRet == -1)
            return(S_FALSE);

        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = lRet+1;
        return(S_OK);
    }

    //
    // Multiple items; must make a collection
    //

    //
    // Allocate memory for the list of item IDs
    //
    lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(INT));
    if (!lpSelected)
        return(E_OUTOFMEMORY);

    //
    // Get the list of selected item IDs
    //
    plbs = NULL;

    lRet = SendMessageINT(hwnd, LB_GETSELITEMS, cSelected, (LPARAM)lpSelected);
    if (lRet != LB_ERR)
    {
        plbs = new CListBoxSelection(0, lRet, lpSelected);
        if (plbs)
        {
            pvarSelection->vt = VT_UNKNOWN;
            plbs->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
        }
    }

    //
    // Free the list memory; the constructor will make a copy.  This is
    // because the constructor is called both from create and clone.
    //
    LocalFree((HANDLE)lpSelected);

    if (!plbs)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(int iChildCur, int cSelected, LPINT lpSelection)
{
    m_idChildCur = iChildCur;

    m_lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(int));
    if (!m_lpSelected)
        m_cSelected = 0;
    else
    {
        m_cSelected = cSelected;
        CopyMemory(m_lpSelected, lpSelection, cSelected*sizeof(int));
    }
}




// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
    //
    // Free item memory
    //
    if (m_lpSelected)
    {
        LocalFree((HANDLE)m_lpSelected);
        m_lpSelected = NULL;
    }
}




// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    *ppunk = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    return(++m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    if ((--m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    //
    // Initialize VARIANTs
    // This is so bogus
    //
    pvar = rgvar;
    for (iCur = 0; iCur < (long)celt; iCur++, pvar++)
        VariantInit(pvar);

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cSelected))
    {
        pvar->vt = VT_I4;
        pvar->lVal = m_lpSelected[iCur] + 1;

        ++cFetched;
        ++iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    m_idChildCur += celt;
    if (m_idChildCur > m_cSelected)
        m_idChildCur = m_cSelected;

    //
    // We return S_FALSE if at the end.
    //
    return((m_idChildCur >= m_cSelected) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    CListBoxSelection * plistselnew;

    InitPv(ppenum);

    plistselnew = new CListBoxSelection(m_idChildCur, m_cSelected, m_lpSelected);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  IsComboEx()
//
//  Returns TRUE if this window is a comboex32
//
// --------------------------------------------------------------------------
BOOL IsComboEx(HWND hwnd)
{
    TCHAR   szClass[128];

    return MyGetWindowClass(hwnd, szClass, ARRAYSIZE(szClass) ) &&
                ! lstrcmpi(szClass, szComboExName);
}


// --------------------------------------------------------------------------
//
//  IsInComboEx()
//
//  Returns the COMBOEX window if the combo is embedded in a COMBOEX (like
//  on the toolbar).
//
// --------------------------------------------------------------------------
HWND IsInComboEx(HWND hwnd)
{
    HWND hwndParent = MyGetAncestor(hwnd, GA_PARENT);
    if( hwndParent && IsComboEx(hwndParent) )
        return hwndParent;
    else
        return NULL;
}


// --------------------------------------------------------------------------
// Copied from shlwapi\path.c
//
// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
// --------------------------------------------------------------------------

STDAPI_(LPTSTR)
MyPathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
            && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}


/*
 *  IsTridentControl
 *
 *  HWND hWnd
 *      window to test against
 *  BOOL fCombo
 *      TRUE if this is a combo or a combolbox
 *  BOOL fComboList
 *      TRUE if this is a combolbox (the drop-down list box associated with a combo)
 *
 *  This works by comparing class names - "Internet Explorer_TridentCmboBx"
 *  for combos, and "Internet Explorer_TridentLstBox" for listboxes.
 *  The drop-lists of combos don't have a special class, so instead we get
 *  the 'parent' combo, and check it against "Internet Explorer_TridentCmboBx".
 *
 */
BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList )
{
    // If this is a drop-list, get the associated combo...
    if( fComboList )
    {
        COMBOBOXINFO cbi;
        if( ! MyGetComboBoxInfo( hWnd, & cbi ) || cbi.hwndCombo == NULL )
        {
            return FALSE;
        }

        hWnd = cbi.hwndCombo;
    }

    // Get class name...
    TCHAR szClass[64];
    szClass[0] = '\0';
    GetClassName( hWnd, szClass, ARRAYSIZE( szClass ) );

    // Compare against expected string...
    TCHAR * pszCompare;
    if( fCombo )
        pszCompare = TEXT("Internet Explorer_TridentCmboBx");
    else
        pszCompare = TEXT("Internet Explorer_TridentLstBox");


    return lstrcmp( szClass, pszCompare ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\listview.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTVIEW.H
//
//  Knows how to talk to COMCTL32's listview control.
//
// --------------------------------------------------------------------------

class CListView32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
		STDMETHODIMP        get_accHelp(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accDoDefaultAction(VARIANT);
        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        void    SetupChildren(void);
        void    RemoveCurrentSelFocus(long);
        CListView32(HWND, long);
};



class CListViewSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListViewSelection(int, int, LPINT);
        ~CListViewSelection();

    protected:
        int     m_cRef;
        int     m_idChildCur;
        int     m_cSelected;
        LPINT   m_lpSelected;
};


extern HRESULT GetListViewSelection(HWND hwnd, VARIANT * pvarSelection);

// CWO:  Copied from latest COMMCTRL.H to support new functionality
#ifndef LVM_GETHEADER
    #define LVM_GETHEADER               (LVM_FIRST + 31)
    #define ListView_GetHeader(hwnd)\
        (HWND)SNDMSG((hwnd), LVM_GETHEADER, 0, 0L)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\mdicli.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MDICLI.CPP
//
//  MDI Client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "mdicli.h"



// --------------------------------------------------------------------------
//
//  CreateMDIClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateMDIClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvMdi)
{
    CMdiClient * pmdicli;
    HRESULT hr;

    InitPv(ppvMdi);

    pmdicli = new CMdiClient(hwnd, idChildCur);
    if (!pmdicli)
        return(E_OUTOFMEMORY);

    hr = pmdicli->QueryInterface(riid, ppvMdi);
    if (!SUCCEEDED(hr))
        delete pmdicli;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMdiClient::CMdiClient()
//
// --------------------------------------------------------------------------
CMdiClient::CMdiClient(HWND hwndSelf, long idChild)
    : CClient( CLASS_MDIClient )
{
    Initialize(hwndSelf, idChild);
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate -- does NOT accept child IDs (yet)
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_MDICLI_NAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accFocus()
//
//  Both the focus and the selection return back the "active" mdi child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accFocus(VARIANT* pvarFocus)
{
    return(get_accSelection(pvarFocus));
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accSelection()
//
//  Both the focus and the selection return back the "active" mdi child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accSelection(VARIANT* pvarSel)
{
    HWND    hwndChild;

    InitPvar(pvarSel);

    hwndChild = (HWND)SendMessage(m_hwnd, WM_MDIGETACTIVE, 0, 0);
    if (!hwndChild)
        return(S_FALSE);

    return(GetWindowObject(hwndChild, pvarSel));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\lresobj.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  lresobj
//
//  LresultFromObject and ObjectFromLresult.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"


#ifndef WMOBJ_SAMETHREAD
#define WMOBJ_SAMETHREAD  0xFFFFFFFF
#endif



//  This structure is used by the NT version of SharedBuffer_Allocate/Free,
//  it acts as a header, and is followed immedialtey by the marshal data.
//
//  (The 9x version of SharedBuffer_Allocate currently stores the data
//  without a header.) 
//
//  Be careful with packing and alignment here - this needs to look the same
//  on 32bit and 64-bit compiles.
// 
typedef struct {
    DWORD       m_dwSig;
    DWORD       m_dwSrcPID;
    DWORD       m_dwDstPID;
    DWORD       m_cbSize;
} XFERDATA, *PXFERDATA;

#define MSAAXFERSIG     0xAA1CF00D



static BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw );

static BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw );
static BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle );



//
//  Note on SharedBuffer_Allocate and SharedBuffer_Free:
//
//  LresultFromObject and ObjectFromLresult call SharedBuffer_Allocate and
//  SharedBuffer_Free respectively to do the actual work of transferring
//  memory between processes.
//
//
//  SharedBuffer_Allocate is given a pointer to the marshalled interface data,
//  and its length (pData, cbData), and the pid of the process that wants the
//  object (dwDstPID, which may be 0 if the destination is unknown - while
//  Oleacc's AccessibleObjectFromWindow sends WM_GETOBJECT with wParam as the
//  pid, some legacy code already out there sends WM_GETOBJECT directly with
//  wParam = 0.)
//
//  SharedBuffer_Allocate then stores that marshalled data however it needs
//  to, and returns an LRESULT that can later be used to get back to that data.
//  Note that since this LRESULT may be used by a 32-bit process, it must be
//  only 32-bit significant. Also, it must look like a SUCCESS HRESULT - ie.
//  bit 31 must be 0.
//
//
//  SharedBuffer_Free is given a DWORD ref - which is the LRESULT that
//  SharedBuffer_Allocate previously returned - the destination process pid -
//  which may be 0 if ObjectFromLresult was called directly by legacy code -
//  and also an riid.
//
//  SharedBuffer_Free needs to use that DWORD ref to get at the memory that
//  SharedBuffer_Allocate set up, and then call the utility function
//  UnmarshalInterface() on that memory with the riid to return an interface
//  pointer. SharedBuffer_Free must also deallocate the associated memory as
//  appropriate.
//
//  Different versions of _Allocate and _Free exist on 9x and NT, denoted by
//  _Win95 and _NT suffixes. A generic _Allocate and _Free called the
//  appropriate one based on compile options and the global fWindows95 flag.
//

static LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData, DWORD cbData, DWORD dwDstPID );
static HRESULT WINAPI SharedBuffer_Free_NT( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv );

#ifndef NTONLYBUILD
static LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData, DWORD cbData, DWORD dwDstPID );
static HRESULT WINAPI SharedBuffer_Free_Win95( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv );
#endif // NTONLYBUILD


static inline
LRESULT WINAPI SharedBuffer_Allocate( const BYTE * pData, DWORD cbData, DWORD dwDstPID )
{
#ifndef NTONLYBUILD
    if( fWindows95 ) 
    {
        return SharedBuffer_Allocate_Win95( pData, cbData, dwDstPID );
    }  
    else 
#endif // NTONLYBUILD
    {
        return SharedBuffer_Allocate_NT( pData, cbData, dwDstPID );
    }
}


static inline
HRESULT WINAPI SharedBuffer_Free( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv )
{
#ifndef NTONLYBUILD
    if( fWindows95 ) 
    {
        return SharedBuffer_Free_Win95( ref, dwDstPID, riid, ppv );
    }  
    else 
#endif // NTONLYBUILD
    {
        return SharedBuffer_Free_NT( ref, dwDstPID, riid, ppv );
    }
}



// --------------------------------------------------------------------------
//
//  LresultFromObject_Local(), ObjectFromLresult_Local()
//
//  These are the same-thread optimizations of LFromO and OFromL.
//
//  The key thing is to bit-twiddle the interface pointer so that it does
//  not look like an error HRESULT - ie. bit31 must be 0.
//  We take advantage of the fact that since these are pointers, bit 0 will
//  be 0, and we are free to use it for our own use in our encoding.
//
//  The mapping scheme is as follows:
//
//  Mapping to Lresult from Object, punk -> LRESULT
//
//    top 32 bits unchanged
//    bit 31 set to 0 (so that it looks like a success HRESULT)
//    bits 30..0 correspond to bits 31..1 of the input value.
//    bit 0 of the original value is lost; assumed to be 0.
//
//  Mapping to Object from Lresult, LRESULT -> punk
//
//    top 32 bits unchanged
//    bits 31..1 correspond to bits 30..0 of the input value.
//    bit 0 set to 0
//
//  This will work on Win64, and on Win32 with memory above 2G enabled.
//
// --------------------------------------------------------------------------

static
LRESULT LresultFromObject_Local( IUnknown * punk )
{
    // Do the work using DWORD_PTRs - thery're unsigned, so we don't get
    // unexpected nasty sign-extension effects, esp. when shifting...
    DWORD_PTR in = (DWORD_PTR) punk;

    // Mask off lower 32 bits to get the upper 32 bits (NOP on W32)...
    DWORD_PTR out = in & ~(DWORD_PTR)0xFFFFFFFF;

    // Now add in the lower 31 bits (excluding bit 0) shifted by one so
    // that bit 31 is 0...
    out |= ( in & (DWORD_PTR)0xFFFFFFFF ) >> 1;

    return (LRESULT) out;
}

static
IUnknown * ObjectFromLresult_Local( LRESULT lres )
{
    Assert( SUCCEEDED( lres ) );

    DWORD_PTR in = (DWORD_PTR) lres;

    // Mask off lower 32 bits to get the upper 32 bits (NOP on W32)...
    DWORD_PTR out = in & ~(DWORD_PTR)0xFFFFFFFF;

    // Now add in the lower 31 bits, shifted back to their original
    // position...
    out |= ( in & (DWORD_PTR)0x7FFFFFFF ) << 1;

    return (IUnknown *) out;
}





// --------------------------------------------------------------------------
//
//  LresultFromObject()
//
//  Encodes an interface pointer into an LRESULT.
//
//  If the client and server are on the same thread, an optimized version is
//  used; the pointer is effectively AddRef()'d and returned as the LRESULT.
//  (some bit-shifting takes place to prevent it looking like an error HRESULT,
//  ObjectFromLresult reverses this bit=shifting.)
//
//  If the client and server are not on the same thread, the interface is
//  marshaled, and Shared_Allocate is used to save a copy of that marshaled
//  data, returning an opaque 32-bit identifier that the client process can
//  pass to ObjectFromLresult to get back the interface.
//
// --------------------------------------------------------------------------

EXTERN_C LRESULT WINAPI LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk) 
{
    SMETHOD( TEXT("LresultFromObject"), TEXT("wParam=%d punk=%p"), wParam, punk );

    // Optimization for when client and server are the same thread; no need to
    // marshal/unmarshal, we can pass the pointer directly.
    
    // Casting to DWORD to avoid sign extention issues - WMOBJ_SAMETHREAD is a
    // 32-bit value, but wParam is 64-bit on 64.
    if( (DWORD)wParam == (DWORD)WMOBJ_SAMETHREAD )
    { 
        // We addref here to hold onto the object on behalf of the client caller.
        // This allows the server to safely release() the object after they've used
        // LresultfromObject to 'convert' it into a LRESULT
        punk->AddRef();

        return LresultFromObject_Local( punk );
    }

    // Cross-proc or cross-thread case, need to marshal the interface, save it
    // to a buffer, and return some sort of reference to that buffer...

    const BYTE * pData;
    DWORD cbData;
    MarshalState mstate;

    HRESULT hr = MarshalInterface( riid, punk, MSHCTX_LOCAL, MSHLFLAGS_NORMAL,
                                   & pData, & cbData, & mstate );
    if( FAILED( hr ) )
    {
        return hr;
    }

    DWORD dwDestPid = (DWORD) wParam;

    // Got the marhalled data, now call SharedBuffer_Allocate to wrap it into
    // some short of shared memory and return a suitable reference to that.
    LRESULT lResult = SharedBuffer_Allocate( pData, cbData, dwDestPid );

    MarshalInterfaceDone( & mstate );

    return lResult;
}




// --------------------------------------------------------------------------
//
//  ObjectFromLresult()
//
//  This function converts the 32-bit opaque value returned from LresultFromObject
//  into a marshalled interface pointer.  
//
// --------------------------------------------------------------------------

EXTERN_C HRESULT WINAPI ObjectFromLresult( LRESULT ref, REFIID riid, WPARAM wParam, void **ppvObject ) 
{
    SMETHOD( TEXT("ObjectFromLResult"), TEXT("ref=%p wParam=%d"), ref, wParam );

    // Do a basic sanity check on parameters
    if( ppvObject == NULL )
    {
        TraceParam( TEXT("ObjectFromLresult: ppvObject should be non-NULL") );
        return E_POINTER;
    }

    *ppvObject = NULL;

    if( FAILED( ref ) ) 
    { 
        TraceParam( TEXT("ObjectFromLresult: failure lResult was passed in (%08lx)"), ref );
        return E_INVALIDARG; 
    }

    // If the client and server are in the same thread, LresultFromObject is
    // optimized to return the original interface pointer since no marshalling 
    // is needed.

    // Casts used to avoid any 32/64 sign extension issues. We only use the low
    // DWORD of wParam, even on w64.
    if( (DWORD)wParam == (DWORD)WMOBJ_SAMETHREAD )
    {
        // Use the bit-mangling in-proc optimization...
        IUnknown * punk = ObjectFromLresult_Local( ref );

        if( punk == NULL )
        {
            TraceError( TEXT("ObjectFromLresult: (inproc case) lresult translates to NULL pointer") );
            return E_INVALIDARG;
        }

		// Some apps was responding to WM_GETOBJECT message with 1. This can cause
		// a problem for folks responding to events in-context, since we expect
        // it to be a pointer - so need to check that it's valid...

		if( IsBadReadPtr( punk, 1 ) )
        {
            TraceError( TEXT("ObjectFromLresult: (inproc case) lresult translates to invalid pointer (%p)"), punk );
            return E_INVALIDARG;
        }

    	HRESULT hr = punk->QueryInterface( riid, ppvObject );
        if( FAILED( hr ) )
        {
            TraceErrorHR( hr, TEXT("ObjectFromLresult: (inproc case) QI'ing translated pointer") );
        }

        punk->Release();
    	return hr;
    }

    // cross-proc case, call SharedBuffer_Free to access the buffer indicated by
    // ref, and to unmarshal the interface...

    // (The cast is for when we're on W64 - convert from (64/42-bit) LRESULT to
    // 32-bit buffer reference...)
    return SharedBuffer_Free( (DWORD) ref, (DWORD) wParam, riid, ppvObject );
}




// --------------------------------------------------------------------------
// Following static functions are local to this module
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData,
//                                           DWORD cbData,
//                                           DWORD dwDstPID );
//
//  IN const BYTE * pData
//    pointer to marshal data to store
//
//  IN DWORD cbData
//    length of marshaled data
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  Returns LRESULT
//    32-bit opaque token (with bit 31 clear) that can be passed to
//    SharedBuffer_Free to get back the interface pointer.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The NT version uses memory-mapped files - we create a file mapping,
//  copy the marshal data into it, and then return the handle.
//
//  If we know the caller'd pid, we DuplicateHandle() the handle to them,
//  and return the duplicated handle.
//
//  If we don't know their pid, we encode the handle and our pid as a string,
//  and convert that to an atom, and return the atom. (This is a 'clever'
//  way of squeezing two 32-bit pieces of information into a single 32-bit
//  LRESULT!)
//
// --------------------------------------------------------------------------

static
LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData, DWORD cbData, DWORD dwDstPID ) 
{
    HRESULT hr = E_FAIL; // if things don't work out...

    // Note that we don't Close this handle explicitly here,
    // DuplicateHandle(DUPLICATE_CLOSE_SOURCE) will code it, whether it is duplicated
    // here (if we know the caller's pid), or in SharedBuffer_Free (if dwDstPID is 0).
    HANDLE hfm = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 
                                    0, cbData + sizeof( XFERDATA ), NULL );
    if( hfm == NULL )
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: CreateFileMapping failed") );
        return E_FAIL;
    }

    PXFERDATA pxd = (PXFERDATA) MapViewOfFile( hfm, FILE_MAP_WRITE, 0, 0, 0 );
    if( pxd == NULL ) 
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: MapViewOfFile failed") );
        return E_FAIL;
    }

    // Got a pointer to the memory. Fill in the header, and copy the marshal data...
    pxd->m_dwSig = MSAAXFERSIG;
    pxd->m_dwSrcPID = GetCurrentProcessId();  // Don't actually need this...
    pxd->m_dwDstPID = dwDstPID;
    pxd->m_cbSize = cbData;

    memcpy( pxd + 1, pData, cbData );

    UnmapViewOfFile( pxd );

    // If we know who the caller is, we can just DUP a handle to them, closing our
    // side, and and return them the DUP's handle...
    if( dwDstPID )
    {

        HANDLE hDstProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwDstPID );
        if( ! hDstProc )
        {
            TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: OpenProcess(pid=%d) failed"), dwDstPID );
            CloseHandle( hfm );
            return E_FAIL;
        }
    
        HANDLE hTarget = NULL;
        BOOL b = DuplicateHandle( GetCurrentProcess(), hfm, hDstProc, & hTarget, 0, FALSE, DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS );
        CloseHandle( hDstProc );

        if( ! b )
        {
            TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: DuplicateHandle (to pid=%d) failed"), dwDstPID );

            // No tidy up to do at this stage. The mapping has been unmapped above; and
            // DuplicateHandle with _CLOSE_SOURCE always closes the source handle, even
            // if it failes to dup it.
            return E_FAIL;
        }

        // Shift right by one to ensure hight-bit is clear (to avoid looking like an error
        // HRESULT). Client will shift-back before use in SharedBuffer_Free.
        hr = (DWORD)HandleToLong(hTarget) >> 1;
    }
    else
    {
        // wParam == 0 means we don't know the caller's PID - encode our pid and the handle
        // is an atom and send that back instead. See comments near EncodeToAtom for full
        // explanation.
        DWORD dwRet;
        if( ! EncodeToAtom( GetCurrentProcessId(), hfm, & dwRet ) )
        {
            TraceError( TEXT("SharedBuffer_Allocate_NT: EncodeToAtom failed") );
            return E_FAIL;
        }

        // Succeeded - so return the atom as the lresult. Atoms are 16-bit, so we don't
        // have to worry about colliding with error HRESULTs.
        hr = dwRet;
    }

    return hr;
}



// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Free_NT( DWORD ref,
//                                       DWORD dwDstPID,
//                                       REFIID riid,
//                                       LPVOID * ppv );
//
//  IN DWORD ref
//    Cookie from SharedBuffer_Allocate
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  IN REFIID riid
//    desired interface to be returned
//
//  OUT LPVOID * ppv
//    returned interface pointer
//
//  Returns HRESULT
//    S_OK on success.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  Basic alg: the ref is either a handle to shared memory, or an atom referencing
//  a handle in another process to shared memory, and that pid. In the latter case,
//  we need to DuplicateHandle that handle to one that we can use.
//
//  Once we've got the handle, map it, check the header of the buffer, and then
//  unmarshal the data to get the interface pointer.
//
// --------------------------------------------------------------------------

static
HRESULT WINAPI SharedBuffer_Free_NT( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv ) 
{
    // sanity check on ref parameter...
    if( FAILED( ref ) ) 
    { 
        TraceError( TEXT("SharedBuffer_Free_NT: ref is failure HRESULT") );
        return E_INVALIDARG; 
    }

    HRESULT hr;
    HANDLE hfm;

    // Extract the handle from ref - two different ways this can happen...

    if( dwDstPID != 0 )
    {
        // Normal case - where we've sent the server our pid and it send us back
        // a handle it has dup'd for us.
        // Server shifted the handle right by one to avoid clashing with error HRESULTS -
        // shift it back before we use it...

        hfm = LongToHandle( ref << 1 );
    }
    else
    {
        // dwDstPid - which is the wParam passed to ObjectFromLresut - is 0, so we don't
        // know the source process's pid. Treat the lresult 'ref' as an atom, and decode
        // that to get the source pid and handle...

        // Extract the source process's PID and its handle from the atom name...
        DWORD dwSrcPID;
        HANDLE hRemoteHandle;

        if( ! DecodeFromAtom( ref, & dwSrcPID, & hRemoteHandle ) )
        {
            return E_FAIL;
        }

        // Now use DuplicateHandle plus the src's pid to convert its src-relative handle
        // to one we can use...

        HANDLE hSrcProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwSrcPID );
        if( ! hSrcProc )
        {
            TraceErrorW32( TEXT("SharedBuffer_Free_NT: OpenProcess(pid=%d) failed"), dwSrcPID );
            return E_FAIL;
        }

        BOOL fDupHandle = DuplicateHandle( hSrcProc, hRemoteHandle,
                                           GetCurrentProcess(), & hfm,
                                           0, FALSE, DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS );
        CloseHandle( hSrcProc );

        if( ! fDupHandle || ! hfm )
        {
            TraceErrorW32( TEXT("SharedBuffer_Free_NT: DuplicateHandle(from pid=%d) failed"), dwSrcPID );
            return E_FAIL;
        }

        // Got it! Now carry on as normal, with hfm == our handle.
    }



    // At this stage, we have the handle. Now map it, so we can extract the data...

    PXFERDATA pxd = (PXFERDATA) MapViewOfFile( hfm, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( pxd == NULL ) 
    {
        TraceErrorW32( TEXT("SharedBuffer_Free_NT: MapViewOfFile failed") );

        // We should only close the handle if it turns out to point to valid
        // shared memory. Otherwise a rogue client could return a handle value
        // that refers to an existing handle in this process - and we'd close
        // that instead.
        UnmapViewOfFile( pxd );
        return E_FAIL;
    }

    // Sanity-check the data:
    // Verify that dest is what we expect them to be.
    // Only check the dstpid if it's non-0...
    if( pxd->m_dwSig != MSAAXFERSIG ||
        ( dwDstPID != 0 && pxd->m_dwDstPID != GetCurrentProcessId() ) )
    {
        TraceError( TEXT("SharedBuffer_Free_NT: Signature of shared mem block is invalid") );

        // don't close handle - see note above...
        UnmapViewOfFile( pxd );
        return E_FAIL;
    }

    BYTE * pData = (BYTE *) ( pxd + 1 );
    DWORD cbData = pxd->m_cbSize;

    // We have the size of the data and the address of the data, unmarshal it
    // make a stream out of it.

    hr = UnmarshalInterface( pData, cbData, riid, ppv );

    UnmapViewOfFile( pxd );
    CloseHandle( hfm );

    return hr;
}


#ifndef NTONLYBUILD




// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData,
//                                              DWORD cbData,
//                                              DWORD dwDstPID );
//
//  IN const BYTE * pData
//    pointer to marshal data to store
//
//  IN DWORD cbData
//    length of marshaled data
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  Returns LRESULT
//    32-bit opaque token (with bit 31 clear) that can be passed to
//    SharedBuffer_Free to get back the interface pointer.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The 9x version uses SharedAlloc, and returns a bit-mangled pointer to
//  the shared buffer.
//
// --------------------------------------------------------------------------

static
LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData, DWORD cbData, DWORD unused( dwDstPID ) ) 
{
    // Since we know we are on Win95, we can specify NULL for
    // the hwnd and hProcess parameters here.
    PVOID pv = SharedAlloc( cbData, NULL, NULL );
    if( pv == NULL )
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_Win95: SharedAlloc failed") );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    memcpy( pv, pData, cbData );

    // Force the high-bit off to indicate a successful return value
    return (LRESULT) ((DWORD) pv) & ~HEAP_GLOBAL; 
}


// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Free_NT( DWORD ref,
//                                       DWORD dwDstPID,
//                                       REFIID riid,
//                                       LPVOID * ppv );
//
//  IN DWORD ref
//    Cookie from SharedBuffer_Allocate
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  IN REFIID riid
//    desired interface to be returned
//
//  OUT LPVOID * ppv
//    returned interface pointer
//
//  Returns HRESULT
//    S_OK on success.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The 9x version un-mangles the pointer to the shared buffer, unmarshalls the marshal
//  data, then frees the shared buffer.
//
// --------------------------------------------------------------------------

static
HRESULT WINAPI SharedBuffer_Free_Win95(DWORD ref, DWORD unused( dwDstPID ), REFIID riid, LPVOID * ppv )
{
    // Get address of shared memory block
    BYTE * pData = (BYTE *) (ref | HEAP_GLOBAL);  // Turn the high-bit back on

    // Get the size of the block in the shared heap.
    DWORD cbData = HeapSize( hheapShared, 0, pData );

    HRESULT hr = UnmarshalInterface( pData, cbData, riid, ppv );

    // we know we are on Win95, can use NULL hProcess...
    SharedFree( pData, NULL);

    return hr;
}

#endif // NTONLYBUILD




// --------------------------------------------------------------------------
//
//  BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw )
//
//
//  IN LPCTSTR pStr
//    pointer to string to parse
//
//  OUT DWORD * pdw
//    returns the hex value of the string.
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Decodes a string of 8 hex digits. This uses EXACTLY 8 hex didits, and
//  fails (returns FALSE) if any invalid (non 0..9A..F) char is encountered.
//
//  Used by DecodeFromAtom().
//
// --------------------------------------------------------------------------

static
BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw )
{
    DWORD dw = 0;
    for( int c = 0 ; c < 8 ; c++, pStr++ )
    {
        dw <<= 4;
        if( *pStr >= '0' && *pStr <= '9' )
        {
            dw += *pStr - '0';
        }
        else if( *pStr >= 'A' && *pStr <= 'F' )
        {
            dw += *pStr - 'A' + 10;
        }
        else if( *pStr >= 'a' && *pStr <= 'f' )
        {
            dw += *pStr - 'a' + 10;
        }
        else
        {
            // invalid hex digit
            return FALSE;
        }
    }

    *pdw = dw;

    return TRUE;
}



//  What this 'atom encoding' is all about...
//
//  If the WM_GETOBJECT is being sent from OLEACC (AccessibleObjectFromWindow),
//  OLEACC will send the pid of the client process in the wParam. The server can
//  use this with DuplicateHandle to create a handle that the destination/client
//  process can use, which the server then returns.
//
//  However, some clients send WM_GETOBJECT directly with wParam == 0; or,
//  in the case of Trident, a provate registered message "WM_HTML_GETOBJECT"
//  is used, with wParam == 0.
//  In this case, the server doesn't know who the client is, so can't Dup a
//  handle to it (in LresultFromObject). Also, the client code, (in
//  ObjectFromLresult) doesn't know who the server is - all it has is the
//  returned DWORD (and a wParam of 0!) - so even if it had a server-relative
//  handle, it couldn't DuplicateHandle it to one that it could use, since that
//  requires knowing the server's pid.
//
//  The solution/workaround here is to special-case the case where wParam is 0.
//  If wParam is non-0 (and is not the SAMETHREAD special value), we use it as the
//  pid and the server dups the handle to one that the cient can use and returns it.
//
//  If the wParam is 0, the server instead builds a string containing the server's
//  pid and the handle, in the following format:
//
//    "MSAA:00000000:00000000:"
//
//  The first 8-digit hex number is the server's pid; the second 8-digit hex number
//  is the server's handle to the memory. (Handles are only 32-bit significant, even
//  on Win64.)
//
//  The server then adds this to the global atom table, using GlobalAddAtom, which
//  returns an ATOM. (Atoms are typedef'd a SHORTs, and will comfortably fit inside
//  the returned DWORD, leaving the high bit 0, avoinding confusion with error
//  HRESULTS.)
//
//  The server returns the atom back to the client.
//  The client code in ObjectFromLresult notices that wParam is 0, so treats the
//  lresult as an Atom, uses globalGetAtomName() to retreive the above string,
//  checks that is has the expected format, and decodes the two hex numbers.
//
//  The client now has the server's PID and the server-relative handle to the 
//  memory containing the marshalled interface pointer. The client can then use
//  these with DuplicateHandle to generate a handle that it can use.
//
//  Now that the client has a handle to the marshalled interface memory, it can
//  continue on as usual to unmarshal the interface which it returns to the caller.
//



// Expected format: "MSAA:00000000:00000000:"

// Defines for offsets into this string. Lengths do not include terminating NULs.
#define ATOM_STRING_LEN         (4 + 1 + 8 + 1 + 8 + 1)

#define ATOM_STRING_PREFIX      TEXT("MSAA:")
#define ATOM_STRING_PREFIX_LEN  5
#define ATOM_PID_OFFSET         5
#define ATOM_COLON2_OFFSET      13
#define ATOM_HANDLE_OFFSET      14
#define ATOM_COLON3_OFFSET      22
#define ATOM_NUL_OFFSET         23



// --------------------------------------------------------------------------
//
//  BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw )
//
//
//  IN DWORD dwSrcPID
//    process id to encode
//
//  IN HANDLE dwSrcHandle
//    handle in source process to encode
//
//  OUT DWORD * pdw
//    returns the resulting atom value
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Encodes the dwSrcPID and dwSrcHandle into a string of the form:
//
//      "MSAA:00000000:00000000:"
//  
//  where the first part is the pid and the second part is the handle, and
//  then gets an atom for this string, and returns the atom.
//
// --------------------------------------------------------------------------

static
BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw )
{
    TCHAR szAtomName[ ATOM_STRING_LEN + 1 ]; // +1 for terminating NUL

    wsprintf( szAtomName, TEXT("MSAA:%08X:%08X:"), dwSrcPID, dwSrcHandle );
    ATOM atom = GlobalAddAtom( szAtomName );

    // atoms are unsigned words - make sure they get converted properly to
    // unsigned DWORD/HRESULTs...
    // At least bit32 must be clear, to avoid confusion with error hresults.
    // (Also, atoms are never 0, so no ambiguity over hr=0 return value, which
    // indicates WM_GETOBJECT not supported.)
    *pdw = (DWORD) atom;
    return TRUE;
}



// --------------------------------------------------------------------------
//
//  BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle )
//
//
//  IN DWORD dw
//    specifies the atom to be decoded
//
//  OUT DWORD * pdwSrcPID
//    returns the source process id
//
//  OUT HANDLE * pdwSrcHandle
//    returns the handle in source process
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Gets ths string for the atom represented by dw, and decodes it to get
//  the source process id and handle value.
//
// --------------------------------------------------------------------------

static
BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle )
{
    // Sanity check that dw looks like an atom - it's a short (WORD), so high word
    // should be zero...

    if( HIWORD( dw ) != 0 || LOWORD( dw ) == 0 )
    {
        TraceError( TEXT("DecodeFromAtom: value doesn't look like atom (%08lx) - high word should be clear"), dw );
        return FALSE;
    }

    ATOM atom = (ATOM)dw;

    TCHAR szAtomName[ ATOM_STRING_LEN + 1 ]; // +1 for terminating NUL

    int len = GlobalGetAtomName( atom, szAtomName, ARRAYSIZE( szAtomName ) );
    if( len != ATOM_STRING_LEN )
    {
        TraceError( TEXT("DecodeFromAtom: atom string is incorrect length - %d instead of %d"), len, ATOM_STRING_LEN );
        return FALSE;
    }

    // Check for expected format...
    if( memcmp( szAtomName, ATOM_STRING_PREFIX, ATOM_STRING_PREFIX_LEN * sizeof( TCHAR ) ) != 0
        || szAtomName[ ATOM_COLON2_OFFSET ] != ':'
        || szAtomName[ ATOM_COLON3_OFFSET ] != ':'
        || szAtomName[ ATOM_NUL_OFFSET ] != '\0' )
    {
        TraceError( TEXT("DecodeFromAtom: atom string has incorrect format (%s)"), szAtomName );
        return FALSE;
    }

    // Extract the source process's PID and its handle from the atom name...
    DWORD dwSrcPID;
    DWORD dwRemoteHandle;

    if( ! ParseHexStr( & szAtomName[ 5 ], & dwSrcPID )
     || ! ParseHexStr( & szAtomName[ 14 ], & dwRemoteHandle ) )
    {
        TraceError( TEXT("DecodeFromAtom: atom string contains bad hex (%s)"), szAtomName );
        return FALSE;
    }

    // Done with the atom - can delete it now...
    GlobalDeleteAtom( atom );

    *pdwSrcPID = dwSrcPID;
    *pdwSrcHandle = LongToHandle( dwRemoteHandle );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\mdicli.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MDICLI.H
//
//  MDI Client support
//
// --------------------------------------------------------------------------


class CMdiClient : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT*);
        virtual STDMETHODIMP        get_accSelection(VARIANT*);

        CMdiClient(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\memchk.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MEMCHK.CPP
//
//  Simple new/delete counting error checking library
//
// --------------------------------------------------------------------------
#include "oleacc_p.h"
#include "default.h"
#include "w95trace.h"
#include "memchk.h"


#ifdef _DEBUG

struct MemInfo
{
	LONG    m_NumAlloc;
	LONG    m_NumFree;
};

// Two MemInfo structures - one for allocations through new/delete,
// one for allocations through SharedAlloc/SharedFree
MemInfo g_MemInfo;
MemInfo g_SharedMemInfo;

#endif // _DEBUG



#ifndef _DEBUG

// Non-_DEBUG new/delete call-through to LocalAlloc/Free...

// --------------------------------------------------------------------------
//
//  new()
//
//  We implement this ourself to avoid pulling in the C++ runtime.
//
// --------------------------------------------------------------------------

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (void *)LocalAlloc(LPTR, nSize);
}


// --------------------------------------------------------------------------
//
//  delete()
//
//  We implement this ourself to avoid pulling in the C++ runtime.
//
// --------------------------------------------------------------------------
void  __cdecl operator delete(void *pv)
{
    LocalFree((HLOCAL)pv);
}


// --------------------------------------------------------------------------
//
//  SharedAlloc()
//
//  This allocates out of the shared heap on Win '95. On NT, we need to
//  use VirtualAllocEx to allocate memory in the other process. The caller
//  of SharedAlloc will need to then use ReadProcessMemory to read the data
//  from the VirtualAlloc'ed memory. What I am going to do is create 2 new
//  functions - SharedRead and SharedWrite, that will read and write shared
//  memory. On Win95, they will just use CopyMemory, but on NT they will use
//  ReadProcessMemory and WriteProcessMemory.
//
//  Parameters:
//      UINT    cbSize      Size of the memory block required
//      HWND    hwnd        Window handle in the process to allocate
//                          the shared memory in.
//      HANDLE* pProcHandle Pointer to a handle that has the process
//                          handle filled in on return. This must be saved
//                          for use in calls to SharedRead, SharedWrite,
//                          and SharedFree.
//
//  Returns:
//      Pointer to the allocated memory, or NULL if it fails. Access to the
//      memory must be done using SharedRead and SharedWrite. On success,
//      pProcHandle is filled in as well.
//
// --------------------------------------------------------------------------
LPVOID SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle)
{
#ifndef NTONLYBUILD
    if (fWindows95)
        return(HeapAlloc(hheapShared, HEAP_ZERO_MEMORY, cbSize));
    else
#endif // NTONLYBUILD
    {
        DWORD dwProcessId;
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )
            return NULL;

        HANDLE hProcess = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
									   FALSE,dwProcessId );
        if( ! hProcess )
            return NULL;

        LPVOID pv = MyVirtualAllocEx( hProcess, NULL, cbSize, MEM_COMMIT, PAGE_READWRITE );
        if( ! pv )
        {
            CloseHandle( hProcess );
            return NULL;
        }

        if( pProcessHandle )
            *pProcessHandle = hProcess;

        return pv;
    }
}


// --------------------------------------------------------------------------
//
//  SharedFree()
//
//  This frees shared memory.
//
// --------------------------------------------------------------------------
VOID SharedFree(LPVOID lpv,HANDLE hProcess)
{
#ifndef NTONLYBUILD
    if (fWindows95)
        HeapFree(hheapShared, 0, lpv);
    else
#endif // NTONLYBUILD
    {
        MyVirtualFreeEx(hProcess,lpv,0,MEM_RELEASE);
        CloseHandle (hProcess);
    }
}


// 'Empty' functions to keep compiler/linker happy in case client
// calls these in non _DEBUG code...
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
void InitMemChk()
{
	// Do nothing
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
void UninitMemChk()
{
	// Do nothing
}



#else // _DEBUG #############################################################

// --------------------------------------------------------------------------
// DEBUG new - increments new count, calls through to LocalAlloc...
// --------------------------------------------------------------------------
void *  __cdecl operator new(unsigned int nSize)
{
    // Zero init just to save some headaches
    void * pv = (void *)LocalAlloc(LPTR, nSize);

	if( ! pv )
	{
		return NULL;
	}

	// Update statistics...
	InterlockedIncrement( & g_MemInfo.m_NumAlloc );

	// return pointer to alloc'd space...
	return pv;
}


// --------------------------------------------------------------------------
// DEBUG delete - increments delete count, calls through to LocalFree...
// --------------------------------------------------------------------------
void  __cdecl operator delete(void *pv)
{
	// C++ allows 'delete NULL'...
	if( pv == NULL )
		return;

    // Update statistics...
	InterlockedIncrement( & g_MemInfo.m_NumFree );

    LocalFree((HLOCAL)pv);
}

// --------------------------------------------------------------------------
//
//  DEBUG SharedAlloc()
//
//  Does alloc, updates count.
// --------------------------------------------------------------------------
LPVOID SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle)
{
#ifndef NTONLYBUILD
    if (fWindows95)
	{
		// Update statistics...
		InterlockedIncrement( & g_SharedMemInfo.m_NumAlloc );

        return(HeapAlloc(hheapShared, HEAP_ZERO_MEMORY, cbSize));
	}
    else
#endif // NTONLYBUILD
    {
        DWORD dwProcessId;
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )
            return NULL;

        HANDLE hProcess = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
									   FALSE,dwProcessId );
        if( ! hProcess )
            return NULL;

        LPVOID pv = MyVirtualAllocEx( hProcess, NULL, cbSize, MEM_COMMIT, PAGE_READWRITE );
        if( ! pv )
        {
            CloseHandle( hProcess );
            return NULL;
        }

		// Update statistics...
		InterlockedIncrement( & g_SharedMemInfo.m_NumAlloc );

        if( pProcessHandle )
            *pProcessHandle = hProcess;

        return pv;
    }
}



// --------------------------------------------------------------------------
//
//  DEBUG SharedFree()
//
//  frees shared memory, updates free count.
//
// --------------------------------------------------------------------------
VOID SharedFree(LPVOID lpv,HANDLE hProcess)
{
	// Update statistics...
	InterlockedIncrement( & g_SharedMemInfo.m_NumFree );

#ifndef NTONLYBUILD
    if (fWindows95)
        HeapFree(hheapShared, 0, lpv);
    else
#endif // NTONLYBUILD
    {
        MyVirtualFreeEx(hProcess,lpv,0,MEM_RELEASE);
        CloseHandle (hProcess);
    }
}


// --------------------------------------------------------------------------
// InitMemChk - sets alloc/free counts to zero.
// --------------------------------------------------------------------------
void InitMemChk()
{
	g_MemInfo.m_NumAlloc = 0;
	g_MemInfo.m_NumFree = 0;

	g_SharedMemInfo.m_NumAlloc = 0;
	g_SharedMemInfo.m_NumFree = 0;
}

// --------------------------------------------------------------------------
// UninitMemChk - outputs stats including number of unfree'd objects...
//
// Note that Shared memory is often allocated from one process and free'd
// from another, so when a process detatches the numbers may not match up.
// At some point in time it might be more useful to keep this as a global
// across all instances of the DLL.
// --------------------------------------------------------------------------
void UninitMemChk()
{
    DBPRINTF( TEXT("Total objects: %d, unfreed: %d\n"),
    	g_MemInfo.m_NumAlloc,
    	g_MemInfo.m_NumAlloc - g_MemInfo.m_NumFree );

    DBPRINTF( TEXT("Total Shared objects: %d, unfreed: %d\n"),
    	g_SharedMemInfo.m_NumAlloc,
    	g_SharedMemInfo.m_NumAlloc - g_SharedMemInfo.m_NumFree );
}

#endif // _DEBUG











// --------------------------------------------------------------------------
//
//  SharedRead
//
//  This reads shared memory.
//
// --------------------------------------------------------------------------

BOOL SharedRead(LPVOID lpvSharedSource,LPVOID lpvDest,DWORD cbSize,HANDLE hProcess)
{
#ifdef _X86_
    if (fWindows95)
    {
        CopyMemory (lpvDest,lpvSharedSource,cbSize);
        return TRUE;
    }
    else
#endif // _X86_
    {
        return (ReadProcessMemory (hProcess,lpvSharedSource,lpvDest,cbSize,NULL));
    }
}


// --------------------------------------------------------------------------
//
//  SharedWrite
//
//  This writes into shared memory.
//
// --------------------------------------------------------------------------

BOOL SharedWrite(LPVOID lpvSource,LPVOID lpvSharedDest,DWORD cbSize,HANDLE hProcess)
{
#ifdef _X86_
    if (fWindows95)
    {
        CopyMemory(lpvSharedDest,lpvSource,cbSize);
        return TRUE;
    }
    else
#endif // _X86_
    {
        return (WriteProcessMemory (hProcess,lpvSharedDest,lpvSource,cbSize,NULL));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\memchk.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MEMCHK.H
//
//  Simple new/delete counting error ehecking library
//
// -------------------------------------------------------------------------=


// Call this at DLL_PROCESS_ATTACH time...
void InitMemChk();

// ... and this at DLL_PROCESS_DETACH time - number of 
// outstanding delete's will be reported by DBPRINTF.
void UninitMemChk();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\menu.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MENU.CPP
//
//  Menu class, for system menus and app menus.
//
//	There are four classes here. 
//	CMenu is the class that knows how to deal with menu bar objects. These
//	have children that are CMenuItem objects, or just children (rare - 
//	this is when you have a command right on the menu bar).
//	CMenuItem is something that when you click on it opens a popup.
//	It has 1 child that is a CMenuPopupFrame.
//	CMenuPopupFrame is the HWND that pops up when you click on a CMenuItem. It
//	has 1 child, a CMenuPopup.
//  CMenuPopup objects represent the client area of a CMenuPopupFrame HWND.
//  It has children that are menu items (little m, little i), separators, and 
//	CMenuItems (when you have cascading menus).
//
//  Issues that came up during design/implementation:
//      (1) How do we select/focus menu items while in menu mode?
//      (2) How do we choose an item (default action)?
//          For menu bars, we use SendInput to send Alt+Shortcut key to 
//          open or execute an item or command. Send just Alt to close 
//          an item that is already open.
//      (3) How do we handle popup menus?  
//          As discussed above, we treat them very strangely. There are ways
//          to get the children in a popup whether it is visible or not.
//      (4) What about "system menu" popups on tray?
//          
//		(5) In general, what about "context menus"? This may need to be
//			exposed by the app itself. We can't do everything!
// 
//  History:
//	written by Laura Butler, early 1996
//	complete re-write by Steve Donie, August 1996-January 1997
//  doDefaultAction changed to use keypresses rather than mouse clicks 3-97
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "menu.h"

#include "propmgr_util.h"

#define MI_NONE         -1

#ifndef MFS_HOTTRACK
#define MFS_HOTTRACK        0x00000100L
#endif // !MFS_HOTTRACK





// --------------------------------------------------------------------------
// prototypes for local functions
// --------------------------------------------------------------------------
HWND GetSubMenuWindow (HMENU hSubMenuToFind);
long FindItemIDThatOwnsThisMenu (HMENU hMenuOwned,HWND* phwndOwner,
                                 BOOL* pfPopup,BOOL* pfSysMenu);
STDAPI  WindowFromAccessibleObjectEx(IAccessible* pacc, HWND* phwnd);

BOOL    MyGetMenuString( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, long id, LPTSTR lpszBuf, UINT cchMax, BOOL fAllowGenerated );

BOOL    TryMSAAMenuHack( IAccessible * pTheObj, HWND hWnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax );
BOOL    GetShellOwnerDrawMenu( HWND hwnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax );

UINT    GetMDIButtonIndex( HMENU hMenu, DWORD idPos );
BOOL    GetMDIMenuDescriptionString( HMENU hMenu, DWORD idPos, BSTR * pbstr );
BOOL    GetMDIMenuString( HWND hwnd, HMENU hMenu, DWORD idPos, LPTSTR lpszBuf, UINT cchMax );

HMENU   MyGetSystemMenu( HWND hwnd );

HRESULT GetMenuItemName( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, BSTR * pszName );
TCHAR   GetMenuItemHotkey( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, DWORD fOptions );
HRESULT GetMenuItemShortcut( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id,
                             BOOL fIsMenuBar, BSTR * pszShortcut );

enum
{
    GMIH_ALLOW_INITIAL     = 0x01,
    GMIH_ALLOW_SYS_SPACE   = 0x02
};



// --------------------------------------------------------------------------
//
//  CreateSysMenuBarObject()
//
//  EXTERNAL for CreateStdAcessibleObject
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for
//	ppvMenu		OUT		ppvMenu holds the indirect pointer to the menu 
//						object. 
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object,
//		E_FAIL if the hwnd is invalid.
//
// --------------------------------------------------------------------------
HRESULT CreateSysMenuBarObject(HWND hwnd, long idObject, REFIID riid,
    void** ppvMenu)
{
    UNUSED(idObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    return(CreateMenuBar(hwnd, TRUE, 0, riid, ppvMenu));
}

// --------------------------------------------------------------------------
//
//  CreateMenuBarObject()
//
//  EXTERNAL for CreateStdAcessibleObject
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for (like IAccessible,
//						IEnumVARIANT,IDispatch...)
//	ppvMenu		OUT		ppvMenu is where QueryInterface will return the 
//						indirect pointer to the menu object (caller casts
//						this to be a pointer to the interface they asked for)
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object,
//		E_FAIL if the hwnd is invalid.
//
// --------------------------------------------------------------------------
HRESULT CreateMenuBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvMenu)
{
    UNUSED(idObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    return(CreateMenuBar(hwnd, FALSE, 0, riid, ppvMenu));
}



// --------------------------------------------------------------------------
//
//  CreateMenuBar()
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	fSysMenu	IN		true if this is a system menu, false if app menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for
//	ppvMenu		OUT		ppvMenu is where QueryInterface will return the 
//						indirect pointer to the menu object
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object.
//
//	Called By:
//	CreateMenuBarObject and CMenu::Clone
// --------------------------------------------------------------------------
HRESULT CreateMenuBar(HWND hwnd, BOOL fSysMenu, long idChildCur,
    REFIID riid, void** ppvMenu)
{
HRESULT     hr;
CMenu*      pmenu;

    InitPv(ppvMenu);

    pmenu = new CMenu(hwnd, fSysMenu, idChildCur);
    if (!pmenu)
        return(E_OUTOFMEMORY);

    hr = pmenu->QueryInterface(riid, ppvMenu);
    if (!SUCCEEDED(hr))
        delete pmenu;

    return(hr);
}

// --------------------------------------------------------------------------
//
//  CMenu::CMenu()
//
//	Constructor for the CMenu class. Initializes the member variables with
//	the passed in parameters. It is only called by CreateMenuBar.
//
// --------------------------------------------------------------------------
CMenu::CMenu(HWND hwnd, BOOL fSysMenu, long idChildCur)
    : CAccessible( CLASS_MenuObject )
{
    m_hwnd = hwnd;
    m_fSysMenu = fSysMenu;
    m_idChildCur = idChildCur;
	m_hMenu = NULL;
	// m_hMenu is filled in by SetupChildren()
	// m_cChildren is filled in by SetupChildren()
}

// --------------------------------------------------------------------------
//
//  CMenu::SetupChildren()
//
//	This uses the object's window handle to get the handle to the appropriate
//	menu (hmenu type menu handle) and the count of the children in that menu.
//	It uses GetMenuBarInfo, a private function in USER, to do this.
//	These values are kept as member variables of the CMenu object.
//
// --------------------------------------------------------------------------
void CMenu::SetupChildren(void)
{
MENUBARINFO mbi;

    if (!MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU), 
        0, &mbi))
    {
        m_hMenu = NULL;
    }
    else
    {
        m_hMenu = mbi.hMenu;
    }

    if (!m_hMenu)
        m_cChildren = 0;
    else
    {
        m_cChildren = GetMenuItemCount(m_hMenu);

        if( m_cChildren == -1 )
        {
            // Paranoia in case we get an invalid HMENU
            m_cChildren = 0;
        }
    }
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accChild()
//
//	What we want this do do is return (in ppdisp) an IDispatch pointer to 
//  the child specified by varChild. The children of a CMenu are either
//	menu commands (rare to have a command on the menu bar) and CMenuItems.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
HMENU	hSubMenu;

    InitPv(ppdisp);

    if (!ValidateChild(&varChild))
        return (E_INVALIDARG);
    
    if (varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

	Assert (m_hMenu);

    hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1);

	if (hSubMenu == NULL)
	{
        // This returns false - for commands on the menu bar, we do not create a child
        // object - the parent is able to answer all the questions.
		return (S_FALSE);
	}

    return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu,hSubMenu,
        varChild.lVal,  0, TRUE, IID_IDispatch, (void**)ppdisp));
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accName()
//
//	Pass in a VARIANT with type VT_I4 and lVal equal to the 1-based position
// of the item you want the name for. Pass in a pointer to a string and the
// string will be filled with the name.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

	if (varChild.lVal != CHILDID_SELF)
	{
        return GetMenuItemName( this, m_hwnd, m_hMenu, varChild.lVal, pszName );
	}

    if (m_fSysMenu)
        return HrCreateString(STR_SYSMENU_NAME, pszName);	// in English = "System"
    else
        return HrCreateString(STR_MENUBAR_NAME, pszName);	// in English, this is "Application"
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accDescription()
//
// get a string with the description of this menu item. For CMenu, this
// is something like "contains commands to manipulate the window" or
// "Contains commands to manipulate the current view or document" 
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{

    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

	// Check if they are asking about the menu bar itself or a child.
    // If asking about a child, return S_FALSE, because we don't have 
    // descriptions for items, just the system and app menu bars.
    //
	if (varChild.lVal != CHILDID_SELF)
    {
        if( GetMDIMenuDescriptionString( m_hMenu, varChild.lVal - 1, pszDesc ) )
        {
            return S_OK;
        }

		return S_FALSE;
    }
    else if (m_fSysMenu)
    {
        return HrCreateString(STR_SYSMENUBAR_DESCRIPTION, pszDesc);
    }
    else
    {
        return HrCreateString(STR_MENUBAR_DESCRIPTION, pszDesc);
    }
}




// --------------------------------------------------------------------------
//
//  CMenu::get_accRole()
//
// get the role - this is either menu item or menu bar
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

	if (varChild.lVal != CHILDID_SELF)
    {
        if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
        {
            // Special case for MDI child buttons - they are actually implemented
            // as menu items, but appear as buttons.
    		pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
        }
        else
        {
    		pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        }
    }
	else
		pvarRole->lVal = ROLE_SYSTEM_MENUBAR;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenu::get_accState()
//
// get the state of the child specified. returned in a variant VT_I4
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    MENUBARINFO mbi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (!m_hMenu || !MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
        varChild.lVal, &mbi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }
    else if( varChild.lVal && GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // For MDI button elements, just leave the state as normal, to be consistent
        // with the top-level restore/close/minimize buttons.

        // Do nothing here.
    }
    else
    {
        // Non-MDI-button menu items, or CHILDID_SELF...

        // smd 1-29-97 - change from OFFSCREEN to INVISIBLE
        if (IsRectEmpty(&mbi.rcBar))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (GetForegroundWindow() == m_hwnd)
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (mbi.fFocused)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        
        if (varChild.lVal)
        {
            MENUITEMINFO    mi;

            //
            // Get menu item flags.  NOTE:  Can't use GetMenuState().  It whacks
            // random stuff in for hierarchicals.
            //
            mi.cbSize = SIZEOF_MENUITEMINFO;
            mi.fMask = MIIM_STATE | MIIM_SUBMENU;

            if (!GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi))
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                return(S_FALSE);
            }

            if (mi.fState & MFS_GRAYED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (mi.fState & MFS_CHECKED)
                pvarState->lVal |= STATE_SYSTEM_CHECKED;

            if (mi.fState & MFS_DEFAULT)
                pvarState->lVal |= STATE_SYSTEM_DEFAULT;

            if (mbi.fFocused)
            {
                pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;
			    if (mi.fState & MFS_HILITE)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }

            if (mi.hSubMenu)
                pvarState->lVal |= STATE_SYSTEM_HASPOPUP;
        
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accKeyboardShortcut()
//
// returns a string with the menu shortcut to the child asked for
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
    {
        if (!m_hMenu)
            return S_FALSE;

        if (m_fSysMenu)
        {
            // Alt+Space/Hyphen is the system menu...
            TCHAR szFormat[16];
            LoadString(hinstResDll, STR_MENU_SHORTCUT_FORMAT, szFormat, ARRAYSIZE(szFormat));

            TCHAR szKey[16];
            LoadString(hinstResDll, ((GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD) ?
                STR_CHILDSYSMENU_KEY : STR_SYSMENU_KEY), szKey, ARRAYSIZE(szKey));

            TCHAR szHotKey[32];
            szHotKey[ 0 ] = '\0';
            wsprintf(szHotKey, szFormat, szKey);

            if (*szHotKey)
            {
                *pszShortcut = TCharSysAllocString(szHotKey);
                if (! *pszShortcut)
                    return E_OUTOFMEMORY;

                return S_OK;
            }

            return S_FALSE;
        }
        else
        {
            // "Alt" is the menu bar
            return HrCreateString(STR_MENU_SHORTCUT, pszShortcut);
        }
    }
    else
    {
        // Get menu item shortcut - TRUE means use "Alt+" format.
        return GetMenuItemShortcut( this, m_hwnd, m_hMenu, varChild.lVal, TRUE, pszShortcut );
    }
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accFocus()
//
//  This fills in pvarFocus with the ID of the child that has the focus.
//	So when say you just hit "Alt" (File is now highlighted) and then call 
//	get_accFocus(), pvarFocus will have VT_I4 and lVal = 1.
//
//	If we are not in menu mode, then we certainly don't have the focus. 
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accFocus(VARIANT* pvarFocus)
{
GUITHREADINFO	GuiThreadInfo;
MENUITEMINFO	mii;
int				i;

	// set it to empty
    InitPvar(pvarFocus);

    //
    // Are we in menu mode?  If not, nothing.
    //
	if (!MyGetGUIThreadInfo (NULL,&GuiThreadInfo))
		return(S_FALSE);

	if (GuiThreadInfo.flags & GUI_INMENUMODE)
	{
		// do I have to loop through all of them to see which
		// one is hilited?? Looks like it...
		mii.cbSize = SIZEOF_MENUITEMINFO;
		mii.fMask = MIIM_STATE;

		SetupChildren();
		for (i=0;i < m_cChildren;i++)
		{
			GetMenuItemInfo (m_hMenu,i,TRUE,&mii);
			if (mii.fState & MFS_HILITE)
			{
				pvarFocus->vt = VT_I4;
				pvarFocus->lVal = i+1;
				return (S_OK);
			}
		}

		// I don't think this should happen
		return(S_FALSE);
	}

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accDefaultAction()
//
//  Menu bars have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command.
//
//  doDefaultAction follows from this. It has to do whatever getDefaultAction
//  says it is going to do. We use keystrokes to do this for menu bars. 
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
GUITHREADINFO   gui;
HMENU           hSubMenu;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);


    if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // Special case for MDI child buttons - they are actually implemented
        // as menu items, but appear as buttons.
        return HrCreateString(STR_BUTTON_PUSH, pszDefA);
    }


    // Only if this window is active can we do the default.
    // There is a slight danger here that an Always On Top window
    // could be covering us, but this is small.
    //
    if (!MyGetGUIThreadInfo(0, &gui))
        return(E_NOT_APPLICABLE);

    if (m_hwnd != gui.hwndActive)
        return(E_NOT_APPLICABLE);

    varChild.lVal--;

    // Is this item enabled?
    if (GetMenuState(m_hMenu, varChild.lVal, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

    // Now check if this item has a submenu that is displayed.
    // If there is, the action is hide, if not, the action is show. 
    // If it doesn't have a submenu, the action is execute.
    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal))
    {
        if (GetSubMenuWindow(hSubMenu))
            return(HrCreateString(STR_DROPDOWN_HIDE, pszDefA));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDefA));
    }
    else
        return(HrCreateString(STR_EXECUTE, pszDefA));
}

// --------------------------------------------------------------------------
//
//  CMenu::accSelect()
//
//  We only accept TAKE_FOCUS. What I wanted this to do is to just put the
//  app into menu mode (if it isn't already - more on this later) and then
//  select the item specified - don't open it or anything, just select it.
//
//  But that was a pain in the butt, so no I just use doDefaultAction to
//  do the work. Maybe I'll fix it for 1.1
//
//  If we are already in menu mode, and a popup is open, then we should 
//  close the popup(s) and select the item. If in menu mode and no popups
//  are up, just select the item. 
//
//  If the app is just setting focus to the menu bar itself, and not already
//  in menu mode, just put us into menu mode (automatically selects first
//  item). If we are already in menu mode, do nothing.
//
//  I want to try to do all this without generating a whole mess of extra
//  events!
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accSelect(long flagsSel, VARIANT varChild)
{
LPARAM          lParam;
GUITHREADINFO   GuiThreadInfo;

    if (!ValidateChild(&varChild) || !ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    if (flagsSel != SELFLAG_TAKEFOCUS)
        return(E_NOT_APPLICABLE);

    // if this window is not the active window, fail.
	MyGetGUIThreadInfo (NULL,&GuiThreadInfo);
    if (GuiThreadInfo.hwndActive != m_hwnd)
        return (E_NOT_APPLICABLE);

#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF (TEXT("null hmenu at 1\r\n"));
        Assert (m_hMenu);
    }
#endif

    if (varChild.lVal == CHILDID_SELF)
    {
        if (!m_fSysMenu)
            lParam = NULL;
        else if (GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD)
            lParam = MAKELONG('-', 0);
        else
            lParam = MAKELONG(' ', 0);

        PostMessage(m_hwnd, WM_SYSCOMMAND, SC_KEYMENU, lParam);
        return (S_OK);
    }
    else if (GetSubMenu(m_hMenu, varChild.lVal-1))
    {
        // for version 1.0, I'll just do this. Safe, even though it's not 100%
        // what I want it to do.
        return (accDoDefaultAction (varChild));
    }

    return (E_FAIL);
}



// --------------------------------------------------------------------------
//
//  CMenu::accLocation()
//
// get the location of the child. left,top,width,height
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    MENUBARINFO mbi;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

	if (!MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
        varChild.lVal, &mbi))
        return(S_FALSE);

    *pcxWidth = mbi.rcBar.right - mbi.rcBar.left;
    *pcyHeight = mbi.rcBar.bottom - mbi.rcBar.top;

    *pxLeft = mbi.rcBar.left;
    *pyTop = mbi.rcBar.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenu::accHitTest()
//
// if the point is in a menu bar, return the child the point is over
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accHitTest(long x, long y, VARIANT* pvarHit)
{
    InitPvar(pvarHit);
    SetupChildren();

    if (SendMessage(m_hwnd, WM_NCHITTEST, 0, MAKELONG(x, y)) == (m_fSysMenu ? HTSYSMENU : HTMENU))
    {
        pvarHit->vt = VT_I4;
        pvarHit->lVal = 0;

        if (m_cChildren)
        {
            if (m_fSysMenu)
                pvarHit->lVal = 1;
            else
            {
                POINT   pt;

                pt.x = x;
                pt.y = y;

				// MenuItemFromPoint conveniently returns -1 if we are not
				// over any menu item, so that gets returned as 0 (CHILDID_SELF)
				// while others get bumped by 1 to be 1..n. Cool!
                pvarHit->lVal = MenuItemFromPoint(m_hwnd, m_hMenu, pt) + 1;
            }

            if (pvarHit->lVal)
            {
                IDispatch* pdispChild;

                pdispChild = NULL;
                get_accChild(*pvarHit, &pdispChild);
                if (pdispChild)
                {
                    pvarHit->vt = VT_DISPATCH;
                    pvarHit->pdispVal = pdispChild;
                }
            }
        }

        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenu::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
long		lEnd = 0;
HMENU		hSubMenu;

    InitPvar(pvarEnd);	

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (varStart.lVal == CHILDID_SELF)
        return(GetParentToNavigate((m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
            m_hwnd, OBJID_WINDOW, dwNavDir, pvarEnd));

	// when we get to here, navdir was either firstchild
	// or lastchild (now changed to either next or previous)
	// OR
	// we were starting from something other than the parent object
    switch (dwNavDir)
    {
        case NAVDIR_RIGHT:
        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_LEFT:
        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
		// we should give the child object back!!
#ifdef _DEBUG
        if (!m_hMenu)
        {
            //DBPRINTF (TEXT("null hmenu at 2\r\n"));
            Assert (m_hMenu);
        }
#endif

		hSubMenu = GetSubMenu (m_hMenu,lEnd-1);
		if (hSubMenu)
		{
			pvarEnd->vt=VT_DISPATCH;
			return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, hSubMenu,
				lEnd,  0, FALSE, IID_IDispatch, (void**)&pvarEnd->pdispVal));
		}
		// just return VT_I4 if it does not have a submenu.
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CMenu::accDoDefaultAction()
//
//  Menu bars have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command. To Open something that is closed or to Execute a command, 
//  we use SendInput to send Alt+ShortcutKey. To Close something, we just 
//  send Alt.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accDoDefaultAction(VARIANT varChild)
{
GUITHREADINFO   gui;
TCHAR           chHotKey;
HMENU	        hSubMenu;
int             i,n;
int             nTries;
#define MAX_TRIES 20

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);


    if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // Special case for MDI child buttons - they are actually implemented
        // as menu items, but appear as buttons.

        // Active them by posting a WM_COMMAND with the command id of the
        // corresponding menu item.
        //
        // This WM_COMMAND gets picked up by the MDIClient window, and it then
        // minimizes/restores/closes the currently active child. (If we did
        // a WM_SYSCOMMAND instead of WM_COMMAND, the overall app window
        // would minimize/restore/close instead!)
        int id = GetMenuItemID( m_hMenu, varChild.lVal - 1 );
        PostMessage(m_hwnd, WM_COMMAND, id, 0L);
        return S_OK;
    }


    //
    // Only if this window is active can we do the default.
	//
    if (!MyGetGUIThreadInfo(0, &gui))
        return(E_FAIL);

    if (m_hwnd != gui.hwndActive)
        return(E_NOT_APPLICABLE);

    // If disabled, fail
    if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF (TEXT("null hmenu at 3\r\n"));
        Assert (m_hMenu);
    }
#endif

    // First check if this item has a sub menu, and if it is open.
    // If it has, and it is, then close it.
    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1))
    {
        if (GetSubMenuWindow(hSubMenu))
        {
            MyBlockInput (TRUE);
            SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
            MyBlockInput (FALSE);
            return (S_OK);
        }
    }

    // when we get here, either it doesn't have a submenu and we need
    // to execute, or the submenu is closed and we need to open it.
    // Our actions are the same in either case. - send Alt+Letter if
    // there is a letter, if not a letter....

    // special case for system menus
    if (m_fSysMenu)
    {
    LPARAM  lParam;

        if (GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD)
            lParam = MAKELONG('-', 0);
        else
            lParam = MAKELONG(' ', 0);

        PostMessage(m_hwnd, WM_SYSCOMMAND, SC_KEYMENU, lParam);
        return (S_OK);
    }

    //
    // Get menu item string; get & character.
    //

    chHotKey = GetMenuItemHotkey( this, m_hwnd, m_hMenu, varChild.lVal, 0 );

    if (chHotKey)
    {
        MyBlockInput (TRUE);
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
        SendKey (KEYPRESS,VK_CHAR,0,chHotKey);
        SendKey (KEYRELEASE,VK_CHAR,0,chHotKey);
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
        MyBlockInput (FALSE);
        return (S_OK);
    }
    else
    {
        // Bad Apps don't define hot keys. We can try to move the selection
        // to that item and then hit enter. An easier way would be to just
        // hit Alt+FirstLetter, but if there are more than 1 item with that
        // letter, it will always do the first one. Not optimal, may lead to
        // unexpected side-effects. Better to do nothing than to do that.
        //
        // We need to put ourselves in menu mode if we aren't already, then
        // send right arrow keys to put us on the right one, then hit Enter.
        // If we are already in menu mode, take us out of menu mode to close
        // the heirarchy, then go back into menu mode and continue.
        MyBlockInput (TRUE);
        if (gui.flags & GUI_INMENUMODE)
        {
            SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
        }

        // now go into menu mode and send right arrows until the one we 
        // want is highlighted.
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);

        // calculate how many right arrows to hit:
        n = varChild.lVal-1;
        // if this menu is the menu of an MDI window and the window
        // is maximized, then the thing now highlighted is the MDI
        // Doc Sys menu, and we'll have to go 1 farther than we think.
        // To see if this is the case, we'll check if the first item
        // in the menu is something with a submenu and it is a bitmap menu.
        if (GetSubMenu(m_hMenu,0) &&
            (GetMenuState(m_hMenu, 0, MF_BYPOSITION) & MF_BITMAP))
            n++;

        for (i = 0; i < n;i++)
        {
            SendKey (KEYPRESS,VK_VIRTUAL,VK_RIGHT,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_RIGHT,0);
        }
        MyBlockInput (FALSE);        

        // check if it is highlighted now. If so, hit enter to activate.
        // try several times - 
        nTries = 0;
        while ( ((GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MF_HILITE) == 0) &&
                (nTries < MAX_TRIES))
        {
            Sleep(55);
            nTries++;
        }

        if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MF_HILITE)
        {
            MyBlockInput (TRUE);        
            SendKey (KEYPRESS,VK_VIRTUAL,VK_RETURN,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_RETURN,0);
            MyBlockInput (FALSE);        
            return (S_OK);
        }
        else
            return (E_FAIL);
    }
}



// --------------------------------------------------------------------------
//
//  CMenu::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::Clone(IEnumVARIANT** ppenum)
{
    return(CreateMenuBar(m_hwnd, m_fSysMenu, m_idChildCur, IID_IEnumVARIANT,
            (void**)ppenum));
}


STDMETHODIMP CMenu::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    DWORD dwpid;
    GetWindowThreadProcessId( m_hwnd, & dwpid );
    MakeHmenuKey( pKeyData, dwpid, m_hMenu, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
//
//  MENU ITEMS
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  CreateMenuItem()
//
//  This creates a child object for a menu item that has a sub menu.
//
//	Parameters:
//	paccMenu	IN		pointer to the parent's IAccessible
//	hwnd		IN		the hwnd of the window that owns the parent menu
//	hMenu		IN		the hmenu of the menu that owns this item.
//	hSubMenu	IN		the hMenu of the submenu this menu item opens
//	ItemID		IN		the menu item ID. Position (1..n).
//	iCurChild	IN		ID of the current child in the enumeration
//	fPopup		IN		is this menu item in a popup or on a menu bar?
//	riid		IN		what interface are we asking for on this item?
//	ppvItem		OUT		the pointer to the interface asked for.
//
// --------------------------------------------------------------------------
HRESULT CreateMenuItem(IAccessible* paccMenu, HWND hwnd, HMENU hMenu, 
	HMENU hSubMenu, long ItemID, long iCurChild, BOOL fPopup, REFIID riid, 
	void** ppvItem)
{
    HRESULT hr;
    CMenuItem* pmenuitem;

    InitPv(ppvItem);

    pmenuitem = new CMenuItem(paccMenu, hwnd, hMenu, hSubMenu, ItemID, iCurChild, fPopup);
    if (! pmenuitem)
        return(E_OUTOFMEMORY);

    hr = pmenuitem->QueryInterface(riid, ppvItem);
    if (!SUCCEEDED(hr))
        delete pmenuitem;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::CMenuItem()
//
//  We hang on to our parent object so we can forward methods up to him.
//  Therefore we must bump up the ref count.
//
// --------------------------------------------------------------------------
CMenuItem::CMenuItem(IAccessible* paccParent, HWND hwnd, HMENU hMenu,
    HMENU hSubMenu, long ItemID, long iCurChild, BOOL fPopup)
    : CAccessible( CLASS_MenuItemObject )
{
    m_hwnd = hwnd;
    m_hMenu = hMenu;
	m_hSubMenu = hSubMenu;
    m_ItemID = ItemID;
    m_idChildCur = iCurChild;
    m_fInAPopup = fPopup;

    m_paccParent = paccParent;
    paccParent->AddRef();
}



// --------------------------------------------------------------------------
//
//  CMenuItem::~CMenuItem()
//
//  We hung on to our parent, so we must release it on destruction.
//
// --------------------------------------------------------------------------
CMenuItem::~CMenuItem()
{
    m_paccParent->Release();
}


// --------------------------------------------------------------------------
//
//  SetupChildren()
//
//  CMenuItems have 1 child. That one child is either a CMenuPopupFrame or
//  a CMenuPopup (depending if the menu is visible).
//
// --------------------------------------------------------------------------
void CMenuItem::SetupChildren(void)
{
    m_cChildren = 1;
}

// --------------------------------------------------------------------------
//
//  CMenuItem::get_accParent()
//
// Pass it on back to the parent.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accParent(IDispatch** ppdispParent)
{
    InitPv(ppdispParent);

    return(m_paccParent->QueryInterface(IID_IDispatch, (void**)ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accChild()
//
//  The menu item's child is either a CMenuPopupFrame (if the popup window
//  is visible and belongs to this CMenuItem) or a CMenuPopup. This allows
//  someone to enumerate the commands whether or not the popup is visible.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
HWND    hwndSubMenu;
HRESULT hr;

    InitPv(ppdispChild);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);
	
    if (varChild.lVal != CHILDID_SELF)
    {
        // In order to create the accessible object representing the child,
        // we have to find the popup menu window.
        // Once we have found it, we check if it is visible. If so, then
        // our child is a CMenuPopupFrame, which we will create by
        // calling CreateMenuPopupWindow.
        // If the popup window is not visible, or if it does not belong
        // to this CMenuItem, then our child is a CMenuPopup, which we
        // will create by calling CreateMenuPopup.
        //
        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)ppdispChild));
        else
        {
            // this is where we create 'invisible' popups so apps can
            // walk down and see all of the commands (most, at least).
            // Since it is invisible, we have to tell it more about who
            // it's parent is.
            hr = CreateMenuPopupClient (NULL,0,IID_IDispatch,(void**)ppdispChild);
            if (SUCCEEDED (hr))
                ((CMenuPopup*)*ppdispChild)->SetParentInfo((IAccessible*)this,
                        m_hSubMenu,varChild.lVal);

            return(hr);
        }
    }

    return(E_INVALIDARG);
}


// --------------------------------------------------------------------------
//
//  CMenuItem::get_accName()
//
//  The name for the child (CMenuPopup or CMenuPopupFrame) is the same as
//  the name of the Parent/Self, so whether we are asked for id=self or
//  id = child (1), we return the same thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    return GetMenuItemName( this, m_hwnd, m_hMenu, m_ItemID, pszName );
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
MENUITEMINFO mi;

    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal == CHILDID_SELF)
    {
        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_TYPE | MIIM_SUBMENU;
        mi.cch = 0;
        mi.dwTypeData = 0;

        GetMenuItemInfo(m_hMenu, m_ItemID-1, TRUE, &mi);
        if (mi.fType & MFT_SEPARATOR)
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
    }
    else
    {
        pvarRole->lVal = ROLE_SYSTEM_MENUPOPUP;
    }
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accState(VARIANT varChild, VARIANT* pvarState)
{
HWND    hwndSubMenu;

    InitPvar(pvarState);

	if (!ValidateChild (&varChild))
        return(E_INVALIDARG);

	// We do this because sometimes we'll be asked for our own info,
	// and the caller will just call us item 0 (CHILDID_SELF) and we 
	// have to make sure when we call our parent to tell her who
	// we are (m_ItemID). 
	if (varChild.lVal == CHILDID_SELF)
    {
		varChild.lVal = m_ItemID;
        return(m_paccParent->get_accState(varChild, pvarState));
    }
    else
    {
        // If the popup (our only child) is not showing or it belongs to 
        // another menu item, set the state to invisible.
        // If it is showing and belongs to us, set the state to normal.
        
        // This starts by assuming that it is invisible, and clearing the
        // state if we find a visible menu that belongs to us.
        pvarState->vt = VT_I4;
        pvarState->lVal = 0 | STATE_SYSTEM_INVISIBLE;

        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
            pvarState->lVal = 0;
    }
    return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuItem::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
    {
        // Get menu item shortcut - use "Alt+" format for menu bars...
        BOOL fIsMenuBar = m_hwnd && ::GetMenu( m_hwnd ) == m_hMenu;

        return GetMenuItemShortcut( this, m_hwnd, m_hMenu, m_ItemID, fIsMenuBar, pszShortcut );
    }

    return S_FALSE;

}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accFocus()
//
//  If focus is us or our popup, great.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accFocus(VARIANT* pvarFocus)
{
HRESULT         hr;
HWND            hwndSubMenu;
IDispatch*      pdispChild;

    // Ask our parent who has the focus.  Is it us?
    hr = m_paccParent->get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr))
        return(hr);

    // No, so return nothing.
    if ((pvarFocus->vt != VT_I4) || (pvarFocus->lVal != m_ItemID))
    {
        VariantClear(pvarFocus);
        pvarFocus->vt = VT_EMPTY;
        return(S_FALSE);
    }

    // Is the currently active popup our child?
    // If so, then we should return an IDispatch to
    // the window frame object.
    hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
    if (hwndSubMenu)
    {
        hr = CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch,(void**)&pdispChild);

        if (!SUCCEEDED(hr))
            return (hr);
        pvarFocus->vt = VT_DISPATCH;
        pvarFocus->pdispVal = pdispChild;
        return (S_OK);
    }
    
    pvarFocus->lVal = 0;
    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenuItem::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

	if (!ValidateChild (&varChild))
        return(E_INVALIDARG);

	// We do this because sometimes we'll be asked for our own info,
	// and the caller will just call us item 0 (CHILDID_SELF) and we 
	// have to make sure when we call our parent to tell her who
	// we are (m_ItemID). 
    // But sometimes, we will be asked for info about our child - There 
    // is no default action for our child.
	if (varChild.lVal == CHILDID_SELF)
    {
		varChild.lVal = m_ItemID;
        return(m_paccParent->get_accDefaultAction(varChild, pszDefA));
    }
    return (E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accSelect()
//
//  We just let our parent take care of this for us. Tell her who we are by
//  setting varChild.lVal to our ItemID.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accSelect(long flagsSel, VARIANT varChild)
{
    if (!ValidateChild (&varChild) ||
        !ValidateSelFlags(flagsSel))
        return (E_INVALIDARG);

	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;
    return(m_paccParent->accSelect(flagsSel, varChild));
}

// --------------------------------------------------------------------------
//
//  CMenuItem::accLocation()
//
//  Sometimes we are asked for the location of a peer object. This is 
//  kinda screwy. This happens when we are asked to navigate next or prev,
//	and then let our parent navigate for us. The caller then starts thinking
//	we know about our peers. 
//  Since this is the only case where something like this happens, we'll
//	have to do some sort of hack. 
//  Problem is, when they ask for a child 0 (self) we are OK.
//	But when we are asked for child 1, is it the popup or peer 1?
//  I am going to assume that it is always the peer.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
	// we just call this to translate empty values - not going to 
	// check the return value.
	ValidateChild (&varChild);

	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;

    return(m_paccParent->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
HWND        hwndSubMenu;

	InitPvar(pvarEnd);

    if (!ValidateChild(&varStart))
        return (E_INVALIDARG);

    if (!ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir >= NAVDIR_FIRSTCHILD) // this means firstchild or lastchild
    {
        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
        {
            pvarEnd->vt = VT_DISPATCH;
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)&(pvarEnd->pdispVal)));
        }

        return(S_FALSE);
    }
    else
    {
		if (varStart.lVal == CHILDID_SELF)
			varStart.lVal = m_ItemID;
        return(m_paccParent->accNavigate(dwNavDir, varStart, pvarEnd));
    }
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT hr;
HWND    hwndSubMenu;
RECT    rc;
POINT   pt;

    InitPvar(pvarHit);

    hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
    if (hwndSubMenu)
    {
        // Is point in our popup menu window child?
        MyGetRect(hwndSubMenu, &rc, TRUE);

        pt.x = x;
        pt.y = y;

        if (PtInRect(&rc, pt))
        {
            // need to set the parent
            pvarHit->vt = VT_DISPATCH;
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)pvarHit->pdispVal));
        }
    }

    // Is point in us?
    hr = m_paccParent->accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/24/97, changed from !SUCCEEDED to !S_OK
    if ((hr != S_OK) || (pvarHit->vt == VT_EMPTY))
        return(hr);

	pvarHit->vt = VT_I4;
	pvarHit->lVal = CHILDID_SELF;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accDoDefaultAction()
//
//  We just let our parent take care of this for us. Tell her who we are by
//  setting varChild.lVal to our ItemID.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accDoDefaultAction(VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    Assert(varChild.vt == VT_I4);
	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;
    return(m_paccParent->accDoDefaultAction(varChild));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::Clone(IEnumVARIANT** ppenum)
{
    return(CreateMenuItem(m_paccParent, m_hwnd, m_hMenu, m_hSubMenu,m_ItemID, 
		m_idChildCur, FALSE, IID_IEnumVARIANT, (void**)ppenum));
}


STDMETHODIMP CMenuItem::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    if( dwIDChild != CHILDID_SELF )
    {
        // CMenuItems have 1 child - that one child is either a CMenuPopupFrame or
        // a CMenuPopup (depending if the menu is visible).
        // We're not going to support geting the IDs of these thourhg the parent,
        // a client should get the interface pointers to those objects themselves,
        // and ask them for their string.
        return E_INVALIDARG;
    }



    // Weird stuff alert:
    //
    // CMenuItem repesents a menu item that has an associated popup. (ie. it is
    // not a command leaf node) There are two options for representing this item:
    //
    //     as a child of its parent menu,
    // or
    //     as the parent (CHILDID_SELF) of its own submenu
    //
    // While the HWND-based controls use the latter option, here we are going for
    // the former - this keeps the menu item with its siblings, regardless of
    // whether they are menu items with popups, or leaf-node commands.
    // We can do this here since we do know what our parent HMENU is and what our
    // child id is in that parent menu.
    // HWND-based proxies as generally don't have this information available to them,
    // so the former option is not really an option for them.

    // This request is for the item itself - represent it as a child of
    // our parent menu

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    // Need to find pid of process that the menu belongs to. Can't use the
    // pid of the popup menu, since that's a shared/reused system window.
    // Instead, we assume that since the menu is present, it belongs to the
    // current foreground thread, which is what GetGUIThreadInfo(NULL) gets us.
    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo( NULL, & GuiThreadInfo ) )
    {
    	 CoTaskMemFree(pKeyData);
        return E_FAIL;
    }
    DWORD dwPid = 0;
    GetWindowThreadProcessId( GuiThreadInfo.hwndActive, & dwPid );
    if( dwPid == 0 )
    {
    	 CoTaskMemFree(pKeyData);
        return E_FAIL;
    }
    MakeHmenuKey( pKeyData, dwPid, m_hMenu, m_ItemID );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//  MENU POPUPS
//
/////////////////////////////////////////////////////////////////////////////



// --------------------------------------------------------------------------
//
//  CreateMenuPopupClient()
//
//  EXTERNAL for CreateClientObject...
//
// --------------------------------------------------------------------------
HRESULT CreateMenuPopupClient(HWND hwnd, long idChildCur,
    REFIID riid, void** ppvPopup)
{
    CMenuPopup*     ppopup;
    HRESULT         hr;

    ppopup = new CMenuPopup(hwnd, idChildCur);
    if (!ppopup)
        return(E_OUTOFMEMORY);

    hr = ppopup->QueryInterface(riid, ppvPopup);
    if (!SUCCEEDED(hr))
        delete ppopup;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::CMenuPopup()
//
// --------------------------------------------------------------------------
CMenuPopup::CMenuPopup(HWND hwnd, long idChildCur)
    : CClient( CLASS_MenuPopupClient )
{
    Initialize(hwnd, idChildCur);
    m_hMenu = NULL;
    m_ItemID = 0;
    m_hwndParent = NULL;
    m_fSonOfPopup = 0;
    m_fSysMenu = 0;

    // this only works if there is a window handle.
    if (hwnd)
    {
        m_hMenu = (HMENU)SendMessage (m_hwnd,MN_GETHMENU,0,0);
        // if we didn't get back an HMENU, that means that the window
        // is probably invisible. Don't try to set other values. 
        // SetupChildren will see this and set m_cChildren to 0.
        if (m_hMenu)
        {
	        m_ItemID = FindItemIDThatOwnsThisMenu (m_hMenu,&m_hwndParent,
                &m_fSonOfPopup,&m_fSysMenu);
        }
    }
}

// --------------------------------------------------------------------------
//
// The CMenuPopup objects need to know their parent when they are invisible, 
// so after one is created, the creator should call SetParentInfo.
//
// --------------------------------------------------------------------------
void CMenuPopup::SetParentInfo(IAccessible* paccParent,HMENU hMenu,long ItemID)
{
    m_paccParent = paccParent;
    m_hMenu = hMenu;
    m_ItemID= ItemID;
    if (paccParent)
        paccParent->AddRef();
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::~CMenuPopup()
//
// --------------------------------------------------------------------------
CMenuPopup::~CMenuPopup(void)
{
    if (m_paccParent)
        m_paccParent->Release();
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::SetupChildren()
//
// --------------------------------------------------------------------------
void CMenuPopup::SetupChildren(void)
{
    // we need to be able to set up our children whether the popup is 
    // displayed or not. So we have a m_hMenu variable, it just needs
    // to be set when the thing is made - It is either set by the 
    // constructor (if we are visible) or by the dude that called the create
    // function if we are invisible.
    // PROBLEM - sometimes CMenuPopups are created by a call to 
    // AccessibleObjectFromEvent, and the hwnd isn't always able to 
    // give us back a good m_hMenu. So we will just set m_cChildren to 0.
    if (m_hMenu)
    {
        m_cChildren = GetMenuItemCount(m_hMenu);

        if( m_cChildren == -1 )
        {
            // Paranoia in case we get an invalid HMENU
            m_cChildren = 0;
        }
    }
    else
        m_cChildren = 0;
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accParent()
//
//  The parent of a CMenuPopup is either a CMenuPopupFrame or a CMenuItem.
//  If the popup is visible, it will have an hwnd, and lots of other stuff
//  will also be set. If it is not visible, it will not have an hwnd.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accParent(IDispatch** ppdispParent)
{
    if (m_paccParent)
    {
        return (m_paccParent->QueryInterface(IID_IDispatch,(void**)ppdispParent));
    }
    else if (m_hwnd)
    {
        // try to create a parent for us...
        return (CreateMenuPopupWindow (m_hwnd,0,IID_IDispatch,(void**)ppdispParent));
    }
    else
        return (E_FAIL);
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accChild()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
HMENU	hSubMenu;

    InitPv(ppdispChild);

    if (!ValidateChild(&varChild) || varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

    //
    // Is this item a hierarchical?
    //
    Assert (m_hMenu);
	hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1);
    if (!hSubMenu)
        return(S_FALSE);

    //
    // Yes.
    //
	return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, hSubMenu,
		varChild.lVal,  0, FALSE, IID_IDispatch, (void**)ppdispChild));
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accName()
//
//  The name of the popup is the name of the item it hangs off of.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accName(VARIANT varChild, BSTR* pszName)
{
HWND            hwndOwner;
TCHAR           szClassName[50];
HRESULT         hr;
IAccessible*    paccParent;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        // If we popped up from a menu bar or as another popup,
		// then our name is the name of the thing that popped us
		// up. If we are a floating popup, then our name is...?
		//
        // We implement this by either:
        // 1. calling our parent object, OR
        // 2. creating a parent object on the fly that we can 
        //    ask the name of, OR
		// 3. Looking for the name of the owner window, OR
        // 4. Checking if we are the child of the start button. 
        // If all else fails, we'll just call ourselves "context menu".
        if (m_paccParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;
            return (m_paccParent->get_accName (varChild,pszName));
        }
        if (m_hwndParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;

            if (m_fSonOfPopup)
                hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else if (m_fSysMenu)
                hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else
                hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);

            if (SUCCEEDED(hr))
            {
                hr = paccParent->get_accName (varChild,pszName);
                paccParent->Release();
            }
            return (hr);
        }
        else
		{
			// Try to get the owner window and use that for a name
			// This doesn't seem to work on anything I have ever found,
            // but it should work if anything has an owner, so i'll
            //leav it in. If it starts breaking, just rip it out.
			if (m_hwnd)
			{
			IAccessible*	pacc;
			HRESULT			hr;

				hwndOwner = ::GetWindow (m_hwnd,GW_OWNER);
				hr = AccessibleObjectFromWindow (hwndOwner, OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
				if (SUCCEEDED(hr))
				{
					hr = pacc->get_accName(varChild,pszName);
                    pacc->Release();
					if (SUCCEEDED(hr))
                    {
						return (hr);
                    }
				}
			}

			// check if the start button has focus
			hwndOwner = MyGetFocus();
			if (InTheShell(hwndOwner, SHELL_TRAY))
			{
                GetClassName(hwndOwner,szClassName,ARRAYSIZE(szClassName));
                if (lstrcmp(szClassName,TEXT("Button")) == 0)
                {
                    return (HrCreateString(STR_STARTBUTTON,pszName));
                }
			}
			// at least return this for a name
            return (HrCreateString (STR_CONTEXT_MENU,pszName));
		} // end else we don't have m_paccparent && m_itemid
    } // end if childid_self
    else // not childid self, childid > 0
    {
        return GetMenuItemName( this, m_hwnd, m_hMenu, varChild.lVal, pszName );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accDescription(varChild, pszDesc));

    return(E_NOT_APPLICABLE);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal == CHILDID_SELF)
        pvarRole->lVal = ROLE_SYSTEM_MENUPOPUP;
    else
    {
        MENUITEMINFO mi;

        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_TYPE;
        mi.cch = 0;
        mi.dwTypeData = 0;

        if (GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi) &&
               (mi.fType & MFT_SEPARATOR))
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accState(varChild, pvarState));
    else
    {
        // GetMenuBarInfo fails if the menu isn't currently present.
        // We don't fail outright when this happens, since we still want
        // to collect other info using GetMenuItemInfo below.
        MENUBARINFO     mbi;
        if( MyGetMenuBarInfo(m_hwnd, OBJID_CLIENT, varChild.lVal, &mbi) )
        {
            if (mbi.fFocused)
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED;
            }
        }

        //
        // Get menu item flags.  NOTE:  Can't use GetMenuState().  It whacks
        // random stuff in for hierarchicals.
        //
        MENUITEMINFO    mi;
        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_STATE | MIIM_SUBMENU;

        if (!GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi))
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_FALSE);
        }

        if (mi.fState & MFS_GRAYED)
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (mi.fState & MFS_CHECKED)
            pvarState->lVal |= STATE_SYSTEM_CHECKED;

        if (mi.fState & MFS_DEFAULT)
            pvarState->lVal |= STATE_SYSTEM_DEFAULT;

        if (mi.hSubMenu)
            pvarState->lVal |= STATE_SYSTEM_HASPOPUP;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
        return CClient::get_accKeyboardShortcut(varChild, pszShortcut);

    // Get menu item shortcut. FALSE means don't use ALT+ form.
    return GetMenuItemShortcut( this, m_hwnd, m_hMenu, varChild.lVal, FALSE, pszShortcut );
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accFocus(VARIANT* pvarFocus)
{
GUITHREADINFO	GuiThreadInfo;
MENUITEMINFO	mii;
int				i;

	// set it to empty
    if (IsBadWritePtr(pvarFocus,sizeof(VARIANT*)))
        return (E_INVALIDARG);

    InitPvar(pvarFocus);

    //
    // Are we in menu mode?  If not, nothing.
    //
	if (!MyGetGUIThreadInfo (NULL,&GuiThreadInfo))
		return(S_FALSE);

	if (GuiThreadInfo.flags & GUI_INMENUMODE)
	{
		// do I have to loop through all of them to see which
		// one is hilited?? Looks like it...
		mii.cbSize = SIZEOF_MENUITEMINFO;
		mii.fMask = MIIM_STATE;

		SetupChildren();
		for (i=0;i < m_cChildren;i++)
		{
			GetMenuItemInfo (m_hMenu,i,TRUE,&mii);
			if (mii.fState & MFS_HILITE)
			{
				pvarFocus->vt = VT_I4;
				pvarFocus->lVal = i+1;
				return (S_OK);
			}
		}

		// I don't think this should happen
		return(S_FALSE);
	}

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accDefaultAction()
//
//  Popups have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
HMENU   hSubMenu;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);

    varChild.lVal--;

    // Is this item enabled?
    if (GetMenuState(m_hMenu, varChild.lVal, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);


    // Now check if this item has a submenu that is displayed.
    // If there is, the action is hide, if not, the action is show. 
    // If it doesn't have a submenu, the action is execute.
#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF ("null hmenu at 4\r\n");
        Assert (m_hMenu);
    }
#endif

    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal))
    {
        if (GetSubMenuWindow(hSubMenu))
            return(HrCreateString(STR_DROPDOWN_HIDE, pszDefA));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDefA));
    }
    else
        return(HrCreateString(STR_EXECUTE, pszDefA));
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accSelect()
//
//  We only accept TAKEFOCUS.  
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accSelect(long flagsSel, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(flagsSel))
        return E_INVALIDARG;

    if (flagsSel != SELFLAG_TAKEFOCUS)
        return E_NOT_APPLICABLE;

    return E_NOTIMPL;
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
MENUBARINFO mbi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (!MyGetMenuBarInfo(m_hwnd, OBJID_CLIENT, varChild.lVal, &mbi))
        return(S_FALSE);

    *pcyHeight = mbi.rcBar.bottom - mbi.rcBar.top;
    *pcxWidth = mbi.rcBar.right - mbi.rcBar.left;

    *pyTop = mbi.rcBar.top;
    *pxLeft = mbi.rcBar.left;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT hr;

    // first make sure we are pointing to our own client area
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    // now we can see which child is at this point.
    SetupChildren();

    if (m_cChildren)
    {
        POINT   pt;

        pt.x = x;
        pt.y = y;

        pvarHit->lVal = MenuItemFromPoint(m_hwnd, m_hMenu, pt) + 1;

        if (pvarHit->lVal)
        {
            IDispatch* pdispChild;

            pdispChild = NULL;
            get_accChild(*pvarHit, &pdispChild);
            if (pdispChild)
            {
                pvarHit->vt = VT_DISPATCH;
                pvarHit->pdispVal = pdispChild;
            }
        }
            
        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
long            lEnd = 0;
MENUITEMINFO    mi;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
	{
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
	}

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
        case NAVDIR_DOWN:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_UP:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
		// we should give the child object back!!
		// can't use getSubMenu here because it seems to ignore
		// separators??
		//hSubMenu = GetSubMenu (m_hMenu,lEnd-1);

        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_SUBMENU;
        mi.cch = 0;
        mi.dwTypeData = 0;
		GetMenuItemInfo (m_hMenu,lEnd-1,TRUE,&mi);
		if (mi.hSubMenu)
		{
			pvarEnd->vt=VT_DISPATCH;
			return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, mi.hSubMenu,
				lEnd,  0, FALSE, IID_IDispatch, (void**)&pvarEnd->pdispVal));
		}
		// just return VT_I4 if it does not have a submenu.
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accDoDefaultAction(VARIANT varChild)
{
RECT		rcLoc;
HRESULT		hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::accDoDefaultAction(varChild));

    // If disabled, fail
    if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

	hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	if (!SUCCEEDED (hr))
		return (hr);
	
	// this will check if WindowFromPoint at the click point is the same
	// as m_hwnd, and if not, it won't click. Cool!
	if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		return (S_OK);
	else
		return (E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::Clone(IEnumVARIANT **ppenum)
{
HRESULT hr;

    hr = CreateMenuPopupClient(m_hwnd, m_idChildCur, IID_IEnumVARIANT,
        (void**)ppenum);
    if (SUCCEEDED(hr))
        ((CMenuPopup*)*ppenum)->SetParentInfo((IAccessible*)this,m_hMenu,m_ItemID);
    return(hr);
}



STDMETHODIMP CMenuPopup::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    // Need to find pid of process that the menu belongs to. Can't use the
    // pid of the popup menu, since that's a shared/reused system window.
    // Instead, we assume that since the menu is present, it belongs to the
    // current foreground thread, which is what GetGUIThreadInfo(NULL) gets us.
    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo( NULL, & GuiThreadInfo ) )
    {
    	 CoTaskMemFree(pKeyData);
        return E_FAIL;
    }
    DWORD dwPid = 0;
    GetWindowThreadProcessId( GuiThreadInfo.hwndActive, & dwPid );
    if( dwPid == 0 )
        return E_FAIL;

    MakeHmenuKey( pKeyData, dwPid, m_hMenu, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}









// ==========================================================================
//
//  POPUP WINDOW FRAMES 
//
// ==========================================================================

// --------------------------------------------------------------------------
//
//  CreateMenuPopupWindow()
//
//  This creates a child object that represents the Window object for a 
//  popup menu. It has no members, but has one child (a cMenuPopup)
//
// --------------------------------------------------------------------------
HRESULT CreateMenuPopupWindow(HWND hwnd, long idChildCur, REFIID riid, void** ppvMenuPopupW)
{
CMenuPopupFrame*    pPopupFrame;
HRESULT             hr;

    InitPv(ppvMenuPopupW);

    pPopupFrame = new CMenuPopupFrame(hwnd,idChildCur);
    if (!pPopupFrame)
        return(E_OUTOFMEMORY);

    hr = pPopupFrame->QueryInterface(riid, ppvMenuPopupW);
    if (!SUCCEEDED(hr))
        delete pPopupFrame;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::CMenuPopupFrame()
//
// --------------------------------------------------------------------------
CMenuPopupFrame::CMenuPopupFrame(HWND hwnd,long idChildCur)
    : CWindow( CLASS_MenuPopupWindow )
{

    Initialize(hwnd, idChildCur);
    m_hMenu = NULL;
    m_ItemID = 0;
    m_hwndParent = NULL;
    m_fSonOfPopup = 0;
    m_fSysMenu = 0;

	m_hMenu = (HMENU)SendMessage (m_hwnd,MN_GETHMENU,0,0);
	m_ItemID = FindItemIDThatOwnsThisMenu (m_hMenu,&m_hwndParent,
        &m_fSonOfPopup,&m_fSysMenu);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::~CMenuPopupFrame()
//
// --------------------------------------------------------------------------
CMenuPopupFrame::~CMenuPopupFrame()
{
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::SetupChildren()
//
//  Frames have 1 child. That one child is the CMenuPopup.
//
// --------------------------------------------------------------------------
void CMenuPopupFrame::SetupChildren(void)
{
	m_cChildren = 1;
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accParent()
//
//  Parent of a popupmenuframe is the CMenuItem that created it (if any).
//  To create one of those we need the grandparent. So we will create the 
//  grandparent (either a CMenuPopup, or a CMenu) temporarily, then we will 
//  create our parent CMenuItem based on that.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accParent(IDispatch** ppdispParent)
{
IAccessible* paccGrandParent;
HRESULT      hr;
CMenu*       pMenu;
CMenuPopup*  pMenuPopup;

    InitPv(ppdispParent);

    if (m_fSonOfPopup)
    {
        hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenuPopup = (CMenuPopup*)paccGrandParent;
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenuPopup->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    else if (m_fSysMenu)
    {
        hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenu = (CMenu*)paccGrandParent;
            pMenu->SetupChildren();
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenu->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    else
    {
        hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenu = (CMenu*)paccGrandParent;
            pMenu->SetupChildren();
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenu->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    return (hr);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accChild()
//
//	What we want this do do is return (in ppdisp) an IDispatch pointer to 
//  the child specified by varChild. The 1 child of a CMenuPopupFrame is
//  a cMenuPopup.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
    InitPv(ppdisp);

    if (!ValidateChild(&varChild) || varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

    return (CreateMenuPopupClient(m_hwnd, 0,IID_IDispatch, (void**)ppdisp));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accName
//
//  Has very similar logic to CMenuPopup::get_accName
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accName(VARIANT varChild, BSTR* pszName)
{
HWND            hwndOwner;
TCHAR           szClassName[50];
HRESULT         hr;
IAccessible*    paccParent;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        // If we popped up from a menu bar or as another popup,
		// then our name is the name of the thing that popped us
		// up. If we are a floating popup, then our name is...?
		//
        // We implement this by either:
        // 1. creating a parent object on the fly that we can 
        //    ask the name of, OR
		// 2. Looking for the name of the owner window, OR
        // 3. Checking if we are the child of the start button. 
        // If all else fails, we'll just call ourselves "context menu".
        if (m_hwndParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;

            if (m_fSonOfPopup)
                hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else if (m_fSysMenu)
                hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else
                hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            if (SUCCEEDED(hr))
            {
                hr = paccParent->get_accName (varChild,pszName);
                paccParent->Release();
            }
            return (hr);
        }
        else
		{
			// Try to get the owner window and use that for a name
			// This doesn't seem to work on anything I have ever found,
            // but it should work if anything has an owner, so i'll
            //leave it in. If it starts breaking, just rip it out.
			if (m_hwnd)
			{
			IAccessible*	pacc;
			HRESULT			hr;

				hwndOwner = ::GetWindow (m_hwnd,GW_OWNER);
				hr = AccessibleObjectFromWindow (hwndOwner, OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
				if (SUCCEEDED(hr))
				{
					hr = pacc->get_accName(varChild,pszName);
                    pacc->Release();
					if (SUCCEEDED(hr))
						return (hr);
				}
			}
			// check if the start button has focus
			hwndOwner = MyGetFocus();
			if (InTheShell(hwndOwner, SHELL_TRAY))
			{
                GetClassName(hwndOwner,szClassName,ARRAYSIZE(szClassName));
                if (lstrcmp(szClassName,TEXT("Button")) == 0)
                    return (HrCreateString(STR_STARTBUTTON,pszName));
			}
			// at least return this for a name
            return (HrCreateString (STR_CONTEXT_MENU,pszName));
		} // end else we don't have m_paccparent && m_itemid
    } // end if childid_self
    else
    {
        // not asking for name of the menupopupframe itself. We do not support asking for
        // name of our child - have to talk to the child itself
        return (E_INVALIDARG);
    }

}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accHitTest()
//
//  We just need to return VARIANT with var.pDispVal set to be our one child, 
//  the CMenuPopup.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accHitTest(long x, long y, VARIANT* pvarHit)
{
IDispatch*  pdispChild;
HRESULT     hr;

    InitPvar(pvarHit);
    SetupChildren();

    pvarHit->vt = VT_I4;
    pvarHit->lVal = CHILDID_SELF;

    if (SendMessage(m_hwnd, WM_NCHITTEST, 0, MAKELONG(x, y)) == HTCLIENT)
    {
        hr = CreateMenuPopupClient (m_hwnd,0,IID_IDispatch,(void**)&pdispChild);
        if (SUCCEEDED (hr))
        {
            pvarHit->vt = VT_DISPATCH;
            pvarHit->pdispVal = pdispChild;
        }
        return(hr);
    }

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accFocus()
//
// This fills in pvarFocus with the child that has the focus.
// Since we only have one child, We'll return an IDispatch to that child.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accFocus(VARIANT* pvarFocus)
{
HRESULT     hr;
IDispatch*  pdispChild;

    InitPvar(pvarFocus);
    hr = CreateMenuPopupClient(m_hwnd, 0,IID_IDispatch, (void**)&pdispChild);
    if (!SUCCEEDED(hr))
        return (hr);

    pvarFocus->vt = VT_DISPATCH;
    pvarFocus->pdispVal = pdispChild;
    return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accLocation()
//
//  Location of Self and Child is the same.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(CWindow::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD || dwNavDir == NAVDIR_LASTCHILD)
    {
        pvarEnd->vt = VT_DISPATCH;
        return (CreateMenuPopupClient (m_hwnd,0,IID_IDispatch, (void**)&(pvarEnd->pdispVal)));
    }

    return (S_FALSE);
}
                                          
// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::Clone(IEnumVARIANT **ppenum)
{
    return (CreateMenuPopupWindow(m_hwnd, m_idChildCur, IID_IEnumVARIANT,
        (void**)ppenum));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::Next()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;

    // we only have one child, so we can only return it if m_idChildCur == 0
    if (m_idChildCur == 0)
    {
        cFetched++;
        m_idChildCur++;
        pvar->vt = VT_DISPATCH;
        CreateMenuPopupClient (m_hwnd,0,IID_IDispatch, (void**)&(pvar->pdispVal));
    }

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
// This is a private function used to get the window handle that contains
// a given hSubMenu.
//
// --------------------------------------------------------------------------

HWND GetSubMenuWindow (HMENU hSubMenuToFind)
{
HWND    hwndSubMenu;
BOOL    bFound;
HMENU   hSubMenuTemp;

    hwndSubMenu = FindWindow (TEXT("#32768"),NULL);
    if (hwndSubMenu == NULL)
        return (NULL);    // random error condition - shouldn't happen
    
    if (!IsWindowVisible(hwndSubMenu))
        return (NULL);

    bFound = FALSE;
    while (hwndSubMenu)
    {
        hSubMenuTemp = (HMENU)SendMessage (hwndSubMenu,MN_GETHMENU,0,0);
        if (hSubMenuTemp == hSubMenuToFind)
        {
            bFound = TRUE;
            break;
        }
        hwndSubMenu = FindWindowEx (NULL,hwndSubMenu,TEXT("#32768"),NULL);
    } // end while hwndSubMenu

    if (bFound)
    {
        return(hwndSubMenu);
    }
    return (NULL);
}



// --------------------------------------------------------------------------
// This looks at each item in the Active window's menu and any other menu 
// windows, until it finds one that has an hSubMenu that matches the hMenu 
// we are trying to find. It then returns the ID of that thing (1..n) and
// fills in the window handle of the owner, and whether that window is a top
// level window or a popup menu.
// --------------------------------------------------------------------------
long FindItemIDThatOwnsThisMenu (HMENU hMenuOwned,HWND* phwndOwner,
                                 BOOL* pfPopup,BOOL *pfSysMenu)
{
HWND            hwndMenu;
HMENU           hMenu;
int             cItems;
int             i;

    if (IsBadWritePtr(phwndOwner,sizeof(HWND*)) || 
        IsBadWritePtr (pfPopup,sizeof(BOOL*))   ||
        IsBadWritePtr (pfSysMenu,sizeof(BOOL*)))
        return 0;

    *pfPopup = FALSE;
    *pfSysMenu = FALSE;
    *phwndOwner = NULL;

    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo (NULL,&GuiThreadInfo) )
        return 0;
    
    // check if it is from the sys menu first
    MENUBARINFO     mbi;
    if( MyGetMenuBarInfo(GuiThreadInfo.hwndActive, OBJID_SYSMENU, 0, &mbi) 
        && mbi.hMenu != NULL )
    {
        hMenu = mbi.hMenu;

        if (GetSubMenu(hMenu,0) == hMenuOwned)
        {
            *pfSysMenu = TRUE;
            *pfPopup = FALSE;
            *phwndOwner = GuiThreadInfo.hwndActive;
            return (1);
        }
    }

    // if not from the sys menu, check the window's menu bar
    hMenu = GetMenu (GuiThreadInfo.hwndActive);
    if (hMenu)
    {
        cItems = GetMenuItemCount (hMenu);
        for (i=0;i<cItems;i++)
        {
#ifdef _DEBUG
            if (!hMenu)
            {
                //DBPRINTF ("null hmenu at 5\r\n");
                Assert (hMenu);
            }
#endif

            if (GetSubMenu(hMenu,i) == hMenuOwned)
            {
                *pfPopup = FALSE;
                *phwndOwner = GuiThreadInfo.hwndActive;
                return (i+1);
            }
        }
    }

	// Okay, it doesn't belong to the active window's menu bar, maybe
	// it belongs to a submenu of that...
    hwndMenu = FindWindow (TEXT("#32768"),NULL);
    while (hwndMenu)
    {
        hMenu = (HMENU)SendMessage (hwndMenu,MN_GETHMENU,0,0);
        if (hMenu)
        {
            cItems = GetMenuItemCount (hMenu);
            for (i=0;i<cItems;i++)
            {
                if (GetSubMenu(hMenu,i) == hMenuOwned)
			    {
                    *pfPopup = TRUE;
                    *phwndOwner = hwndMenu;
                    return (i+1);
                }
            }
        }
        hwndMenu = FindWindowEx (NULL,hwndMenu,TEXT("#32768"),NULL);
    } // end while hwndMenu
	
	// if we still haven't returned, then this menu is either a context
	// menu, or belongs to the start button
	return 0;
}



// --------------------------------------------------------------------------
//
//  INTERNAL
//  MyGetMenuString()
//
//  This tries to get the text of menu items.  If they are ownerdraw, this
//  will hack around in shell structures to get the text.
//
//  Parameters:
//  hwnd            IN  the hwnd that owns the menu 
//  hMenu           IN  the hMenu to talk to
//  id              IN  the ID of the item to get (1..n)
//  fShell          IN  TRUE if this is a shell owned menu - tells the function
//                      to hack into the shell's memory
//  lpszBuf         OUT gets filled in with the string
//  cchMax          IN  number of characters in lpszBuf
//  fAllowGenerated IN  If TRUE, generated names (eg. those for MDI items)
//                      are allowed.
//
//  Returns:
//  TRUE if string was filled in, FALSE otherwise
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  'Generated names' are menu item names that do not actually correspond
//  to text on the menu item - eg. "Close"/"Restore" for the MDI buttons.
//  Typically you do want this text if you are looking for the name, but you
//  do not want this text if you are looking to extract a shortcut key.
// --------------------------------------------------------------------------

BOOL MyGetMenuString( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, long id, 
                      LPTSTR lpszBuf, UINT cchMax, BOOL fAllowGenerated )
{
    --id;
    *lpszBuf = 0;

    MENUITEMINFO mii;
    mii.cbSize = SIZEOF_MENUITEMINFO;
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_DATA | MIIM_ID;
    mii.dwTypeData = NULL;
    mii.cch = 0;

    if (!GetMenuItemInfo(hMenu, id, TRUE, &mii))
        return FALSE;

    // Is this a separator?  If so, bail.
    if (mii.fType & MFT_SEPARATOR)
        return FALSE;

    // For MDI windows - the min/restore/close buttons of the child window are
    // actually menu items. Have to check for them here...
    if( fAllowGenerated && hwnd && GetMDIMenuString( hwnd, hMenu, id, lpszBuf, cchMax ) )
        return TRUE;

    // If it's owner-draw, check if it supports the the 'dwData is ptr to
    // MSAA data' workaround.
    if( ( mii.fType & MFT_OWNERDRAW )
        && TryMSAAMenuHack( pTheObj, hwnd, mii.dwItemData, lpszBuf, cchMax ) )
        return TRUE;

    // Try to get the text.
    //
    // GetMenuString does the right thing for Win95/NT close/min/max
    // system menu items - whereas mii.dwTypeData only contains a bitmap
    // number (apparently - although cchSize does give the character
    // count as though it were a string...)
    if (GetMenuString(hMenu, id, lpszBuf, cchMax, MF_BYPOSITION))
        return TRUE;

    // is this a shell owner menu item?
    // Check that (a) this is a shell menu, (b) it's ownerdraw, and
    // (c) it has non-0 ownerdraw itemdata,
    if ( InTheShell( hwnd, SHELL_PROCESS ) && ( mii.fType & MFT_OWNERDRAW ) && mii.dwItemData )
    {
        if( GetShellOwnerDrawMenu( hwnd, mii.dwItemData, lpszBuf, cchMax ) )
            return TRUE;
    }

    // We've tried everything, but didn't get any name...
    return FALSE;
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetShellOwnerDrawMenu
//
//  Pull text out of shell's internal data structs.
//  This is used by the SendTo menu. (Also used to be used by the old
//  pre-IE4 start menus, before they changed to being Toolbar32 based.)
//
//	Parameters:
//	hwnd	IN		hwnd of menu
//	dwItemData	IN	dwItemData from the menu
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL GetShellOwnerDrawMenu( HWND hwnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax )
{
    DWORD idProcess = 0;
    GetWindowThreadProcessId(hwnd, &idProcess);
    if (!idProcess)
        return FALSE;

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, idProcess);
    if (!hProcess)
        return FALSE;

    //
    // Try to read FILEMENUITEM's worth of stuff.
    //
    FILEMENUITEM  fmi;
    SIZE_T        cbRead;
    if (ReadProcessMemory(hProcess, (LPCVOID)dwItemData, &fmi, sizeof(fmi), &cbRead) &&
        (cbRead == sizeof(fmi)))
    {
        //
        // Is there a string pointer in here?
        //
        if (fmi.psz)
        {
            ReadProcessMemory(hProcess, fmi.psz, lpszBuf, cchMax, &cbRead);
            lpszBuf[cchMax-1] = 0;
        }
        else if (fmi.pidl)
        {
            ITEMIDLIST id;

            // No, we have to grovel inside of the PIDL
            if (ReadProcessMemory(hProcess, fmi.pidl, &id, sizeof(ITEMIDLIST), &cbRead) &&
                (cbRead == sizeof(id)))
            {
                id.cbTotal -= OFFSET_SZFRIENDLYNAME;
                cchMax = min((DWORD)id.cbTotal, cchMax);
                cchMax = max(cchMax, 1);

                ReadProcessMemory(hProcess, (LPBYTE)fmi.pidl + OFFSET_SZFRIENDLYNAME,
                    lpszBuf, cchMax, &cbRead);
                lpszBuf[cchMax-1] = 0;

                //
                // Are the last 4 characters ".lnk"? or ".pif"?
                // or .??? - we'll cut 'em all off.
                //
                cchMax = lstrlen(lpszBuf);
                if ((cchMax >= 4) && (lpszBuf[cchMax-4] == '.'))
                    lpszBuf[cchMax-4] = 0;
            }
        }
    }

    CloseHandle(hProcess);

    return *lpszBuf != 0;
}





// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIButtonIndex
//
//  Returns appropritate INDEX_TITLEBAR_nnn for the given menu item, if it
//  is really an MDI child button (restore/minimize/close).
//
//  Returns 0 otherwise.
//
// --------------------------------------------------------------------------


UINT GetMDIButtonIndex( HMENU hMenu, DWORD idPos )
{
    switch( GetMenuItemID( hMenu, idPos ) )
    {
        case SC_MINIMIZE:   return INDEX_TITLEBAR_MINBUTTON;
        case SC_RESTORE:    return INDEX_TITLEBAR_RESTOREBUTTON;
        case SC_CLOSE:      return INDEX_TITLEBAR_CLOSEBUTTON;
        default:            return 0; // INDEX_TITLEBAR_SELF
    }
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIChildMenuString
//
//  Check if this is a MDI menu - return strings for the document menu,
//  and the min/restore/close buttons
//
//	Parameters:
//	hmenu   IN	    handle of menu
//	id      IN	    0-based index of the menu item
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL GetMDIMenuString( HWND hwnd, HMENU hMenu, DWORD idPos, LPTSTR lpszBuf, UINT cchMax )
{
    // For MDI windows - the min/restore/close buttons of the child window are
    // actually owner-draw menu items. Have to check for them here...

    UINT iIndex = GetMDIButtonIndex( hMenu, idPos );
    if( iIndex )
    {
        return LoadString( hinstResDll, iIndex + STR_TITLEBAR_NAME, lpszBuf, cchMax ) != 0;
    }

    // Detect the document system menu by checking that it has a submenu
    // which contains the Restore item (GetMenuState returns -1 if not found...)
    // but which is not the actual system menu (since that also has a restore item).
    HMENU hSub = GetSubMenu( hMenu, idPos );
    if( hSub && GetMenuState( hSub, SC_RESTORE, MF_BYCOMMAND ) != -1
        && hSub != MyGetSystemMenu( hwnd ) )
    {
        return LoadString( hinstResDll, STR_DOCMENU_NAME, lpszBuf, cchMax ) != 0;
    }

    return FALSE;
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIMenuDescriptionString
//
//  Check if this is a MDI menu - return description strings for the document
//  menu, and the min/restore/close buttons
//
//	Parameters:
//	hmenu   IN	    handle of menu
//	idPos   IN	    0-based index of the menu item
//	pbstr   OUT     returns the description of the item
//
//	Returns:
//	TRUE if item is a MDI element and pbstr was set, FALSE otherwise.
// --------------------------------------------------------------------------

BOOL GetMDIMenuDescriptionString( HMENU hMenu, DWORD idPos, BSTR * pbstr )
{
    UINT iIndex = GetMDIButtonIndex( hMenu, idPos );
    if( iIndex )
    {
        return HrCreateString( iIndex + STR_TITLEBAR_DESCRIPTION, pbstr ) == S_OK;
    }
    else
    {
        return FALSE;
    }
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  TryMSAAMenuHack()
//
//  Checks if a menu supports the 'dwData is ptr to MSAA data' workaround.
//
//	Parameters:
//	pTheObj	IN		the hwnd that owns the menu (used to get window handle
//                  if hWnd is NULL)
//	hWnd	IN		hwnd of menu, NULL if not known (eg. invisible 'fake'
//                  popups)
//	dwItemData	IN	dwItemData from the menu
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL TryMSAAMenuHack( IAccessible *  pTheObj,
                      HWND           hWnd,
                      DWORD_PTR      dwItemData,
                      LPTSTR         lpszBuf,
                      UINT           cchMax )
{
    BOOL bGotIt = FALSE;

    if( ! hWnd )
    {
        // It's an invisible 'fake' popup menu (CPopuMenu created to expose
        // a HMENU, but no menu, and therefore no popup window, is currenly
        // visible).
        // Need a window handle so we can get the process id...
        if( WindowFromAccessibleObjectEx( pTheObj, & hWnd ) != S_OK || hWnd == NULL )
            return FALSE;
    }

    // ...now get process id...
    DWORD idProcess = 0;
    GetWindowThreadProcessId( hWnd, &idProcess );
    if( !idProcess )
        return FALSE;

    // Open that process so we can read its memory...
    HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, idProcess );
    if( hProcess )
    {
        // Treat dwItemData as an address, and try to read a
        // MSAAMENUINFO struct from there...
        MSAAMENUINFO menuinfo;
        SIZE_T cbRead;

        if( ReadProcessMemory( hProcess, (LPCVOID)dwItemData, (LPVOID) & menuinfo, sizeof( menuinfo ), &cbRead ) 
            && ( cbRead == sizeof( menuinfo ) ) )
        {

            // Check signature...
            if( menuinfo.dwMSAASignature == MSAA_MENU_SIG )
            {
                // Work out len of UNICODE string to copy (+1 for terminating NUL)
                DWORD copyLen = ( menuinfo.cchWText + 1 ) * sizeof( WCHAR );

                WCHAR * pAlloc = (LPWSTR) LocalAlloc( LPTR, copyLen );
                if( pAlloc )
                {

                    // Do the copy... also fail if we read less than expected, or terminating NUL missing...
                    if( ReadProcessMemory( hProcess, (LPCVOID)menuinfo.pszWText, pAlloc, copyLen, &cbRead ) 
                            && ( cbRead == copyLen )
                            && ( pAlloc[ menuinfo.cchWText ] == '\0' ) )
                    {

#ifdef UNICODE
						// Copy text to output buffer...
						if( cchMax > 0 )
						{
							UINT cchCopy = menuinfo.cchWText;
							if( cchCopy > cchMax - 1 )
								cchCopy = cchMax - 1; // -1 for terminating NUL
							memcpy( lpszBuf, pAlloc, cchCopy * sizeof( TCHAR ) );
							lpszBuf[ cchCopy ] = L'\0';
							bGotIt = TRUE;
						}
#else
                        // Convert (and copy) UNICODE to ANSI...
                        if( WideCharToMultiByte( CP_ACP, 0, pAlloc, -1, lpszBuf, cchMax, NULL, NULL ) != 0 )
                        {
                            bGotIt = TRUE;
                        }
#endif
                    }

                    LocalFree( pAlloc );
                } // pAlloc
            } // m_Signature
        } // ReadProcessMemory

        CloseHandle( hProcess );
    } // hProcess

    return bGotIt;
}






// --------------------------------------------------------------------------
//
//  WindowFromAccessibleObjectEx()
//
//  This walks UP the ancestor chain until we find something who responds to
//  IOleWindow().  Then we get the HWND from it.
//
//  This is effectively a local version of WindowFromAccessibleObject
//  This version doesn't stop till it runs out of objects, it gets a valid
//  hwnd. The non-ex version stops even if it getgs a NULL hwnd.
//  This allows us to navigate up through menupopups which have no hwnd
//  (return NULL), but which do have parents, which eventually leads us to
//  the owning hWnd.
//
// --------------------------------------------------------------------------
STDAPI WindowFromAccessibleObjectEx( IAccessible* pacc, HWND* phwnd )
{
IAccessible* paccT;
IOleWindow* polewnd;
IDispatch* pdispParent;
HRESULT     hr;

    //CWO: 12/4/96, Added check for NULL object
    //CWO: 12/13/96, Removed NULL check, replaced with IsBadReadPtr check (#10342)
    if (IsBadWritePtr(phwnd,sizeof(HWND*)) || IsBadReadPtr(pacc, sizeof(void*)))
        return (E_INVALIDARG);

    *phwnd = NULL;
    paccT = pacc;
    hr = S_OK;

    while (paccT && SUCCEEDED(hr))
    {
        polewnd = NULL;
        hr = paccT->QueryInterface(IID_IOleWindow, (void**)&polewnd);
        if (SUCCEEDED(hr) && polewnd)
        {
            hr = polewnd->GetWindow(phwnd);
            polewnd->Release();

            // Don't quit if we just got a NULL hwnd...
            // (this is the only change from WindowFromAccessibleObject(), which
            // just unconditionally returned when it got here...)
            if( *phwnd != NULL )
            {
                //
                // Release an interface we obtained on our own, but not the one
                // passed in.
                //
                if (paccT != pacc)
                {
                    paccT->Release();
                    paccT = NULL;
                }
                break;
            }
        }

        //
        // Get our parent.
        //
        pdispParent = NULL;
        hr = paccT->get_accParent(&pdispParent);

        //
        // Release an interface we obtained on our own, but not the one
        // passed in.
        //
        if (paccT != pacc)
        {
            paccT->Release();
        }

        paccT = NULL;

        if (SUCCEEDED(hr) && pdispParent)
        {
            hr = pdispParent->QueryInterface(IID_IAccessible, (void**)&paccT);
            pdispParent->Release();
        }
    }

    return(hr);
}






// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemName()
//
//  Returns the BSTR name for a menu item.
//
//  Parameters:
//  pTheObj         IN      the hwnd that owns the menu (used to get window
//                          handle if hWnd is NULL)
//  hWnd            IN      hwnd of menu, NULL if not known (eg. invisible
//                          'fake' popups)
//  hMenu           IN      Menu handle
//  id              IN      1-based id of the menu item (idChild)
//  pszName         OUT     returns string containing text for menu item.
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  Catches special cases " " and "-", which get mapped to "System" and
//  "Document window" respectively. These are the top-level and child window
//  system menus.
//
// --------------------------------------------------------------------------

HRESULT GetMenuItemName( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, BSTR * pszName )
{
    Assert( hMenu );

    TCHAR szItemName[256];

    // TRUE -> allow generated names (eg. for MDI buttons)
    if( MyGetMenuString( pTheObj, hwnd, hMenu, id, szItemName, ARRAYSIZE( szItemName ), TRUE ) )
    {
        StripMnemonic( szItemName );

        if( lstrcmp( szItemName, TEXT(" ") ) == 0 )
        {
            return HrCreateString( STR_SYSMENU_NAME, pszName ); // "System"
        }

        if( lstrcmp( szItemName, TEXT("-") ) == 0 )
        {
            return HrCreateString( STR_DOCMENU_NAME, pszName ); // "Document window"
        }

        *pszName = TCharSysAllocString(szItemName);
        if( ! *pszName )
            return E_OUTOFMEMORY;

        return S_OK;
    }
    else
    {
        *szItemName = '\0';
        *pszName = NULL;
        return S_FALSE;
    }
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemShortcut()
//
//  Returns the BSTR name for a menu shortcut.
//
//  Parameters:
//  pTheObj     IN      the hwnd that owns the menu (used to get window
//                      handle if hWnd is NULL)
//  hWnd        IN      hwnd of menu, NULL if not known (eg. invisible
//                      'fake' popups)
//  hMenu       IN      Menu handle
//  id          IN      1-based id of the menu item (idChild)
//  fIsMenuBar  IN      TRUE if the menu is a menubar; false for a popup
//  pszShortcut OUT     returns string containing kbshortcut for menu item.
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  Catches special case " " for system menu.
//  If fMenuBar is TRUE, uses "Alt+%c" form.
//
// --------------------------------------------------------------------------

HRESULT GetMenuItemShortcut( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id,
                             BOOL fIsMenuBar, BSTR * pszShortcut )
{
    TCHAR szHotKey[32];
    szHotKey[0] = GetMenuItemHotkey( pTheObj, hwnd, hMenu, id,
                                     GMIH_ALLOW_INITIAL | GMIH_ALLOW_SYS_SPACE );
    szHotKey[1] = 0;

    if ( szHotKey[0] == ' ' )
    {
        // Expand space character ' ' to the string "Space"
        szHotKey[ 0 ] = '\0';
        LoadString( hinstResDll, STR_SYSMENU_KEY, szHotKey, ARRAYSIZE( szHotKey ) );
    }

    // Fall through... This gives us c -> Alt+c if it was a single char,
    // or ' ' -> "Space" -> "Alt+Space" if it was a space char (for sys menu).

    if ( *szHotKey )
    {
        // If this is a menu bar, use the ALT+ form...
        if ( fIsMenuBar )
        {
            // Make a string of the form "Alt+ch".
            return HrMakeShortcut( szHotKey, pszShortcut );
        }
        else
        {
            // otherwise use just the key
            *pszShortcut = TCharSysAllocString( szHotKey );
            if ( ! *pszShortcut )
            {
                return E_OUTOFMEMORY;
            }

            return S_OK;
        }
    }

    *pszShortcut = NULL;
    return S_FALSE;
}





// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemHotkey()
//
//  Returns the TCHAR hotkey for a menu, if one exists.
//
//  Parameters:
//  pTheObj     IN      the hwnd that owns the menu (used to get window
//                      handle if hWnd is NULL)
//  hWnd        IN      hwnd of menu, NULL if not known (eg. invisible
//                      'fake' popups)
//  hMenu       IN      Menu handle
//  id          IN      1-based id of the menu item (idChild)
//  fOption     IN      Option flags - see below.
//
//  Returns:
//  Hotkey character of menu item, or '\0' if item has no hotkey.
//
//  Options:
//
//    GMIH_ALLOW_INITIAL
//      If set, allows the initial character of the menu item string to be
//      returned as the shortcut key (provided that no other items also use
//      that key as their menonic.)
//
//    GMIH_ALLOW_SYS_SPACE   = 0x02
//      If set, returns ' ' as the shortcut key of the system menu item.
//
// --------------------------------------------------------------------------

TCHAR GetMenuItemHotkey( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, DWORD fOptions )
{
    TCHAR szItemName[ 256 ];

    // FALSE -> disallow generated names (eg. for MDI buttons)
    if( ! MyGetMenuString( pTheObj, hwnd, hMenu, id, szItemName, ARRAYSIZE( szItemName ), FALSE ) )
    {
        return '\0';
    }

    // Check for menu name being " " - caller will want to treat this as a special hotkey of "Space".
    // (eg. givein "Alt+Space" as the entire hotkey string.)
    if( ( fOptions & GMIH_ALLOW_SYS_SPACE )
        && lstrcmp( szItemName, TEXT(" ") ) == 0 )
    {
        return ' ';
    }

    TCHAR ch = StripMnemonic( szItemName );

    // Can stop here if caller doesn't want initial chars (ie. &-mnemonics only)
    if( ! ( fOptions & GMIH_ALLOW_INITIAL ) )
    {
        return ch;
    }



    // Did we get a hot-key? If so, use it.
    if( ch != '\0' )
    {
        return ch;
    }

    // Try initial letter instead...
    LPTSTR pScanCh = szItemName;
    while( *pScanCh == ' ' )
    {
        *pScanCh++;
    }

    // Obscure USER32 menu thing - was used to right-justify Help items in a previous version?
    // Anyhow, USER skips over it to find the real first letter. So we do likewise...
    if( *pScanCh == '\x08' )
    {
        pScanCh++;
    }

    // Just in case there's no initial letter... (all spaces)
    if( *pScanCh == '\0' )
    {
        return '\0';
    }

    // Hotkeys are always returned as lowercase...
    CharLowerBuff( pScanCh, 1 );
    ch = *pScanCh;



    // Now compare against all other menu items - if one other item has this
    // initial letter as its mnemonic, then we can't use it for this one.
    // (Mnemonic takes precedence over initial letters)

    // GetMenuItemHotkey index is 1-based (ie. idChild), as is id, so also
    // using a 1-based index here.
    int cItems = GetMenuItemCount( hMenu );
    for( int iScan = 1 ; iScan <= cItems ; iScan++ )
    {
        // Don't compare against this item!
        if( iScan != id )
        {
            if( ch == GetMenuItemHotkey( pTheObj, hwnd, hMenu, iScan, NULL ) )
            {
                // Some other item has a mnemonic that is the same as this
                // item's initial char - it mnemonic takes precedence, so
                // this item has no kbshortcut.
                return '\0';
            }
        }
    }

    // No item use this item's initial char as a mnemonic - we're clear to use
    // it as this item's kbshortcut.
    return ch;
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  MyGetSystemMenu()
//
//  Returns the system HMENU for the given HWND.
//
//  Can't use the Win32 API GetSystemMenu, since that modifies the system
//  HMENU for the window.
//
// --------------------------------------------------------------------------

HMENU MyGetSystemMenu( HWND hwnd )
{
    MENUBARINFO mbi;
    if ( ! MyGetMenuBarInfo( hwnd, OBJID_SYSMENU, 0, &mbi ) )
    {
        return NULL;
    }
    // GetMenuBarInfo returns a menu containing the sysmenu as its only
    // submenu. Use GetSubMenu to access that...
    return GetSubMenu( mbi.hMenu, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\menu.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MENU.H
//
//  Menu bar Active Accessibility implementation
//
//	There are four classes here. 
//	CMenu is the class that knows how to deal with menu bar objects. These
//	have children that are CMenuItem objects, or just children (rare - 
//	this is when you have a command right on the menu bar).
//	CMenuItem is something that when you click on it opens a popup.
//	It has 1 child that is a CMenuPopupFrame.
//	CMenuPopupFrame is the HWND that pops up when you click on a CMenuItem. It
//	has 1 child, a CMenuPopup.
//  CMenuPopup objects represent the client area of a CMenuPopupFrame HWND.
//  It has children that are menu items (little m, little i), separators, and 
//	CMenuItems (when you have cascading menus).
//
//	This results in a heirarchy that looks like this:
//	menu bar
//		file menu item
//		edit menu item
//          edit menu popup frame (when droppped down)
//			    edit menu popup 
//				    cut menu item
//				    copy menu item
//      view menu item
//          view menu popup (invisible)
//              this menu item
//              that menu item
//      etc.
//
// -------------------------------------------------------------------------=

extern HRESULT CreateMenuBar(HWND hwnd, BOOL fSysMenu, LONG idCur, REFIID riid, void**ppvMenu);
extern HRESULT CreateMenuItem(IAccessible*, HWND, HMENU, HMENU, long, long, BOOL, REFIID, void**);

//
// This is the CMenuClass. It inherits from CAccessible directly since it is a child
// object of a CWindow object.
//
class CMenu : public CAccessible 
{
    public:
        // IAccessible
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT ** ppenum);

        /*CTOR*/            CMenu(HWND, BOOL, long);
        void                SetupChildren(void);
        HMENU               GetMenu(void) {return m_hMenu;}

        // IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );

    protected:
        BOOL                m_fSysMenu;		// TRUE if this is a system menu
        HMENU               m_hMenu;		// the menu handle
};

//
// This is the CMenuItem class. It inherits from CAccessible because it is
// a child of the CMenu object or the CMenuPopup object.
//
class CMenuItem : public CAccessible
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch** ppdispParent);
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
        STDMETHODIMP        get_accFocus(VARIANT* pvarFocus);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);

        STDMETHODIMP        accSelect(long flagsSel, VARIANT varChild);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long x, long y, VARIANT* pvarHit);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        /*CTOR*/            CMenuItem(IAccessible*, HWND, HMENU, HMENU, long, long, BOOL);
        /*DTOR*/            ~CMenuItem();
        void                SetupChildren(void);
        HMENU               GetMenu(void) {return m_hMenu;}

        // IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );
		
    protected:
        IAccessible*    m_paccParent;   // Parent menu object
		HMENU			m_hMenu;		// menu we are in
		HMENU			m_hSubMenu;		// hMenu of the popup!
        BOOL            m_fInAPopup;    // TRUE - this item is in a popup. False - in a menu bar
        long            m_ItemID;       // Item we are. This will be like 1..n
};

//
// This is the CMenuPopupFrame class. It inherits from the CWindow class
// because it is a thing that has an HWND. We have to override some of the
// methods because it is not a normal window at all.
// It will create a CMenuPopup inside itself as its only child.
//
class CMenuPopupFrame : public CWindow
{
    public:
        // IAccessible
        STDMETHODIMP    get_accParent(IDispatch ** ppdispParent);
        STDMETHODIMP    get_accChild (VARIANT, IDispatch**);
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP    accHitTest(long x, long y, VARIANT* pvarHit);
        STDMETHODIMP    get_accFocus(VARIANT* pvarFocus);
        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd);

        // IEnumVARIANT
        STDMETHODIMP    Clone(IEnumVARIANT **ppenum);
        STDMETHODIMP    Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched);

        /*CTOR*/        CMenuPopupFrame(HWND hwnd,long idChildCur);
        /*DTOR*/        ~CMenuPopupFrame(void);
        void            SetupChildren(void);

    protected:
        long            m_ItemID;       // What is the ID for the parent item that created us?
        HMENU           m_hMenu;        // what hmenu are we?
        HWND            m_hwndParent;   // what hwnd do we descend from?
        BOOL            m_fSonOfPopup;  // are we descended from a popup?
        BOOL            m_fSysMenu;     // are we descended from a sys menu?
};

//
// This is the CMenuPopup class. It inherits from the CClient class because
// it represents the client area of the popup window (HWND type window).
//
class CMenuPopup :  public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch** ppdispParent);
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        /*CTOR*/            CMenuPopup(HWND, long);
        /*DTOR*/            ~CMenuPopup(void);
        void                SetupChildren(void);
        void                SetParentInfo(IAccessible* paccParent,HMENU hMenu,long ItemID);
        HMENU               GetMenu(void) {return m_hMenu;}

		// IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );


    protected:
        long                m_ItemID;       // what is the id our parent gave us?
        HMENU               m_hMenu;        // what hmenu are we?
        HWND                m_hwndParent;   // what hwnd do we descend from?
        BOOL                m_fSonOfPopup;  // are we descended from a popup?
        BOOL                m_fSysMenu;     // are we descended from a sys menu?
        IAccessible*        m_paccParent;   // only set if we are invisible, so we know our parent
};

//
// Special system HBITMAP values
//
#define MENUHBM_SYSTEM      1
#define MENUHBM_RESTORE     2
#define MENUHBM_MINIMIZE    3
#define MENUHBM_BULLET      4
#define MENUHBM_CLOSE       5
#define MENUHBM_CLOSE_D     6
#define MENUHBM_MINIMIZE_D  7


// --------------------------------------------------------------------------
//
//  SHELL MENU ITEMS (ownerdraw hack-o-rama parsing)
//
//  The Start menu and other context menus that are ownerdraw in the shell
//  have been inaccessible up til now.
//
//  We are going to hack it and fix it.  If we come across an OWNERDRAW menu
//  item in a popup in the shell process, we will get the item data from
//  it and grovel it.  If there is a string pointer, great.  If not, we will
//  grovel the ITEMIDLIST to pull the string out of there.
//
//  NOTE:  Be careful, massive validation and maybe even try-except would 
//  not be a bad idea.
//
//  ALSO:  This needs to work on Win '95 and Nashville.
//
// --------------------------------------------------------------------------

typedef enum
{
    FMI_NULL            = 0x0000,
    FMI_MARKER          = 0x0001,
    FMI_FOLDER          = 0x0002,
    FMI_EXPAND          = 0x0004,
    FMI_EMPTY           = 0x0008,
    FMI_SEPARATOR       = 0x0010,
    FMI_DISABLED        = 0x0020,     // Enablingly Challenged ???
    FMI_ON_MENU         = 0x0040,
    FMI_IGNORE_PIDL     = 0x0080,
    FMI_FILESYSTEM      = 0x0100,
    FMI_MARGIN          = 0x0200,
    FMI_MAXTIPWIDTH     = 0x0400,
    FMI_TABSTOP         = 0x0800,
    FMI_DRAWFLAGS       = 0x1000,
} FILEMENUITEMFLAGS;


//
// In reality, this is a variable structure, with szFriendlyName null-termed
// followed by sz8.3Name null-termed.
//
typedef struct tagITEMIDLIST
{
    SHORT   cbTotal;
    BYTE    aID[12];
    TCHAR   szFriendlyName[1];
} ITEMIDLIST, *LPITEMIDLIST;


// sizeof(cbTotal) is 2 + sizeof(aID) is 12 
#define OFFSET_SZFRIENDLYNAME   14


//
// One of these per file menu.
//
typedef struct
{
    void *psf;                      // Shell Folder.
    HMENU hmenu;                    // Menu.
    LPITEMIDLIST pidlFolder;        // Pidl for the folder.
    DWORD hdpaFMI;                  // List of items (see below).
    UINT idItems;                   // Command.
    UINT fmf;                       // Header flags.
    UINT fFSFilter;                 // file system enum filter
    HBITMAP hbmp;                   // Background bitmap.
    UINT cxBmp;                     // Width of bitmap.
    UINT cyBmp;                     // Height of bitmap.
    UINT cxBmpGap;                  // Gap for bitmap.
    UINT yBmp;                      // Cached Y coord.
    COLORREF clrBkg;                // Background color.
    UINT cySel;                     // Prefered height of selection.
    DWORD pfncb;                    // Callback function.
} FILEMENUHEADER, *PFILEMENUHEADER;

//
// One of these for each file menu item.
//
typedef struct
{
    PFILEMENUHEADER pFMH;           // The header.
    int iImage;                     // Image index to use.
    FILEMENUITEMFLAGS Flags;        // Misc flags above.
    LPITEMIDLIST pidl;              // IDlist for item.
    LPTSTR psz;                     // Text when not using pidls.
} FILEMENUITEM, *PFILEMENUITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\oleacc.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  OLEACC
//
//  DllMain and other entry points.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "classmap.h"
#include "w95trace.h"
#include "memchk.h"
#include "fwd_macros.h"

#include "PropMgr_Client.h"


// Define this locally instead of #including "PropMgr_Impl", since that
// drags in lots of ATL goo.
void PropMgrImpl_Uninit();

//
// Shared Globals
//
// Note that these are only used when running on 9x; and are not even present
// on builds which are specifically for W2K.
//

#ifndef NTONLYBUILD
#pragma data_seg("Shared")
LONG        g_cProcessesMinus1 = -1;    // number of attached processes minus 1 (the Interlocked APIs don't work well with 0 as a base)
HANDLE      hheapShared = NULL;         // handle to the shared heap (Win95 only)
#pragma data_seg()
#pragma comment(linker, "/Section:Shared,RWS")
#endif // NTONLYBUILD


//
// Globals
//

HANDLE      g_hLoadedMutex;             // Useful mutex - by using oh.exe to look for this,
                                        // we can see who's loaded our .dll.
HINSTANCE   g_hinstDll;                 // instance of this library - nothing actually uses this at the moment.
HINSTANCE   hinstResDll;		        // instance of resource library
BOOL        fCreateDefObjs;             // running with new USER32?
BOOL        g_fInitedOleacc = FALSE;    // Set by InitOleacc()
#ifdef _X86_
BOOL        fWindows95;                 // running on Windows '95?
#endif // _X86_


//
// Forward decls...
//


//
// DLL rountines that we chain - we combine:
// * Core oleacc (only DllMan, reg and unreg)
// * RemoteProxyFactory6432
// * Proxy/Stubs fpr the PropMgr
//
extern "C" {
BOOL    WINAPI Oleacc_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI Oleacc_DllRegisterServer();
HRESULT WINAPI Oleacc_DllUnregisterServer();

BOOL    WINAPI ProxyStub_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI ProxyStub_DllRegisterServer();
HRESULT WINAPI ProxyStub_DllUnregisterServer();
HRESULT WINAPI ProxyStub_DllCanUnloadNow();
HRESULT WINAPI ProxyStub_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

BOOL    WINAPI ComATLMain_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI ComATLMain_DllRegisterServer();
HRESULT WINAPI ComATLMain_DllUnregisterServer();
HRESULT WINAPI ComATLMain_DllCanUnloadNow();
HRESULT WINAPI ComATLMain_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
};


// This one is called from DLLMain... (not safe to use LoadLibrary etc.)
static BOOL InitOleaccDLL( HINSTANCE hInstance );

// And this one is called in DLLMain when exiting...
static void UninitOleacc();


// This displays a "oleacc version xxxxxx loading/unloading from process xxxx" message
#ifdef _DEBUG
static void DisplayLoadUnloadString( LPCTSTR pszAction );
#endif // _DEBUG





// if this W2K and not ALPHA enable 64b/32b interoperability
#if defined(UNICODE) && !defined(_M_AXP64)
#define ENABLE6432_INTEROP
#endif


BOOL WINAPI DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved )
{
#ifdef _WIN64
    DBPRINTF(TEXT("******** Hello from 64-bit OLEACC! ******** \r\n"));
#else
    DBPRINTF(TEXT("******** Hello from 32-bit OLEACC! ******** \r\n"));
#endif
    if( ! Oleacc_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("Oleacc_DllMain FAILED\r\n"));
        return FALSE;
    }

	// Call the remote proxy factory for 64/32 bit interop DllMain
	// TODO Possible performance improvement:  only call ProxyFactoryDllMain if loaded by DLLHost32/64
    if( ! ComATLMain_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("ComATLMain_DllMain FAILED\r\n"));
        return FALSE;
    }

    if( ! ProxyStub_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("ProxyStub_DllMain FAILED\r\n"));
        return FALSE;
    }

    return TRUE;
}




//
// Note about what gets registered:
//
// Oleacc_DllRegisterServer regiters the main typelib - this registers the
// IAccessible interfaces, and sets them to use typelib marshalling.
//
// ProxyStub_DllRegisterServer re-registers the IAccessible interface, also
// registers the IAccProp* annotation interfaces, and sets all those
// interfaces to use proxy/stub marshalling, overwriting the previous
// typelib marshalling, if any.
//
// Oleacc's DLLMain calls Oleacc_DllRegisterServer, which again
// re-registers the interfaces, and sets IAccessible back to using
// typelib marshalling.
//
// Bottom line is that all the interfaces do get registered, though
// some may use typelib marshalling, some may use proxy/stub marshalling.
// Doesn't really matter which is used; both marshalling techniques
// have the same end result.
//
// 
//
// When unregistering, Oleacc_DllUnregisterServer calls the typelib
// unregistration function, which removes the entries for all the IAccessible
// interfaces.
//
// ProxyStub_DllUnregister tries to unregister all the IAccessible and IAccProp
// interfaces - it will successfully remove all those that exist, but on 9x,
// it will return an error hresult because some of those have already been
// unregistered by Oleacc_DllUnregisterServer. (W2K doesn't complain about
// this.) We can safely ignore this error.
//
//
// One possible alternative to all the above would be to just use the
// proxy/stub registration and marshalling, and remove the IAccessible
// typelib stuff completely. This would simplify this code, and simplify
// the data in the registry. However, the typelib approach was kept
// just in case there is some code or tool out there that expects to
// be able to find a typelib for IAccessible via the registry.
//
//
// (Note that the ComATL_* registers/unregisters the Win64 helper
// classes, and that always uses typelib marshalling - using the
// second typelib in oleacc.dll. See those functions for more info.)
//
// 
HRESULT WINAPI DllRegisterServer()
{
    HRESULT hrRet = Oleacc_DllRegisterServer();

    HRESULT hr = ComATLMain_DllRegisterServer();
    if( hrRet == S_OK )
        hrRet = hr;
    
    hr = ProxyStub_DllRegisterServer();
    if( hrRet == S_OK )
        hrRet = hr;

    return hrRet; 
}

HRESULT WINAPI DllUnregisterServer()
{
    HRESULT hrRet = Oleacc_DllUnregisterServer();

    HRESULT hr = ComATLMain_DllUnregisterServer();
    if( hrRet == S_OK )
        hrRet = hr;
    
    // We ignore the 'file not found' error returned by the proxy/stub unregistration
    // code. It tries to unreg all interfaces mentioned in oleacc.idl - but most of those
    // have already been unregd by Oleacc_DllUnregisterServer above. On 9x, it returns
    // this error, which we must ignore. (The w2k version doesn't return this error - 
    // it looks like it ignores it internally.)
    hr = ProxyStub_DllUnregisterServer();
    if( hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) && hrRet == S_OK )
        hrRet = hr;

    return hrRet;
}


HRESULT WINAPI DllCanUnloadNow()
{
    HRESULT hr = ComATLMain_DllCanUnloadNow();
    if( hr != S_OK )
        return hr;

    return ProxyStub_DllCanUnloadNow();
}



HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr = ComATLMain_DllGetClassObject(rclsid, riid, ppv);
    if( hr == S_OK )
        return hr;

    return ProxyStub_DllGetClassObject(rclsid, riid, ppv);
}










//
// DLLMain
//


BOOL WINAPI Oleacc_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID unused( pvReserved ) )
{
    if( dwReason == DLL_PROCESS_ATTACH )
    {
        // We don't need DLL_THREAD_XXX notifications - more efficient to not have them...
        DisableThreadLibraryCalls( hinst );

        if( ! InitOleaccDLL( hinst ) )
            return FALSE;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UninitOleacc();
    }

    return TRUE;
} 


//
//  Oleacc_DllRegisterServer
//

#define TYPELIB_MAJORVER    1
#define TYPELIB_MINORVER    1

HRESULT WINAPI Oleacc_DllRegisterServer()
{
	ITypeLib	*pTypeLib = NULL;
	HRESULT		hr;
    OLECHAR		wszOleAcc[] = L"oleacc.dll";

	hr = LoadTypeLib( wszOleAcc, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
		hr = RegisterTypeLib( pTypeLib, wszOleAcc, NULL );
		if ( FAILED(hr) )
			DBPRINTF (TEXT("OLEACC: DllRegisterServer could not register type library hr=%lX\r\n"),hr);
		pTypeLib->Release();
	}
	else
	{
		DBPRINTF (TEXT("OLEACC: DllRegisterServer could not load type library hr=%lX\r\n"),hr);
	}

    return S_OK;
}



HRESULT WINAPI Oleacc_DllUnregisterServer()
{
	// The major/minor typelib version number determine
	//	which regisered version of OLEACC.DLL will get
	//	unregistered.

	return UnRegisterTypeLib( LIBID_Accessibility, TYPELIB_MAJORVER, TYPELIB_MINORVER, 0, SYS_WIN32 );
}














// --------------------------------------------------------------------------
//
//  Stubs for the exported APIs.
//
//  The .def file references these (instead of referencing the exported APIs
//  directly) - and these currently just call through to the API code.
//  We can change these to pre/post process or jump elsewhere if necessary.
//
// --------------------------------------------------------------------------

#define FORWARD( ret, name, c, params ) /**/\
    extern "C" ret WINAPI EXTERNAL_ ## name AS_DECL( c, params )\
    {\
        if( ! g_fInitedOleacc )\
            InitOleacc();\
        return name AS_CALL( c, params );\
    }

#define FORWARD_VOID( name, c, params ) /**/\
    extern "C" VOID WINAPI EXTERNAL_ ## name AS_DECL( c, params )\
    {\
        if( ! g_fInitedOleacc )\
            InitOleacc();\
        name AS_CALL( c, params );\
    }


FORWARD( LRESULT,   LresultFromObject,          3,  ( REFIID, riid, WPARAM, wParam, LPUNKNOWN, punk ) )
FORWARD( HRESULT,   ObjectFromLresult,          4,  ( LRESULT, lResult, REFIID, riid, WPARAM, wParam, void**, ppvObject ) )
FORWARD( HRESULT,   WindowFromAccessibleObject, 2,  ( IAccessible *, ppAcc, HWND *, phwnd ) )
FORWARD( HRESULT,   AccessibleObjectFromWindow, 4,  ( HWND, hwnd, DWORD, dwId, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   AccessibleObjectFromEvent,  5,  ( HWND, hwnd, DWORD, dwId, DWORD, dwChildId, IAccessible **, ppacc, VARIANT *, pvarChild ) )
FORWARD( HRESULT,   AccessibleObjectFromPoint,  3,  ( POINT, ptScreen, IAccessible **, ppacc, VARIANT *, pvarChild ) )
FORWARD( HRESULT,   AccessibleChildren,         5,  ( IAccessible *, paccContainer, LONG, iChildStart, LONG, cChildren, VARIANT *, rgvarChildren, LONG *, pcObtained ) )
FORWARD( UINT,      GetRoleTextA,               3,  ( DWORD, lRole, LPSTR, lpszRole, UINT, cchRoleMax ) )
FORWARD( UINT,      GetRoleTextW,               3,  ( DWORD, lRole, LPWSTR, lpszRole, UINT, cchRoleMax ) )
FORWARD( UINT,      GetStateTextA,              3,  ( DWORD, lStateBit, LPSTR, lpszState, UINT, cchState ) )
FORWARD( UINT,      GetStateTextW,              3,  ( DWORD, lStateBit, LPWSTR, lpszState, UINT, cchState ) )
FORWARD( HRESULT,   CreateStdAccessibleObject,  4,  ( HWND, hwnd, LONG, idObject, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   CreateStdAccessibleProxyA,  5,  ( HWND, hwnd, LPCSTR, pClassName, LONG, idObject, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   CreateStdAccessibleProxyW,  5,  ( HWND, hwnd, LPCWSTR, pClassName, LONG, idObject, REFIID, riid, void **, ppvObject ) )

FORWARD_VOID(       GetOleaccVersionInfo,       2,  ( DWORD *, pVer, DWORD *, pBuild ) )





//
//  InitOleaccDLL
//
//  Called from DLLMain - only do bare minimum init here - leave proper initing
//  to InitOleacc(), which is called the first time one of the APIs is called.
//
//  Since this is called from DLLMain, we can't use LoadLibrary() (or anything
//  that uses that) here. See the docs on DLLMain for additional restrictions.
//
//  Anything that can affect the success of this DLL loading/unloading should
//  also go here.
//
static
BOOL InitOleaccDLL( HINSTANCE hInstance )
{

    g_hLoadedMutex = CreateMutex(NULL,NULL,__TEXT("oleacc-msaa-loaded"));
    
    
    g_hinstDll = hInstance;

    // check platform version information
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    // refuse to run on Win32s
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32s)
        return FALSE;

#ifdef _X86_
    fWindows95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
#endif // _X86_

	// Load the resource-only DLL. We're not supposed to use regular
    // LoadLibary from within DLLMain, but LoadLibraryEx is safe,
    // since it only maps the file, and doesn't exec any code (that
    // lib's DLLMain).
	hinstResDll = LoadLibraryEx( TEXT("OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
	if( ! hinstResDll )
	{
		// Refuse to load if oleaccrc isn't present
		return FALSE;
	}


    // Use the counter g_cProcessesMinus1 to figure out if this is the 
    // first time this DLL is loaded. If so, do any necessary once-off
    // setup - eg. setting up values in the (9x-only) shared segment.

    // InterlockedIncrement() and Decrement() return 1 if the result is 
    // positive, 0 if  zero, and -1 if negative.  Therefore, the only
    // way to use them practically is to start with a counter at -1.  
    // Then incrementing from -1 to 0, the first time, will give you
    // a unique value of 0.  And decrementing the last time from 0 to -1
    // will give you a unique value of -1.

#ifndef NTONLYBUILD
#ifdef _X86_
    if( InterlockedIncrement( & g_cProcessesMinus1 ) == 0 )
    {
        // if on Win95, create a shared heap to use when
        // communicating with controls in other processes
        if( fWindows95 )
        {
            hheapShared = HeapCreate( HEAP_SHARED, 0, 0 );
            if( hheapShared == NULL )
                return FALSE;
        }
    }
#endif // _X86_
#endif // NTONLYBUILD


    return TRUE;
}



//
//  InitOleacc
//
//  Called when any of our APIs is called for the first time. Proper initialization
//  happens here.  Also called in DllGetClassObject.
//
BOOL InitOleacc()
{
    if (g_fInitedOleacc)
        return TRUE;

    g_fInitedOleacc = TRUE;

    // set the flag that causes proxies to work.
    fCreateDefObjs = TRUE;

    // Init any GetProcAddress'd imports
    InitImports();


#ifdef _DEBUG

	// Initialize the new/delete checker...
	InitMemChk();

    DisplayLoadUnloadString( TEXT("loading") );

#ifndef NTONLYBUILD

    // On first load, show dialog with names of any imports not found...
    if( g_cProcessesMinus1 == 0 )
    {
        TCHAR szErrorMsg[1024];
        lstrcpy( szErrorMsg,TEXT("WARNING: the following functions were not found:\r\n") );

        LPTSTR pEnd = szErrorMsg + lstrlen( szErrorMsg );
        ReportMissingImports( pEnd );

        if( *pEnd )
        {
            MessageBeep( MB_ICONEXCLAMATION );
            MessageBox( NULL, szErrorMsg, TEXT("OLEACC.DLL"), MB_OK | MB_ICONEXCLAMATION );
			DBPRINTF( szErrorMsg );
        }
    }

#endif // NTONLYBUILD

#endif // _DEBUG


    // Everything that follows is done for every process attach.

    // do a LoadLibrary of OLEAUT32.DLL to ensure that it stays
    // loaded in every process that OLEACC is attched to.
    // There is a slight chance of a crash. From Paul Vick:
    // The problem occurs when oleaut32.dll is loaded into a process, 
    // used, unloaded and then loaded again. When you try to use 
    // oleaut32.dll in this case, you crash because of a problem 
    // manging state between us (oleaut32) and OLE. What happens is that when 
    // oleaut32.dll is loaded, we register some state with OLE so 
    // we are notified when OLE is uninitialized. In some cases 
    // (esp. multithreading), we are not able to clean up this 
    // state when were unloaded. When you reload oleaut32.dll, 
    // we try to set the state in OLE again and OLE tries to free 
    // the old (invalid) state, causing a crash later on.
    LoadLibrary( TEXT("OLEAUT32.DLL") );

    InitWindowClasses();

    // Since Office 97 can mess up the registration, 
    // we'll call our self-registration function.
    // may be slight perf hit on load, but not that big a deal,
    // and this way we know we are always correctly registered..
    Oleacc_DllRegisterServer();

    // Initialize the property/annotation client
    PropMgrClient_Init();

    return TRUE;
}



//
//  UninitOleacc
//
//  Called on DLL Detach time from DLLMain. Any necessary cleanup happens here.
//
static
void UninitOleacc()
{
    PropMgrImpl_Uninit();

    PropMgrClient_Uninit();

	// Release the resource DLL. Usually FreeLibrary isn't safe, but it's OK
    // here since this is a resource-only DLL that was loaded _AS_DATAFILE.
	if( hinstResDll )
		FreeLibrary( hinstResDll );

#ifdef _DEBUG
	// This reports the number of outstanding delete's, if any...
	UninitMemChk();
    DisplayLoadUnloadString( TEXT("unloading") );
#endif // _DEBUG


#ifndef NTONLYBUILD
    // stuff that needs to be cleaned up on the last detach - clean
    // up stuff in the shared data segment.
    if (InterlockedDecrement(&g_cProcessesMinus1) == -1)
    {
#ifdef _X86_
        if (fWindows95)
        {
            if (hheapShared)
                HeapDestroy(hheapShared);
            hheapShared = NULL;
        }
#endif // _X86_
		UnInitWindowClasses();
    }
#endif // NTONLYBUILD

    if( g_hLoadedMutex )
        CloseHandle( g_hLoadedMutex );
}





#ifdef _DEBUG

void DisplayLoadUnloadString( LPCTSTR pszAction )
{
    TCHAR szModName[255];
    TCHAR szVer[1024] = TEXT("???");

	// Output to debug terminal - oleacc was attached to process x,
	// show which oleacc version is running, what directory it was
	// loaded from, etc.

    // NULL -> get application's name (not oleacc)
    MyGetModuleFileName( NULL, szModName, ARRAYSIZE( szModName ) );
    DBPRINTF( TEXT("'%s' is %s "),szModName, pszAction );

    MyGetModuleFileName( g_hinstDll, szModName, ARRAYSIZE( szModName ) );

    DWORD dwUseless;
    DWORD dwSize = GetFileVersionInfoSize( szModName, & dwUseless );
    if( dwSize )
    {
        LPVOID lpVersionData = LocalAlloc( LPTR, (UINT) dwSize );
        if( GetFileVersionInfo( szModName, dwUseless, dwSize, lpVersionData ) )
        {
            VS_FIXEDFILEINFO * lpVersionInfo;
            DWORD dwBytes;
            VerQueryValue( lpVersionData, TEXT("\\"), (void**)&lpVersionInfo, (UINT*)&dwBytes );
            wsprintf( szVer, TEXT("%d.%d.%d.%d"), HIWORD( lpVersionInfo->dwFileVersionMS ),
                                                  LOWORD( lpVersionInfo->dwFileVersionMS ),
                                                  HIWORD( lpVersionInfo->dwFileVersionLS ),
                                                  LOWORD( lpVersionInfo->dwFileVersionLS ) );
        }
		LocalFree( (HLOCAL) lpVersionData );
    }

	DBPRINTF( TEXT("%s version %s\r\n"), szModName, szVer );
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\progress.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PROGRESS.CPP
//
//  Wrapper for COMCTL32's progress bar
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "progress.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>



// --------------------------------------------------------------------------
//
//  CreateProgressBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateProgressBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvProgress)
{
    CProgressBar*   pprogress;
    HRESULT         hr;

    InitPv(ppvProgress);

    pprogress = new CProgressBar(hwnd, idChildCur);
    if (!pprogress)
        return(E_OUTOFMEMORY);

    hr = pprogress->QueryInterface(riid, ppvProgress);
    if (!SUCCEEDED(hr))
        delete pprogress;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  CProgressBar::CProgressBar()
//
// --------------------------------------------------------------------------
CProgressBar::CProgressBar(HWND hwnd, long idChildCur)
    : CClient( CLASS_ProgressBarClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CProgressBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CProgressBar::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_PROGRESSBAR;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CProgressBar::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CProgressBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    LONG    lCur;
    LONG    lMin;
    LONG    lMax;
    TCHAR   szPercentage[16];
    TCHAR   szFormat[8];

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The value of the progress bar is the current percent complete.  This is
    // cur pos - low pos / high pos - low pos.
    //

    //
    // We can now get the range and the position without changing them,
    // Thank you CheeChew!
    //
    lCur = SendMessageINT(m_hwnd, PBM_GETPOS, 0, 0);
    lMin = SendMessageINT(m_hwnd, PBM_GETRANGE, TRUE, 0);
    lMax = SendMessageINT(m_hwnd, PBM_GETRANGE, FALSE, 0);

    //
    // Don't want to divide by zero.
    //
    if (lMin == lMax)
        lCur = 100;
    else
    {
        //
        // Convert to a percentage.
        //
        lCur = max(lCur, lMin);
        lCur = min(lMax, lCur);
        
        lCur = (100 * (lCur - lMin)) / (lMax - lMin);
    }

    // Make a string
    LoadString(hinstResDll, STR_PERCENTAGE_FORMAT, szFormat, ARRAYSIZE(szFormat));
    wsprintf(szPercentage, szFormat, lCur);

    *pszValue = TCharSysAllocString(szPercentage);
    if (! *pszValue)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\oleacc_p.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  oleacc_p
//
//  Constants, Definitions, Types, and Classes private to the OLEACC
//  implementation. This header file is part of the OLEACC project.
//  OLEACC.H (included here) is machine-generated from OLEACC.IDL via
//  the MIDL compiler.
//
// --------------------------------------------------------------------------


#define INC_OLE2

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional

#include <windows.h>
#include <windowsx.h>

#if (_WIN32_WINNT < 0x0403)		// on Win95 compile, we need stuff in winable.h and userole.h,
#include <winable.h>			// but for NT build, this is included in winuserp.h
#include <userole.h>			// TODO? Change win95 to be more like NT to keep in ssync 
#else							// more easily!
#include <winuserp.h>
#endif

#include <limits.h>


#include "types6432.h"

#include "com_external.h" // this includes oleacc.h, since internal.idl includes oleacc.idl


#include "debug.h"
#include "w95trace.h"   // eventually deprecate this in favor of debug.h

#include "strtable.h"

#include "imports.h"

#include "util.h"
#include "accutil.h"

#include "classinfo.h"


// If this is being built as UNICODE, then assume that this build is NT-Only
// (eg. buildlab); so omit all 9x-specific code.
// (If some version of 9x ever supports Unicode, we may want to change how
// this gets defined.)
#ifdef UNICODE
#define NTONLYBUILD
#endif



//
// Constants
//

#define HEAP_SHARED     0x04000000      // Win95 only
#define HEAP_GLOBAL     0x80000000      // Win95 only


// Should we return DISP_E_MEMBERNOTFOUND explicitly instead of this?
// It's confusing because someone reading the code won't know that
// E_NOT_APPLICABLE is a local define, not a real code...
#define E_NOT_APPLICABLE            DISP_E_MEMBERNOTFOUND



//
// Handy #define's
//

#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))

#define unused( param )

// TODO - replace this style with the proper version above.
#define UNUSED(param)   (param)




//
// Variables
//
extern HINSTANCE	hinstResDll;	// instance of the resource library
#ifdef _X86_ 
extern HANDLE       hheapShared;    // handle to the shared heap (Windows '95 only)
extern BOOL         fWindows95;     // running on Windows '95?
#endif // _X86_
extern BOOL         fCreateDefObjs; // running with new USER32?


// These all live in memchk.cpp
// SharedAlloc ZEROES OUT THE ALLOCATED MEMORY - we rely on this for class member initialization.
LPVOID   SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle);
VOID     SharedFree(LPVOID lpv,HANDLE hProcess);
BOOL     SharedRead(LPVOID lpvSharedSource,LPVOID lpvDest,DWORD cbSize,HANDLE hProcess);
BOOL     SharedWrite(LPVOID lpvSource,LPVOID lpvSharedDest,DWORD cbSize,HANDLE hProcess);

// Make sure this function gets called before using oleacc (can be called multiple times)
BOOL     InitOleacc();



// Bit manipultation - a bit more readable than all those |'s and &'s and ~'s and <<'s...
//
// iBit is an index (0 for least significant bit, 1 for second bit, and so on), not a mask.

template <class T>
inline void SetBit( T * pval, int iBit )
{
    *pval |= ( (T)1 << iBit );
}

template <class T>
inline void ClearBit( T * pval, int iBit )
{
    *pval &= ~ ( (T)1 << iBit );
}

template <class T>
inline BOOL IsBitSet( T val, int iBit )
{
    return  val & ( (T)1 << iBit );
}


// Sizes...
//
// Some structs have grown between releases. Typically APIs from later
// releases will accept the previous smaller sizes; but the earlier
// APIs will not accept the new larger sizes.
// So, instead of using sizeof(...), we use this define. This takes
// as an additional argument the last used field in the struct, and
// evalueates to the size of the struct up to and including that field.
//
// We currently use this on an as-needed basis, instead of using it
// everywhere.
//
// Notable structs that got bigger:
// LVITEM - in comctlV6
// TTTOOLINFO - in comctlV6
// MENUITEMINFO - in Win2K
//
// This is based on the CCSIZEOF_STRUCT macro in commctrl.h.
// It's similar to the classic 'offsetof' macro, but it also adds in the
// size of the last field.

#define SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))


#define SIZEOF_TOOLINFO     SIZEOF_STRUCT( TOOLINFO, lParam )

#if !defined(_WIN64)
#define SIZEOF_MENUITEMINFO SIZEOF_STRUCT( MENUITEMINFO, cch )
#else
// Win64 only accepts the full-sized struct, not any earlier smaller versions.
#define SIZEOF_MENUITEMINFO sizeof( MENUITEMINFO )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\outline.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  OUTLINE.H
//
//  Knows how to talk to COMCTL32's TreeView control.
//
//  NOTE:  The VALUE is the indent level.  This lets us treat the children
//  like peers (otherwise, the elements of a node would be children but not
//  contained, really weird).
//
//  NOTE:  The child id is the HTREEITEM.  There is no index support for
//  treeview.  Hence we must do our own validation and IEnumVARIANT handling.
//
// --------------------------------------------------------------------------


class COutlineView32 :  public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Next(ULONG, VARIANT*, ULONG*);
        STDMETHODIMP        Skip(ULONG);
        STDMETHODIMP        Reset(void);

        
        BOOL        ValidateChild(VARIANT*);
        void        SetupChildren(void);
        COutlineView32(HWND, long);

    private:
        HTREEITEM   NextLogicalItem(HTREEITEM);
        HTREEITEM   PrevLogicalItem(HTREEITEM);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\outline.cpp ===
// --------------------------------------------------------------------------
//
//  OUTLINE.CPP
//
//  Wrapper for COMCTL32's treeview control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "RemoteProxy6432.h"
#include "propmgr_util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
//#define NOLISTVIEW            // INDEXTOSTATEIMAGEMASK needs LISTVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include "w95trace.h"

#include "outline.h"

struct MSAASTATEIMAGEMAPENT
{
    DWORD   dwRole;
    DWORD   dwState;
};


enum
{
    TV_IMGIDX_Image,
    TV_IMGIDX_State,
    TV_IMGIDX_Overlay,
    TV_IMGIDX_COUNT
};

BOOL TVGetImageIndex( HWND hwnd, HTREEITEM id, int aKeys[ TV_IMGIDX_COUNT ] );


extern "C" {
BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole );
BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState );
BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole );
}


// These convert between the DWORD childIDs and HTREEITEMS.
//
// Pre-win64, HTREEITEMS were cast to DWORDs, but that doesn't work on
// Win64 since HTREEITEMS are pointers, and no longer fit into a plain
// DWORD. Instead, the treeview supplies messages to map between
// an internal DWORD id and HTREEITEMS; these functions wrap that
// functionality.

HTREEITEM TVItemFromChildID( HWND hwnd, DWORD idChild );

DWORD ChildIDFromTVItem( HWND hwnd, HTREEITEM htvi );




// Template-based shared read/write/alloc
//
// Notes:
//
//   Read/Write each have two versions; one reads/writes a single item,
//   the other allows a count to be specified. Count specifies number
//   of items, not the number of bytes (unless the type is actually byte!).
//
//   Order or arguments is ( dest, souce ) - this is consistent with memcpy,
//   strcpy and regular assignments (dest = source).
//
//   In TSharedWrite, the source arg is an actual value, not a pointer to one.
//   (This avoids having to use a dummy variable to contain the value you want
//   to use.)

template< typename T >
BOOL TSharedWrite( T * pRemote, const T & Local, HANDLE hProcess )
{
    return SharedWrite( const_cast< T * >( & Local ), pRemote, sizeof( T ), hProcess );
}

template< typename T >
BOOL TSharedRead( T * pLocal, const T * pRemote, HANDLE hProcess )
{
    return SharedRead( const_cast< T * >( pRemote ), pLocal, sizeof( T ), hProcess );
}

template< typename T >
BOOL TSharedRead( T * pLocal, const T * pRemote, int count, HANDLE hProcess )
{
    return SharedRead( const_cast< T * >( pRemote ), pLocal, sizeof( T ) * count, hProcess );
}

template< typename T >
T * TSharedAlloc( HWND hwnd, HANDLE * pProcessHandle )
{
    return (T *) SharedAlloc( sizeof( T ), hwnd, pProcessHandle );
}

template< typename T >
T * TSharedAllocExtra( HWND hwnd, HANDLE * pProcessHandle, UINT cbExtra )
{
    return (T *) SharedAlloc( sizeof( T ) + cbExtra, hwnd, pProcessHandle );
}





#define MAX_NAME_SIZE   255

// these are in a newer version of comctl.h
#ifndef TVM_GETITEMSTATE

#define TVM_GETITEMSTATE        (TV_FIRST + 39)

#define TreeView_GetItemState(hwndTV, hti, mask) \
   (UINT)SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)hti, (LPARAM)mask)

#define TreeView_GetCheckState(hwndTV, hti) \
   ((((UINT)(SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)hti, TVIS_STATEIMAGEMASK))) >> 12) -1)

#endif // ifndef TVM_GETITEMSTATE


// --------------------------------------------------------------------------
//
//  CreateTreeViewClient()
//
// --------------------------------------------------------------------------
HRESULT CreateTreeViewClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvTreeView)
{
    COutlineView32 * poutline;
    HRESULT         hr;

    InitPv(ppvTreeView);

    poutline = new COutlineView32(hwnd, idChildCur);
    if (!poutline)
        return(E_OUTOFMEMORY);

    hr = poutline->QueryInterface(riid, ppvTreeView);
    if (!SUCCEEDED(hr))
        delete poutline;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::COutlineView32()
//
// --------------------------------------------------------------------------
COutlineView32::COutlineView32(HWND hwnd, long idChildCur)
    : CClient( CLASS_TreeViewClient )
{
    m_fUseLabel = TRUE;
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::SetupChildren()
//
// --------------------------------------------------------------------------
void COutlineView32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, TVM_GETCOUNT, 0, 0);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::ValidateChild()
//
//  We have no index-ID support in tree view.  Hence, the HTREEITEM is the
//  child ID, only thing we can do.  We don't bother validating it except
//  to make sure it is less than 0x80000000.
//
// --------------------------------------------------------------------------
BOOL COutlineView32::ValidateChild(VARIANT* pvar)
{
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
//BRENDANM - high bit set is valid, on 3G systems plus this can also happen on w64?
//            if (pvar->lVal < 0)
//                return(FALSE);

            //
            // Assume it's a valid HTREEITEM!
            //
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::NextLogicalItem()
//
// --------------------------------------------------------------------------
HTREEITEM COutlineView32::NextLogicalItem(HTREEITEM ht)
{
    HTREEITEM htNext;

    //
    // We see if this item has a child.  If so, we are done.  If not,
    // we get the next sibling.  If that fails, we move back to the parent,
    // and try the next sibling thing again.  And so on until we reach the
    // root.
    //
    htNext = TreeView_GetChild(m_hwnd, ht);
    if (htNext)
        return(htNext);

    while (ht)
    {
        htNext = TreeView_GetNextSibling(m_hwnd, ht);
        if (htNext)
            return(htNext);

        ht = TreeView_GetParent(m_hwnd, ht);
    }

    return(NULL);
}

// --------------------------------------------------------------------------
//
//  COutlineView32::PrevLogicalItem()
//
// --------------------------------------------------------------------------
HTREEITEM COutlineView32::PrevLogicalItem(HTREEITEM ht)
{
    HTREEITEM htPrev;

    //
    // If this item has no previous sibling return the parent.
    // Then if the so, see if run done the first children.  
    // Then get the previous sibling has no children return that.
    // Otherwise march down the tre find the last sibling of the last child
    //
    htPrev = TreeView_GetPrevSibling(m_hwnd, ht);
    if ( !htPrev )
    {
        return TreeView_GetParent(m_hwnd, ht);
    }
    else
    {   
        HTREEITEM htTest = TreeView_GetChild(m_hwnd, htPrev);
		if ( !htTest )
		{
            return htPrev;
		}
		else
		{
			htPrev = htTest;
		    // We are at the first child of the previous sibling
			for ( ;; )
			{
				htTest = TreeView_GetNextSibling(m_hwnd, htPrev);
				if ( !htTest )
			    {
    				htTest = TreeView_GetChild(m_hwnd, htPrev);
    				if ( !htTest )
    				    break;
    			}	

                htPrev = htTest;
			}

			return htPrev;
		}
    }
}


// --------------------------------------------------------------------------
//
//  COutlineView32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accName(VARIANT varChild, BSTR* pszName)
{
    TVITEM* lptvShared;
    LPTSTR  lpszShared;
    HANDLE  hProcess;
    LPTSTR  lpszLocal;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::get_accName(varChild, pszName);

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( ! htItem )
    {
        return E_INVALIDARG;
    }

    //
    // Try getting the item's text the easy way, by asking first. Since the
    // file system limits us to 255 character names, assume items aren't
    // bigger than that.
    //
    lptvShared = TSharedAllocExtra<TVITEM>( m_hwnd, & hProcess,
                                            (MAX_NAME_SIZE+2)*sizeof(TCHAR) );
    if (!lptvShared)
        return(E_OUTOFMEMORY);

    lpszLocal = (LPTSTR)LocalAlloc(LPTR,((MAX_NAME_SIZE+2)*sizeof(TCHAR)));
    if (!lpszLocal)
    {
        SharedFree (lptvShared,hProcess);
        return(E_OUTOFMEMORY);
    }

    lpszShared = (LPTSTR)(lptvShared+1);

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( & lptvShared->mask,       (UINT)TVIF_TEXT,    hProcess );
    TSharedWrite( & lptvShared->hItem,      htItem,             hProcess );
    TSharedWrite( & lptvShared->pszText,    lpszShared,         hProcess );
    TSharedWrite( & lptvShared->cchTextMax, MAX_NAME_SIZE + 1,  hProcess );

    if (TreeView_GetItem(m_hwnd, lptvShared))
    {
        TSharedRead( lpszLocal, lpszShared, MAX_NAME_SIZE + 2, hProcess );
        if (*lpszLocal)
            *pszName = TCharSysAllocString(lpszLocal);
    }

    SharedFree(lptvShared,hProcess);
    LocalFree (lpszLocal);

    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accValue()
//
//  This returns back the indent level for a child item.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return E_NOT_APPLICABLE;

    HTREEITEM htParent = TVItemFromChildID( m_hwnd, varChild.lVal );
	if( ! htParent )
	{
		return E_INVALIDARG;
	}

    long lValue = 0;
    while( htParent = TreeView_GetParent( m_hwnd, htParent ) )
	{
        lValue++;
	}

    return VarBstrFromI4( lValue, 0, 0, pszValue );
}

// --------------------------------------------------------------------------
//
//  COutlineView32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
    {
		HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
		if( ! htItem )
		{
			return E_INVALIDARG;
		}

        DWORD dwRole;
        BOOL fGotRole = FALSE;

        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_ROLEMAP,
                               aKeys, ARRAYSIZE( aKeys ),
                               & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
            else if( GetRoleFromStateImageMap( m_hwnd, aKeys[ TV_IMGIDX_Image ], & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
        }

        if( ! fGotRole )
        {
            //
            //  Note that just because the treeview has TVS_CHECKBOXES
            //  doesn't mean that every item is itself a checkbox.  We
            //  need to sniff at the item, too, to see if it has a state
            //  image.
            //
            if ((GetWindowLong (m_hwnd,GWL_STYLE) & TVS_CHECKBOXES) &&
                TreeView_GetItemState(m_hwnd, htItem, TVIS_STATEIMAGEMASK))
            {
                pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
            else
            {
                pvarRole->lVal = ROLE_SYSTEM_OUTLINEITEM;
            }
        }
    }
    else
	{
        pvarRole->lVal = ROLE_SYSTEM_OUTLINE;
	}

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    LPTVITEM    lptvShared;
    HANDLE      hProcess;
    TVITEM      tvLocal;
    DWORD       dwStyle;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( htItem == NULL )
    {
        return E_INVALIDARG;
    }

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (MyGetFocus() == m_hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    lptvShared = TSharedAlloc< TVITEM >( m_hwnd, & hProcess );
    if (!lptvShared)
        return(E_OUTOFMEMORY);

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( & lptvShared->mask,   (UINT)(TVIF_STATE | TVIF_CHILDREN), hProcess );
    TSharedWrite( & lptvShared->hItem,  htItem,                             hProcess );

    if (TreeView_GetItem(m_hwnd, lptvShared))
    {
        TSharedRead( & tvLocal, lptvShared, hProcess );

        if (tvLocal.state & TVIS_SELECTED)
        {
            pvarState->lVal |= STATE_SYSTEM_SELECTED;
            if (pvarState->lVal & STATE_SYSTEM_FOCUSABLE)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        }

        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        if (tvLocal.state & TVIS_DROPHILITED)
            pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

        //
        // If it isn't expanded and it has children, then it must be
        // collapsed.
        //
        if (tvLocal.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL))
            pvarState->lVal |= STATE_SYSTEM_EXPANDED;
        else if (tvLocal.cChildren)
            pvarState->lVal |= STATE_SYSTEM_COLLAPSED;

        // If the treeview has checkboxes, then see if it's checked.
        // State 0 = no checkbox, State 1 = unchecked, State 2 = checked
        dwStyle = GetWindowLong (m_hwnd,GWL_STYLE);
        if ((dwStyle & TVS_CHECKBOXES) &&
            (tvLocal.state & TVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2))
            pvarState->lVal |= STATE_SYSTEM_CHECKED;


        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            DWORD dwState;
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_STATEMAP,
                               aKeys, ARRAYSIZE( aKeys ), & dwState ) )
            {
                pvarState->lVal |= dwState;
            }
            else if( GetStateFromStateImageMap( m_hwnd, aKeys[ TV_IMGIDX_Image ], & dwState ) )
            {
                pvarState->lVal |= dwState;
            }
        }
    }

    SharedFree(lptvShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;


    if (varChild.lVal)
    {
        HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
        if( ! htItem )
        {
            return E_INVALIDARG;
        }

        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            if( CheckStringMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF, PROPINDEX_DESCRIPTIONMAP,
                                aKeys, ARRAYSIZE( aKeys ), pszDesc ) )
            {
                return S_OK;
            }
        }
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  COutlineView32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accFocus(VARIANT* pvarFocus)
{
    HRESULT hr;

    //
    // Do we have the focus?
    //
    hr = CClient::get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr) || (pvarFocus->vt != VT_I4) || (pvarFocus->lVal != 0))
        return hr;

    //
    // We do.  What item is focused?
    //
    return COutlineView32::get_accSelection(pvarFocus);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accSelection(VARIANT* pvarSelection)
{
    InitPvar(pvarSelection);

    HTREEITEM ht = TreeView_GetSelection(m_hwnd);
    if (ht)
    {
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = ChildIDFromTVItem( m_hwnd, ht );
        if( pvarSelection->lVal == 0 )
            return E_FAIL;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accDefaultAction()
//
//  The default action of a node with children is:
//      * Expand one level if it is fully collapsed
//      * Collapse if it is partly or completely expanded
//
//  The reason for not expanding fully is that it is slow and there is no
//  keyboard shortcut or mouse click that will do it.  You can use a menu
//  command to do so if you want.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    VARIANT varState;
    HRESULT hr;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefA));

    //
    // Get our state.  NOTE that we will not get back STATE_SYSTEM_COLLAPSED
    // if the item doesn't have children.
    //
    VariantInit(&varState);
    hr = get_accState(varChild, &varState);
    if (!SUCCEEDED(hr))
        return(hr);

    if (varState.lVal & STATE_SYSTEM_EXPANDED)
        return(HrCreateString(STR_TREE_COLLAPSE, pszDefA));
    else if (varState.lVal & STATE_SYSTEM_COLLAPSED)
        return(HrCreateString(STR_TREE_EXPAND, pszDefA));
    else
        return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  COutlineView32::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accSelect(long selFlags, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(selFlags))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::accSelect(selFlags, varChild);

	HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
	if( htItem == NULL )
	{
		return E_INVALIDARG;
	}

    if (selFlags & SELFLAG_TAKEFOCUS) 
    {
        MySetFocus(m_hwnd);
    }

	if ((selFlags & SELFLAG_TAKEFOCUS) || (selFlags & SELFLAG_TAKESELECTION))
	{
		TreeView_SelectItem(m_hwnd, htItem);
		return S_OK;
	}
	else
	{
		return E_NOT_APPLICABLE;
	}

}



// --------------------------------------------------------------------------
//
//  COutlineView32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( htItem == NULL )
    {
        return E_INVALIDARG;
    }

    // Get the listview item rect.
    HANDLE hProcess;
    LPRECT lprcShared = TSharedAlloc< RECT >( m_hwnd, & hProcess );
    if (!lprcShared)
        return E_OUTOFMEMORY;

    // can't use the TreeView_GetItemRect macro, because it does a behind-the-scenes
    // assignment of the item id into the rect, which blows on shared memory.
    // TVM_GETITEMRECT is weird: it's a ptr to a RECT, which, on input, contains
    // the HTREEITEM of the item; on output it contains that item's rect.

    TSharedWrite( (HTREEITEM *)lprcShared, htItem, hProcess);

    if (SendMessage (m_hwnd, TVM_GETITEMRECT, TRUE, (LPARAM)lprcShared))
    {
        RECT rcLocal;
        TSharedRead( & rcLocal, lprcShared, hProcess );

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;
    }

    SharedFree(lprcShared,hProcess);

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
	HTREEITEM   htItem;
    HTREEITEM   htNewItem = 0;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir >= NAVDIR_FIRSTCHILD)
    {
        htNewItem = TreeView_GetRoot(m_hwnd);

        if ((dwNavDir == NAVDIR_LASTCHILD) && htNewItem)
        {
            HTREEITEM   htNext;

            // make sure we are at the last root sibling
            htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
            while (htNext)
            {
                htNewItem = htNext;
                htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
            }
            
RecurseAgain:
            //
            // Keep recursing down all the way to the last ancestor of the
            // last item under the root.
            //
            htNext = TreeView_GetChild(m_hwnd, htNewItem);
            if (htNext)
            {
                while (htNext)
                {
                    htNewItem = htNext;
                    htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
                }

                goto RecurseAgain;
            }
        }

        goto AllDone;
    }
    else if (!varStart.lVal)
	{
        return CClient::accNavigate(dwNavDir, varStart, pvarEnd);
	}


	htItem = TVItemFromChildID( m_hwnd, varStart.lVal );
	if( htItem == NULL )
	{
		return E_INVALIDARG;
	}


    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            // Next logical item, peer or child
            htNewItem = NextLogicalItem(htItem);
            break;

        case NAVDIR_PREVIOUS:
            // Previous logical item, peer or parent
            htNewItem = PrevLogicalItem(htItem);
            break;

        case NAVDIR_UP:
            // Previous sibling!
            htNewItem = TreeView_GetPrevSibling(m_hwnd, htItem);
            break;

        case NAVDIR_DOWN:
            // Next sibling!
            htNewItem = TreeView_GetNextSibling(m_hwnd, htItem);
            break;

        case NAVDIR_LEFT:
            // Get parent!
            htNewItem = TreeView_GetParent(m_hwnd, htItem);
            break;

        case NAVDIR_RIGHT:
            // Get first child!
            htNewItem = TreeView_GetChild(m_hwnd, htItem);
            break;
    }

AllDone:
    if (htNewItem)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = ChildIDFromTVItem( m_hwnd, htNewItem );
        if( pvarEnd->lVal == 0 )
            return E_FAIL;
        
        return S_OK;
    }
    else
	{
        return S_FALSE;
	}
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT         hr;
    LPTVHITTESTINFO lptvhtShared;
    HANDLE          hProcess;
    POINT           ptLocal;

    SetupChildren();
    
    //
    // Is the point in the listview at all?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    //
    // Now find out what item this point is on.
    //
    lptvhtShared = TSharedAlloc< TVHITTESTINFO >( m_hwnd, & hProcess );
    if (!lptvhtShared)
        return(E_OUTOFMEMORY);

    // Cast keeps templates happy - NULL on its own is #define'd as 0 and has no type.
    TSharedWrite( & lptvhtShared->hItem, (HTREEITEM)NULL, hProcess );
    
    ptLocal.x = x;
    ptLocal.y = y;
    ScreenToClient(m_hwnd, &ptLocal);

    TSharedWrite( & lptvhtShared->pt, ptLocal, hProcess );

    SendMessage(m_hwnd, TVM_HITTEST, 0, (LPARAM)lptvhtShared);

    HTREEITEM hItem;
    TSharedRead( &hItem, & lptvhtShared->hItem, hProcess );
    SharedFree(lptvhtShared,hProcess);

    if( hItem )
    {
        pvarHit->lVal = ChildIDFromTVItem( m_hwnd, hItem );
        if( pvarHit->lVal == 0 )
            return E_FAIL;
    }
    else
    {
        // if hItem is NULL, then point is over the treeview itself
        pvarHit->lVal = CHILDID_SELF;
    }


    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accDoDefaultAction()
//
//  This expands collapsed items and collapses expanded items.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accDoDefaultAction(VARIANT varChild)
{
    VARIANT varState;
    HRESULT hr;
    UINT    tve;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    //
    // Get the item's state.
    //
    VariantInit(&varState);
    hr = get_accState(varChild, &varState);
    if (!SUCCEEDED(hr))
        return(hr);

    if (varState.lVal & STATE_SYSTEM_COLLAPSED)
        tve = TVE_EXPAND;
    else if (varState.lVal & STATE_SYSTEM_EXPANDED)
        tve = TVE_COLLAPSE;
    else
        return(E_NOT_APPLICABLE);

    PostMessage(m_hwnd, TVM_EXPAND, tve, (LPARAM)varChild.lVal);
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Reset()
//
//  Sets the "current" HTREEITEM to NULL so we know we are at the beginning.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Reset()
{
    m_idChildCur = 0;
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Next()
//
//  We descend into children, among siblings, and back up as necessary.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Next(ULONG celt, VARIANT* rgvarFetch, ULONG* pceltFetch)
{
    SetupChildren();

    if (pceltFetch)
        InitPv(pceltFetch);

    HTREEITEM htCur;
    HTREEITEM htNext;
    if( m_idChildCur == 0 )
    {
        htCur = NULL;
        htNext = TreeView_GetRoot(m_hwnd);
    }
    else
    {
        htCur = TVItemFromChildID( m_hwnd, m_idChildCur );
        if( ! htCur )
        {
            return E_FAIL;
        }
        htNext = NextLogicalItem(htCur);
    }

    VARIANT * pvar = rgvarFetch;
    ULONG cFetched = 0;
    while( (cFetched < celt) && htNext )
    {
        htCur = htNext;

        cFetched++;

        pvar->vt = VT_I4;
        pvar->lVal = ChildIDFromTVItem( m_hwnd, htCur );
        if( pvar->lVal == 0 )
            return E_FAIL;
        pvar++;

        htNext = NextLogicalItem(htCur);
    }

    // if htCur is still NULL, then the treeview has 0 items, and
    // m_idChildCur is still 0, at the start of the (empty) list.
    // - safe to leave as is.
    if( htCur )
    {
        m_idChildCur = ChildIDFromTVItem( m_hwnd, htCur );
        if( m_idChildCur == 0 )
            return E_FAIL;
    }

    if (pceltFetch)
        *pceltFetch = cFetched;

    return (cFetched < celt) ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Skip(ULONG celtSkip)
{
    SetupChildren();

    HTREEITEM htCur;
    HTREEITEM htNext;
    if( m_idChildCur == 0 )
    {
        htCur = NULL;
        htNext = TreeView_GetRoot(m_hwnd);
    }
    else
    {
        htCur = TVItemFromChildID( m_hwnd, m_idChildCur );
        if( ! htCur )
        {
            return E_FAIL;
        }
        htNext = NextLogicalItem(htCur);
    }

    while ((celtSkip > 0) && htNext)
    {
        --celtSkip;

        htCur = htNext;
        htNext = NextLogicalItem(htCur);
    }

    // if htCur is still NULL, then the treeview has 0 items, and
    // m_idChildCur is still 0, at the start of the (empty) list.
    // - safe to leave as is.
    if( htCur )
    {
        m_idChildCur = ChildIDFromTVItem( m_hwnd, htCur );
        if( m_idChildCur == 0 )
            return E_FAIL;
    }

    return htNext ? S_OK : S_FALSE;
}




BOOL TVGetImageIndex( HWND hwnd, HTREEITEM id, int aKeys[ TV_IMGIDX_COUNT ] )
{
    HANDLE  hProcess;
    TVITEM * lptvShared = TSharedAlloc< TVITEM >( hwnd, & hProcess );
    if (!lptvShared)
        return FALSE;

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( &lptvShared->mask,    (UINT)(TVIF_IMAGE | LVIF_STATE),    hProcess );
    TSharedWrite( &lptvShared->hItem,   id,                                 hProcess );

    BOOL fRet;
    if (TreeView_GetItem(hwnd, lptvShared))
    {
        INT iImage;
        UINT state;
        TSharedRead( & iImage,  & lptvShared->iImage,   hProcess );
        TSharedRead( & state,   & lptvShared->state,    hProcess );

        aKeys[ TV_IMGIDX_Image ]   = iImage;
        aKeys[ TV_IMGIDX_Overlay ] = ( state >> 8 ) & 0x0F;
        aKeys[ TV_IMGIDX_State ]   = ( state >> 12 ) & 0x0F;
        
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    SharedFree( lptvShared, hProcess );

    return fRet;
}





// This reads from the process associated with the given
// hwnd, and does the necessary OpenProcess/CloseHandle
// tidyup and checks....
BOOL ReadProcessMemoryHWND( HWND hwnd, void * pSrc, void * pDst, DWORD len )
{
    DWORD idProcess = 0;
    GetWindowThreadProcessId(hwnd, &idProcess);
    if( ! idProcess )
        return FALSE;

    HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, idProcess );
    if( ! hProcess )
        return FALSE;

    SIZE_T cbActual = 0;
    BOOL retval = ReadProcessMemory( hProcess, pSrc, pDst, len, & cbActual )
            && len == cbActual;

    CloseHandle( hProcess );

    return retval;
}


BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole )
{
    void * pAddress = (void *) GetProp( hwnd, TEXT("MSAAStateImageMapAddr") );
    if( ! pAddress )
        return FALSE;

    int NumStates = PtrToInt( GetProp( hwnd, TEXT("MSAAStateImageMapCount") ) );
    if( NumStates == 0 )
        return FALSE;

    // <= used since number is a 1-based count, iImage is a 0-based index.
    // If iImage is 0, should be at least one state.
    if( NumStates <= iImage )
        return FALSE;

    // Adjust to iImage into array...
    pAddress = (void*)( (MSAASTATEIMAGEMAPENT*)pAddress + iImage );

    MSAASTATEIMAGEMAPENT ent;
    if( ! ReadProcessMemoryHWND( hwnd, pAddress, & ent, sizeof(ent) ) )
        return FALSE;

    *pdwState = ent.dwState;
    *pdwRole = ent.dwRole;
    return TRUE;
}



BOOL GetStateImageMapEnt( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole )
{
    // Quick shortcut - if this property isn't present, then don't even bother
    // going further...
    if( ! GetProp( hwnd, TEXT("MSAAStateImageMapCount") ) )
        return FALSE;


	// First determine if hwnd is a process with the same bitness as this DLL
	BOOL fIsSameBitness;
	if (FAILED(SameBitness(hwnd, &fIsSameBitness)))
		return FALSE;	// this case should never happen


    if( fIsSameBitness )
    {
        return GetStateImageMapEnt_SameBitness( hwnd, iImage, pdwState, pdwRole );
    }
    else
    {
		// The server (hwnd) is not the same bitness so get a remote proxy
		// factory object and call GetRoleFromStateImageMap thru it.
		IRemoteProxyFactory *p;
		if (FAILED(GetRemoteProxyFactory(&p)))
        {
			return FALSE;
        }

		HRESULT hr = p->GetStateImageMapEnt(
				          HandleToLong( hwnd )
				        , iImage
				        , pdwState
				        , pdwRole );

        p->Release();

        return hr == S_OK;
	}
}


BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole )
{
    DWORD dwState;
    return GetStateImageMapEnt( hwnd, iImage, & dwState, pdwRole );
}

BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState )
{
    DWORD dwRole;
    return GetStateImageMapEnt( hwnd, iImage, pdwState, & dwRole );
}






// These are defined in the latest commctrl.h...
#ifndef TVM_MAPACCIDTOHTREEITEM

#define TVM_MAPACCIDTOHTREEITEM     (TV_FIRST + 42)
#define TreeView_MapAccIDToHTREEITEM(hwnd, id) \
    (HTREEITEM)SNDMSG((hwnd), TVM_MAPACCIDTOHTREEITEM, id, 0)

#define TVM_MAPHTREEITEMTOACCID     (TV_FIRST + 43)
#define TreeView_MapHTREEITEMToAccID(hwnd, htreeitem) \
    (UINT)SNDMSG((hwnd), TVM_MAPHTREEITEMTOACCID, (WPARAM)htreeitem, 0)

#endif



// TODO - need to handle the case where the treeview is 64-bit, the
// client is 32. SendMessage will truncate the retuend HTREEITEM,
// and the 32-bit client has no way of sending a 64-bit value to the
// 64-bit tree anyhow.
// Need to detect that case, and get the 64-bit helper server to help
// out.

// This should work tree-client 32t-32c, 64t-64c and 32t-64c.

HTREEITEM TVItemFromChildID( HWND hwnd, DWORD idChild )
{
    Assert( idChild );
    if( idChild == 0 )
        return NULL;

    HTREEITEM hItem = TreeView_MapAccIDToHTREEITEM( hwnd, idChild );

    if( hItem )
    {
        return hItem;
    }

#ifdef _WIN64
    return NULL;
#else
    // Fallback for older 32-bit comctls that don't implement the mapping
    // message
    return (HTREEITEM) idChild;
#endif

}


DWORD ChildIDFromTVItem( HWND hwnd, HTREEITEM htvi )
{
    Assert( htvi != NULL );
    if( htvi == NULL )
        return 0;

    DWORD dwid = TreeView_MapHTREEITEMToAccID( hwnd, htvi );

    if( dwid != 0 )
    {
        return dwid;
    }

#ifdef _WIN64
    return 0;
#else
    // Fallback for older 32-bit comctls that don't implement the mapping
    // message
    return (DWORD) htvi;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\progress.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PROGRESS.H
//
// --------------------------------------------------------------------------

class   CProgressBar :     public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accValue(VARIANT varChild, BSTR* pszValue);

        CProgressBar(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_client.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Client
//
//  Property manager / annotation client. Uses the shared memory component 
//  (PropMgr_Mem.*) to read properties directly w/o cross-proc com overhead
//  to the annotation server.
//
//  This is effectively a singleton - Init/Uninit called at startup/shutdown,
//  one method to get properties.
//
// --------------------------------------------------------------------------



// Must be called before any other PropMgrClient_ APIs are used
BOOL PropMgrClient_Init();

// Call at shutdown to release resources
void PropMgrClient_Uninit();

// Checks if there is a live server out there - if not, a client
// can short-circuit getting the key and calling LookupProp.
BOOL PropMgrClient_CheckAlive();

// Look up a property a key.
BOOL PropMgrClient_LookupProp( const BYTE * pKey,
                               DWORD dwKeyLen,
                               PROPINDEX idxProp,
                               VARIANT * pvar );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_client.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Client
//
//  Property manager / annotation client. Uses the shared memory component 
//  (PropMgr_MemStream.*) to read properties directly w/o cross-proc com overhead
//  to the annotation server.
//
//  This is effectively a singleton - Init/Uninit called at startup/shutdown,
//  plus one method to get properties.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"

#include "PropMgr_Client.h"

#include "PropMgr_Util.h"
#include "PropMgr_Mem.h"


// Note: See PropMgr_Impl.cpp for a description of the shared memory
// layout.


// class MapReaderMgr
//
// This class manages looking up properties.
//
// This class is private to this file; its functionality is exposed by the
// PropMgr_ APIs near the bottom of this file.
//
// This class is a singleton, a single instance, g_MapReader, exists.

class MapReaderMgr
{



    // _ReadCallbackProperty
    //
    // Given a pointer to the start of a marshaled object reference pInfo,
    // it unmarshalls the callback object and calls it to get the property
    // corresponding to the given child key.
    // Returns TRUE if all goes well, and if the callback knows about this
    // property.
    BOOL _ReadCallbackProperty( MemStream pInfo,
                                const BYTE * pChildKey, DWORD dwChildKeyLen, 
                                PROPINDEX idxProp,
                                VARIANT * pvar )
    {
        // Read length of marshalled data...
        DWORD dwLen;
        if( ! MemStreamRead_DWORD( pInfo, & dwLen ) )
        {
            return FALSE;
        }

        const BYTE * pData = MemStream_GetBinaryPtr( pInfo, dwLen );
        if( ! pData )
        {
            return FALSE;
        }

        IAccPropServer * pServer = NULL;
        HRESULT hr = UnmarshalInterface( pData, dwLen, IID_IAccPropServer, (void **) & pServer );
        if( hr != S_OK )
        {
            return FALSE;
        }

        // Got it - ask it for the property...
        BOOL fGotProp = FALSE;
        hr = pServer->GetPropValue( pChildKey, dwChildKeyLen,
                                    *g_PropInfo[ idxProp ].m_idProp,
                                    pvar,
                                    & fGotProp );
        pServer->Release();

        // Did the call succeed, and did the server return a value?
        if( hr != S_OK || fGotProp == FALSE )
        {
            return FALSE;
        }

        return TRUE;
    }
        


    // Read a specific property from a record .
    // (a record contains all properties about a given object)
    BOOL _ReadPropertyFromEntry( MemStream pEntryInfo,
                                 const BYTE * pChildKey, DWORD dwChildKeyLen, 
                                 PROPINDEX idxProp,
                                 BOOL fWantContainerOnly,
                                 VARIANT * pvar )
    {
        // Skip over the size at start of info block
        if( ! MemStreamSkip_DWORD( pEntryInfo ) )
        {
            return FALSE;
        }

        // Extract the bitmasks:
        // Which properties are present, which are variants, and which are scoped...
        DWORD dwUsedBits;
        DWORD dwVariantBits;
        DWORD dwScopeBits;

        if( ! MemStreamRead_DWORD( pEntryInfo, & dwUsedBits )
         || ! MemStreamRead_DWORD( pEntryInfo, & dwVariantBits )
         || ! MemStreamRead_DWORD( pEntryInfo, & dwScopeBits ) )
        {
            return FALSE;
        }

        // Is the property we're looking for present at all?
        // (Note - if we decide to allow other GUIDS other than those in the array,
        // we'll have to skip over the indexed ones and then search through any
        // guid/val pairs after that. Could use one bit of this mask to indicate
        // 'there are other // GUID properties present', though.)
        if( ! IsBitSet( dwUsedBits, idxProp ) )
        {
            // Property not present - return false.
            return FALSE;
        }

        // The property is present - but are we specifically looking for
        // container-scoped properties? If so, bail out if the bit isn't set...
        if( fWantContainerOnly && ! IsBitSet( dwScopeBits, idxProp ) )
        {
            return FALSE;
        }

        // Property is present - now we have to skip over the other present
        // properties to get to the one we want...
        for( int i = 0 ; i < idxProp ; i++ )
        {
            // Only haqve to skip over properties that are actually present...
            if( IsBitSet( dwUsedBits, i ) )
            {
                if( IsBitSet( dwVariantBits, i ) )
                {
                    // Skip over variant...
                    if( ! MemStreamSkip_VARIANT( pEntryInfo ) )
                        return FALSE;
                }
                else
                {
                    // Skip over object reference...
                    DWORD dwLen;
                    if( ! MemStreamRead_DWORD( pEntryInfo, & dwLen ) )
                        return FALSE;

                    if( ! MemStreamSkip_Binary( pEntryInfo, dwLen ) )
                        return FALSE;
                }
            }
        }

        // Now we're at the one we want. Extract it...

        // Is it a variant or a server object?
        if( IsBitSet( dwVariantBits, idxProp ) )
        {
            // variant - return it...
            return MemStreamRead_VARIANT( pEntryInfo, pvar );
        }
        else
        {
            // server object - use and return what it returns...
            return _ReadCallbackProperty( pEntryInfo,
                                          pChildKey, dwChildKeyLen, 
                                          idxProp,
                                          pvar );
        }
    }



    HWND PropHwndFromKey( const BYTE * pKey, DWORD dwKeyLen )
    {
        HWND hwndProp;
        if( DecodeHwndKey( pKey, dwKeyLen, & hwndProp, NULL, NULL ) )
        {
            return hwndProp;
        }

        // If it's a HMENU key, find the PID, then find window using window name
        // generated using that PID...
        DWORD dwPid;
        if( DecodeHmenuKey( pKey, dwKeyLen, & dwPid, NULL, NULL ) )
        {
            TCHAR szWindowName[ 64 ];
            wsprintf( szWindowName, TEXT("MSAA_DA_%lx"), dwPid );

            hwndProp = FindWindow( TEXT("MSAA_DA_Class"), szWindowName );

            return hwndProp;
        }

        return NULL;
    }


    // _LookupProp
    //
    // 
    // fWantContainerOnly means we're only interested in props markes with the
    // 'container' scope. This happens when we search for a prop for a child,
    // don't find anything there - so also check parent to see if it is a parent
    // and has a property set for it and its children. (These props are currently
    // always server callback props)
    BOOL _LookupProp( const BYTE * pKey, DWORD dwKeyLen, 
                      const BYTE * pChildKey, DWORD dwChildKeyLen, 
                      PROPINDEX idxProp, BOOL fWantContainerOnly, VARIANT * pvar )
    {
        HWND hwndProp = PropHwndFromKey( pKey, dwKeyLen );
        if( ! hwndProp )
        {
            return FALSE;
        }

        LPTSTR pKeyString = MakeKeyString( pKey, dwKeyLen );
        if( ! pKeyString  )
        {
            return FALSE;
        }

        void * pvProp = GetProp( hwndProp, pKeyString );

        delete [ ] pKeyString;


        if( ! pvProp )
        {
            return FALSE;
        }

        DWORD pid = 0;
        GetWindowThreadProcessId( hwndProp, & pid );
        if( ! pid )
        {
            return FALSE;
        }
        HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, pid );
        if( ! hProcess )
        {
            return FALSE;
        }

        DWORD dwSize;
        SIZE_T cbBytesRead = 0;
        if( ! ReadProcessMemory( hProcess, pvProp, & dwSize, sizeof( dwSize ), & cbBytesRead )
                || cbBytesRead != sizeof( dwSize ) )
        {
            CloseHandle( hProcess );
            return FALSE;
        }


        BYTE * pBuffer = new BYTE [ dwSize ];
        if( ! pBuffer )
        {
            CloseHandle( hProcess );
            return FALSE;
        }

        cbBytesRead = 0;
        if( ! ReadProcessMemory( hProcess, pvProp, pBuffer, dwSize, & cbBytesRead )
                || cbBytesRead != dwSize )
        {
            delete [ ] pBuffer;
            CloseHandle( hProcess );
            return FALSE;
        }

        CloseHandle( hProcess );

        
        MemStream p( pBuffer, dwSize );


        BOOL fGotProp = _ReadPropertyFromEntry( p,
                                                pChildKey, dwChildKeyLen, 
                                                idxProp,
                                                fWantContainerOnly,
                                                pvar );

        delete [ ] pBuffer;

        return fGotProp;
    }




public:

    BOOL LookupProp( const BYTE * pKey,
                     DWORD dwKeyLen,
                     PROPINDEX idxProp,
                     VARIANT * pvar )
    {
        BOOL bRetVal = _LookupProp( pKey, dwKeyLen,
                                    pKey, dwKeyLen,
                                    idxProp, FALSE, pvar );

        if( ! bRetVal )
        {
            // Is this a leaf-node element? If so, try the parent for a 'container
            // scope' property.
            // This is what allows a callback-annotation on a parent to apply
            // to all its simple-element children
            // If we later extend this to allow for pluggable namespaces, we'd
            // need to change this to be non-HWND-specific (eg. call a
            // IAccNamespece::GetParentKey() or similar method)
            HWND hwnd;
            DWORD idObject;
            DWORD idChild;
            if( DecodeHwndKey( pKey, dwKeyLen, & hwnd, & idObject, & idChild )
             && idChild != CHILDID_SELF )
            {
                BYTE ParentKey[ HWNDKEYSIZE ];
                MakeHwndKey( ParentKey, hwnd, idObject, CHILDID_SELF );
                bRetVal = _LookupProp( ParentKey, HWNDKEYSIZE,
                                       pKey, dwKeyLen,
                                       idxProp, TRUE, pvar );
            }
            else
            {
                HMENU hmenu;
                DWORD idChild;
                DWORD dwpid;
                if( DecodeHmenuKey( pKey, dwKeyLen, & dwpid, & hmenu, & idChild )
                 && idChild != CHILDID_SELF )
                {
                    BYTE ParentKey[ HMENUKEYSIZE ];
                    MakeHmenuKey( ParentKey, dwpid, hmenu, CHILDID_SELF );
                    bRetVal = _LookupProp( ParentKey, HMENUKEYSIZE,
                                           pKey, dwKeyLen,
                                           idxProp, TRUE, pvar );
                }
            }
        }

        return bRetVal;
    }
};



MapReaderMgr g_MapReader;






BOOL PropMgrClient_Init()
{
    // no-op
    return TRUE;
}

void PropMgrClient_Uninit()
{
    // no-op
}

BOOL PropMgrClient_CheckAlive()
{
    // no-op
    return TRUE;
}

BOOL PropMgrClient_LookupProp( const BYTE * pKey,
                               DWORD dwKeyLen,
                               PROPINDEX idxProp,
                               VARIANT * pvar )
{
    return g_MapReader.LookupProp( pKey, dwKeyLen, idxProp, pvar );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_impl.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Impl
//
//  Property manager server class
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>


#include "PropMgr_Util.h"
#include "PropMgr_Impl.h"
#include "PropMgr_Mem.h"

#pragma warning(push, 3)
#pragma warning(disable: 4530)
#include <map>
#include <vector>
#pragma warning(pop) 


#include "debug.h"


/*
 
Format of item record:

    * size prefix

    * 'Properties present' bitmask
      Indicates that the property is present for this key

    * 'Property is a variant' bitmask
      For present properties, indicates whether the property is a VARIANT
      versus an object reference.

    * 'Property has container scope' bitmask
      Indicates that the property applies to this key, and to all that element's
      simple children.


    * Property data: For each property which is present (see 'property present'
      bitmask), there is:
      
        either 


        * a serialized VARIANT

        or

        * a serialized/marshalled callback object reference (IAccPropServer)


        - depending on whether the 'property is variant' bitmask is set for this property.




Variants are serialized as a leading SHORT indicating the type (VT_???), followed by:
    DWORD for I4s,
    DWORD length followed by unicode chars for BSTR

A marshalled callback reference is serialized as:
    DWORD for length of marshalled data,
    BYTEs of the marshalled data.



*/















BOOL IsKeyAlive( const BYTE * pKeyData, DWORD dwKeyLen )
{
    // For the moment, assume it uses either the HWND or HMENU naming scheme.
    // (Later on, if we extend this to allow pluggable namespaces, we'd use something
    // like IAccNamespace::IsKeyAlive() instead.)

    HWND hwnd;
    if( DecodeHwndKey( pKeyData, dwKeyLen, & hwnd, NULL, NULL ) )
    {
        return IsWindow( hwnd );
    }

    HMENU hmenu;
    if( DecodeHmenuKey( pKeyData, dwKeyLen, NULL, & hmenu, NULL ) )
    {
        return IsMenu( hmenu );
    }

    Assert( FALSE );
    return FALSE;
}



// This is a reference to a key (aka id string) - it does not own or contain
// the key.
//
// When used in the object map, (which contains {AccObjKeyRef, AccInfo*} pairs),
// m_pKeyData points to the key data in the corresponding AccInfo. This object
// and the corresponding AccInfo have identical lifetimes.
//
// In other cases - for example, when used as a value to look up in the map -
// m_pKeyData points to an already existing key string - possibly the id string
// specified by the caller of one of the IAccPropServer methods. In this usage,
// the AccObjKeyRef is really being used as a temporary adapter to allow the
// existing string to be used to look up a value in the map.
class AccObjKeyRef
{
    const BYTE *  m_pKeyData;
    DWORD         m_dwKeyLen;

    // Disable default ctor
    AccObjKeyRef();

public:

    // copy ctor
    AccObjKeyRef( const BYTE * pKeyData, DWORD dwKeyLen )
        : m_pKeyData( pKeyData ),
          m_dwKeyLen( dwKeyLen ) 
    {
    }

    // use default member-wise assignment

    
    // Comparisons - used in map lookup

    bool operator < ( const AccObjKeyRef & x ) const
    {
        if( m_dwKeyLen != x.m_dwKeyLen )
            return m_dwKeyLen < x.m_dwKeyLen;

        return memcmp( m_pKeyData, x.m_pKeyData, m_dwKeyLen ) < 0;
    }

    bool operator == ( const AccObjKeyRef & x ) const
    {
        if( m_dwKeyLen != x.m_dwKeyLen )
            return false;

        return memcmp( m_pKeyData, x.m_pKeyData, m_dwKeyLen ) == 0;
    }

    bool operator != ( const AccObjKeyRef & x ) const
    {
        return ! operator == ( x );
    }
};








struct AccInfo
{
private:

    // disable copy ctor
    AccInfo( const AccInfo & x );

private:

    struct PropInfo
    {
        union {
            VARIANT             m_var;

            struct
            {
                BYTE *      m_pMarshalData;
                DWORD       m_dwMarshalDataLen;
            } m_ServerInfo;
        };
    };


    BYTE *      m_pKeyData;
    DWORD       m_dwKeyLen;


    DWORD       m_fPropInUseBits; 
    DWORD       m_fPropIsVariantBits;   // 1-bit indicates the property is VARIANT - otherwise it's a IAccPropServer
    DWORD       m_fContainerScopeBits;  // 1-bit indicates that the property is a IAccPropServer, and should also
                                        // be used for the children of this node. (annoScope was CONTAINER).

    PropInfo    m_Props[ NUMPROPS ];


    HWND        m_hwndProp;
    LPTSTR      m_pKeyString;

    BYTE *      m_pBlob;


public:

    AccInfo()
    {
        m_fPropInUseBits = 0;
        m_fPropIsVariantBits = 0;
        m_fContainerScopeBits = 0;
        m_pKeyString = NULL;
        m_hwndProp = NULL;
        m_pBlob = NULL;
    }


    ~AccInfo()
    {
        ClearBlob();

        for( int i = 0 ; i < NUMPROPS ; i++ )
        {
            ClearProp( i );
        }

        delete [ ] m_pKeyData;
        delete [ ] m_pKeyString;
    }


    BOOL Init( const BYTE * pKeyData, DWORD dwKeyLen, HWND hwndProp )
    {
        m_pKeyData = new BYTE [ dwKeyLen ];
        if( ! m_pKeyData )
        {
            TraceError( TEXT("AccInfo::Init: new returned NULL") );
            return FALSE;
        }
        memcpy( m_pKeyData, pKeyData, dwKeyLen );
        m_dwKeyLen = dwKeyLen;

        m_pKeyString = MakeKeyString( pKeyData, dwKeyLen );

        m_hwndProp = hwndProp;

        return TRUE;
    }

    const AccObjKeyRef GetKeyRef()
    {
        return AccObjKeyRef( m_pKeyData, m_dwKeyLen );
    }


	BOOL SetPropValue (
		int             iProp,
		VARIANT *		pvarValue )
    {
        ClearProp( iProp );

        SetBit( & m_fPropIsVariantBits, iProp );
        SetBit( & m_fPropInUseBits, iProp );
        ClearBit( & m_fContainerScopeBits, iProp );
        m_Props[ iProp ].m_var.vt = VT_EMPTY;

        // We'll accept any type here. It's up to the caller of this to enforce
        // any property-vs-type policies (eg. only allow I4's for ROLE, etc.)
        VariantCopy( & m_Props[ iProp ].m_var, pvarValue );

        return TRUE;
    }


    BOOL SetPropServer (
        int                 iProp,
        const BYTE *        pMarshalData,
        int                 dwMarshalDataLen,
        AnnoScope           annoScope )
    {
        if( dwMarshalDataLen == 0 )
        {
            TraceError( TEXT("AccInfo::SetPropServer: dwMarshalDataLen param = 0") );
            return FALSE;
        }

        BYTE * pCopyData = new BYTE [ dwMarshalDataLen ];
        if( ! pCopyData )
        {
            TraceError( TEXT("AccInfo::SetPropServer: new returned NULL") );
            return FALSE;
        }

        ClearProp( iProp );

        ClearBit( & m_fPropIsVariantBits, iProp );
        SetBit( & m_fPropInUseBits, iProp );

        if( annoScope == ANNO_CONTAINER )
        {
            SetBit( & m_fContainerScopeBits, iProp );
        }
        else
        {
            ClearBit( & m_fContainerScopeBits, iProp );
        }

        m_Props[ iProp ].m_ServerInfo.m_dwMarshalDataLen = dwMarshalDataLen;
        memcpy( pCopyData, pMarshalData, dwMarshalDataLen );
        m_Props[ iProp ].m_ServerInfo.m_pMarshalData = pCopyData;

        return TRUE;
    }
  


    void ClearProp( int i )
    {
        // Does this property need to be cleared?
        if( IsBitSet( m_fPropInUseBits, i ) )
        {
            // Is it a simple variant, or a callback reference?
            if( IsBitSet( m_fPropIsVariantBits, i ) )
            {
                // Simple variant...
                VariantClear( & m_Props[ i ].m_var );
            }
            else
            {
                BYTE * pMarshalData = m_Props[ i ].m_ServerInfo.m_pMarshalData;
                DWORD dwMarshalDataLen = m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen;

                // Callback reference...
                Assert( dwMarshalDataLen );
                if( dwMarshalDataLen && pMarshalData )
                {
                    // This releases the object reference, byt we have to delete the buffer
                    // ourselves...
                    ReleaseMarshallData( pMarshalData, dwMarshalDataLen );

                    delete [ ] pMarshalData;
                    m_Props[ i ].m_ServerInfo.m_pMarshalData = NULL;
                    m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen = 0;
                }
            }

            ClearBit( & m_fPropInUseBits, i );
        }
    }

    BOOL IsEmpty()
    {
        return m_fPropInUseBits == 0;
    }


    BOOL Alive()
    {
        return IsKeyAlive( m_pKeyData, m_dwKeyLen );
    }


    BOOL Sync()
    {
        return UpdateBlob();
    }


private:


    BYTE * AllocBlob( SIZE_T cbSize )
    {
        return (BYTE *) Alloc_32BitCompatible( cbSize );
    }

    void DeallocBlob( BYTE * pBlob )
    {
        Free_32BitCompatible( pBlob );
    }



    void ClearBlob()
    {
        if( m_pBlob )
        {
            RemoveProp( m_hwndProp, m_pKeyString );
            DeallocBlob( m_pBlob );
            m_pBlob = NULL;
        }
    }

    BOOL UpdateBlob()
    {
        BYTE * pOldBlob = m_pBlob;
        BYTE * pNewBlob = CalcBlob();


        // We always update - even if pNewblob is NULL (ie. Calc failed)...
        if( pNewBlob )
        {
            SetProp( m_hwndProp, m_pKeyString, pNewBlob );
        }
        else
        {
            RemoveProp( m_hwndProp, m_pKeyString );
        }

        if( pOldBlob )
        {
            DeallocBlob( pOldBlob );
        }

        m_pBlob = pNewBlob;

        return TRUE;
    }

    BYTE * CalcBlob()
    {
        // If there are no properties being used, then we don't need anything at all.
        if( ! m_fPropInUseBits )
        {
            return NULL;
        }

        // First, measure how much space we need...
        
        // three constants...
        SIZE_T dwSize = sizeof( DWORD ) * 4; // size header, m_fPropInUseBits, m_fPropIsVariantBits, m_fContainerScopeBits
        
        // for each present property...
        for( int i = 0 ; i < NUMPROPS ; i++ )
        {
            if( IsBitSet( m_fPropInUseBits, i ) )
            {
                if( IsBitSet( m_fPropIsVariantBits, i ) )
                {
                    MemStreamMeasure_VARIANT( & dwSize, m_Props[ i ].m_var );
                }
                else
                {
                    MemStreamMeasure_DWORD( & dwSize );
                    MemStreamMeasure_Binary( & dwSize, m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen );
                }
            }
        }

        // Now allocate space...
        BYTE * pBlob = AllocBlob( dwSize );
        if( ! pBlob )
        {
            TraceError( TEXT("AccInfo::CalcBloc: AllocBlob returned NULL") );
            return NULL;
        }

        // Finally write the data to the allocated space...

        MemStream p( pBlob, dwSize );

        MemStreamWrite_DWORD( p, (DWORD) dwSize );
        MemStreamWrite_DWORD( p, m_fPropInUseBits );
        MemStreamWrite_DWORD( p, m_fPropIsVariantBits );
        MemStreamWrite_DWORD( p, m_fContainerScopeBits );

        for( int j = 0 ; j < NUMPROPS ; j++ )
        {
            if( IsBitSet( m_fPropInUseBits, j ) )
            {
                if( IsBitSet( m_fPropIsVariantBits, j ) )
                {
                    MemStreamWrite_VARIANT( p, m_Props[ j ].m_var );
                }
                else
                {
                    MemStreamWrite_DWORD( p, m_Props[ j ].m_ServerInfo.m_dwMarshalDataLen );
                    MemStreamWrite_Binary( p, m_Props[ j ].m_ServerInfo.m_pMarshalData, m_Props[ j ].m_ServerInfo.m_dwMarshalDataLen );
                }
            }
        }
        // If we later decide to allow any GUIDs (other than the well-known ones which have indices) as props,
        // we could add them here as GUID/VARIANT pairs.

        return pBlob;
    }


};


#define HWND_MESSAGE     ((HWND)-3)

typedef std::map< AccObjKeyRef, AccInfo * > AccInfoMapType;




class CPropMgrImpl
{

    AccInfoMapType      m_Map;

    BOOL                m_fSelfLocked;

    HWND                m_hwnd;

    int                 m_ref;

    static
    CPropMgrImpl * s_pThePropMgrImpl;

    friend void PropMgrImpl_Uninit();

public:

    CPropMgrImpl()
        : m_fSelfLocked( FALSE ),
          m_hwnd( NULL ),
          m_ref( 1 )
    {
        _Module.Lock();
    }

    BOOL Init()
    {
        TCHAR szWindowName[ 32 ];
        wsprintf( szWindowName, TEXT("MSAA_DA_%lx"), GetCurrentProcessId() );

        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = StaticWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = TEXT("MSAA_DA_Class");

        RegisterClass( & wc );

        CreateWindow( TEXT("MSAA_DA_Class"),
                      szWindowName,
                      0,
                      0, 0, 128, 128,
                      NULL, NULL, _Module.GetModuleInstance(), this );

        // Make this a message only window.  We don't care if it fails, win9x case.
        SetParent( m_hwnd, HWND_MESSAGE );

        SetTimer( m_hwnd, 1, 5 * 1000, NULL );

        return TRUE;
    }

    ~CPropMgrImpl()
    {
        s_pThePropMgrImpl = NULL;

        KillTimer( NULL, 1 );

        if( m_hwnd )
        {
            SetWindowLongPtr( m_hwnd, GWLP_USERDATA, NULL );
            DestroyWindow( m_hwnd );
        }

        _Module.Unlock();
    }


    void AddRef()
    {
        m_ref++;
    }

    void Release()
    {
        m_ref--;
        if( m_ref == 0 )
        {
            delete this;
        }
    }


    static
    CPropMgrImpl * GetThePropMgrImpl()
    {
        if( ! s_pThePropMgrImpl )
        {
            s_pThePropMgrImpl = new CPropMgrImpl();
            if( ! s_pThePropMgrImpl )
            {
                TraceError( TEXT("CPropMgrImpl::GetThePropMgrImpl: new returned NULL") );
                return NULL;
            }

            if( ! s_pThePropMgrImpl->Init() )
            {
                delete s_pThePropMgrImpl;
                s_pThePropMgrImpl = NULL;
                TraceError( TEXT("CPropMgrImpl::GetThePropMgrImpl: s_pThePropMgrImpl->Init() returned FALSE") );
                return NULL;
            }
        }
        else
        {
            // We only addref the second and subsequent times that we
            // hand out a pointer.
            // The first time, we use the ref the the object had when it
            // was created.
            // (This static ptr s_pThePropMgrImpl is a weak reference.)
            s_pThePropMgrImpl->AddRef();
        }

        return s_pThePropMgrImpl;
    }




    void Clean()
    {
        // Go through the elements in the map...

        for( AccInfoMapType::iterator i = m_Map.begin() ; i != m_Map.end() ; )
        {
            // check if the key is still valid...
            if( ! i->second->Alive() )
            {
                AccInfoMapType::iterator t = i;
                i++;

                AccInfo * pInfo = t->second;
                m_Map.erase( t );

                delete pInfo;
            }
            else
            {
                i++;
            }
        }

        // Unload if necessary
        CheckRef();
    }

    void ClearAll()
    {
        for( AccInfoMapType::iterator i = m_Map.begin() ; i != m_Map.end() ; )
        {
            AccInfoMapType::iterator t = i;
            i++;

            AccInfo * pInfo = t->second;
            m_Map.erase( t );

            delete pInfo;
        }

        // Unload if necessary
        CheckRef();
    }


    void CheckRef()
    {
        if( m_Map.empty() )
        {
            if( m_fSelfLocked )
            {
                m_fSelfLocked = FALSE;
                Release();
            }
        }
        else
        {
            if( ! m_fSelfLocked )
            {
                m_fSelfLocked = TRUE;
                AddRef();
            }
        }
    }


    AccInfo * LookupKey( const BYTE * pKeyData, DWORD dwKeyLen, BOOL fCreate )
    {
        AccInfoMapType::iterator i;

        AccObjKeyRef keyref( pKeyData, dwKeyLen );
    
        i = m_Map.find( keyref );

        if( i == m_Map.end() || i->first != keyref )
        {
            // insert...
            if( fCreate )
            {
                AccInfo * pInfo = new AccInfo;
                if( ! pInfo )
                {
                    TraceError( TEXT("CPropMgrImpl::LookupKey: new returned NULL") );
                    return NULL;
                }

                // If the key is associated with a HWND, use that; otherwise attach the key to our own window.
                HWND hwndProp;
                if( ! DecodeHwndKey( pKeyData, dwKeyLen, & hwndProp, NULL, NULL ) )
                {
                    hwndProp = m_hwnd;
                }

                pInfo->Init( pKeyData, dwKeyLen, hwndProp );

                m_Map.insert( std::make_pair( pInfo->GetKeyRef(), pInfo ) );

                // make sure we're locked...
                CheckRef();

                return pInfo;
            }
            else
            {
                return NULL;
            }
        }
        else
        {
            return i->second;
        }
    }

    void RemoveEntry( AccInfo * pInfo )
    {
        m_Map.erase( pInfo->GetKeyRef() );

        // if we're empty, we can unlock the module...
        CheckRef();
    }


    HRESULT ValidateArray( const void * pvStart, int cLen, int elsize, LPCTSTR pMethodName, LPCTSTR pPtrName, LPCTSTR pLenName )
    {
        // Parameter checking...

        if( ! pvStart )
        {
            TraceParam( TEXT("%s: %s is NULL"), pMethodName, pPtrName );
            return E_POINTER;
        }
        if( cLen <= 0 )
        {
            TraceParam( TEXT("%s: %s is <= 0"), pMethodName, pLenName );
            return E_INVALIDARG;
        }
        if( IsBadReadPtr( pvStart, cLen * elsize ) )
        {
            TraceParam( TEXT("%s: %s/%s points to non-readable memory"), pMethodName, pPtrName, pLenName );
            return E_POINTER;
        }

        return S_OK;
    }



    HRESULT SetPropValue( const BYTE * pKeyData,
                          DWORD dwKeyLen,
                          MSAAPROPID   idProp,
                          VARIANT *    pvarValue )
    {
        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("SetPropValue"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        if( pvarValue == NULL )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: pvarValue is NULL") );
            return E_POINTER;
        }



        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, TRUE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        int idxProp = IndexFromProp( idProp );
        if( idxProp == -1 )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: unknown prop") );
            return E_INVALIDARG;
        }

        // check type...
        if( pvarValue->vt != g_PropInfo[ idxProp ].m_Type )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: incorrect type for property") );
            return E_INVALIDARG;
        }

        // Do we support setting this property directly?
        // (Some can be returned via callbacks only, not set directly)
        if( ! g_PropInfo[ idxProp ].m_fSupportSetValue )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: prop does not support direct set") );
            return E_INVALIDARG;
        }

        if( ! pInfo->SetPropValue( idxProp, pvarValue ) )
        {
            return E_FAIL;
        }

        pInfo->Sync();

        return S_OK;
    }


    HRESULT ClearProps( const BYTE * pKeyData,
                        DWORD dwKeyLen,
                        const MSAAPROPID *  paProps,
                        int                 cProps )
    {
        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("ClearProps"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        hr = ValidateArray( paProps, cProps, sizeof(MSAAPROPID), TEXT("ClearProps"), TEXT("paProps"), TEXT("cProps") );
        if( hr != S_OK )
            return hr;



        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, FALSE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        BOOL fUnknownProp = FALSE;

        for( int i = 0 ; i < cProps ; i++ )
        {
            int idxProp = IndexFromProp( paProps[ i ] );
            if( idxProp == -1 )
            {
                TraceParam( TEXT("CPropMgrImpl::ClearProps: unknown prop") );
                fUnknownProp = TRUE;
                // Continue and clear the other props that we do recognize...
            }
            else
            {
                pInfo->ClearProp( idxProp );
            }
        }

        pInfo->Sync();

        if( pInfo->IsEmpty() )
        {
            RemoveEntry( pInfo );
        }

        return fUnknownProp ? E_INVALIDARG : S_OK;
    }


    HRESULT SetPropServer( const BYTE *         pKeyData,
                           DWORD                dwKeyLen,

                           const MSAAPROPID *   paProps,
                           int                  cProps,

                           const BYTE *         pMarshalData,
                           int                  dwMarshalDataLen,

                           AnnoScope            annoScope )
    {

        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("SetPropServer"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        hr = ValidateArray( paProps, cProps, sizeof(MSAAPROPID), TEXT("SetPropServer"), TEXT("paProps"), TEXT("cProps") );
        if( hr != S_OK )
            return hr;


        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, TRUE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        // TODO - make this two-pass - validate props first,
        // add them later - to make this atomic.
        // (either all or none of the props should be registered)
        for( int i = 0 ; i < cProps ; i++ )
        {
            int idxProp = IndexFromProp( paProps[ i ] );
            if( idxProp == -1 )
            {
                TraceParam( TEXT("CPropMgrImpl::SetPropServer: unknown prop") );
                return E_INVALIDARG;
            }

            if( ! pInfo->SetPropServer( idxProp, pMarshalData, dwMarshalDataLen, annoScope ) )
            {
                return E_FAIL;
            }
        }

        pInfo->Sync();

        return S_OK;
    }


    LRESULT WndProc( HWND hwnd,
                     UINT uMsg,
                     WPARAM wParam,
                     LPARAM lParam )
    {
        if( uMsg == WM_TIMER )
        {
            Clean();
        }

        return DefWindowProc( hwnd, uMsg, wParam, lParam );
    }

    static
    LRESULT CALLBACK StaticWndProc( HWND hwnd,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam )
    {
        CPropMgrImpl * pThis = (CPropMgrImpl *) GetWindowLongPtr( hwnd, GWLP_USERDATA );
        if( pThis )
        {
            return pThis->WndProc( hwnd, uMsg, wParam, lParam );
        }
        else if( uMsg == WM_NCCREATE )
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
            pThis = (CPropMgrImpl *)lpcs->lpCreateParams;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (DWORD_PTR) pThis );
            pThis->m_hwnd = hwnd;
            return pThis->WndProc( hwnd, uMsg, wParam, lParam );
        }

        return DefWindowProc( hwnd, uMsg, wParam, lParam );
    }

};



CPropMgrImpl * CPropMgrImpl::s_pThePropMgrImpl = NULL;






// If all annotated windows disappear before the app shuts down, or if all
// annotations are cleared, then everything gets cleaned up nicely.
//
// However, if CoUninitialize is called while controls are still annotated,
// we will need to explicitly clean up before COM unloads our dll.
//
// (If we don't, then (a) we leak memory, and (b) the DA window will
// still receive WM_TIMER messages to a wndproc that has been unloaded
// causin ga fault.)
//
// This is called from DLLMain's PROCESS_DETACH.

void PropMgrImpl_Uninit()
{
    // Check if there is a Mgr in the first place...
    CPropMgrImpl * pTheMgr = CPropMgrImpl::s_pThePropMgrImpl;

    // No mgr - nothing to clean up.
    if( ! pTheMgr )
        return;

    // AddRef it, to keep it alive while we're using it.
    pTheMgr->AddRef();

    // Clear all properties
    pTheMgr->ClearAll();

    // This release will cause the mgr to delete itself, since it is now empty.
    pTheMgr->Release();
}






CPropMgr::CPropMgr()
{
    IMETHOD( TEXT("CPropMgr::CPropMgr") );

    m_pMgrImpl = CPropMgrImpl::GetThePropMgrImpl();
    if( ! m_pMgrImpl )
    {
        TraceError( TEXT("CPropMgr::CPropMgr: CPropMgrImpl::GetThePropMgrImpl returned NULL") );
    }
}


CPropMgr::~CPropMgr()
{
    IMETHOD( TEXT("CPropMgr::~CPropMgr") );

    if( m_pMgrImpl )
    {
        m_pMgrImpl->Release();
    }
}



HRESULT STDMETHODCALLTYPE
CPropMgr::SetPropValue (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetPropValue") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    return m_pMgrImpl->SetPropValue( pIDString, dwIDStringLen, idProp, & var );
}



HRESULT STDMETHODCALLTYPE
CPropMgr::SetPropServer (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetPropServer"), TEXT("cProps=%d"), cProps );

    if( ! m_pMgrImpl )
        return E_FAIL;


    const BYTE * pData;
    DWORD dwDataLen;
    MarshalState mstate;

    // We use strong table marshalling to keep the object alive until we free it.
    // (Ownership is actually transferred to the property manager, which will release it when
    // either the property is cleared explicity, or after the HWND dies and it gets swept away.)
    HRESULT hr = MarshalInterface( IID_IAccPropServer, pServer, MSHCTX_LOCAL, MSHLFLAGS_TABLESTRONG,
                                   & pData, & dwDataLen, & mstate );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("CPropMgr::SetPropServer: MarshalInterface failed") );
        return hr;
    }


    hr = m_pMgrImpl->SetPropServer( pIDString, dwIDStringLen, paProps, cProps, pData, dwDataLen, annoScope );

    MarshalInterfaceDone( & mstate );

    return hr;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::ClearProps (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearProps"), TEXT("cProps=%d"), cProps );

    if( ! m_pMgrImpl )
        return E_FAIL;

    return m_pMgrImpl->ClearProps( pIDString, dwIDStringLen, paProps, cProps );
}


// Quick OLEACC/HWND-based functionality

HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndProp (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,
    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndProp") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return m_pMgrImpl->SetPropValue( HwndKey, HWNDKEYSIZE, idProp, & var );
}


HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndPropStr (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,
    MSAAPROPID          idProp,
    LPCWSTR             str
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndPropStr") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    // Need to convert the LPCWSTR to a BSTR before we can put it into a variant...
    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( str );
    if( ! var.bstrVal )
    {
        TraceError( TEXT("CPropMgr::SetHwndPropStr: SysAllocString failed") );
        return E_OUTOFMEMORY;
    }

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );
    
    HRESULT hr = m_pMgrImpl->SetPropValue( HwndKey, HWNDKEYSIZE, idProp, & var );
    SysFreeString( var.bstrVal );
    return hr;
}




HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndPropServer (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndPropServer") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return SetPropServer( HwndKey, HWNDKEYSIZE, paProps, cProps, pServer, annoScope );
}

HRESULT STDMETHODCALLTYPE
CPropMgr::ClearHwndProps (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearHwndProps") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return ClearProps( HwndKey, HWNDKEYSIZE, paProps, cProps );
}



// Methods for composing/decomposing a HWND-based key...

HRESULT STDMETHODCALLTYPE
CPropMgr::ComposeHwndIdentityString (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    BYTE **             ppIDString,
    DWORD *             pdwIDStringLen
)
{
    IMETHOD( TEXT("CPropMgr::ComposeHwndIdentityString") );

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *)CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        TraceError( TEXT("CPropMgr::ComposeHwndIdentityString: CoTaskMemAlloc failed") );
        return E_OUTOFMEMORY;
    }

    MakeHwndKey( pKeyData, hwnd, idObject, idChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::DecomposeHwndIdentityString (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    HWND *              phwnd,
    DWORD *             pidObject,
    DWORD *             pidChild
)
{
    IMETHOD( TEXT("CPropMgr::DecomposeHwndIdentityString") );

    if( ! DecodeHwndKey( pIDString, dwIDStringLen, phwnd, pidObject, pidChild ) )
    {
        TraceParam( TEXT("CPropMgr::DecomposeHwndIdentityString: not a valid HWND id string") );
        return E_INVALIDARG;
    }

    return S_OK;
}



// Quick OLEACC/HMENU-based functionality

HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuProp (
    HMENU               hmenu,
    DWORD               idChild,
    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuProp") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return m_pMgrImpl->SetPropValue( HmenuKey, HMENUKEYSIZE, idProp, & var );
}


HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuPropStr (
    HMENU               hmenu,
    DWORD               idChild,
    MSAAPROPID          idProp,
    LPCWSTR             str
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuPropStr") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    // Need to convert the LPCWSTR to a BSTR before we can put it into a variant...
    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( str );
    if( ! var.bstrVal )
    {
        TraceError( TEXT("CPropMgr::SetHmenuPropStr: SysAllocString failed") );
        return E_OUTOFMEMORY;
    }

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );
    
    HRESULT hr = m_pMgrImpl->SetPropValue( HmenuKey, HMENUKEYSIZE, idProp, & var );
    SysFreeString( var.bstrVal );
    return hr;
}




HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuPropServer (
    HMENU               hmenu,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuPropServer") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return SetPropServer( HmenuKey, HMENUKEYSIZE, paProps, cProps, pServer, annoScope );
}

HRESULT STDMETHODCALLTYPE
CPropMgr::ClearHmenuProps (
    HMENU               hmenu,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearHmenuProps") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return ClearProps( HmenuKey, HMENUKEYSIZE, paProps, cProps );
}


// Methods for composing/decomposing a HMENU-based key...


HRESULT STDMETHODCALLTYPE
CPropMgr::ComposeHmenuIdentityString (
    HMENU               hmenu,
    DWORD               idChild,

    BYTE **             ppIDString,
    DWORD *             pdwIDStringLen
)
{
    IMETHOD( TEXT("CPropMgr::ComposeHmenuIdentityString") );

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *)CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        TraceError( TEXT("CPropMgr::ComposeHmenuIdentityString: CoTaskMemAlloc failed") );
        return E_OUTOFMEMORY;
    }

    MakeHmenuKey( pKeyData, GetCurrentProcessId(), hmenu, idChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::DecomposeHmenuIdentityString (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    HMENU *             phmenu,
    DWORD *             pidChild
)
{
    IMETHOD( TEXT("CPropMgr::DecomposeHmenuIdentityString") );

    if( ! DecodeHmenuKey( pIDString, dwIDStringLen, NULL, phmenu, pidChild ) )
    {
        TraceParam( TEXT("CPropMgr::DecomposeHmenuIdentityString: not a valid HMENU id string") );
        return E_INVALIDARG;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_mem.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Mem
//
//  Helper classes/routines for accessing serialized memory
//
// --------------------------------------------------------------------------




inline
SIZE_T AlignUp( SIZE_T s, SIZE_T alignment )
{
    // alignment must be a power of 2...
    Assert( alignment == 1      // byte
         || alignment == 2      // word
         || alignment == 4      // dword
         || alignment == 8 );   // 64bit
                                // Shouldn't need any others for the moment.

    return ( s + alignment - 1 ) & ~ ( alignment - 1 );
}


inline
BYTE * AlignUp( BYTE * p, SIZE_T alignment )
{
    return (BYTE *) AlignUp( (SIZE_T) p, (SIZE_T) alignment );
}







#ifndef UNICODE
inline
int WStrLen( LPCWSTR pWStr )
{
    LPCWSTR pWScan = pWStr;
    while( *pWScan != '\0' )
        pWScan++;
    return pWScan - pWStr;
}
#endif



class MemStream
{
//    friend class MemStream;

    BYTE *  m_pCurPos;
    SIZE_T  m_cbRemaining;



    BOOL Check( SIZE_T unit_size, int count = 1 )
    {
        // Check that we're aligned properly... - do this *before*
        // checking size left...
        BYTE * pNewPos = AlignUp( m_pCurPos, unit_size );

        // Work out how much would remain, after aligning...
        // (This can be negative, eg. if aligning pushes us over end...)
        SIZE_T cbNewRemaining = m_cbRemaining - ( pNewPos - m_pCurPos );

        if( unit_size * count <= cbNewRemaining )
        {
            // There's space available...
            m_cbRemaining = cbNewRemaining;
            m_pCurPos = pNewPos;
            return TRUE;
        }
        else
        {
            // No space left
            m_cbRemaining = 0;
            return FALSE;
        }
    }

    void Advance( SIZE_T size, int count = 1 )
    {
        m_pCurPos += size * count;
        m_cbRemaining -= size * count;
    }



public:


    MemStream( BYTE * pBlock, SIZE_T cbSize )
    {
        m_pCurPos = pBlock;
        m_cbRemaining = cbSize;
    }


    MemStream( const MemStream & x )
    {
        m_pCurPos = x.m_pCurPos;
        m_cbRemaining = x.m_cbRemaining;
    }


    //
    // Basic unit read/write operations...
    //

    BOOL Write_DWORD( DWORD x )
    {
        if( ! Check( sizeof( x ) ) )
            return FALSE;
        *((DWORD *) m_pCurPos ) = x;
        Advance( sizeof( x ) );
        return TRUE;
    }

    BOOL Read_DWORD( DWORD * px )
    {
        if( ! Check( sizeof( *px ) ) )
            return FALSE;
        *px = *((DWORD *) m_pCurPos );
        Advance( sizeof( *px ) );
        return TRUE;
    }


    BOOL Skip_DWORD()
    {
        if( ! Check( sizeof( DWORD ) ) )
            return FALSE;
        Advance( sizeof( DWORD ) );
        return TRUE;
    }


    BOOL Write_WORD( WORD x )
    {
        if( ! Check( sizeof( x ) ) )
            return FALSE;
        *((WORD *) m_pCurPos ) = x;
        Advance( sizeof( x ) );
        return TRUE;
    }

    BOOL Read_WORD( WORD * px )
    {
        if( ! Check( sizeof( *px ) ) )
            return FALSE;
        *px = *((WORD *) m_pCurPos );
        Advance( sizeof( *px ) );
        return TRUE;
    }

    BOOL Skip_WORD()
    {
        if( ! Check( sizeof( WORD ) ) )
            return FALSE;
        Advance( sizeof( WORD ) );
        return TRUE;
    }


    BOOL Write_Binary( const BYTE * pData, int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;

        memcpy( m_pCurPos, pData, len );
        Advance( len );
        return TRUE;
    }

    BOOL Read_Binary( BYTE * pData, int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;

        memcpy( pData, m_pCurPos, len );
        Advance( len );
        return TRUE;
    }

    BOOL Skip_Binary( int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;
        Advance( len );
        return TRUE;
    }

    const BYTE * GetBinaryPtr( int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return NULL;

        return m_pCurPos;
    }
};



inline BOOL MemStreamWrite_DWORD    ( MemStream & ptr, DWORD x )     {   return ptr.Write_DWORD( x );    }
inline BOOL MemStreamRead_DWORD     ( MemStream & ptr, DWORD * px )  {   return ptr.Read_DWORD( px );    }
inline BOOL MemStreamSkip_DWORD     ( MemStream & ptr )              {   return ptr.Skip_DWORD(); }

inline BOOL MemStreamWrite_WORD     ( MemStream & ptr, WORD x )      {   return ptr.Write_WORD( x );     }
inline BOOL MemStreamRead_WORD      ( MemStream & ptr, WORD * px )   {   return ptr.Read_WORD( px );     }
inline BOOL MemStreamSkip_WORD      ( MemStream & ptr )              {   return ptr.Skip_WORD();         }

inline BOOL MemStreamWrite_Binary   ( MemStream & ptr, const BYTE * pData, int Len ) {   return ptr.Write_Binary( pData, Len );  }
inline BOOL MemStreamRead_Binary    ( MemStream & ptr, BYTE * pData, int Len )       {   return ptr.Read_Binary( pData, Len );   }
inline BOOL MemStreamSkip_Binary    ( MemStream & ptr, int Len )                     {   return ptr.Skip_Binary( Len );          }

inline const BYTE * MemStream_GetBinaryPtr( MemStream & ptr, int len ) {    return ptr.GetBinaryPtr( len ); }


// pcbSize is an in/out parameter; it is adjusted to account for allignmenmt plus the addition of an item of the given type.
inline
void MemStreamMeasure_DWORD ( SIZE_T * pcbSize, int count = 1 )
{
    *pcbSize = AlignUp( *pcbSize, sizeof( DWORD ) ) + sizeof( DWORD ) * count;
}

inline
void MemStreamMeasure_WORD ( SIZE_T * pcbSize, int count = 1 )
{
    *pcbSize = AlignUp( *pcbSize, sizeof( WORD ) ) + sizeof( WORD ) * count;
}

inline
void MemStreamMeasure_Binary ( SIZE_T * pcbSize, int Len )
{
    *pcbSize += Len;
}





inline
BOOL MemStreamWrite_VARIANT( MemStream & ptr, VARIANT & x )
{
    if( ! MemStreamWrite_WORD( ptr, x.vt ) )
        return FALSE;
    switch( x.vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
#ifdef UNICODE
            DWORD len = lstrlen( x.bstrVal );
#else
            DWORD len = WStrLen( x.bstrVal );
#endif
            // Note - does not include terminating NUL...
            if( ! MemStreamWrite_DWORD( ptr, len ) ||
                ! MemStreamWrite_Binary( ptr, (BYTE *) x.bstrVal, len * sizeof( WCHAR ) ) )
                return FALSE;
            break;
        }

        case VT_I4:
        {
            if( ! MemStreamWrite_DWORD( ptr, x.lVal ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}


inline
BOOL MemStreamRead_VARIANT( MemStream & ptr, VARIANT * px )
{
    if( ! MemStreamRead_WORD( ptr, & px->vt ) )
        return FALSE;

    switch( px->vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
            DWORD len;
            if( ! MemStreamRead_DWORD( ptr, & len ) )
                return FALSE;

            px->bstrVal = SysAllocStringLen( NULL, len ); // 1 for NUL is added automatically by SysAllocStringLen
            if( ! MemStreamRead_Binary( ptr, (BYTE *) px->bstrVal, len * sizeof( WCHAR ) ) )
            {
                SysFreeString( px->bstrVal );
                return FALSE;
            }

            px->bstrVal[ len ] = '\0';

            break;
        }

        case VT_I4:
        {
            if( ! MemStreamRead_DWORD( ptr, reinterpret_cast< DWORD * >( & px->lVal ) ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}


inline
BOOL MemStreamSkip_VARIANT( MemStream & ptr )
{
    WORD vt;
    if( ! MemStreamRead_WORD( ptr, & vt ) )
        return FALSE;

    switch( vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
            DWORD len;
            if( ! MemStreamRead_DWORD( ptr, & len ) ||
                ! MemStreamSkip_Binary( ptr, len * sizeof( WCHAR ) ) )
                return FALSE;
            break;
        }

        case VT_I4:
        {
            if( ! MemStreamSkip_DWORD( ptr ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}



inline
void MemStreamMeasure_VARIANT( SIZE_T * pSize, VARIANT & x )
{
    MemStreamMeasure_WORD( pSize );
    switch( x.vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
#ifdef UNICODE
            DWORD len = lstrlen( x.bstrVal );
#else
            DWORD len = WStrLen( x.bstrVal );
#endif
            MemStreamMeasure_DWORD( pSize );
            MemStreamMeasure_Binary( pSize, len * sizeof( WCHAR ) );
            break;
        }

        case VT_I4:
        {
            MemStreamMeasure_DWORD( pSize );
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }
}



inline
BOOL MemStreamWrite_GUID( MemStream & ptr, const GUID & x )
{
    return MemStreamWrite_DWORD( ptr, x.Data1 )
        && MemStreamWrite_WORD( ptr, x.Data2 )
        && MemStreamWrite_WORD( ptr, x.Data3 )
        && MemStreamWrite_Binary( ptr, x.Data4, 8 );
}

inline
BOOL MemStreamRead_GUID( MemStream & ptr, GUID * px )
{
    return MemStreamRead_DWORD( ptr, & px->Data1 )
        && MemStreamRead_WORD( ptr, & px->Data2 )
        && MemStreamRead_WORD( ptr, & px->Data3 )
        && MemStreamRead_Binary( ptr, px->Data4, 8 );
}

inline
void MemStreamMeasure_GUID( SIZE_T * pSize )
{
    MemStreamMeasure_DWORD( pSize, 3 );
    MemStreamMeasure_Binary( pSize, 8 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_util.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Util
//
//  Utility and shared code and data used by both the exe-server and the
//  shared memory client.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include "PropMgr_Util.h"


// Note: Keep this array's size in sync with NUMPROPS #defined in the .h file
PropInfo g_PropInfo [ NUMPROPS ] =
{
    { & PROPID_ACC_NAME             , VT_BSTR,      TRUE    },
    { & PROPID_ACC_VALUE            , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DESCRIPTION      , VT_BSTR,      TRUE    },
    { & PROPID_ACC_ROLE             , VT_I4,        TRUE    },
    { & PROPID_ACC_STATE            , VT_I4,        TRUE    },
    { & PROPID_ACC_HELP             , VT_BSTR,      TRUE    },
    { & PROPID_ACC_KEYBOARDSHORTCUT , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DEFAULTACTION    , VT_BSTR,      TRUE    },

    { & PROPID_ACC_HELPTOPIC        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_FOCUS            , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_SELECTION        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_PARENT           , VT_EMPTY,     FALSE   },

    { & PROPID_ACC_NAV_UP           , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_DOWN         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_LEFT         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_RIGHT        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_PREV         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_NEXT         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_FIRSTCHILD   , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_LASTCHILD    , VT_EMPTY,     FALSE   },

    { & PROPID_ACC_VALUEMAP         , VT_BSTR,      TRUE    },
    { & PROPID_ACC_ROLEMAP          , VT_BSTR,      TRUE    },
    { & PROPID_ACC_STATEMAP         , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DESCRIPTIONMAP   , VT_BSTR,      TRUE    },

    { & PROPID_ACC_DODEFAULTACTION  , VT_EMPTY,     FALSE   },
};










int IndexFromProp( const MSAAPROPID & idProp )
{
    for( int i = 0 ; i < NUMPROPS ; i++ )
    {
        if( *g_PropInfo[ i ].m_idProp == idProp )
            return i;
    }

    return -1;
}








LPTSTR MakeKeyString( const BYTE * pKeyData, DWORD dwKeyLen )
{
    const LPCTSTR szHexChars = TEXT("0123456789ABCDEF");

    LPTSTR pStart = new TCHAR [ ( dwKeyLen * 2 ) + 5 + 1 ]; // +5 for MSAA_, +1 for NUL
    if( pStart == NULL )
    {
        return NULL;
    }

    memcpy( pStart, TEXT("MSAA_"), sizeof(TCHAR) * 5 );
    LPTSTR pScan = pStart + 5;

    while( dwKeyLen-- )
    {
        *pScan++ = szHexChars[ *pKeyData >> 4 ];   // High nybble
        *pScan++ = szHexChars[ *pKeyData & 0x0F ]; // Low nybble
        pKeyData++;
    }

    *pScan = '\0';

    return pStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_util.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Util
//
//  Utility and shared code and data used by both the exe-server and the
//  shared memory client.
//
// --------------------------------------------------------------------------




// All identity strings start with a DWORD to indicate the naming scheme...

enum
{
    MSAA_ID_HWND  = 0x80000001,    // OLEACC's HWND naming scheme
    MSAA_ID_HMENU = 0x80000002,    // OLEACC's HMENU naming scheme
};




// Note: Keep this in sync with size of the g_PropInfo array in the .cpp file
// Also: We use these as bit-indices into a DWORD (see dwUsedBits in
// PropMgr_Client.cpp), so we're limited to 32 for the moment.
enum PROPINDEX
{
    PROPINDEX_NAME,
    PROPINDEX_VALUE,
    PROPINDEX_DESCRIPTION,
    PROPINDEX_ROLE,
    PROPINDEX_STATE,
    PROPINDEX_HELP,
    PROPINDEX_KEYBOARDSHORTCUT,
    PROPINDEX_DEFAULTACTION,

    PROPINDEX_HELPTOPIC,
    PROPINDEX_FOCUS,
    PROPINDEX_SELECTION,
    PROPINDEX_PARENT,

    PROPINDEX_NAV_UP,
    PROPINDEX_NAV_DOWN,
    PROPINDEX_NAV_LEFT,
    PROPINDEX_NAV_RIGHT,
    PROPINDEX_NAV_PREV,
    PROPINDEX_NAV_NEXT,
    PROPINDEX_NAV_FIRSTCHILD,
    PROPINDEX_NAV_LASTCHILD,

    PROPINDEX_VALUEMAP,
    PROPINDEX_ROLEMAP,
    PROPINDEX_STATEMAP,
    PROPINDEX_DESCRIPTIONMAP,

    PROPINDEX_DODEFAULTACTION,

    // By the magic of enums (they start with 0), this entry will have a value
    // equal to the number of entries before it.
    NUMPROPS
};



// If m_fSupportSetValue is false, then the property can only be returned from
// a server callback; it can't be set using SetPropValue().
struct PropInfo
{
    const MSAAPROPID *  m_idProp;
    short               m_Type;
    BOOL                m_fSupportSetValue;
};

extern PropInfo g_PropInfo [ NUMPROPS ];



// returns -1 if not found
int IndexFromProp( const MSAAPROPID & idProp );






// Utility for generating Win32/HWND/OLEACC keys...
#define HWNDKEYSIZE    (sizeof(DWORD)*4)

inline
void MakeHwndKey( BYTE * pDest, HWND hwnd, DWORD idObject, DWORD idChild )
{
    DWORD adw [ 4 ] = { (DWORD)MSAA_ID_HWND, (DWORD) HandleToLong( hwnd ), idObject, idChild };
    memcpy( pDest, adw, sizeof( adw ) );
}

inline 
BOOL DecodeHwndKey( BYTE const * pSrc, DWORD dwLen, HWND * phwnd, DWORD * pidObject, DWORD * pidChild )
{
    if( dwLen != HWNDKEYSIZE )
    {
        return FALSE;
    }

    DWORD adw [ 4 ];
    memcpy( adw, pSrc, HWNDKEYSIZE );

    if( adw[ 0 ] != MSAA_ID_HWND )
    {
        return FALSE;
    }

    if( phwnd )
    {
        *phwnd = (HWND)LongToHandle(adw[ 1 ]);
    }

    if( pidObject )
    {
        *pidObject = adw[ 2 ];
    }

    if( pidChild )
    {
        *pidChild = adw[ 3 ];
    }

    return TRUE;   
}




// Utility for generating OLEACC's HMENU keys...
#define HMENUKEYSIZE    (sizeof(DWORD)*4)

inline
void MakeHmenuKey( BYTE * pDest, DWORD dwpid, HMENU hmenu, DWORD idChild )
{
    DWORD adw [ 4 ] = { (DWORD)MSAA_ID_HMENU, dwpid, (DWORD) HandleToLong( hmenu ), idChild };
    memcpy( pDest, adw, sizeof( adw ) );
}

inline 
BOOL DecodeHmenuKey( BYTE const * pSrc, DWORD dwLen, DWORD * pdwpid, HMENU * phmenu, DWORD * pidChild )
{
    if( dwLen != HMENUKEYSIZE )
    {
        return FALSE;
    }

    DWORD adw [ 4 ];
    memcpy( adw, pSrc, HMENUKEYSIZE );

    if( adw[ 0 ] != MSAA_ID_HMENU )
    {
        return FALSE;
    }

    if( pdwpid )
    {
        *pdwpid = adw[ 1 ];
    }

    if( phmenu )
    {
        *phmenu = (HMENU)LongToHandle(adw[ 2 ]);
    }

    if( pidChild )
    {
        *pidChild = adw[ 3 ];
    }

    return TRUE;   
}




//  Returns a ASCII-fied version of the given key - eg.
//  something like "MSAA_001110034759FAE03...."
//  Caller's responsibility to release with  delete [ ].
//
//  eg.
//      LPTSTR pStr = MakeKeyString( pKeyData, dwKeyLen );
//      if( pStr )
//      {
//          ... do stuff with pStr here ...
//          delete [ ] pStr;
//      }
//

LPTSTR MakeKeyString( const BYTE * pKeyData, DWORD dwKeyLen );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\remoteproxyfactory.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// RemoteProxyFactory.h : Declaration of the CRemoteProxyFactory

#ifndef __REMOTEPROXYFACTORY_H_
#define __REMOTEPROXYFACTORY_H_

#include "resource.h"       // main symbols
#include "oleacc_p.h"

extern "C" {
BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole );
}

/////////////////////////////////////////////////////////////////////////////
// CRemoteProxyFactory
class ATL_NO_VTABLE CRemoteProxyFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
#ifdef _WIN64
	public CComCoClass<CRemoteProxyFactory, &CLSID_RemoteProxyFactory64>,
#else
	public CComCoClass<CRemoteProxyFactory, &CLSID_RemoteProxyFactory32>,
#endif
	public IDispatchImpl<IRemoteProxyFactory, &IID_IRemoteProxyFactory, &LIBID_REMOTEPROXY6432Lib>
{
public:
	CRemoteProxyFactory(){}

#ifdef _WIN64
DECLARE_REGISTRY_RESOURCEID( IDR_REMOTEPROXYFACTORY64 )
#else
DECLARE_REGISTRY_RESOURCEID( IDR_REMOTEPROXYFACTORY32 )
#endif
DECLARE_NOT_AGGREGATABLE(CRemoteProxyFactory)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteProxyFactory)
	COM_INTERFACE_ENTRY(IRemoteProxyFactory)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRemoteProxyFactory
public:

    STDMETHOD(AccessibleProxyFromWindow)(
		/*[in]*/ DWORD dwhwnd, 
		/*[in]*/ long lObjectId, 
		/*[out]*/ IUnknown **ppUnk
	)
	{
		return CreateStdAccessibleObject(
			  (HWND)LongToHandle( dwhwnd )
			, lObjectId
			, IID_IUnknown
			, reinterpret_cast<void **>(ppUnk));
	}

	STDMETHOD(GetStateImageMapEnt)(
        /* [in] */ DWORD dwhwnd,
        /* [in] */ long iImage,
        /* [out] */ DWORD *pdwState,
        /* [out] */ DWORD *pdwRole
	)
	{
        if( GetStateImageMapEnt_SameBitness( (HWND)LongToHandle( dwhwnd ), iImage,
                                             pdwState,
                                             pdwRole ) )
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }
	}
};

#endif //__REMOTEPROXYFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oleacc.rc
//
#define IDR_TYPELIB1                    101
#define IDR_REMOTEPROXYFACTORY32        102
#define IDR_REMOTEPROXYFACTORY64        103
#define IDR_PROPMGR                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\propmgr_impl.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Impl
//
//  Property manager class
//
// --------------------------------------------------------------------------



// PropMgrImpl.h : Declaration of the CPropMgr

#ifndef __PROPMGR_H_
#define __PROPMGR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPropMgr

// Internal class CPropMgrImpl does all the real work, CPropMgr just wraps it,
// and provides extra 'convenience' methods which are implemented in terms
// of CPropMgrImpl's core set of methods.

class CPropMgrImpl;

class ATL_NO_VTABLE CPropMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropMgr, &CLSID_AccPropServices>,

    public IAccPropServices
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROPMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPropMgr)
	COM_INTERFACE_ENTRY(IAccPropServices)
END_COM_MAP()


	CPropMgr();
	~CPropMgr();

    // IAccPropServices

    HRESULT STDMETHODCALLTYPE SetPropValue (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        MSAAPROPID          idProp,
        VARIANT             var
    );


    HRESULT STDMETHODCALLTYPE SetPropServer (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );


    HRESULT STDMETHODCALLTYPE ClearProps (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        const MSAAPROPID *  paProps,
        int                 cProps
    );

    // Quick OLEACC/HWND-based functionality

    HRESULT STDMETHODCALLTYPE SetHwndProp (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,
        MSAAPROPID          idProp,
        VARIANT             var
    );

    HRESULT STDMETHODCALLTYPE SetHwndPropStr (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,
        MSAAPROPID          idProp,
        LPCWSTR             bstr
    );

    HRESULT STDMETHODCALLTYPE SetHwndPropServer (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );

    HRESULT STDMETHODCALLTYPE ClearHwndProps (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps
    );



    // Methods for composing/decomposing a HWND based IdentityString...

    HRESULT STDMETHODCALLTYPE ComposeHwndIdentityString (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        BYTE **             ppIDString,
        DWORD *             pdwIDStringLen
    );


    HRESULT STDMETHODCALLTYPE DecomposeHwndIdentityString (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        HWND *              phwnd,
        DWORD *             pidObject,
        DWORD *             pidChild
    );


    // Quick OLEACC/HMENU-based functionality

    HRESULT STDMETHODCALLTYPE SetHmenuProp (
        HMENU               hmenu,
        DWORD               idChild,
        MSAAPROPID          idProp,
        VARIANT             var
    );

    HRESULT STDMETHODCALLTYPE SetHmenuPropStr (
        HMENU               hmenu,
        DWORD               idChild,
        MSAAPROPID          idProp,
        LPCWSTR             bstr
    );

    HRESULT STDMETHODCALLTYPE SetHmenuPropServer (
        HMENU               hmenu,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );

    HRESULT STDMETHODCALLTYPE ClearHmenuProps (
        HMENU               hmenu,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps
    );

    // Methods for composing/decomposing a HMENU based IdentityString...

    HRESULT STDMETHODCALLTYPE ComposeHmenuIdentityString (
        HMENU               hmenu,
        DWORD               idChild,

        BYTE **             ppIDString,
        DWORD *             pdwIDStringLen
    );

    HRESULT STDMETHODCALLTYPE DecomposeHmenuIdentityString (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        HMENU *             phmenu,
        DWORD *             pidChild
    );


private:

    CPropMgrImpl *          m_pMgrImpl;
};




void PropMgrImpl_Uninit();


#endif //__PROPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\scroll.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SCROLLBAR.H
//
//  Scrollbar ole accessibility implementation
//
// --------------------------------------------------------------------------


//
// Scrollbar
//
class   CScrollBar : public CAccessible
{
    public:
        
        CScrollBar()
            : CAccessible( CLASS_ScrollBarObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDescription);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP			accNavigate(long navDir, VARIANT varChild, VARIANT* pvarEndUpAt);
        STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);

        // IEnumVARIANT
        STDMETHODIMP            Clone(IEnumVARIANT** ppenum);

        // This is virtual, since each type of sys object implements this.
        BOOL                    FInitialize(HWND hwnd, LONG idObject, LONG iChildCur);


        // IAccIdentity (overidden from base class CAccessible)
        STDMETHODIMP CScrollBar::GetIdentityString (
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );

    protected:
        BOOL    m_fVertical;      // Vertical or horizontal
};



//
// Scrollbar control
//
class   CScrollCtl : public CClient
{
    public:

        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDescription);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP			accNavigate(long navDir, VARIANT varChild, VARIANT* pvarEndUpAt);
        STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);

        // This is virtual, since each type of sys object implements this.
        CScrollCtl(HWND, long);

    protected:
        BOOL    m_fGrip;            // Sizebox instead of bar
        BOOL    m_fVertical;        // Vertical or horizontal
};



//
// Size grip
//
class   CSizeGrip : public CAccessible
{
        BOOL                    IsActive();

    public:

        CSizeGrip()
            : CAccessible( CLASS_SizeGripObject )
        {
            // Done.
        }
        
        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR * pszNaem);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDesc);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT * pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT * pvarState);
        
        STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP            accNavigate(long dwNavFlags, VARIANT varStart, VARIANT * pvarEnd);
        STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarHit);

        // IEnumVARIANT
        STDMETHODIMP            Clone(IEnumVARIANT * * ppenum);

        BOOL                    FInitialize(HWND hwnd);
};


HRESULT CreateScrollBarThing(HWND hwnd, LONG idObj, LONG iItem, REFIID riid, void** ppvScroll);
void            FixUpScrollBarInfo(LPSCROLLBARINFO);

HRESULT CreateSizeGripThing(HWND hwnd, LONG idObj, REFIID riid, void** ppvObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\scroll.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SCROLL.CPP
//
//  Scroll bar class.
//
//  OUTSTANDING ISSUES:
//  Internationalize scrollbar placement for RtoL languages in window.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "scroll.h"

#include "propmgr_util.h"


/////////////////////////////////////////////////////////////////////////////
//
//  SCROLLBAR (in a Window)
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateScrollBarObject()
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvScroll)
{
    return(CreateScrollBarThing(hwnd, idObject, 0, riid, ppvScroll));
}



// --------------------------------------------------------------------------
//
//  CreateScrollBarThing()
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarThing(HWND hwnd, long idObject, long iItem, REFIID riid, void** ppvScroll)
{
    CScrollBar * pscroll;
    HRESULT     hr;

    InitPv(ppvScroll);

    pscroll = new CScrollBar();
    if (pscroll)
    {
        if (! pscroll->FInitialize(hwnd, idObject, iItem))
        {
            delete pscroll;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = pscroll->QueryInterface(riid, ppvScroll);
    if (!SUCCEEDED(hr))
        delete pscroll;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::Clone(IEnumVARIANT** ppenum)
{
    return(CreateScrollBarThing(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        m_idChildCur, IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CScrollBar::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CScrollBar::FInitialize(HWND hwndScrollBar, LONG idObject, LONG iChildCur)
{
    if (! IsWindow(hwndScrollBar))
        return(FALSE);

    m_hwnd = hwndScrollBar;

    m_cChildren = CCHILDREN_SCROLLBAR;
    m_idChildCur = iChildCur;

    m_fVertical = (idObject == OBJID_VSCROLL);

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  GetScrollMask()
//
//  Gets present elements (may or may not be offscreen)
//
// --------------------------------------------------------------------------
void FixUpScrollBarInfo(LPSCROLLBARINFO lpsbi)
{
    if (lpsbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE)
    {
        lpsbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_INVISIBLE;
        lpsbi->rgstate[INDEX_SCROLLBAR_THUMB] |= STATE_SYSTEM_INVISIBLE;
        lpsbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_INVISIBLE;
    }
}



// --------------------------------------------------------------------------
//
//  CScrollBar::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_SCROLLBAR_NAME + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszName));
}



// --------------------------------------------------------------------------
//
//  CScrollBar::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // The value is the position.
    //
    lPos = GetScrollPos(m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ));

    int Min, Max;
    GetScrollRange( m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ), & Min, & Max );

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    return(VarBstrFromI4(lPos, 0, 0, pszValue));
}




// --------------------------------------------------------------------------
//
//  CScrollBar::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    //
    // Validate the params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_SCROLLBAR_DESCRIPTION + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszDesc));
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_SELF:
            pvarRole->lVal = ROLE_SYSTEM_SCROLLBAR;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SCROLLBAR_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    SCROLLBARINFO   sbi;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Get our information
    //
    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            &sbi)       ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_INVISIBLE))
    {
        //
        // If scrollbar isn't there period, fail.
        //
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    //
    // If unavailable or offscreen, everything is.
    //
    FixUpScrollBarInfo(&sbi);

    pvarState->lVal |= sbi.rgstate[INDEX_SCROLLBAR_SELF];
    pvarState->lVal |= sbi.rgstate[varChild.lVal];

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accDefaultAction(VARIANT varChild,
    BSTR * pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate the params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
        case INDEX_SCROLLBAR_DOWN:
            return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));
    }

    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    SCROLLBARINFO   sbi;
    int             dxyButton;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            &sbi)       ||
        (sbi.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);
    if (sbi.rgstate[varChild.lVal] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN))
        return(S_FALSE);

    if (m_fVertical)
        dxyButton = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    else
        dxyButton = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            
    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_SELF:
            *pxLeft = sbi.rcScrollBar.left;
            *pyTop = sbi.rcScrollBar.top;
            *pcxWidth = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
            *pcyHeight = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;
                *pcyHeight = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pyTop = sbi.rcScrollBar.top;
                else
                    *pyTop = sbi.rcScrollBar.bottom - *pcyHeight;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;
                *pcxWidth = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pxLeft = sbi.rcScrollBar.left;
                else
                    *pxLeft = sbi.rcScrollBar.right - *pcxWidth;
            }
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.dxyLineButton;
                *pcyHeight = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.dxyLineButton;
                *pcxWidth = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbBottom;
                *pcyHeight = (sbi.rcScrollBar.bottom - sbi.rcScrollBar.top) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbBottom;
                *pcxWidth = (sbi.rcScrollBar.right - sbi.rcScrollBar.left) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_THUMB:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbTop;
                *pcyHeight = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbTop;
                *pcxWidth = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT * pvarEnd)
{
    long    lEndUp = 0;
    SCROLLBARINFO sbi;

    InitPvar(pvarEnd);

    //
    // Validate params
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        &sbi))
    {
        return(S_FALSE);
    }

    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        dwNavDir = NAVDIR_NEXT;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (varStart.lVal == INDEX_SCROLLBAR_SELF)
        return(GetParentToNavigate((m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            m_hwnd, OBJID_WINDOW, dwNavDir, pvarEnd));

    FixUpScrollBarInfo(&sbi);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
FindNext:
            lEndUp = varStart.lVal;

            while (++lEndUp <= INDEX_SCROLLBAR_MAC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_SCROLLBAR_MAC)
                lEndUp = 0;
            break;

        case NAVDIR_PREVIOUS:
FindPrevious:
            lEndUp = varStart.lVal;

            while (--lEndUp >= INDEX_SCROLLBAR_MIC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_SCROLLBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_UP:
            lEndUp = 0;
            if (m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_LEFT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_DOWN:
            lEndUp = 0;
            if (m_fVertical)
                goto FindNext;
            break;

        case NAVDIR_RIGHT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindNext;
            break;

        default:
            AssertStr( TEXT("Invalid NavDir") );
    }

    if (lEndUp != INDEX_SCROLLBAR_SELF)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    POINT pt;
    SCROLLBARINFO sbi;
    int   xyPtAxis;
    int   xyScrollEnd;
    long  lHit;

    InitPvar(pvarChild);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
          &sbi)   ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_OFFSCREEN | STATE_SYSTEM_INVISIBLE)))
    {
        return(S_FALSE);
    }

    pt.x = xLeft;
    pt.y = yTop;
    if (! PtInRect(&sbi.rcScrollBar, pt))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);

    //
    // Convert to scrollbar coords.
    //
    if (m_fVertical)
    {
        xyPtAxis = yTop - sbi.rcScrollBar.top;
        xyScrollEnd = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
    }
    else
    {
        xyPtAxis = xLeft - sbi.rcScrollBar.left;
        xyScrollEnd = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    }

    lHit = INDEX_SCROLLBAR_SELF;

    if (xyPtAxis < sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UP] & STATE_SYSTEM_INVISIBLE));
        lHit = INDEX_SCROLLBAR_UP;
    }
    else if (xyPtAxis >= xyScrollEnd - sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWN] & STATE_SYSTEM_INVISIBLE));
        lHit = INDEX_SCROLLBAR_DOWN;
    }
    else if (!(sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE))
    {
        if (xyPtAxis < sbi.xyThumbTop)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UPPAGE] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_UPPAGE;
        }
        else if (xyPtAxis >= sbi.xyThumbBottom)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWNPAGE] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_DOWNPAGE;
        }
        else
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_THUMB] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_THUMB;
        }
    }

    pvarChild->vt = VT_I4;
    pvarChild->lVal = lHit;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accDoDefaultAction()
//
//  Only works if the element is visible and available!
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accDoDefaultAction(VARIANT varChild)
{
    WPARAM  wpAction;
    SCROLLBARINFO sbi;

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Is child available and present?
    //
    if (!MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        &sbi)   ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);

    if (sbi.rgstate[varChild.lVal] & STATE_SYSTEM_UNAVAILABLE)
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
            wpAction = SB_LINEUP;
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            wpAction = SB_PAGEUP;
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            wpAction = SB_PAGEDOWN;
            break;

        case INDEX_SCROLLBAR_DOWN:
            wpAction = SB_LINEDOWN;
            break;

        default:
            return(E_NOT_APPLICABLE);
    }

    PostMessage(m_hwnd, (m_fVertical ? WM_VSCROLL : WM_HSCROLL),
        wpAction, (LPARAM)m_hwnd);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollBar::put_accValue()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;

    SetScrollPos(m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ), lPos, TRUE);

    return(S_OK);
}






STDMETHODIMP CScrollBar::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    // Unlike the other HWND-based proxies, this one has two associated
    // objids - OBJID_VSCROLL or OBJID_HSCROLL, dpending on whether it represents
    // the horizontal or vertival non-client scrollbar.
    // Because of this, the default implementation of GetIdentityString in
    // the CAccessible base class can't handle this for us, since it can't
    // determin that this is a CScrollBar nor check what our m_fVertical flag is.
    //
    // Instead, we override GetIdentityString, and implement it here where we
    // have the information we need.

    // TODO - should probably verify that idChild is valid.
    // (we can do this for some classes - eg. where the number of children is
    // fixed and known - but it may not be preactical to do it in general.)

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    DWORD idObject = m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL;
    MakeHwndKey( pKeyData, m_hwnd, idObject, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
//
//  GRIP
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateSizeGripObject()
//
//  EXTERNAL
//
// --------------------------------------------------------------------------
HRESULT CreateSizeGripObject(HWND hwnd, long idObject, REFIID riid, void** ppvGrip)
{
    return(CreateSizeGripThing(hwnd, idObject, riid, ppvGrip));
}


// --------------------------------------------------------------------------
//
//  CreateSizeGripThing()
//
//  INTERNAL
//
// --------------------------------------------------------------------------
HRESULT CreateSizeGripThing(HWND hwnd, long idObject, REFIID riid, void** ppvGrip)
{
    CSizeGrip * psizegrip;
    HRESULT     hr;

    UNUSED(idObject);

    InitPv(ppvGrip);

    psizegrip = new CSizeGrip();
    if (psizegrip)
    {
        if (! psizegrip->FInitialize(hwnd))
        {
            delete psizegrip;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = psizegrip->QueryInterface(riid, ppvGrip);
    if (!SUCCEEDED(hr))
        delete psizegrip;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  CSizeGrip::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CSizeGrip::FInitialize(HWND hwnd)
{
    m_hwnd = hwnd;

    return(IsWindow(hwnd));
}


// --------------------------------------------------------------------------
//
//  CSizeGrip::IsActive()
//
//  Returns TRUE if the size grip can actually be used to size a window.
//  Sometimes size grips are present, but do not allow sizing - eg.
//  present on a control because horiz+vert scrollbars are present, but the
//  control is fixed in a dialog.
//
//  See ntuser\rtl\winmgr.c:SizeBoxHwnd() for the corresponding USER code
//  that does this.
//
// --------------------------------------------------------------------------
BOOL CSizeGrip::IsActive()
{
    // sizable if:

    // size grip is present...
    WINDOWINFO wi;
    if( ! MyGetWindowInfo( m_hwnd, & wi )
     || ! ( wi.dwStyle & WS_VSCROLL )
     || ! ( wi.dwStyle & WS_HSCROLL ) )
    {
        return FALSE;
    }

    // Find first ancestor or self that is sizable and non-maximized...

    HWND hwndSizable = m_hwnd;
    HWND hwndDesktop = GetDesktopWindow();
    for( ; ; )
    {
        DWORD dwStyle = GetWindowLong( hwndSizable, GWL_STYLE );
        if( dwStyle & WS_THICKFRAME )
        {
            // Got it!
            break;
        }

        // try next level up...
        hwndSizable = MyGetAncestor( hwndSizable, GA_PARENT ); 
        if( ! hwndSizable || hwndSizable == hwndDesktop )
        {
            // Didn't find any sizable ancestors - so not active.
            return FALSE;
        }
    }

    // We should really do this check along with checking the THICKFRAME
    // abive - ie. "find the first sizable and non-zoomed window"; instead of
    // this which is "find the first sizable window, and then check that it
    // is non-zoomed".
    // This version is consistent with USER's behavior, which disallows a
    // maximized MDI child from sizing its parent.
    if( IsZoomed( hwndSizable ) )
    {
        return FALSE;
    }


    // If the window we're sizing is different than this window, then check
    // that the size grip is within SM_C[X|Y]EDGE of the sizable window...
    if( hwndSizable != m_hwnd )
    {
        // sizable window's scrollbars must NOT be showing...
        if( ! MyGetWindowInfo( hwndSizable, & wi )
         || ( wi.dwStyle & WS_VSCROLL )
         || ( wi.dwStyle & WS_HSCROLL ) )
        {
            return FALSE;
        }

        // check if bottom-right aligns with top-level window...
        RECT rcInner;
        GetWindowRect( m_hwnd, & rcInner );
        RECT rcTopLevel;
        GetClientRect( hwndSizable, & rcTopLevel );
        MapWindowPoints( NULL, hwndSizable, (POINT *) & rcInner, 2 );

        if( rcInner.right < rcTopLevel.right - GetSystemMetrics( SM_CXEDGE )
            || rcInner.bottom < rcTopLevel.bottom - GetSystemMetrics( SM_CYEDGE ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accName(VARIANT varChild, BSTR * pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if( IsActive() )
    {
        return HrCreateString( STR_SCROLLBAR_NAME + INDEX_SCROLLBAR_GRIP, pszName );
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accDescription(VARIANT varChild, BSTR * pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if( IsActive() )
    {
        return HrCreateString( STR_SCROLLBAR_DESCRIPTION + INDEX_SCROLLBAR_GRIP, pszDesc );
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_GRIP;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    WINDOWINFO  wi;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // We are only visible if both scrollbars are present.
    //
    if (! MyGetWindowInfo(m_hwnd, &wi)      ||
        !(wi.dwStyle & WS_VSCROLL)          ||
        !(wi.dwStyle & WS_HSCROLL))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE;
    }
    else if( ! IsActive() )
    {
        pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    WINDOWINFO  wi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi)    &&
        (wi.dwStyle & WS_VSCROLL)       &&
        (wi.dwStyle & WS_HSCROLL))
    {
        *pxLeft = wi.rcClient.right;
        *pyTop = wi.rcClient.bottom;
        *pcxWidth = GetSystemMetrics(SM_CXVSCROLL);
        *pcyHeight = GetSystemMetrics(SM_CYHSCROLL);
    }
    else
        return(S_FALSE);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    WINDOWINFO wi;

    InitPvar(pvarChild);

    if (MyGetWindowInfo(m_hwnd, &wi)  &&
        (wi.dwStyle & WS_VSCROLL)     &&
        (wi.dwStyle & WS_HSCROLL))
    {
        if ((xLeft >= wi.rcClient.right) &&
            (xLeft < wi.rcClient.right + GetSystemMetrics(SM_CXVSCROLL)) &&
            (yTop >= wi.rcClient.bottom) &&
            (yTop < wi.rcClient.bottom + GetSystemMetrics(SM_CYHSCROLL)))
        {
            pvarChild->vt = VT_I4;
            pvarChild->lVal = CHILDID_SELF;
            return(S_OK);
        }
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accNavigate(long dwNavFlags, VARIANT varStart,
    VARIANT * pvarEnd)
{
    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavFlags, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavFlags >= NAVDIR_FIRSTCHILD)
        return(S_FALSE);

    //
    // Navigation among peers only
    //
    return(GetParentToNavigate(OBJID_SIZEGRIP, m_hwnd, OBJID_WINDOW,
        dwNavFlags, pvarEnd));
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::Clone(IEnumVARIANT** ppenum)
{
    return(CreateSizeGripThing(m_hwnd, OBJID_SIZEGRIP, IID_IEnumVARIANT, (void**)ppenum));
}




/////////////////////////////////////////////////////////////////////////////
//
//  SCROLL CONTROL (Can be bar or grip)
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateScrollBarClient()
//
//  Called from CClient creation
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvScroll)
{
    CScrollCtl * pscroll;
    HRESULT hr;

    InitPv(ppvScroll);

    pscroll = new CScrollCtl(hwnd, idChildCur);
    if (!pscroll)
        return(E_OUTOFMEMORY);

    hr = pscroll->QueryInterface(riid, ppvScroll);
    if (!SUCCEEDED(hr))
        delete pscroll;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::CScrollCtl
//
// --------------------------------------------------------------------------
CScrollCtl::CScrollCtl(HWND hwnd, long idChildCur)
    : CClient( CLASS_ScrollBarClient )
{
    long    lStyle;

    Initialize(hwnd, idChildCur);

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    if (lStyle & (SBS_SIZEBOX| SBS_SIZEGRIP))
    {
        m_fGrip = TRUE;
        m_cChildren = 0;
    }
    else
    {
        m_fUseLabel = TRUE;
        m_cChildren = CCHILDREN_SCROLLBAR;

        if (lStyle & SBS_VERT)
            m_fVertical = TRUE;
    }
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    Assert(!m_fGrip);

    return(HrCreateString(STR_SCROLLBAR_NAME + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszName));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal || m_fGrip)
        return(E_NOT_APPLICABLE);

    lPos = GetScrollPos(m_hwnd, SB_CTL);
    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    return(VarBstrFromI4(lPos, 0, 0, pszValue));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDescription(varChild, pszDesc));

    Assert(!m_fGrip);

    return(HrCreateString(STR_SCROLLBAR_DESCRIPTION + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszDesc));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case 0:
            if (m_fGrip)
                pvarRole->lVal = ROLE_SYSTEM_GRIP;
            else
                pvarRole->lVal = ROLE_SYSTEM_SCROLLBAR;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SCROLLBAR_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    SCROLLBARINFO   sbi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    Assert(!m_fGrip);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    FixUpScrollBarInfo(&sbi);

    pvarState->lVal |= sbi.rgstate[INDEX_SCROLLBAR_SELF];
    pvarState->lVal |= sbi.rgstate[varChild.lVal];

    if ((varChild.lVal == INDEX_SCROLLBAR_THUMB) && (MyGetFocus() == m_hwnd))
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
        case INDEX_SCROLLBAR_DOWN:
            return(HrCreateString(STR_BUTTON_PUSH, pszDefA));
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    SCROLLBARINFO   sbi;
    int             dxyButton;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);
    if (sbi.rgstate[varChild.lVal] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN))
        return(S_FALSE);

    if (m_fVertical)
        dxyButton = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    else
        dxyButton = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            
    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;
                *pcyHeight = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pyTop = sbi.rcScrollBar.top;
                else
                    *pyTop = sbi.rcScrollBar.bottom - *pcyHeight;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;
                *pcxWidth = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pxLeft = sbi.rcScrollBar.left;
                else
                    *pxLeft = sbi.rcScrollBar.right - *pcxWidth;
            }
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.dxyLineButton;
                *pcyHeight = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.dxyLineButton;
                *pcxWidth = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbBottom;
                *pcyHeight = (sbi.rcScrollBar.bottom - sbi.rcScrollBar.top) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbBottom;
                *pcxWidth = (sbi.rcScrollBar.right - sbi.rcScrollBar.left) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_THUMB:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbTop;
                *pcyHeight = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbTop;
                *pcxWidth = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CScrollCtl::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    long    lEndUp = 0;
    SCROLLBARINFO   sbi;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (!varStart.lVal)
    {
        if (dwNavDir < NAVDIR_FIRSTCHILD)
            return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

        if (!m_fGrip)
            return(S_FALSE);

        if (dwNavDir == NAVDIR_FIRSTCHILD)
            dwNavDir = NAVDIR_NEXT;
        else
        {
            dwNavDir = NAVDIR_PREVIOUS;
            varStart.lVal = m_cChildren + 1;
        }
    }

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
FindNext:
            lEndUp = varStart.lVal;

            while (++lEndUp <= INDEX_SCROLLBAR_MAC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_SCROLLBAR_MAC)
                lEndUp = 0;
            break;

        case NAVDIR_PREVIOUS:
FindPrevious:
            lEndUp = varStart.lVal;

            while (--lEndUp >= INDEX_SCROLLBAR_MIC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_SCROLLBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_UP:
            lEndUp = 0;
            if (m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_LEFT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_DOWN:
            lEndUp = 0;
            if (m_fVertical)
                goto FindNext;
            break;

        case NAVDIR_RIGHT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindNext;
            break;

        default:
            AssertStr( TEXT("Invalid NavDir") );
    }

    if (lEndUp != INDEX_SCROLLBAR_SELF)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accHitTest(long xLeft, long yTop, VARIANT* pvarHit)
{
    HRESULT hr;
    SCROLLBARINFO sbi;
    int     xyPtAxis;
    int     xyScrollEnd;

    //
    // Is this in our client area at all?
    //
    hr = CClient::accHitTest(xLeft, yTop, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0) || m_fGrip)
        return(hr);

    //
    // We only get here if this is a scrollbar control (not a grip)
    //
    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_OK);

    FixUpScrollBarInfo(&sbi);

    //
    // Convert to scrollbar coords.
    //
    if (m_fVertical)
    {
        xyPtAxis = yTop - sbi.rcScrollBar.top;
        xyScrollEnd = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
    }
    else
    {
        xyPtAxis = xLeft - sbi.rcScrollBar.left;
        xyScrollEnd = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    }

    if (xyPtAxis < sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UP] & STATE_SYSTEM_INVISIBLE));
        pvarHit->lVal = INDEX_SCROLLBAR_UP;
    }
    else if (xyPtAxis >= xyScrollEnd - sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWN] & STATE_SYSTEM_INVISIBLE));
        pvarHit->lVal = INDEX_SCROLLBAR_DOWN;
    }
    else if (!(sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE))
    {
        if (xyPtAxis < sbi.xyThumbTop)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UPPAGE] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_UPPAGE;
        }
        else if (xyPtAxis >= sbi.xyThumbBottom)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWNPAGE] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_DOWNPAGE;
        }
        else
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_THUMB] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_THUMB;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accDoDefaultAction(VARIANT varChild)
{
    WPARAM          wpAction = 0;
    SCROLLBARINFO   sbi;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal || (varChild.lVal == INDEX_SCROLLBAR_THUMB))
        return(E_NOT_APPLICABLE);

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi) ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);

    if (sbi.rgstate[varChild.lVal] & STATE_SYSTEM_UNAVAILABLE)
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
            wpAction = SB_LINEUP;
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            wpAction = SB_PAGEUP;
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            wpAction = SB_PAGEDOWN;
            break;

        case INDEX_SCROLLBAR_DOWN:
            wpAction = SB_LINEDOWN;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }                     

    SendMessage(GetParent(m_hwnd), (m_fVertical ? WM_VSCROLL : WM_HSCROLL),
        wpAction, (LPARAM)m_hwnd);

    return(S_OK);

}



// --------------------------------------------------------------------------
//
//  CScrollCtl::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal || m_fGrip)
        return(E_NOT_APPLICABLE);

    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;

    SetScrollPos(m_hwnd, SB_CTL, lPos, TRUE);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\sdm95.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//----------------------------------------------------------------------//
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
// DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! WARNING! //
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
//----------------------------------------------------------------------//
//                                                                      //
// WARNING!       This file is part of the SDM project.         DANGER! //
// WARNING!    Do not modify it!  If you change this file       DANGER! //
// WARNING!   you will break the build when SDM is updated!     DANGER! //
// WARNING!   If you need to make changes, make them in the     DANGER! //
// WARNING!   SDM project.  If you don't know where that is     DANGER! //
// WARNING!    contact NeilH.  In fact, contact NeilH           DANGER! //
// WARNING!   anyway, to make sure your change doesn't break    DANGER! //
// WARNING!    a version that you're not using.  Thank you.     DANGER! //
//                                                                      //
//----------------------------------------------------------------------//
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
// DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! WARNING! //
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
//----------------------------------------------------------------------//

//------------------------------------------------------------------------
// SDMTOWCT.H - include file containing the interface to be used for
// communication from outside applications with SDM dialogs.
//------------------------------------------------------------------------

#ifndef SDM_WCT_DEFINED
#define SDM_WCT_DEFINED

//------------------------------------------------------------------------
// WCT/SDM Values - Definitions and descriptions
//------------------------------------------------------------------------
#define wVerWord		2		// WinWord format


// A pointer to an array of WCTL structures is passed as the lParam
//  in a WM_GETCONTROLS message when wParam is wVerWord.
//

// 32-bit structure
typedef struct _wctl32
{
	WORD wtp;				// Item type
	WORD wId;				// Unique identifier within this dialog (TMC)
	WORD wState;			// Current value if fHasState
	WORD cchText;			// Size of text value, if fHasText
	WORD cchTitle;			// Size of title, if fHasTitle
    WORD wPad1;             // First padding word for WIN32
#ifdef MAC
	Rect rect;				// Rectangle in dialog window
#else
	RECT rect;				// Rectangle in dialog window
#endif
	LONG fHasState:1;		// Can this type of item have a numeric state?
	LONG fHasText:1;		// Can this type of item have a text value?
	LONG fHasTitle:1;		// Does the item have a title?
	LONG fEnabled:1;		// Is the item currently enabled?
	LONG fVisible:1;		// Is the item visible?
	LONG fCombo:1;			// Is the item a combo edit or listbox?
	LONG fSpin:1;			// Is the item a spin edit?
	LONG fOwnerDraw:1;		// Is the item owner-draw (or extended listbox)?
	LONG fCanFocus:1;		// Can the item receive focus?
	LONG fHasFocus:1;		// Does the item have focus?
	LONG fList:1;			// Supports wtxi.wIndex, WM_GETLISTCOUNT
	LONG lReserved:21;		// A bunch o' bits
	WORD wParam1;			// for tmtStaticText, tmtFormattedText
	WORD wParam2;			// as above
	WORD wParam3;			// yet another spare value for drawing routines
    WORD wPad2;             // Second padding word for WIN32
} WCTL32, *PWCTL32, FAR *LPWCTL32;


#pragma pack(1)
// 16-bit structure
typedef struct _wctl16
{
	WORD wtp;				// Item type
	WORD wId;				// Unique identifier within this dialog (TMC)
	WORD wState;			// Current value if fHasState
	WORD cchText;			// Size of text value, if fHasText
	WORD cchTitle;			// Size of title, if fHasTitle
#ifdef MAC
	Rect rect;				// Rectangle in dialog window
#else
    short   left;
    short   top;
    short   right;
    short   bottom;
#endif
	LONG fHasState:1;		// Can this type of item have a numeric state?
	LONG fHasText:1;		// Can this type of item have a text value?
	LONG fHasTitle:1;		// Does the item have a title?
	LONG fEnabled:1;		// Is the item currently enabled?
	LONG fVisible:1;		// Is the item visible?
	LONG fCombo:1;			// Is the item a combo edit or listbox?
	LONG fSpin:1;			// Is the item a spin edit?
	LONG fOwnerDraw:1;		// Is the item owner-draw (or extended listbox)?
	LONG fCanFocus:1;		// Can the item receive focus?
	LONG fHasFocus:1;		// Does the item have focus?
	LONG fList:1;			// Supports wtxi.wIndex, WM_GETLISTCOUNT
	LONG lReserved:21;		// A bunch o' bits
} WCTL16, *PWCTL16, FAR *LPWCTL16;
#pragma pack()


/* Possible values for wctl.wtp */
#define wtpMin				1
#define wtpStaticText		1
#define wtpPushButton		2
#define wtpCheckBox			3
#define wtpRadioButton		4
#define wtpGroupBox			5
#define wtpEdit				6
#define wtpFormattedText	7
#define wtpListBox			8
#define	wtpDropList			9
#define wtpBitmap			10
#define wtpGeneralPicture	11
#define wtpScroll			12
#define wtpMax				13

// A pointer to a WTXI structure is passed as the lParam of
//  a WM_GETCTLTEXT or WM_GETCTLTITLE message.
//

// Win32 structure
typedef struct _wtxi32		// WinWord text info
{
#ifdef MAC
	char*	lpszBuffer;		// Buffer to receive string
#else
	LPSTR	lpszBuffer;		// Buffer to receive string
#endif
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
#ifdef MAC
	Rect	rect;			// Only used for WM_GETCTLTITLE
#else
	RECT	rect;			// Only used for WM_GETCTLTITLE
#endif
	WORD	wIndex;			// Only used for WM_GETCTLTEXT on ListBoxes
    WORD    wPad1;          // Padding for Win32
} WTXI32, *PWTXI32, FAR *LPWTXI32;


// Win16 structure
#pragma pack(1)
typedef struct _wtxi16
{
#ifdef MAC
	char*	lpszBuffer;		// Buffer to receive string
#else
	LPSTR	lpszBuffer;		// Buffer to receive string
#endif
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
#ifdef MAC
	Rect	rect;			// Only used for WM_GETCTLTITLE
#else
    short   left;
    short   top;
    short   right;
    short   bottom;
#endif
	WORD	wIndex;			// Only used for WM_GETCTLTEXT on ListBoxes
} WTXI16, *PWTXI16, FAR *LPWTXI16;
#pragma pack()


//------------------------------------------------------------------------
// WCT/SDM MESSAGES - Definitions and descriptions
//------------------------------------------------------------------------

#define WM_GETCOUNT		0x7FFE
	// Returns the number of bytes needed to store control info.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLSSHAREDMEM 0x7FF6
#define WM_GETCONTROLS	0x7FF7
	// Retrieves control information for the dialog.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWCTL
	//		Must be at least the size returned by WM_GETCOUNT
	// Return value is the number of WCTL structures filled.

#define WM_GETCTLTEXT	0x7FFD
	// Retrieves the text value for the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS.
	//		For a listbox (wtpListBox or wtpDropList) (*lParam)->wIndex
	//		  must be the index of the listbox entry to be retrieved.

#define WM_GETCTLTITLE	0x7FFC
	// Retrieves the title of the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS

#define WM_GETCTLFOCUS	0x7FFB
	// Returns the wId (TMC) (as in wctl.wId) of the control with focus.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_SETCTLFOCUS	0x7FFA
	// Sets focus to the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS

#define WM_GETLISTCOUNT 0x7FF9
	// Returns the number of entries in a listbox
	// wParam	- the version id
	//		Must be wVerWord
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS
	//		Must be a listbox (wtpListBox or wtpDropList)

#define WM_GETHELPID	0x7FF8
	// Returns the dialog's Help ID
	// wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLSMOUSEDRV 0x7FFF
	// special "light" version of GETCONTROLS
	// used by the mouse 9.01 driver

#define WM_GETDROPDOWNID 0x7FF5
	//Returns the item identifier (TMC) of the control that currently owns the dropdown list window
	//This message should be sent directly to the dropdown list window.
	// wParam	- the version id
	//		Must be wVerAnsi or wVerUnicode
	//	lParam	- Unused
	//		Must be 0

#endif //SDM_WCT_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\slider.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SLIDER.CPP
//
//  Knows how to talk to COMCTL32's TRACKBAR control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "slider.h"

#include "PropMgr_Util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOPROGRESS
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>


// BOGUS
// For the moment, assume TBS_REVERSE will be0x0200
#ifndef TBS_REVERSE
#define TBS_REVERSE 0x0200
#endif

// --------------------------------------------------------------------------
//
//  CreateSliderClient()
//
// --------------------------------------------------------------------------
HRESULT CreateSliderClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvSlider)
{
    CSlider32*  pslider;
    HRESULT     hr;

    InitPv(ppvSlider);

    pslider = new CSlider32(hwnd, idChildCur);
    if (!pslider)
        return(E_OUTOFMEMORY);

    hr = pslider->QueryInterface(riid, ppvSlider);
    if (!SUCCEEDED(hr))
        delete pslider;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CSlider32::CSlider32()
//
// --------------------------------------------------------------------------
CSlider32::CSlider32(HWND hwnd, long idChildCur)
    : CClient( CLASS_SliderClient )
{
    Initialize(hwnd, idChildCur);
    m_cChildren = CCHILDREN_SLIDER;
    m_fUseLabel = TRUE;

    if (GetWindowLong(hwnd, GWL_STYLE) & TBS_VERT)
        m_fVertical = TRUE;
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    // Use scrollbar strings
    return(HrCreateString(STR_SCROLLBAR_NAME +
        (m_fVertical ? INDEX_SCROLLBAR_UP :  INDEX_SCROLLBAR_LEFT) +
        varChild.lVal, pszName));
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The elements of the slider never have a value
    //
    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // Get the current position
    //
    int lPos = SendMessageINT(m_hwnd, TBM_GETPOS, 0, 0);

    BOOL fGotUseRaw;
    if( CheckStringMap( m_hwnd, OBJID_CLIENT, varChild.lVal, PROPINDEX_VALUEMAP, & lPos, 1, pszValue,
                        TRUE /* allow 'use_raw' */, & fGotUseRaw ) )
    {
        if( ! fGotUseRaw )
            return S_OK; // Got string from map, use it...
        else
            return VarBstrFromI4( lPos, 0, 0, pszValue ); // 'use_raw' annotation present - don't scale
    }

    // No annotation - scale value to 0...100...
    long Min = SendMessageINT(m_hwnd, TBM_GETRANGEMIN, 0, 0);
    long Max = SendMessageINT(m_hwnd, TBM_GETRANGEMAX, 0, 0);

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    // if invert flag set, lPos = 100-lPos
    LONG Style = GetWindowLong( m_hwnd, GWL_STYLE );
    if( Style & TBS_REVERSE )
        lPos = 100 - lPos;

    return VarBstrFromI4( lPos, 0, 0, pszValue );
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_SLIDER_SELF:
            pvarRole->lVal = ROLE_SYSTEM_SLIDER;
            break;

        case INDEX_SLIDER_PAGEUPLEFT:
        case INDEX_SLIDER_PAGEDOWNRIGHT:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SLIDER_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of slider") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accState()
//
//  If the thumb is all the way to one side, that page up/down button is
//  not available.
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    LPRECT  lprcChannel;
    LPRECT  lprcThumb;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcChannel;
    RECT    rcThumb;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE;
        return(S_OK);
    }

    if (varChild.lVal != INDEX_SLIDER_THUMB)
    {
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
        if (!lprcChannel)
            return(E_OUTOFMEMORY);

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess1);

        lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (lprcThumb)
        {
            int iCoord;

            SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
            SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess2);

            iCoord = (m_fVertical ? 1 : 0);
            iCoord += (varChild.lVal == INDEX_SLIDER_PAGEDOWNRIGHT ? 2 : 0);

            if (((LPINT)&rcChannel)[iCoord] == ((LPINT)&rcThumb)[iCoord])
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            SharedFree(lprcThumb,hProcess2);
        }

        SharedFree(lprcChannel,hProcess1);
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CSlider32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprcChannel;
    LPRECT  lprcThumb;
    int     iCoord;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcChannel;
    RECT    rcThumb;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
        return(S_FALSE);

    //
    // Get the thumb rect.
    //
    lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
    if (!lprcThumb)
        return(E_OUTOFMEMORY);

    SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
    SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess1);

    if (varChild.lVal == INDEX_SLIDER_THUMB)
    {
        //
        // We are done.
        //
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcThumb, 2);

        *pxLeft = rcThumb.left;
        *pyTop = rcThumb.top;
        *pcxWidth = rcThumb.right - rcThumb.left;
        *pcyHeight = rcThumb.bottom - rcThumb.top;
    }
    else
    {
        //
        // Get the channel rect.
        //
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (!lprcChannel)
        {
            SharedFree(lprcThumb,hProcess1);
            return(E_OUTOFMEMORY);
        }

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess2);

        // Need to flip the channel rect if vertical, since the trackbar doesn't do that itself...
        if( m_fVertical )
        {
            int temp = rcChannel.left; rcChannel.left = rcChannel.top; rcChannel.top = temp;
            temp = rcChannel.right; rcChannel.right = rcChannel.bottom; rcChannel.bottom = temp;
        }

        //
        // Figure out the page up/page down area rect.
        //
        iCoord = (m_fVertical ? 1 : 0);
        iCoord += (varChild.lVal == INDEX_SLIDER_PAGEUPLEFT) ? 2 : 0;

        //
        // We want the left side of the page right area to start at the 
        //      right side of the thumb.
        // We want the right side of the page left area to end at the
        //      left side of the thumb.
        // We want the top side of the page down area to start at the
        //      bottom side of the thumb.
        // We want the bottom side of the page up area to end at the
        //      top side of the thumb.
        ((LPINT)&rcChannel)[iCoord] = ((LPINT)&rcThumb)[(iCoord+2) % 4];

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcChannel, 2);

        *pxLeft = rcChannel.left;
        *pyTop = rcChannel.top;
        *pcxWidth = rcChannel.right - rcChannel.left;
        *pcyHeight = rcChannel.bottom - rcChannel.top;
        
        SharedFree (lprcChannel,hProcess2);
    }

    SharedFree(lprcThumb,hProcess1);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSlider32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    POINT   pt;
    HRESULT hr;
    LPRECT  lprcThumb;
    LPRECT  lprcChannel;
    int     iCoord;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcThumb;
    RECT    rcChannel;

    //
    // Is the point in us?  Or do we have no children?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0) ||
        (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    //
    // Get the thumb.
    //
    lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
    if (!lprcThumb)
        return(E_OUTOFMEMORY);

    //
    // Is the point in it?
    //
    SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
    SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess1);
    if (PtInRect(&rcThumb, pt))
    {
        // Yes.
        pvarHit->lVal = INDEX_SLIDER_THUMB;
    }
    else
    {
        // No.  See what side of the thumb it is on.
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (!lprcChannel)
        {
            SharedFree(lprcThumb,hProcess1);
            return(E_OUTOFMEMORY);
        }

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess2);

        // Need to flip the channel rect if vertical, since the trackbar doesn't do that itself...
        if( m_fVertical )
        {
            int temp = rcChannel.left; rcChannel.left = rcChannel.top; rcChannel.top = temp;
            temp = rcChannel.right; rcChannel.right = rcChannel.bottom; rcChannel.bottom = temp;
        }

        iCoord = (m_fVertical ? 1 : 0);

        if ((((LPINT)&pt)[iCoord] >= ((LPINT)&rcChannel)[iCoord]) &&
            (((LPINT)&pt)[iCoord] < ((LPINT)&rcThumb)[iCoord])) 
        {
            pvarHit->lVal = INDEX_SLIDER_PAGEUPLEFT;
        }
        else if ((((LPINT)&pt)[iCoord] >= ((LPINT)&rcThumb)[iCoord+2]) &&
            (((LPINT)&pt)[iCoord] < ((LPINT)&rcChannel)[iCoord+2]))
        {
            pvarHit->lVal = INDEX_SLIDER_PAGEDOWNRIGHT;
        }

        SharedFree(lprcChannel,hProcess2);
    }

    SharedFree(lprcThumb,hProcess1);
    
    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CSlider32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd = 0;
    VARIANT varChild;
    VARIANT varState;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
        return(S_FALSE);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
NextChild:
            lEnd = varStart.lVal;
            while (++lEnd <= m_cChildren)
            {
                // Is this item visible?
                VariantInit(&varChild);
                varChild.vt = VT_I4;
                varChild.lVal = lEnd;

                VariantInit(&varState);

                get_accState(varChild, &varState);
                if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
PrevChild:
            lEnd = varStart.lVal;
            while (--lEnd > 0)
            {
                // Is this item visible?
                VariantInit(&varChild);
                varChild.vt = VT_I4;
                varChild.lVal = lEnd;

                VariantInit(&varState);

                get_accState(varChild, &varState);
                if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
                    break;
            }
            break;

        case NAVDIR_UP:
            lEnd = 0;
            if (m_fVertical)
                goto PrevChild;
            break;

        case NAVDIR_DOWN:
            lEnd = 0;
            if (m_fVertical)
                goto NextChild;
            break;

        case NAVDIR_LEFT:
            lEnd = 0;
            if (!m_fVertical)
                goto PrevChild;
            break;

        case NAVDIR_RIGHT:
            lEnd = 0;
            if (!m_fVertical)
                goto NextChild;
            break;

    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CSlider32::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    // Convert string to position.
    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);
    
    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    long Min = SendMessageINT(m_hwnd, TBM_GETRANGEMIN, 0, 0);
    long Max = SendMessageINT(m_hwnd, TBM_GETRANGEMAX, 0, 0);

    // if invert flag set, lPos = 100-lPos
    LONG Style = GetWindowLong( m_hwnd, GWL_STYLE );
    if( Style & TBS_REVERSE )
        lPos = 100 - lPos;

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;
  
    SendMessage(m_hwnd, TBM_SETPOS, 0, lPos);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\slider.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SLIDER.H
//
//  Knows how to talk to COMCTL32's TRACKBAR control.
//
// --------------------------------------------------------------------------


class   CSlider32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP        get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);

        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        STDMETHODIMP        put_accValue(VARIANT, BSTR szValue);

        CSlider32(HWND, long);

    protected:
        BOOL    m_fVertical;
};


#define INDEX_SLIDER_SELF           0
#define INDEX_SLIDER_PAGEUPLEFT     1
#define INDEX_SLIDER_THUMB          2
#define INDEX_SLIDER_PAGEDOWNRIGHT  3
#define CCHILDREN_SLIDER            3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\statbar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATBAR.H
//
//  This communicates with COMCTL32's status bar control.
//
// --------------------------------------------------------------------------


class CStatusBar32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accState(VARIANT, VARIANT*);

        virtual STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP    accHitTest(long, long, VARIANT*);

        CStatusBar32(HWND, long);
        void                SetupChildren(void);
        long                FindIDFromChildWindow (long id);
        long                FindChildWindowFromID (long ID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\static.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATIC.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "static.h"




// --------------------------------------------------------------------------
//
//  CreateStaticClient()
//
// --------------------------------------------------------------------------
HRESULT CreateStaticClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvStatic)
{
    CStatic * pstatic;
    HRESULT hr;

    InitPv(ppvStatic);

    pstatic = new CStatic(hwnd, idChildCur);
    if (!pstatic)
        return(E_OUTOFMEMORY);

    hr = pstatic->QueryInterface(riid, ppvStatic);
    if (!SUCCEEDED(hr))
        delete pstatic;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CStatic::CStatic()
//
// --------------------------------------------------------------------------
CStatic::CStatic(HWND hwnd, long idChildCur)
    : CClient( CLASS_StaticClient )
{
    Initialize(hwnd, idChildCur);

    // Is this a graphic?
    long lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    long lType = lStyle & SS_TYPEMASK;
    switch ( lType )
    {
        case SS_LEFT:
        case SS_CENTER:
        case SS_RIGHT:
        case SS_SIMPLE:
        case SS_LEFTNOWORDWRAP:
        case SS_EDITCONTROL:
            // For label-like statics, use their own text, and expose a text role.
            m_fUseLabel = FALSE;	
            m_fGraphic = FALSE;
            break;

        case SS_OWNERDRAW:
            // For owner-draw statics, use their own text, and expose a graphic role.
            m_fUseLabel = FALSE;	
            m_fGraphic = TRUE;
            break;

        default:
            // For everything else, ignore the control's own text (probably a meaningless
            // resource ID) and use a label instead; and expose a graphic role.
            m_fUseLabel = TRUE;	
            m_fGraphic = TRUE;
            break;
    }
}



// --------------------------------------------------------------------------
//
//  CStatic::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatic::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (m_fGraphic)
        pvarRole->lVal = ROLE_SYSTEM_GRAPHIC;
    else
        pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatic::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatic::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

	pvarState->lVal |= STATE_SYSTEM_READONLY;

    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }
    
	if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\statbar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATBAR.CPP
//
//  This knows how to talk to COMCTL32's status bar control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "statbar.h"

#define NOTOOLBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>

#define LPRECT_IN_LPRECT(rc1,rc2)   ((rc1->left >= rc2->left) && \
                                     (rc1->right <= rc2->right) && \
                                     (rc1->top >= rc2->top) && \
                                     (rc1->bottom <= rc2->bottom))

#define RECT_IN_RECT(rc1,rc2)   ((rc1.left >= rc2.left) && \
                                 (rc1.right <= rc2.right) && \
                                 (rc1.top >= rc2.top) && \
                                 (rc1.bottom <= rc2.bottom))


// --------------------------------------------------------------------------
//
//  CreateStatusBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateStatusBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppv)
{
    HRESULT hr;
    CStatusBar32 * pstatus;

    InitPv(ppv);

    pstatus = new CStatusBar32(hwnd, idChildCur);
    if (!pstatus)
        return(E_OUTOFMEMORY);

    hr = pstatus->QueryInterface(riid, ppv);
    if (!SUCCEEDED(hr))
        delete pstatus;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::CStatusBar32()
//
// --------------------------------------------------------------------------
CStatusBar32::CStatusBar32(HWND hwnd, long iChildCur)
    : CClient( CLASS_StatusBarClient )
{
    Initialize(hwnd, iChildCur);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::SetupChildren()
//
// --------------------------------------------------------------------------
void CStatusBar32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, SB_GETPARTS, 0, 0);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accName(VARIANT varChild, BSTR* pszValue)
{
    LPTSTR  lpszValue;
    UINT    cchValue;
    HANDLE  hProcess;
    LPTSTR  lpszValueLocal;

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;
    cchValue = SendMessageINT(m_hwnd, SB_GETTEXTLENGTH, varChild.lVal, 0);

    // HIGHWORD is type info, LOWORD is length
    cchValue = LOWORD( cchValue );

    if (! cchValue)
        return(S_FALSE);

    cchValue++;
    lpszValue = (LPTSTR)SharedAlloc((cchValue*sizeof(TCHAR)),m_hwnd,&hProcess);
    if (! lpszValue)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETTEXT, varChild.lVal, (LPARAM)lpszValue))
    {
        lpszValueLocal = (LPTSTR)LocalAlloc (LPTR,cchValue*sizeof(TCHAR));
        if (! lpszValueLocal)
        {
            SharedFree (lpszValue,hProcess);
            return(E_OUTOFMEMORY);
        }
        SharedRead (lpszValue,lpszValueLocal,cchValue*sizeof(TCHAR),hProcess);

        if (*lpszValueLocal)
            *pszValue = TCharSysAllocString(lpszValueLocal);

        SharedFree(lpszValue,hProcess);
        LocalFree (lpszValueLocal);

        if (! *pszValue)
            return(E_OUTOFMEMORY);

        return(S_OK);
    }
    else
    {
        SharedFree(lpszValue,hProcess);
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (! varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_STATUSBAR;
    else
        pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Status bar
    //
    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    //
    // Status items
    //
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprc;
    RECT    rcLocal;
    HANDLE  hProcess;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (! lprc)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcLocal,sizeof(RECT),hProcess);
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;

        SharedFree(lprc,hProcess);

        return(S_OK);
    }
    else
    {
        SharedFree(lprc,hProcess);
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accNavigate(long dwNavDir, VARIANT varStart, 
    VARIANT* pvarEnd)
{
    LONG    lEnd;

    InitPvar(pvarEnd);

    //CWO, 1/31/97, #14023, check for HWND children
    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    // If the action is any navigation other than first or last
    // and the child is 0
    if ((dwNavDir < NAVDIR_FIRSTCHILD) && !varStart.lVal)
        // Then call the CClient navigation method
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    // If the starting point is not a child ID, but is an
    // HWNDID, then we have to convert from the HWND to the
    // child ID by seeing which child area has coordinates
    // that contain the HWND.
    if (IsHWNDID(varStart.lVal))
        varStart.lVal = FindIDFromChildWindow( varStart.lVal );

    switch (dwNavDir)
    {
        case NAVDIR_FIRSTCHILD:
            lEnd = 1;
            goto NextStatusItem;

        case NAVDIR_LASTCHILD:
            lEnd = m_cChildren;
            break;

        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal+1;
NextStatusItem:
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal-1;
            break;

        default:
            lEnd = 0;
            break;
           
    }

    if (lEnd)
    {
        // When we get here, we know which section to look in. 
        // We need to check all our child windows to see if they
        // are contained within that section and return a dispatch
        // interface if so.
        lEnd = FindChildWindowFromID (lEnd);
        if (IsHWNDID(lEnd))
        {
            pvarEnd->vt = VT_DISPATCH;
            return (AccessibleObjectFromWindow(HwndFromHWNDID(m_hwnd, lEnd),OBJID_WINDOW,
                                    IID_IDispatch, (void**)&pvarEnd->pdispVal));
        }
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accHitTest(long x, long y, VARIANT* pvarEnd)
{
    HRESULT hr;
    int*    lpi;
    HANDLE  hProcess;

    SetupChildren();

    //
    // Are we in the client area at all?
    //
    hr = CClient::accHitTest(x, y, pvarEnd);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarEnd->vt != VT_I4) || (pvarEnd->lVal != 0) ||
        !m_cChildren)
        return(hr);

    //
    // Yes.  What item are we over?
    //
    lpi = (LPINT)SharedAlloc((m_cChildren*sizeof(DWORD)),m_hwnd,&hProcess);
    if (! lpi)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETPARTS, m_cChildren, (LPARAM)lpi))
    {
        LPINT   lpiLocal;
        POINT   pt;
        int     iPart;
        int     xCur;

        lpiLocal = (LPINT)LocalAlloc (LPTR,m_cChildren*sizeof(DWORD));
        if (! lpiLocal)
        {
            SharedFree (lpi,hProcess);
            return(E_OUTOFMEMORY);
        }
        SharedRead (lpi,lpiLocal,m_cChildren*sizeof(DWORD),hProcess);
        // 
        // Charming fact:  The right side of the last item can be -1,
        // meaning extend all the way to the right.  Turn this into MAXINT
        // so the comparison loop below will work OK.
        //

        //
        // This gets us back the right sides of each item, in order.
        //
        pt.x = x;
        pt.y = y;
        ScreenToClient(m_hwnd, &pt);

        xCur = 0;
        for (iPart = 0; iPart < m_cChildren; iPart++)
        {
            if (lpiLocal[iPart] == -1)
                lpiLocal[iPart] = 0x7FFFFFFF;

            if ((pt.x >= xCur) && (pt.x < lpiLocal[iPart]))
            {
                pvarEnd->lVal = iPart+1;
                break;
            }

            xCur = lpiLocal[iPart];
        }
    }

    SharedFree(lpi,hProcess);

    return(S_OK);
}


// --------------------------------------------------------------------------
// FindIDFromChildWindow
//
// This tries to find which section of the status bar the window child is
// in.
//
// What this is really doing is converting an id that refers to a child
// window to an ID that refers to the section of the status bar where that
// HWND lives.
//
//  Parameters:
//      long    HwndID - this should be an HWNDID - an ID referring to a HWND.
//
//  Returns:
//      long indicating which section the window is in. We will return a
//      1-based number, unless we didn't find anything, when we return 0.
//
// --------------------------------------------------------------------------
long CStatusBar32::FindIDFromChildWindow( long id )
{
LPRECT  lprcPart;
int     nParts;
int     i;
RECT    rcPartLocal;
RECT    rcWindowLocal;
HANDLE  hProcess2;

    lprcPart = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
    if (lprcPart == NULL)
        return(0);

    if (!GetWindowRect (HwndFromHWNDID(m_hwnd, id),&rcWindowLocal))
    {
        SharedFree(lprcPart,hProcess2);
        return (0);
    }

    nParts = SendMessageINT(m_hwnd,SB_GETPARTS,0,0);
    for (i=0;i<nParts;i++)
    {
        SendMessage (m_hwnd,SB_GETRECT,i,(LPARAM)lprcPart);
        SharedRead (lprcPart,&rcPartLocal,sizeof(RECT),hProcess2);
        MapWindowPoints (m_hwnd,NULL,(LPPOINT)&rcPartLocal,2);

        if (RECT_IN_RECT(rcWindowLocal,rcPartLocal))
        {
            SharedFree(lprcPart,hProcess2);
            return (i+1);
        }
    }// end for

    SharedFree(lprcPart,hProcess2);
    return (0);
}

// --------------------------------------------------------------------------
// FindChildWindowFromID 
//
// This tries to find a child window inside a given part of a status bar.
//
//  Parameters:
//      long    ID - this should be a 1-based child ID indicating which
//                  part of the status bar to check for a child window.
//  Returns:
//      long that actually contains an HWNDID, or just the value passed
//      in if there was no child window.
// --------------------------------------------------------------------------
long CStatusBar32::FindChildWindowFromID (long ID)
{
LPRECT  lprcPart;
HWND    hwndChild;
RECT    rcWindowLocal;
RECT    rcPartLocal;
HANDLE  hProcess2;

    lprcPart = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
    if (lprcPart == NULL)
        return(0);

    SendMessage (m_hwnd,SB_GETRECT,ID-1,(LPARAM)lprcPart);
    SharedRead (lprcPart,&rcPartLocal,sizeof(RECT),hProcess2);
    MapWindowPoints (m_hwnd,NULL,(LPPOINT)&rcPartLocal,2);

    hwndChild = ::GetWindow(m_hwnd,GW_CHILD);
    while (hwndChild)
    {
        GetWindowRect (hwndChild,&rcWindowLocal);
        if (RECT_IN_RECT(rcWindowLocal,rcPartLocal))
        {
            SharedFree(lprcPart,hProcess2);
            return (HWNDIDFromHwnd(m_hwnd, hwndChild));
        }
        hwndChild = ::GetWindow(hwndChild,GW_HWNDNEXT);
    }
    SharedFree(lprcPart,hProcess2);
    return (ID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\strtable.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

#define STR_CARETNAME                   100

#define STR_CURSORNAMEFIRST             110

#define STR_TITLEBAR_NAME               140
#define STR_TITLEBAR_IMEBUTTON_NAME     141
#define STR_TITLEBAR_MINBUTTON_NAME     142
#define STR_TITLEBAR_MAXBUTTON_NAME     143
#define STR_TITLEBAR_HELPBUTTON_NAME    144
#define STR_TITLEBAR_CLOSEBUTTON_NAME   145
#define STR_TITLEBAR_RESTOREBUTTON_NAME 146

#define STR_TITLEBAR_DESCRIPTION        150
#define STR_TITLEBAR_SHORTCUT           160

#define STR_SCROLLBAR_NAME              180
#define STR_SCROLLBAR_DESCRIPTION       200

#define STR_MENUBAR_NAME                250
#define STR_SYSMENU_NAME                251
#define STR_MENUBAR_DESCRIPTION         252
#define STR_SYSMENUBAR_DESCRIPTION      253
#define STR_MENU_SHORTCUT               254
#define STR_MENU_SHORTCUT_FORMAT        255
#define STR_SYSMENU_KEY                 256
#define STR_CHILDSYSMENU_KEY            257
#define STR_EXECUTE                     258

#define STR_SHIFT                       259
#define STR_CONTROL                     260
#define STR_ALT                         STR_MENU_SHORTCUT
#define STR_CHILDSYSMENU_NAME           261
#define STR_STARTBUTTON_SHORTCUT		262
#define STR_CONTEXT_MENU                263
#define STR_DOCMENU_NAME				264
#define STR_DOUBLE_CLICK                265
#define STR_CLICK                       266

#define STR_WINDOW_NAME                 270
#define STR_STARTBUTTON                 271
#define STR_SPIN_GREATER                272
#define STR_SPIN_LESSER                 273
#define STR_TRAY                        274
#define STR_HOTKEY_NONE                 275

#define STR_COMBOBOX_LIST_SHORTCUT      280
#define STR_DROPDOWN_SHOW               285
#define STR_DROPDOWN_HIDE               286


#define STR_ALTTAB_NAME                 290
#define STR_ALTTAB_DESCRIPTION          291
#define STR_TAB_SWITCH                  292
#define STR_MDICLI_NAME                 293
#define STR_DESKTOP_NAME                294
#define STR_PERCENTAGE_FORMAT           295

#define STR_TREE_EXPAND                 305
#define STR_TREE_COLLAPSE               306

#define STR_HTML_JUMP                   307
#define STR_BUTTON_PUSH                 308
#define STR_BUTTON_CHECK                309
#define STR_BUTTON_UNCHECK              310
#define STR_BUTTON_HALFCHECK            311

#define STR_DESC_IP_PART				320

#define STR_STATEFIRST                  1000
#define STR_ROLEFIRST                   1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\tabctrl.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TABCTRL.CPP
//
//  This knows how to talk to COMCTL32's tab control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "tabctrl.h"


#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTREEVIEW
#define NOTOOLBAR
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include <tchar.h>

#define MAX_NAME_SIZE   128  // maximum size of name of tab control

// Used for Tab control code
// cbExtra for the tray is 8, so pick something even bigger, 16
#define CBEXTRA_TRAYTAB     16


// --------------------------------------------------------------------------
//
//  CreateTabControlClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateTabControlClient(HWND hwnd, long idChildCur,REFIID riid, void** ppvTab)
{
    CTabControl32 * ptab;
    HRESULT hr;

    InitPv(ppvTab);

    ptab = new CTabControl32(hwnd, idChildCur);
    if (! ptab)
        return(E_OUTOFMEMORY);

    hr = ptab->QueryInterface(riid, ppvTab);
    if (!SUCCEEDED(hr))
        delete ptab;

    return(hr);
}





// --------------------------------------------------------------------------
//
//  IsReallyVisible()
//
//  Internal, used for wizard compat.
//  Wizards have a tab control that is has 'visible' state; but is covered
//  up by sibling dialogs (the actual sheets) so that to a user it is not
//  visible.
//
//  They (the comctl people who own the property sheet code) can't make it
//  actually invisible for compat reasons...
//
//  So we have to take this into account when calculating our 'visible'
//  flag.
//  If we didn't do this, Narrator and friends would think the control was
//  visible, and would read it out when reading the window.
//
// --------------------------------------------------------------------------


BOOL IsReallyVisible( HWND hwnd )
{
    // TODO - check own visible state...
    RECT rc;
    GetWindowRect( hwnd, & rc );

    for( HWND hPrev = GetWindow( hwnd, GW_HWNDPREV ) ; hPrev ; hPrev = GetWindow( hPrev, GW_HWNDPREV ) )
    {
        // if window is visible, and covers own rectangle, then we're invisible...
        if( IsWindowVisible( hPrev ) )
        {
            RECT rcSibling;
            GetWindowRect( hPrev, & rcSibling );

            if( rcSibling.left <= rc.left
             && rcSibling.right >= rc.right
             && rcSibling.top <= rc.top
             && rcSibling.bottom >= rc.bottom )
            {
                return FALSE;
            }
        }
    }

    // No predecessors whoch obscure us - visible by default...
    return TRUE;
}




// --------------------------------------------------------------------------
//
//  CTabControl32::CTabControl32()
//
// --------------------------------------------------------------------------
CTabControl32::CTabControl32(HWND hwnd, long idChild)
    : CClient( CLASS_TabControlClient )
{
    Initialize(hwnd, idChild);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::SetupChildren()
//
// --------------------------------------------------------------------------
void CTabControl32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, TCM_GETITEMCOUNT, 0, 0L);
}

// --------------------------------------------------------------------------
//
//  CTabControl32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accName(VARIANT varChild, BSTR* pszName)
{
LPTSTR  lpszName;
HRESULT hr;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_TRAY))
            return(HrCreateString(STR_TRAY, pszName));
        else
            return(CClient::get_accName(varChild, pszName));
    }

    varChild.lVal--;

	// Get the unstripped name
	hr = GetTabControlString (varChild.lVal,&lpszName);
	if( ! lpszName )
		return hr; // could be S_FALSE or E_erro_code

    if (*lpszName)
    {
        StripMnemonic(lpszName);
        *pszName = TCharSysAllocString(lpszName);
    }

	LocalFree (lpszName);
    
    return(*pszName ? S_OK : S_FALSE);
}

    
// --------------------------------------------------------------------------
//
//  CTabControl32::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
TCHAR   chMnemonic = 0;
LPTSTR  lpszName;
HRESULT hr;

    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_TRAY))
            return(S_FALSE); // no shortcut keys for these
        else
            return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
    }

    varChild.lVal--;

	// Get the unstripped name
	hr = GetTabControlString (varChild.lVal,&lpszName);
	if( ! lpszName )
		return hr; // could be S_FALSE or E_error_code

    if (*lpszName)
        chMnemonic = StripMnemonic(lpszName);

	LocalFree (lpszName);

	//
	// Is there a mnemonic?
	//
	if (chMnemonic)
	{
		//
		// Make a string of the form "Alt+ch".
		//
		TCHAR   szKey[2];

		*szKey = chMnemonic;
		*(szKey+1) = 0;

		return(HrMakeShortcut(szKey, pszShortcut));
	}
	return (S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CTabControl32::GetTabControlString()
//
// Get the name of the tab. There are three ways to do this - 
// You can just ask using the standard messages, if the tab is an
// owner drawn tab owned by the shell we happen to know that the
// item data is the hwnd, so we can just the hwnd's text, or if both
// of those fail, we can try to get it from a tooltip. Since we need to
// do this for both name and keyboard shortcut, we'll write a private
// method to get the unstripped name.
//
// Parameters:
//		int	ChildIndex	    - the zero based index of the tab we want to get
//		LPTSTR*	ppszName	- pointer that will be LocalAlloc'ed and filled
//							  in with the name. Caller must LocalFree it.
//
// Returns:
//
//      On Success:
//        returns S_TRUE, *ppszName will be non-NULL, caller must LocalFree() it.
//
//      On Failure:
//		  returns S_FALSE - no name available. *ppszName set to NULL.
//		  ...or...
//		  returns COM Failure code (including E_OUTOFMEMORY) - com/memory error.
//		  *ppszName set to NULL.
//
// Note: caller should take care if using "FAILED( hr )" to examine the return
// value of this method, since it does treats both S_OK and S_FALSE as 'success'.
// It may be better to check that *ppszName is non-NULL.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::GetTabControlString(int ChildIndex, LPTSTR* ppszName)
{
HWND        hwndToolTip;
LPTSTR		pszName = NULL;

	// Set this to NULL now, in case we return an error code (or S_FALSE) later...
    // (We'll set it to a valid return value later if we succeed...)
    *ppszName = NULL;

    // Try to get name of tab the easy way, by asking first.
	// Allocate a TCITEM structure in the process that owns the window,
	// so they can just read it/write into it when we send the message.
	// Have to use SharedWrite to set up the structure.
	TCHAR tchText[MAX_NAME_SIZE + 1] = {0};
	TCITEM tci;
	memset(&tci, 0, sizeof(TCITEM));
	tci.mask = TCIF_TEXT;
	tci.pszText = tchText;
	tci.cchTextMax = MAX_NAME_SIZE;

	if (SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, ChildIndex, &tci)))
	{
		if (tci.pszText && *tci.pszText)
		{
			pszName = (LPTSTR)LocalAlloc (LPTR,(lstrlen(tci.pszText)+1)*sizeof(TCHAR));
			if (!pszName)
				return E_OUTOFMEMORY;

			lstrcpy(pszName, tci.pszText);
			*ppszName = pszName;
			return S_OK;
		}
	}

    // OK, Step 2 - another hack.  If this is the tray, we know the item data
    // is an HWND, so get the window's text.  So the tricky code is
    // really:  Is this from the tray?

	struct TCITEM_SHELL
	{
		TCITEM	tci;
		BYTE	bExtra[ CBEXTRA_TRAYTAB ];
		// Sending TCM_GETITEM with mask of TCIF_PARAM will overwrite bytes
		// from tci.lParam onwards. The length is set to sizeof(LPARAM) by
		// default, so it's usually not an issue. But the taskbar uses
		// TCM_SETITEMEXTRA to reserve an extra DWORD - so TCM_GETIEEM+TCIF_PARAM
		// sent to the taskbar will overwrite the lParam field plus the following
		// DWORD. It's really really really important to have something that can
		// take this, otherwise it's bye bye stack...
	};

	TCITEM_SHELL tcis;

    pszName = NULL;
	tcis.tci.mask = TCIF_PARAM;
	tcis.tci.pszText = 0;
	tcis.tci.cchTextMax = 0;

	if (InTheShell(m_hwnd, SHELL_TRAY) 
	  && SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, ChildIndex, &tcis.tci)))
	{
		hwndToolTip = (HWND)tcis.tci.lParam;
        pszName = GetTextString (hwndToolTip,TRUE);
		if (pszName && *pszName)
		{
			*ppszName = pszName;
			return S_OK;
		}
	}
    LocalFree (pszName);

	//
	// If we still don't have a name, try method 3 - get name of tab via 
	// tooltip method 
	//
	// TODO (micw) Need to test getting name from tool tip
    hwndToolTip = (HWND)SendMessage(m_hwnd, TCM_GETTOOLTIPS, 0, 0);
    if (!hwndToolTip)
        return(S_FALSE);

	// See if there's tool tip text

	tchText[0] = 0;
	TOOLINFO ti;
	memset(&ti, 0, SIZEOF_TOOLINFO );
	ti.cbSize = SIZEOF_TOOLINFO;
	ti.lpszText = tchText;
	ti.hwnd = m_hwnd;
	ti.uId = ChildIndex;

	if (SUCCEEDED(XSend_ToolTip_GetItem(hwndToolTip, TTM_GETTEXT, 0, &ti, MAX_NAME_SIZE)))
	{
		if (*ti.lpszText)
		{
			pszName = (LPTSTR)LocalAlloc (LPTR,(lstrlen(ti.lpszText)+1)*sizeof(TCHAR));
			if (!pszName)
				return E_OUTOFMEMORY;

			lstrcpy(pszName, ti.lpszText);
			*ppszName = pszName;
			return S_OK;
		}
	}

	return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  CTabControl32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (!varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_PAGETABLIST;
    else
        pvarRole->lVal = ROLE_SYSTEM_PAGETAB;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);
    
    if( ! ValidateChild( & varChild ) )
        return E_INVALIDARG;

    if( !varChild.lVal )
    {
        // Workarond for wizard property sheets...
        //
        // Want to make the 'visible' but covered-up (so not visible to user)
        // tab strip have a state of invisible, so Narrator and friends don't
        // read it out.
        //
        // Do this by calling through to CClient::get_accState as usual,
        // then add in the invisible bit after, if necessary.
        HRESULT hr = CClient::get_accState( varChild, pvarState );
        if( hr == S_OK
         && pvarState->vt == VT_I4
         && ! ( pvarState->lVal & STATE_SYSTEM_INVISIBLE ) )
        {
            if( ! IsReallyVisible( m_hwnd ) )
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            }
        }
        return hr;
    }

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    TCITEM tci;
    memset(&tci, 0, sizeof(TCITEM));
    tci.mask = TCIF_STATE;

    if (SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, varChild.lVal-1, &tci)))
    {
        if (tci.dwState & TCIS_BUTTONPRESSED)
            pvarState->lVal |= STATE_SYSTEM_PRESSED;
    } else
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    // It is always selectable
    pvarState->lVal |= STATE_SYSTEM_SELECTABLE;
    
    // Is this the current one?
    if (SendMessage(m_hwnd, TCM_GETCURSEL, 0, 0) == (varChild.lVal-1))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;
    
    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
        
        if (SendMessage(m_hwnd, TCM_GETCURFOCUS, 0, 0) == (varChild.lVal-1))
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    
    
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accFocus(VARIANT* pvarChild)
{
    HRESULT hr;
    long    lCur;

    hr = CClient::get_accFocus(pvarChild);
    if (!SUCCEEDED(hr) || (pvarChild->vt != VT_I4) || (pvarChild->lVal != 0))
        return(hr);

    //
    // This window has the focus.
    //
    lCur = SendMessageINT(m_hwnd, TCM_GETCURFOCUS, 0, 0L);
    pvarChild->lVal = lCur+1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CTabControl32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accSelection(VARIANT* pvarChild)
{
    long    lCur;

    InitPvar(pvarChild);

    lCur = SendMessageINT(m_hwnd, TCM_GETCURSEL, 0, 0L);
    if (lCur != -1)
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = lCur+1;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefAction));

    return(HrCreateString(STR_TAB_SWITCH, pszDefAction));
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accSelect(long flags, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(flags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(flags, varChild));

    if (flags & ~(SELFLAG_TAKEFOCUS | SELFLAG_TAKESELECTION))
        return(E_NOT_APPLICABLE);

    if (flags & SELFLAG_TAKEFOCUS)
    {
        MySetFocus(m_hwnd);

        SendMessage(m_hwnd, TCM_SETCURFOCUS, varChild.lVal-1, 0);
    }

    if (flags & SELFLAG_TAKESELECTION)
        SendMessage(m_hwnd, TCM_SETCURSEL, varChild.lVal-1, 0);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
LPRECT  lprcShared;
HANDLE  hProcess;
RECT    rcLocation;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Get the tab item rect
    //
    lprcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprcShared)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, TCM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprcShared))
    {
        SharedRead (lprcShared,&rcLocation,sizeof(RECT),hProcess);

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocation, 2);

        *pxLeft = rcLocation.left;
        *pyTop = rcLocation.top;
        *pcxWidth = rcLocation.right - rcLocation.left;
        *pcyHeight = rcLocation.bottom - rcLocation.top;
    }

    SharedFree(lprcShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accNavigate()
//
//  BOGUS!  Doesn't handle multiple row or vertical right now.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accNavigate(long dwNavFlags, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavFlags, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavFlags == NAVDIR_FIRSTCHILD)
        dwNavFlags = NAVDIR_NEXT;
    else if (dwNavFlags == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavFlags = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavFlags, varStart, pvarEnd));

    switch (dwNavFlags)
    {
        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal - 1;
            break;

        default:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CTabControl32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT         hr;
long            lItem;
LPTCHITTESTINFO lptchShared;
HANDLE          hProcess;
POINT           ptTest;

    InitPvar(pvarHit);

    // Is the point in us?
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4))
        return(hr);

    // What item is this over?
    lptchShared = (LPTCHITTESTINFO)SharedAlloc(sizeof(TCHITTESTINFO),m_hwnd,&hProcess);
    if (!lptchShared)
        return(E_OUTOFMEMORY);

    ptTest.x = x;
    ptTest.y = y;
    ScreenToClient(m_hwnd, &ptTest);

    SharedWrite(&ptTest,&lptchShared->pt,sizeof(POINT),hProcess);

    lItem = SendMessageINT(m_hwnd, TCM_HITTEST, 0, (LPARAM)lptchShared);

    SharedFree(lptchShared,hProcess);

    // Note that if the point isn't over an item, TCM_HITTEST returns -1, 
    // and -1+1 is zero, which is self.
    pvarHit->vt = VT_I4;
    pvarHit->lVal = lItem+1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accDoDefaultAction(VARIANT varChild)
{
RECT		rcLoc;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

	accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	
    // this will check if WindowFromPoint at the click point is the same
	// as m_hwnd, and if not, it won't click. Cool!
	if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		return (S_OK);

    return(E_NOT_APPLICABLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\tabctrl.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TABCTRL.H
//
//  Knows how to talk to COMCTL32's tab control
//
// --------------------------------------------------------------------------

class CTabControl32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accFocus(VARIANT*);
        virtual STDMETHODIMP    get_accSelection(VARIANT*);
        virtual STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        virtual STDMETHODIMP    accSelect(long, VARIANT);
        virtual STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP    accHitTest(long, long, VARIANT*);
        virtual STDMETHODIMP    accDoDefaultAction(VARIANT);

        // constructor
        CTabControl32(HWND, long);

        // other methods
        void                    SetupChildren(void);

    private:
        STDMETHODIMP            GetTabControlString(int ChildIndex,LPTSTR* ppszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\static.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATIC.H
//
//  Static object
//
// --------------------------------------------------------------------------

class   CStatic :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT *pvarRole);
		STDMETHODIMP	get_accState(VARIANT varChild, VARIANT *pvarState);

        CStatic(HWND, long);

    protected:
        BOOL    m_fGraphic;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\titlebar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TITLEBAR.H
//
//  Titlebar ole accessibility implementation
//
// --------------------------------------------------------------------------

//
// BOGUS!  Do we implement QueryInterface() and respond to ITextDocument etc.
// if OSM is around?
//

class   CTitleBar :   public  CAccessible
{
    public:

        CTitleBar()
            : CAccessible( CLASS_TitleBarObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT varChild, BSTR * pszDesc);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR * pszDefAction);

        STDMETHODIMP        accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
            long* pcyHeight, VARIANT varChild);
        STDMETHODIMP        accNavigate(long narDir, VARIANT varStart,
            VARIANT * pvarEndUpAt);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT * pvarChild);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);
		STDMETHODIMP		accSelect(long flagsSel, VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        BOOL                FInitialize(HWND hwnd, LONG iChildCur);
};


//
// Helper functions
//
HRESULT     CreateTitleBarThing(HWND hwnd, long idObject, REFIID riid, void** ppvObject);
long        GetRealChild(DWORD dwStyle, LONG lChild);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\titlebar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TITLEBAR.CPP
//
//  Title bar class.
//
//  NOTE:
//  Every time we make a drawing, hittesting change to USER for titlebars,
//  update this file also!  I.E. when you
//      (1) Add a titlebar element like a new button
//      (2) Change the spacing like margins
//      (3) Add a new type of titlebar beyond normal/small
//      (4) Shuffle the layout
//
//  ISSUES:
//      (1) Need "button down" info from USER and hence a shared <oleuser.h>
//      (2) Need "hovered" info from USER
//      (3) For FE, we need a SC_IME system command.  The TrackIMEButton()
//          code does the command in line, unlike all other titlebar buttons.
//          This makes it not programmable.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "titlebar.h"


// --------------------------------------------------------------------------
//
//  CreateTitleBarObject()
//
// --------------------------------------------------------------------------
HRESULT CreateTitleBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvTitle)
{
    UNUSED(idObject);

    return(CreateTitleBarThing(hwnd, 0, riid, ppvTitle));
}


// --------------------------------------------------------------------------
//
//  CreateTitleBarThing()
//
// --------------------------------------------------------------------------
HRESULT CreateTitleBarThing(HWND hwnd, long iChildCur, REFIID riid, void** ppvTitle)
{
    CTitleBar * ptitlebar;
    HRESULT hr;

    InitPv(ppvTitle);

    ptitlebar = new CTitleBar();
    if (ptitlebar)
    {
        if (! ptitlebar->FInitialize(hwnd, iChildCur))
        {
            delete ptitlebar;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = ptitlebar->QueryInterface(riid, ppvTitle);
    if (!SUCCEEDED(hr))
        delete ptitlebar;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  GetRealChild()
//
// --------------------------------------------------------------------------
long GetRealChild(DWORD dwStyle, LONG lChild)
{
    switch (lChild)
    {
        case INDEX_TITLEBAR_MINBUTTON:
            if (dwStyle & WS_MINIMIZE)
                lChild = INDEX_TITLEBAR_RESTOREBUTTON;
            break;

        case INDEX_TITLEBAR_MAXBUTTON:
            if (dwStyle & WS_MAXIMIZE)
                lChild = INDEX_TITLEBAR_RESTOREBUTTON;
            break;
    }

    return(lChild);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::FInitialize
//
// --------------------------------------------------------------------------
BOOL CTitleBar::FInitialize(HWND hwndTitleBar, LONG iChildCur)
{
    if (! IsWindow(hwndTitleBar))
        return(FALSE);

    m_hwnd = hwndTitleBar;
    m_cChildren = CCHILDREN_TITLEBAR;
    m_idChildCur = iChildCur;

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::Clone(IEnumVARIANT ** ppenum)
{
    return(CreateTitleBarThing(m_hwnd, m_idChildCur, IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accName()
//
//  Returns the proper noun name of the object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accName(VARIANT varChild, BSTR * pszName)
{
    long    index;
    LONG    dwStyle;

    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    // The titlebar doesn't have a name itself
    if (!varChild.lVal)
        return(S_FALSE);

    //
    // Figure out what string to _really_ load (depends on window state)
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    return(HrCreateString(STR_TITLEBAR_NAME+index, pszName));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accValue()
//
//  The value of the titlebar itself is the text inside.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Only the titlebar has a value, the child buttons don't.
    //
    if (varChild.lVal)
        //CWO, 1/16/97, Changed to S_FALSE from E_NOT_APPLICABLE
        return(S_FALSE);

    return(HrGetWindowName(m_hwnd, FALSE, pszValue));
}




// --------------------------------------------------------------------------
//
//  CTitleBar::get_accDescription()
//
//  Returns a full sentence describing the object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accDescription(VARIANT varChild, BSTR * pszDesc)
{
    long    index;
    LONG    dwStyle;

    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Figure out what string to _really_ load, depends on state.
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    return(HrCreateString(STR_TITLEBAR_DESCRIPTION+index, pszDesc));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal == INDEX_TITLEBAR_SELF)
        pvarRole->lVal = ROLE_SYSTEM_TITLEBAR;
    else
        pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    TITLEBARINFO    ti;

    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & STATE_SYSTEM_INVISIBLE))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    pvarState->lVal |= ti.rgstate[INDEX_TITLEBAR_SELF];
    pvarState->lVal |= ti.rgstate[varChild.lVal];

	// only the title bar itself is focusable.
	if (varChild.lVal != INDEX_TITLEBAR_SELF)
		pvarState->lVal &= ~STATE_SYSTEM_FOCUSABLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accDefaultAction()
//
//  NOTE:  only the buttons have default actions.  The default action of
//  the system menu is ambiguous, since it is unknown until the window
//  enters menu mode.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accDefaultAction(VARIANT varChild, BSTR*
    pszDefAction)
{
    long index;
    LONG dwStyle;

    InitPv(pszDefAction);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // Get the string
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    //
    // BOGUS!  The IME button doesn't have a def action either since
    // we can't change the keyboard layout indirectly via WM_SYSCOMMAND.
    // The IME code does the work in line.  We need to make an SC_.
    //
    if (index <= INDEX_TITLEBAR_IMEBUTTON)
        return(E_NOT_APPLICABLE);

    return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));
}


// --------------------------------------------------------------------------
//
//  CTitleBar::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accSelect(long flagsSel, VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

	if (flagsSel & SELFLAG_TAKEFOCUS)
	{
		if (varChild.lVal == CHILDID_SELF)
		{
            MySetFocus(m_hwnd);
			return (S_OK);
		}
	}

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CTitleBar::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT * pvarEnd)
{
    TITLEBARINFO    ti;
    long        lEndUp;

    InitPvar(pvarEnd);

    if (! ValidateChild(&varStart) ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetTitleBarInfo(m_hwnd, &ti))
        return(S_FALSE);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (varStart.lVal == INDEX_TITLEBAR_SELF)
        return(GetParentToNavigate(OBJID_TITLEBAR, m_hwnd,
            OBJID_WINDOW, dwNavDir, pvarEnd));

    //
    // NOTE:  It is up to the caller to make sure the item navigation
    // is starting from is visible.
    //
    switch (dwNavDir)
    {
        case NAVDIR_LEFT:
        case NAVDIR_PREVIOUS:
            // 
            // Is there anything to the left of us?
            //
            lEndUp = varStart.lVal;
            while (--lEndUp >= INDEX_TITLEBAR_MIC)
            {
                if (!(ti.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_TITLEBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_RIGHT:
        case NAVDIR_NEXT:
            //
            // Is there anything to the right of us?
            //
            lEndUp = varStart.lVal;
            while (++lEndUp <= INDEX_TITLEBAR_MAC)
            {
                if (!(ti.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_TITLEBAR_MAC)
                lEndUp = 0;
            break;

        default:
            lEndUp = 0;
            break;
    }

    if (lEndUp)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CTitleBar::accLocation()
//
//  Gets the screen rect of a particular element.  If the item isn't
//  actually present, this will fail.
//
//  NOTE:  It is up to the caller to make sure that the container (titlebar)
//  is visible before calling accLocation on a child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    int     cyBorder;
    int     cxyButton;
    TITLEBARINFO ti;
    int     index;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! MyGetTitleBarInfo(m_hwnd, &ti))
        return(S_FALSE);

    //
    // If this object isn't around, fail.
    //
    if ((ti.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN)) ||
        (ti.rgstate[varChild.lVal] & STATE_SYSTEM_INVISIBLE))
    {
        return(S_FALSE);
    }

    cyBorder = GetSystemMetrics(SM_CYBORDER);
    cxyButton = ti.rcTitleBar.bottom - ti.rcTitleBar.top - cyBorder;

    if (varChild.lVal == INDEX_TITLEBAR_SELF)
    {
        *pxLeft     = ti.rcTitleBar.left;
        *pyTop      = ti.rcTitleBar.top;
        *pcxWidth   = ti.rcTitleBar.right - ti.rcTitleBar.left;
        *pcyHeight  = ti.rcTitleBar.bottom - ti.rcTitleBar.top;
    }
    else
    {
        *pyTop      = ti.rcTitleBar.top;
        *pcxWidth   = cxyButton;
        *pcyHeight  = cxyButton;

        // Where is the left side of the button?  Our INDEX_s are
        // conveniently defined in left-to-right order.  Start at the
        // end and work backwards to the system menu.  Subtract cxyButton
        // when a child is present.
        *pxLeft     = ti.rcTitleBar.right - cxyButton;
        for (index = INDEX_TITLEBAR_MAC; index > INDEX_TITLEBAR_SELF; index--)
        {
            if (index == varChild.lVal)
                break;

            if (!(ti.rgstate[index] & STATE_SYSTEM_INVISIBLE))
                *pxLeft -= cxyButton;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accHitTest(long xLeft, long yTop, VARIANT* pvarChild)
{
    POINT   pt;
    int     cxyButton;
    int     index;
    TITLEBARINFO    ti;

    InitPvar(pvarChild);

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE || STATE_SYSTEM_OFFSCREEN)))
        return(S_FALSE);

    pt.x = xLeft;
    pt.y = yTop;

    // 
    // We return VT_EMPTY when the point isn't in the titlebar at all.
    //
    if (! PtInRect(&ti.rcTitleBar, pt))
        return(S_FALSE);

    pvarChild->vt = VT_I4;
    pvarChild->lVal = INDEX_TITLEBAR_SELF;

    cxyButton = ti.rcTitleBar.bottom - ti.rcTitleBar.top - GetSystemMetrics(SM_CYBORDER);

    // If yTop is greater than this, the point is on the border drawn below
    // the caption
    if (yTop < ti.rcTitleBar.top + cxyButton)
    {
        //
        // Start at the right side and work backwards.
        //
        pt.x = ti.rcTitleBar.right - cxyButton;

        for (index = INDEX_TITLEBAR_MAC; index > INDEX_TITLEBAR_SELF; index--)
        {
            //
            // This child is here.
            //
            if (!(ti.rgstate[index] & STATE_SYSTEM_INVISIBLE))
            {
                //
                // Is this point where this child is?
                //
                if (xLeft >= pt.x)
                {
                    pvarChild->lVal = index;
                    break;
                }

                pt.x -= cxyButton;
            }
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accDoDefaultAction(VARIANT varChild)
{
    WPARAM  scCommand = 0;
    int     index;
    TITLEBARINFO    ti;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // We return nothing for the titlebar & system menu objects.  Hence it
    // is a real error to attempt to do the default action  on them.
    //
    if (varChild.lVal <= INDEX_TITLEBAR_IMEBUTTON)
        return(E_NOT_APPLICABLE);

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & STATE_SYSTEM_INVISIBLE))
        return(S_FALSE);


    //
    // We do NOT do the default action of an object that is invisible.
    //
    if (ti.rgstate[varChild.lVal] & STATE_SYSTEM_INVISIBLE)
        return(S_FALSE);

    index = GetRealChild(GetWindowLong(m_hwnd, GWL_STYLE), varChild.lVal);

    switch (index)
    {
        case INDEX_TITLEBAR_MINBUTTON:
            scCommand = SC_MINIMIZE;
            break;

        case INDEX_TITLEBAR_HELPBUTTON:
            scCommand = SC_CONTEXTHELP;
            break;

        case INDEX_TITLEBAR_MAXBUTTON:
            scCommand = SC_MAXIMIZE;
            break;

        case INDEX_TITLEBAR_RESTOREBUTTON:
            scCommand = SC_RESTORE;
            break;

        case INDEX_TITLEBAR_CLOSEBUTTON:
            scCommand = SC_CLOSE;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of titlebar") );
    }

    //
    // Context help puts into a modal loop, which will block the calling
    // thread until the loop ends.  Hence we post this instead of sending it.
    //
    // Note that we will no doubt do something similar in menus.
    //
    PostMessage(m_hwnd, WM_SYSCOMMAND, scCommand, 0L);
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\toolbar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLBAR.CPP
//
//  This knows how to talk to COMCTL32's tool bar control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include <tchar.h>

#include "toolbar.h"

#define MAX_NAME_SIZE   128 


#ifndef I_IMAGENONE
#define I_IMAGENONE             (-2)
#endif


// --------------------------------------------------------------------------
//
//  CreateToolBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateToolBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvTool)
{
    HRESULT hr;
    CToolBar32* ptool;

    InitPv(ppvTool);

    ptool = new CToolBar32(hwnd, idChildCur);
    if (! ptool)
        return(E_OUTOFMEMORY);

    hr = ptool->QueryInterface(riid, ppvTool);
    if (!SUCCEEDED(hr))
        delete ptool;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::CToolBar32()
//
// --------------------------------------------------------------------------
CToolBar32::CToolBar32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ToolBarClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::SetupChildren()
//
//  We need the # of buttons, plus 1 if there is a window child.
//
// --------------------------------------------------------------------------
void CToolBar32::SetupChildren()
{
    m_cChildren = SendMessageINT(m_hwnd, TB_BUTTONCOUNT, 0, 0);

    if (::GetWindow(m_hwnd,GW_CHILD))
        m_cChildren++;
}



// --------------------------------------------------------------------------
//
//  CToolBar32::GetItemData()
//
//  This gets the data from a button in the toolbar, the command ID, the 
//  state, the style, etc.  We need the command ID for example to pass to
//  most TB_ messages instead of the index.
//
// --------------------------------------------------------------------------
BOOL CToolBar32::GetItemData(int itemID, LPTBBUTTON lptbResult)
{
LPTBBUTTON  lptbShared;
BOOL        fReturn;
HANDLE      hProcess;

    fReturn = FALSE;

    // Allocate a TBBUTTON struct from shared memory.  The last member in
	// TBBUTTON is an INT_PTR (iString) which isn't used by OLEACC.  For
	// 32b, in case we're making a cross-proc call to a 64b server, we'll
	// add an extra DWORD onto the end of the memory we allocate so the struct
	// is correctly sized for a 64b server.  When reading back the lower
	// DWORD is lopped off.

	UINT ccbTButton = sizeof(TBBUTTON);
#ifdef _WIN32
	ccbTButton += sizeof(DWORD);
#endif

    lptbShared = (LPTBBUTTON)SharedAlloc(ccbTButton,m_hwnd,&hProcess);
    if (lptbShared)
    {
        if (SendMessage(m_hwnd, TB_GETBUTTON, itemID-1, (LPARAM)lptbShared))
        {
            SharedRead (lptbShared,lptbResult,sizeof(TBBUTTON),hProcess);
            fReturn = TRUE;
        }

        SharedFree(lptbShared,hProcess);
    }

    return(fReturn);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accName(VARIANT varChild, BSTR* pszName)
{
LPTSTR  lpszName = NULL;
HRESULT hr;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    // if child id is not zero (CHILDID_SELF)...
    hr = GetToolbarString (varChild.lVal,&lpszName);
    if( ! lpszName )
        return (hr); // will be S_FALSE or an E_error_code

    if (*lpszName)
    {
        StripMnemonic(lpszName);
        *pszName = TCharSysAllocString(lpszName);
    }

	LocalFree (lpszName);
    
    return(*pszName ? S_OK : S_FALSE);


}


// --------------------------------------------------------------------------
//
//  CToolBar32::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
TCHAR   chMnemonic = 0;
LPTSTR  lpszName = NULL;
HRESULT hr;

    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    // if child id is not zero (CHILDID_SELF)...
    hr = GetToolbarString (varChild.lVal,&lpszName);
    if ( ! lpszName )
        return (hr); // will be S_FALSE or E_error_code...

    if (*lpszName)
		chMnemonic = StripMnemonic(lpszName);

	LocalFree (lpszName);

	//
	// Is there a mnemonic?
	//
	if (chMnemonic)
	{
		//
		// Make a string of the form "Alt+ch".
		//
		TCHAR   szKey[2];

		*szKey = chMnemonic;
		*(szKey+1) = 0;

		return(HrMakeShortcut(szKey, pszShortcut));
	}

    return(S_FALSE);

}


// --------------------------------------------------------------------------
//
//  CToolBar32::GetToolbarString()
//
// Get the name of the item on the toolbar. There are two ways to do this - 
// You can just ask using the standard messages, or if that fails, you
// can try to get it from a tooltip. Since we need to do this for both name 
// and keyboard shortcut, we'll write a private method to get the 
// unstripped name.
//
// Parameters:
//		int	ChildId	        - the Child ID (1 based) of the item we want to get
//		LPTSTR*	ppszName	- pointer that will be LocalAlloc'ed and filled
//							  in with the name. Caller must LocalFree it.
//
//	Returns:
//
//      On Success:
//        returns S_TRUE, *ppszName will be non-NULL, caller must LocalFree() it.
//
//      On Failure:
//		  returns S_FALSE - no name available. *ppszName set to NULL.
//		  ...or...
//		  returns COM Failure code (including E_OUTOFMEMORY) - com/memory error.
//		  *ppszName set to NULL.
//
// Note: caller should take care if using "FAILED( hr )" to examine the return
// value of this method, since it does treats both S_OK and S_FALSE as 'success'.
// It may be better to check that *ppszName is non-NULL.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::GetToolbarString(int ChildId, LPTSTR* ppszName)
{
LPTSTR      lpszTextShared;
int         cchText;
int         nSomeInt;
TBBUTTON    tb;
HANDLE      hProcess;
LPTSTR      pszName = NULL;

	// Set this to NULL now, in case we return an error code (or S_FALSE) later...
    // (We'll set it to a valid return value later if we succeed...)
    *ppszName = NULL;

    // Get the button ID
    if (!GetItemData(ChildId, &tb))
        return(S_FALSE);

    //
    // Get the button text length.  NOTE:  If this is a separator item
    // then just return empty now.
    //
    if (tb.fsStyle & TBSTYLE_SEP)
        return(S_FALSE);

    cchText = SendMessageINT(m_hwnd, TB_GETBUTTONTEXT, tb.idCommand, 0);
    if (cchText && (cchText != -1))
    {
        // Allocate a buffer to hold it
        lpszTextShared = (LPTSTR)SharedAlloc((cchText+1)*sizeof(TCHAR),
                                        m_hwnd,&hProcess);

        if (! lpszTextShared)
            return(E_OUTOFMEMORY);

        pszName =  (LPTSTR)LocalAlloc(LPTR,(cchText+1)*sizeof(TCHAR));
        if (! pszName)
        {
            SharedFree (lpszTextShared,hProcess);
            return(E_OUTOFMEMORY);
        }

        // Get the button text
        nSomeInt = 0;
        SharedWrite (&nSomeInt,lpszTextShared,sizeof(int),hProcess);

        SendMessage(m_hwnd, TB_GETBUTTONTEXT, tb.idCommand, (LPARAM)lpszTextShared);

        SharedRead (lpszTextShared,pszName,(cchText+1)*sizeof(TCHAR),hProcess);
        SharedFree(lpszTextShared,hProcess);
    }
    else // Button has no text, so use tooltip method.
    {
        if ( ! GetTooltipStringForControl( m_hwnd, TB_GETTOOLTIPS, tb.idCommand, & pszName ) )
        {
            return S_FALSE;
        }
	}

	// At this stage, local var pszName points to a (possibly) empty string.
	// We deal with that next...

    // Paranoia...
    if( ! pszName )
    {
        return S_FALSE;
    }

    // do we have a non-empty string?
    if( *pszName )
	{
		*ppszName = pszName;
        return S_OK;
	}
	else
	{
		// Free the 'empty' pszName...
		LocalFree( pszName );
		return S_FALSE;
	}
}


// --------------------------------------------------------------------------
//
//  CToolBar32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        pvarRole->vt = VT_I4;
        pvarRole->lVal = ROLE_SYSTEM_TOOLBAR;
    }
    else
    {
        TBBUTTON tb;

        // Get the button type (checkbox, radio, or push).
        if (!GetItemData(varChild.lVal, &tb))
            return(S_FALSE);

        pvarRole->vt = VT_I4;

        BOOL bHasImageList = SendMessage( m_hwnd, TB_GETIMAGELIST, 0, 0 ) != 0;
	    DWORD dwExStyle = SendMessageINT( m_hwnd, TB_GETEXTENDEDSTYLE, 0, 0 );

        // If a separator, say so
		if (tb.fsStyle & TBSTYLE_SEP)
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else if (tb.fsStyle & TBSTYLE_CHECK)
        {
            // Special case for task list - they use the checked style, but only for visuals...
            TCHAR szClassName[ 64 ];
            HWND hwndParent = GetParent( m_hwnd );
            if ( hwndParent != NULL
                && GetClassName( hwndParent, szClassName, ARRAYSIZE( szClassName ) )
                && ( lstrcmp( szClassName, TEXT("MSTaskSwWClass") ) == 0 ) )
            {
                pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            }
            else
            {
			    // Check other possible styles
                if (tb.fsStyle & TBSTYLE_GROUP)
                    pvarRole->lVal = ROLE_SYSTEM_RADIOBUTTON;
                else
                    pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
        }
        else if (!bHasImageList || tb.iBitmap == I_IMAGENONE )
        {
            // TODO - check that it's not a standard image (since they don't require an
            // imagelist?

            // Text-only, no bitmap, so it's effectively a menu item.
            // (eg. as used in MMC)
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        }
        else if ( ( tb.fsStyle & TBSTYLE_DROPDOWN ) && ( dwExStyle & TBSTYLE_EX_DRAWDDARROWS ) )
		{
			// if its a drop down and it has an arrow its a split button
			pvarRole->lVal = ROLE_SYSTEM_SPLITBUTTON;
		}
		else
		{	
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
		}
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
	{
        return CClient::get_accState( varChild, pvarState );
	}
    else
    {
        TBBUTTON tb;

        if (! GetItemData(varChild.lVal, &tb))
        {
            pvarState->vt = VT_I4;
            pvarState->lVal = STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (tb.fsState & TBSTATE_CHECKED)
            pvarState->lVal |= STATE_SYSTEM_CHECKED;
        if (tb.fsState & TBSTATE_PRESSED)
            pvarState->lVal |= STATE_SYSTEM_PRESSED;
        if (!(tb.fsState & TBSTATE_ENABLED))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (tb.fsState & TBSTATE_HIDDEN)
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        else
        {
            if( IsClippedByWindow( this, varChild, m_hwnd ) )
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
            }
        }

        if (tb.fsState & TBSTATE_INDETERMINATE)
            pvarState->lVal |= STATE_SYSTEM_MIXED;

        if (tb.fsStyle & TBSTYLE_ALTDRAG)
            pvarState->lVal |= STATE_SYSTEM_MOVEABLE;


        // Special case for task list - they use the checked style, but only for visuals...
        TCHAR szClassName[ 64 ];
        HWND hwndParent = GetParent( m_hwnd );
        if ( hwndParent != NULL
            && GetClassName( hwndParent, szClassName, ARRAYSIZE( szClassName ) )
            && ( lstrcmp( szClassName, TEXT("MSTaskSwWClass") ) == 0 ) )
        {
            // Change the checked state into pressed instead...
            if( pvarState->lVal & STATE_SYSTEM_CHECKED )
            {
                pvarState->lVal &= ~ STATE_SYSTEM_CHECKED;
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            }
        }


        // idChild-1 will never == -1 here, since we handle that case (id==CHILDID_SELF)
        // in the first branch of this if. (TB_GETHOTITEM returns -1 if there's no hot item.)
        if( SendMessage( m_hwnd, TB_GETHOTITEM, 0, 0 ) == varChild.lVal - 1 )
        {
            pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

            // This doesn't quite work...
            // Some apps - notably MMCs - don't actually focus their toolbar -
            // they leave their main MDI child focused. So we have no way of
            // telling whether the menu is hot because it's in 'focus' mode
            // or whether it's just because the mouse is over it (not really
            // focused).
            //
            // But at least this finally gets us the correct state for the quick
            // launch toolbar.
            if( MyGetFocus() == m_hwnd )
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }
        }

        // What about separators?
		// CWO, 4/22/97, Separators have a state of TBSTATE_ENABLED

        return(S_OK);
    }
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accDefaultAction()
//
//  Default action is same as the name of the button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accDefaultAction(VARIANT varChild, BSTR* pszDef)
{
    InitPv(pszDef);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDef));
    else
    {
        TBBUTTON tb;

        // TBSTYLE_DROP has a different default action than the name
        if (GetItemData(varChild.lVal, &tb) && (tb.fsStyle & TBSTYLE_DROPDOWN))
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDef));
        else
            return(HrCreateString(STR_BUTTON_PUSH, pszDef));
    }
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
    else
    {
        LPRECT  prcShared;
        HRESULT hr;
        RECT    rcLocal;
        HANDLE  hProcess;

        // Allocate a Shared RECT
        prcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
        if (! prcShared)
            return(E_OUTOFMEMORY);

        // This returns FALSE if the button is hidden
        if (SendMessage(m_hwnd, TB_GETITEMRECT, varChild.lVal-1, (LPARAM)prcShared))
        {
            hr = S_OK;

            SharedRead (prcShared,&rcLocal,sizeof(RECT),hProcess);
            MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

            *pxLeft = rcLocal.left;
            *pyTop = rcLocal.top;
            *pcxWidth = rcLocal.right - rcLocal.left;
            *pcyHeight = rcLocal.bottom - rcLocal.top;
        }
        else
            hr = S_FALSE;

        SharedFree(prcShared,hProcess);

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CToolBar32::accNavigate()
//
//  Toolbar clients can only set an indent on the left side.  Hence all
//  child window objects are on the left, buttons are on the right.
//
//  BOGUS!  Doesn't deal with wrapped toolbars yet.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    int lEnd = 0;
    TBBUTTON tb;

    InitPvar(pvarEnd);

    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    // Peer-to-peer navigation in nonclient
    if (!varStart.lVal && (dwNavDir < NAVDIR_FIRSTCHILD))
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Nav is strange, the first items on the left have the highest IDs.
    //
    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal;

            // Toolbars can't really have windows as children - it is
            // a hack that explorer does. Because it is a hack, we know
            // that when we get starting point that is a window, it is 
            // the first child, so to naviagte next, we just move to the
            // first 'real' child. 
            // If we are trying to navigate next from 0 (the toolbar itself) 
            // we just check if the toolbar window has a child window, and 
            // return a dispatch interface to that child.
            if (lEnd == CHILDID_SELF)
            {
            HWND    hwndChild;

                if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
                {
			        pvarEnd->vt=VT_DISPATCH;
                    return (AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                        IID_IDispatch, (void**)&pvarEnd->pdispVal));
                }
            }
            // just set lEnd to 0 so we get the first 'real' child
            // of the toolbar - the first button.
            if (IsHWNDID(lEnd))
                lEnd = 0;

            while (++lEnd <= m_cChildren)
            {
                //
                // Is this a visible child?
				// CWO, 4/22/97, removed separate clause
                //
                if (GetItemData(lEnd, &tb) && !(tb.fsState & TBSTATE_HIDDEN))
                    break; // out of while loop
            }

            if (lEnd > m_cChildren)
                lEnd = 0;
            break; // out of switch 

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal;

            // Navigating previous is similar to next when dealing with 
            // children that are windows. If the start point is a child
            // window, then the end point is 0, the toolbar itself. If
            // the end point (after doing normal children) is 0, then 
            // check if the toolbar has a child window and if so, return
            // a dispatch interface to that object.
            if (IsHWNDID(lEnd))
            {
                lEnd = 0;
                break; // out of switch
            }
            while (--lEnd > 0)
            {
                //
                // Is this a visible child?
                // CWO, 4/22/97, removed separate clause
				//
                if (GetItemData(lEnd, &tb) && !(tb.fsState & TBSTATE_HIDDEN))
                    break; // out of while
            }
            if (lEnd == CHILDID_SELF)
            {
            HWND    hwndChild;

                if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
                {
			        pvarEnd->vt=VT_DISPATCH;
                    return (AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                        IID_IDispatch, (void**)&pvarEnd->pdispVal));
                }
            }
            break; // out of switch

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            lEnd = 0;
            // Don't handle wrapping toolbars yet.
            break; // out of switch
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accHitTest()
//
//  First, ask the client window what is here.  If itself, then try the
//  buttons.  If nothing/child window, return that thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    POINT   pt;
    LPRECT  lprcShared;
    int     iButton;
    HRESULT hr;
    RECT    rcLocal;
    HANDLE  hProcess;

    SetupChildren();

    //
    // Is this point in our client, not in any child window?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    //
    // Figure out what button this point is over.  We have to do this the
    // hard way, by looping through the buttons asking for location.
    //
    lprcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprcShared)
        return(E_OUTOFMEMORY);

    for (iButton = 0; iButton < m_cChildren; iButton++)
    {
        if (SendMessage(m_hwnd, TB_GETITEMRECT, iButton, (LPARAM)lprcShared))
        {
            SharedRead (lprcShared,&rcLocal,sizeof(RECT),hProcess);
            if (PtInRect(&rcLocal, pt))
            {
                pvarHit->vt = VT_I4;
                pvarHit->lVal = iButton+1;

                SharedFree(lprcShared,hProcess);
                return(S_OK);
            }
        }
    }

    //
    // If we got here, the point is not over any toolbar item.  It must be
    // over ourself.
    //

    SharedFree(lprcShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accDoDefaultAction()
//
//  This sends the command that the button represents.  We can't fake a click
//  because that won't work if the window isn't active.  
//
//  We have to send a WM_COMMAND, BN_CLICKED to the toolbar parent.  Problem
//  is, no easy way to get the parent.  So we set it (which returns the old
//  one, then set it back).
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accDoDefaultAction(VARIANT varChild)
{
    HWND    hwndToolBarParent;
    TBBUTTON tb;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    //
    // Get the toolbar parent in a hacky way, by setting it then setting
    // it back.  THIS CODE ASSUMES THAT THE HANDLING IS MINIMAL IN COMCTL32.
    //
    hwndToolBarParent = (HWND)SendMessage(m_hwnd, TB_SETPARENT, 0, 0);
    SendMessage(m_hwnd, TB_SETPARENT, (WPARAM)hwndToolBarParent, 0);

    if (! hwndToolBarParent)
        return(S_FALSE);

    //
    // Get the command ID of this button, and generate a BN_CLICK if it
    // isn't a separator.
    //
    if (GetItemData(varChild.lVal, &tb) &&
        !(tb.fsStyle & TBSTYLE_SEP) &&
        (tb.fsState & TBSTATE_ENABLED) &&
        !(tb.fsState & TBSTATE_HIDDEN))
    {
        PostMessage(hwndToolBarParent, WM_COMMAND, MAKEWPARAM(tb.idCommand, BN_CLICKED), (LPARAM)m_hwnd);
        return(S_OK);
    }
    else
        return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CToolBar32::Next()
//
//  This knows that the first child might be an HWND.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
HWND        hwndChild;
VARIANT*    pvar;
long        cFetched;
HRESULT     hr;
long        iCur;
long        cChildTemp;

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    cFetched = 0;

    // check for window handle child first
    if (m_idChildCur == CHILDID_SELF)
    {
        if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
        {
			rgvar->vt=VT_DISPATCH;
            hr = AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                IID_IDispatch, (void**)&rgvar->pdispVal);

            if (!SUCCEEDED(hr))
                return(hr);

            // decrement how many left to get
            celt--;
            cFetched = 1;
            // increment to next variant in array
            rgvar++;

            // increment count of fetched
            if (pceltFetched)
                (*pceltFetched)++;

            // remember current child
            m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndChild);
            
            // if no more to get, return
            if (!celt)
                return(S_OK);
        } // end if there is a child window
    } // end if (started at 0)


    // now get any non-window children
    pvar = rgvar;
    iCur = m_idChildCur;
    if (IsHWNDID(iCur))
        iCur = 0;

    //
    // Loop through our items. Need to do different if there is a 
    // window child, because m_cChildren will be +1.
    //
    cChildTemp = m_cChildren;
    if (::GetWindow(m_hwnd,GW_CHILD))
        cChildTemp--;
    while ((cFetched < (long)celt) && (iCur < cChildTemp))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us (index)+1 because we incremented iCur
        //
        pvar->vt = VT_I4;
        pvar->lVal = iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;
    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\tooltips.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLTIPS.CPP
//
//  Knows how to talk to COMCTL32's tooltips.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "tooltips.h"

#include <commctrl.h>

#include "win64helper.h"


#ifndef TTS_BALLOON
#define TTS_BALLOON             0x40
#endif


// --------------------------------------------------------------------------
//
//  CreateToolTipsClient()
//
// --------------------------------------------------------------------------
HRESULT CreateToolTipsClient(HWND hwnd, long idChildCur, REFIID riid, void **ppvToolTips)
{
    CToolTips32 *   ptooltips;
    HRESULT         hr;

    InitPv(ppvToolTips);

    ptooltips = new CToolTips32(hwnd, idChildCur);
    if (!ptooltips)
        return(E_OUTOFMEMORY);

    hr = ptooltips->QueryInterface(riid, ppvToolTips);
    if (!SUCCEEDED(hr))
        delete ptooltips;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CToolTips32::CToolTips32()
//
// --------------------------------------------------------------------------
CToolTips32::CToolTips32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ToolTipsClient )
{
    Initialize(hwnd, idChildCur);
}


// --------------------------------------------------------------------------
//
//  CToolTips32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolTips32::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    HRESULT hr = HrGetWindowName(m_hwnd, m_fUseLabel, pszName);

    if( FAILED( hr ) )
    {
        return hr;
    }

    // Check for title...
    WCHAR szTitle[ 1024 ];
    TTGETTITLE ttgt;
    ttgt.dwSize = sizeof( ttgt );
    ttgt.pszTitle = szTitle;
    ttgt.cch = ARRAYSIZE( szTitle );

    if( S_OK == XSend_ToolTip_GetTitle( m_hwnd, TTM_GETTITLE, 0, & ttgt ) 
        && szTitle[ 0 ] != '\0' )
    {
        // Got a title - glue it in front of the name string. If we didn't
        // get a name string, use the title on its own.
        int cchTitle = lstrlenW( szTitle );

        int cchName = 0;
        int cchSep = 0;
        if( *pszName )
        {
            cchName = lstrlenW( *pszName );
            cchSep = 2; // space for ": "
        }
        
        // SysAllocStringLen adds an extra 1 for terminating NUL, so we don't have to.
        BSTR bstrCombined = SysAllocStringLen( NULL, cchTitle + cchSep + cchName );
        if( ! bstrCombined )
        {
            // Just go with whatever we got above...
            return hr;
        }

        memcpy( bstrCombined, szTitle, cchTitle * sizeof( WCHAR ) );
        if( *pszName )
        {
            memcpy( bstrCombined + cchTitle, L": ", cchSep * sizeof( WCHAR ) );
            memcpy( bstrCombined + cchTitle + cchSep, *pszName, cchName * sizeof( WCHAR ) );

            SysFreeString( *pszName );
        }

        // Add terminating NUL, copy string to out param...
        bstrCombined[ cchName + cchSep + cchTitle ] = '\0';
        
        *pszName = bstrCombined;
    }

    return hr;
}


// --------------------------------------------------------------------------
//
//  CToolTips32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolTips32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    DWORD dwStyle = GetWindowLong( m_hwnd, GWL_STYLE );

    pvarRole->vt = VT_I4;

    if( dwStyle & TTS_BALLOON )
        pvarRole->lVal = ROLE_SYSTEM_HELPBALLOON;
    else
        pvarRole->lVal = ROLE_SYSTEM_TOOLTIP;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\toolbar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLBAR.H
//
//  This communicates with COMCTL32's tool bar control.
//
// --------------------------------------------------------------------------


class CToolBar32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT, BSTR*);
        STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP    get_accState(VARIANT, VARIANT*);
        STDMETHODIMP    get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP    accHitTest(long, long, VARIANT*);
        STDMETHODIMP    accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP    Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched);

        // constructor
        CToolBar32(HWND, long);

        // misc. methods
        BOOL                GetItemData(int, LPTBBUTTON);
        void                SetupChildren();

    private:
        STDMETHODIMP    GetToolbarString(int ChildId, LPTSTR* ppszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\types6432.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  types6432
//
//  basetsd.h substitute;
//  allows compliation on 32-bit systems without the up-to-date basetsd.h
//  defines.
//
//  If using VC6 headers, define NEED_BASETSD_DEFINES.
//  VC6 does have basetsd.h, but it's inconsistent with the current one.
//  (eg. it typedefs INT_PTR as long - causing int/long conversion errors -
//  should be plain int.)
//
// --------------------------------------------------------------------------

//
// Win64 compatibility
//

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )

typedef unsigned long UINT_PTR;
typedef ULONG ULONG_PTR;
typedef DWORD DWORD_PTR;
typedef LONG  LONG_PTR;
#define PtrToInt  (int)
#define IntToPtr  (void *)
#define HandleToLong  (long)
#define LongToHandle (HANDLE)

// These 'override' VC6's broken INT_PTR definitions.
// That defines them as long - which causes long/int conversion problems.
// Here, we correctly define them as int- types.
// #define used sin'ce we can't untypedef the existing ones.

typedef int MY_INT_PTR;
typedef unsigned int MY_UINT_PTR;
#define INT_PTR MY_INT_PTR
#define UINT_PTR MY_UINT_PTR

#define SetWindowLongPtr    SetWindowLong
#define SetWindowLongPtrA   SetWindowLongA
#define SetWindowLongPtrW   SetWindowLongW
#define GetWindowLongPtr    GetWindowLong
#define GetWindowLongPtrA   GetWindowLongA
#define GetWindowLongPtrW   GetWindowLongW

#define SetClassLongPtr     SetClassLong
#define SetClassLongPtrA    SetClassLongA
#define SetClassLongPtrW    SetClassLongW
#define GetClassLongPtr     GetClassLong
#define GetClassLongPtrA    GetClassLongA
#define GetClassLongPtrW    GetClassLongW


#define GWLP_USERDATA       GWL_USERDATA
#define GWLP_WNDPROC        GWL_WNDPROC

#define GCLP_HMODULE        GCL_HMODULE

#endif



//
// inlines for SendMessage - saves having casts all over the place.
//
// SendMessageUINT - used when expecting a 32-bit return value - eg. text
//     length, number of elements, size of small (<4G) structures, etc.
//     (ie. almost all windows API messages)
//
// SendMessagePTR - used when expecting a pointer (32 or 64) return value
//     (ie. WM_GETOBJECT)
//

inline INT SendMessageINT( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    // Signed int, in keeping with LRESULT, which is also signed...
    return (INT)SendMessage( hWnd, uMsg, wParam, lParam );
}

inline void * SendMessagePTR( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return (void *) SendMessage( hWnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\tooltips.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLTIPS.H
//
//  Knows how to talk to COMCTL32's tooltips.
//
// --------------------------------------------------------------------------


class CToolTips32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR *pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);

        CToolTips32(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\updown.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  UPDOWN.CPP
//
//  This knows how to talk to COMCTL32's updown control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "updown.h"


#define NOSTATUSBAR
#define NOTOOLBAR
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>




// --------------------------------------------------------------------------
//
//  CreateUpDownClient()
//
// --------------------------------------------------------------------------
HRESULT CreateUpDownClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvClient)
{
    CUpDown32 * pupdown;
    HRESULT     hr;

    InitPv(ppvClient);

    pupdown = new CUpDown32(hwnd, idChildCur);
    if (!pupdown)
        return(E_OUTOFMEMORY);

    hr = pupdown->QueryInterface(riid, ppvClient);
    if (!SUCCEEDED(hr))
        delete pupdown;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::CUpDown32()
//
// --------------------------------------------------------------------------
CUpDown32::CUpDown32(HWND hwnd, long idChildCur)
    : CClient( CLASS_UpDownClient )
{
    Initialize(hwnd, idChildCur);

    m_cChildren = CCHILDREN_UPDOWN;

    if (!(GetWindowLong(m_hwnd, GWL_STYLE) & UDS_HORZ))
        m_fVertical = TRUE;
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    //
    // Remember:
    // Spin buttons work opposite to the way that scrollbars do.  When you 
    // push the up arrow button in a vertical scrollbar, you are _decreasing_
    // the position of the vertical scrollbar, its value.  When you push
    // the up arrow button in a vertical spin button, you are _increasing_
    // its value.
    //
    return(HrCreateString(STR_SPIN_GREATER + varChild.lVal - 1, pszName));
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return E_NOT_APPLICABLE;
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
    else
        pvarRole->lVal = ROLE_SYSTEM_SPINBUTTON;
    
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;
    int     iCoord;
    int     nHalf;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    // The buttons split the client area in half.
    MyGetRect(m_hwnd, &rc, FALSE);
    MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

    iCoord = (m_fVertical ? 1 : 0);
    nHalf = (((LPINT)&rc)[iCoord] + ((LPINT)&rc)[iCoord+2]) / 2;

    //
    // We want the right side of the left button to be the halfway point.
    // We want the left side of the right button to be the halfway point.
    // We want the bottom side of the up button to be the halfway point.
    // We want the top side of the down button to be the halfway point.
    //
    ((LPINT)&rc)[iCoord + ((varChild.lVal == INDEX_UPDOWN_UPLEFT) ? 2 : 0)] =
        nHalf;

    *pxLeft = rc.left;
    *pyTop = rc.top;
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT hr;
    POINT   pt;
    RECT    rc;
    int     iCoord;
    int     nHalf;

    //
    // If the point isn't in us at all, don't bother hit-testing for the
    // button item.
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    MyGetRect(m_hwnd, &rc, FALSE);

    iCoord = (m_fVertical ? 1 : 0);
    nHalf = (((LPINT)&rc)[iCoord] + ((LPINT)&rc)[iCoord+2]) / 2;

    if (((LPINT)&pt)[iCoord] < nHalf)
        pvarHit->lVal = INDEX_UPDOWN_UPLEFT;
    else
        pvarHit->lVal = INDEX_UPDOWN_DNRIGHT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    long    lEnd = 0;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
NextChild:
            lEnd = varStart.lVal+1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
PreviousChild:
            lEnd = varStart.lVal-1;
            break;

        case NAVDIR_UP:
            if (m_fVertical)
                goto PreviousChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_DOWN:
            if (m_fVertical)
                goto NextChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_LEFT:
            if (!m_fVertical)
                goto PreviousChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_RIGHT:
            if (!m_fVertical)
                goto NextChild;
            else
                lEnd = 0;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    // 
    // BOGUS!  Do we set the pos directly, or set this in the buddy?
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    lPos = 0;
    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    SendMessage(m_hwnd, UDM_SETPOS, 0, lPos);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\updown.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  UPDOWN.H
//
//  This knows how to talk to COMCTL32's updown control
//
// --------------------------------------------------------------------------


class CUpDown32 : public CClient
{
    public:
        // IAccessible
        // BOGUS!  No way to do default action support!
        //         Or button state.  Need COMCTL32 help.
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);

        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        STDMETHODIMP        put_accValue(VARIANT, BSTR);

        CUpDown32(HWND, long);

    protected:
        BOOL    m_fVertical;
};


#define INDEX_UPDOWN_SELF       0
#define INDEX_UPDOWN_UPLEFT     1
#define INDEX_UPDOWN_DNRIGHT    2
#define CCHILDREN_UPDOWN        2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\util.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  util
//
//  Miscellaneous helper routines
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
//#include "util.h" // already in oleacc_p.h

#include "propmgr_util.h"
#include "propmgr_client.h"

#include <commctrl.h>

#include "Win64Helper.h"

const LPCTSTR g_szHotKeyEvent = TEXT("MSAASetHotKeyEvent");
const LPCTSTR g_szHotKeyAtom = TEXT("MSAASetFocusHotKey");
const LPCTSTR g_szMessageWindowClass = TEXT("MSAAMessageWindow");
#define HWND_MESSAGE     ((HWND)-3)
#define HOT_KEY 0xB9
LRESULT CALLBACK MessageWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

// This class is used to give aother window focus.
// This used to be done using SetForgroundWindow but in Win2k and beyond you (as in your thread) 
// must have input focus in order for SetForgroundWindow to work.  This class create a message 
// window, then registers a HotKey, sends that HotKey to the window and waits for that key to get
// to its window proc.  When it does I now has input focus and can call SetForgroundWindow with 
// the desired affect.
class CSetForegroundWindowHelper
{

public:
	CSetForegroundWindowHelper() : 
        m_hwndMessageWindow( NULL ), 
        m_atomHotKeyId( 0 ), 
        m_vkHotKey( 0 ), 
        m_fReceivedHotKey( FALSE ), 
        m_hwndTarget( NULL ),
        m_cUseCount( 0 )
	{
	}
	
	~CSetForegroundWindowHelper() 
	{
        Reset();
    }

    BOOL SetForegroundWindow( HWND hwnd );
    LRESULT CALLBACK CSetForegroundWindowHelper::WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    

private:

    BOOL RegHotKey();
    void UnRegHotKey();
    BOOL CreateHiddenWindow();
    void Reset();
   
private:

    HWND m_hwndMessageWindow;
    ATOM m_atomHotKeyId;
    WORD m_vkHotKey;      // this virtural key is undefined
    HWND m_hwndTarget;
    bool m_fReceivedHotKey;
    int  m_cUseCount;

};


BOOL CSetForegroundWindowHelper::SetForegroundWindow( HWND hwnd )
{
    // if a regular SetForegroundWindow works their is no reason to go through all this
    // work.  This will be the case in win9x and win2k administrators.
    if ( ::SetForegroundWindow( hwnd ) )
        return TRUE;

    if ( !m_hwndMessageWindow )
    {
        m_vkHotKey = HOT_KEY;

        if ( !CreateHiddenWindow() )
        {
            DBPRINTF( TEXT("CreateHiddenWindow failed") );
            return FALSE;
        }

        // Wake up in 5 minutes and see if anyone is using this window
        SetTimer( m_hwndMessageWindow, 1, 300000, NULL );
    }

    if ( !RegHotKey() )
    {
        DBPRINTF( TEXT("RegHotKey failed") );
        return FALSE;
    }

    m_hwndTarget = hwnd;
    m_cUseCount++;

    m_fReceivedHotKey = false;

    MyBlockInput (TRUE);
    // Get state of shift keys and if they are down, send an up
    // when we're done
    BOOL fCtrlPressed = GetKeyState(VK_CONTROL) & 0x8000;
    BOOL fAltPressed = GetKeyState(VK_MENU) & 0x8000;
    BOOL fShiftPressed = GetKeyState(VK_SHIFT) & 0x8000;
    if (fCtrlPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_SHIFT,0);


    // send the hot key
    SendKey( KEYPRESS, VK_VIRTUAL, m_vkHotKey, 0 ); 
    SendKey( KEYRELEASE, VK_VIRTUAL, m_vkHotKey, 0 );

    // send shift key down events if they were down before
    if (fCtrlPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_SHIFT,0);
    MyBlockInput (FALSE);

    MSG msg;
    // Spin in this message loop until we get the hot key
    while ( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
        if ( m_fReceivedHotKey )
            break;
    }
    m_fReceivedHotKey = false;
    
    UnRegHotKey();
    
    return TRUE;
}

LRESULT CALLBACK CSetForegroundWindowHelper::WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = 0;

    switch( Msg )
    {
        case WM_HOTKEY:
            m_fReceivedHotKey = TRUE;
            ::SetForegroundWindow( m_hwndTarget );
            break;

        case WM_TIMER:
            if ( m_cUseCount == 0 )
            {
                KillTimer( m_hwndMessageWindow, 1 );
                Reset();
            }
            m_cUseCount = 0;
            break;

        default:
            lReturn = DefWindowProc( hWnd, Msg, wParam, lParam );
    }


    return lReturn;
}

BOOL CSetForegroundWindowHelper::RegHotKey()
{
    // If the ATOM is set the we already have a registered HotKey so get out
    if ( m_atomHotKeyId )
        return TRUE;

    const UINT uiModifiers = 0;
    const int cMaxTries = 20;
    bool fFoundHotKey = false;
    m_atomHotKeyId = GlobalAddAtom( g_szHotKeyAtom );

    //  Try a buch if different hot keys incase its already registered
    for ( int i = 0; i < cMaxTries; i++, m_vkHotKey-- )
    {
        if ( RegisterHotKey(m_hwndMessageWindow, m_atomHotKeyId, uiModifiers, m_vkHotKey ) )
        {
            DBPRINTF( TEXT("HotKey found\r\n") );
            fFoundHotKey = true;
            break;
        }
    }

    // only report an error if it the last try
    if ( !fFoundHotKey )
    {
        DBPRINTF( TEXT("RegisterHotKey failed, error = %d\r\n"), GetLastError() );
        GlobalDeleteAtom( m_atomHotKeyId  );
        m_atomHotKeyId = 0;
        return FALSE;
    }

    return TRUE;
}

void CSetForegroundWindowHelper::UnRegHotKey()
{
    if ( m_atomHotKeyId )
    {
        UnregisterHotKey( m_hwndMessageWindow, m_atomHotKeyId );
        GlobalDeleteAtom( m_atomHotKeyId  );
        m_atomHotKeyId = 0;
        m_vkHotKey = HOT_KEY;
    }

}

// create a message only window this is just used to get a hotkey message
BOOL CSetForegroundWindowHelper::CreateHiddenWindow()
{
    WNDCLASSEX wc;

    ZeroMemory( &wc, sizeof(WNDCLASSEX) );

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = MessageWindowProc;
    wc.lpszClassName = g_szMessageWindowClass;

    if( 0 == RegisterClassEx( &wc ) )
    {   
        DWORD dwError = GetLastError();

        if ( ERROR_CLASS_ALREADY_EXISTS != dwError )
        {
            DBPRINTF( TEXT("Register window class failed, error = %d\r\n"), dwError);
            return FALSE;
        }
    }

    m_hwndMessageWindow = CreateWindowEx(0,
                                         g_szMessageWindowClass,
                                         g_szMessageWindowClass,
                                         0,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         HWND_MESSAGE,
                                         NULL,
                                         NULL,
                                         NULL);

    if( !m_hwndMessageWindow )
    {
        DBPRINTF( TEXT("CreateWindowEx failed, error = %d\r\n"), GetLastError() );
        return FALSE;
    }

    return TRUE;
}

void CSetForegroundWindowHelper::Reset()
{
    UnRegHotKey();
    
    if ( m_hwndMessageWindow )
    {
        DestroyWindow( m_hwndMessageWindow );
        m_hwndMessageWindow = NULL;
    }
}

CSetForegroundWindowHelper g_GetFocus;

LRESULT CALLBACK MessageWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    return g_GetFocus.WinProc( hWnd, Msg, wParam, lParam );
}


////////////////////////////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------
//
// ClickOnTheRect
//
// This function takes a pointer to a rectangle that contains coordinates
// in the form (top,left) (width,height). These are screen coordinates. It
// then finds the center of that rectangle and checks that the window handle
// given is in fact the window at that point. If so, it uses the SendInput
// function to move the mouse to the center of the rectangle, do a single
// click of the default button, and then move the cursor back where it
// started. In order to be super-robust, it checks the Async state of the 
// shift keys (Shift, Ctrl, and Alt) and turns them off while doing the 
// click, then back on if they were on. if fDblClick is TRUE, it will do
// a double click instead of a single click.
//
// We have to make sure we are not interrupted while doing this!
//
// Returns TRUE if it did it, FALSE if there was some bad error.
//
// --------------------------------------------------------------------------

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;


BOOL ClickOnTheRect(LPRECT lprcLoc,HWND hwndToCheck,BOOL fDblClick)
{
    POINT		ptCursor;
    POINT		ptClick;
    HWND		hwndAtPoint;
    MOUSEINFO	miSave;
    MOUSEINFO   miNew;
    int			nButtons;
    INPUT		rgInput[6];
    int         i;
    DWORD		dwMouseDown;
    DWORD		dwMouseUp;

    // Find Center of rect
	ptClick.x = lprcLoc->left + (lprcLoc->right/2);
	ptClick.y = lprcLoc->top + (lprcLoc->bottom/2);

	// check if hwnd at point is same as hwnd to check
	hwndAtPoint = WindowFromPoint (ptClick);
	if (hwndAtPoint != hwndToCheck)
		return FALSE;

    MyBlockInput (TRUE);
    // Get current cursor pos.
    GetCursorPos(&ptCursor);
	if (GetSystemMetrics(SM_SWAPBUTTON))
	{
		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
		dwMouseUp = MOUSEEVENTF_RIGHTUP;
	}
	else
	{
		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
		dwMouseUp = MOUSEEVENTF_LEFTUP;
	}

    // Get delta to move to center of rectangle from current
    // cursor location.
    ptCursor.x = ptClick.x - ptCursor.x;
    ptCursor.y = ptClick.y - ptCursor.y;

    // NOTE:  For relative moves, USER actually multiplies the
    // coords by any acceleration.  But accounting for it is too
    // hard and wrap around stuff is weird.  So, temporarily turn
    // acceleration off; then turn it back on after playback.

    // Save mouse acceleration info
    if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
    {
        MyBlockInput (FALSE);
        return (FALSE);
    }

    if (miSave.MouseSpeed)
    {
        miNew.MouseThresh1 = 0;
        miNew.MouseThresh2 = 0;
        miNew.MouseSpeed = 0;

        if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
        {
            MyBlockInput (FALSE);
            return (FALSE);
        }
    }

    // Get # of buttons
    nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

    // Get state of shift keys and if they are down, send an up
    // when we're done

    BOOL fCtrlPressed = GetKeyState(VK_CONTROL) & 0x8000;
    BOOL fAltPressed = GetKeyState(VK_MENU) & 0x8000;
    BOOL fShiftPressed = GetKeyState(VK_SHIFT) & 0x8000;
    if (fCtrlPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_SHIFT,0);

    DWORD time = GetTickCount();

    // mouse move to center of start button
    rgInput[0].type = INPUT_MOUSE;
    rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
    rgInput[0].mi.dwExtraInfo = 0;
    rgInput[0].mi.dx = ptCursor.x;
    rgInput[0].mi.dy = ptCursor.y;
    rgInput[0].mi.mouseData = nButtons;
    rgInput[0].mi.time = time;

    i = 1;

DBL_CLICK:
    // Mouse click down, left button
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = dwMouseDown;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = 0;
    rgInput[i].mi.dy = 0;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    // Mouse click up, left button
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = dwMouseUp;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = 0;
    rgInput[i].mi.dy = 0;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    if (fDblClick)
    {
        fDblClick = FALSE;
        goto DBL_CLICK;
    }
	// move mouse back to starting location
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = -ptCursor.x;
    rgInput[i].mi.dy = -ptCursor.y;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    if (!MySendInput(i, rgInput,sizeof(INPUT)))
        MessageBeep(0);

    // send shift key down events if they were down before
    if (fCtrlPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_SHIFT,0);

    //
    // Restore Mouse Acceleration
    //
    if (miSave.MouseSpeed)
        SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

    MyBlockInput (FALSE);

	return TRUE;
}






//--------------------------------------------------------------------------
//
//  SendKey
//
// This is a private function. Sends the key event specified by 
// the parameters - down or up, plus a virtual key code or character. 
//
// Parameters:
//  nEvent          either KEYPRESS or KEYRELEASE
//  nKeyType        either VK_VIRTUAL or VK_CHAR
//  wKeyCode        a Virtual Key code if KeyType is VK_VIRTUAL,
//                  ignored otherwise
//  cChar           a Character if KeyType is VK_CHAR, ignored otherwise.
//
// Returns:
//  BOOL indicating success (TRUE) or failure (FALSE)
//--------------------------------------------------------------------------
BOOL SendKey (int nEvent,int nKeyType,WORD wKeyCode,TCHAR cChar)
{
    INPUT		Input;

    Input.type = INPUT_KEYBOARD;
    if (nKeyType == VK_VIRTUAL)
    {
        Input.ki.wVk = wKeyCode;
        Input.ki.wScan = LOWORD(MapVirtualKey(wKeyCode,0));
    }
    else // must be a character
    {
        Input.ki.wVk = VkKeyScan (cChar);
        Input.ki.wScan = LOWORD(OemKeyScan (cChar));
    }
    Input.ki.dwFlags = nEvent;
    Input.ki.time = GetTickCount();
    Input.ki.dwExtraInfo = 0;

    return MySendInput(1, &Input,sizeof(INPUT));
}


// --------------------------------------------------------------------------
//
//  MyGetFocus()
//
//  Gets the focus on this window's VWI.
//
// --------------------------------------------------------------------------
HWND MyGetFocus()
{
    GUITHREADINFO     gui;

    //
    // Use the foreground thread.  If nobody is the foreground, nobody has
    // the focus either.
    //
    if (!MyGetGUIThreadInfo(0, &gui))
        return(NULL);

    return(gui.hwndFocus);
}



// --------------------------------------------------------------------------
//
//  MySetFocus()
//
//  Attempts to set the focused window.
//  Since SetFocus only works on HWNDs owned by the calling thread,
//  we use SetActiveWindow instead.
//
// --------------------------------------------------------------------------
void MySetFocus( HWND hwnd )
{

    HWND hwndParent = hwnd;
    BOOL fWindowEnabled = TRUE;
	HWND hwndDesktop = GetDesktopWindow();
	while ( hwndParent != hwndDesktop )
	{
        fWindowEnabled = IsWindowEnabled( hwndParent );
        if ( !fWindowEnabled ) 
            break;
        hwndParent = MyGetAncestor(hwndParent, GA_PARENT );
    }

	if ( fWindowEnabled )
	{
        // This is freaky, but seems to work.

        // There are some cases where it doesn't quite work, though:
        // * Won't focus the Address: combo in an IE/Explorer window
        // * Needs to check that the window is enabled first! Possible
        //   to set focus to a hwnd that is disabled because it has a
        //   modal dialog showing.

        // First, use SetForegroundWindow on the target window...
        // This can do weird things if its a child window - it looks
        // like the top-level window doesn't get activated properly...
        g_GetFocus.SetForegroundWindow( hwnd );

        // Now call SetForegroundWindow on the top-level window. This fixes the
        // activation, but actually leaves the focus on the child window.
        HWND hTopLevel = MyGetAncestor( hwnd, GA_ROOT );
        if( hTopLevel )
        {
            SetForegroundWindow( hTopLevel );
        }
    }
    
}




// --------------------------------------------------------------------------
//
//  MyGetRect
//
//  This initializes the rectangle to empty, then makes a GetClientRect()
//  or GetWindowRect() call.  These APIs will leave the rect alone if they
//  fail, hence the zero'ing out ahead of time.  They don't return a useful
//  value in Win '95.
//
// --------------------------------------------------------------------------
void MyGetRect(HWND hwnd, LPRECT lprc, BOOL fWindowRect)
{
    SetRectEmpty(lprc);

    if (fWindowRect)
        GetWindowRect(hwnd, lprc);
    else
        GetClientRect(hwnd, lprc);
}



// --------------------------------------------------------------------------
//
//  TCharSysAllocString
//
//  Pillaged from SHELL source, does ANSI BSTR stuff.
//
// --------------------------------------------------------------------------
BSTR TCharSysAllocString(LPTSTR pszString)
{
#ifdef UNICODE
    return SysAllocString(pszString);
#else
    LPOLESTR    pwszOleString;
    BSTR        bstrReturn;
    int         cChars;

    // do the call first with 0 to get the size needed
    cChars = MultiByteToWideChar(CP_ACP, 0, pszString, -1, NULL, 0);
    pwszOleString = (LPOLESTR)LocalAlloc(LPTR,sizeof(OLECHAR)*cChars);
    if (pwszOleString == NULL)
    {
        return NULL;
    }

	cChars = MultiByteToWideChar(CP_ACP, 0, pszString, -1, pwszOleString, cChars);
    bstrReturn = SysAllocString(pwszOleString);
	LocalFree (pwszOleString);
    return bstrReturn;
#endif
}




// --------------------------------------------------------------------------
//
//  HrCreateString
//
//  Loads a string from the resource file and makes a BSTR from it.
//
// --------------------------------------------------------------------------

#define CCH_STRING_MAX  256

HRESULT HrCreateString(int istr, BSTR* pszResult)
{
    TCHAR   szString[CCH_STRING_MAX];

    Assert(pszResult);
    *pszResult = NULL;

    if (!LoadString(hinstResDll, istr, szString, CCH_STRING_MAX))
        return(E_OUTOFMEMORY);

    *pszResult = TCharSysAllocString(szString);
    if (!*pszResult)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  GetLocationRect
//
//  Get a RECT location from an IAccessible. Converts accLocation's width and
//  height to right and bottom coords.
//
// --------------------------------------------------------------------------


HRESULT GetLocationRect( IAccessible * pAcc, VARIANT & varChild, RECT * prc )
{
    HRESULT hr = pAcc->accLocation( & prc->left, & prc->top, & prc->right, & prc->bottom, varChild );
    if( hr == S_OK )
    {
        // convert width/height to right/bottom...
        prc->right += prc->left;
        prc->bottom += prc->top;
    }
    return hr;
}



// --------------------------------------------------------------------------
//
//  IsClippedByWindow
//
//  Returns TRUE if a given IAccesible/varChild is completely outside the
//  rectangle of a given HWND.
//
//  (When varChildID is not CHILDID_SELF, and when the HWND is the HWND of
//  the IAccessible, then it means that the item is clipped by its parent.)
//
// --------------------------------------------------------------------------

BOOL IsClippedByWindow( IAccessible * pAcc, VARIANT & varChild, HWND hwnd )
{
    RECT rcItem;
    if( GetLocationRect( pAcc, varChild, & rcItem ) != S_OK )
        return FALSE;

    RECT rcWindow;
    GetClientRect( hwnd, & rcWindow );

    MapWindowPoints( hwnd, NULL, (POINT *) & rcWindow, 2 );

    return Rect1IsOutsideRect2( rcItem, rcWindow );
}




//
// Why not use the stdlib? Well, we want to do this all in Unicode, and
// work on 9x... (even when built as ANSI)
//
static
void ParseInt( LPCWSTR pStart, LPCWSTR * ppEnd, int * pInt )
{
    // Allow single leading + or -...
    BOOL fIsNeg = FALSE;
    if( *pStart == '-' )
    {
        fIsNeg = TRUE;
        pStart++;
    }
    else if( *pStart == '+' )
    {
        pStart++;
    }

    // Skip possible leading 0...
    if( *pStart == '0' )
    {
        pStart++;
    }

    // Possible 'x' indicating hex number...
    int base = 10;
    if( *pStart == 'x' || *pStart == 'X' )
    {
        base = 16;
        pStart++;
    }


    // Numbers all the way from here...

    // Note - this doesn't handle overflow/wraparound, nor the
    // extremities of the range (eg. max and min possible #'s...)
    int x = 0;
    for( ; ; )
    {
        int digit;

        if( *pStart >= '0' && *pStart <= '9' )
        {
            digit =  *pStart - '0';
        }
        else if( *pStart >= 'a' && *pStart <= 'f' )
        {
            digit =  *pStart - 'a' + 10;
        }
        else if( *pStart >= 'A' && *pStart <= 'F' )
        {
            digit =  *pStart - 'A' + 10;
        }
        else
        {
            // invalid digit
            break;
        }

        if( digit >= base )
        {
            // digit not appropriate for this base
            break;
        }

        pStart++;

        x = ( x * base ) + digit;
    }

    if( fIsNeg )
    {
        x = -x;
    }

    *pInt = x;
    *ppEnd = pStart;
}

static
void ParseString( LPCWSTR pStart, LPCWSTR * ppEnd, WCHAR wcSep )
{
    while( *pStart != '\0' && *pStart != wcSep )
    {
        pStart++;
    }
    *ppEnd = pStart;
}


static
BOOL StrEquW( LPCWSTR pStrA, LPCWSTR pStrB )
{
    while( *pStrA && *pStrA == *pStrB )
    {
        pStrA++;
        pStrB++;
    }
    return *pStrA == *pStrB;
}


// Format of map:
//
// Type A - currently only supported string.
// Separator can be any character (except NUL - must be a legal
// string character. Doesn't make sense to use space... also can't 
// be a numeric digit...)
//
// "A:0:String0:1:String1:2:String2:3:String3:"
//
// or...
//
// "TypeA 0='String0' 1='String1' 2='String2' 3='String3'"
//
// How to deal with quotes?



// FALSE -> Value not found in map.
// TRUE -> Value found, ppStart, ppEnd point to end points of corresponding entry

static
BOOL ParseValueMap( LPCWSTR pWMapStr,
                    int * aKeys,
                    int cKeys,
                    LPCWSTR * ppStrStart,
                    LPCWSTR * ppStrEnd )
{
    // Check header for Type-A signature

    // Note - I've used plain ANSI literals below - eg. 'A' instead of
    // L'A' - this is ok, since the compiler will promote these to Unicode
    // before doing the comparison.

    
    // Check for leading 'A'...
    if( *pWMapStr != 'A' )
    {
        return FALSE;
    }
    pWMapStr++;


    // Check for separator.
    WCHAR wcSeparator = *pWMapStr;
    if( wcSeparator == '\0' )
    {
        return FALSE;
    }
    pWMapStr++;


    // The first item indicates which source key we are using...
    int iKey;
    LPCWSTR pWStartOfInt = pWMapStr;
    ParseInt( pWMapStr, & pWMapStr, & iKey );
    
    if( pWMapStr == pWStartOfInt )
    {
        // missing number
        return FALSE;
    }

    // Check for separator...
    if( *pWMapStr != wcSeparator )
    {
        return FALSE;
    }
    pWMapStr++;

    // Is index within range?
    if( iKey >= cKeys )
    {
        return FALSE;
    }

    // Now we know what the key is in the key-value map...
    int TargetValue = aKeys[ iKey ];
                                        
    // We don't explicitly check for the terminating NUL in the map string here -
    // however, both ParseInt and ParseString will stop at it, and we'll then
    // check that it's the separator - which will fail, so we'll exit with FALSE.
    for( ; ; )
    {
        int x;
        LPCWSTR pWStartOfInt = pWMapStr;
        ParseInt( pWMapStr, & pWMapStr, & x );
        
        if( pWMapStr == pWStartOfInt )
        {
            // missing number
            return FALSE;
        }

        // Check for separator...
        if( *pWMapStr != wcSeparator )
        {
            return FALSE;
        }
        pWMapStr++;

        LPCWSTR pStrStart = pWMapStr;
        ParseString( pWMapStr, & pWMapStr, wcSeparator );
        LPCWSTR pStrEnd = pWMapStr;

        // Check for separator...
        if( *pWMapStr != wcSeparator )
        {
            return FALSE;
        }
        pWMapStr++;

        // Found it...
        if( TargetValue == x )
        {
            *ppStrStart = pStrStart;
            *ppStrEnd = pStrEnd;
            return TRUE;
        }
    }
}





BOOL CheckStringMap( HWND hwnd,
                     DWORD idObject,
                     DWORD idChild,
                     PROPINDEX idxProp,
                     int * pKeys,
                     int cKeys,
                     BSTR * pbstr,
                     BOOL fAllowUseRaw,
                     BOOL * pfGotUseRaw )
{
    VARIANT varMap;

    BYTE HwndKey[ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    if( ! PropMgrClient_LookupProp( HwndKey, HWNDKEYSIZE, idxProp, & varMap ) )
    {
        return FALSE;
    }

    if( varMap.vt != VT_BSTR )
    {
        VariantClear( & varMap );
        return FALSE;
    }

    if( fAllowUseRaw )
    {
        *pfGotUseRaw = StrEquW( varMap.bstrVal, L"use_raw" );
        if( *pfGotUseRaw )
            return TRUE;
    }

    LPCWSTR pStrStart;
    LPCWSTR pStrEnd;

    BOOL fGot = ParseValueMap( varMap.bstrVal, pKeys, cKeys, & pStrStart, & pStrEnd );
    SysFreeString( varMap.bstrVal );
    if( ! fGot )
    {
        return FALSE;
    }

    // Cast for Win64 compile. Subtracting ptrs give 64-bit value; we only
    // want the 32-bit part...
    *pbstr = SysAllocStringLen( pStrStart, (UINT)( pStrEnd - pStrStart ) );
    if( ! *pbstr )
    {
        return FALSE;
    }

    return TRUE;
}




BOOL CheckDWORDMap( HWND hwnd,
                    DWORD idObject,
                    DWORD idChild,
                    PROPINDEX idxProp,
                    int * pKeys,
                    int cKeys,
                    DWORD * pdw )
{
    VARIANT varMap;

    BYTE HwndKey[ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );
    
    if( ! PropMgrClient_LookupProp( HwndKey, HWNDKEYSIZE, idxProp, & varMap ) )
    {
        return FALSE;
    }

    if( varMap.vt != VT_BSTR )
    {
        VariantClear( & varMap );
        return FALSE;
    }

    LPCWSTR pStrStart;
    LPCWSTR pStrEnd;

    BOOL fGot = ParseValueMap( varMap.bstrVal, pKeys, cKeys, & pStrStart, & pStrEnd );
    SysFreeString( varMap.bstrVal );
    if( ! fGot )
    {
        return FALSE;
    }

    int i;
    LPCWSTR pIntEnd;
    ParseInt( pStrStart, & pIntEnd, & i );
    if( pIntEnd == pStrStart || pIntEnd != pStrEnd )
    {
        // invalid number...
        return FALSE;
    }

    *pdw = (DWORD) i;

    return TRUE;
}














#define MAX_NAME_SIZE   128 



struct EnumThreadWindowInfo
{
    HWND    hwndCtl;
    DWORD   dwIDCtl;

    TCHAR * pszName;
};


static
HRESULT TryTooltip( HWND hwndToolTip, LPTSTR pszName, HWND hwndCtl, DWORD dwIDCtl )
{
    TOOLINFO ti;
    ti.cbSize = SIZEOF_TOOLINFO;
    ti.lpszText = pszName;
    ti.hwnd = hwndCtl;
    ti.uId = dwIDCtl;

    *pszName = '\0';
    HRESULT hr = XSend_ToolTip_GetItem( hwndToolTip, TTM_GETTEXT, 0, & ti, MAX_NAME_SIZE );

    if( hr != S_OK )
        return hr;

    return S_OK;
}


static
BOOL CALLBACK EnumThreadWindowsProc( HWND hWnd, LPARAM lParam )
{
    EnumThreadWindowInfo * pInfo = (EnumThreadWindowInfo *) lParam;

    // Is this a tooltip window?
    TCHAR szClass[ 64 ];
    if( ! GetClassName( hWnd, szClass, ARRAYSIZE( szClass ) ) )
        return TRUE;

    if( lstrcmpi( szClass, TEXT("tooltips_class32") ) != 0 )
        return TRUE;

    if( TryTooltip( hWnd, pInfo->pszName, pInfo->hwndCtl, pInfo->dwIDCtl ) != S_OK )
        return TRUE;

    // Didn't get anything - continue looking...
    if( pInfo->pszName[ 0 ] == '\0' )
        return TRUE;

    // Got it - can stop iterating now.
    return FALSE;
}




BOOL GetTooltipStringForControl( HWND hwndCtl, UINT uGetTooltipMsg, DWORD dwIDCtl, LPTSTR * ppszName )
{
    TCHAR szName[ MAX_NAME_SIZE ];

    BOOL fTryScanningForTooltip = TRUE;

    if( uGetTooltipMsg )
    {
        HWND hwndToolTip = (HWND) SendMessage( hwndCtl, uGetTooltipMsg, 0, 0 );
        if( hwndToolTip )
        {
            // We've found the tooltip window, so we won't need to scan for it.
            // Instead, when we exit this if, we'll fall through to the code that
            // post-processed the name we've got...
            fTryScanningForTooltip = FALSE;

            // Got a tooltip window - use it.
            // (Otherwise we fall through to scanning for a corresponding tooltip
            // window...)
            TOOLINFO ti;
            szName[ 0 ] = '\0';
            ti.cbSize = SIZEOF_TOOLINFO;
            ti.lpszText = szName;
            ti.hwnd = hwndCtl;
            ti.uId = dwIDCtl;

            HRESULT hr = XSend_ToolTip_GetItem( hwndToolTip, TTM_GETTEXT, 0, & ti, MAX_NAME_SIZE );

            if( hr != S_OK )
                return FALSE;

            // Fall through and post-process the string...
        }
    }


    if( fTryScanningForTooltip )
    {
        // Control doesn't know its tooltip window - instead scan for one...

        // Enum the top-level windows owned by this thread...
        DWORD pid;
        DWORD tid = GetWindowThreadProcessId( hwndCtl, & pid );

        EnumThreadWindowInfo info;
        info.hwndCtl = hwndCtl;
        info.dwIDCtl = dwIDCtl;
        info.pszName = szName;
        info.pszName[ 0 ] = '\0';

        EnumThreadWindows( tid, EnumThreadWindowsProc, (LPARAM) & info );
    }

    // At this stage we might have gotten a name from some tooltip window -
    // check if there's anything there...

    if( szName[ 0 ] == '\0' )
        return FALSE;

    int len = lstrlen( szName ) + 1; // +1 for terminating NUL
    *ppszName = (LPTSTR)LocalAlloc( LPTR, len * sizeof(TCHAR) );
    if( ! * ppszName )
        return FALSE;

    memcpy( *ppszName, szName, len * sizeof(TCHAR) );

    return TRUE;
}







// This function also resets the stream pointer to the beginning
static
HRESULT RewindStreamAndGetSize( LPSTREAM pstm, PDWORD pcbSize ) 
{
    *pcbSize = 0;  // If anything fails, 0 is returned

    LARGE_INTEGER li = { 0, 0 };
    HRESULT hr = pstm->Seek( li, STREAM_SEEK_SET, NULL );

    if( FAILED(hr) ) 
    {
        TraceErrorHR( hr, TEXT("RewindStreamAndGetSize: pstm->Seek() failed") );
        return hr;
    }

    // Get the number of bytes in the stream
    STATSTG statstg;
    hr = pstm->Stat( & statstg, STATFLAG_NONAME );

    if( FAILED(hr) ) 
    {
        TraceErrorHR( hr, TEXT("RewindStreamAndGetSize: pstm->Stat() failed") );
        return hr;
    }

    *pcbSize = statstg.cbSize.LowPart;

    return S_OK;
}


// Marshals an interface, returning pointer to marshalled buffer.
// When done, caller must call MarshalInterfaceDone().
HRESULT MarshalInterface( REFIID riid,
                          IUnknown * punk,
                          DWORD dwDestContext,
                          DWORD mshlflags,
                          
                          const BYTE ** ppData,
                          DWORD * pDataLen,

                          MarshalState * pMarshalState )
{
    IStream * pStm = NULL;
    HRESULT hr = CreateStreamOnHGlobal( NULL, TRUE, & pStm );
    if( FAILED( hr ) || ! pStm )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: CreateStreamOnHGlobal failed") );
        return FAILED( hr ) ? hr : E_FAIL;
    }

    // We use strong table marshalling to keep the object alive until we release it.
    hr = CoMarshalInterface( pStm, riid, punk,
                             dwDestContext, NULL, mshlflags );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: CoMarshalInterface failed") );
        pStm->Release();
        return hr;
    }

    HGLOBAL hGlobal = NULL;
    hr = GetHGlobalFromStream( pStm, & hGlobal );
    if( FAILED( hr ) || ! hGlobal )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: GetHGlobalFromStream failed") );
        LARGE_INTEGER li = { 0, 0 };
        pStm->Seek(li, STREAM_SEEK_SET, NULL);
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return FAILED( hr ) ? hr : E_FAIL;
    }

    DWORD dwDataLen = 0;
    hr = RewindStreamAndGetSize( pStm, & dwDataLen );
    if( FAILED( hr ) || dwDataLen == 0 )
    {
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return FAILED( hr ) ? hr : E_FAIL;
    }

    BYTE * pData = (BYTE *) GlobalLock( hGlobal );
    if( ! pData )
    {
        TraceErrorW32( TEXT("MarshalInterface: GlobalLock failed") );
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return E_FAIL;
    }

    *ppData = pData;
    *pDataLen = dwDataLen;

    pMarshalState->pstm = pStm;
    pMarshalState->hGlobal = hGlobal;

    return S_OK;
}



void MarshalInterfaceDone( MarshalState * pMarshalState )
{
    // Unlock the HGLOBAL *before* we release the stream...
    GlobalUnlock( pMarshalState->hGlobal );

    pMarshalState->pstm->Release();
}




HRESULT ReleaseMarshallData( const BYTE * pMarshalData, DWORD dwMarshalDataLen )
{
    IStream * pStm = NULL;
    HRESULT hr = CreateStreamOnHGlobal( NULL, TRUE, & pStm );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CreateStreamOnHGlobal failed") );
        return hr;
    }
    
    if( pStm == NULL )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CreateStreamOnHGlobal returned NULL") );
        return E_FAIL;
    }

    hr = pStm->Write( pMarshalData, dwMarshalDataLen, NULL );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: pStm->Write() failed") );
        pStm->Release();
        return hr;
    }

    LARGE_INTEGER li = { 0, 0 };
    hr = pStm->Seek( li, STREAM_SEEK_SET, NULL );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: pStm->Seek() failed") );
        pStm->Release();
        return hr;
    }

    hr = CoReleaseMarshalData( pStm );
    pStm->Release();

    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CoReleaseMarshalData failed") );
        // Nothing we can do about this, so return S_OK anyway...
    }

    return S_OK;
}



HRESULT UnmarshalInterface( const BYTE * pData, DWORD cbData,
                            REFIID riid, LPVOID * ppv )
{
    // Allocate memory for data
    HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, cbData );
    if( hGlobal == NULL ) 
    {
        TraceErrorW32( TEXT("UnmarshalInterface: GlobalAlloc failed") );
        return E_OUTOFMEMORY;
    }

    VOID * pv = GlobalLock( hGlobal );
    if( ! pv )
    {
        TraceErrorW32( TEXT("UnmarshalInterface: GlobalLock failed") );
        GlobalFree( hGlobal );
        return E_FAIL;
    }

    memcpy( pv, pData, cbData );

    GlobalUnlock( hGlobal );

    // Create a stream out of the data buffer
    IStream * pstm;
    // TRUE => Delete HGLOBAL on release
    HRESULT hr = CreateStreamOnHGlobal( hGlobal, TRUE, & pstm );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("UnmarshalInterface: CreateStreamOnHGlobal failed") );
        GlobalFree( hGlobal );
        return hr;
    }

    hr = CoUnmarshalInterface( pstm, riid, ppv );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("UnmarshalInterface: CoUnmarshalInterface failed") );
    }

    pstm->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\util.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  util
//
//  Miscellaneous helper routines
//
// --------------------------------------------------------------------------


BOOL ClickOnTheRect( LPRECT lprcLoc, HWND hwndToCheck, BOOL fDblClick );



// defines used for SendKey function
#define KEYPRESS    0
#define KEYRELEASE  KEYEVENTF_KEYUP
#define VK_VIRTUAL  0
#define VK_CHAR     1


BOOL SendKey( int nEvent, int nKeyType, WORD wKeyCode, TCHAR cChar );

HWND MyGetFocus();

void MySetFocus( HWND hwnd );

void MyGetRect(HWND, LPRECT, BOOL);

BSTR TCharSysAllocString( LPTSTR lpszString );

HRESULT HrCreateString(int istr, BSTR* pszResult);

inline
BOOL Rect1IsOutsideRect2( RECT const & rc1, RECT const & rc2 )
{
    return ( rc1.right  <= rc2.left ) ||
           ( rc1.bottom <= rc2.top )  ||
           ( rc1.left  >= rc2.right ) ||
           ( rc1.top >= rc2.bottom );
}

HRESULT GetLocationRect( IAccessible * pAcc, VARIANT & varChild, RECT * prc );

BOOL IsClippedByWindow( IAccessible * pAcc, VARIANT & varChild, HWND hwnd );


// This avoids requiring that files that #include this file
// also #include the propmgr files...
typedef enum PROPINDEX;

BOOL CheckStringMap( HWND hwnd,
                     DWORD idObject,
                     DWORD idChild,
                     PROPINDEX idxProp,
                     int * paKeys,
                     int cKeys,
                     BSTR * pbstr,
                     BOOL fAllowUseRaw = FALSE,
                     BOOL * pfGotUseRaw = NULL );

BOOL CheckDWORDMap( HWND hwnd,
                    DWORD idObject,
                    DWORD idChild,
                    PROPINDEX idxProp,
                    int * paKeys,
                    int cKeys,
                    DWORD * pdw );



BOOL GetTooltipStringForControl( HWND hwndCtl, UINT uGetTooltipMsg, DWORD dwIDCtl, LPTSTR * ppszName );






//
// Marshals an interface pointer, returning pointer to marshalled buffer.
//
// Also returns a MarshalState struct, which caller must pass to MarshalInterfaceDone
// when done using buffer.
//

class  MarshalState
{
    IStream * pstm;
    HGLOBAL   hGlobal;

    friend 
    HRESULT MarshalInterface( REFIID riid,
                              IUnknown * punk,
                              DWORD dwDestContext,
                              DWORD mshlflags,
                              const BYTE ** ppData,
                              DWORD * pDataLen,
                              MarshalState * pMarshalState );

    friend 
    void MarshalInterfaceDone( MarshalState * pMarshalState );

};

HRESULT MarshalInterface( REFIID riid,
                          IUnknown * punk,
                          DWORD dwDestContext,
                          DWORD mshlflags,
                          
                          const BYTE ** ppData,
                          DWORD * pDataLen,

                          MarshalState * pMarshalState );

void MarshalInterfaceDone( MarshalState * pMarshalState );


// Releases references associated with marshalled buffer.
// (wrapper for CoReleaseMarshalData)
// (Does not free/delete the actual buffer.)
HRESULT ReleaseMarshallData( const BYTE * pMarshalData, DWORD dwMarshalDataLen );

HRESULT UnmarshalInterface( const BYTE * pData, DWORD cbData,
                            REFIID riid, LPVOID * ppv );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\verdefs.h ===
//
//
//  Version information
//
//  In VSS, this lives in the top-level inc32 directory, and is
//  updated automatically by the build process. This controls
//  the version number of oleacc and the applets.
//
//  On the NT Build (Source Depot), this file lives in the same
//  directory as oleacc.dll, is updated by hand during checkin,
//  and controls the FileVersion of oleacc.dll. (ProductVersion
//  is determined by the NT build).
//
//  The four-digit version 4.2.yydd.0 is calculated by:
//    yy  Number of months since January 1997.
//    dd  Day of month
//
//  For example, a checkin on March 17th 2000 would have a
//  version of 3917.
//  
//  #include'd by:
//     oleacc\api.cpp       - used by GetOleaccVersionInfo
//     oleacc\version.h     - used in VERSIONINFO resource
//
//  additionally, for VSS builds:
//     oleaccrc\rc_ver.h    - used in VERSIONINFO resource
//     inc32\common.rc      - used in VERSIONINFO resource
//

#define BUILD_VERSION_INT   4,2,5406,0
#define BUILD_VERSION_STR   "4.2.5406.0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95




// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );



#else
  #define DBPRINTF        1 ? (void)0 : (void)
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\w95trace.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"


#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return;
    CloseHandle( hTestMutex );


    HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
    HANDLE heventData;   /* data passing synch object */
    HANDLE hSharedFile;  /* memory mapped file shared data */
    LPTSTR lpszSharedMem;
    TCHAR achBuffer[500];

    /* create the output buffer */
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);

    /* 
        Do a regular OutputDebugString so that the output is 
        still seen in the debugger window if it exists.

        This ifdef is necessary to avoid infinite recursion 
        from the inclusion of W95TRACE.H
    */
#ifdef UNICODE
    ::OutputDebugStringW(achBuffer);
#else
    ::OutputDebugStringA(achBuffer);
#endif

    /* bail if it's not Win95 */
    {
        OSVERSIONINFO VerInfo;
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&VerInfo);
        if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
            return;
    }

    /* make sure DBWIN is open and waiting */
    heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if ( !heventDBWIN )
    {
        //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
        return;            
    }

    /* get a handle to the data synch object */
    heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
        CloseHandle(heventDBWIN);
        return;            
    }
    
    hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    /* wait for buffer event */
    WaitForSingleObject(heventDBWIN, INFINITE);

    /* write it to the shared memory */
    *((LPDWORD)lpszSharedMem) = _getpid();
    wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

    /* signal data ready event */
    SetEvent(heventData);

    /* clean up handles */
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\version.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// OLEACC.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#include "verdefs.h"

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Active Accessibility Core Component"
#define VER_INTERNALNAME_STR        "OLEACC"
#define VER_ORIGINALFILENAME_STR    "OLEACC.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEVERSION             BUILD_VERSION_INT
#define VER_FILEVERSION_STR         BUILD_VERSION_STR

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\win64helper.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation
// ----------------------------------------------------------------------------
// Win64Helper.cpp
//
// Helper functions used by all the control wrappers
//
// ----------------------------------------------------------------------------
#include "Win64Helper.h"
#include "w95trace.h"

#include "RemoteProxy6432.h"
#include <atlbase.h> // CComPtr


// Used for Tab control code
// cbExtra for the tray is 8, so pick something even bigger, 16
#define CBEXTRA_TRAYTAB     16



// Stuff in this file:
//
// * Bitness utility functions
//   - determine whether we are on a 32- or 64- bit system, determine
//     what bitness a process is.
//
// * Cross-proc SendMessage utility class
//   - manages allocting a struct in the remote process, copying to that
//     struct, sending a message, and copying back out the result.
//
// * Remote type template class
//   - template class used in the explicit 64/32 structure definitions
//
// * Explicit 64/32 structure definitions
//   - Definitions of comctl and related structs (eg. LVITEM) in separate
//     64- and 32-bit versions (eg. LVITEM_64, LVITEM_32) that have the
//     correct item sizes, layout and alignment for that bitness.
//
// * Cross-proc message handlers
//   - one for each supported message/datatype. (eg. ListView_Get_Handler
//     handles LVM_GETITEM which uses LVITEM.) These copy the 'in' fields
//     from a local struct (eg. LVITEM) to a local copy of the appropriate
//     'remote' struct (eg. LVITEM_32 or LVITEM_64, depending on the bitness
//     of the target proxy), use the cross-proc sendmessage helper to
//     copy that to the remote proc, send the message, and copy back; and
//     then copy the appropriate 'out' fields back to the original local
//     struct.
//
// * Stub macro
//   - this macro declares a function that does a plain sendmessage if we're
//     in the same process as the target HWND - otherwise it uses a cross-proc
//     handler (see above) to send the message cross-proc.
//
//
// * GetRemoteProxyFactory
//   - Lives here because there's no other suitable place for it.
//
//





// ----------------------------------------------------------------------------
//
//  Bitness utility functions
//
//  Class CProcessorType is used to determine whether we are running on a
//  64- or 32-bit system (regardless of whether this is a 32- or 64-bit
//  process - eg. we could be a 32-bit process on a 64-bit machine).
//
//  Function SameBitness determines if a window belongs to a process with the
//  same bitness as the current process.
//
// ----------------------------------------------------------------------------


// Taken from enum _PROCESSINFOCLASS in NT\PUBLIC\sdk\inc\ntpsapi.h ...

#define ProcessWow64Information 26

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

typedef enum ProcessorTypes {
    ProcessorUndef,
    ProcessorX86,
    ProcessorIA64
} ProcessorTypes;

class CProcessorType {
private:
    static ProcessorTypes m_ProcessorType;
    static void Init()
    {
        if (m_ProcessorType != ProcessorUndef)
            return;
#ifndef _WIN64
        ULONG_PTR Wow64Info = NULL;
        HANDLE hProcess;

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
        long lStatus = MyNtQueryInformationProcess(hProcess, ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL);
        CloseHandle(hProcess);
        if (NT_ERROR(lStatus))
        {
            // Query failed.  Must be on an NT4 or earlier NT machine.  Definitely a 32-bit machine.
            m_ProcessorType = ProcessorX86;
        } else if (Wow64Info) 
        {
            // We are running inside WOW64 on a 64-bit machine
            m_ProcessorType = ProcessorIA64;
        } else 
        {
            // We are running on x86 Win2000 or later OS
            m_ProcessorType = ProcessorX86;
        }
        DBPRINTF(TEXT("CProcessorType:  !_WIN64 defined m_ProcessorType=%d\r\n"), m_ProcessorType);
#else
        // _WIN64 is defined, so definitely running on a 64-bit processor
        m_ProcessorType = ProcessorIA64;
        DBPRINTF(TEXT("CProcessorType:  _WIN64 defined m_ProcessorType=%d\r\n"), m_ProcessorType);
#endif
    };
public:
    CProcessorType() {};
    ~CProcessorType() {};
    static BOOL ProcessorIsIA64() {
        Init();
        return m_ProcessorType == ProcessorIA64;
    }
    static BOOL ProcessorIsX86() {
        Init();
        return m_ProcessorType == ProcessorX86;
    }
};
ProcessorTypes CProcessorType::m_ProcessorType = ProcessorUndef;




HRESULT SameBitness(HWND hwnd, BOOL *pfIsSameBitness)
{
    *pfIsSameBitness = TRUE;

#ifndef ENABLE6432_INTEROP
    return S_OK;
#endif

    // If running on an X86 then we must be same bitness
    if (CProcessorType::ProcessorIsX86())
        return S_OK;

    DWORD dwProcessId;
    if ( !GetWindowThreadProcessId(hwnd, &dwProcessId) )
        return E_FAIL;
    
    BOOL fIs32Bit;
    
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
    if ( NULL == hProcess )
    {
        // The desktop window is in a process that OpenProcess fails on
        // with an ERROR_ACCESS_DENIED (5) so special case it an assume 
        // its the same as the platform
        // TODO figure out what other thisngs could fall in this catagory 
        // and deal with them as exceptions
        const HWND hwndDesktop = GetDesktopWindow();
        if ( hwnd == hwndDesktop )
        {
            // at this point we are on a 64 bit platfrom and therefore
            // can assume that the desktop is 64 bit as well
            fIs32Bit = FALSE;   
        }
        else
        {
            DWORD dwErr = GetLastError();
            DBPRINTF( TEXT("OpenProcess returned null GetLastError()=%d\r\n"), dwErr );
            return E_FAIL;
        }
    }
    else
    {
        ULONG_PTR Wow64Info = NULL;
        long rv = MyNtQueryInformationProcess(
                      hProcess
                    , ProcessWow64Information
                    , &Wow64Info
                    , sizeof(Wow64Info)
                    , NULL);
        CloseHandle(hProcess);

        if (NT_ERROR(rv))
        {
            Wow64Info = NULL;    // fake that process is 64bit (OK because this code only executed for _WIN64)
        }

        fIs32Bit = (NULL != Wow64Info);
    }
    
#ifdef _WIN64
    *pfIsSameBitness = !fIs32Bit;
#else
    *pfIsSameBitness = fIs32Bit;
#endif
    return S_OK;
}




// ----------------------------------------------------------------------------
//
//  Cross-proc SendMessage utility class
//
//  The cross-proc message handlers all follow a similar pattern.
//
//  First, the handler works out how much extra storage it will need - eg.
//  for returning a text string. It then calls Alloc() with the size of the
//  base struct (eg. LVITEM), and the size of the extra data - if any (may be
//  0).
//
//  Alloc() then allocaes space for both the base struct and the extra
//  data, and returns TRUE if the allocation succeeded.
//
//  GetExtraPtr() returns a pointer, relative to the remote process, to the
//  extra space. If no extra space was requested, it returns NULL.
//
//  ReadExtra() is used to read data in that extra space from the remote
//  process to the local process. If no extra space was requested, it
//  does nothing.
//  
//  WriteSendMsgRead() copies the struct to the remote process, sends the
//  message using SendMessage, and then copies the struct back to the local
//  process.
//
//  WriteSendMsg() is the same as WriteSendMsgRead(), except it does not
//  copy the result back. (This is used for 'put' messages that do not
//  return information.)
//
// ----------------------------------------------------------------------------

class CXSendHelper
{
private:
    void *  m_pvAddress;    // Ptr to remote shared mem
    HANDLE  m_hProcess;     // Handle of remote process
    UINT    m_cbSize;       // Size of base struct
    UINT    m_cbExtra;      // Size of extra stuff - usually text - stored after the struct

public:

    CXSendHelper() : m_pvAddress(0) {};

    virtual ~CXSendHelper() 
    {
        if (m_pvAddress)
        {
            ::SharedFree(m_pvAddress, m_hProcess);
            m_pvAddress = 0;
        }
    }

    BOOL Alloc( HWND hwnd, UINT cbSize, UINT cbExtra )
    {
        m_cbSize = cbSize;
        m_cbExtra = cbExtra;
        m_pvAddress = ::SharedAlloc( cbSize + cbExtra, hwnd, &m_hProcess );
        return m_pvAddress != NULL;
    }

    void * GetExtraPtr()
    {
        // If no extra space was requested, then return NULL...
        if( ! m_cbExtra )
        {
            return NULL;
        }

        // Return pointer to the 'extra' data that follows the struct
        return (BYTE *)m_pvAddress + m_cbSize;
    }

    BOOL ReadExtra( LPVOID lpvDest, LPVOID lpvRemoteSrc, BOOL fIsString )
    {
        // Does nothing if no extra space was requested.
        if( ! m_cbExtra )
            return TRUE;
        
        if( lpvRemoteSrc )
        {
            // This may point to the extra space we allocated, or the control may
            // have changed the pointer to point to its own data instead of copying
            // into the space we allocated.
            if( ! SharedRead( lpvRemoteSrc, lpvDest, m_cbExtra, m_hProcess ) )
                return FALSE;

            if( fIsString )
            {
                // Paranoia - forcibly NUL-terminate, in case we get garbage...
                LPTSTR pEnd = (LPTSTR)((BYTE *)lpvDest + m_cbExtra) - 1;
                *pEnd = '\0';
            }

            return TRUE;
        }
        else
        {
            // The control changed the pointer to NULL - assume that this means there's
            // nothing there.
            if( fIsString )
            {
                // Use empty string
                *(LPTSTR)lpvDest = '\0';
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    template < class T >
    BOOL WriteSendMsgRead ( T * pStruct, HWND hwnd, UINT uMsg, WPARAM wParam, BOOL fCheckSend )
    {
        // Copy the struct to the remote process...
        if( ! SharedWrite( pStruct, m_pvAddress, sizeof( T ), m_hProcess ) )
        {
            return FALSE;
        }

        // Send the message...
        // If SendMessage fails, we fail only if the fCheckSend flag is specified.
        if( ( ! SendMessage( hwnd, uMsg, wParam, (LPARAM) m_pvAddress) ) && fCheckSend )
        {
            return FALSE;
        }

        // Copy returned struct back to local process...
        if( ! SharedRead( m_pvAddress, pStruct, sizeof( T ), m_hProcess ) )
        {
            return FALSE;
        }

        return TRUE;
    }

    template < class T >
    BOOL WriteSendMsg ( T * pStruct, HWND hwnd, UINT uMsg, WPARAM wParam, BOOL fCheckSend )
    {
        // Copy the struct remotely...
        if( ! SharedWrite( pStruct, m_pvAddress, sizeof( T ), m_hProcess ) )
            return FALSE;

        // Send the message...
        // If SendMessage fails, we fail only if the fCheckSend flag is specified.
        if( ! SendMessage( hwnd, uMsg, wParam, (LPARAM) m_pvAddress) && fCheckSend )
            return FALSE;

        return TRUE;
    }
};






// ----------------------------------------------------------------------------
//
//  'Remote Type' template class
//
//  This is used to represent a type in a remote address space.
//  While the local type may be a poiter, a handle, or some other 'native'
//  type, when accessed remotely, an integer type is used to ensure correct
//  size.
//
//  Eg. a pointer in a 64-bit process is represented as a ULONG64; a ptr in a
//  32-bit process is represented as a ULONG32.
//
//  Signedness matters for some types - pointers are zero-extended when going
//  from 32-to-64, but handles are sign-extended.
//
//  This class, which has assignment and conversion operators defined, takes
//  care of the necessary casting to ensure correct conversion between the
//  local type and the remote representation
//
//  This is a template class, which takes the following parameters:
//  
//    REMOTE_INT       - remote representation type - eg. ULONG64, LONG32, etc.
//    LOCAL_INT_PTR    - local integer type, eg. ULONG_PTR, LONG_PTR
//    LOCAL_TYPE       - local type - eg handle, void*, LPARAM, etc.
//
//
//  A 64-bit pointer, for example, would have a REMOTE_INT of ULONG64 - 64bit
//  size, unsigned for zero-extension; a LOCAL_INT_PTR of ULONG_PTR - same
//  sign as REMOTE_INT - and a local type of void*.
//
// ----------------------------------------------------------------------------

template < typename REMOTE_INT, typename LOCAL_INT_PTR, typename LOCAL_TYPE >
class RemoteType
{
    REMOTE_INT    m_val;

public:

    void operator = ( LOCAL_TYPE h )
    {
        // Convert from local type to remote integer type, via local integer type
        m_val = (REMOTE_INT) (LOCAL_INT_PTR) h;
    }

    operator LOCAL_TYPE ( )
    {
        // Convert from remote integer to local type, via local integer type
        return (LOCAL_TYPE) (LOCAL_INT_PTR) m_val;
    }
};


typedef RemoteType< ULONG32, ULONG_PTR, void * > Ptr32;
typedef RemoteType< ULONG64, ULONG_PTR, void * > Ptr64;

typedef RemoteType< LONG32, LONG_PTR, LPARAM > LParam32;
typedef RemoteType< LONG64, LONG_PTR, LPARAM > LParam64;

typedef RemoteType< LONG32, LONG_PTR, HWND > HWnd32;
typedef RemoteType< LONG64, LONG_PTR, HWND > HWnd64;

typedef RemoteType< LONG32, LONG_PTR, HBITMAP > HBitmap32;
typedef RemoteType< LONG64, LONG_PTR, HBITMAP > HBitmap64;

typedef RemoteType< LONG32, LONG_PTR, HINSTANCE > HInstance32;
typedef RemoteType< LONG64, LONG_PTR, HINSTANCE > HInstance64;






// ----------------------------------------------------------------------------
//
// Explicit 32-bit and 64-bit versions of the control structs
//
// These use explicit 'remote type' fields instead of handler or pointer,
// to ensure the correct size and sign extension when compiled as either
// 32-bit or 64-code. "for_alignment" fields are also added to the 64-bit
// versions where necessary to obtain correct alignment.
//
// These structs do not contain recently added fields (those that are ifdef'd
// out with #if (_WIN32_IE >= 0x0300) or later) - we go for a 'least common
// denominator' approach. The earlier, smalleer structs are accepted by both
// old and new comctl versions; but only the recent comctl versions accept
// the larger structs.
//
// (This only really matters where the struct has a cbSize field - otherwise
// a field isn't used unless it is referenced by a bit in the mask.)
//
// ----------------------------------------------------------------------------

struct LVITEM_32 {
    UINT        mask; 
    int         iItem; 
    int         iSubItem; 
    UINT        state; 
    UINT        stateMask; 
    Ptr32       pszText; 
    int         cchTextMax; 
    int         iImage; 
    LParam32    lParam;
    int         iIndent;
};

struct LVITEM_64 {
    UINT        mask; 
    int         iItem; 
    int         iSubItem; 
    UINT        state; 
    UINT        stateMask; 
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax; 
    int         iImage; 
    LParam64    lParam;
    int         iIndent;
};


// LVITEM_V6 structs are extensions of the old ones...
struct LVITEM_V6_32: public LVITEM_32
{
    int         iGroupId;
    UINT        cColumns;
    Ptr32       puColumns;
};

struct LVITEM_V6_64: public LVITEM_64
{
    int         iGroupId;
    UINT        cColumns;
    Ptr64       puColumns;
};

struct LVGROUP_V6_32
{
    UINT    cbSize;
    UINT    mask;
    Ptr32  pszHeader;
    int     cchHeader;

    Ptr32  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};

struct LVGROUP_V6_64
{
    UINT    cbSize;
    UINT    mask;
    Ptr64  pszHeader;
    int     cchHeader;

    Ptr64  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};



struct LVCOLUMN_32 {
    UINT        mask;
    int         fmt;
    int         cx;
    Ptr32       pszText;
    int         cchTextMax;
    int         iSubItem;
};

struct LVCOLUMN_64 {
    UINT        mask;
    int         fmt;
    int         cx;
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax;
    int         iSubItem;
};



struct HDITEM_32 {
    UINT        mask; 
    int         cxy; 
    Ptr32       pszText; 
    HBitmap32   hbm; 
    int         cchTextMax; 
    int         fmt; 
    LParam32    lParam; 
    int         iImage;
    int         iOrder;
};

struct HDITEM_64 {
    UINT        mask; 
    int         cxy; 
    Ptr64       pszText;
    HBitmap64   hbm; 
    int         cchTextMax; 
    int         fmt; 
    LParam64    lParam; 
    int         iImage;
    int         iOrder;
};

struct TCITEM_32 {
    UINT        mask;
    DWORD       dwState;
    DWORD       dwStateMask;
    Ptr32       pszText;
    int         cchTextMax;
    int         iImage;
    LParam32    lParam;
}; 

struct TCITEM_64 {
    UINT        mask;
    DWORD       dwState;
    DWORD       dwStateMask;
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax;
    int         iImage;
    LParam64    lParam;
}; 

struct TOOLINFO_32 {
    UINT        cbSize; 
    UINT        uFlags; 
    HWnd32      hwnd; 
    WPARAM      uId; 
    RECT        rect; 
    HInstance32 hinst; 
    Ptr32       lpszText; 
};

struct TOOLINFO_64 {
    UINT        cbSize; 
    UINT        uFlags; 
    HWnd64      hwnd; 
    WPARAM      uId; 
    RECT        rect; 
    HInstance64 hinst; 
    Ptr64       lpszText; 
};


struct TTGETTITLE_32
{
    DWORD       dwSize;
    UINT        uTitleBitmap;
    UINT        cch;
    Ptr32       pszTitle;
};

struct TTGETTITLE_64
{
    DWORD       dwSize;
    UINT        uTitleBitmap;
    UINT        cch;
    UINT        for_alignment;
    Ptr64       pszTitle;
};



// ----------------------------------------------------------------------------
//
//  Handlers for the common controls message handlers
//
//  The basic structure of these is:
//
//  1. Determine if extra storage is needed for text.
//  2. Allocate storage
//  3. Fill a local struct that has the same bitness as the target
//  4. Copy that struct to the remote process, do the SendMessage, and copy
//     the struct back
//  5. Copy fields from that struct back to the local one
//  6. Copy any extra data back (usually text) if necessary
//
// ----------------------------------------------------------------------------


template <class T>
HRESULT ListView_Get_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM * pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iItem        = pItemSrc->iItem;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;


    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->state     = lvDest.state;
    pItemSrc->stateMask = lvDest.stateMask;
    pItemSrc->iImage    = lvDest.iImage;
    pItemSrc->lParam    = lvDest.lParam;
    pItemSrc->iIndent   = lvDest.iIndent;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, lvDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>            // T is one of the LVITEM types
HRESULT ListView_Set_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iItem        = pItemSrc->iItem;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;
    lvDest.state        = pItemSrc->state;
    lvDest.stateMask    = pItemSrc->stateMask;
    lvDest.iImage       = pItemSrc->iImage;
    lvDest.lParam       = pItemSrc->lParam;
    lvDest.iIndent      = pItemSrc->iIndent;

    xsh.WriteSendMsg( & lvDest, hwnd, uiMsg, wParam, fCheckSend );

    return S_OK;
}


template <class T>
HRESULT ListView_GetCol_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVCOLUMN * pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVCF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;

    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, lvDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ListView_V6_Get_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM_V6 * pItemSrc, BOOL fCheckSend, UINT )
{
    // This version only gets column information, not text...

    DWORD dwExtraSize = 0;
    if(pItemSrc->mask & LVIF_COLUMNS)
        dwExtraSize = sizeof(UINT) * (pItemSrc->cColumns);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwExtraSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask      = pItemSrc->mask;
    lvDest.iItem     = pItemSrc->iItem;
    lvDest.iSubItem  = pItemSrc->iSubItem;
    lvDest.cColumns  = pItemSrc->cColumns;
    lvDest.puColumns = xsh.GetExtraPtr();

    // LVM_GETITEM/LVIF_COLUMNS returns FALSE when puColumns is NULL, even though it
    // does set cColumns to the size required. So we should only check that SendMessage
    // returns TRUE when puColumns is non-NULL.
    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->cColumns = lvDest.cColumns;
    pItemSrc->iGroupId = lvDest.iGroupId;

    // Copy columns back out separately...
    // UINTs are the same on 64 vs 32, so don't need extra processing here.
    if( ! xsh.ReadExtra( pItemSrc->puColumns, lvDest.puColumns, FALSE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ListView_V6_GetGroup_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVGROUP_V6 * pItemSrc, BOOL fCheckSend, UINT )
{
    DWORD dwTextSize = 0;
    if( pItemSrc->mask & LVGF_HEADER )
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchHeader + 1);
    
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    lvDest.cbSize       = pItemSrc->cbSize;
    lvDest.mask       = pItemSrc->mask;
    lvDest.pszHeader   = xsh.GetExtraPtr();
    lvDest.cchHeader   = pItemSrc->cchHeader;
    lvDest.iGroupId    = pItemSrc->iGroupId;
    
    if( ! xsh.WriteSendMsgRead( &lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
    
    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszHeader, lvDest.pszHeader, TRUE ) )
        return E_FAIL;
    
    return S_OK;
}



template <class T>
HRESULT HeaderCtrl_Get_Handler( T & hdDest, HWND hwnd, UINT uiMsg, WPARAM wParam, HDITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & HDI_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    hdDest.mask         = pItemSrc->mask;
    hdDest.pszText      = xsh.GetExtraPtr();
    hdDest.cchTextMax   = pItemSrc->cchTextMax;

    if( ! xsh.WriteSendMsgRead( & hdDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->cxy       = hdDest.cxy;
    pItemSrc->hbm       = hdDest.hbm;
    pItemSrc->fmt       = hdDest.fmt;
    pItemSrc->lParam    = hdDest.lParam;
    pItemSrc->iImage    = hdDest.iImage;
    pItemSrc->iOrder    = hdDest.iOrder;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, hdDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>
HRESULT TabCtrl_Get_Handler( T & tcDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TCITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & TCIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T) + CBEXTRA_TRAYTAB, dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tcDest.mask           = pItemSrc->mask;
    tcDest.dwState        = pItemSrc->dwState;
    tcDest.dwStateMask    = pItemSrc->dwStateMask;
    tcDest.pszText        = xsh.GetExtraPtr();
    tcDest.cchTextMax     = pItemSrc->cchTextMax;
    tcDest.iImage         = pItemSrc->iImage;
    tcDest.lParam         = pItemSrc->lParam;

    if( ! xsh.WriteSendMsgRead( & tcDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->dwState     = tcDest.dwState;
    pItemSrc->dwStateMask = tcDest.dwStateMask;
    pItemSrc->iImage      = tcDest.iImage;
    pItemSrc->lParam      = tcDest.lParam;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, tcDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>
HRESULT ToolInfo_Get_Handler( T & tiDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TOOLINFO *pItemSrc, BOOL fCheckSend, UINT cchTextMax )
{
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), sizeof(TCHAR) * cchTextMax ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tiDest.cbSize   = sizeof( tiDest );
    tiDest.uFlags   = pItemSrc->uFlags;
    tiDest.uId      = pItemSrc->uId;
    tiDest.hwnd     = pItemSrc->hwnd;
    tiDest.lpszText = xsh.GetExtraPtr();

    // Don't fail if the message is TTM_GETTEXT and 0 is returned - that's OK for that message.
    // (TTM_GETTEXT has no documented return value!)
    if( ! xsh.WriteSendMsgRead( & tiDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->uFlags = tiDest.uFlags;
    pItemSrc->uId    = tiDest.uId;
    pItemSrc->rect   = tiDest.rect;

    // Copy text back out...
    if( ! xsh.ReadExtra( pItemSrc->lpszText, tiDest.lpszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ToolInfo_GetTitle_Handler( T & tiDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TTGETTITLE *pItemSrc, BOOL fCheckSend, UINT )
{
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), sizeof(TCHAR) * pItemSrc->cch ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tiDest.dwSize   = sizeof( tiDest );
    tiDest.cch      = pItemSrc->cch;
    tiDest.pszTitle = xsh.GetExtraPtr();

    if( ! xsh.WriteSendMsgRead( & tiDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->uTitleBitmap = tiDest.uTitleBitmap;

    // Copy text back out...
    if( ! xsh.ReadExtra( pItemSrc->pszTitle, tiDest.pszTitle, TRUE ) )
        return E_FAIL;

    return S_OK;
}






// ----------------------------------------------------------------------------
//
//  Cross-proc sendmessage stub macro
//
//  All cross-proc SendMessage code has the same basic structure - some tests
//  to determine if a cross proc send message is needed in the first place - 
//  if not, we can do a regular local SendMessage instead.
//  If we do need to do a remote SendMessage, we call either a 32-bit or 64-bit
//  "handler" routine based on the bitness of the target proxy.
//
//  Since this code is the same for all cases, a #define is used to avoid
//  duplication of code.
//
//
//  DEFINE_XSEND_STUB takes the following parameters:
//
//  Name            - the name of the function being defined
//  Handler         - the name of the cross-proc handler (see above)
//  Type            - base type used.
//  CheckSendExpr   - expression that indicates if the result of SendMessage
//                    should be checked. Most - but not all - messages return
//                    TRUE to indicate success. 
// 
//
// ----------------------------------------------------------------------------


// For a given type - eg. LVITEM - this macro sets LVITEM_THIS and
// LVITEM_REMOTE to be typedef'd to LVITEM_32 and LVITEM_64 as appropriate,
// depending on whether this is 32- or 64- bit code.
//
// This relies on the base struct (eg. LVITEM) having the same base name as the
// explicit 32- and 64- bit structs which are defined above.

#ifdef _WIN64
#define DEFINE_TYPE_6432( Type ) typedef Type ## _64 Type ## _THIS; typedef Type ## _32 Type ## _REMOTE;
#else
#define DEFINE_TYPE_6432( Type ) typedef Type ## _32 Type ## _THIS; typedef Type ## _64 Type ## _REMOTE;
#endif


#define DEFINE_XSEND_STUB( Name, Handler, Type, CheckSendExpr ) /**/ \
    HRESULT Name ( HWND hwnd, UINT uiMsg, WPARAM wParam, Type * pItem, UINT uiParam )\
    {\
        /* Optimize if in same process...*/\
        DWORD dwProcessId;\
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )\
            return E_FAIL;\
    \
        BOOL fCheckSend = CheckSendExpr;\
    \
        if( dwProcessId == GetCurrentProcessId() )\
        {\
            DBPRINTF( TEXT("Inprocess") );\
            if( ! SendMessage( hwnd, uiMsg, wParam, (LPARAM) pItem ) && fCheckSend )\
            {\
                DBPRINTF( TEXT("SendMessag failed") );\
                return E_FAIL;\
            }\
    \
            return S_OK;\
        }\
    \
        /* Otherwise pass the correct type off to the template function...*/\
        BOOL fIsSameBitness;\
        if( FAILED( SameBitness( hwnd, & fIsSameBitness ) ) )\
            return E_FAIL;\
    \
        if( fIsSameBitness )\
        {\
            Type ## _THIS t;\
            memset( & t, 0, sizeof( t ) );\
            return Handler( t, hwnd, uiMsg, wParam, pItem, fCheckSend, uiParam );\
        }\
        else\
        {\
            Type ## _REMOTE t;\
            memset( & t, 0, sizeof( t ) );\
            return Handler( t, hwnd, uiMsg, wParam, pItem, fCheckSend, uiParam );\
        }\
    }


DEFINE_TYPE_6432( LVITEM    )
DEFINE_TYPE_6432( LVITEM_V6 )
DEFINE_TYPE_6432( LVGROUP_V6 )
DEFINE_TYPE_6432( LVCOLUMN  )
DEFINE_TYPE_6432( TCITEM    )
DEFINE_TYPE_6432( HDITEM    )
DEFINE_TYPE_6432( TOOLINFO  )
DEFINE_TYPE_6432( TTGETTITLE )

DEFINE_XSEND_STUB( XSend_ListView_GetItem,      ListView_Get_Handler,       LVITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_ListView_SetItem,      ListView_Set_Handler,       LVITEM,     FALSE   )
DEFINE_XSEND_STUB( XSend_ListView_GetColumn,    ListView_GetCol_Handler,    LVCOLUMN,   TRUE    )
DEFINE_XSEND_STUB( XSend_ListView_V6_GetItem,   ListView_V6_Get_Handler,    LVITEM_V6,  pItem->puColumns != NULL )
DEFINE_XSEND_STUB( XSend_ListView_V6_GetGroupInfo, ListView_V6_GetGroup_Handler,    LVGROUP_V6,  TRUE )
DEFINE_XSEND_STUB( XSend_TabCtrl_GetItem,       TabCtrl_Get_Handler,        TCITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_HeaderCtrl_GetItem,    HeaderCtrl_Get_Handler,     HDITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_ToolTip_GetItem,       ToolInfo_Get_Handler,       TOOLINFO,   uiMsg != TTM_GETTEXT     )
DEFINE_XSEND_STUB( XSend_ToolTip_GetTitle,      ToolInfo_GetTitle_Handler,  TTGETTITLE, TRUE    )


// ----------------------------------------------------------------------------
//
// GetRemoteProxyFactory()
//
// Returns an AddRef'd proxy factory for the other bitness
//

CComPtr<IRemoteProxyFactory> g_pRemoteProxyFactory;    // Only a single instance. CComPtr
                                                    // will release on dll unload.

HRESULT GetRemoteProxyFactory(IRemoteProxyFactory **pRPF)
{
    if (IsBadWritePtr(pRPF, sizeof(IRemoteProxyFactory *)))
        return E_POINTER;

    *pRPF = NULL;

    if (!g_pRemoteProxyFactory)
    {
        HRESULT hr = CoCreateInstance(
#ifdef _WIN64
                  CLSID_RemoteProxyFactory32
#else
                  CLSID_RemoteProxyFactory64
#endif
                , NULL
                , CLSCTX_LOCAL_SERVER
                , IID_IRemoteProxyFactory
                , reinterpret_cast<void **>(&g_pRemoteProxyFactory));

        if (FAILED(hr))
        {
            DBPRINTF(TEXT("GetRemoteProxyFactory: CoCreateInstance FAILED "));
#ifdef _WIN64
                DBPRINTF(TEXT("for clsid 0x%x\r\n"), CLSID_RemoteProxyFactory32.Data1);
#else
                DBPRINTF(TEXT("for clsid 0x%x\r\n"), CLSID_RemoteProxyFactory64.Data1);
#endif
            return hr;
        }

        if (!g_pRemoteProxyFactory)
            return E_OUTOFMEMORY;
    }

    DBPRINTF(TEXT("GetRemoteProxyFactory: CoCreateInstance SUCCEEDED\r\n"));
    *pRPF = g_pRemoteProxyFactory;
    (*pRPF)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\win64helper.h ===
// Copyright (c) 1996-2000 Microsoft Corporation
// ----------------------------------------------------------------------------
// Win64Helper.h
//
// Helper function prototypes used by the comctl32 wrappers
//
// ----------------------------------------------------------------------------
#ifndef INC_OLE2
#include "oleacc_p.h"
#include "default.h"
#endif
#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>

// if this W2K and not ALPHA enable 64b/32b interoperability
#if defined(UNICODE) && !defined(_M_AXP64)
#define ENABLE6432_INTEROP
#endif


// ComCtl V6 Listview structure - this has extra fields since the previous
// version. We define this structure explicitly here, so that we can compile
// in either NT build or in VS6 - we're not reliant on the lastest commctrl.h
// file.

#ifndef LVIF_COLUMNS
#define LVIF_COLUMNS            0x0200
#endif

struct LVITEM_V6
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPTSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
    int iIndent;
    // The following fields are new in V6.
    int iGroupId;
    UINT cColumns; // tile view columns
    PUINT puColumns;
};


#ifndef LVGF_HEADER
#define LVGF_HEADER         0x00000001
#endif

#ifndef LVIF_GROUPID
#define LVIF_GROUPID            0x0100
#endif

#ifndef LVM_GETGROUPINFO
#define LVM_GETGROUPINFO         (LVM_FIRST + 149)
#endif


struct LVGROUP_V6
{
    UINT    cbSize;
    UINT    mask;
    LPTSTR  pszHeader;
    int     cchHeader;

    LPTSTR  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};



#ifndef TTM_GETTITLE
#define TTM_GETTITLE            (WM_USER + 35)

struct TTGETTITLE
{
    DWORD dwSize;
    UINT uTitleBitmap;
    UINT cch;
    WCHAR* pszTitle;
};
#endif

HRESULT SameBitness(HWND hwnd, BOOL *pfIsSameBitness);

// Why the unused 'dummy' variable? Only XSend_ToolTip_GetItem actually uses that param,
// but adding it to all these functions gives them the same number of params, and, with
// the exception of the struct field (LVITEM/HDITEM/etc), gives them the same signature.
// This allows for somewhat cleaner code in the implemetation (Win64Helper.cpp)
// Using a default value for that param means that calling code doesn't have to specify
// it, so the callers can ignore the fact that it is there.

HRESULT XSend_ListView_GetItem    ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ListView_SetItem    ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ListView_GetColumn  ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVCOLUMN *  pItem, UINT dummy = 0 );
HRESULT XSend_ListView_V6_GetItem ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM_V6 * pItem, UINT dummy = 0 );
HRESULT XSend_ListView_V6_GetGroupInfo ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVGROUP_V6 * pItem, UINT dummy = 0 );
HRESULT XSend_HeaderCtrl_GetItem  ( HWND hwnd, UINT uiMsg, WPARAM wParam, HDITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_TabCtrl_GetItem     ( HWND hwnd, UINT uiMsg, WPARAM wParam, TCITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ToolTip_GetItem     ( HWND hwnd, UINT uiMsg, WPARAM wParam, TOOLINFO *  pItem, UINT cchTextMax );
HRESULT XSend_ToolTip_GetTitle    ( HWND hwnd, UINT uiMsg, WPARAM wParam, TTGETTITLE * pItem, UINT dummy = 0 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\window.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  WINDOW.H
//
//  Default window OLE accessible object class
//
// --------------------------------------------------------------------------

class CWindow : public CAccessible
{
        // internal ctor. Private so taht derived classes don't inadvertantly use this -
        // they should use the one below (*where they specify a CLASS_ENUM) instead.
        // CreateWindowThing is a friend so it can create us (using new).

        CWindow()
            : CAccessible( CLASS_WindowObject )
        {
            // Done.
        }

        friend HRESULT CreateWindowThing(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject);

    public:

        // Used by derived classes
        CWindow( CLASS_ENUM eclass )
            : CAccessible( eclass )
        {
            // Done.
        }

        // IAccessible
        virtual STDMETHODIMP    get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP    get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);

        virtual STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP    get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT * pvarRole);
        virtual STDMETHODIMP    get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP    get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP    get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
        virtual STDMETHODIMP    get_accFocus(VARIANT * pvarFocusChild);

        virtual STDMETHODIMP    accSelect(long flags, VARIANT varChild);
        virtual STDMETHODIMP    accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP    accNavigate(long navDir, VARIANT varStart, VARIANT* pvarEndUpAt);
        virtual STDMETHODIMP    accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

        // IEnumVARIANT
        virtual STDMETHODIMP    Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP    Clone(IEnumVARIANT * *);

        void    Initialize(HWND, long);

        //
        // NOTE:  We override the default implementation of ValidateChild()!
        //
        virtual BOOL ValidateChild(VARIANT*);
};


//
// Version defines
//
#define VER30   0x0300
#define VER31   0x030A
#define VER40   0x0400
#define VER41   0x040A

#define ObjidFromIndex(index)       (DWORD)(0 - (LONG)(index))
#define IndexFromObjid(objid)       (-(long)(objid))

extern HRESULT  CreateWindowThing(HWND hwnd, long iChild, REFIID riid, void** ppvObjct);
extern HRESULT  FrameNavigate(HWND, long, long, VARIANT *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\window.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  WINDOW.CPP
//
//  Window class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "client.h"
#include "window.h"

#pragma warning( disable : 4005 ) // macro redefinition
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
#pragma warning( default : 4005 ) 


#define MaskBit(n)                  (1 << (n))

#define IndexFromNavDir(navdir)     (navdir - NAVDIR_UP)

// Remember, these are negative!
#define OBJID_WINDOW_FIRST      OBJID_SIZEGRIP
#define OBJID_WINDOW_LAST       OBJID_SYSMENU

typedef struct tagNAVIGATE
{
    long    NavPeer[4];
} NAVIGATE;

#ifndef CCHILDREN_FRAME
#define CCHILDREN_FRAME  7
#endif

// Order is Up, Down, Left, Right
NAVIGATE    rgFrameNavigate[CCHILDREN_FRAME] =
{
    // System menu
    {
        0, IndexFromObjid(OBJID_MENU), 0, IndexFromObjid(OBJID_TITLEBAR)
    },

    // Title bar
    {
        0, IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_SYSMENU), 0
    },

    // Menu bar
    {
        IndexFromObjid(OBJID_TITLEBAR), IndexFromObjid(OBJID_CLIENT), 0, 0
    },

    // Client
    {
        IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_HSCROLL), 0, IndexFromObjid(OBJID_VSCROLL)
    },

    // Vertical scrollbar
    {
        IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_SIZEGRIP), IndexFromObjid(OBJID_CLIENT), 0
    },

    // Horizontal scrollbar
    {
        IndexFromObjid(OBJID_CLIENT), 0, 0, IndexFromObjid(OBJID_SIZEGRIP)
    },

    // Size grip
    {
        IndexFromObjid(OBJID_VSCROLL), 0, IndexFromObjid(OBJID_HSCROLL), 0
    }
};



// --------------------------------------------------------------------------
//
//  CreateWindowObject()
//
//  External function for CreateDefault...
//
// --------------------------------------------------------------------------
HRESULT CreateWindowObject(HWND hwnd, long idObject, REFIID riid, void** ppvWindow)
{
    UNUSED(idObject);

    InitPv(ppvWindow);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateWindowThing as default if none found.
    // (TRUE => use window, as opposed to client, classes)
    return FindAndCreateWindowClass( hwnd, TRUE, CLASS_WindowObject,
                                     OBJID_WINDOW, 0, riid, ppvWindow );
}


// --------------------------------------------------------------------------
//
//  CreateWindowThing()
//
//  Private function that uses atom type to decide what class of window
//  this is.  If there is a private create function, uses that one.  Else
//  uses generic window frame handler.
//
// --------------------------------------------------------------------------
HRESULT CreateWindowThing(HWND hwnd, long idChildCur, REFIID riid, void** ppvWindow)
{
    CWindow * pwindow;
    HRESULT     hr;

    InitPv(ppvWindow);

    pwindow = new CWindow();
    if (!pwindow)
        return(E_OUTOFMEMORY);

    // Can't be in the constructor--derived classes can't call the init
    // code if so.
    pwindow->Initialize(hwnd, idChildCur);

    hr = pwindow->QueryInterface(riid, ppvWindow);
    if (!SUCCEEDED(hr))
        delete pwindow;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CWindow::Initialize()
//
// --------------------------------------------------------------------------
void CWindow::Initialize(HWND hwnd, LONG iChild)
{
    m_hwnd = hwnd;
    m_cChildren = CCHILDREN_FRAME;
    m_idChildCur = iChild;
}



// --------------------------------------------------------------------------
//
//  CWindow::ValidateChild()
//
//  The window children are the OBJID_s of the elements that compose the
//  frame.  These are NEGATIVE values.  Hence we override the validation.
//
// --------------------------------------------------------------------------
BOOL CWindow::ValidateChild(VARIANT* pvar)
{
    //
    // This validates a VARIANT parameter and translates missing/empty
    // params.
    //

TryAgain:
    // Missing parameter, a la VBA
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

// remove this! VT_I2 is not valid!!
#ifdef  VT_I2_IS_VALID  // it isn't now...
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if ((pvar->lVal > 0) || (pvar->lVal < (long)OBJID_WINDOW_FIRST))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accParent()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accParent(IDispatch ** ppdispParent)
{
    HWND    hwndParent;

    InitPv(ppdispParent);

    hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    if (! hwndParent)
        return(S_FALSE);

    return(AccessibleObjectFromWindow(hwndParent, OBJID_CLIENT, IID_IDispatch,
        (void **)ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accChild()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    InitPv(ppdispChild);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IDispatch, (void**)ppdispChild));
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accName(VARIANT varChild, BSTR* pszName)
{
    IAccessible * poleacc;
    HRESULT hr;

    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // If the caller want's our name, forward to the client object
    //
    if (varChild.lVal == CHILDID_SELF)
        varChild.lVal = OBJID_CLIENT;


    //
    // Get the name of our child frame object.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IAccessible, (void **)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    varChild.lVal = CHILDID_SELF;
    hr = poleacc->get_accName(varChild, pszName);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        return(S_FALSE);
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the description of our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal, IID_IAccessible,
            (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accDescription(varChild, pszDesc);
        poleacc->Release();

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CWindow::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    InitPv(pszHelp);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the help for our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accHelp(varChild, pszHelp);
        poleacc->Release();

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CWindow::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        //
        // Fill in our role.
        //
        pvarRole->vt = VT_I4;
        pvarRole->lVal = ROLE_SYSTEM_WINDOW;
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the role of our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accRole(varChild, pvarRole);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    HWND    hwndParent;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (varChild.lVal == CHILDID_SELF)
    {
        //
        // Get our state.
        //
        WINDOWINFO  wi;
        RECT        rcParent;

        if (! MyGetWindowInfo(m_hwnd, &wi))
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        if (!(wi.dwStyle & WS_VISIBLE))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (wi.dwStyle & WS_DISABLED)
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (wi.dwStyle & WS_THICKFRAME)
            pvarState->lVal |= STATE_SYSTEM_SIZEABLE;

        if ((wi.dwStyle & WS_CAPTION) == WS_CAPTION)
        {
            pvarState->lVal |= STATE_SYSTEM_MOVEABLE;
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
        }

// Windows are not selectable, so they shouldn't be selected either.
#if 0
        if (wi.dwWindowStatus & WS_ACTIVECAPTION)
            pvarState->lVal |= STATE_SYSTEM_SELECTED;
#endif

        if (MyGetFocus() == m_hwnd)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (GetForegroundWindow() == MyGetAncestor(m_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        // This is the _real_ parent window.
        if (hwndParent = MyGetAncestor(m_hwnd, GA_PARENT))
        {
            MyGetRect(hwndParent, &rcParent, FALSE);
            MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);

			if ( hwndParent == GetDesktopWindow() )
			{
				if ( MonitorFromRect( &wi.rcWindow, MONITOR_DEFAULTTONULL ) == NULL )
					pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
			}
			else
			{
                if ( Rect1IsOutsideRect2( wi.rcWindow, rcParent ) )
                {
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
                }
            }
        }
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Ask the frame element what its state is.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accState(varChild, pvarState);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    IAccessible * poleacc;
    HRESULT hr;

    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // If the caller is asking us for our shortcut, forward to the client.
    //
    if (varChild.lVal == CHILDID_SELF)
        varChild.lVal = OBJID_CLIENT;

    //
    // Ask the child.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IAccessible, (void **)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    varChild.lVal = CHILDID_SELF;
    hr = poleacc->get_accKeyboardShortcut(varChild, pszShortcut);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accFocus(VARIANT* pvarChild)
{
    HWND    hwndFocus;

    InitPvar(pvarChild);

    //
    // BOGUS!  If we are in menu mode, then menu object has focus.  If
    // we are in scrolling mode, scrollbar has the focus.  etc.
    //
    hwndFocus = MyGetFocus();

    if ((m_hwnd == hwndFocus) || IsChild(m_hwnd, hwndFocus))
        return(GetNoncObject(m_hwnd, OBJID_CLIENT, pvarChild));

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CWindow::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        return(FrameNavigate(m_hwnd, 0, NAVDIR_NEXT, pvarEnd));
    else if (dwNavDir == NAVDIR_LASTCHILD)
        return(FrameNavigate(m_hwnd, OBJID_SIZEGRIP-1, NAVDIR_PREVIOUS, pvarEnd));
    else if (varStart.lVal == CHILDID_SELF)
    {
        HWND    hwndParent;

        hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
        if (!hwndParent)
            return(S_FALSE);

        return (GetParentToNavigate(HWNDIDFromHwnd(hwndParent, m_hwnd), hwndParent,
            OBJID_CLIENT, dwNavDir, pvarEnd));
    }
    else
        return(FrameNavigate(m_hwnd, varStart.lVal, dwNavDir, pvarEnd));

}


// --------------------------------------------------------------------------
//
//  CWindow::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accSelect(long lSelFlags, VARIANT varChild)
{
    if (! ValidateChild(&varChild) ||
        ! ValidateSelFlags(lSelFlags))
        return E_INVALIDARG;

    if (lSelFlags != SELFLAG_TAKEFOCUS)
        return E_NOT_APPLICABLE;

    if (varChild.lVal)
        return S_FALSE ;

    MySetFocus( m_hwnd );

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CWindow::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == 0)
    {
        MyGetRect(m_hwnd, &rc, TRUE);

        *pxLeft = rc.left;
        *pyTop = rc.top;
        *pcxWidth = rc.right - rc.left;
        *pcyHeight = rc.bottom - rc.top;
    }
    else
    {
        //
        // Ask the child.
        //
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the help for our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accHitTest(long xLeft, long yTop, VARIANT* pvarHit)
{
    WINDOWINFO wi;
    long    lEnd;
    long    lHit;
    POINT   pt;

    InitPvar(pvarHit);

    lEnd = 0;

    if (! MyGetWindowInfo(m_hwnd, &wi))
        return(S_FALSE);

    //
    // Find out where point is.  But special case the client area!
    //
    pt.x = xLeft;
    pt.y = yTop;
    if (PtInRect(&wi.rcClient, pt))
        goto ReallyTheClient;

    lHit = SendMessageINT(m_hwnd, WM_NCHITTEST, 0, MAKELONG(xLeft, yTop));

    switch (lHit)
    {
        case HTERROR:
        case HTNOWHERE:
            return(S_FALSE);

        case HTCAPTION:
        case HTMINBUTTON:
        case HTMAXBUTTON:
        case HTHELP:
        case HTCLOSE:
        // case HTIME!
            lEnd = OBJID_TITLEBAR;
            break;

        case HTMENU:
            lEnd = OBJID_MENU;
            break;

        case HTSYSMENU:
            lEnd = OBJID_SYSMENU;
            break;

        case HTHSCROLL:
            lEnd = OBJID_HSCROLL;
            break;

        case HTVSCROLL:
            lEnd = OBJID_VSCROLL;
            break;

        case HTCLIENT:
        case HTTRANSPARENT:
ReallyTheClient:
            lEnd = OBJID_CLIENT;
            break;

        case HTGROWBOX:
            lEnd = OBJID_SIZEGRIP;
            break;

        case HTBOTTOMRIGHT:
            // Note that for sizeable windows, being over the size grip may
            // return in fact HTBOTTOMRIGHT for sizing purposes.  If this
            // point is inside the window borders, that is the case.
            if ((xLeft < wi.rcWindow.right - (int)wi.cxWindowBorders) &&
                (yTop < wi.rcWindow.bottom - (int)wi.cyWindowBorders))
            {
                lEnd = OBJID_SIZEGRIP;
            }
            break;

        // Includes borders!
        default:
            break;
    }

    if (lEnd)
        return(GetNoncObject(m_hwnd, lEnd, pvarHit));
    else
    {
        pvarHit->vt = VT_I4;
        pvarHit->lVal = lEnd;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CWindow::Next()
//
//  We do loop from 0 to cChildren, it's just that the IDs are NEGATIVE,
//  not positive.  We accept child ids that are OBJIDs.
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cChildren))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us -((index)+1), which means we start at -1 and
        // decrement.  Conveniently, this corresponds to OBJID values!
        //
        pvar->vt = VT_I4;
        pvar->lVal = 0 - iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CWindow::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::Clone(IEnumVARIANT ** ppenum)
{
    InitPv(ppenum);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateWindowThing as default if none found.
    // (TRUE => use window, as opposed to client, classes)
    return FindAndCreateWindowClass( m_hwnd, TRUE, CLASS_WindowObject,
                           OBJID_WINDOW, m_idChildCur, IID_IEnumVARIANT, (void**)ppenum );
}




// --------------------------------------------------------------------------
//
//  FrameNavigate()
//
//  Default handling of navigation among frame children.  The standard
//  frame widget handlers (titlebar, menubar, scrollbar, etc.) hand off
//  peer navigation to us, their parent.  There are two big reasons for this:
//
//  (1) It saves on code and ease of implementation, since the knowledge of
//      what is to the left of what, what is below what, etc. only has to
//      be coded in one place.
//
//  (2) It allows apps that want to manage their own frame and e.g. add a
//      new element that acts like a frame piece yet still have navigation
//      work properly.  Their frame handler can hand off to the default
//      implementation but trap navigation.
//
// --------------------------------------------------------------------------
HRESULT FrameNavigate(HWND hwndFrame, long lStart, long dwNavDir,
    VARIANT * pvarEnd)
{
    long        lEnd;
    long        lMask;
    WINDOWINFO  wi;
    TCHAR       szClassName[128];
    BOOL        bFound = FALSE;
    IAccessible *   poleacc;
    IDispatch * pdispEl;
    HRESULT     hr;

    //
    // Currently, we get an index (fix validation layer so IDs are OBJIDs)
    //
    lEnd = 0;

    lStart = IndexFromObjid(lStart);

    //
    // Figure out what is present, what isn't.
    //
    if (!MyGetWindowInfo(hwndFrame, &wi))
        return(E_FAIL);

    lMask = 0;
    lMask |= MaskBit(IndexFromObjid(OBJID_CLIENT));

    if ((wi.dwStyle & WS_CAPTION)== WS_CAPTION)
        lMask |= MaskBit(IndexFromObjid(OBJID_TITLEBAR));

    if (wi.dwStyle & WS_SYSMENU)
        lMask |= MaskBit(IndexFromObjid(OBJID_SYSMENU));

    if (wi.dwStyle & WS_VSCROLL)
        lMask |= MaskBit(IndexFromObjid(OBJID_VSCROLL));

    if (wi.dwStyle & WS_HSCROLL)
        lMask |= MaskBit(IndexFromObjid(OBJID_HSCROLL));

    if ((wi.dwStyle & (WS_HSCROLL | WS_VSCROLL)) == (WS_HSCROLL | WS_VSCROLL))
        lMask |= MaskBit(IndexFromObjid(OBJID_SIZEGRIP));

    if (!(wi.dwStyle & WS_CHILD) && GetMenu(hwndFrame))
        lMask |= MaskBit(IndexFromObjid(OBJID_MENU));

    // HACKISH BIT for new IE4/Shell Menubands
    // The menus aren't menus, so we have to see if this thing
    // has menubands.
    // First, check the classname - only the browser and shell
    // windows have these things...
    // The reason we have to do this is because the IE4 guys are
    // slackers and didn't do very much for accessibility.
    GetClassName (hwndFrame, szClassName,ARRAYSIZE(szClassName));
    if ((0 == lstrcmp (szClassName,TEXT("IEFrame"))) ||
        (0 == lstrcmp (szClassName,TEXT("CabinetWClass"))))
    {
        HWND            hwndWorker;
        HWND            hwndRebar;
        HWND            hwndSysPager;
        HWND            hwndToolbar;

        // We can just send a WM_GETOBJECT to the menuband window,
        // we just have to find it. Let's use FindWindowEx to do that.
        // This is not easy: There are 4 children of an IEFrame Window,
        // and I am not sure how many children of a shell window (CabinetWClass).
        // For IEFrame windows, the menuband is the:
        // ToolbarWindow32 child of a SysPager that is the child of a
        // RebarWindow32 that is the child of a Worker.
        // But there are 2 Worker windows at the 1st level down,
        // and 2 SysPagers that are children of the RebarWindow32.

        bFound = FALSE;
        hwndWorker = NULL;
        while (!bFound)
        {
            hwndWorker = FindWindowEx (hwndFrame,hwndWorker,TEXT("Worker"),NULL);
            if (!hwndWorker)
                break;

            hwndRebar = FindWindowEx (hwndWorker,NULL,TEXT("RebarWindow32"),NULL);
            if (!hwndRebar)
                continue;

            hwndSysPager = NULL;
            while (!bFound)
            {
                hwndSysPager = FindWindowEx (hwndRebar,hwndSysPager,TEXT("SysPager"),NULL);
                if (!hwndSysPager)
                    break;
                hwndToolbar = FindWindowEx (hwndSysPager,NULL,TEXT("ToolbarWindow32"),NULL);
                hr = AccessibleObjectFromWindow (hwndToolbar,OBJID_MENU,
                                                 IID_IAccessible, (void **)&poleacc);
                if (SUCCEEDED(hr))
                {
                    bFound = TRUE;
                    lMask |= MaskBit(IndexFromObjid(OBJID_MENU));
                }
            }
        }
    } // end if we are talking to something that might have a menuband

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            lEnd = lStart;
            while (++lEnd <= CCHILDREN_FRAME)
            {
                // Is the next item present?
                if (lMask & MaskBit(lEnd))
                    break;
            }

            if (lEnd > CCHILDREN_FRAME)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = lStart;
            while (--lEnd > 0)
            {
                // Is the previous item present?
                if (lMask & MaskBit(lEnd))
                    break;
            }

            Assert(lEnd >= 0);
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
            lEnd = lStart;
            while (lEnd = rgFrameNavigate[lEnd-1].NavPeer[IndexFromNavDir(dwNavDir)])
            {
                // Is this item around?
                if (lMask & MaskBit(lEnd))
                    break;
            }
            break;
    }

    if (lEnd)
    {
        // now finish up our hackish work. For normal things, we just
        // return GetNoncObject, which is basically just a call to
        // AccessibleObjectFromWindow with the id of the frame element,
        // and then it just stuffs the return value (an IDispatch) into
        // the VARIANT.
        // For IE4 hackish stuff, we have an IAccessible, we'll QI for
        // IDispatch, Release the IAccessible, and stuff the IDispatch
        // into a VARIANT.
        if (bFound && lEnd == IndexFromObjid(OBJID_MENU))
        {
            hr = poleacc->QueryInterface(IID_IDispatch,(void**)&pdispEl);
			poleacc->Release();

            if (!SUCCEEDED(hr))
                return(hr);
            if (!pdispEl)
                return(E_FAIL);

            pvarEnd->vt = VT_DISPATCH;
            pvarEnd->pdispVal = pdispEl;
            return (S_OK);
        }
        else
            return(GetNoncObject(hwndFrame, ObjidFromIndex(lEnd), pvarEnd));
    }
    else
        return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\wrap_annotation.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_annotation
//
//  Wrapper class to implement annotation for IAccessibles
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include "PropMgr_Client.h"
#include "PropMgr_Util.h"

#include "wrap_base.h"



class AccWrap_AddIAccProp: public AccWrap_Base
{
    HWND                m_FakeIAccPropHwnd;
    BOOL                m_fCheckedForFakeIAccProp;


    BOOL CanFakeIAccIdentity( HWND * phwnd )
    {
        // Can we fale IAccIdentity for this object?
        // Yes, if:
        // * It supports IAccessible
        // * It has a parent
        // * The parent supports IAccIdentity
        // * Parent's identity is HWND-base,d and is OBJID_WINDOW.
        // We can 99.9% assume that the child is an OBJID_CLIENT object.
        //
        // (TODO - also check that its HWND matches that of its parent?)
        //
        // This is useful where native IAccessible is implementing IAccessible
        // for a client (ie. where it's not something complicated like Trident
        // with multiple levels). Since the native IAccessible won't implement
        // IAccIdentity (since that was spec'd only recently), annotation
        // won't work for it.
        // However, if we can determine that it is a simple IAccessible - and
        // we do so by checking that it's parent is a OBJID_WINDOW object -
        // we can supply the identity for it.
        // This works because noone has ever wanted to supply an IAccessible
        // for anything other than the OBJID_CLIENT child of an OBJID_WINDOW.


        // Note that we use the AccWrap_Base::get_accParent here instead of
        // using get_accParent - if we used the latter, we'd end up trying
        // to use annotation (to see if the parent was annotated), but we're
        // in the middle ot QI'ing for an annotation interface, so that would
        // be freaky. So we explicitly call the base class to short-circuit-out
        // the annotated version of get_accParent.
        IDispatch * pdispParent = NULL;
        HRESULT hr = AccWrap_Base::get_accParent( & pdispParent );
        if( hr != S_OK || pdispParent == NULL )
        {
            return FALSE;
        }

        // This is very important - we want to talk to the real parent IAccessible -
        // not its wrapper, so that when we QI it for IAccIdentity, we will know
        // for sure if the parent actually supports it or not. (If we didn't do this,
        // the parent's wrapper would try to implement IAccIdentity for it, by
        // calling back into this method on the parent, which would in turn do the same
        // for the parent's parent, and so on up the tree. Eventually, that would all
        // correctly return 'FALSE', but it's a particularly expensive way to calculate
        // FALSE, especially where deep trees are used, eg. in a trident doc.)
        // 
        // We get the real parent by QI'ing for IServiceProvider, and then QS'ing for
        // IIS_AccWrapBase_GetIUnknown. (These are implemented in wrap_base.cpp).

        IServiceProvider * psvc = NULL;
        hr = pdispParent->QueryInterface( IID_IServiceProvider, (void **) & psvc );
        pdispParent->Release();
        if( hr != S_OK || psvc == NULL )
        {
            return FALSE;
        }

        // QS allows us to both get the real parent, and QI it (for IAccIdentity) in one go...
        IAccIdentity * pParentID = NULL;
        hr = psvc->QueryService( IIS_AccWrapBase_GetIUnknown, IID_IAccIdentity, (void **) & pParentID );
        psvc->Release();
        if( hr != S_OK || pParentID == NULL )
        {
            return FALSE;
        }

        // Got the parent's identity interface - now get its identity string...
        BYTE * pIDString = NULL;
        DWORD dwStringLen = 0;
        hr = pParentID->GetIdentityString( CHILDID_SELF, & pIDString, & dwStringLen );
        pParentID->Release();
        if( hr != S_OK || pIDString == NULL )
        {
            return FALSE;
        }

        // Finally check if it is a OBJID_WINDOW thing...
        HWND hwnd;
        DWORD idObject;
        DWORD idChild;
        BOOL fGotIt = DecodeHwndKey( pIDString, dwStringLen, & hwnd, & idObject, & idChild );
        CoTaskMemFree( pIDString );

        if( ! fGotIt || hwnd == NULL || idObject != OBJID_WINDOW || idChild != CHILDID_SELF )
        {
            return FALSE;
        }

        * phwnd = hwnd;

        return TRUE;
    }

public:

    AccWrap_AddIAccProp( IUnknown * punk )
        : AccWrap_Base( punk ),
          m_FakeIAccPropHwnd( NULL ),
          m_fCheckedForFakeIAccProp( FALSE )
    {
    }


    ~AccWrap_AddIAccProp()
    {
    }


    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void ** ppv )
    {
        HRESULT hr = AccWrap_Base::QueryInterface( riid, ppv );

        if( hr == E_NOINTERFACE && riid == IID_IAccIdentity )
        {
            if( ! m_fCheckedForFakeIAccProp )
            {
                // Check if we can fake an IAccIdentity, if we haven't
                // checked already...
                HWND hwnd;
                m_fCheckedForFakeIAccProp = TRUE;
                if( CanFakeIAccIdentity( & hwnd ) )
                {
                    m_FakeIAccPropHwnd = hwnd;
                }
            }

            if( m_FakeIAccPropHwnd )
            {
                // Yes, we can fake it...
                *ppv = (IAccIdentity *) this;
                AddRef();
                hr = S_OK;
            }
        }
        return hr;
    }


    HRESULT STDMETHODCALLTYPE GetIdentityString (
        DWORD	    dwIDChild,
        BYTE **     ppIDString,
        DWORD *     pdwIDStringLen
    )
    {
        *ppIDString = NULL;
        *pdwIDStringLen = 0;

        if( ! m_fCheckedForFakeIAccProp )
        {
            // Object supports this interface natively - call through...
            return AccWrap_Base::GetIdentityString( dwIDChild, ppIDString, pdwIDStringLen );
        }

        if( ! m_FakeIAccPropHwnd )
        {
            // This shouldn't happen - if we've checked for the interface, but didn't
            // get a valid HWND to use, then we'd have returned E_NOINTERFACE in QI, so
            // the caller shouldn't have got an interface to call us on.
            Assert( FALSE );
            return E_NOTIMPL;
        }

        // Ok, we need to fake a key for an object that doesn't itself support IAccIdentity,
        // but which is fakeable (see CanFakeIAccIdentity for more details
        // on what that means.) Basically assume it's OBJID_CLIENT, and construct
        // a win32/hwnd key.
        BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
        if( ! pKeyData )
        {
            return E_OUTOFMEMORY;
        }

        MakeHwndKey( pKeyData, m_FakeIAccPropHwnd, OBJID_CLIENT, dwIDChild );

        *ppIDString = pKeyData;
        *pdwIDStringLen = HWNDKEYSIZE;

        return S_OK;
    }
};





//
//  Note on member m_pAccPropID:
//
//  This is a pointer to an interface on *this* object - so we don't need
//  to AddRef it. It is actually important that we don't AddRef() it,
//  otherwise we'd be keeping a ref to ourself - so we'd never get
//  destroyed (circular ref problem).
//  We get this interface pointer from QI on this object - the base
//  class AccWrap_Base will only return a pointer if the object we're
//  wrapping supports it too.
//  As soon as we get the ptr from QI, we Release() to undo the effect
//  of the AddRef in QI. It is still valid to use this pointer, however,
//  since it is a pointer to ourself.
//  This weirdness applies only because this is a pointer back to
//  ourself. If the pointer pointed to any other object, we'd have to
//  do the usual Release-only-when-done-with-ptr-eg.-in-the-dtor stuff.
//
//  (Why not just cast instead of using QI? Well, the base class only
//  returns a pointer via QI if the object we're wrapping also supports
//  this inteface. If we did a cast, we'd always succeed, even if the
//  object we're wrapping doesn't support this interface.)
//

class AccWrap_Annotate: public AccWrap_AddIAccProp
{
    BOOL                m_fInited;
    IAccIdentity *      m_pAccPropID; // See note above

    // This function calls our ctor...
    friend HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv );


    AccWrap_Annotate( IUnknown * punk )
        : AccWrap_AddIAccProp( punk ),
          m_fInited( FALSE ),
          m_pAccPropID( NULL )
    {
    }


    ~AccWrap_Annotate()
    {
        // We *don't* release m_pAccPropID, since it points to this object.
        // See note at top of class for more details.
    }

    void Init()
    {
        if( ! m_fInited )
        {
            // Get the identity interface for this IAccessible - if it has one...
            IAccIdentity * pAccPropID = NULL;
            HRESULT hr = this->QueryInterface( IID_IAccIdentity, (void **) & pAccPropID );
            if( hr == S_OK && pAccPropID )
            {
                m_pAccPropID = pAccPropID;

                // We *must* release m_pAccPropID now, even though we're going to use it later.
                // This is only because it points to this object.
                // See note at top of class for more details.
                m_pAccPropID->Release();
            }
        }
        m_fInited = TRUE;
    }

public:

    // Factory method - the AccWrap_Base calls this when it needs to wrap outgoing
    // params to the IAccessible methods.
    IUnknown * WrapFactory( IUnknown * punk )
    {
        return static_cast<IAccessible *>( new AccWrap_Annotate( punk ) );
    }





    // Forwarding methods...


    BOOL GetGenericProp( VARIANT varChild, PROPINDEX idxProp, short vt, VARIANT * pvar )
    {
        // We do the 'check if annotation is active' check before calculating the key (in Init()).
        // This saves calc'ing the key - which can be slightly expensive for out-of-proc objects
        // (cross proc calls involved - at least QI.) - if nothing is using annotation anyhow.
        if( varChild.vt != VT_I4 || ! PropMgrClient_CheckAlive() )
        {
            return FALSE;
        }

        Init();

        if( ! m_pAccPropID )
        {
            return FALSE;
        }

        BYTE * pIDString = NULL;
        DWORD dwIDStringLen = 0;
        HRESULT hr = m_pAccPropID->GetIdentityString( varChild.lVal, & pIDString, & dwIDStringLen );
        if( hr != S_OK || pIDString == NULL )
        {
            return FALSE;
        }

        BOOL fLookup = PropMgrClient_LookupProp( pIDString, dwIDStringLen, idxProp, pvar );

        CoTaskMemFree( pIDString );

        if( ! fLookup )
        {
            return FALSE;
        }

        // If vt is not VT_EMPTY, then check the type is what we expect...
        if( vt != VT_EMPTY && pvar->vt != vt )
        {
            VariantClear( pvar );
            return FALSE;
        }

        return TRUE;
    }








#define FORWARD_BSTR( name, idProp ) /**/\
    HRESULT STDMETHODCALLTYPE get_acc ## name ( VARIANT varChild, BSTR * pbstr )\
    {\
        VARIANT var;\
        if( GetGenericProp( varChild, idProp, VT_BSTR, & var ) )\
        {\
            *pbstr = var.bstrVal;\
            return S_OK;\
        }\
        return AccWrap_Base::get_acc ## name( varChild, pbstr );\
    }

#define FORWARD_VTI4( name, idProp ) /**/\
    HRESULT STDMETHODCALLTYPE get_acc ## name ( VARIANT varChild, VARIANT * pvar )\
    {\
        if( GetGenericProp( varChild, idProp, VT_I4, pvar ) )\
        {\
            return S_OK;\
        }\
        return AccWrap_Base::get_acc ## name( varChild, pvar );\
    }


    FORWARD_BSTR( Name,              PROPINDEX_NAME                )
    FORWARD_BSTR( Value,             PROPINDEX_VALUE               )
    FORWARD_BSTR( Description,       PROPINDEX_DESCRIPTION         )
    FORWARD_BSTR( Help,              PROPINDEX_HELP                )
    FORWARD_BSTR( KeyboardShortcut,  PROPINDEX_KEYBOARDSHORTCUT    )
    FORWARD_BSTR( DefaultAction,     PROPINDEX_DEFAULTACTION       )

    FORWARD_VTI4( Role,              PROPINDEX_ROLE                )
    FORWARD_VTI4( State,             PROPINDEX_STATE               )



    HRESULT STDMETHODCALLTYPE get_accParent( IDispatch ** ppdispParent )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        VARIANT var;
        if( GetGenericProp( varChild, PROPINDEX_PARENT, VT_DISPATCH, & var ) )
        {
            *ppdispParent = var.pdispVal;
            return S_OK;
        }

        return AccWrap_Base::get_accParent( ppdispParent );
    }

    HRESULT STDMETHODCALLTYPE get_accFocus( VARIANT * pvar )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        if( GetGenericProp( varChild, PROPINDEX_FOCUS, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }
        return AccWrap_Base::get_accFocus( pvar );
    }

    HRESULT STDMETHODCALLTYPE get_accSelection( VARIANT * pvar )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        if( GetGenericProp( varChild, PROPINDEX_SELECTION, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }
        return AccWrap_Base::get_accSelection( pvar );
    }


    HRESULT STDMETHODCALLTYPE accNavigate( long NavDir, VARIANT varStart, VARIANT * pvar )
    {
        PROPINDEX idxProp;

        switch( NavDir )
        {
            case NAVDIR_UP:         idxProp = PROPINDEX_NAV_UP;         break;
            case NAVDIR_DOWN:       idxProp = PROPINDEX_NAV_DOWN;       break;
            case NAVDIR_LEFT:       idxProp = PROPINDEX_NAV_LEFT;       break;
            case NAVDIR_RIGHT:      idxProp = PROPINDEX_NAV_RIGHT;      break;
            case NAVDIR_NEXT:       idxProp = PROPINDEX_NAV_NEXT;       break;
            case NAVDIR_PREVIOUS:   idxProp = PROPINDEX_NAV_RIGHT;      break;
            case NAVDIR_LASTCHILD:  idxProp = PROPINDEX_NAV_LASTCHILD;  break;
            case NAVDIR_FIRSTCHILD: idxProp = PROPINDEX_NAV_FIRSTCHILD; break;

            default:
                return AccWrap_Base::accNavigate( NavDir, varStart, pvar );
        }

        if( GetGenericProp( varStart, idxProp, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }

        return AccWrap_Base::accNavigate( NavDir, varStart, pvar );
    }


    HRESULT STDMETHODCALLTYPE accDoDefaultAction( VARIANT varChild )
    {
        VARIANT varResult;
        if( GetGenericProp( varChild, PROPINDEX_DODEFAULTACTION, VT_I4, & varResult ) )
        {
            return varResult.lVal;
        }
        return AccWrap_Base::accDoDefaultAction( varChild );
    }

};




//
//  AccessibleObjectFromWindow calls this to wrap outgoing objects...
//


HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv )
{
    if( AccWrap_Base::AlreadyWrapped( punk ) )
    {
        return punk->QueryInterface( riid, ppv );
    }
    else
    {
        IUnknown * punkWrap = (IAccessible *) new AccWrap_Annotate( punk );
        // TODO - error check if NULL...
        if( ! punkWrap )
            return E_OUTOFMEMORY;

        HRESULT hr = punkWrap->QueryInterface( riid, ppv );
        punkWrap->Release();

        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleaccrc\oleaccrc.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

/*
 *
 *  Minimal DllMain - to keep linker happy.
 *  DLL otherwise contains just resources.
 *
 *
 *  Note: set compiler/linker options to ignore
 *  default libraries, and set entry point symbol
 *  to DllMain.
 *
 */
#include <windows.h>

BOOL WINAPI DllMain( HANDLE hInst, 
                     ULONG ul_reason_for_call,
                     LPVOID lpReserved )
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\wrap_base.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_base
//
//  Base class for IAccessible wrapping.
//  Derived classes implement annotation, caching, and other cool features.
//
// --------------------------------------------------------------------------

#include "fwd_macros.h"


// Private QI'ing to return the base IUnknown. Does not work across apartments.
DEFINE_GUID( IIS_AccWrapBase_GetIUnknown, 0x33f139ee, 0xe509, 0x47f7, 0xbf, 0x39, 0x83, 0x76, 0x44, 0xf7, 0x45, 0x76);


class AccWrap_Base: public IAccessible,
                    public IOleWindow,
                    public IEnumVARIANT,
                    public IAccIdentity,
                    public IServiceProvider
{
    // We need to do our own refcounting for this wrapper object
    ULONG               m_ref;

    // Need ptr to the IAccessible - also keep around ptrs to EnumVar and
    // OleWindow as part of this object, so we can filter those interfaces
    // and trap their QI's...
    // ( We leave pEnumVar and OleWin as NULL until we need them )
    IUnknown *          m_pUnknown;

    IAccessible *       m_pAcc;
    IEnumVARIANT *      m_pEnumVar;
    IOleWindow *        m_pOleWin;
    IAccIdentity *      m_pAccID;
    IServiceProvider *  m_pSvcPdr;

    DWORD               m_QIMask; // Remembers what we've QI'd for, so we don't try again


    ITypeInfo *         m_pTypeInfo;


    HRESULT InitTypeInfo();


    // These process [out] params, and wrap them where necessary.

    HRESULT ProcessIUnknown( IUnknown ** ppUnk );
    HRESULT ProcessIDispatch( IDispatch ** ppdisp );
    HRESULT ProcessIEnumVARIANT( IEnumVARIANT ** ppEnum );
    HRESULT ProcessVariant( VARIANT * pvar, BOOL CanBeCollection = FALSE );
    HRESULT ProcessEnum( VARIANT * pvar, ULONG * pceltFetched );

    IUnknown * Wrap( IUnknown * pUnk );

    HRESULT CheckForInterface( IUnknown * punk, REFIID riid, int QIIndex, void ** pDst );

protected:

    // Only derived classes should have access to this - sould call through
    // in their ctors.
            AccWrap_Base( IUnknown * pUnk );

public:


    static  BOOL                        AlreadyWrapped( IUnknown * punk );


    virtual ~AccWrap_Base( );



    // Override in derived classes so that propogated values get wrapped appropriately.
    virtual IUnknown * WrapFactory( IUnknown * pUnk ) = 0;



    // IUnknown
    // ( We do our own ref counting )
    virtual HRESULT STDMETHODCALLTYPE   QueryInterface( REFIID riid, void ** ppv );
    virtual ULONG   STDMETHODCALLTYPE   AddRef( );
    virtual ULONG   STDMETHODCALLTYPE   Release( );

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE   QueryService( REFGUID guidService, REFIID riid, void **ppv );

    // IDispatch
    virtual HRESULT STDMETHODCALLTYPE   GetTypeInfoCount( UINT * pctinfo );
    virtual HRESULT STDMETHODCALLTYPE   GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo ** pptinfo );
    virtual HRESULT STDMETHODCALLTYPE   GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames,
                                                       LCID lcid, DISPID * rgdispid );
    virtual HRESULT STDMETHODCALLTYPE   Invoke( DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                                DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
                                                UINT * puArgErr );


        
//  Forwarding macro:
//
//    ptr           is the member pointer to forward this call though - a different
//                  one is used for each interface we support,
//
//    name          is the name of the method,
//
//    c, params     are the count of parameters, and the parameters; in (type1,var1,
//                  type2,var2...typeN,varN) format.
//
//    expr          is an expression to evaluate after making the forwarded call. It
//                  will typically contain a call to one of the methods to fixup and
//                  wrap any outgoing params. Will be 0 (no-op) if not needed.

#define FORWARD( ptr, name, c, params, expr ) /**/\
HRESULT STDMETHODCALLTYPE AccWrap_Base:: name AS_DECL( c, params )\
{\
    HRESULT hr = ptr -> name AS_CALL( c, params );\
    if( hr != S_OK )\
        return hr;\
    expr;\
    return hr;\
}

        
    // IAccessible

    FORWARD( m_pAcc, get_accParent,             1, ( IDispatch **, ppdispParent ),      ProcessIDispatch( ppdispParent ) )

    FORWARD( m_pAcc, get_accChildCount,         1, ( long *, pChildCount ),             0 )

    FORWARD( m_pAcc, get_accChild,              2, ( VARIANT, varChild,
                                                     IDispatch **, ppdispChild ),       ProcessIDispatch( ppdispChild ) )


    FORWARD( m_pAcc, get_accName,               2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accValue,              2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accDescription,        2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accHelp,               2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accKeyboardShortcut,   2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accDefaultAction,      2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )

    FORWARD( m_pAcc, get_accRole,               2, ( VARIANT, varChild, VARIANT *, pvarRole ),  0 )
    FORWARD( m_pAcc, get_accState,              2, ( VARIANT, varChild, VARIANT *, pvarState ), 0 )

    FORWARD( m_pAcc, get_accHelpTopic,          3, ( BSTR *, pszHelpFile,
                                                     VARIANT, varChild,
                                                     long *, pidTopic ),                0 )


    FORWARD( m_pAcc, get_accFocus,              1, ( VARIANT *, pvarChild ),            ProcessVariant( pvarChild ) )

    FORWARD( m_pAcc, get_accSelection,          1, ( VARIANT *, pvarChildren ),         ProcessVariant( pvarChildren, TRUE ) )

    FORWARD( m_pAcc, accSelect,                 2, ( long, flagsSel,
                                                     VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, accLocation,               5, ( long *, pxLeft,
                                                     long *, pyTop,
                                                     long *, pcxWidth,
                                                     long *, pcyHeight,
                                                     VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, accNavigate,               3, ( long, navDir,
                                                     VARIANT, varStart,
                                                     VARIANT *, pvarEndUpAt ),          ProcessVariant( pvarEndUpAt ) )

    FORWARD( m_pAcc, accHitTest,                3, ( long, xLeft,
                                                     long, yTop,
                                                     VARIANT *, pvarChildAtPoint ),     ProcessVariant( pvarChildAtPoint ) )

    FORWARD( m_pAcc, accDoDefaultAction,        1, ( VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, put_accName,               2, ( VARIANT, varChild,
                                                     BSTR, bstr ),                      0 )

    FORWARD( m_pAcc, put_accValue,              2, ( VARIANT, varChild,
                                                     BSTR, bstr ),                      0 )


    // IEnumVARIANT

    FORWARD( m_pEnumVar, Next,                  3, ( ULONG, celt,
                                                     VARIANT *, rgvar,
                                                     ULONG *, pceltFetched ),           ProcessEnum( rgvar, pceltFetched ) )

    FORWARD( m_pEnumVar, Skip,                  1, ( ULONG, celt ),                     0 )


    FORWARD( m_pEnumVar, Reset,                 0, ( ),                                 0 )


    FORWARD( m_pEnumVar, Clone,                 1, ( IEnumVARIANT **, ppenum ),         ProcessIEnumVARIANT( ppenum ) )


    // IOleWindow

    FORWARD( m_pOleWin, GetWindow,              1, ( HWND *, phwnd ),                   0 )

    FORWARD( m_pOleWin, ContextSensitiveHelp,   1, ( BOOL, fEnterMode ),                0 )


    // IAccIdentity

    FORWARD( m_pAccID, GetIdentityString,       3, ( DWORD, dwIDChild,
                                                     BYTE **, ppIDString,
                                                     DWORD *, pdwIDStringLen ),         0 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleacc\wrap_base.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_base
//
//  Base class for IAccessible wrapping.
//  Derived classes implement annotation, caching, and other cool features.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include <initguid.h> // used for IIS_AccWrapBase_GetIUnknown in wrap_base.h
#include "wrap_base.h"



enum
{
    QIINDEX_IAccessible,
    QIINDEX_IEnumVARIANT,
    QIINDEX_IOleWindow,
    QIINDEX_IAccIdentity,
    QIINDEX_IServiceProvider,
};


AccWrap_Base::AccWrap_Base( IUnknown * pUnknown )
    : m_ref( 1 ),
      m_QIMask( 0 ),
      m_pUnknown( pUnknown ),
      m_pAcc( NULL ),
      m_pEnumVar( NULL ),
      m_pOleWin( NULL ),
      m_pAccID( NULL ),
      m_pSvcPdr( NULL ),
      m_pTypeInfo( NULL )
{
    m_pUnknown->AddRef();
}

AccWrap_Base::~AccWrap_Base()
{
    m_pUnknown->Release();
    if( m_pAcc )
        m_pAcc->Release();
    if( m_pEnumVar )
        m_pEnumVar->Release();
    if( m_pOleWin )
        m_pOleWin->Release();
    if( m_pAccID )
        m_pAccID->Release();
    if( m_pSvcPdr )
        m_pSvcPdr->Release();
    if( m_pTypeInfo )
        m_pTypeInfo->Release();
}



// Helper used by QI...
HRESULT AccWrap_Base::CheckForInterface( IUnknown * punk, REFIID riid, int QIIndex, void ** pDst )
{
    // Do we already have a cached interface ptr? If so, don't need to QI again...
    if( *pDst )
        return S_OK;

    // Did we try QI'ing for this before? If so, don't try again, just return E_NOINTERFACE...
    if( IsBitSet( m_QIMask, QIIndex ) )
        return E_NOINTERFACE;

    SetBit( & m_QIMask, QIIndex );

    HRESULT hr = punk->QueryInterface( riid, pDst );
    if( FAILED( hr ) )
    {
        *pDst = NULL;
        return hr;
    }

    // Paranoia ( in case QI returns S_OK with NULL... )
    if( ! *pDst )
        return E_FAIL;

    return S_OK;
}



BOOL AccWrap_Base::AlreadyWrapped( IUnknown * punk )
{
    // Try QueryService'ing to IIS_AccWrapBase_GetIUnknown - if it succeeds, then
    // we are talking to something that's already wrapped.
    IServiceProvider * psvc = NULL;
    HRESULT hr = punk->QueryInterface( IID_IServiceProvider, (void **) & psvc );
    if( hr != S_OK || psvc == NULL )
    {
        return FALSE;
    }

    IUnknown * pout = NULL;
    hr = psvc->QueryService( IIS_AccWrapBase_GetIUnknown, IID_IUnknown, (void **) & pout );
    psvc->Release();
    if( hr != S_OK || pout == NULL )
    {
        return FALSE;
    }

    pout->Release();
    return TRUE;
}

IUnknown * AccWrap_Base::Wrap( IUnknown * pUnk )
{
    if( AlreadyWrapped( pUnk ) )
    {
        pUnk->AddRef();
        return pUnk;
    }
    else
    {
        return WrapFactory( pUnk );
    }
}



// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
HRESULT STDMETHODCALLTYPE  AccWrap_Base::QueryInterface( REFIID riid, void ** ppv )
{
    HRESULT hr;
    *ppv = NULL;

    if ( riid == IID_IUnknown )
    {
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IAccessible || riid == IID_IDispatch )
    {
        hr = CheckForInterface( m_pUnknown, IID_IAccessible, QIINDEX_IAccessible, (void **) & m_pAcc );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IEnumVARIANT )
    {
        hr = CheckForInterface( m_pUnknown, IID_IEnumVARIANT, QIINDEX_IEnumVARIANT, (void **) & m_pEnumVar );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IEnumVARIANT * >( this );
    }
    else if( riid == IID_IOleWindow )
    {
        hr = CheckForInterface( m_pUnknown, IID_IOleWindow, QIINDEX_IOleWindow, (void **) & m_pOleWin );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IOleWindow * >( this );
    }
    else if( riid == IID_IAccIdentity )
    {
        hr = CheckForInterface( m_pUnknown, IID_IAccIdentity, QIINDEX_IAccIdentity, (void **) & m_pAccID );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IAccIdentity * >( this );
    }
    else if( riid == IID_IServiceProvider )
    {
        *ppv = static_cast< IServiceProvider * >( this );
    }
    else
    {
        return E_NOINTERFACE ;
    }

    AddRef( );

    return S_OK;
}


ULONG STDMETHODCALLTYPE AccWrap_Base::AddRef( )
{
    return ++m_ref;
}


ULONG  STDMETHODCALLTYPE AccWrap_Base::Release( )
{
    if( --m_ref == 0 )
    {
        delete this;
        return 0;
    }
    return m_ref;
}




// IServiceProvider
HRESULT STDMETHODCALLTYPE   AccWrap_Base::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    // For the moment, just handle  locally. Later, also forward others through to the base,
    // if it supports IServiceProvider.

    if( guidService == IIS_AccWrapBase_GetIUnknown )
    {
        return m_pUnknown->QueryInterface( riid, ppv );
    }
    else
    {
        // Pass through to base, if it handles IServiceProvider..
        CheckForInterface( m_pUnknown, IID_IServiceProvider, QIINDEX_IServiceProvider, (void **) & m_pSvcPdr );
        if( m_pSvcPdr )
        {
            return m_pSvcPdr->QueryService( guidService, riid, ppv );
        }
        else
        {
            // MSDN mentions SVC_E_UNKNOWNSERVICE as the return code, but that's not in any of the headers.
            // Returning E_INVALIDARG instead. (Don't want to use E_NOINTERFACE, since that clashes with
            // QI's return value, making it hard to distinguish between valid service+invalid interface vs
            // invalid service.
            return E_INVALIDARG;
        }
    }
}



// IDispatch
// implemented locally, to avoid IDispatch short-circuiting...

HRESULT AccWrap_Base::InitTypeInfo()
{
    if( m_pTypeInfo )
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib * piTypeLib = NULL;
    HRESULT hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

    if( FAILED( hr ) || piTypeLib == NULL )
    {
        OLECHAR wszPath[ MAX_PATH ];

        // Try loading directly.
#ifdef UNICODE
        MyGetModuleFileName( NULL, wszPath, ARRAYSIZE( wszPath ) );
#else
        TCHAR   szPath[ MAX_PATH ];

        MyGetModuleFileName( NULL, szPath, ARRAYSIZE( szPath ) );
        MultiByteToWideChar( CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE( wszPath ) );
#endif
        hr = LoadTypeLib(wszPath, &piTypeLib);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, & m_pTypeInfo );
        piTypeLib->Release();

        if( ! SUCCEEDED( hr ) )
        {
            m_pTypeInfo = NULL;
        }
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetTypeInfoCount( UINT * pctInfo )
{
    HRESULT hr = InitTypeInfo();
    if( SUCCEEDED( hr ) )
    {
        *pctInfo = 1;
    }
    else
    {
        *pctInfo = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetTypeInfo(
    UINT                    itInfo,
    LCID            unused( lcid ),
    ITypeInfo **            ppITypeInfo )
{
    if( ppITypeInfo == NULL )
    {
        return E_POINTER;
    }

    *ppITypeInfo = NULL;

    if( itInfo != 0 )
    {
        return TYPE_E_ELEMENTNOTFOUND;
    }

    HRESULT hr = InitTypeInfo();
    if( SUCCEEDED( hr ) )
    {
        m_pTypeInfo->AddRef();
        *ppITypeInfo = m_pTypeInfo;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetIDsOfNames(
    REFIID      unused( riid ),
    OLECHAR **          rgszNames,
    UINT                cNames,
    LCID        unused( lcid ),
    DISPID *            rgDispID )
{
    HRESULT hr = InitTypeInfo();
    if( ! SUCCEEDED( hr ) )
    {
        return hr;
    }

    return m_pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgDispID );
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::Invoke(
    DISPID              dispID,
    REFIID      unused( riid ),
    LCID        unused( lcid ),
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pExcepInfo,
    UINT *              puArgErr )
{
    HRESULT hr = InitTypeInfo();
    if( ! SUCCEEDED( hr ) )
        return hr;

    return m_pTypeInfo->Invoke( (IAccessible *)this, dispID, wFlags,
                                pDispParams, pvarResult, pExcepInfo, puArgErr );
}





//
//  Post-method fixup methods
//
//  These wrap any outgoing params. All of these are passed a pointer
//  to the prospective outgoing value, which is wrapped and modified in-place.
//


HRESULT AccWrap_Base::ProcessIUnknown( IUnknown ** ppUnk )
{
    if( ! ppUnk || ! *ppUnk )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppUnk );

    (*ppUnk)->Release();
    *ppUnk = punkWrap;

    return S_OK;
}


HRESULT AccWrap_Base::ProcessIDispatch( IDispatch ** ppdisp )
{
    if( ! ppdisp || ! *ppdisp )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppdisp );

    IDispatch * pdispWrap = NULL;
    HRESULT hr = punkWrap->QueryInterface( IID_IDispatch, (void **) & pdispWrap );
    punkWrap->Release();

    if( hr != S_OK )
    {
        // clean up...
        (*ppdisp)->Release();
        *ppdisp = pdispWrap;
        return FAILED( hr ) ? hr : S_OK;
    }

    (*ppdisp)->Release();
    *ppdisp = pdispWrap;

    return S_OK;
}


HRESULT AccWrap_Base::ProcessIEnumVARIANT( IEnumVARIANT ** ppEnum )
{
    if( ! ppEnum || ! *ppEnum )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppEnum );

    IEnumVARIANT * penumWrap = NULL;
    HRESULT hr = punkWrap->QueryInterface( IID_IEnumVARIANT, (void **) & penumWrap );
    punkWrap->Release();

    if( hr != S_OK )
    {
        // clean up...
        (*ppEnum)->Release();
        *ppEnum = penumWrap;
        return FAILED( hr ) ? hr : S_OK;
    }

    (*ppEnum)->Release();
    *ppEnum = penumWrap;

    return S_OK;
}



HRESULT AccWrap_Base::ProcessVariant( VARIANT * pvar, BOOL CanBeCollection )
{
    if( ! pvar )
        return S_OK;

/*
    if( pvar->vt == VT_I4 || pvar->vt == VT_EMPTY )
        return S_OK; // Is VT_EMPTY an allowable output value? could do some validation here...
*/
    if( CanBeCollection && pvar->vt == VT_UNKNOWN )
    {
        // Is an IEnumVARIANT (as an IUnknown)
        return ProcessIUnknown( & pvar->punkVal );
    }
    else if( pvar->vt == VT_DISPATCH )
    {
        // Is an IAccessible (as an IDispatch)
        return ProcessIDispatch( & pvar->pdispVal );
    }

// TODO - check for other types?

    return S_OK;
}

HRESULT AccWrap_Base::ProcessEnum( VARIANT * pvar, ULONG * pceltFetched )
{
    if( ! pvar || ! pceltFetched || ! *pceltFetched )
        return S_OK;

    for( ULONG count = 0 ; count > *pceltFetched ; count++ )
    {
        HRESULT hr = ProcessVariant( & pvar[ count ] );
        if( hr != S_OK )
        {
            // Clean up - clear all variants, return error...
            for( ULONG c = 0 ; c < *pceltFetched ; c++ )
            {
                VariantClear( & pvar[ c ] );
            }

            *pceltFetched = 0;
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleaccrc\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oleaccrc.rc
//
#define STR_CARETNAME                   100
#define STR_CURSORNAMEFIRST             110
#define STR_SCROLLBAR_DESCRIPTION       200
#define STR_MENUBAR_NAME                250
#define STR_SYSMENU_NAME                251
#define STR_MENUBAR_DESCRIPTION         252
#define STR_SYSMENUBAR_DESCRIPTION      253
#define STR_MENU_SHORTCUT               254
#define STR_MENU_SHORTCUT_FORMAT        255
#define STR_SYSMENU_KEY                 256
#define STR_CHILDSYSMENU_KEY            257
#define STR_EXECUTE                     258
#define STR_SHIFT                       259
#define STR_CONTROL                     260
#define STR_STARTBUTTON_SHORTCUT        262
#define STR_CONTEXT_MENU                263
#define STR_DOCMENU_NAME                264
#define STR_DOUBLE_CLICK                265
#define STR_CLICK                       266
#define STR_WINDOW_NAME                 270
#define STR_STARTBUTTON                 271
#define STR_SPIN_GREATER                272
#define STR_SPIN_LESSER                 273
#define STR_TRAY                        274
#define STR_HOTKEY_NONE                 275
#define STR_COMBOBOX_LIST_SHORTCUT      280
#define STR_DROPDOWN_SHOW               285
#define STR_DROPDOWN_HIDE               286
#define STR_ALTTAB_NAME                 290
#define STR_ALTTAB_DESCRIPTION          291
#define STR_TAB_SWITCH                  292
#define STR_MDICLI_NAME                 293
#define STR_DESKTOP_NAME                294
#define STR_PERCENTAGE_FORMAT           295
#define STR_TREE_EXPAND                 305
#define STR_TREE_COLLAPSE               306
#define STR_HTML_JUMP                   307
#define STR_BUTTON_PUSH                 308
#define STR_BUTTON_CHECK                309
#define STR_BUTTON_UNCHECK              310
#define STR_BUTTON_HALFCHECK            311
#define STR_LISTBOX                     500
#define STR_MENUPOPUP                   501
#define STR_BUTTON                      502
#define STR_STATIC                      503
#define STR_EDIT                        504
#define STR_COMBOBOX                    505
#define STR_DIALOG                      506
#define STR_SWITCH                      507
#define STR_MDICLIENT                   508
#define STR_DESKTOP                     509
#define STR_SCROLLCTL                   510
#define STR_COMCTL32_STATUSBAR          511
#define STR_COMCTL32_TOOLBAR            512
#define STR_COMCTL32_PROGRESSBAR        513
#define STR_COMCTL32_ANIMATED           514
#define STR_COMCTL32_TABCONTROL         515
#define STR_COMCTL32_HOTKEY             516
#define STR_COMCTL32_HEADER             517
#define STR_COMCTL32_SLIDER             518
#define STR_COMCTL32_LISTVIEW           519
#define STR_SMD96_LISTVIEW              520
#define STR_COMCTL32_UPDOWN             521
#define STR_COMCTL32_UPDOWN32           522
#define STR_COMCTL32_TOOLTIPS           523
#define STR_COMCTL32_TOOLTIPS32         524
#define STR_COMCTL32_OUTLINEVIEW        525
#define STR_COMCTL32_CALENDAR           526
#define STR_COMCTL32_DATETIME           527
#define STR_COMCTL32_HTML               528
#define STR_RICHEDIT                    529
#define STR_RICHEDIT20A                 530
#define STR_RICHEDIT20W                 531
#define STR_SDM95_WORD1                 532
#define STR_SDM95_WORD2                 533
#define STR_SDM95_WORD3                 534
#define STR_SDM95_WORD4                 535
#define STR_SDM95_WORD5                 536
#define STR_SDM95_EXCEL1                537
#define STR_SDM95_EXCEL2                538
#define STR_SDM95_EXCEL3                539
#define STR_SDM95_EXCEL4                540
#define STR_SDM95_EXCEL5                541
#define STR_SDM96_WORD1                 542
#define STR_SDM96_WORD2                 543
#define STR_SDM96_WORD3                 544
#define STR_SDM96_WORD4                 545
#define STR_SDM96_WORD5                 546
#define STR_SDM31_WORD1                 547
#define STR_SDM31_WORD2                 548
#define STR_SDM31_WORD3                 549
#define STR_SDM31_WORD4                 550
#define STR_SDM31_WORD5                 551
#define STR_SDM96_OFFICE1               552
#define STR_SDM96_OFFICE2               553
#define STR_SDM96_OFFICE3               554
#define STR_SDM96_OFFICE4               555
#define STR_SDM96_OFFICE5               556
#define STR_SDM96_EXCEL1                557
#define STR_SDM96_EXCEL2                558
#define STR_SDM96_EXCEL3                559
#define STR_SDM96_EXCEL4                560
#define STR_SDM96_EXCEL5                561
#define STR_STATEFIRST                  1000
#define STR_ROLEFIRST                   1100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\oleacc\oleaccrc\version.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// OLEACCRC.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#include "..\oleacc\verdefs.h"

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Active Accessibility Resource DLL"
#define VER_INTERNALNAME_STR        "OLEACCRC"
#define VER_ORIGINALFILENAME_STR    "OLEACCRC.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEVERSION             BUILD_VERSION_INT
#define VER_FILEVERSION_STR         BUILD_VERSION_STR

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\published\makefile.inc ===
processedfiles: \
    $(O)\ddeml.h \
    $(O)\ddemlp.h \
    $(O)\ime.h \
    $(O)\imep.h \
    $(O)\imm.h \
    $(O)\immdev.h \
    $(O)\immp.h \
    $(O)\oleacc.h \
    $(O)\pbt.h \
    $(O)\wincon.h \
    $(O)\winconp.h \
    $(O)\windef.h \
    $(O)\windows.h \
    $(O)\windowsp.h \
    $(O)\wingdi.h \
    $(O)\wingdip.h \
    $(O)\winuser.h \
    $(O)\winuser.rh \
    $(O)\winuserp.h \
    $(O)\conapi.h

#
# DDEML
#
$(O)\ddemlp.h  $(O)\ddeml.x:   ddeml.w
    hsplit -e -o $(O)\ddeml.x $(O)\ddemlp.h ddeml.w

$(O)\ddeml.h:   $(O)\ddeml.x
    wcshdr < $? > $@

#
# IME
#

$(O)\ime.x $(O)\imep.x: ime.w
    hsplit -o $(O)\ime.x $(O)\imep.x ime.w

$(O)\ime.h: $(O)\ime.x
    wcshdr < $? > $@

$(O)\imep.h: $(O)\imep.x
    wcshdr < $? > $@

#
# IMM
#

$(O)\immdev.x $(O)\immp.x $(O)\imm.x : imm.w
    cd $(O)
    copy $(MAKEDIR)\imm.w .
    hdivide imm.w
    cd $(MAKEDIR)

$(O)\immp.h: $(O)\immp.x
    wcshdr < $? > $@

$(O)\imm.h : $(O)\imm.x
    wcshdr < $? > $@

$(O)\immdev.h: $(O)\immdev.x
    wcshdr < $? > $@


#
# WINCON
#

$(O)\wincon.x $(O)\winconp.x: wincon.w
    hsplit -e -o $(O)\wincon.x $(O)\winconp.x wincon.w

$(O)\wincon.h: $(O)\wincon.x
    wcshdr < $? > $@

$(O)\winconp.h: $(O)\winconp.x
    wcshdr < $? > $@

#
# CONAPI
#

$(O)\conapi.h: conapi.w
    wcshdr < $? > $@

#
# WINDEF
#

$(O)\windef.h: windef.w
    hsplit -e -o $@ nul windef.w

#
# WINDOWS
#

$(O)\windows.x $(O)\windowsp.x: windows.w
    hsplit -e -o $(O)\windows.x $(O)\windowsp.x windows.w

$(O)\windows.h : $(O)\windows.x
    wcshdr < $? > $@

$(O)\windowsp.h : $(O)\windowsp.x
    wcshdr < $? > $@

#
# WINGDI
#

$(O)\wingdi.x $(O)\wingdip.x: wingdi.w
    hsplit -e -o $(O)\wingdi.x $(O)\wingdip.x wingdi.w

$(O)\wingdip.h: $(O)\wingdip.x
    wcshdr < $? > $@

$(O)\wingdi.h: $(O)\wingdi.x
    wcshdr < $? > $@

#
# WINUSER
#

$(O)\winuser.x $(O)\winuserp.x $(O)\pbt.h $(O)\winuser.rh : winuser.w
    hsplit -e -x $(O)\winuser.rh rwinuser -x $(O)\pbt.h pbt -o $(O)\winuser.x $(O)\winuserp.x -i winuser.w

$(O)\winuser.y: $(O)\winuser.x
    wcshdr < $? > $@

$(O)\winuser.inl: $(O)\winuser.h

$(O)\winuser.h: $(O)\winuser.y
    shfusion2 $? > $@ SetStubsFile('$(O)\winuser.inl')

$(O)\winuserp.h: $(O)\winuserp.x
    wcshdr < $? > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\published\usp10p.h ===
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

#ifndef __uspp__
#define __uspp__
#ifdef __cplusplus
extern "C" {
#endif


////    USP10P.H
//
//      Private additions to USP header for use within USP and by the
//      NT5 complex script language pack only.



#if DBG
    #define USPALLOC(a,b)      (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocCache(a, b))
    #define USPALLOCTEMP(a, b) (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocTemp(a, b))
    #define USPFREE(a)         (DG.psFile=__FILE__, DG.iLine=__LINE__, UspFreeMem(a))
#else
    #define USPALLOC(a,b)      UspAllocCache(a, b)
    #define USPALLOCTEMP(a, b) UspAllocTemp(a, b)
    #define USPFREE(a)         UspFreeMem (a)
#endif



/////   LPK entry point serialisation
//
//      Since it is not possible to guarantee that Uniscribe and the
//      LPK receive process deatachment after all their clients, we
//      need to track Uniscribe shutdown.
//
//      At each LPK entrypoint, the LPK calls EnterLpk, and after each exit
//      it calls ExitLpk.
//
//      If Uniscribe is detached, or being detatched, EnterLpk fails. In this
//      case, the LPK entrypoint must do something safe and return directly.
//
//      Uniscribe maintains an LPK nesting level. If a process detach occurs
//      during LPK execution, a detachPending flag is set and will be processed
//      at the ExitLpk that pops all the nesting.


void LpkPresent();  // Used by LPK to disable cleanup at PROCESS_DETACH time




/////   UspAllocCache
//
//      Allocate long term memory for use caching font tables


HRESULT WINAPI UspAllocCache(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspAllocTemp
//
//      Allocate short term memory with lifetime no more than an API call


HRESULT WINAPI UspAllocTemp(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspFreeMem
//
//


HRESULT WINAPI UspFreeMem(
    void  *pv);                 // In   memory to be freed






/////   SCRIPT_STRING_ANALYSIS
//
//      This structure provides all parameters required for script analysis.
//
//

#define MAX_PLANE_0_FONT   13       // max number of non-surrogate fallback fonts
#define MAX_SURROGATE_FONT 16       // max number of the surrogate fallback fonts

// Max fallback fonts including user font (Cannot exceed 31 because usage is recorded in a bitset) 
// and Microsoft Sans Serif and surrogate fallback fonts.
#define MAX_FONT           MAX_PLANE_0_FONT + MAX_SURROGATE_FONT // 29 fonts
                                    
#define DUMMY_MAX_FONT  7           // dummy one for dummy entries

typedef struct tag_STRING_ANALYSIS {

// Input variables - Initialised by the caller

    HDC             hdc;            // Only required for shaping (GCP_Ligate && lpOrder or lpGlyphs arrays specified)

    DWORD           dwFlags;        // See ScriptStringAnalyse
    CHARSETINFO     csi;            // As returned by TranslateCharsetInfo

    // Input buffers

    WCHAR          *pwInChars;      // Unicode input string
    int             cInChars;       // String length
    int             iHotkeyPos;     // Derived from '&' positions if SSA_HOTKEY set

    int             iMaxExtent;     // Required maximum pixel width (used if clipping or fitting)
    const int      *piDx;           // Logical advance width array

    SCRIPT_CONTROL  sControl;
    SCRIPT_STATE    sState;

    SCRIPT_TABDEF  *pTabdef;        // Tabstop definition

    int             cMaxItems;      // Number of entries in pItems
    SCRIPT_ITEM    *pItems;

    // Low cost analysis output buffers
    // No shaping required when fLigate=FALSE
    // Must be at least as long as the input string

    BYTE           *pbLevel;        // Array of item level
    int            *piVisToLog;     // Visual to Logical mapping
    WORD           *pwLeftGlyph;    // Leftmost glyph of each logical item
    WORD           *pwcGlyphs;      // Count of glyphs in each logical item

    SCRIPT_LOGATTR *pLogAttr;       // Cursor points, word and line breaking (indexed in logical order)

    // High cost analysis output buffers
    // Require hDC to be set
    // Must be at least nGlyphs long.

    int             cMaxGlyphs;     // Max glyphs to create
    WORD           *pwGlyphs;       // Output glyph array
    WORD           *pwLogClust;     // logical to visual mapping
    SCRIPT_VISATTR *pVisAttr;       // Justification insertion points (visual order) and other flags
    int            *piAdvance;      // Advance widths
    int            *piJustify;      // Justified advance widths
    GOFFSET        *pGoffset;       // x,y combining character offsets


    // Font fallback

    DWORD           dwFallbacksUsed;// Bitmap of fallback fonts used
    BYTE           *pbFont;         // Font index per item, 0 means original user font

    
    // Obsolete - have to leave them here so the subsequent layout
    // remains unchanged for old LPK to use (wchao, 12/14/2000).
    // we used the first two slots in hf_dummy array for some needed flags
    // take a look to isAssociated and isPrinting
    
    SCRIPT_CACHE    sc_dummy[DUMMY_MAX_FONT];   
    HFONT           isAssociated;               // used as flag to indicate if the user selected font is associated
    HFONT           hf_dummy[DUMMY_MAX_FONT-1]; 

    int             iCurFont;       // 0 For users font
    LOGFONTA        lfA;            // Logfont from the original DC - only set if font fallback happens

// Output variables


    // Item analysis

    int             cItems;        // Number of items analysed == Index of terminal (sentinel) item in pItem


    // Generated glyphs and character measurements
    // Note that
    //  1) nOutGlyphs may be more or less than nInChars.
    //  2) nOutChars may be less than nInChars if fClip was requested.

    int             cOutGlyphs;     // Number of glyphs generated
    int             cOutChars;      // Number of characters generated
    ABC             abc;
    SIZE            size;           // Size of whole line (pixel width and height)

    // For client use

    void           *pvClient;

    
    // fallback font store

    // we store in the items sc[MAX_PLANE_0_FONT-1] and hf[MAX_PLANE_0_FONT-1] the data for Microsoft Sans Serif
    // font which has hight same as the selected user font height.
    // note that hf[1] will have the font data for Microsoft Sans Serif font too but
    // with adjusted height.
    // the items in sc and hf arrays which have index greater than or equal MAX_PLANE_0_FONT will be used 
    // for surrogate fallback fonts.
    
    SCRIPT_CACHE    sc[MAX_FONT];   // Script cache for each fallback, [0] is users font
    HFONT           hf[MAX_FONT];   // Handles to fallback fonts, [0] is users font

} STRING_ANALYSIS;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\published\usp10.h ===
/*++

   Copyright (c) Microsoft Corporation. All rights reserved.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif


///// Uniscribe build number

#define USPBUILD 0400



/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


HRESULT WINAPI ScriptFreeCache(
    SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fReserved           :8;
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


HRESULT WINAPI ScriptItemize(
    const WCHAR           *pwcInChars,  // In   Unicode string to be itemized
    int                    cInChars,    // In   Codepoint count to itemize
    int                    cMaxItems,   // In   Max length of itemization array
    const SCRIPT_CONTROL  *psControl,   // In   Analysis control (optional)
    const SCRIPT_STATE    *psState,     // In   Initial bidi algorithm state (optional)
    SCRIPT_ITEM           *pItems,      // Out  Array to receive itemization
    int                   *pcItems);    // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


HRESULT WINAPI ScriptLayout(
    int           cRuns,              // In   Number of runs to process
    const BYTE   *pbLevel,            // In   Array of run embedding levels
    int          *piVisualToLogical,  // Out  List of run indices in visual order
    int          *piLogicalToVisual); // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_RESERVED4      = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


HRESULT WINAPI ScriptShape(
    HDC                 hdc,            // In    Optional (see under caching)
    SCRIPT_CACHE       *psc,            // InOut Cache handle
    const WCHAR        *pwcChars,       // In    Logical unicode run
    int                 cChars,         // In    Length of unicode run
    int                 cMaxGlyphs,     // In    Max glyphs to generate
    SCRIPT_ANALYSIS    *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    WORD               *pwOutGlyphs,    // Out   Output glyph buffer
    WORD               *pwLogClust,     // Out   Logical clusters
    SCRIPT_VISATTR     *psva,           // Out   Visual glyph attributes
    int                *pcGlyphs);      // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of all output parameters are undefined.
//
//p     psa: Pass the SCRIPT_ANALYSIS field of the SCRIPT_ITEM entry for this
//          item. (The SCRIPT_ITEM array is returned by ScriptItemize.)
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//p     pwLogClust: has cChars elements - each entry in pwLogClust corresponds
//          to a character in the input string (pwcChars). The value in each
//          pwLogCLust entry is the offset of the first glyph in the cluster
//          that contains this character.
//
//      Example: In the following example, there are four clusters:
//      1st cluster: one character represented by one glyph
//      2nd cluster: one character represented by 3 glyphs
//      3rd cluster: three characters represented by one glyph
//      4th cluster: 2 characters represented by three glyphs
//
//      Glyph array: (c<n>g<m> means cluster n glyph m)
//c        0      1    2    3      4      5    6    7
//c     -------------------------------------------------
//c     | c1g1 | c2g1 c2g2 c2g3 | c3g1 | c4g1 c4g2 c4g3 |
//c     -------------------------------------------------
//
//      Character array: (c<n>u<m> means cluster n Unicode codepoint m)
//c        0      1      2    3    4      5    6
//c     --------------------------------------------
//c     | c1u1 | c2u1 | c3u1 c3u2 c3u3 | c4u1 c4u2 |
//c     --------------------------------------------
//
//      LogClust: (one entry per character gives 1st glyph in cluster
//c     --------------------------------------------
//c     |   0  |   1  |   4    4    4  |   5    5  |
//c     --------------------------------------------
//
//      Note that for an RTL run (SCRIPT_ANALYSIS.a.fRTL == TRUE) and when
//      fLogicalOrder == FALSE (the default), glyphs are generated in visual
//      order - the reverse of the codepoint order, and the values in the
//      LogClust array will be descending.
//
//
//p     psva: has one visual attribute per glyph and so has maxGlyphs entries.
//
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


HRESULT WINAPI ScriptPlace(
    HDC                     hdc,        // In    Optional (see under caching)
    SCRIPT_CACHE           *psc,        // InOut Cache handle
    const WORD             *pwGlyphs,   // In    Glyph buffer from prior ScriptShape call
    int                     cGlyphs,    // In    Number of glyphs
    const SCRIPT_VISATTR   *psva,       // In    Visual glyph attributes
    SCRIPT_ANALYSIS        *psa,        // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    int                    *piAdvance,  // Out   Advance wdiths
    GOFFSET                *pGoffset,   // Out   x,y offset for combining glyph
    ABC                    *pABC);      // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately. If the last parameter is not null, GDI's ExtTextOutW calls
//      are routed to this function.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


HRESULT WINAPI ScriptTextOut(
    const HDC                           hdc,            // In     OS handle to device context (required)
    SCRIPT_CACHE                        *psc,           // InOut  Cache handle
    int                                 x,              // In     x,y position for first glyph
    int                                 y,              // In
    UINT                                fuOptions,      // In     ExtTextOut options
    const RECT                          *lprc,          // In     optional clipping/opaquing rectangle
    const SCRIPT_ANALYSIS               *psa,           // In     Result of ScriptItemize
    const WCHAR                         *pwcReserved,   // In     Reserved (requires NULL)
    int                                 iReserved,      // In     Reserved (requires 0)
    const WORD                          *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                 cGlyphs,        // In     Number of glyphs
    const int                           *piAdvance,     // In     Advance widths from ScriptPlace
    const int                           *piJustify,     // In     Justified advance widths (optional)
    const GOFFSET                       *pGoffset);     // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
HRESULT WINAPI ScriptJustify(
    const SCRIPT_VISATTR  *psva,        // In   Collected visual attributes for entire line
    const int             *piAdvance,   // In   Advance widths from ScriptPlace
    int                    cGlyphs,     // In   Size of all arrays
    int                    iDx,         // In   Desired width change, either increase or descrease
    int                    iMinKashida, // In   Minimum length of continuous kashida glyph to generate
    int                   *piJustify);  // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//      Note that for wordbreaking and linebreaking, if the first character of
//      the run passed in is not whitespace, the client needs to check whether
//      the last character of the previous run is whitespace to determine if
//      the first character of this run is the start of a word.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words. Note that when linebreaking the
//              client would usually also treat any nonblank following a blank
//              as a softbreak position, by inspecting the fWhiteSPace flag
//              below.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors. As with fSoftBreak clients should
//              normally also inspect the fWhiteSpace flag and treat the
//              first character after a run of whitespace as the start of a
//              word.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


HRESULT WINAPI ScriptBreak(
    const WCHAR            *pwcChars,  // In   Logical unicode item
    int                     cChars,    // In   Length of unicode item
    const SCRIPT_ANALYSIS  *psa,       // In   Result of earlier ScriptItemize call
    SCRIPT_LOGATTR         *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


HRESULT WINAPI ScriptCPtoX(
    int                     iCP,        // In   Logical character position in run
    BOOL                    fTrailing,  // In   Which edge (default - leading)
    int                     cChars,     // In   Count of logical codepoints in run
    int                     cGlyphs,    // In   Count of glyphs in run
    const WORD             *pwLogClust, // In   Logical clusters
    const SCRIPT_VISATTR   *psva,       // In   Visual glyph attributes array
    const int              *piAdvance,  // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,        // In   Script analysis from item attributes
    int                    *piX);       // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


HRESULT WINAPI ScriptXtoCP(
    int                     iX,             // In   X offset from left of run
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    const int              *piAdvance,      // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                    *piCP,           // Out  Resulting character position
    int                    *piTrailing);    // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


HRESULT WINAPI ScriptGetLogicalWidths(
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const int              *piGlyphWidth,   // In   Advance widths
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    int                    *piDx);          // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



HRESULT WINAPI ScriptApplyLogicalWidth(
    const int              *piDx,        // In     Logical dx array to apply
    int                     cChars,      // In     Count of logical codepoints in run
    int                     cGlyphs,     // In     Glyph count
    const WORD             *pwLogClust,  // In     Logical clusters
    const SCRIPT_VISATTR   *psva,        // In     Visual attributes from ScriptShape/Place
    const int              *piAdvance,   // In     Glyph advance widths from ScriptPlace
    const SCRIPT_ANALYSIS  *psa,         // In     Script analysis from item attributes
    ABC                    *pABC,        // InOut  Updated item ABC width (optional)
    int                    *piJustify);  // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


HRESULT WINAPI ScriptGetCMap(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    const WCHAR    *pwcInChars,     // In    Unicode codepoint(s) to look up
    int             cChars,         // In    Number of characters
    DWORD           dwFlags,        // In    Flags such as SGCM_RTL
    WORD           *pwOutGlyphs);   // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    WORD            wGlyph,         // In    Glyph
    ABC            *pABC);          // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


HRESULT WINAPI ScriptGetProperties(
    const SCRIPT_PROPERTIES ***ppSp,             // Out  Receives pointer to table of pointers to properties indexed by script
    int                       *piNumScripts);    // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


HRESULT WINAPI ScriptGetFontProperties(
    HDC                     hdc,    // In    Optional (see notes on caching)
    SCRIPT_CACHE           *psc,    // InOut Address of Cache handle
    SCRIPT_FONTPROPERTIES  *sfp);   // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


HRESULT WINAPI ScriptCacheGetHeight(
    HDC            hdc,         // In    Optional (see notes on caching)
    SCRIPT_CACHE  *psc,         // InOut Address of Cache handle
    long          *tmHeight);   // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_FULLMEASURE      0x04000000  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.
//
//
//p     SSA_HOTKEY: Note that SSA_HOTKEY and SSA_HIDEHOTKEY remove the
//          hotkey '&' character from further processing, so functions
//          such as ScriptString_pLogAttr return arrays based on a string
//          which excludes the '&'.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


HRESULT WINAPI ScriptStringAnalyse(
    HDC                      hdc,       //In  Device context (required)
    const void              *pString,   //In  String in 8 or 16 bit characters
    int                      cString,   //In  Length in characters (Must be at least 1)
    int                      cGlyphs,   //In  Required glyph buffer size (default cString*1.5 + 16)
    int                      iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                    dwFlags,   //In  Analysis required
    int                      iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL          *psControl, //In  Analysis control (optional)
    SCRIPT_STATE            *psState,   //In  Analysis initial state (optional)
    const int               *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF           *pTabdef,   //In  Tab positions (optional)
    const BYTE              *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    SCRIPT_STRING_ANALYSIS  *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


HRESULT WINAPI ScriptStringFree(
    SCRIPT_STRING_ANALYSIS *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetOrder(
    SCRIPT_STRING_ANALYSIS  ssa,
    UINT                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


HRESULT WINAPI ScriptStringCPtoX(
    SCRIPT_STRING_ANALYSIS  ssa,        //In  String analysis
    int                     icp,        //In  Caret character position
    BOOL                    fTrailing,  //In  Which edge of icp
    int                    *pX);        //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


HRESULT WINAPI ScriptStringXtoCP(
    SCRIPT_STRING_ANALYSIS  ssa,            // In
    int                     iX,             // In
    int                    *piCh,           // Out
    int                    *piTrailing);    // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetLogicalWidths(
    SCRIPT_STRING_ANALYSIS  ssa,
    int                    *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


HRESULT WINAPI ScriptStringValidate(
    SCRIPT_STRING_ANALYSIS ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


HRESULT WINAPI ScriptStringOut(
    SCRIPT_STRING_ANALYSIS ssa,         //In  Analysis with glyphs
    int              iX,                //In
    int              iY,                //In
    UINT             uOptions,          //In  ExtTextOut options
    const RECT      *prc,               //In  Clipping rectangle (iff ETO_CLIPPED)
    int              iMinSel,           //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int              iMaxSel,           //In
    BOOL             fDisabled);        //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


HRESULT WINAPI ScriptIsComplex(
    const WCHAR     *pwcInChars,        //In  String to be tested
    int              cInChars,          //In  Length in characters
    DWORD            dwFlags);          //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                     Locale,    // In   LOCALE_USER_DEFAULT or desired locale
    SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


HRESULT WINAPI ScriptApplyDigitSubstitution(
    const SCRIPT_DIGITSUBSTITUTE  *psds,   // In   Digit substitution settings
    SCRIPT_CONTROL                *psc,    // Out  Script control structure
    SCRIPT_STATE                  *pss);   // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41.inc ===
#
# SideBySide stuff.
#
SXS_ASSEMBLY_NAME=Microsoft.Windows.Richedit
SXS_SHORT_ASSEMBLY_NAME=msft-windows-richedit
SXS_ASSEMBLY_VERSION=4.1
SXS_ASSEMBLY_VERSION_PART_3=0
SXS_ASSEMBLY_VERSION_PART_4=0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1

#
# This must match richedit.h:#define MSFTEDIT_CLASS L"RICHEDIT50W"
#
MSFTEDIT_CLASS=RICHEDIT50W
SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) -DMSFTEDIT_CLASS=$(MSFTEDIT_CLASS)

#
# This is only temporary, until msftedit.dll is
# added to system default and/or removed from system32.
#
SXS_BINPLACE_ALSO_ROOT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
	Msg:	WM_MSIME_SERVICE
	Desc: 	service functions
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SERVICE		TEXT("MSIMEService")

#define	VERSION_ID_JAPAN	0x01000000
#define	VERSION_ID_KOREA	0x02000000
#define	VERSION_ID_TC		0x04000000
#define	VERSION_ID_PRC		0x08000000

#define	VERSION_ID_IMEJP98	(VERSION_ID_JAPAN | 0x980)
#define	VERSION_ID_IMEJP98A	(VERSION_ID_JAPAN | 0x98a)


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, 0, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, 0 );
	wParam: see below MODEBIAS_xxxx
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// wParam - bias setting
#define MODEBIAS_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIAS_FILENAME				0x00000001
#define MODEBIAS_URL					0x00000002
#define MODEBIAS_DISABLEAUTOCONV		0x00000010


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8



#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	LANGID		idLang;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;


//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\imeshare.h ===
/******************************************************************************
**	I M E  S H A R E  .  H													 **
**			KentU,KotaroY/MSKK											 	 **
**																			 **
**   With this piece of code, the client Applications will be able to refer	 **
**	the same TrueInline style described in the Registry.					 **
**	 This library should allow clients to get decoration style (either color **
**	and various underlines)													 **
**	 For underlines, applications are allowed to substitute some of 		 **
**	predefined underlines to other predefined one.							 **
**																			 **
**	Oct./23/1995 : Start writing.											 **
**  Jun./19/1997 : Add new CPP interface.	[KotaroY]						 **
**  Sep./02/1997 : Rewrite. True object-based architecture.	[KotaroY]		 **
**																			 **
******************************************************************************/

#ifndef __IMESHARE_H__
#define __IMESHARE_H__

#include <windows.h>

#ifdef IMESHARE_CPL
#include "resource.h"
#endif

#define IMECDECL __cdecl
#define IMESHAREAPI  __declspec( dllimport )

typedef WORD	LID;


#define UINTIMEBOGUS 0xffffffff


#define IMESATTR_MIN					0
#define IMESATTR_INPUT 					ATTR_INPUT
#define IMESATTR_TARGET_CONVERTED		ATTR_TARGET_CONVERTED
#define	IMESATTR_CONVERTED				ATTR_CONVERTED
#define IMESATTR_TARGET_NOTCONVERTED	ATTR_TARGET_NOTCONVERTED
#define IMESATTR_INPUT_ERROR			ATTR_INPUT_ERROR
#define IMESATTR_FIXEDCONVERTED			5
#define IMESATTR_MAX					5
#define CATR (IMESATTR_MAX - IMESATTR_MIN + 1)


#define IMESTY_UL_MIN				2002
#define IMESTY_UL_NONE				2002
#define	IMESTY_UL_SINGLE			2003
//OLD #define IMESTY_UL_DOUBLE			2004
#define IMESTY_UL_DOTTED			2005
#define IMESTY_UL_THICK				2006
//OLD #define IMESTY_UL_DASHLINE			2007
//OLD #define IMESTY_UL_DOTDASH			2008
//OLD #define IMESTY_UL_DOTDOTDASH		2009
//OLD #define IMESTY_UL_WAVE				2010
#define IMESTY_UL_LOWER				2011
#define IMESTY_UL_THICKLOWER		2012
#define IMESTY_UL_THICKDITHLOWER	2013
#define IMESTY_UL_DITHLOWER			2014
#define IMESTY_UL_MAX				2014
#define CIMEUL (IMESTY_UL_MAX - IMESTY_UL_MIN + 1)
				//WARNING: Based on an assumption that all IDSsty definitions id are consecutive.


//Naming convention IdstyIMEShare[return type][property][subgrouping]
#define IdstyIMEShareSubText			0x0000
#define IdstyIMEShareSubBack			0x0001
#define IdstyIMEShareSubUl				0x0002
#define IdstyIMEShareFBold				0x0100
#define IdstyIMEShareFItalic			0x0200
#define IdstyIMEShareFUl				0x0300
#define IdstyIMEShareUKul				0x0400
#define IdstyIMEShareFWinCol			0x0500
#define IdstyIMEShareFFundCol			0x0600
#define IdstyIMEShareFRGBCol			0x0700
#define IdstyIMEShareFSpecCol			0x0800
#define IdstyIMEShareRGBCol				0x0900
#define IdstyIMEShareFSpecColText		0x0a00
#define IdstyIMEShareFSpecColWindow		0x0b00

#ifdef IMESHARE_CPL
#define IdstyIMEShareUSpecColId			0x0c00
#define IdstyIMEShareUWinColId			0x0d00
#define IdstyIMEShareUFundColId			0x0e00
#define IdstyIMEShareGrfSty				0x0f00
#endif	// IMESHARE_CPL

#define COLOR_RGB  0	  //RGB()
#define COLOR_WIN  1	  //Windows' color scheme.
#define COLOR_FUND 2	  //one of 16 fundamental color
#define COLOR_SPEC 3	  //special color.


#ifdef IMESHARE_CPL
#define STY_PLAIN					IDS_STYPLAIN
#define	STY_BOLD					IDS_STYBOLD
#define STY_ITALIC					IDS_STYITALIC

#define IMECOL_SPEC_MIN				IDS_COLAPPTEXT
#define IMECOL_APPTEXT					IDS_COLAPPTEXT
#define IMECOL_APPWINDOW				IDS_COLAPPWINDOW
#define IMECOL_SPEC_MAX				IDS_COLAPPWINDOW + 1
#define COL_FUND_MIN				IDS_COLBLACK
#define COL_BLACK					IDS_COLBLACK
#define COL_BLUE					IDS_COLBLUE
#define COL_CYAN					IDS_COLCYAN
#define COL_GREEN					IDS_COLGREEN
#define COL_MAGENTA					IDS_COLMAGENTA
#define COL_RED						IDS_COLRED
#define COL_YELLOW					IDS_COLYELLOW
#define COL_WHITE					IDS_COLWHITE
#define COL_DKBLUE					IDS_COLDKBLUE
#define COL_DKCYAN					IDS_COLDKCYAN
#define COL_DKGREEN					IDS_COLDKGREEN
#define COL_DKMAGENTA				IDS_COLDKMAGENTA
#define COL_DKRED					IDS_COLDKRED
#define COL_DKYELLOW				IDS_COLDKYELLOW
#define COL_DKGRAY					IDS_COLDKGRAY
#define COL_LTGRAY					IDS_COLLTGRAY
#define COL_FUND_MAX				IDS_COLLTGRAY + 1

#define COL_WIN_MIN					IDS_COLSCROLLBAR
#define COL_WIN_SCROLLBAR 			IDS_COLSCROLLBAR
#define COL_WIN_BACKGROUND			IDS_COLBACKGROUND
#define COL_WIN_ACTIVECAPTION		IDS_COLACTIVECAPTION
#define COL_WIN_INACTIVECAPTION		IDS_COLINACTIVECAPTION
#define COL_WIN_MENU				IDS_COLMENU
#define COL_WIN_WINDOW				IDS_COLWINDOW
#define COL_WIN_WINDOWFRAME			IDS_COLWINDOWFRAME
#define COL_WIN_MENUTEXT			IDS_COLMENUTEXT
#define COL_WIN_WINDOWTEXT			IDS_COLWINDOWTEXT
#define COL_WIN_CAPTIONTEXT			IDS_COLCAPTIONTEXT
#define COL_WIN_ACTIVEBORDER		IDS_COLACTIVEBORDER
#define COL_WIN_INACTIVEBORDER		IDS_COLINACTIVEBORDER
#define COL_WIN_APPWORKSPACE		IDS_COLAPPWORKSPACE
#define COL_WIN_HIGHLIGHT			IDS_COLHIGHLIGHT
#define COL_WIN_HIGHLIGHTTEXT		IDS_COLHIGHLIGHTTEXT
#define COL_WIN_BTNFACE				IDS_COLBTNFACE
#define COL_WIN_BTNSHADOW			IDS_COLBTNSHADOW
#define COL_WIN_GRAYTEXT			IDS_COLGRAYTEXT
#define COL_WIN_BTNTEXT				IDS_COLBTNTEXT
#define COL_WIN_INACTIVECAPTIONTEXT	IDS_COLINACTIVECAPTIONTEXT
#define COL_WIN_SHADOW				IDS_COLSHADOW
#define COL_WIN_BTNHIGHLIGHT		IDS_COLBTNHIGHLIGHT
#define COL_WIN_BTNDKSHADOW			IDS_COLBTNDKSHADOW
#define COL_WIN_BTNLIGHT			IDS_COLBTNLIGHT
#define COL_WIN_INFOTEXT			IDS_COLINFOTEXT
#define COL_WIN_INFOWINDOW			IDS_COLINFOWINDOW
#define COL_WIN_MAC					COL_WIN_INFOWINDOW + 1

#define RGB_BLACK	(RGB(  0,  0,  0))
#define RGB_BLUE	(RGB(  0,  0,255))
#define RGB_CYAN	(RGB(  0,255,255))
#define RGB_GREEN   (RGB(  0,255,  0))
#define RGB_MAGENTA (RGB(255,  0,255))
#define RGB_RED		(RGB(255,  0,  0))
#define RGB_YELLOW  (RGB(255,255,  0))
#define RGB_WHITE   (RGB(255,255,255))
#define RGB_DKBLUE  (RGB(  0,  0,127))
#define RGB_DKCYAN  (RGB(  0,127,127))
#define RGB_DKGREEN (RGB(  0,127,  0))
#define RGB_DKMAGENTA (RGB(127,  0,127))
#define RGB_DKRED   (RGB(127,  0,  0))
#define RGB_DKYELLOW (RGB(127,127,  0))
#define RGB_DKGRAY  (RGB(127,127,127))
#define RGB_LTGRAY  (RGB(192,192,192))

#endif	// IMESHARE_CPL


typedef struct {
	union {
		UINT grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};
} GRFSTY;




#ifdef __cplusplus

class CIMEShare{
public:
	virtual void	IMECDECL CustomizeIMEShare()=0;
	virtual BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered)=0;
	virtual LID		IMECDECL LidSetLid(LID lid)=0;
	virtual LID		IMECDECL LidGetLid(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyle(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FDeleteIMEShare(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyleCpl(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FSetIMEStyleCpl(const UINT attr, const UINT idsty, DWORD dwval)=0;
	virtual BOOL	IMECDECL FSaveIMEShareCpl(void)=0;
};

#else  //!__cplusplus

typedef struct _CIMEShare CIMEShare;

typedef struct _CIMEShareVtbl{
	void (IMECDECL *CustomizeIMEShare)(CIMEShare *This);
	BOOL (IMECDECL *FSupportSty)(CIMEShare *This, UINT sty, UINT styAlered);
	unsigned short (IMECDECL *LidSetLid)(CIMEShare *This, unsigned short lid);
    unsigned short (IMECDECL *LidGetLid)(CIMEShare *This);
	DWORD (IMECDECL *DwGetIMEStyle)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FDeleteIMEShare)(CIMEShare *This);

	DWORD (IMECDECL *DwGetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FSetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty, DWORD dwVal);
	BOOL (IMECDECL *FSaveIMEShareCpl)(CIMEShare *This);
} CIMEShareVtbl;

typedef struct _CIMEShare{
	const CIMEShareVtbl *lpVtbl;
} CIMEShare;

#endif //__cplusplus


#ifdef __cplusplus
extern "C"{
#endif
CIMEShare * IMECDECL PIMEShareCreate();
typedef CIMEShare * (IMECDECL FNPIMESHARECREATE)(void);
#ifdef __cplusplus
}
#endif




#ifdef OBSOLETE

typedef struct {
	UINT colorId;
	union {
		COLORREF	rgb;
		UINT		colorWin;
		UINT		colorSpec;
		UINT		colorFund;
	};
} IMECOLORSTY;

typedef struct {
	union {
		GRFSTY	grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};

	union {
		IMECOLORSTY colorstyText;
		struct {
			UINT	colorIdText;
			union {
				COLORREF	rgbText;
				UINT		colorWinText;
				UINT		colorSpecText;
				UINT		colorFundText;
			};
		};
	};

	union {
		IMECOLORSTY colorstyBack;
		struct {
			UINT	colorIdBack;
			union {
				COLORREF	rgbBack;
				UINT		colorWinBack;
				UINT		colorSpecBack;
				UINT		colorFundBack;
			};
		};
	};

	union {
		IMECOLORSTY colorstyUl;
		struct {
			UINT	colorIdUl;
			union {
				COLORREF	rgbUl;
				UINT		colorWinUl;
				UINT		colorSpecUl;
				UINT		colorFundUl;
			};
		};
	};
} IMESTYLE;

#ifdef __cplusplus
extern "C"{
#endif
//Functions

#if 0	// no need to redefine DllMain.
#ifndef PEGASUS
IMESHAREAPI BOOL	WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
#endif

IMESHAREAPI BOOL	IMECDECL FInitIMEShare();
IMESHAREAPI void	IMECDECL CustomizeIMEShare();
IMESHAREAPI void	IMECDECL EndIMEShare();

// Multilingual support
LID IMECDECL LidGetLid(void);
LID IMECDECL LidSetLid(LID NewValue);

//Refresh notify support
IMESHAREAPI BOOL	IMECDECL FRefreshStyle();

//substitution
IMESHAREAPI BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered);

//style handling                            
IMESHAREAPI const IMESTYLE * IMECDECL PIMEStyleFromAttr(const UINT attr);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleTextFromIMEStyle(const IMESTYLE * pimestyle);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleBackFromIMEStyle(const IMESTYLE * pimestyle);
#define PIMESTY(x) (PIMEStyleFromAttr(x))
#define PTEXTIMECOL(x) (PColorStyleTextFromIMEStyle(PIMESTY(x)))
#define PBACKIMECOL(x) (PColorStyleBackFromIMEStyle(PIMESTY(x)))
IMESHAREAPI BOOL	IMECDECL FBoldIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FItalicIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FUlIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI UINT	IMECDECL IdUlIMEStyle(const IMESTYLE *pimestyle);

//color handling
IMESHAREAPI BOOL	IMECDECL FWinIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FFundamentalIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FRGBIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialTextIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialWindowIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI COLORREF	IMECDECL RGBFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);

#ifdef IMESHARE_CPL
IMESHAREAPI UINT	IMECDECL IdSpecialFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdWinFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdFundamentalFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI GRFSTY	IMECDECL GrfStyIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FGetIMEStyleAttr(IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyleAttr(const IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEColorStyle(UINT attr, BOOL fTextCol, UINT id, DWORD col);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyle(const UINT attr, BOOL fBold, BOOL fItalic, BOOL fUl, UINT idUl);
IMESHAREAPI BOOL	IMECDECL FSaveIMEShareSetting(void);
#endif // IMESHARE_CPL
#ifdef __cplusplus
}
#endif
#endif // OBSOLETE


#endif	// __IMESHARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\imm.h ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

#ifndef IMM_WINVER
#define IMM_WINVER 0x040A
#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMC);
//#else
typedef DWORD     HIMC;
//#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMCC);
//#else
typedef DWORD     HIMCC;
//#endif

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

#define NULLIMC  ((HIMC)0)

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;
#endif

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
#define IMEMENUITEM_STRING_SIZE 80 

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

#endif /* IMM_WINVER >= 0x040A */

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);
#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(HWND, HIMC, DWORD);
#endif /* IMM_WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD, LPCANDIDATELIST, DWORD);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD, LPCANDIDATELIST, DWORD);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#if 0
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE
#endif
DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD, UINT);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD, UINT);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD, DWORD, DWORD);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(DWORD);
DWORD WINAPI ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* IMM_WINVER >= 0x040A */

// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F

// dwSystemInfoFlags bits

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000

// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW            0x0001
#define IMN_OPENSTATUSWINDOW             0x0002
#define IMN_CHANGECANDIDATE              0x0003
#define IMN_CLOSECANDIDATE               0x0004
#define IMN_OPENCANDIDATE                0x0005
#define IMN_SETCONVERSIONMODE            0x0006
#define IMN_SETSENTENCEMODE              0x0007
#define IMN_SETOPENSTATUS                0x0008
#define IMN_SETCANDIDATEPOS              0x0009
#define IMN_SETCOMPOSITIONFONT           0x000A
#define IMN_SETCOMPOSITIONWINDOW         0x000B
#define IMN_SETSTATUSWINDOWPOS           0x000C
#define IMN_GUIDELINE                    0x000D
#define IMN_PRIVATE                      0x000E

#if(IMM_WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYCHARPOSITION      0x0006
#define IMR_DOCUMENTFEED           0x0007
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

#if(IMM_WINVER >= 0x040A)
// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x00000001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x00000001
#define IGIMII_SMODE                    0x00000002
#define IGIMII_CONFIGURE                0x00000004
#define IGIMII_TOOLS                    0x00000008
#define IGIMII_HELP                     0x00000010
#define IGIMII_OTHER                    0x00000020
#define IGIMII_INPUTTOOLS               0x00000040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT
#endif /* IMM_WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\dbug32.h ===
//DBUG.DLL main header

#ifndef DBUG_H
#define DBUG_H
#define DllExport __declspec(dllexport)
#define DllImport __declspec(dllimport)

//USERDBUG is defined by users who want to use IMallocSpy
//but not the rest of the stuff in here.
#ifdef USERDBUG

#if defined(DEBUG) || defined(_DEBUG)
#ifdef __cplusplus
extern "C"
{
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
}
#else
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
#endif //_cplusplus
//Macros for Install/Remove IMallocSpy
#define INSTALLIMALLOCSPY() InstallIMallocSpy()
#define REMOVEIMALLOCSPY(f) RemoveIMallocSpy(f)
#define IMALLOCSPYREPORT()  IMallocSpyReport()
#else
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#endif //DEBUG

#else //USERDBUG

//
//This is stuff from dbugit.h that is here for compatibility
//with existing code.
//
#if defined(DEBUG) || defined(MEMCHECK) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_)

typedef struct _assertfile
{
	char *szFile;
	INT ifte;
} ASSERTFILE;

#if !defined(MACPORT)
#define	ASSERTDATA		static char _szFile[] = __FILE__; \
						static ASSERTFILE _asfile = {_szFile, -1};
#else
	#ifdef AssertData	// Mso's version of AssertData to work with its asserts.
		#define ASSERTDATA AssertData
	#else
		need to include msodebug.h before DBUG32.h
	#endif
#endif

#else	// DEBUG || MEMCHECK

#define	ASSERTDATA

#endif	// DEBUG || MEMCHECK, else


#if defined(DEBUG) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_)

#define FFromTag FALSE
//TODO this isn't used and references should be removed.
extern BOOL fInAssert;

#endif



//
//This is new stuff for dbug32.dll
//
#if !defined(PEGASUS) && !defined(MACPORT) && (defined(DEBUG) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_))
//macport change until dbug32 accessed
//we are also not doing this for WinCE right now
//#if defined(DEBUG) || defined(_DEBUG)	//orig code

//This is the buffer length used for building messages
#define MAXDEBUGSTRLEN (MAX_PATH + MAX_PATH)

#ifndef _RELEASE_ASSERTS_
//The following constants are used to specify and interpret
//packed values in the DWORD flags parameter passed to TraceMsg.
//Each of these is held in a 4-bit field in the DWORD.

//Subsystem field values
#define TRCSUBSYSNONE   0x0
#define TRCSUBSYSDISP   0x1
#define TRCSUBSYSWRAP   0x2
#define TRCSUBSYSEDIT   0x3
#define TRCSUBSYSTS     0x4
#define TRCSUBSYSTOM    0x5
#define TRCSUBSYSOLE    0x6
#define TRCSUBSYSBACK   0x7
#define TRCSUBSYSSEL    0x8
#define TRCSUBSYSHOST   0x9
#define TRCSUBSYSDTE    0xa
#define TRCSUBSYSUNDO   0xb
#define TRCSUBSYSRANG   0xc
#define TRCSUBSYSUTIL   0xd
#define TRCSUBSYSNOTM   0xe
#define TRCSUBSYSRTFR   0xf
#define TRCSUBSYSRTFW   0x10
#define TRCSUBSYSPRT    0x11
#define TRCSUBSYSFE     0x12
#define TRCSUBSYSFONT	0x13

//Severity field values
#define TRCSEVNONE      0x0
#define TRCSEVWARN      0x1
#define TRCSEVERR       0x2
#define TRCSEVASSERT    0x3
#define TRCSEVINFO      0x4
#define TRCSEVMEM       0x5

//Scope field values
#define TRCSCOPENONE    0x0
#define TRCSCOPEEXTERN  0x1
#define TRCSCOPEINTERN  0x2

//Data field values
#define TRCDATANONE     0x0
#define TRCDATAHRESULT  0x1
#define TRCDATASTRING   0x2
#define TRCDATAPARAM    0x3
#define TRCDATADEFAULT  0x4

//Debug option flags.  See the macros in this header for setting and testing
//these option flags.
#define OPTUSEDEFAULTS  0x00000001  //Use defaults from win.ini 
                                    //(used only with InitDebugServices).
#define OPTHEAPVALON    0x00000002  //Heap validation for all traces
#define OPTHEAPVALEXT   0x00000004  //Heap validation for external traces only
#define OPTLOGGINGON    0x00000008  //Logging of trace output
#define OPTVERBOSEON    0x00000010  //Subsys, Scope & PID/TID
#define OPTINFOON       0x00000020  //Informational messages
#define OPTTRACEON      0x00000040  //All function tracing on
#define OPTTRACEEXT     0x00000080  //Function tracing only for external functions
#define OPTMEMORYON     0x00000100  //Memory alloc/free tracing on
//The following options allow tracing to be enabled for one or more
//specific subsystems.  If OPTTRACEON is set, these will have no effect.
//if OPTTRACEEXT is set, they will enable tracing for all functions in
//the designated subsystem in addition to external functions.
//The SETOPT and ISOPTSET macros should be used for setting and checking
//these options.  INITDEBUGSERVICES can also be used.
#define OPTTRACEDISP    0x00001000  //Function tracing for Display subsystem
#define OPTTRACEWRAP    0x00002000  //Function tracing for Wrapper subsystem
#define OPTTRACEEDIT    0x00004000  //Function tracing for Edit subsystem
#define OPTTRACETS      0x00008000  //Function tracing for TextServices subsystem
#define OPTTRACETOM     0x00010000  //Function tracing for TOM subsystem
#define OPTTRACEOLE     0x00020000  //Function tracing for OLE support subsystem
#define OPTTRACEBACK    0x00040000  //Function tracing for Backing Store subsystem
#define OPTTRACESEL     0x00080000  //Function tracing for Selection subsystem
#define OPTTRACEHOST    0x00100000  //Function tracing for WinHost subsystem
#define OPTTRACEDTE     0x00200000  //Function tracing for DataXfer subsystem
#define OPTTRACEUNDO    0x00400000  //Function tracing for Muli-undo subsystem
#define OPTTRACERANG    0x00800000  //Function tracing for Range subsystem
#define OPTTRACEUTIL    0x01000000  //Function tracing for Utility subsystem
#define OPTTRACENOTM    0x02000000  //Function tracing for Notification Mgr subsystem
#define OPTTRACERTFR    0x04000000  //Function tracing for RTF reader subsystem
#define OPTTRACERTFW    0x08000000  //Function tracing for RTF writer subsystem
#define OPTTRACEPRT     0x10000000  //Function tracing for Printing subsystem
#define OPTTRACEFE      0x20000000  //Function tracing for Far East subsystem
#define OPTTRACEFONT    0x40000000  //Function tracing for Font Cache

//Union for handling tracing flags
//This union is used to decode the
//packed DWORD passed to TraceMsg.
typedef union
{
    struct
    {
        unsigned uData2         :4;
        unsigned uData1         :4;
        unsigned uScope         :4;
        unsigned uSeverity      :4;
        unsigned uSubSystem     :8;
        unsigned uUnused1       :4;
        unsigned uUnused2       :4;
    }       fields;
    DWORD   dw;
} TrcFlags;


//Exported classes and functions.
//Generally, these should not be used directly by the user.
//They should be used via the macros defined in this header.
//This helps to ensure that the parameter lists are well
//formed and keeps references to them from showing up in
//in non-debug builds.

//This class is used to implement the function Entry/Exit
//tracing. By declaring it on the stack at the beginning
//of a function, Entry and Exit messages are automatically
//generated by the constructor and destructor.
class DllExport CTrace
{
    public:
        CTrace(DWORD, DWORD, DWORD, LPSTR);
        ~CTrace();

    private:
        TrcFlags trcf;
        char szFileName[MAXDEBUGSTRLEN];
        char szFuncName[80];
};


DllImport DWORD dwDebugOptions;
DllImport void WINAPI SetLogging(BOOL);
DllImport void WINAPI Tracef(DWORD, LPSTR szFmt, ...);
DllImport void WINAPI TraceError(LPSTR sz, LONG sc);
extern "C"
{
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
DllImport void WINAPI TrackBlock(void *pMem);
}
#endif //!_RELEASE_ASSERTS_


typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
typedef BOOL (CALLBACK * PFNTRACEHOOK)(DWORD*, DWORD*, DWORD*, LPSTR, int*);
DllImport PFNTRACEHOOK pfnTrace;
DllImport PFNASSERTHOOK pfnAssert;
DllImport void WINAPI Dbug32AssertSzFn(LPSTR, LPSTR, int);
DllImport void WINAPI TraceMsg(DWORD, DWORD, DWORD, LPSTR, int);
DllImport void WINAPI InitDebugServices(DWORD, PFNASSERTHOOK, PFNTRACEHOOK);


//Assert based on boolean f.
#ifndef Assert
#define Assert(f)           AssertSz((f), NULL)
#endif

//Assert based on boolean f in debug, resolve to f in non-debug.
#ifndef SideAssert
#define SideAssert(f)       AssertSz((f), NULL)
#endif

//Assert based on boolean f and use string sz in assert message.
#ifndef AssertSz
#define AssertSz(f, sz)     (!(f) ? Dbug32AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETASSERTFN(pfn)      (pfnAssert = (pfn))    


#ifndef _RELEASE_ASSERTS_
//Assert only on debug builds, not on _RELEASE_ASSERTS_ builds
//This is for asserts that contain debug only code
#ifndef AssertNr
#define AssertNr(f)         AssertSz((f), NULL)
#endif

#ifndef AssertNrSz
#define AssertNrSz(f, sz)     (!(f) ? Dbug32AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif

//This is a utility macro for internal use.  The user should not need this.
#define MAKEFLAGS(ss, sv, sc, d1, d2) ((ss << 16) + (sv << 12) + (sc << 8)\
            + (d1 << 4) + (d2))

//The following macros provide access to the debug services in this dll.
//Assert macros pop a dialog.  Trace macros output to debug output and
//logfile if enabled.

//Macro for InitDebugServices
#define INITDEBUGSERVICES(f, pfnA, pfnT) InitDebugServices(f, pfnA, pfnT)

//Macros for Install/Remove IMallocSpy
#define INSTALLIMALLOCSPY() InstallIMallocSpy()
#define REMOVEIMALLOCSPY(f) RemoveIMallocSpy(f)
#define IMALLOCSPYREPORT()  IMallocSpyReport()

//Macro for TraceError
#define TRACEERRSZSC(sz, sc) TraceError(sz, sc)

//Warning based on GetLastError or default message if no last error.
#define TRACEWARN           TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)
//Error based on GetLastError or default message if no last error.
#define TRACEERROR          TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)

//Warning based on HRESULT hr
#define TRACEWARNHR(hr)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)


//Test for a failure HR && warn
#define TESTANDTRACEHR(hr)	if( hr < 0 ) { TRACEWARNHR(hr); }

//Error based on HRESULT hr
#define TRACEERRORHR(hr)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Warning using string sz
#define TRACEWARNSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEERRORSZ(sz)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEINFOSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Initiate tracing.  This declares an instance of the CTtrace class
//on the stack.  Subsystem (ss), Scope (sc), and the function name
//(sz) must be specifed.  ss and sc are specified using the macros
//defined in this header (i.e. - TRCSUBSYSTOM, TRCSCOPEEXTERN, etc.).
//sz can be a static string.
#define TRACEBEGIN(ss, sc, sz)  CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATANONE),\
                                    (DWORD)(sz), (DWORD)0, __FILE__)

//Same as TRACEBEGIN but it takes the additional param which is interpreted
//by TraceMsg as a Text Message request.
#define TRACEBEGINPARAM(ss, sc, sz, param) \
                                CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATAPARAM),\
                                    (DWORD)(sz), (DWORD)(param), __FILE__)


//Set Heap Validation for all traces to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", OPTHEAPVALEXT is ignored.
#define SETHEAPVAL(f)       ((f) ? (dwDebugOptions |= OPTHEAPVALON) :\
                                (dwDebugOptions &= ~OPTHEAPVALON))

//Set Heap Validation for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTHEAPVALON has not
//been set.
#define SETHEAPVALEXT(f)    ((f) ? (dwDebugOptions |= OPTHEAPVALEXT) :\
                            (dwDebugOptions &= ~OPTHEAPVALEXT))

//Set logging to on (f = TRUE) or off (f = FALSE)
#define SETLOGGING(f)       SetLogging(f)

//Set output of process & thread IDs to on (f = TRUE) or off (f = FALSE)
#define SETVERBOSE(f)       ((f) ? (dwDebugOptions |= OPTVERBOSEON) :\
                            (dwDebugOptions &= ~OPTVERBOSEON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETINFO(f)          ((f) ? (dwDebugOptions |= OPTINFOON) :\
                            (dwDebugOptions &= ~OPTINFOON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETMEMORY(f)          ((f) ? (dwDebugOptions |= OPTMEMORYON) :\
                            (dwDebugOptions &= ~OPTMEMORYON))

//Set tracing for all functions to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", external and subsystem level tracing
//has no effect since all function traces are enabled. If it is off,
//external and subsystem level tracing remain in whatever state they
//have been set to.
#define SETTRACING(f)       ((f) ? (dwDebugOptions |= OPTTRACEON) :\
                            (dwDebugOptions &= ~OPTTRACEON))

//Set tracing for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTTRACEON has not
//been set.
#define SETTRACEEXT(f)      ((f) ? (dwDebugOptions |= OPTTRACEEXT) :\
                            (dwDebugOptions &= ~OPTTRACEEXT))

//This macro turns all function tracing off.
#define SETALLTRACEOFF      (dwDebugOptions &= ~(OPTTRACEEXT | OPTTRACEON | 0xfffff000))

//This macro sets a given option or options (if they are or'ed together)
//to on (f = TRUE), or off (f = FALSE).  It cannot be used to set logging.
#define SETOPT(opt, f)      ((f) ? (dwDebugOptions |= (opt)) :\
                            (dwDebugOptions &= (~(opt))))
                             
//This macro determines the state of a given option.
#define ISOPTSET(opt)       ((opt) & dwDebugOptions)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETTRACEFN(pfn)      (pfnTrace = (pfn))    

//The following option tests are explicitly defined for convenience.
#define fHeapVal            (OPTHEAPVALON & dwDebugOptions)
#define fHeapValExt         (OPTHEAPVALEXT & dwDebugOptions)
#define fLogging            (OPTLOGGINGON & dwDebugOptions)
#define fVerbose            (OPTVERBOSEON & dwDebugOptions)
#define fInfo               (OPTINFOON & dwDebugOptions)
#define fMemory             (OPTMEMORYON & dwDebugOptions)
#define fTrace              (OPTTRACEON & dwDebugOptions)
#define fTraceExt           (OPTTRACEEXT & dwDebugOptions)


//IMallocSpy
class CImpIMallocSpy : public IMallocSpy
{
    private:
    ULONG m_cRef;

    public:
    ULONG m_cAlloc;

    CImpIMallocSpy (void);
    ~CImpIMallocSpy (void);

    //IUnknown members.
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppUnk);
    STDMETHODIMP_(ULONG)  AddRef (void);
    STDMETHODIMP_(ULONG)  Release (void);

    //IMallocSpy members
    STDMETHODIMP_(ULONG)  PreAlloc (ULONG cbRequest);
    STDMETHODIMP_(void *) PostAlloc (void * pActual);
    STDMETHODIMP_(void *) PreFree (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(void)   PostFree (BOOL fSpyed);
    STDMETHODIMP_(ULONG)  PreRealloc (void * pRequest,
                                      ULONG cbRequest,
                                      void ** ppNewRequest,
                                      BOOL fSpyed);
    STDMETHODIMP_(void *) PostRealloc (void * pActual, BOOL fSpyed);
    STDMETHODIMP_(void *) PreGetSize (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(ULONG)  PostGetSize (ULONG cbActual, BOOL fSpyed);
    STDMETHODIMP_(void *) PreDidAlloc (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(BOOL)   PostDidAlloc (void * pRequest, BOOL fSpyed,
                                        BOOL fActual);
    STDMETHODIMP_(void)   PreHeapMinimize (void);
    STDMETHODIMP_(void)   PostHeapMinimize (void);

	// memory tracing stuff
	public:
		void MemoryReport(void) { _memlist.Report(); }

	public:
		class CMemTagList
		{
		public:
			CMemTagList() : _dwAllocId(0), _pmemtHead(NULL) {}
			~CMemTagList();

			void Add(void *pv);		// add a memory alloc tag to the list for alloc @ pv
			void Remove(void *pv);	// remove the memory alloc tag for alloc @ pv
			void Report(void);		// report on un-deallocated memory blocks

		private:
			struct MemTag 
			{
				void *_pvLoc;
				DWORD _dwId;
				MemTag *_pmemtNext;

				// rewrite these if you want to use a different allocator to
				// maintain the memory allocation tag list
#if 0
				void *operator new(size_t stSize) 
					{ return ::operator new(stSize); }

				void operator delete(void *pv) { ::operator delete(pv); }
#endif
			};

			DWORD _dwAllocId;
			MemTag *_pmemtHead;
		} _memlist;
};

#else //_RELEASE_ASSERTS_
//Functions not used by release build with asserts
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define Tracef	;/##/
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#define TRACEERRSZSC(sz, sc)
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETHEAPVAL(f)
#define SETHEAPVALEXT(f)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETTRACEFN(pfn)

#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError


#endif //_RELEASE_ASSERTS_

#else //DEBUG,_RELEASE_ASSERTS_

#define Tracef	;/##/
#define INITDEBUGSERVICES(f, pfnA, pfnT)
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#define TRACEERRSZSC(sz, sc)
#ifndef Assert
#define Assert(f)
#endif
#ifndef SideAssert
#define SideAssert(f) (f)
#endif
#ifndef AssertSz
#define AssertSz(f, sz)
#endif
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETHEAPVAL(f)
#define SETHEAPVALEXT(f)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETASSERTFN(pfn)
#define SETTRACEFN(pfn)

// debugging for Mac, maybe someday we'll convert dbug32.dll to run on Macs, for now, use Mso debuggin stuff.
#ifdef MACPORTMsoTrace
#if defined(DEBUG) || defined(_DEBUG)	  // For Mac, MsoTraceSz writes to trace.txt, a file, and is slow
	#undef TRACEBEGIN					  // because of constant vol flushing, but if you need it turned on...
	#define TRACEBEGIN(ss, sc, sz) MsoTraceSz(sz)
#endif
#endif
#define Dbug32AssertSzFn(sz, __FILE__, __LINE__)  // MACPORT ADDED THIS - Dbug32AssertSzFn
#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError

#endif //DEBUG

#endif //USERDBUG


#endif //DBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\ourtypes.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	OURTYPES.H	-- Miscellaneous type declarations |
 *	
 *	Original Author: <nl>
 *		DGreen
 *
 *	History: <nl>
 *		02/19/98  KeithCu  Cleaned up
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OURTYPES_H_
#define _OURTYPES_H_

// WM_SYSKEYDOWN masks for lKeyData
#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000


#ifndef WINDOWS
#define WINDOWS
#endif


// Windows does not provide defines for WM_NCMOUSEFIRST and WM_NCMOUSELAST
// as is done for MOUSE and KEY events.

#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST WM_NCMBUTTONDBLCLK


#if defined(WIN32) && !defined(MACPORT)

#define CchSzAToSzW(_szA, _szW, _cbSzW)	\
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (_szA), -1, (_szW),	\
						(_cbSzW) / sizeof(WCHAR))

#define CchSzWToSzA(_szW, _szA, _cbSzA)	\
	WideCharToMultiByte(CP_ACP, 0, (_szW), -1, (_szA), (_cbSzA), NULL, NULL)

#define UsesMakeOLESTRX(_cchMax)	WCHAR szWT[_cchMax]
#define UsesMakeOLESTR				UsesMakeOLESTRX(MAX_PATH)
#define MakeOLESTR(_szA)	\
	(CchSzAToSzW((_szA), szWT, sizeof(szWT)) ? szWT : NULL)

#define UsesMakeANSIX(_cchMax)		CHAR szAT[_cchMax * 2]
#define UsesMakeANSI				UsesMakeANSIX(MAX_PATH)
#define MakeANSI(_szW)		\
	(CchSzWToSzA((_szW), szAT, sizeof(szAT)) ? szAT : NULL)

HRESULT HrSzAFromSzW(LPWSTR szW, LPSTR * psz);

#else	// !WIN32

#define UsesMakeOLESTRX(_cchMax)	/##/
#define UsesMakeOLESTR				/##/
#define MakeOLESTR(_szA)		(_szA)

#define UsesMakeANSIX(_cchMax)		/##/
#define UsesMakeANSI				/##/
#define MakeANSI(_szW)			(_szW)

#endif	// !WIN32

#endif //_OURTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define JPOS_UNDEFINED		0

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//ϖ
#define JPOS_MEISHI_ZAHEN		102		//ϖ
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//ό`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//ŗL
#define JPOS_SHAMEI		119		//Ж
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//㖼
#define JPOS_DAIMEISHI_NINSHOU		124		//l̑㖼
#define JPOS_DAIMEISHI_SHIJI		125		//w㖼
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//ȍs
#define JPOS_5DAN_BA		206		//΍s
#define JPOS_5DAN_MA		207		//܍s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//sϊi
#define JPOS_4DAN_HA		212		//͍sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//ϓ
#define JPOS_TOKUSHU_SAHENSURU		215		//ϓ
#define JPOS_TOKUSHU_SAHEN		216		//sϊi
#define JPOS_TOKUSHU_ZAHEN		217		//sϊi
#define JPOS_TOKUSHU_NAHEN		218		//ȍsϊi
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//낤
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//iȂj
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//悤
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//낤
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//悤
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//ϕ
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//Ă
#define JPOS_RENTAISHI		600		//A̎
#define JPOS_RENTAISHI_SHIJI		601		//wA̎
#define JPOS_SETSUZOKUSHI		650		//ڑ
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//ړ
#define JPOS_SETTOU_KAKU		701		//Pړ
#define JPOS_SETTOU_SAI		702		//Qړ
#define JPOS_SETTOU_FUKU		703		//Rړ
#define JPOS_SETTOU_MI		704		//Sړ
#define JPOS_SETTOU_DAISHOU		705		//Tړ
#define JPOS_SETTOU_KOUTEI		706		//Uړ
#define JPOS_SETTOU_CHOUTAN		707		//Vړ
#define JPOS_SETTOU_SHINKYU		708		//Wړ
#define JPOS_SETTOU_JINMEI		709		//lړ
#define JPOS_SETTOU_CHIMEI		710		//nړ
#define JPOS_SETTOU_SONOTA		711		//ŗLړ
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JPړ
#define JPOS_SETTOU_TEINEI_GO		714		//JQړ
#define JPOS_SETTOU_TEINEI_ON		715		//JRړ
#define JPOS_SETSUBI		800		//ڔ
#define JPOS_SETSUBI_TEKI		801		//Pڔ
#define JPOS_SETSUBI_SEI		802		//Qڔ
#define JPOS_SETSUBI_KA		803		//Rڔ
#define JPOS_SETSUBI_CHU		804		//Sڔ
#define JPOS_SETSUBI_FU		805		//Tڔ
#define JPOS_SETSUBI_RYU		806		//Uڔ
#define JPOS_SETSUBI_YOU		807		//Vڔ
#define JPOS_SETSUBI_KATA		808		//Wڔ
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//lڔ
#define JPOS_SETSUBI_CHIMEI		811		//nڔ
#define JPOS_SETSUBI_KUNI		812		//ڔ
#define JPOS_SETSUBI_KEN		813		//ڔ
#define JPOS_SETSUBI_GUN		814		//Sڔ
#define JPOS_SETSUBI_KU		815		//ڔ
#define JPOS_SETSUBI_SHI		816		//sڔ
#define JPOS_SETSUBI_MACHI		817		//Pڔ
#define JPOS_SETSUBI_CHOU		818		//Qڔ
#define JPOS_SETSUBI_MURA		819		//Pڔ
#define JPOS_SETSUBI_SON		820		//Qڔ
#define JPOS_SETSUBI_EKI		821		//wڔ
#define JPOS_SETSUBI_SONOTA		822		//ŗLڔ
#define JPOS_SETSUBI_SHAMEI		823		//Жڔ
#define JPOS_SETSUBI_SOSHIKI		824		//gDڔ
#define JPOS_SETSUBI_KENCHIKU		825		//zڔ
#define JPOS_RENYOU_SETSUBI		826		//Apڔ
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//ԏ
#define JPOS_SETSUBI_JIKANPLUS		830		//ԏ{
#define JPOS_SETSUBI_TEINEI		831		//Jڔ
#define JPOS_SETSUBI_SAN		832		//JPڔ
#define JPOS_SETSUBI_KUN		833		//JQڔ
#define JPOS_SETSUBI_SAMA		834		//JRڔ
#define JPOS_SETSUBI_DONO		835		//JSڔ
#define JPOS_SETSUBI_FUKUSU		836		//ڔ
#define JPOS_SETSUBI_TACHI		837		//Pڔ
#define JPOS_SETSUBI_RA		838		//Qڔ
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//Ɨ
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//Ǔ_
#define JPOS_KANJI		909		//͕s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1996, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000007FL)	// Mask out RO bits
#define REO_OWNERDRAWSELECT	(0x00000040L)	// Owner draws selected object
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\zmouse.h ===
/******************************************************************************\
*       ZMOUSE.H - Include file for MSDELTA Zoom mouse DLL. 
*
*       AUTHOR - Paul Henderson, July 1995
*                Lora McCambridge January 1996
*       REVISIONS - 
*        Lora McCambridge April 1996 - removing WM_MOUSEWHEEL, this
*             message will only be available via the OS.  Applications
*             must now register the message MSH_MOUSEWHEEL, and
*             use that message for messages from MSWHEEL.  
*       LKM May 1996 - Added add'l #defines for class and title of the wheel
*                      module window to reflect the MSH_ style.
*                    - Added #defines for WHEEL SUPPORT and Scroll Lines
*                    - Added inline function HwndMsWheel, apps can use
*                      this function to retrieve the handle to mswheel,
*                      get the message ID's for the registered messages,
*                      the flag for 3d support, and the value for scroll
*                      lines. Please in function at end of file.
*
*       Copyright (C) 1995, 1996 Microsoft Corporation.
*       All rights reserved. 
\******************************************************************************/


/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
   // wParam = zDelta expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one detent


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS 
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	 determining 3D support active
	 determining # of Scroll Lines
***************************************************************************/

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  "MouseZ"           // wheel window class  
#define MOUSEZ_TITLE      "Magellan MSWHEEL" // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines below to
// get the message number that can be sent to the MSWHEEL window to
// query if wheel support is active (MSH_WHEELSUPPORT), and the message
// number to query the number of scroll lines (MSH_SCROLLLINES).  
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is currently not available.

#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                // to query for wheel support
// MSH_WHEELSUPPORT
//    wParam - not used 
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise

                                
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"

// MSH_SCROLL_LINES
//    wParam - not used 
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL  
#define WHEEL_PAGESCROLL  (UINT_MAX)    // signifies to scroll a page, to
					// be defined in updated winuser.h
					// in SDK release for NT4.0
#endif 


// NB!! The remainder of the original header file has been deleted since it
// doesn't compile.  RichEdit doesn't need the remainder in any event.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc30\win2mac.h ===
//*******************************************************************
//
//
//		win2mac.h
//
//		Compatability transforms
//
//
//
//*******************************************************************
#ifndef _WIN2MAC_H_
#define _WIN2MAC_H_


#ifdef MACPORT
#define USE_UNICODE_WRAPPER


#if defined(UNICODE)

#include "ourmac.h"
#include "msostd.h"
#include "msostr.h"
#include "msointl.h"
#include <winnls.h>
#include <WINUSER.H>
#include <tchar.h>



//----------------------------------------------------------------------------
// We have to re-define some of the clipboard formats
#ifdef CF_TEXT
#undef CF_TEXT
#endif
#define CF_TEXT cfText

#ifdef CF_UNICODETEXT
#undef CF_UNICODETEXT
#endif
#define CF_UNICODETEXT 'UNIC'

//----------------------------------------------------------------------------
// These are from WINERROR.H which is no longer being included
// now that we compile for native MACOLE
#define ERROR_INVALID_FLAGS              1004L
#define CO_E_RELEASED                    0x800401FFL
#define FACILITY_WIN32 0x0007
#define HRESULT_FROM_WIN32(x) \
     (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )

//----------------------------------------------------------------------------
// maximum unsigned 16 bit value -  from MSDEV\limits.h 
#define _UI16_MAX	  0xffffui16	

//----------------------------------------------------------------------------
// 
// Misc functions/macros
// 
//----------------------------------------------------------------------------
EXTERN_C int __pascal GetLocaleInfoA(LCID, LCTYPE, char FAR*, int);
LRESULT CALLBACK MacRichEditWndProc(HWND, UINT, WPARAM, LPARAM);
UINT MacSimulateKey (UINT& msg, WPARAM& wParam);
UINT MacSimulateMouseButtons (UINT& msg, WPARAM& wParam);

#define ActivateKeyboardLayout(a,b)
#define CreateFileW	CreateFileA	
#define GetHGlobalFromStream(a, b)	GetHGlobalFromStream(a, (Handle *)b)
#define GetProfileIntA(a,b,c)	c
#define OleDuplicateData(a,b,c) OleDuplicateData((Handle)a, b, c)
#define ReleaseStgMedium(a) ReleaseStgMedium((DUAL_STGMEDIUM*)a)

//----------------------------------------------------------------------------
#ifdef  ExtTextOutW
#undef  ExtTextOutW
#endif 
#define ExtTextOutW			MsoExtTextOutW
MSOAPI_(BOOL) MsoTextOutW(HDC, int, int, LPCWSTR, int);

//----------------------------------------------------------------------------
#ifdef  TextOutW
#undef  TextOutW
#endif 
#define TextOutW			MsoTextOutW
MSOAPI_(BOOL) MsoExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);

//----------------------------------------------------------------------------
#ifdef  GetTextExtentPointW
#undef  GetTextExtentPointW
#endif 
#define GetTextExtentPointW MsoGetTextExtentPointW
MSOAPI_(BOOL) MsoGetTextExtentPointW(HDC, LPCWSTR, int, LPSIZE);

//----------------------------------------------------------------------------
#ifdef  MultiByteToWideChar
#undef  MultiByteToWideChar
#endif 
#define MultiByteToWideChar	MsoMultiByteToWideChar
		
//----------------------------------------------------------------------------
#ifdef  WideCharToMultiByte
#undef  WideCharToMultiByte
#endif 
#define WideCharToMultiByte	MsoWideCharToMultiByte


//----------------------------------------------------------------------------
//
//	Mac wrappers  
//
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#ifdef  CoTaskMemAlloc
#undef  CoTaskMemAlloc
#endif
#define CoTaskMemAlloc		MacCoTaskMemAlloc
STDAPI_(LPVOID) MacCoTaskMemAlloc(
			ULONG cb
			);

//----------------------------------------------------------------------------
#ifdef  CoTaskMemRealloc
#undef  CoTaskMemRealloc
#endif
#define CoTaskMemRealloc	MacCoTaskMemRealloc
STDAPI_(LPVOID) MacCoTaskMemRealloc(
			LPVOID pv, 
			ULONG cb
			);

//----------------------------------------------------------------------------
#ifdef  CoTaskMemFree
#undef  CoTaskMemFree
#endif
#define CoTaskMemFree		MacCoTaskMemFree
STDAPI_(void)   MacCoTaskMemFree(
			LPVOID pv
			);

//----------------------------------------------------------------------------
#ifdef  CLSIDFromProgID
#undef  CLSIDFromProgID
#endif 
#define CLSIDFromProgID		MacCLSIDFromProgID
STDAPI  MacCLSIDFromProgID(
			LPCWSTR lpszProgID, 
			LPCLSID lpclsid
			);

//----------------------------------------------------------------------------
#ifdef  DoDragDrop
#undef  DoDragDrop
#endif 
#define DoDragDrop			MacDoDragDrop 
STDAPI  MacDoDragDrop(
			LPDATAOBJECT	pDataObj,
            LPDROPSOURCE	pDropSource,
            DWORD			dwOKEffects,
            LPDWORD         pdwEffect
			);

//----------------------------------------------------------------------------
#ifdef  GetCurrentObject
#undef  GetCurrentObject
#endif 
#define GetCurrentObject			MacGetCurrentObject 
HGDIOBJ WINAPI MacGetCurrentObject(HDC	hdc,  
                                   UINT uObjectType); 
 
//----------------------------------------------------------------------------
#ifdef  GetDoubleClickTime
#undef  GetDoubleClickTime
#endif
#define GetDoubleClickTime	MacGetDoubleClickTime;
UINT MacGetDoubleClickTime();
    
//----------------------------------------------------------------------------
#ifdef  GetMetaFileBitsEx
#undef  GetMetaFileBitsEx
#endif
#define GetMetaFileBitsEx	MacGetMetaFileBitsEx
UINT WINAPI MacGetMetaFileBitsEx(
			HMETAFILE  hmf,    
			UINT  nSize,    
			LPVOID  lpvData   
			);

//----------------------------------------------------------------------------
#ifdef  IsValidCodePage
#undef  IsValidCodePage
#endif 
#define IsValidCodePage		MacIsValidCodePage
WINBASEAPI BOOL WINAPI MacIsValidCodePage(
			UINT  CodePage
			);

//----------------------------------------------------------------------------
#ifdef  OleDraw 
#undef  OleDraw 
#endif 
#define OleDraw				MacOleDraw
STDAPI  MacOleDraw(
			IUnknown *	pUnk,
			DWORD		dwAspect, 
			HDC			hdcDraw, 
			LPCRECT		lprcBounds
			);

//----------------------------------------------------------------------------
#ifdef  ProgIDFromCLSID
#undef  ProgIDFromCLSID
#endif 
#define ProgIDFromCLSID		MacProgIDFromCLSID
STDAPI  MacProgIDFromCLSID(
			REFCLSID clsid, 
			LPWSTR FAR* lplpszProgID
			);

//----------------------------------------------------------------------------
#ifdef  RegisterDragDrop
#undef  RegisterDragDrop
#endif 
#define RegisterDragDrop	MacRegisterDragDrop
STDAPI  MacRegisterDragDrop(
			HWND			hwnd, 
            LPDROPTARGET	pDropTarget
			);

//----------------------------------------------------------------------------
#ifdef  RevokeDragDrop
#undef  RevokeDragDrop
#endif 
#define RevokeDragDrop		MacRevokeDragDrop
STDAPI  MacRevokeDragDrop(
			HWND hwnd
			);

//----------------------------------------------------------------------------
#ifdef  SelectPalette 
#undef  SelectPalette 
#endif 
#define SelectPalette		MacSelectPalette
HPALETTE WINAPI MacSelectPalette(
			HDC,
			HPALETTE,
			BOOL
			);

//----------------------------------------------------------------------------
#ifdef  SetCursor 
#undef  SetCursor
#endif
// note we have not named this MacSetCursor 
// since this function already exists in WLM
#define SetCursor			MacportSetCursor
HCURSOR MacportSetCursor(
			HCURSOR  hCursor 	
			);

//----------------------------------------------------------------------------
#ifdef  SetMetaFileBitsEx
#undef  SetMetaFileBitsEx
#endif
#define SetMetaFileBitsEx	MacSetMetaFileBitsEx
HMETAFILE WINAPI MacSetMetaFileBitsEx(
			UINT  nSize,
			CONST BYTE *  lpData 
			);

//----------------------------------------------------------------------------
#ifdef  SysAllocStringLen
#undef  SysAllocStringLen 
#endif 
#define SysAllocStringLen	MacSysAllocStringLen
STDAPI_(BSTR) MacSysAllocStringLen(
			LPCWSTR, 
			UINT
			);

//----------------------------------------------------------------------------
#ifdef  WORDSWAPLONG
#undef  WORDSWAPLONG      
#endif 
#define WORDSWAPLONG		MacWordSwapLong
ULONG	MacWordSwapLong( 
			ULONG ul
			);

#endif //UNICODE

#endif //MACPORT

#endif // _WIN2MAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusbase.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Base
*
* Abstract:
*
*   Represents the base class for GDIPlus memory allocation. 
*
* Revision History:
*
*   04/27/2000 gillesk
*       
*
\**************************************************************************/

#ifndef _GDIPLUSBASE_H
#define _GDIPLUSBASE_H

class GdiplusBase
{
public:
    void (operator delete)(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new)(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
    void (operator delete[])(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new[])(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusbrush.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Brush API related declarations
*
* Revision History:
*
*   4/26/2000 ericvan
*       Update header files.
*
*   12/09/1998 davidx
*       Flesh out Brush interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSBRUSH_H
#define _GDIPLUSBRUSH_H

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class GraphicsPath;

class Brush : public GdiplusBase
{
public:
    friend class Pen;
    friend class Graphics;

    virtual ~Brush()
    {
        DllExports::GdipDeleteBrush(nativeBrush);
    }

    virtual Brush* Clone() const
    {
        GpBrush *brush = NULL;

        SetStatus(DllExports::GdipCloneBrush(nativeBrush, &brush));

        Brush *newBrush = new Brush(brush, lastResult);
        
        if (newBrush == NULL) 
        {
            DllExports::GdipDeleteBrush(brush);
        }

        return newBrush;
    }

    BrushType GetType() const
    {
        BrushType type = static_cast<BrushType>(-1);

        SetStatus(DllExports::GdipGetBrushType(nativeBrush, &type));

        return type;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:

    Brush()
    {
        SetStatus(NotImplemented);
    }

    Brush(const Brush& brush)
    {
        brush;
        SetStatus(NotImplemented);
    }

    Brush& operator=(const Brush& brush)
    {
        brush;
        SetStatus(NotImplemented);
        return *this;
    }

    Brush(GpBrush* nativeBrush, Status status)
    {
        lastResult = status;
        SetNativeBrush(nativeBrush);
    }

    VOID SetNativeBrush(GpBrush* nativeBrush)
    {
        this->nativeBrush = nativeBrush;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpBrush* nativeBrush;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Represent solid fill brush object
//--------------------------------------------------------------------------

class SolidBrush : public Brush
{
public:
    friend class Pen;

    SolidBrush(IN const Color& color)
    {
        GpSolidFill *brush = NULL;

        lastResult = DllExports::GdipCreateSolidFill(color.GetValue(), &brush);

        SetNativeBrush(brush);
    }

    Status GetColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetSolidFillColor((GpSolidFill*)nativeBrush,
                                                    &argb));

        *color = Color(argb);

        return lastResult;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetSolidFillColor((GpSolidFill*)nativeBrush, 
                                                           color.GetValue()));
    }

protected:

    SolidBrush()
    {
    }
};

class TextureBrush : public Brush
{
public:
    friend class Pen;

    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode = WrapModeTile)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture(
                                                  image->nativeImage,
                                                  wrapMode, &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode,
                 IN const RectF &dstRect)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstRect.X, 
                                                   dstRect.Y, 
                                                   dstRect.Width, 
                                                   dstRect.Height,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.

    TextureBrush(IN Image *image, 
                 IN RectF &dstRect,
                 IN ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    
    #ifdef DCR_USE_NEW_145138
    TextureBrush(IN Image *image, 
                 IN Rect &dstRect,
                 IN ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            (REAL)dstRect.X, 
            (REAL)dstRect.Y, 
            (REAL)dstRect.Width, 
            (REAL)dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    #endif

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.

    TextureBrush(
        IN Image* image,
        IN WrapMode wrapMode,
        
        #ifdef DCR_USE_NEW_145138       
        const IN Rect &dstRect
        #else
        IN Rect &dstRect
        #endif
    )
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstRect.X, 
                                                    dstRect.Y, 
                                                    dstRect.Width, 
                                                    dstRect.Height,
                                                    &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN REAL dstX, 
                 IN REAL dstY, 
                 IN REAL dstWidth, 
                 IN REAL dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstX, 
                                                   dstY, 
                                                   dstWidth, 
                                                   dstHeight,
                                                   &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN INT dstX, 
                 IN INT dstY, 
                 IN INT dstWidth, 
                 IN INT dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstX, 
                                                    dstY, 
                                                    dstWidth, 
                                                    dstHeight,
                                                    &texture);

        SetNativeBrush(texture);
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetTextureTransform((GpTexture*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyTextureTransform((GpTexture*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateTextureTransform((GpTexture*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleTextureTransform((GpTexture*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateTextureTransform((GpTexture*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTextureWrapMode((GpTexture*)nativeBrush, 
                                                            wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTextureWrapMode((GpTexture*)nativeBrush, 
                                                     &wrapMode));
        return wrapMode;
    }

    // Get texture brush attributes

    Image *GetImage() const
    {
        GpImage *image;

        SetStatus(DllExports::GdipGetTextureImage((GpTexture *)nativeBrush,
                                                  &image));

        Image *retimage = new Image(image, lastResult);

        if (retimage == NULL) 
        {
            DllExports::GdipDisposeImage(image);
        }

        return retimage;
    }

protected:

    TextureBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Represent line gradient brush object
//--------------------------------------------------------------------------

class LinearGradientBrush : public Brush
{
public:
    friend class Pen;

    LinearGradientBrush(IN const PointF& point1,
                        IN const PointF& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrush(&point1,
                                                     &point2,
                                                     color1.GetValue(),
                                                     color2.GetValue(),
                                                     WrapModeTile,
                                                     &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Point& point1,
                        IN const Point& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushI(&point1,
                                                      &point2,
                                                      color1.GetValue(),
                                                      color2.GetValue(),
                                                      WrapModeTile,
                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRect(&rect,
                                                             color1.GetValue(),
                                                             color2.GetValue(),
                                                             mode,
                                                             WrapModeTile,
                                                             &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectI(&rect,
                                                              color1.GetValue(),
                                                              color2.GetValue(),
                                                              mode,
                                                              WrapModeTile,
                                                              &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngle(&rect,
                                                                      color1.GetValue(),
                                                                      color2.GetValue(),
                                                                      angle,
                                                                      isAngleScalable,
                                                                      WrapModeTile,
                                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngleI(&rect,
                                                                       color1.GetValue(),
                                                                       color2.GetValue(),
                                                                       angle,
                                                                       isAngleScalable,
                                                                       WrapModeTile,
                                                                       &brush);

        SetNativeBrush(brush);
    }

    // Get/set point attributes

    Status SetLinearPoints(IN const PointF& point1, 
                           IN const PointF& point2)
    {
        return SetStatus(DllExports::GdipSetLinePoints((GpLineGradient*)nativeBrush,
                                                       &point1, &point2));
    }

    Status GetLinearPoints(OUT PointF* points) const 
    {
        return SetStatus(DllExports::GdipGetLinePoints((GpLineGradient*) nativeBrush,
                                                       points));
    }

    Status SetLinearPoints(IN const Point& point1, 
                           IN const Point& point2)
    {
        return SetStatus(DllExports::GdipSetLinePointsI((GpLineGradient*)nativeBrush,
                                                        &point1, &point2));
    }

    Status GetLinearPoints(OUT Point* points) const
    {
        return SetStatus(DllExports::GdipGetLinePointsI((GpLineGradient*) nativeBrush,
                                                        points));
    }
    // Get/set color attributes

    Status SetLinearColors(IN const Color& color1, 
                           IN const Color& color2)
    {
        return SetStatus(DllExports::GdipSetLineColors((GpLineGradient*)nativeBrush,
                                                       color1.GetValue(),
                                                       color2.GetValue()));
    }

    Status GetLinearColors(OUT Color* colors) const
    {
        ARGB argb[2];

        if (colors == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        SetStatus(DllExports::GdipGetLineColors((GpLineGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
        }

        return lastResult;
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRect((GpLineGradient*)nativeBrush, rect));
    }

    // integer version
    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRectI((GpLineGradient*)nativeBrush, rect));
    }

    // Gamma correction in interporlation.

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    useGammaCorrection));
    }
    
    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLineBlendCount((GpLineGradient*)
                                                    nativeBrush,
                                                    &count));

        return count;
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions,
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetLineBlend((GpLineGradient*)
                                                      nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    Status GetBlend(OUT REAL* blendFactors, 
                    OUT REAL* blendPositions, 
                    IN INT count) const 
    {
        return SetStatus(DllExports::GdipGetLineBlend((GpLineGradient*)nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    INT GetInterpolationColorCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLinePresetBlendCount((GpLineGradient*)
                                                          nativeBrush,
                                                          &count));

        return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);
         
        ARGB *argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetLinePresetBlend(
                                                                        (GpLineGradient*) nativeBrush,
                                                                        argbs,
                                                                        blendPositions,
                                                                        count));
            delete [] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors, 
                                  OUT REAL* blendPositions, 
                                  IN INT count) const 
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);

        ARGB* argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetLinePresetBlend((GpLineGradient*)nativeBrush,
                                                                     argbs,
                                                                     blendPositions,
                                                                     count));
        if (status == Ok) 
        {
            for (INT i = 0; i < count; i++)
            { 
                presetColors[i] = Color(argbs[i]);
            }
        }
        
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetLineSigmaBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    #ifdef DCR_USE_NEW_145135
    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    #else
    Status SetBlendTrianglarShape(IN REAL focus,
                                  IN REAL scale = 1.0)
    #endif                              
    {
        return SetStatus(DllExports::GdipSetLineLinearBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetLineTransform((GpLineGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyLineTransform((GpLineGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateLineTransform((GpLineGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleLineTransform((GpLineGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateLineTransform((GpLineGradient*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetLineWrapMode((GpLineGradient*)nativeBrush, 
                                                         wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetLineWrapMode((GpLineGradient*)
                                                  nativeBrush, 
                                                  &wrapMode));

        return wrapMode;
    }

protected:

    LinearGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// PathGradientBrush object is defined
// in gdipluspath.h.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Represent hatch brush object
//--------------------------------------------------------------------------

class HatchBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    HatchBrush(IN HatchStyle hatchStyle, 
               IN const Color& foreColor,
               IN const Color& backColor = Color())
    {
        GpHatch *brush = NULL;

        lastResult = DllExports::GdipCreateHatchBrush(hatchStyle, 
                                                      foreColor.GetValue(), 
                                                      backColor.GetValue(),
                                                      &brush);
        SetNativeBrush(brush);
    }

    HatchStyle GetHatchStyle() const
    {
        HatchStyle hatchStyle;

        SetStatus(DllExports::GdipGetHatchStyle((GpHatch*)nativeBrush, 
                                                &hatchStyle));

        return hatchStyle;
    }
    
    Status GetForegroundColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetHatchForegroundColor(
                                                        (GpHatch*)nativeBrush, 
                                                        &argb));

        color->SetValue(argb);

        return status;
    }

    Status GetBackgroundColor(OUT Color *color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        Status status = SetStatus(DllExports::GdipGetHatchBackgroundColor(
                                                        (GpHatch*)nativeBrush,
                                                        &argb));

        color->SetValue(argb);
        
        return status;
    }

protected:

    HatchBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplus.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUS_H
#define _GDIPLUS_H

struct IDirectDrawSurface7;

namespace Gdiplus
{
    namespace DllExports
    {
        #include "GdiplusMem.h"
    };

    #include "GdiplusBase.h"

    // The following headers are used internally as well
    #include "GdiplusEnums.h"
    #include "GdiplusTypes.h"
    #include "GdiplusPixelFormats.h"
    #include "GdiplusColor.h"
    #include "GdiplusMetaHeader.h"
    #include "GdiplusImaging.h"
    #include "imaging.h"
    #include "GdiplusColorMatrix.h"

    // The rest of these are used only by the application

    #include "GdiplusGpStubs.h"
    #include "GdiplusHeaders.h"

    namespace DllExports
    {
        #include "GdiplusFlat.h"
    };


    #include "GdiplusImageAttributes.h"
    #include "GdiplusMatrix.h"
    #include "GdiplusBrush.h"
    #include "GdiplusPen.h"
    #include "GdiplusStringFormat.h"
    #include "GdiplusPath.h"
    #include "GdiplusLineCaps.h"
    #include "GdiplusMetafile.h"
    #include "GdiplusGraphics.h"
    #include "GdiplusCachedBitmap.h"
    #include "GdiplusRegion.h"
    #include "GdiplusFontCollection.h"
    #include "GdiplusFontFamily.h"
    #include "GdiplusFont.h"
    #include "GdiplusBitmap.h"
    #include "GdiplusImageCodec.h"

}; // namespace Gdiplus

#endif // !_GDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluscachedbitmap.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap class definition
*
* Abstract:
*
*   CachedBitmap is a representation of an accelerated drawing
*   that has restrictions on what operations are allowed in order
*   to accelerate the drawing to the destination.
*
*
 Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GDIPLUSCACHEDBITMAP_H
#define _GDIPLUSCACHEDBITMAP_H

/**************************************************************************
*
* Class Name:
*
*   CachedBitmap
*
* Abstract:
*
*   An object to store a bitmap prepared for rendering on a particular
*   Graphics object. The memory storage for the CachedBitmap is opaque
*   to the other Engine code, so the only operations supported are
*   initializing the data (with a bitmap) and using the graphics to
*   draw it on the screen with an integer offset.
*
*   Look for the class definition in GdiplusHeaders.h
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/
inline 
CachedBitmap::CachedBitmap(
    IN Bitmap *bitmap, 
    IN Graphics *graphics)
{
    nativeCachedBitmap = NULL;    

    lastResult = DllExports::GdipCreateCachedBitmap(
        (GpBitmap *)bitmap->nativeImage,
        graphics->nativeGraphics,
        &nativeCachedBitmap
    );
}

inline 
CachedBitmap::~CachedBitmap()
{
    DllExports::GdipDeleteCachedBitmap(nativeCachedBitmap);
}

inline Status 
CachedBitmap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusbitmap.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Bitmap.hpp
*
* Abstract:
*
*   Bitmap related declarations
*
* Revision History:
*
*   4/26/2000 ericvan
*       Update header files.
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSBITMAP_H
#define _GDIPLUSBITMAP_H

// NOTE:
//  Our current choice for the public API is to use constructors
//  instead of static load functions to create image objects.
//
//  I've kept the static load functions here for now so that
//  existing test programs are not broken. But they should
//  eventually be taken out.

#ifndef DCR_USE_NEW_140782

inline 
Image::Image(
    IN const WCHAR* filename
    )
{
    nativeImage = NULL;
    lastResult = DllExports::GdipLoadImageFromFile(filename, &nativeImage);
}

inline 
Image::Image(
    IN IStream* stream
    )
{
    nativeImage = NULL;
    lastResult = DllExports::GdipLoadImageFromStream(stream, &nativeImage);
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename
    )
{
    return new Image(filename);
}

inline Image*
Image::FromStream(
    IN IStream* stream
    )
{
    return new Image(stream);
}

#else

inline 
Image::Image(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromFileICM(
            filename, 
            &nativeImage
        );
    }
    else
    {      
        lastResult = DllExports::GdipLoadImageFromFile(
            filename, 
            &nativeImage
        );
    }
}

inline 
Image::Image(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromStreamICM(
            stream, 
            &nativeImage
        );
    }
    else
    {
        lastResult = DllExports::GdipLoadImageFromStream(
            stream, 
            &nativeImage
        );
    }
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Image*
Image::FromStream(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        stream,
        useEmbeddedColorManagement
    );
}

#endif

inline 
Image::~Image()
{
    DllExports::GdipDisposeImage(nativeImage);
}

inline Image* 
Image::Clone() 
{
    GpImage *cloneimage = NULL;

    SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

    return new Image(cloneimage, lastResult);
}

// Encorder Parameter

inline UINT
Image::GetEncoderParameterListSize(
    IN const CLSID* clsidEncoder
    ) 
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetEncoderParameterListSize(nativeImage,
                                                          clsidEncoder,
                                                          &size));
    return size;
}

inline Status
Image::GetEncoderParameterList(
    IN const CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* buffer
    )
{
    return SetStatus(DllExports::GdipGetEncoderParameterList(nativeImage,
                                                             clsidEncoder,
                                                             size,
                                                             buffer));
}

// Save images

inline Status
Image::Save(
    IN const WCHAR* filename,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToFile(nativeImage,
                                                     filename,
                                                     clsidEncoder,
                                                     encoderParams));
}

inline Status
Image::Save(
    IN IStream* stream,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToStream(nativeImage,
                                                       stream,
                                                       clsidEncoder,
                                                       encoderParams));
}

inline Status
Image::SaveAdd(
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveAdd(nativeImage,
                                             encoderParams));
}

inline Status
Image::SaveAdd(
    IN Image* newImage,
    IN const EncoderParameters *encoderParams
    )
{
    if ( newImage == NULL )
    {
        return SetStatus(InvalidParameter);
    }

    return SetStatus(DllExports::GdipSaveAddImage(nativeImage,
                                                  newImage->nativeImage,
                                                  encoderParams));
}

// Get size and type information
inline ImageType 
Image::GetType() const
{
    ImageType type = ImageTypeUnknown;

    SetStatus(DllExports::GdipGetImageType(nativeImage, &type));

    return type;
}

inline Status 
Image::GetPhysicalDimension(
    OUT SizeF* size
    ) 
{
    if (size == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    REAL width, height;
    Status status;

    status = SetStatus(DllExports::GdipGetImageDimension(nativeImage,
                                                         &width, &height));

    size->Width  = width;
    size->Height = height;

    return status;
}

inline Status 
Image::GetBounds(
    OUT RectF *srcRect, 
    OUT Unit *srcUnit
    )
{
    return SetStatus(DllExports::GdipGetImageBounds(nativeImage,
                                                    srcRect, srcUnit));
}

inline UINT 
Image::GetWidth()
{
    UINT width = 0;

    SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

    return width;
}

inline UINT 
Image::GetHeight()
{
    UINT height = 0;

    SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

    return height;
}

inline REAL 
Image::GetHorizontalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageHorizontalResolution(nativeImage, &resolution));

    return resolution;
}

inline REAL 
Image::GetVerticalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageVerticalResolution(nativeImage, &resolution));

    return resolution;
}

inline UINT 
Image::GetFlags()
{
    UINT flags = 0;

    SetStatus(DllExports::GdipGetImageFlags(nativeImage, &flags));

    return flags;
}

inline Status 
Image::GetRawFormat(OUT GUID *format)
{
    return SetStatus(DllExports::GdipGetImageRawFormat(nativeImage, format));
}

inline PixelFormat 
Image::GetPixelFormat()
{
    PixelFormat format;

    SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

    return format;
}

inline INT 
Image::GetPaletteSize()
{
    INT size = 0;
    
    SetStatus(DllExports::GdipGetImagePaletteSize(nativeImage, &size));
    
    return size;
}

inline Status 
Image::GetPalette(
    OUT ColorPalette *palette,
    IN INT size
)
{
    return SetStatus(DllExports::GdipGetImagePalette(nativeImage, palette, size));
}

inline Status 
Image::SetPalette(
    IN const ColorPalette *palette
    )
{
    return SetStatus(DllExports::GdipSetImagePalette(nativeImage, palette));
}

// Thumbnail support

inline Image* 
Image::GetThumbnailImage(
    IN UINT thumbWidth,
    IN UINT thumbHeight,
    IN GetThumbnailImageAbort callback,
    IN VOID* callbackData
    )
{
    GpImage *thumbimage = NULL;

    SetStatus(DllExports::GdipGetImageThumbnail(nativeImage,
                                                thumbWidth, thumbHeight,
                                                &thumbimage,
                                                callback, callbackData));

    Image *newImage = new Image(thumbimage, lastResult);

    if (newImage == NULL) 
    {
        DllExports::GdipDisposeImage(thumbimage);
    }

    return newImage;
}

// Multi-frame support
inline UINT 
Image::GetFrameDimensionsCount()
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameDimensionsCount(nativeImage,
                                                                  &count));

    return count;
}

inline Status 
Image::GetFrameDimensionsList(
    OUT GUID* dimensionIDs, 
    IN UINT count
    )
{
    return SetStatus(DllExports::GdipImageGetFrameDimensionsList(nativeImage,
                                                                 dimensionIDs,
                                                                 count));
}

inline UINT 
Image::GetFrameCount(
    IN const GUID* dimensionID
    )
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameCount(nativeImage,
                                                        dimensionID,
                                                        &count));
    return count;
}

inline Status 
Image::SelectActiveFrame(
    IN const GUID *dimensionID, 
    IN UINT frameIndex
    )
{
    return SetStatus(DllExports::GdipImageSelectActiveFrame(nativeImage,
                                                            dimensionID,
                                                            frameIndex));
}

// Image property related functions

inline UINT 
Image::GetPropertyCount()
{
    UINT numProperty = 0;

    SetStatus(DllExports::GdipGetPropertyCount(nativeImage,
                                               &numProperty));

    return numProperty;
}

inline Status 
Image::GetPropertyIdList(
    IN UINT numOfProperty, 
    OUT PROPID* list
    )
{
    return SetStatus(DllExports::GdipGetPropertyIdList(nativeImage,
                                                       numOfProperty, list));
}
    
inline UINT 
Image::GetPropertyItemSize(
    IN PROPID propId
    )
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetPropertyItemSize(nativeImage,
                                                  propId,
                                                  &size));

    return size;
}

inline Status 
Image::GetPropertyItem(
    IN PROPID propId, 
    IN UINT propSize,
    OUT PropertyItem* buffer
    )
{
    return SetStatus(DllExports::GdipGetPropertyItem(nativeImage,
                                                     propId, propSize, buffer));
}

inline Status 
Image::GetPropertySize(
    OUT UINT* totalBufferSize, 
    OUT UINT* numProperties
    )
{
    return SetStatus(DllExports::GdipGetPropertySize(nativeImage,
                                                     totalBufferSize,
                                                     numProperties));
}

inline Status 
Image::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    OUT PropertyItem* allItems
    )
{
    if (allItems == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    return SetStatus(DllExports::GdipGetAllPropertyItems(nativeImage,
                                                         totalBufferSize,
                                                         numProperties,
                                                         allItems));
}

inline Status 
Image::RemovePropertyItem(
    IN PROPID propId
    )
{
    return SetStatus(DllExports::GdipRemovePropertyItem(nativeImage, propId));
}

inline Status 
Image::SetPropertyItem(
    IN const PropertyItem* item
    )
{
    return SetStatus(DllExports::GdipSetPropertyItem(nativeImage, item));
}

// Get/SetLayout
// Support for Middle East localization (right-to-left mirroring)

inline ImageLayout
Image::GetLayout() const
{
    ImageLayout layout;

    SetStatus(DllExports::GdipGetImageLayout(nativeImage, &layout));

    return layout;
}

inline Status
Image::SetLayout(IN const ImageLayout layout)
{
    SetStatus(DllExports::GdipSetImageLayout(nativeImage, layout));
}

inline Status
Image::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline 
Image::Image(GpImage *nativeImage, Status status)
{
    SetNativeImage(nativeImage);
    lastResult = status;
}

inline VOID 
Image::SetNativeImage(GpImage *nativeImage)
{
    this->nativeImage = nativeImage;
}

inline 
Bitmap::Bitmap(
    IN const WCHAR *filename, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement) 
    {
        lastResult = DllExports::GdipCreateBitmapFromFileICM(filename, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromFile(filename, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IStream *stream, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN INT stride,
    IN PixelFormat format,
    IN BYTE *scan0
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       stride,
                                                       format,
                                                       scan0,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       0,
                                                       format,
                                                       NULL,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width, 
    IN INT height, 
    IN Graphics* target)
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGraphics(width,
                                                          height,
                                                          target->nativeGraphics,
                                                          &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromDirectDrawSurface(surface,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGdiDib(gdiBitmapInfo,
                                                        gdiBitmapData,
                                                        &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHBITMAP(hbm, hpal, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HICON hicon
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHICON(hicon, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromResource(hInstance,
                                                          bitmapName,
                                                          &bitmap);

    SetNativeImage(bitmap);
}


inline Bitmap* 
Bitmap::FromFile(
    IN const WCHAR *filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromStream(
    IN IStream *stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        stream, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromDirectDrawSurface7(
    IN IDirectDrawSurface7* surface
    )
{
    return new Bitmap(surface);
}

inline Bitmap* 
Bitmap::FromBITMAPINFO(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData)
{
    return new Bitmap(gdiBitmapInfo, gdiBitmapData);
}

inline Bitmap* 
Bitmap::FromHBITMAP(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    return new Bitmap(hbm, hpal);
}

inline Bitmap* 
Bitmap::FromHICON(
    IN HICON hicon
    )
{
    return new Bitmap(hicon);
}

inline Bitmap* 
Bitmap::FromResource(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName)
{
    return new Bitmap(hInstance, bitmapName);
}

inline Status 
Bitmap::GetHBITMAP(
    IN const Color& colorBackground,
    OUT HBITMAP* hbmReturn
    )
{
    return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hbmReturn,
                                        colorBackground.GetValue()));
}

inline Status 
Bitmap::GetHICON(
    OUT HICON* hiconReturn
    )
{
    return SetStatus(DllExports::GdipCreateHICONFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hiconReturn));
}

inline Bitmap* 
Bitmap::Clone(
    IN const Rect& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap* 
Bitmap::Clone(
    IN INT x,
    IN INT y,
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   lastResult = DllExports::GdipCloneBitmapAreaI(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap);

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap* 
Bitmap::Clone(
    IN const RectF& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap*
Bitmap::Clone(
    IN REAL x,
    IN REAL y,
    IN REAL width,
    IN REAL height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   SetStatus(DllExports::GdipCloneBitmapArea(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap));

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap::Bitmap(GpBitmap *nativeBitmap)
{
    SetNativeImage(nativeBitmap);
}

inline Status
Bitmap::LockBits(
    IN const Rect& rect,
    IN UINT flags,
    IN PixelFormat format,
    OUT BitmapData* lockedBitmapData
)
{
    return SetStatus(DllExports::GdipBitmapLockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    &rect,
                                    flags,
                                    format,
                                    lockedBitmapData));
}

inline Status 
Bitmap::UnlockBits(
    IN BitmapData* lockedBitmapData
    )
{
    return SetStatus(DllExports::GdipBitmapUnlockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    lockedBitmapData));
}

inline Status 
Bitmap::GetPixel(
    IN INT x, 
    IN INT y, 
    OUT Color *color) 
{
    ARGB argb;

    Status status = SetStatus(DllExports::GdipBitmapGetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,        
        &argb));

    if (status == Ok) 
    {
        color->SetValue(argb);
    }

    return  status;
}

inline Status 
Bitmap::SetPixel(
    IN INT x, 
    IN INT y, 
    IN const Color& color) 
{
    return SetStatus(DllExports::GdipBitmapSetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,
        color.GetValue()));
}

inline Status 
Bitmap::SetResolution(
    IN REAL xdpi, 
    IN REAL ydpi)
{
    return SetStatus(DllExports::GdipBitmapSetResolution(
        static_cast<GpBitmap *>(nativeImage),
        xdpi, ydpi));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\ct_ras_win.h ===
/*

Copyright (c) 1999  Microsoft Corporation

******************************
*** Microsoft Confidential ***
******************************

Module Name:

    CT_Ras_Win.h

Author: 

  Paul Linnerud (paulli@microsoft.com)

Abstract:

    This module defines the API mapping layer for the standalone implementation of the ClearType
	rasterizer. Applications written to use the Win32 API should make use of these functions to
	output using ClearType.

Revision History:

*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _CT_Ras_Win_
#define _CT_Ras_Win_

#if !defined(_CTWAPI_LIB_)
#define CTWAPI __declspec(dllimport)
#else
#define CTWAPI
#endif

/* defines */

typedef void *(__cdecl *CTWAPI_ALLOCPROC)(ULONG ulSize);
typedef void *(__cdecl *CTWAPI_REALLOCPROC)(void * pMem, ULONG ulSize);
typedef void  (__cdecl *CTWAPI_FREEPROC)(void * pMem);

typedef struct
{
	CTWAPI_ALLOCPROC fnAlloc; 
	CTWAPI_REALLOCPROC fnReAlloc; 
	CTWAPI_FREEPROC fnFree;
} CTWAPIMEMORYFUNCTIONS, *PCTWAPIMEMORYFUNCTIONS;

typedef HANDLE WAPIFONTINSTANCEHANDLE;

typedef struct
{
	ULONG ulStructSize;

	/* System Parameters */
	BOOL bBGR;
	BOOL bHorizontal;

	// gamma clamp
	ULONG ulGammaBottom, ulGammaTop;

	/* User Parameters */
	// color filter
	ULONG ulColorThreshold;
	ULONG ulCLFRedFactor;
	ULONG ulCLFGreenFactor;

	// blue color filter
	ULONG ulBlueColorThreshold;
	ULONG ulBCLFGreenFactor;
	ULONG ulBCLFBlueFactor;
	ULONG ulBCLFRedFactor;
}CTWAPIPARAMS, *PCTWAPIPARAMS;

/* Fetch last error. */
CTWAPI LONG WINAPI WAPI_CTGetLastError();

/* Override the default memory handler. Optional function only should be called once per process and
before any other functions in this module are called. */
CTWAPI BOOL WAPI_CTOverrideDefaultMemoryFunctions(PCTWAPIMEMORYFUNCTIONS pMemFunctionStruct);

/* Functions to manage an instance of a font. */

/* From a handle to a DC, create a FONTINSTANCE handle. */
CTWAPI WAPIFONTINSTANCEHANDLE WINAPI WAPI_CTCreateFontInstance(HDC hDC, DWORD dwFlags);

/* Delete a FONTINSTANCE handle. */
CTWAPI BOOL WINAPI WAPI_CTDeleteFontInstance(WAPIFONTINSTANCEHANDLE hFontInstance);

/* Information functions. */

/* Return the family name for the font. */
CTWAPI LONG WINAPI WAPI_CTGetTextFaceW(WAPIFONTINSTANCEHANDLE hFontInstance, LONG lCount, PWSTR pTextFace);

/* Get the TEXTMETRICW structure. */
CTWAPI BOOL WINAPI WAPI_CTGetTextMetricsW(WAPIFONTINSTANCEHANDLE hFontInstance, PTEXTMETRICW ptm);

/* Get the OUTLINETEXTMETRICW structure. */
CTWAPI ULONG WINAPI WAPI_CTGetOutlineTextMetricsW(WAPIFONTINSTANCEHANDLE hFontInstance, ULONG ulcData, POUTLINETEXTMETRICW potm);

/* Get the ABC widths. */
CTWAPI BOOL WINAPI WAPI_CTGetCharABCWidthsW(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);
CTWAPI BOOL WINAPI WAPI_CTGetCharABCWidthsI(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

/* Get the char widths. */
CTWAPI BOOL WINAPI WAPI_CTGetCharWidthW(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);
CTWAPI BOOL WINAPI WAPI_CTGetCharWidthI(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);

/* GetTextExtentPoint */
CTWAPI BOOL WINAPI WAPI_CTGetTextExtentPointW(WAPIFONTINSTANCEHANDLE hFontInstance, PWSTR pString, LONG lCount, PSIZE pSize);

/* GetTextExtentExPoint */
CTWAPI BOOL WINAPI WAPI_CTGetTextExtentExPointW(WAPIFONTINSTANCEHANDLE hFontInstance, PWSTR pString, LONG lCount, LONG lMaxExtent,
										PLONG pnFit, PLONG apDx, PSIZE pSize);

/* Modes */
CTWAPI COLORREF WINAPI WAPI_CTSetTextColor(WAPIFONTINSTANCEHANDLE hFontInstance, COLORREF crColor);

CTWAPI COLORREF WINAPI WAPI_CTGetTextColor(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI COLORREF WINAPI WAPI_CTSetBkColor(WAPIFONTINSTANCEHANDLE hFontInstance, COLORREF crColor);

CTWAPI COLORREF WINAPI WAPI_CTGetBkColor(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI LONG WINAPI WAPI_CTSetBkMode(WAPIFONTINSTANCEHANDLE hFontInstance, LONG lBkMode);

/* Supports opaque and transparent with solid color. Note that we need to know the background color for the
ClearType algorithm so even in transparent mode, the correct color must be set prior to rendering text. */
CTWAPI LONG WINAPI WAPI_CTGetBkMode(WAPIFONTINSTANCEHANDLE hFontInstance);

/* Set text alignment supporting TA_BASELINE, TA_TOP, TA_CENTER, TA_LEFT, TA_RIGHT. */
CTWAPI ULONG WINAPI WAPI_CTSetTextAlign(WAPIFONTINSTANCEHANDLE hFontInstance, ULONG fMode);

/* Get text alignment supporting TA_BASELINE, TA_TOP, TA_CENTER, TA_LEFT, TA_RIGHT.*/
CTWAPI ULONG WINAPI WAPI_CTGetTextAlign(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI BOOL WINAPI WAPI_CTSetSystemParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTSetUserParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTGetParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTRestoreDefaultParameters();

/* Output functions. */

/* Output the text the basic way. */
CTWAPI BOOL WINAPI WAPI_CTTextOutW(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

/* Output text via glyph index. */
CTWAPI BOOL WINAPI WAPI_CTTextOutI(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

/* Output the text with limited  extended functionality. 
	supports: lpDx and flags ETO_GLYPH_INDEX and ETO_PDY and ETO_OPAQUE. */
CTWAPI BOOL WINAPI WAPI_CTExtTextOutW(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, DWORD dwOptions,
							  CONST RECT* lprc, PWSTR pString, ULONG ulCount, CONST LONG *lpDx);

/* Alternative EZ functions that trade off speed for being easier to use and integrate. Functions are DC based so we store
	the WAPIFONTINSTANCEHANDLE internally and must find it for each function. Additional time is also taken since we fetch
	the various modes from DC for each call. Any support limitations mentioned above with faster functions also apply to the
	EZ functions. */

CTWAPI BOOL WINAPI WAPI_EZCTCreateFontInstance(HDC hDC, DWORD dwFlags);

CTWAPI BOOL WINAPI WAPI_EZCTDeleteFontInstance(HFONT hFont);

// can be used to get WAPIFONTINSTANCEHANDLE from DC so additional function above such as WAPI_CTGetTextMetrics may be used.
CTWAPI WAPIFONTINSTANCEHANDLE WINAPI WAPI_EZCTDcToFontInst(HDC hDC);

CTWAPI BOOL WINAPI WAPI_EZCTTextOutW(HDC hDC, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

CTWAPI BOOL WINAPI WAPI_EZCTTextOutI(HDC hDC, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

CTWAPI BOOL WINAPI WAPI_EZCTExtTextOutW(HDC hDC, LONG lXStart, LONG lYStart, DWORD dwOptions,
							  CONST RECT* lprc, PWSTR pString, ULONG ulCount, CONST LONG *lpDx);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharABCWidthsW(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharABCWidthsI(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharWidthW(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharWidthI(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);


#endif /* _CT_Ras_Win_ */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluscolormatrix.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Color Matrix
*
* Abstract:
*
*   Class for color adjustment object passed to Graphics.DrawImage
*
* Revision History:
*
*   09/17/1999 gilmanw
*       Created it.
*   10/14/1999 agodfrey
*       Moved it out of GdiplusTypes.h
*
\**************************************************************************/

#ifndef _GDIPLUSCOLORMATRIX_H
#define _GDIPLUSCOLORMATRIX_H

//----------------------------------------------------------------------------
// Color matrix
//----------------------------------------------------------------------------

struct ColorMatrix
{
    REAL m[5][5];
};

//----------------------------------------------------------------------------
// Color Matrix flags
//----------------------------------------------------------------------------

enum ColorMatrixFlags
{
    ColorMatrixFlagsDefault   = 0,
    ColorMatrixFlagsSkipGrays = 1,
    ColorMatrixFlagsAltGray   = 2
};

//----------------------------------------------------------------------------
// Color Adjust Type
//----------------------------------------------------------------------------

enum ColorAdjustType
{
    ColorAdjustTypeDefault,
    ColorAdjustTypeBitmap,
    ColorAdjustTypeBrush,
    ColorAdjustTypePen,
    ColorAdjustTypeText,
    ColorAdjustTypeCount,   // must be immediately after all the individual ones
    ColorAdjustTypeAny      // internal use: for querying if any type has recoloring
};

//----------------------------------------------------------------------------
// Color Map
//----------------------------------------------------------------------------

struct ColorMap
{
    Color oldColor;
    Color newColor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdipluscolor.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Color
*
* Abstract:
*
*   Represents a GDI+ color.
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Moved it out of GdiplusTypes.h
*
\**************************************************************************/

#ifndef _GDIPLUSCOLOR_H
#define _GDIPLUSCOLOR_H

//----------------------------------------------------------------------------
// Color mode
//----------------------------------------------------------------------------

enum ColorMode
{
    ColorModeARGB32 = 0,
    ColorModeARGB64 = 1
};

//----------------------------------------------------------------------------
// Color Channel flags
//----------------------------------------------------------------------------

enum ColorChannelFlags
{
    ColorChannelFlagsC = 0,
    ColorChannelFlagsM,
    ColorChannelFlagsY,
    ColorChannelFlagsK,
    ColorChannelFlagsLast
};

//----------------------------------------------------------------------------
// Color
//----------------------------------------------------------------------------

class Color
{
public:

    Color()
    {
        Argb = (ARGB)Color::Black;
    }

    // Construct an opaque Color object with
    // the specified R, G, B values.

    Color(IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(255, r, g, b);
    }

    // Construct a Color object with
    // the specified A, R, G, B values.
    //
    // NOTE: R, G, B color values are not premultiplied.

    Color(IN BYTE a,
          IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(a, r, g, b);
    }

    // Construct a Color object with
    // the specified ARGB values.
    //
    // NOTE: R, G, B color components are not premultiplied.

    Color(IN ARGB argb)
    {
        Argb = argb;
    }

    // Extract A, R, G, B components

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetA() const
    {
        return GetAlpha();
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetR() const
    {
        return GetRed();
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetG() const
    {
        return GetGreen();
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    BYTE GetB() const
    {
        return GetBlue();
    }

    // Retrieve ARGB values

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    VOID SetFromCOLORREF(IN COLORREF rgb)
    {
        Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

public:

    // Standard color constants
    enum
    {
       Black = 0xff000000,
       Silver = 0xffc0c0c0,
       Gray = 0xff808080,
       White = 0xffffffff,
       Maroon = 0xff800000,
       Red = 0xffff0000,
       Purple = 0xff800080,
       Fuchsia = 0xffff00ff,
       Green = 0xff008000,
       Lime = 0xff00ff00,
       Olive = 0xff808000,
       Yellow = 0xffffff00,
       Navy = 0xff000080,
       Blue = 0xff0000ff,
       Teal = 0xff008080,
       Aqua = 0xff00ffff
    };

    // Shift count and bit mask for A, R, G, B components
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

protected:

    ARGB Argb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusfont.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font related declarations
*
* Revision History:
*
*   05/06/1999 ikkof
*       Created it.
*   22/July/1999  Xudong Wu [tessiew]
*       Modified it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONT_H
#define _GDIPLUSFONT_H

inline
Font::Font(IN HDC hdc)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTW* logfont)
{
    GpFont *font = NULL;
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontW(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTA* logfont)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(
     IN const FontFamily * family,
     IN REAL         emSize,
     IN INT          style,
     IN Unit         unit
)
{
    GpFont *font = NULL;

    lastResult = DllExports::GdipCreateFont(family->nativeFamily,
                    emSize,
                    style,
                    unit,
                    &font);

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(
     IN const WCHAR *          familyName,
     IN REAL                   emSize,
     IN INT                    style,
     IN Unit                   unit,
     IN const FontCollection * fontCollection
)
{
    FontFamily family(familyName, fontCollection);

    GpFont * font = NULL;

    lastResult = family.GetLastStatus();

    if (lastResult == Ok)
    {

        lastResult = DllExports::GdipCreateFont(family.nativeFamily,
                                emSize,
                                style,
                                unit,
                                &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline Status
Font::GetLogFontA(IN const Graphics *g,
                  OUT LOGFONTA *logfontA) const
{
    return SetStatus(DllExports::GdipGetLogFontA(nativeFont, g->nativeGraphics, logfontA));

}

inline Status
Font::GetLogFontW(IN const Graphics *g,
                  OUT LOGFONTW *logfontW) const
{
    return SetStatus(DllExports::GdipGetLogFontW(nativeFont, g->nativeGraphics, logfontW));
}


inline Font*
Font::Clone() const
{
    GpFont *cloneFont = NULL;

    SetStatus(DllExports::GdipCloneFont(nativeFont, &cloneFont));

    return new Font(cloneFont, lastResult);
}

inline
Font::~Font()
{
    DllExports::GdipDeleteFont(nativeFont);
}

// Operations

inline BOOL
Font::IsAvailable() const
{
    return (nativeFont ? TRUE : FALSE);
}

inline Status
Font::GetFamily(OUT FontFamily *family) const
{
    if (family == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    Status status = DllExports::GdipGetFamily(nativeFont, &(family->nativeFamily));
    family->SetStatus(status);

    return SetStatus(status);
}

inline INT
Font::GetStyle() const
{
    INT style;

    SetStatus(DllExports::GdipGetFontStyle(nativeFont, &style));

    return style;
}

inline REAL
Font::GetSize() const
{
    REAL size;
    SetStatus(DllExports::GdipGetFontSize(nativeFont, &size));
    return size;
}

inline Unit
Font::GetUnit() const
{
    Unit unit;
    SetStatus(DllExports::GdipGetFontUnit(nativeFont, &unit));
    return unit;
}

inline REAL
Font::GetHeight(IN const Graphics *graphics) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeight(
        nativeFont,
        graphics ? graphics->nativeGraphics : NULL,
        &height
    ));
    return height;
}

// protected method
inline
Font::Font(IN GpFont* font,
           IN Status status)
{
    lastResult = status;
    SetNativeFont(font);
}

// protected method
inline VOID
Font::SetNativeFont(GpFont *Font)
{
    nativeFont = Font;
}

inline Status
Font::GetLastStatus(void) const
{
    return lastResult;
}

// protected method
inline Status
Font::SetStatus(IN Status status) const
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusflat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   flatapi.h
*
* Abstract:
*
*   Flat GDI+ API wrappers - header file
*
* Revision History:
*
*   12/13/1998 davidx
*       Created it.
*
\**************************************************************************/

// TODO: this file style needs to be made internally consistent with the way
//       it handles breaking the long argument lists across multiple lines

#ifndef _FLATAPI_H
#define _FLATAPI_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#define GDIPCONST const

#ifdef __cplusplus
extern "C" {
#endif

VOID
WINGDIPAPI
GdipDisplayPaletteWindowNotify(WindowNotifyEnum notify);

//----------------------------------------------------------------------------
// GraphicsPath methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePath(GpFillMode brushMode, GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode,
                                    GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode,
                                     GpPath **path);

GpStatus WINGDIPAPI
GdipClonePath(GpPath* path, GpPath **clonePath);

GpStatus WINGDIPAPI
GdipDeletePath(GpPath* path);

GpStatus WINGDIPAPI
GdipResetPath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPointCount(GpPath* path, INT* count);

GpStatus WINGDIPAPI
GdipGetPathTypes(GpPath* path, BYTE* types, INT count);

GpStatus WINGDIPAPI
GdipGetPathPoints(GpPath*, GpPointF* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathPointsI(GpPath*, GpPoint* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);

GpStatus WINGDIPAPI
GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);

GpStatus WINGDIPAPI
GdipGetPathData(GpPath *path, GpPathData* pathData);

GpStatus WINGDIPAPI
GdipStartPathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigures(GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathMarker(GpPath* path);

GpStatus WINGDIPAPI
GdipClearPathMarkers(GpPath* path);

GpStatus WINGDIPAPI
GdipReversePath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPathLastPoint(GpPath* path, GpPointF* lastPoint);

GpStatus WINGDIPAPI
GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2,
                           REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);

GpStatus WINGDIPAPI
GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width,
                            REAL height);

GpStatus WINGDIPAPI
GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathPath(GpPath *path, GDIPCONST GpPath* addingPath, BOOL connect);

GpStatus WINGDIPAPI
GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST RectF *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST Rect *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);

GpStatus WINGDIPAPI
GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2,
                           INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFlattenPath(GpPath *path, GpMatrix* matrix, REAL flatness);

GpStatus WINGDIPAPI
GdipWidenPathWithMinimumResolutions(GpPath *path, GpPen *pen, REAL minXres,
            REAL minYres, GpMatrix *matrix, BOOL removeSelftIntersects);

GpStatus WINGDIPAPI
GdipWarpPath(GpPath *path, GpMatrix* matrix,
            GDIPCONST GpPointF *points, INT count,
            REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
            WarpMode warpMode, REAL flatness);

GpStatus WINGDIPAPI
GdipTransformPath(GpPath* path, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetPathWorldBounds(GpPath* path, GpRectF* bounds, GDIPCONST GpMatrix *matrix,
                  GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipGetPathWorldBoundsI(GpPath* path, GpRect* bounds, GDIPCONST GpMatrix *matrix,
                   GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipIsVisiblePathPoint(GpPath* path, REAL x, REAL y,
                       GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePathPointI(GpPath* path, INT x, INT y,
                        GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPoint(GpPath* path, REAL x, REAL y, GpPen *pen,
                              GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPointI(GpPath* path, INT x, INT y, GpPen *pen,
                               GpGraphics *graphics, BOOL *result);

//----------------------------------------------------------------------------
// Path Enumeration methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathIter(GpPathIterator **iterator, GpPath* path);

GpStatus WINGDIPAPI
GdipDeletePathIter(GpPathIterator *iterator);

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextPathType(GpPathIterator* iterator, INT* resultCount,
        BYTE* pathType, INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarker(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path);

GpStatus WINGDIPAPI
GdipPathIterGetCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterIsValid(GpPathIterator* iterator, BOOL* valid);

GpStatus WINGDIPAPI
GdipPathIterHasCurve(GpPathIterator* iterator, BOOL* hasCurve);

GpStatus WINGDIPAPI
GdipPathIterRewind(GpPathIterator* iterator);

GpStatus WINGDIPAPI
GdipPathIterEnumerate(GpPathIterator* iterator, INT* resultCount,
    GpPointF *points, BYTE *types, INT count);

GpStatus WINGDIPAPI
GdipPathIterCopyData(GpPathIterator* iterator, INT* resultCount,
    GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

//----------------------------------------------------------------------------
// Matrix methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx,
                                      REAL dy, GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg,
                                      GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg,
                                       GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);

GpStatus WINGDIPAPI
GdipDeleteMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22,
                      REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY,
                    GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);

GpStatus WINGDIPAPI
GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipGetMatrixElements(GpMatrix *matrix, REAL *matrixOut);

GpStatus WINGDIPAPI
GdipIsMatrixInvertible(GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixIdentity(GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixEqual(GpMatrix *matrix, GpMatrix *matrix2, BOOL *result);

//----------------------------------------------------------------------------
// Region methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateRegion(GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionPath(GpPath *path, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);

GpStatus WINGDIPAPI
GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);

GpStatus WINGDIPAPI
GdipDeleteRegion(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetInfinite(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetEmpty(GpRegion *region);

GpStatus WINGDIPAPI
GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect,
                      CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect,
                       CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRegion(GpRegion *region,  GpRegion *region2,
                        CombineMode combineMode);

GpStatus WINGDIPAPI
GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipTransformRegion(GpRegion *region, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics,
                             GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics,
                             GpRect *rect);

GpStatus WINGDIPAPI
GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);

GpStatus WINGDIPAPI
GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics,
                              BOOL *result);

GpStatus WINGDIPAPI
GdipIsEqualRegion(GpRegion *region, GpRegion *region2,
                           GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionDataSize(GpRegion *region, UINT * bufferSize);

GpStatus WINGDIPAPI
GdipGetRegionData(GpRegion *region, BYTE * buffer, UINT bufferSize, UINT * sizeFilled);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width,
                        REAL height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width,
                         INT height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionScansCount(GpRegion *region, UINT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScansI(GpRegion *region, GpRect* rects, INT* count, GpMatrix* matrix);

//----------------------------------------------------------------------------
// Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);

GpStatus WINGDIPAPI
GdipDeleteBrush(GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetBrushType(GpBrush *brush, GpBrushType *type);

//----------------------------------------------------------------------------
// Hatch Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol,
                              ARGB backcol, GpHatch **brush);

GpStatus WINGDIPAPI
GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);

GpStatus WINGDIPAPI
GdipGetHatchForegroundColor(GpHatch *brush, ARGB* forecol);

GpStatus WINGDIPAPI
GdipGetHatchBackgroundColor(GpHatch *brush, ARGB* backcol);

//----------------------------------------------------------------------------
// Texture Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateTexture(GpImage *image, GpWrapMode wrapmode,
                           GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x,
                   REAL y, REAL width, REAL height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIA(GpImage *image, GpImageAttributes *imageAttributes,
                    REAL x, REAL y, REAL width, REAL height,
                    GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x,
                    INT y, INT width, INT height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetTextureTransform(GpTexture* brush);

GpStatus WINGDIPAPI
GdipMultiplyTextureTransform(GpTexture* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateTextureTransform(GpTexture* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleTextureTransform(GpTexture* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateTextureTransform(GpTexture* brush, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureImage(GpTexture *brush, GpImage **image);

//----------------------------------------------------------------------------
// Solid Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateSolidFill(ARGB color, GpSolidFill **brush);

GpStatus WINGDIPAPI
GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);

GpStatus WINGDIPAPI
GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);

//----------------------------------------------------------------------------
// LineBrush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateLineBrush(GDIPCONST GpPointF* point1,
                    GDIPCONST GpPointF* point2,
                    ARGB color1, ARGB color2,
                    GpWrapMode wrapMode,
                    GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushI(GDIPCONST GpPoint* point1,
                     GDIPCONST GpPoint* point2,
                     ARGB color1, ARGB color2,
                     GpWrapMode wrapMode,
                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRect(GDIPCONST GpRectF* rect,
                            ARGB color1, ARGB color2,
                            LinearGradientMode mode,
                            GpWrapMode wrapMode,
                            GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectI(GDIPCONST GpRect* rect,
                             ARGB color1, ARGB color2,
                             LinearGradientMode mode,
                             GpWrapMode wrapMode,
                             GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipSetLinePoints(GpLineGradient *brush,
                  GDIPCONST GpPointF* point1,
                  GDIPCONST GpPointF* point2);

GpStatus WINGDIPAPI
GdipSetLinePointsI(GpLineGradient *brush,
                   GDIPCONST GpPoint* point1,
                   GDIPCONST GpPoint* point2);

GpStatus WINGDIPAPI
GdipGetLinePoints(GpLineGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetLinePointsI(GpLineGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);

GpStatus WINGDIPAPI
GdipGetLineColors(GpLineGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL* positions,
                 INT count);

GpStatus WINGDIPAPI
GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend,
                 GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend,
                                           REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend,
                       GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetLineTransform(GpLineGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyLineTransform(GpLineGradient* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateLineTransform(GpLineGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleLineTransform(GpLineGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateLineTransform(GpLineGradient* brush, REAL angle, GpMatrixOrder order);

//----------------------------------------------------------------------------
// PathGradient Brush
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathGradient(GDIPCONST GpPointF* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientI(GDIPCONST GpPoint* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientFromPath(GDIPCONST GpPath* path,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB colors);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush, ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush,
                        GDIPCONST ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPoint(
                        GpPathGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPointI(
                        GpPathGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPoint(
                        GpPathGradient *brush, GDIPCONST GpPointF* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPointI(
                        GpPathGradient *brush, GDIPCONST GpPoint* points);

GpStatus WINGDIPAPI
GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientGammaCorrection(GpPathGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientGammaCorrection(GpPathGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientBlendCount(GpPathGradient *brush,
                                             INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientBlend(GpPathGradient *brush,
                                    REAL *blend, REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientBlend(GpPathGradient *brush,
                GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend,
                                                REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend,
                                        GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipGetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipSetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPathGradientTransform(GpPathGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyPathGradientTransform(GpPathGradient* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePathGradientTransform(GpPathGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePathGradientTransform(GpPathGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePathGradientTransform(GpPathGradient* brush, REAL angle,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale, REAL* yScale);

GpStatus WINGDIPAPI
GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale, REAL yScale);

//----------------------------------------------------------------------------
// Pen methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);

GpStatus WINGDIPAPI
GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit,
                        GpPen **pen);

GpStatus WINGDIPAPI
GdipClonePen(GpPen *pen, GpPen **clonepen);

GpStatus WINGDIPAPI
GdipDeletePen(GpPen *pen);

GpStatus WINGDIPAPI
GdipSetPenWidth(GpPen *pen, REAL width);

GpStatus WINGDIPAPI
GdipGetPenWidth(GpPen *pen, REAL *width);

GpStatus WINGDIPAPI
GdipSetPenUnit(GpPen *pen, GpUnit unit);

GpStatus WINGDIPAPI
GdipGetPenUnit(GpPen *pen, GpUnit *unit);

GpStatus WINGDIPAPI
GdipSetPenLineCap(GpPen *pen, GpLineCap startCap, GpLineCap endCap,
                  GpLineCap dashCap);

GpStatus WINGDIPAPI
GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);

GpStatus WINGDIPAPI
GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipSetPenDashCap(GpPen *pen, GpLineCap dashCap);

GpStatus WINGDIPAPI
GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);

GpStatus WINGDIPAPI
GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);

GpStatus WINGDIPAPI
GdipGetPenDashCap(GpPen *pen, GpLineCap *dashCap);

GpStatus WINGDIPAPI
GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);

GpStatus WINGDIPAPI
GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);

GpStatus WINGDIPAPI
GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);

GpStatus WINGDIPAPI
GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);

GpStatus WINGDIPAPI
GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);

GpStatus WINGDIPAPI
GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPenTransform(GpPen *pen);

GpStatus WINGDIPAPI
GdipMultiplyPenTransform(GpPen *pen, GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetPenColor(GpPen *pen, ARGB argb);

GpStatus WINGDIPAPI
GdipGetPenColor(GpPen *pen, ARGB *argb);

GpStatus WINGDIPAPI
GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);

GpStatus WINGDIPAPI
GdipGetPenFillType(GpPen *pen, GpPenType* type);

GpStatus WINGDIPAPI
GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);

GpStatus WINGDIPAPI
GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);

GpStatus WINGDIPAPI
GdipGetPenDashOffset(GpPen *pen, REAL *offset);

GpStatus WINGDIPAPI
GdipSetPenDashOffset(GpPen *pen, REAL offset);

GpStatus WINGDIPAPI
GdipGetPenDashCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);

//----------------------------------------------------------------------------
// CustomLineCap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCustomLineCap(GpPath* fillPath, GpPath* strokePath,
   GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);

GpStatus WINGDIPAPI
GdipDeleteCustomLineCap(GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipCloneCustomLineCap(GpCustomLineCap* customCap,
                       GpCustomLineCap** clonedCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapType(GpCustomLineCap* customCap,
                       CustomLineCapType* capType);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap startCap, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap* startCap, GpLineCap* endCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, GpLineJoin* lineJoin);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap baseCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap* baseCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL inset);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL* inset);

GpStatus WINGDIPAPI
GdipSetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL widthScale);

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL* widthScale);

//----------------------------------------------------------------------------
// AdjustableArrowCap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled,
                             GpAdjustableArrowCap **cap);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL height);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL* height);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL width);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL* width);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, REAL middleInset);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, REAL* middleInset);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL fillState);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL* fillState);

//----------------------------------------------------------------------------
// Image methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipLoadImageFromStream(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFile(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromStreamICM(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFileICM(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipCloneImage(GpImage *image, GpImage **cloneImage);

GpStatus WINGDIPAPI
GdipDisposeImage(GpImage *image);

GpStatus WINGDIPAPI
GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR* filename,
                    GDIPCONST CLSID* clsidEncoder, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveImageToStream(GpImage *image, IStream* stream,
                      GDIPCONST CLSID* clsidEncoder, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAddImage(GpImage *image, GpImage* newImage,
                 GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);

GpStatus WINGDIPAPI
GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);

GpStatus WINGDIPAPI
GdipGetImageType(GpImage *image, ImageType *type);

GpStatus WINGDIPAPI
GdipGetImageWidth(GpImage *image, UINT *width);

GpStatus WINGDIPAPI
GdipGetImageHeight(GpImage *image, UINT *height);

GpStatus WINGDIPAPI
GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageFlags(GpImage *image, UINT *flags);

GpStatus WINGDIPAPI
GdipGetImageRawFormat(GpImage *image, GUID *format);

GpStatus WINGDIPAPI
GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);

GpStatus WINGDIPAPI
GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight,
                      GpImage **thumbImage,
                      GetThumbnailImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                                UINT* size);

GpStatus WINGDIPAPI
GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                            UINT size, EncoderParameters* buffer);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsCount(GpImage* image, UINT* count);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsList(GpImage* image, GUID* dimensionIDs, UINT count);

GpStatus WINGDIPAPI
GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID* dimensionID, UINT* count);

GpStatus WINGDIPAPI
GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID* dimensionID,
                           UINT frameIndex);
GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size);

GpStatus WINGDIPAPI
GdipGetPropertyCount(GpImage *image, UINT* numOfProperty);

GpStatus WINGDIPAPI
GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID* list);

GpStatus WINGDIPAPI
GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT* size);

GpStatus WINGDIPAPI
GdipGetPropertyItem(GpImage *image, PROPID propId,UINT propSize,
                    PropertyItem* buffer);

GpStatus WINGDIPAPI
GdipGetPropertySize(GpImage *image, UINT* totalBufferSize, UINT* numProperties);

GpStatus WINGDIPAPI
GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize,
                        UINT numProperties, PropertyItem* allItems);

GpStatus WINGDIPAPI
GdipRemovePropertyItem(GpImage *image, PROPID propId);

GpStatus WINGDIPAPI
GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem* item);

GpStatus WINGDIPAPI
GdipImageForceValidation(GpImage *image);

GpStatus WINGDIPAPI
GdipGetImageLayout(GpImage *image, ImageLayout* layout);

GpStatus WINGDIPAPI
GdipSetImageLayout(GpImage *image, GDIPCONST ImageLayout layout);

//----------------------------------------------------------------------------
// Bitmap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateBitmapFromStream(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFile(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromStreamICM(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFileICM(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromScan0(INT width,
                          INT height,
                          INT stride,
                          PixelFormat format,
                          BYTE* scan0,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGraphics(INT width,
                             INT height,
                             GpGraphics* target,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7* surface,
                                      GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO* gdiBitmapInfo,
                           VOID* gdiBitmapData,
                           GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHBITMAP(HBITMAP hbm,
                            HPALETTE hpal,
                            GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap,
                            HBITMAP* hbmReturn,
                            ARGB background);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHICON(HICON hicon,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHICONFromBitmap(GpBitmap* bitmap,
                          HICON* hbmReturn);

GpStatus WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                            PixelFormat format,
                            GpBitmap *srcBitmap,
                            GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapAreaI(INT x,
                     INT y,
                     INT width,
                     INT height,
                     PixelFormat format,
                     GpBitmap *srcBitmap,
                     GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipBitmapLockBits(GpBitmap* bitmap,
                   GDIPCONST GpRect* rect,
                   UINT flags,
                   PixelFormat format,
                   BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapUnlockBits(GpBitmap* bitmap,
                     BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapGetPixel(GpBitmap* bitmap, INT x, INT y, ARGB *color);

GpStatus WINGDIPAPI
GdipBitmapSetPixel(GpBitmap* bitmap, INT x, INT y, ARGB color);

GpStatus WINGDIPAPI
GdipBitmapSetResolution(GpBitmap* bitmap, REAL xdpi, REAL ydpi);

//----------------------------------------------------------------------------
// ImageAttributes methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr);

GpStatus WINGDIPAPI
GdipCloneImageAttributes(GpImageAttributes *imageattr,
                         GpImageAttributes **cloneImageattr);

GpStatus WINGDIPAPI
GdipDisposeImageAttributes(GpImageAttributes *imageattr);

GpStatus WINGDIPAPI
GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr,
                                 ColorAdjustType type);
GpStatus WINGDIPAPI
GdipResetImageAttributes(GpImageAttributes *imageattr,
                         ColorAdjustType type);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr,
                               ColorAdjustType type,
                               BOOL enableFlag,
                               GDIPCONST ColorMatrix* colorMatrix,
                               GDIPCONST ColorMatrix* grayMatrix,
                               ColorMatrixFlags flags);

GpStatus WINGDIPAPI
GdipSetImageAttributesThreshold(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                REAL threshold);

GpStatus WINGDIPAPI
GdipSetImageAttributesGamma(GpImageAttributes *imageattr,
                            ColorAdjustType type,
                            BOOL enableFlag,
                            REAL gamma);

GpStatus WINGDIPAPI
GdipSetImageAttributesNoOp(GpImageAttributes *imageattr,
                           ColorAdjustType type,
                           BOOL enableFlag);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                ARGB colorLow,
                                ARGB colorHigh);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr,
                                    ColorAdjustType type,
                                    BOOL enableFlag,
                                    ColorChannelFlags channelFlags);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr,
                                                ColorAdjustType type,
                                                BOOL enableFlag,
                                                GDIPCONST WCHAR *colorProfileFilename);

GpStatus WINGDIPAPI
GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr,
                                 ColorAdjustType type,
                                 BOOL enableFlag,
                                 UINT mapSize,
                                 GDIPCONST ColorMap *map);
GpStatus WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
);

GpStatus WINGDIPAPI
GdipSetImageAttributesICMMode(
    GpImageAttributes *imageAttr,
    BOOL on
);

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
);

//----------------------------------------------------------------------------
// Graphics methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipFlush(GpGraphics *graphics, GpFlushIntention intention);

GpStatus WINGDIPAPI
GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipDeleteGraphics(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetDC(GpGraphics* graphics, HDC * hdc);

GpStatus WINGDIPAPI
GdipReleaseDC(GpGraphics* graphics, HDC hdc);

GpStatus WINGDIPAPI
GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);

GpStatus WINGDIPAPI
GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);

GpStatus WINGDIPAPI
GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);

GpStatus WINGDIPAPI
GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);

GpStatus WINGDIPAPI
GdipSetCompositingQuality(GpGraphics *graphics, CompositingQuality compositingQuality);

GpStatus WINGDIPAPI
GdipGetCompositingQuality(GpGraphics *graphics, CompositingQuality *compositingQuality);

GpStatus WINGDIPAPI
GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);

GpStatus WINGDIPAPI
GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);

GpStatus WINGDIPAPI
GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);

GpStatus WINGDIPAPI
GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);

GpStatus WINGDIPAPI
GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);

GpStatus WINGDIPAPI
GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);

GpStatus  WINGDIPAPI
GdipSetTextGammaValue(GpGraphics *graphics, UINT gammaValue);

GpStatus  WINGDIPAPI
GdipGetTextGammaValue(GpGraphics *graphics, UINT * gammaValue);

GpStatus WINGDIPAPI
GdipSetInterpolationMode(GpGraphics *graphics, InterpolationMode interpolationMode);

GpStatus WINGDIPAPI
GdipGetInterpolationMode(GpGraphics *graphics, InterpolationMode *interpolationMode);

GpStatus WINGDIPAPI
GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetWorldTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipMultiplyWorldTransform(GpGraphics *graphics, GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy,
                        GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateWorldTransform(GpGraphics *graphics, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPageTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);

GpStatus WINGDIPAPI
GdipGetPageScale(GpGraphics *graphics, REAL *scale);

GpStatus WINGDIPAPI
GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);

GpStatus WINGDIPAPI
GdipSetPageScale(GpGraphics *graphics, REAL scale);

GpStatus WINGDIPAPI
GdipGetDpiX(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipGetDpiY(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPointF *points,
                             INT count);

GpStatus WINGDIPAPI
GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPoint *points,
                             INT count);

GpStatus WINGDIPAPI
GdipGetNearestColor(GpGraphics *graphics, ARGB* argb);

// Create the Win9x Halftone Palette (even on NT) with correct Desktop colors
HPALETTE WINGDIPAPI
GdipCreateHalftonePalette();

GpStatus WINGDIPAPI
GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                      REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                      INT x2, INT y2);

GpStatus WINGDIPAPI
GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                        REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                        INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                      REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                      INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                         REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                         INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                     REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);

GpStatus WINGDIPAPI
GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
               INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen,
                    GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPointF *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen,
                      GDIPCONST GpPoint *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipGraphicsClear(GpGraphics *graphics, ARGB color);

GpStatus WINGDIPAPI
GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                  REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                   INT width, INT height);

GpStatus WINGDIPAPI
GdipFillRectangles(GpGraphics *graphics, GpBrush *brush,
                   GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush,
                    GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon(GpGraphics *graphics, GpBrush *brush,
                GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush,
                  GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                 INT width, INT height);

GpStatus WINGDIPAPI
GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
             INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillRegion(GpGraphics *graphics, GpBrush *brush,
                        GpRegion *region);

GpStatus WINGDIPAPI
GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);

GpStatus WINGDIPAPI
GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);

GpStatus WINGDIPAPI
GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y,
                           REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y,
                           INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawImagePoints(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPointF *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPoint *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x,
                                REAL y, REAL srcx, REAL srcy, REAL srcwidth,
                                REAL srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x,
                                INT y, INT srcx, INT srcy, INT srcwidth,
                                INT srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx,
                      REAL dsty, REAL dstwidth, REAL dstheight,
                      REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
                      GpUnit srcUnit,
                      GpImageAttributes* imageAttributes,
                      DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx,
                       INT dsty, INT dstwidth, INT dstheight,
                       INT srcx, INT srcy, INT srcwidth, INT srcheight,
                       GpUnit srcUnit,
                       GpImageAttributes* imageAttributes,
                       DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image,
                        GDIPCONST GpPointF *points, INT count, REAL srcx,
                        REAL srcy, REAL srcwidth, REAL srcheight,
                        GpUnit srcUnit,
                        GpImageAttributes* imageAttributes,
                        DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image,
                         GDIPCONST GpPoint *points, INT count, INT srcx,
                         INT srcy, INT srcwidth, INT srcheight,
                         GpUnit srcUnit,
                         GpImageAttributes* imageAttributes,
                         DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    );

GpStatus WINGDIPAPI
GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics,
                    CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y,
                         REAL width, REAL height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRectI(GpGraphics *graphics, INT x, INT y,
                         INT width, INT height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRegion(GpGraphics *graphics, GpRegion *region,
                  CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipResetClip(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipGetClip(GpGraphics *graphics, GpRegion *region);

GpStatus WINGDIPAPI
GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y,
                           REAL width, REAL height, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y,
                           INT width, INT height, BOOL *result);

GpStatus WINGDIPAPI
GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);

GpStatus WINGDIPAPI
GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);

GpStatus WINGDIPAPI
GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF* dstrect,
                   GDIPCONST GpRectF *srcrect, GpUnit unit, GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect* dstrect,
                    GDIPCONST GpRect *srcrect, GpUnit unit, GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);

GpStatus WINGDIPAPI
GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);

GpStatus
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    APMFileHeader *     apmFileHeader,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    );

GpStatus WINGDIPAPI
GdipCreateStreamOnFile(GDIPCONST WCHAR * filename, UINT access, IStream **stream);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf,
                          APMFileHeader * apmFileHeader, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf,
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromFile(GDIPCONST WCHAR* file, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromStream(IStream * stream, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders);

GpStatus WINGDIPAPI
GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders);

GpStatus WINGDIPAPI
GdipAddImageCodec(GDIPCONST ImageCodecInfo *codec);

GpStatus WINGDIPAPI
GdipRemoveImageCodec(GDIPCONST ImageCodecInfo *codec);

GpStatus WINGDIPAPI
GdipGetGraphicsPixel(GpGraphics* graphics, REAL x, REAL y, ARGB* argb);

GpStatus WINGDIPAPI
GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE * data);

GpStatus WINGDIPAPI
GdipGetGraphicsLayout(GpGraphics* graphics, GraphicsLayout* layout);

GpStatus WINGDIPAPI
GdipSetGraphicsLayout(GpGraphics* graphics, GDIPCONST GraphicsLayout layout);

//----------------------------------------------------------------------------
// FontFamily
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **FontFamily);

GpStatus WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *FontFamily);

GpStatus WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *FontFamily, GpFontFamily **clonedFontFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);


GpStatus WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily  *family,
    WCHAR                name[LF_FACESIZE],
    LANGID               language
);

GpStatus   WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, BOOL * IsStyleAvailable);

GpStatus WINGDIPAPI
GdipFontCollectionEnumerable(
    GpFontCollection* fontCollection,
    GpGraphics* graphics,
    INT *       numFound
);

GpStatus WINGDIPAPI GdipFontCollectionEnumerate(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound,
    GpGraphics*     graphics
);

//-----------------------------------
// New API
//-----------------------------------

GpStatus WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, UINT16 * EmHeight);

GpStatus WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellAscent);

GpStatus WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellDescent);

GpStatus WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, UINT16 * LineSpacing);


//----------------------------------------------------------------------------
// Font
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC        hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC        hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily  *fontFamily,
    REAL                 emSize,
    INT                  style,
    Unit                 unit,
    GpFont             **font
);

GpStatus WINGDIPAPI
GdipCloneFont(GpFont* font, GpFont** cloneFont);

GpStatus WINGDIPAPI
GdipDeleteFont(GpFont* font);

GpStatus WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family);

GpStatus WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style);

GpStatus WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size);

GpStatus WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit);

GpStatus WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, REAL *height);

GpStatus WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA);

GpStatus WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);

// FontCollection

GpStatus WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection* fontCollection,
    INT *       numFound
);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
);

GpStatus WINGDIPAPI
GdipInstallFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipUninstallFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
);

//----------------------------------------------------------------------------
// Text
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
);

GpStatus WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,
    INT                      *linesFilled
);

GpStatus WINGDIPAPI
GdipMeasureStringRegion(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       firstCharacterIndex,
    INT                       characterCount,
    GpRegion                 *region
);

GpStatus WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix
);

GpStatus WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix,
    RectF *boundingBox
);

GpStatus WINGDIPAPI
GdipDriverStringPointToCodepoint(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix,
    GDIPCONST PointF *hit,
    INT *index,
    BOOL *rightEdge,
    REAL *distance
);

//----------------------------------------------------------------------------
// String format APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format);

GpStatus WINGDIPAPI
GdipCloneStringFormat(GDIPCONST GpStringFormat *format, GpStringFormat **newFormat);

GpStatus WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags);

GpStatus WINGDIPAPI GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, INT *flags);

GpStatus WINGDIPAPI
GdipSetStringFormatLineSpacing(GpStringFormat *format, REAL amount,
                               LineSpacing method);

GpStatus WINGDIPAPI
GdipGetStringFormatLineSpacingAmount(GDIPCONST GpStringFormat *format, REAL *amount);
GpStatus WINGDIPAPI
GdipGetStringFormatLineSpacingMethod(GDIPCONST GpStringFormat *format, LineSpacing *method);

GpStatus WINGDIPAPI
GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatAlign(GDIPCONST GpStringFormat *format, StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatLineAlign(GpStringFormat *format,
                             StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat *format,
                             StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
);

GpStatus WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
);

GpStatus WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);

GpStatus WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, INT *hotkeyPrefix);

GpStatus WINGDIPAPI
GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, INT count, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, REAL *firstTabOffset, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT * count);

#ifdef DCR_USE_NEW_146933
GpStatus WINGDIPAPI
GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language, 
                                     StringDigitSubstitute substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat *format, LANGID *language, 
                                     StringDigitSubstitute *substitute);
#endif // DCR_USE_NEW_146933

//----------------------------------------------------------------------------
// Cached Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **cachedBitmap
);

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *graphics,
    GpCachedBitmap *cachedBitmap,
    INT x,
    INT y
);

#ifdef __cplusplus
}
#endif

#endif // !_FLATAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusfontcollection.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font collections (Installed and Private)
*
* Revision History:
*
*   03/07/2000 DChinn
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONTCOLL_H
#define _GDIPLUSFONTCOLL_H

inline
FontCollection::FontCollection()
{
    nativeFontCollection = NULL;
}

inline
FontCollection::~FontCollection()
{
}

inline INT
FontCollection::GetFamilyCount() const
{
    INT numFound = 0;

    lastResult = DllExports::GdipGetFontCollectionFamilyCount(
                             nativeFontCollection, &numFound);



    return numFound;
}

inline Status
FontCollection::GetFamilies(
    IN INT           numSought,
    OUT FontFamily * gpfamilies,
    OUT INT *        numFound
) const
{
    if (numSought <= 0 || gpfamilies == NULL || numFound == NULL)
    {
        return SetStatus(InvalidParameter);
    }

    GpFontFamily **nativeFamilyList = new GpFontFamily*[numSought];

    if (nativeFamilyList == NULL)
    {
        return SetStatus(OutOfMemory);
    }

    Status status = SetStatus(DllExports::GdipGetFontCollectionFamilyList(
        nativeFontCollection,
        numSought,
        nativeFamilyList,
        numFound
    ));

    for (INT i = 0; i < *numFound; i++)
    {
        DllExports::GdipCloneFontFamily(nativeFamilyList[i],
                                        &gpfamilies[i].nativeFamily);
    }

    delete [] nativeFamilyList;

    return status;
}

inline Status FontCollection::GetLastStatus () const
{
    return lastResult;
}

// protected method
inline Status
FontCollection::SetStatus(IN Status status) const
{
    lastResult = status;
    return lastResult;
}

inline
InstalledFontCollection::InstalledFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewInstalledFontCollection(&nativeFontCollection);
}

inline
InstalledFontCollection::~InstalledFontCollection()
{
}

inline Status
InstalledFontCollection::InstallFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipInstallFontFile(nativeFontCollection, filename));
}

inline Status
InstalledFontCollection::UninstallFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipUninstallFontFile(nativeFontCollection, filename));
}

inline
PrivateFontCollection::PrivateFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewPrivateFontCollection(&nativeFontCollection);
}

inline
PrivateFontCollection::~PrivateFontCollection()
{
    DllExports::GdipDeletePrivateFontCollection(&nativeFontCollection);
}

inline Status
PrivateFontCollection::AddFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipPrivateAddFontFile(nativeFontCollection, filename));
}

inline Status
PrivateFontCollection::AddMemoryFont(IN const void* memory,
                                     IN INT length)
{
    return SetStatus(DllExports::GdipPrivateAddMemoryFont(
        nativeFontCollection,
        memory,
        length));
}

#endif // _GDIPLUSFONTCOLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\inc41\gdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.hpp
*
* Abstract:
*
*   Various enumeration types
*
* Revision History:
*
*   12/11/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // for apps that need the best performance
    QualityModeHigh      = 2  // for apps that need the best rendering quality
};

//--------------------------------------------------------------------------
// Alpha compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------
enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,         // 0
    HatchStyleVertical,           // 1
    HatchStyleForwardDiagonal,    // 2
    HatchStyleBackwardDiagonal,   // 3
    HatchStyleCross,              // 4
    HatchStyleDiagonalCross       // 5
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter   = 0,
    LineJoinBevel   = 1,
    LineJoinRound   = 2
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};

//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (does exclude from)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------
enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1,
    PenAlignmentOutset       = 2,
    PenAlignmentLeft         = 3,
    PenAlignmentRight        = 4
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

//  These should probably be flags

//  Must have:
//      Regular = 0
//      Bold = 1
//      Italic = 2
//      BoldItalic = 3

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // no pixel offset
    PixelOffsetModeHalf     // offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSingleBitPerPixelGridFit = 0, // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap without hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap with hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------
enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfAldus,           // Aldus Placeable Metafile format
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

// Specifies the type of EMF to record
enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

// All persistent objects must have a type listed here
enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeMax = ObjectTypeImageAttributes,
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.
enum EmfPlusRecordType;
#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // we list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(