//==================== OFFICE PHONE ========================================
//
STDMETHODIMP 
CFaxSender::get_OfficePhone(
	BSTR *pbstrOfficePhone
)
/*++

Routine name : CFaxSender::get_OfficePhone

Routine description:

	return OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficePhone	            [out]    - the OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_OfficePhone"), hr);
		
    hr = GetBstr(pbstrOfficePhone, m_bstrOfficePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_OfficePhone (
	BSTR bstrOfficePhone
)
/*++

Routine name : CFaxSender::put_OfficePhone

Routine description:

	Set OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficePhone               [in]    - new OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_OfficePhone"), hr, _T("%s"), bstrOfficePhone);

	m_bstrOfficePhone = bstrOfficePhone;
	if (!m_bstrOfficePhone && bstrOfficePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE LOCATION ========================================
//
STDMETHODIMP 
CFaxSender::get_OfficeLocation(
	BSTR *pbstrOfficeLocation
)
/*++

Routine name : CFaxSender::get_OfficeLocation

Routine description:

	return OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficeLocation	            [out]    - the OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_OfficeLocation"), hr);

    hr = GetBstr(pbstrOfficeLocation, m_bstrOfficeLocation);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_OfficeLocation (
	BSTR bstrOfficeLocation
)
/*++

Routine name : CFaxSender::put_OfficeLocation

Routine description:

	Set OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficeLocation               [in]    - new OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_OfficeLocation"), hr, _T("%s"), bstrOfficeLocation);

	m_bstrOfficeLocation = bstrOfficeLocation;
	if (!m_bstrOfficeLocation && bstrOfficeLocation)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STATE ========================================
//
STDMETHODIMP 
CFaxSender::get_State(
	BSTR *pbstrState
)
/*++

Routine name : CFaxSender::get_State

Routine description:

	return State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrState	            [out]    - the State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_State"), hr);

    hr = GetBstr(pbstrState, m_bstrState);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_State (
	BSTR bstrState
)
/*++

Routine name : CFaxSender::put_State

Routine description:

	Set State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrState				[in]    - new State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_State"), hr, _T("%s"), bstrState);

	m_bstrState = bstrState;
	if (!m_bstrState && bstrState)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STREET ADDRESS ========================================
//
STDMETHODIMP 
CFaxSender::get_StreetAddress (
	BSTR *pbstrStreetAddress
)
/*++

Routine name : CFaxSender::get_StreetAddress

Routine description:

	return StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrStreetAddress	            [out]    - the StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_StreetAddress"), hr);

    hr = GetBstr(pbstrStreetAddress, m_bstrStreetAddress);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_StreetAddress (
	BSTR bstrStreetAddress
)
/*++

Routine name : CFaxSender::put_StreetAddress

Routine description:

	Set StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrStreetAddress				[in]    - new StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_StreetAddress"), hr, _T("%s"), bstrStreetAddress);

	m_bstrStreetAddress = bstrStreetAddress;
	if (!m_bstrStreetAddress && bstrStreetAddress)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TITLE ========================================
//
STDMETHODIMP 
CFaxSender::get_Title (
	BSTR *pbstrTitle
)
/*++

Routine name : CFaxSender::get_Title

Routine description:

	return Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTitle	            [out]    - the Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Title"), hr);

    hr = GetBstr(pbstrTitle, m_bstrTitle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Title (
	BSTR bstrTitle
)
/*++

Routine name : CFaxSender::put_Title

Routine description:

	Set Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTitle				[in]    - new Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Title"), hr, _T("%s"), bstrTitle);

	m_bstrTitle = bstrTitle;
	if (!m_bstrTitle && bstrTitle)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== ZIP CODE ========================================
//
STDMETHODIMP 
CFaxSender::get_ZipCode (
	BSTR *pbstrZipCode
)
/*++

Routine name : CFaxSender::get_ZipCode

Routine description:

	return ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrZipCode	            [out]    - the ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_ZipCode"), hr);

    hr = GetBstr(pbstrZipCode, m_bstrZipCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr);
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_ZipCode (
	BSTR bstrZipCode
)
/*++

Routine name : CFaxSender::put_ZipCode

Routine description:

	Set ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrZipCode				[in]    - new ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_ZipCode"), hr, _T("%s"), bstrZipCode);

	m_bstrZipCode = bstrZipCode;
	if (!m_bstrZipCode && bstrZipCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr);
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxSender::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxSender::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxSender::get_FaxNumber"), hr);

    hr = m_Recipient.get_FaxNumber(pbstrFaxNumber);
    return hr;
}

STDMETHODIMP 
CFaxSender::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxSender::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER(_T("CFaxSender::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	hr = m_Recipient.put_FaxNumber(bstrFaxNumber);
	return hr;
}


//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxSender::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxSender::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxSender::get_Name"), hr);

    hr = m_Recipient.get_Name(pbstrName);
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxSender::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Name"), hr, _T("%s"), bstrName);

	hr = m_Recipient.put_Name(bstrName);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxsecurity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSecurity.cpp

Abstract:

	Implementation of CFaxSecurity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxSecurity.h"
#include "faxutil.h"


//
//================== INFORMATION TYPE ===========================================
//
STDMETHODIMP 
CFaxSecurity::get_InformationType(
    long *plInformationType
)
/*++

Routine name : CFaxSecurity::get_InformationType

Routine description:

    Return current SecurityInformation value

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    plInformationType   [out]    - the SecurityInformation data to be returned

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxSecurity::get_InformationType"), hr);

    hr = GetLong(plInformationType, m_dwSecurityInformation);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxSecurity::put_InformationType(
    long lInformationType
)
/*++

Routine name : CFaxSecurity::put_InformationType

Routine description:

    Set SecurityInformation for the Descriptor

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    lInformationType    [in]    - the SecurityInformation data to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DWORD dwSecInfo = ( OWNER_SECURITY_INFORMATION  |
                        GROUP_SECURITY_INFORMATION  |
                        DACL_SECURITY_INFORMATION   |
                        SACL_SECURITY_INFORMATION );

    DBG_ENTER (_T("CFaxSecurity::put_InformationType"), hr, _T("%ld"), lInformationType);


    if (m_dwSecurityInformation != lInformationType)
    {
        //
        //  check that lInformationType is valid
        //

        if (0 == (lInformationType & dwSecInfo))
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("lInformationType does not contain good bits."), hr);
            AtlReportError(
                CLSID_FaxSecurity, 
                IDS_ERROR_INVALID_ARGUMENT, 
                IID_IFaxSecurity, 
                hr);
            return hr;
        }

        if (0 != (lInformationType & ~dwSecInfo))
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("lInformationType contains bad bits."), hr);
            AtlReportError(
                CLSID_FaxSecurity, 
                IDS_ERROR_INVALID_ARGUMENT, 
                IID_IFaxSecurity, 
                hr);
            return hr;
        }

        m_dwSecurityInformation = lInformationType;

        //
        //  we want to discard current Descriptor, because its security_information is different now
        //
        m_bInited = false;
    }

    return hr;
}

//
//================== DESCRIPTOR ===========================================
//
STDMETHODIMP 
CFaxSecurity::put_Descriptor(
    /*[out, retval]*/ VARIANT vDescriptor
)
/*++

Routine name : CFaxSecurity::put_Descriptor

Routine description:

	Set the given Security Descriptor

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    sabDescriptor               [in]    -   the given Security Descriptor


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::put_Descriptor"), hr);

    //
    //  First, initialize the FaxSecurity object
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Before filling the m_pbSD with the User's value, store its current value for roll-back
    //
    CFaxPtrLocal<BYTE>  pSDTmp;
    pSDTmp = m_pbSD.Detach();

    hr = VarByteSA2Binary(vDescriptor, &m_pbSD);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        goto exit;
    }

    //
    //  Check that we have got a valid Descriptor
    //
    if (!::IsValidSecurityDescriptor(m_pbSD))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("IsValidSecurityDescriptor(m_pbSD)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr);
        goto exit;
    }

    //
    //  Check that we have got a Self-Relative Descriptor
    //
    SECURITY_DESCRIPTOR_CONTROL     sdControl;
    DWORD                           dwRevision;
    if (!::GetSecurityDescriptorControl(m_pbSD, &sdControl, &dwRevision))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("GetSecurityDescriptorContrl(m_pbSD, &sdControl, ...)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr);
        goto exit;
    }

    if (!(sdControl & SE_SELF_RELATIVE))
    {
        //
        //  Security Descriptor is not Self-Relative
        //
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Security Descriptor is not Self-Relative"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_SDNOTSELFRELATIVE, IID_IFaxSecurity, hr);
        goto exit;
    }

    //
    //  we have valid Descriptor. Old one will be deallocated by pSecDescTmp
    //
    return hr;

exit:
    //
    //  Set previous value for the Descriptor
    //
    m_pbSD = pSDTmp.Detach();
    return hr;
}

STDMETHODIMP 
CFaxSecurity::get_Descriptor(
    /*[out, retval]*/ VARIANT *pvDescriptor
)
/*++

Routine name : CFaxSecurity::get_Descriptor

Routine description:

	Return the current Security Descriptor

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::get_Descriptor"), hr);

    //
    //  check that we have got good ptr
    //
    if (::IsBadWritePtr(pvDescriptor, sizeof(VARIANT)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvDescriptor, sizeof(VARIANT))"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr);
        return hr;
    }

    //
    //  Bring the data from the Server, if not brought yet
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Find size of the Security Descriptor
    //
    DWORD   dwLength = GetSecurityDescriptorLength(m_pbSD);

    //
    //  Convert the byte blob into variant containing Safe Array of bytes
    //
    hr = Binary2VarByteSA(m_pbSD, pvDescriptor, dwLength);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
		return hr;
    }

    return hr;
}

//
//================== SAVE ===========================================
//
STDMETHODIMP 
CFaxSecurity::Save()
/*++

Routine name : CFaxSecurity::Save

Routine description:

	Save the Object's contents to the Server

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::Save"), hr);

    //
    //  No changes ==> nothing to update at the Server
    //
    if (!m_bInited)
    {
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }

    //
    //  Set Security Data at the Server 
    //
    if (!FaxSetSecurity(hFaxHandle, m_dwSecurityInformation, m_pbSD))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetSecurity(hFaxHandle, dwSecInfo, m_pbSD)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }
    return hr;
}

//
//================== GET GRANTED RIGHTS ===========================================
//
STDMETHODIMP 
CFaxSecurity::get_GrantedRights(
    FAX_ACCESS_RIGHTS_ENUM *pGrantedRights    
)
/*++

Routine name : CFaxSecurity::get_GrantedRights

Routine description:

	Return current Access Rights of a user

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pGrantedRights      [out, retval]   -   Bit-Wise combination of the granted rights of the user

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::get_GrantedRights"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pGrantedRights, sizeof(FAX_ACCESS_RIGHTS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pGrantedRights, sizeof(FAX_ACCESS_RIGHTS_ENUM))"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
		return hr;
	}

    //
    //  Bring the data from the Server, if not brought yet
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	*pGrantedRights = FAX_ACCESS_RIGHTS_ENUM(m_dwAccessRights);
    return hr;
}
    
//
//================== REFRESH ===========================================
//
STDMETHODIMP 
CFaxSecurity::Refresh()
/*++

Routine name : CFaxSecurity::Refresh

Routine description:

	Refresh the Object's contents : bring new Security data from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::Refresh"), hr);
    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }
    //
    //  Ask the Server for the Access Rights Data
    //
    if (!FaxAccessCheckEx(hFaxHandle, MAXIMUM_ALLOWED, &m_dwAccessRights))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxAccessCheckEx(hFaxHandle, MAXIMUM_ALLOWED, &m_dwAccessRights)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }
    //
    //  Ask the Server for the SD
    //
    PSECURITY_DESCRIPTOR pSecDesc = NULL;
    if (!FaxGetSecurityEx(hFaxHandle, m_dwSecurityInformation, &pSecDesc))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetSecurityEx(hFaxHandle, m_dwSecurityInformation, &m_pSecurityDescriptor)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr);
        return hr;
    }
    //
    //  Copy the given SD to m_pbSD
    //
    DWORD   dwLength = GetSecurityDescriptorLength(pSecDesc);
    m_pbSD = (BYTE *)MemAlloc(dwLength);
    if (!m_pbSD)
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("MemAlloc(dwLength)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_OUTOFMEMORY, IID_IFaxSecurity, hr);
        FaxFreeBuffer(pSecDesc);
        return hr;
    }
    memcpy(m_pbSD, pSecDesc, dwLength);
    //
    //  Free the Server's memory for SD
    //
    FaxFreeBuffer(pSecDesc);
    m_bInited = true;
    return hr;
}   // CFaxSecurity::Refresh

//
//============================ SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxSecurity::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxSecurity::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info mechanism.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxSecurity
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxserver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxServer.h

Abstract:

	Declaration of the CFaxServer Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXSERVER_H_
#define __FAXSERVER_H_

#include "resource.h"       // main symbols
#include "FaxFolders.h"
#include "FaxReceiptOptions.h"
#include "FaxLoggingOptions.h"
#include "FaxActivity.h"
#include "FaxSecurity.h"
#include "FaxInboundRouting.h"
#include "FaxOutboundRouting.h"
#include <atlwin.h>
#include "FXSCOMEXCP.h"

//
//================= WINDOW FOR NOTIFICATIONS =================================
//

//
//  Forward Declaration
//
class CFaxServer;

class CNotifyWindow : public CWindowImpl<CNotifyWindow>
{
public:
    CNotifyWindow(CFaxServer *pServer)
    {
        DBG_ENTER(_T("CNotifyWindow::Ctor"));

        m_pServer = pServer;
        m_MessageId = RegisterWindowMessage(_T("{2E037B27-CF8A-4abd-B1E0-5704943BEA6F}"));
        if (m_MessageId == 0)
        {
            m_MessageId = WM_USER + 876;
        }
    }

    BEGIN_MSG_MAP(CNotifyWindow)
        MESSAGE_HANDLER(m_MessageId, OnMessage)
    END_MSG_MAP()

    UINT GetMessageId(void) { return m_MessageId; };

private:
    UINT        m_MessageId;
    CFaxServer  *m_pServer;

    LRESULT OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};


//
//================= REGISTRATION OF ROUTING EXTENSION METHODS ===========================
//

#define     DELIMITER                           _T(";")
#define     EXCEPTION_INVALID_METHOD_DATA       0xE0000001

BOOL CALLBACK RegisterMethodCallback(HANDLE FaxHandle, LPVOID Context, LPWSTR MethodName, 
                                     LPWSTR FriendlyName, LPWSTR FunctionName, LPWSTR Guid);

//
//=============== FAX SERVER ==================================================
//
class ATL_NO_VTABLE CFaxServer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxServer, &CLSID_FaxServer>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxServer, &IID_IFaxServer, &LIBID_FAXCOMEXLib>,
	public IFaxServerInner,
    public CFaxInitInner,    //  for Debug purposes only
    public IConnectionPointContainerImpl<CFaxServer>,
    public CProxyIFaxServerNotify< CFaxServer >
{
public:
	CFaxServer() : CFaxInitInner(_T("FAX SERVER")),
      m_faxHandle(NULL),
      m_pFolders(NULL),
      m_pActivity(NULL),
      m_pSecurity(NULL),
      m_pReceiptOptions(NULL),
      m_pLoggingOptions(NULL),
      m_pInboundRouting(NULL),
      m_pOutboundRouting(NULL),
      m_bVersionValid(false),
      m_pNotifyWindow(NULL),
      m_hEvent(NULL),
      m_lLastRegisteredMethod(0),
      m_EventTypes(fsetNONE)
	{
    }

	~CFaxServer()
	{
        //
        //  Disconnect
        //
        if (m_faxHandle)
        {
            Disconnect();
        }

        //
        //  free all the allocated objects
        //
        if (m_pFolders) 
        {
            delete m_pFolders;
        }

        if (m_pActivity) 
        {
            delete m_pActivity;
        }

        if (m_pSecurity) 
        {
            delete m_pSecurity;
        }

        if (m_pReceiptOptions) 
        {
            delete m_pReceiptOptions;
        }

        if (m_pLoggingOptions) 
        {
            delete m_pLoggingOptions;
        }

        if (m_pInboundRouting) 
        {
            delete m_pInboundRouting;
        }

        if (m_pOutboundRouting) 
        {
            delete m_pOutboundRouting;
        }
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSERVER)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxServer)
	COM_INTERFACE_ENTRY(IFaxServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IFaxServerInner)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)

END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CFaxServer)
    CONNECTION_POINT_ENTRY(DIID_IFaxServerNotify)
END_CONNECTION_POINT_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)(BSTR bstrServerName);

	STDMETHOD(GetDevices)(/*[out, retval]*/ IFaxDevices **ppDevices);
	STDMETHOD(get_Folders)(/*[out, retval]*/ IFaxFolders **ppFolders);
	STDMETHOD(get_Activity)(/*[out, retval]*/ IFaxActivity **ppActivity);
	STDMETHOD(get_Security)(/*[out, retval]*/ IFaxSecurity **ppSecurity);
	STDMETHOD(get_ReceiptOptions)(/*[out, retval]*/ IFaxReceiptOptions **ppReceiptOptions);
    STDMETHOD(get_LoggingOptions)(/*[out, retval]*/ IFaxLoggingOptions **ppLoggingOptions);
	STDMETHOD(get_InboundRouting)(/*[out, retval]*/ IFaxInboundRouting **ppInboundRouting);
	STDMETHOD(GetDeviceProviders)(/*[out, retval]*/ IFaxDeviceProviders **ppDeviceProviders);
	STDMETHOD(get_OutboundRouting)(/*[out, retval]*/ IFaxOutboundRouting **ppFaxOutboundRouting);

	STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
	STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
	STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
	STDMETHOD(get_ServerName)(/*[out, retval]*/ BSTR *pbstrServerName);
	STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
	STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_APIVersion)(/*[out,retval]*/ FAX_SERVER_APIVERSION_ENUM *pAPIVersion);

	STDMETHOD(SetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[in]*/ VARIANT vProperty);
	STDMETHOD(GetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[out, retval]*/ VARIANT *pvProperty);

	STDMETHOD(UnregisterDeviceProvider)(BSTR bstrProviderUniqueName);
	STDMETHOD(UnregisterInboundRoutingExtension)(BSTR bstrExtensionUniqueName);
    STDMETHOD(RegisterDeviceProvider)(
        /*[in]*/ BSTR bstrGUID, 
        /*[in]*/ BSTR bstrFriendlyName, 
        /*[in]*/ BSTR bstrImageName, 
        /*[in]*/ BSTR TspName,
        /*[in]*/ long lFSPIVersion);
    STDMETHOD(RegisterInboundRoutingExtension)(
        /*[in]*/ BSTR bstrExtensionName, 
        /*[in]*/ BSTR bstrFriendlyName, 
        /*[in]*/ BSTR bstrImageName, 
        /*[in]*/ VARIANT vMethods);

	STDMETHOD(ListenToServerEvents)(/*[in]*/ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);
    STDMETHOD(get_RegisteredEvents)(/*[out, retval]*/ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);

//  Internal Use
	STDMETHOD(GetHandle)(/*[out, retval]*/ HANDLE* pFaxHandle);
    BOOL GetRegisteredData(LPWSTR MethodName, LPWSTR FriendlyName, LPWSTR FunctionName, LPWSTR Guid);
    HRESULT ProcessMessage(FAX_EVENT_EX *pFaxEventInfo);

private:
	HANDLE                      m_faxHandle;
	CComBSTR                    m_bstrServerName;

    FAX_VERSION                 m_Version;
    FAX_SERVER_APIVERSION_ENUM  m_APIVersion;
    bool                        m_bVersionValid;

    long                        m_lLastRegisteredMethod;
    SAFEARRAY                   *m_pRegMethods;

    FAX_SERVER_EVENTS_TYPE_ENUM     m_EventTypes;

    //
    //  All these objects requires alive Server Object
    //  so their Reference Counting is done by the Server
    //
    CComContainedObject2<CFaxFolders>            *m_pFolders;
    CComContainedObject2<CFaxActivity>           *m_pActivity;
    CComContainedObject2<CFaxSecurity>           *m_pSecurity;
    CComContainedObject2<CFaxReceiptOptions>     *m_pReceiptOptions;
    CComContainedObject2<CFaxLoggingOptions>     *m_pLoggingOptions;
    CComContainedObject2<CFaxInboundRouting>     *m_pInboundRouting;
    CComContainedObject2<CFaxOutboundRouting>    *m_pOutboundRouting;

    //
    //  Window for Notifications
    //
    CNotifyWindow   *m_pNotifyWindow;
    HANDLE          m_hEvent;

//  Functions
    STDMETHOD(GetVersion)();
    void GetMethodData(/*[in]*/ BSTR    bstrAllString, /*[out]*/ LPWSTR strWhereToPut);
    void ClearNotifyWindow(void);

    typedef enum LOCATION { IN_QUEUE, OUT_QUEUE, IN_ARCHIVE, OUT_ARCHIVE } LOCATION;

    HRESULT ProcessJobNotification(DWORDLONG dwlJobId, FAX_ENUM_JOB_EVENT_TYPE eventType, 
        LOCATION place, FAX_JOB_STATUS *pJobStatus = NULL);
};

#endif //__FAXSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxsender.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSender.h

Abstract:

	Definition of Sender Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXSENDER_H_
#define __FAXSENDER_H_

#include "resource.h"
#include "FaxCommon.h"
#include "FaxRecipient.h"

//
//====================== FAX SENDER ===========================================================
//
class ATL_NO_VTABLE CFaxSender : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxSender, &IID_IFaxSender, &LIBID_FAXCOMEXLib>
{
public:
	CFaxSender()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSENDER)
DECLARE_NOT_AGGREGATABLE(CFaxSender)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxSender)
	COM_INTERFACE_ENTRY(IFaxSender)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	static HRESULT Create(IFaxSender **ppSender);
	STDMETHOD(GetSenderProfile)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pSenderProfile);
	STDMETHOD(PutSenderProfile)(/*[in]*/ FAX_PERSONAL_PROFILE *pSenderProfile);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxSender
	STDMETHOD(SaveDefaultSender)();
	STDMETHOD(LoadDefaultSender)();
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pbstrBillingCode);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR bstrBillingCode);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pbstrCity);
	STDMETHOD(put_City)(/*[in]*/ BSTR bstrCity);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pbstrCompany);
	STDMETHOD(put_Company)(/*[in]*/ BSTR bstrCompany);
	STDMETHOD(get_Country)(/*[out, retval]*/ BSTR *pbstrCountry);
	STDMETHOD(put_Country)(/*[in]*/ BSTR bstrCountry);
	STDMETHOD(get_Department)(/*[out, retval]*/ BSTR *pbstrDepartment);
	STDMETHOD(put_Department)(/*[in]*/ BSTR bstrDepartment);
	STDMETHOD(get_Email)(/*[out, retval]*/ BSTR *pbstrEmail);
	STDMETHOD(put_Email)(/*[in]*/ BSTR bstrEmail);
	STDMETHOD(get_HomePhone)(/*[out, retval]*/ BSTR *pbstrHomePhone);
	STDMETHOD(put_HomePhone)(/*[in]*/ BSTR bstrHomePhone);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_OfficePhone)(/*[out, retval]*/ BSTR *pbstrOfficePhone);
	STDMETHOD(put_OfficePhone)(/*[in]*/ BSTR bstrOfficePhone);
	STDMETHOD(get_OfficeLocation)(/*[out, retval]*/ BSTR *pbstrOfficeLocation);
	STDMETHOD(put_OfficeLocation)(/*[in]*/ BSTR bstrOfficeLocation);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(put_State)(/*[in]*/ BSTR bstrState);
	STDMETHOD(get_StreetAddress)(/*[out, retval]*/ BSTR *pbstrStreetAddress);
	STDMETHOD(put_StreetAddress)(/*[in]*/ BSTR bstrStreetAddress);
	STDMETHOD(get_Title)(/*[out, retval]*/ BSTR *pbstrTitle);
	STDMETHOD(put_Title)(/*[in]*/ BSTR bstrTitle);
	STDMETHOD(get_ZipCode)(/*[out, retval]*/ BSTR *pbstrZipCode);
	STDMETHOD(put_ZipCode)(/*[in]*/ BSTR bstrZipCode);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);

private:
	CComBSTR	m_bstrOfficeLocation;
	CComBSTR	m_bstrStreetAddress;
	CComBSTR	m_bstrOfficePhone;
	CComBSTR	m_bstrBillingCode;
	CComBSTR	m_bstrDepartment;
	CComBSTR	m_bstrHomePhone;
	CComBSTR	m_bstrCompany;
	CComBSTR	m_bstrCountry;
	CComBSTR	m_bstrZipCode;
	CComBSTR	m_bstrEmail;
	CComBSTR	m_bstrState;
	CComBSTR	m_bstrTitle;
	CComBSTR	m_bstrCity;
	CComBSTR	m_bstrTSID;

    CComObject<CFaxRecipient>   m_Recipient;
};

#endif //__FAXSENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxserver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxServer.cpp

Abstract:

    Implementation of CFaxServer

Author:

    Iv Garber (IvG) Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxServer.h"
#include "FaxDevices.h"
#include "FaxDeviceProviders.h"
#include <new>
//
//================== GET API VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_APIVersion(
    /*[out, retval]*/ FAX_SERVER_APIVERSION_ENUM *pAPIVersion
)
/*++

Routine name : CFaxServer::get_APIVersion

Routine description:

    Return API Version of the Fax Server.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    pAPIVersion                [out]    - ptr to the place to put the API Version of the Fax Server 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_APIVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Check the pointer we have got
    //
    if (::IsBadWritePtr(pAPIVersion, sizeof(FAX_SERVER_APIVERSION_ENUM))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pAPIVersion = m_APIVersion;
    return hr;
}

//
//====================== CLEAR NOTIFY WINDOW ============================
//
void 
CFaxServer::ClearNotifyWindow(void)
/*++

Routine name : CFaxServer::ClearNotifyWindow

Routine description:

    Clear Notify Window.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (m_pNotifyWindow && ::IsWindow(m_pNotifyWindow->m_hWnd))
    {
        m_pNotifyWindow->DestroyWindow();
    }

    if (m_pNotifyWindow)
    {
        delete m_pNotifyWindow;
        m_pNotifyWindow = NULL;
    }
    return;
}

//
//====================== PROCESS JOB NOTIFICATION =======================
//
HRESULT
CFaxServer::ProcessJobNotification(
    /*[in]*/ DWORDLONG   dwlJobId,
    /*[in]*/ FAX_ENUM_JOB_EVENT_TYPE eventType,
    /*[in]*/ LOCATION place,
    /*[in]*/ FAX_JOB_STATUS *pJobStatus
)
/*++

Routine name : CFaxServer::ProcessJobNotification

Routine description:

    Call appropriate Fire Method, for Jobs/Messages in Queues/Archives.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    dwlJobId                      [in]    - Id of the Job/Message
    eventType                     [in]    - Type of the Event
    place                         [in]    - Where the Job/Message sits
    pJobStatus                    [in]    - FAX_JOB_STATUS structure

Return Value:

    Standard HRESULT value.

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ProcessJobNotification"), 
        hr, 
        _T("JOBID=%ld EVENTTYPE=%ld PLACE=%d"), 
        dwlJobId, 
        eventType, 
        place);

    //
    //  Convert JobId from DWORDLONG into BSTR 
    //
    CComBSTR bstrJobId;
    hr = GetBstrFromDwordlong(dwlJobId,  &bstrJobId);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("GetBstrFromDwordlong(dwlJobId, &bstrJobId)"), hr);
        return hr;
    }

    //
    //  Check Type of the Event that happened
    //
    switch (eventType)
    {
    case FAX_JOB_EVENT_TYPE_ADDED:

        switch (place)
        {
        case IN_QUEUE:
            hr = Fire_OnIncomingJobAdded(this, bstrJobId);
            break;
        case OUT_QUEUE:
            hr = Fire_OnOutgoingJobAdded(this, bstrJobId);
            break;
        case IN_ARCHIVE:
            hr = Fire_OnIncomingMessageAdded(this, bstrJobId);
            break;
        case OUT_ARCHIVE:
            hr = Fire_OnOutgoingMessageAdded(this, bstrJobId);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(place == IN_QUEUE);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out Job/Message Added(this, bstrJobId)"), hr);
            return hr;
        }
        break;
    case FAX_JOB_EVENT_TYPE_REMOVED:

        switch (place)
        {
        case IN_QUEUE:
            hr = Fire_OnIncomingJobRemoved(this, bstrJobId);
            break;
        case OUT_QUEUE:
            hr = Fire_OnOutgoingJobRemoved(this, bstrJobId);
            break;
        case IN_ARCHIVE:
            hr = Fire_OnIncomingMessageRemoved(this, bstrJobId);
            break;
        case OUT_ARCHIVE:
            hr = Fire_OnOutgoingMessageRemoved(this, bstrJobId);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(place == IN_QUEUE);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out Job/Message Removed(this, bstrJobId)"), hr);
            return hr;
        }
        break;
    case FAX_JOB_EVENT_TYPE_STATUS:
        {
            if (!pJobStatus)
			{
				ATLASSERT(pJobStatus);
				hr = E_FAIL;
				return hr;
			}

            //
            //  Create Job Status Object to pass to the Events
            //
            CComObject<CFaxJobStatus>   *pJobStatusClass = NULL;
            pJobStatusClass = new (std::nothrow) CComObject<CFaxJobStatus>;
            if (!pJobStatusClass)
            {
                //
                //  Out of Memory
                //
                CALL_FAIL(MEM_ERR, _T("new CComObject<CFaxJobStatus>"), hr);
                return hr;
            }

            //
            //  Init the Object
            //
            hr = pJobStatusClass->Init(pJobStatus);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("pJobStatusClass->Init(pJobStatus)"), hr);
                delete pJobStatusClass;
                return hr;
            }

            //
            //  Query the Interface from the Object
            //
            CComPtr<IFaxJobStatus>      pFaxJobStatus = NULL;
            hr = pJobStatusClass->QueryInterface(IID_IFaxJobStatus, (void **) &pFaxJobStatus);
            if (FAILED(hr) || !pFaxJobStatus)
            {
                CALL_FAIL(GENERAL_ERR, _T("pJobStatusClass->QueryInterface(pFaxJobStatus)"), hr);
                delete pJobStatusClass;
                return hr;
            }

            switch (place)
            {
            case IN_QUEUE:
                hr = Fire_OnIncomingJobChanged(this, bstrJobId, pFaxJobStatus);
                break;
            case OUT_QUEUE:
                hr = Fire_OnOutgoingJobChanged(this, bstrJobId, pFaxJobStatus);
                break;
            default:
                //
                //  assert (FALSE)
                //
                ATLASSERT(place == IN_QUEUE);  
                hr = E_FAIL;
                return hr;
            }

            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out JobChanged(this, bstrJobId)"), hr);
                return hr;
            }
        }
        break;

    default:
        //
        //  assert (FALSE)
        //
        ATLASSERT(eventType == FAX_JOB_EVENT_TYPE_STATUS);  
        hr = E_FAIL;
        return hr;
    }

    return hr;
}

//
//================= PROCESS MESSAGE ============================================
//
HRESULT
CFaxServer::ProcessMessage(
    FAX_EVENT_EX *pFaxEventInfo
)
/*++

Routine name : CFaxServer::ProcessMessage

Routine description:

    Fire appropriate Message

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pFaxEventInfo                 [TBD]    - Information about current Event

Return Value:

    None.

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ProcessMessage"), hr);

    if (!m_faxHandle)
    {
        //
        //  Fax Server already disconnected
        //
        VERBOSE(DBG_WARNING, _T("FaxServer already disconnected."));
        return hr;
    }

    switch (pFaxEventInfo->EventType)
    {
    case FAX_EVENT_TYPE_IN_QUEUE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            IN_QUEUE,
            pFaxEventInfo->EventInfo.JobInfo.pJobData);
        break;

    case FAX_EVENT_TYPE_OUT_QUEUE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            OUT_QUEUE,
            pFaxEventInfo->EventInfo.JobInfo.pJobData);
        break;

    case FAX_EVENT_TYPE_IN_ARCHIVE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            IN_ARCHIVE);
        break;

    case FAX_EVENT_TYPE_OUT_ARCHIVE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            OUT_ARCHIVE);
        break;

    case FAX_EVENT_TYPE_CONFIG:

        switch (pFaxEventInfo->EventInfo.ConfigType)
        {
        case FAX_CONFIG_TYPE_RECEIPTS:
            hr = Fire_OnReceiptOptionsChange(this);
            break;
        case FAX_CONFIG_TYPE_ACTIVITY_LOGGING:
            hr = Fire_OnActivityLoggingConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUTBOX:
            hr = Fire_OnOutgoingQueueConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_SENTITEMS:
            hr = Fire_OnOutgoingArchiveConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_INBOX:
            hr = Fire_OnIncomingArchiveConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_SECURITY:
            hr = Fire_OnSecurityConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_EVENTLOGS:
            hr = Fire_OnEventLoggingConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_DEVICES:
            hr = Fire_OnDevicesConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUT_GROUPS:
            hr = Fire_OnOutboundRoutingGroupsConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUT_RULES:
            hr = Fire_OnOutboundRoutingRulesConfigChange(this);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(pFaxEventInfo->EventInfo.ConfigType == FAX_CONFIG_TYPE_OUT_RULES);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On <...> ConfigChange(this)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_ACTIVITY:

        hr = Fire_OnServerActivityChange(this, 
            pFaxEventInfo->EventInfo.ActivityInfo.dwIncomingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwRoutingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwOutgoingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwQueuedMessages);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnServerActivityChange(this, ...)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_QUEUE_STATE:

        hr = Fire_OnQueuesStatusChange(this, 
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_OUTBOX_BLOCKED), 
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_OUTBOX_PAUSED),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_INCOMING_BLOCKED));
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnQueueStatusChange(this, ...)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_NEW_CALL:
        {
            CComBSTR    bstrCallerId = pFaxEventInfo->EventInfo.NewCall.lptstrCallerId;
            if (pFaxEventInfo->EventInfo.NewCall.lptstrCallerId && !bstrCallerId)
            {
                CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), E_OUTOFMEMORY);
                return hr;
            }

            hr = Fire_OnNewCall(this, 
                pFaxEventInfo->EventInfo.NewCall.hCall,
                pFaxEventInfo->EventInfo.NewCall.dwDeviceId,
                bstrCallerId);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Fire_OnNewCall(this, ...)"), hr);
                return hr;
            }
        }
        break;

    case FAX_EVENT_TYPE_FXSSVC_ENDED:

        hr = Fire_OnServerShutDown(this);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnServerShutDown(this)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_DEVICE_STATUS:

        hr = Fire_OnDeviceStatusChange(this, 
            pFaxEventInfo->EventInfo.DeviceStatus.dwDeviceId,
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_POWERED_OFF),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_SENDING),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_RECEIVING),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_RINGING));
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnDeviceStatusChange(this, dwDeviceId, ...)"), hr);
            return hr;
        }
        break;

    default:
        //
        //  assert (FALSE)
        //
        ATLASSERT(pFaxEventInfo->EventType == FAX_EVENT_TYPE_FXSSVC_ENDED);  
        hr = E_FAIL;
        return hr;
    }

    return hr;
}

//
//========== MESSAGE HANDLER FUNCTION ======================================
//
LRESULT 
CNotifyWindow::OnMessage(UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
)
/*++

Routine name : CNotifyWindow::OnMessage

Routine description:

    Get the Message and call Server's ProcessMessage.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    uMsg                          [in]    - Msg Id
    wParam                        [in]    - wParam
    lParam                        [in]    - LParam
    bHandled                      [in,out]    - bHandled

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(_T("CNotifyWindow::OnMessage"));

    //
    //  Check that lParam is valid
    //
    if (!lParam)
    {
        CALL_FAIL(GENERAL_ERR, _T("(!lParam)"), E_FAIL);
        return 0;
    }

    if (::IsBadReadPtr((FAX_EVENT_EX *)lParam, sizeof(FAX_EVENT_EX)))
    {
        CALL_FAIL(GENERAL_ERR, _T("(::IsBadReadPtr((FAX_EVENT_EX *)lParam, sizeof(FAX_EVENT_EX))"), E_FAIL);
        return 0;
    }

    if (((FAX_EVENT_EX *)lParam)->dwSizeOfStruct != sizeof(FAX_EVENT_EX))
    {
        CALL_FAIL(GENERAL_ERR, _T("(((FAX_EVENT_EX *)lParam)->dwSizeOfStruct != sizeof(FAX_EVENT_EX))"), E_FAIL);
        return 0;
    }

    //
    //  Call Server to Process the Message
    //
    if (m_pServer)
    {
        HRESULT hr = S_OK;
        hr = m_pServer->ProcessMessage((FAX_EVENT_EX *)lParam);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("m_pServer->ProcessMessage()"), hr);
        }
    }

    //
    //  Free the Buffer
    //
    FaxFreeBuffer((void *)lParam);
    return 0;
}

//
//================ GET METHOD DATA ================================================
//
void
CFaxServer::GetMethodData(
    /*[in]*/ BSTR    bstrAllString,
    /*[out]*/ LPWSTR strWhereToPut
)
/*++

Routine name : CFaxServer::GetMethodData

Routine description:

    Read from bstrAllString data upto DELIMITER and store it in strWhereToPut. 
    Used in GetRegisteredData for Extension Method Registration.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    bstrAllString                 [TBD]    - in subsequent calls
    strWhereToPut                 [TBD]    - where to put the value that was readed from the bstrAllString.

--*/
{
    BOOL bRes = TRUE;
    DBG_ENTER(_T("CFaxServer::GetMethodData()"));

    //
    //  Find Method Name
    //
    BSTR bstrTmp;
    bstrTmp = _tcstok(bstrAllString, DELIMITER);
    if (!bstrTmp)
    {
        CALL_FAIL(MEM_ERR, _T("_tcstok(bstrAllString, DELIMITER))"), bRes);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    //
    //  Check that length of the readen data
    //
    if (_tcslen(bstrTmp) > 100)
    {
        //
        //  Error : exceeds the limit
        //
        CALL_FAIL(GENERAL_ERR, _T("(_tcslen(bstrTmp) > 100)"), E_FAIL);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    memcpy(strWhereToPut, bstrTmp, (sizeof(TCHAR) * (_tcslen(bstrTmp) + 1)));
    return;
}

//
//============= GET REGISTERED DATA =========================================
//
BOOL
CFaxServer::GetRegisteredData(
    /*[out]*/ LPWSTR MethodName, 
    /*[out]*/ LPWSTR FriendlyName, 
    /*[out]*/ LPWSTR FunctionName, 
    /*[out]*/ LPWSTR Guid
)
/*++

Routine name : CFaxServer::GetRegisteredData

Routine description:

    Return data about specific Method being registered.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    MethodName                    [TBD]    - Name of the Method
    FriendlyName                  [TBD]    - Friendly Name of the Method
    FunctionName                  [TBD]    - Function Name of the Method
    Guid                          [TBD]    - GUID of the Method

Return Value:

    TRUE if Method Data is filled ok, FALSE if all the methods already registered.

Notes:

    The function raises an exception when any error happens.    

--*/
{
    BOOL    bRes = TRUE;
    DBG_ENTER(_T("CFaxServer::GetRegisteredData"), bRes);

    //
    //  Check if we already finished the array
    //
    if (m_pRegMethods->rgsabound[0].cElements == m_lLastRegisteredMethod)
    {
        bRes = FALSE;
        CALL_FAIL(GENERAL_ERR, _T("We have reached the End of the Array"), bRes);
        return bRes;
    }

    CComBSTR    bstrMethodData;
    HRESULT hr = SafeArrayGetElement(m_pRegMethods, &m_lLastRegisteredMethod, &bstrMethodData);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetElement(m_pRegMethods, ...)"), hr);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    GetMethodData(bstrMethodData, MethodName);
    GetMethodData(NULL, FriendlyName);
    GetMethodData(NULL, FunctionName);
    GetMethodData(NULL, Guid);

    //
    //  Increase the Index of the SafeArray
    //
    m_lLastRegisteredMethod++;
    return bRes;
}

//
//=================== REGISTER METHOD CALLBACK ===============================
//
BOOL CALLBACK RegisterMethodCallback(
    /*[in]*/ HANDLE FaxHandle, 
    /*[in]*/ LPVOID Context, 
    /*[out]*/ LPWSTR MethodName, 
    /*[out]*/ LPWSTR FriendlyName, 
    /*[out]*/ LPWSTR FunctionName, 
    /*[out]*/ LPWSTR Guid
)
{
    BOOL    bRes = TRUE;
    DBG_ENTER(_T("RegisterMethodCallback"), bRes);

    bRes = ((CFaxServer *)Context)->GetRegisteredData(MethodName, FriendlyName, FunctionName, Guid);
    return bRes;
}

//
//=================== LISTEN TO SERVER EVENTS ===============================
//
STDMETHODIMP
CFaxServer::ListenToServerEvents(
    /*[in]*/ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes
)
/*++

Routine name : CFaxServer::ListenToServerEvents

Routine description:

    Starts or stops listening to Server Events.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    EventTypes                   [in]    - Events to listen to.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ListenToServerEvents"), hr, _T("Events=%ld"), EventTypes);

    //
    //  Check Fax Handle
    //
    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    HANDLE  hEvent = NULL;
    if (EventTypes > fsetNONE)
    {
        if (!m_pNotifyWindow)
        {
            //
            //  Create new Window
            //
            m_pNotifyWindow = new (std::nothrow) CNotifyWindow(this);
            if (!m_pNotifyWindow)
            {
                //
                //  Out of Memory
                //
                hr = E_OUTOFMEMORY;
                Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxServer, hr);
                CALL_FAIL(MEM_ERR, _T("new CNotifyWindow(this)"), hr);
                return hr;
            }

            RECT    rcRect;
            ZeroMemory(&rcRect, sizeof(rcRect));

            m_pNotifyWindow->Create(NULL, rcRect, NULL, WS_POPUP, 0x0, 0);
            if (!::IsWindow(m_pNotifyWindow->m_hWnd))
            {
                //
                //  Failed to Create Window
                //
                hr = E_FAIL;
                CALL_FAIL(GENERAL_ERR, _T("m_pNotifyWindow->Create(NULL, rcRect)"), hr);
                ClearNotifyWindow();
                Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
                return hr;
            }
        }

        //
        //  Register for new Set of Events 
        //
        if (!FaxRegisterForServerEvents(m_faxHandle, 
            EventTypes, 
            NULL, 
            0, 
            m_pNotifyWindow->m_hWnd, 
            m_pNotifyWindow->GetMessageId(), 
            &hEvent))
        {
            //
            //  Failed to Register given Set of Events
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxRegisterForServerEvents(m_faxHandle, lEventTypes, ...)"), hr);
            ClearNotifyWindow();
            return hr;
        }
    }

    //
    //  Unregister from the previous set of Events, if there was one
    //
    if (m_hEvent)
    {
        if (!FaxUnregisterForServerEvents(m_hEvent))
        {
            //
            //  Failed to Unregister given Set of Events
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterForServerEvents(m_hEvent)"), hr);

            //
            //  Return Error only when Caller specially wanted to Unregister.
            //  Otherwise, debug Warning is enough.
            //
            if (EventTypes == fsetNONE)
            {
                Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
            }
        }
    }
    //
    //  store the new Listening HANDLE for future UNRegistration
    //
    m_hEvent = hEvent;
    if (m_hEvent == NULL)
    {
        //
        // We're not listening to any events - dismiss the hidden window
        //
        ClearNotifyWindow();
    }
    m_EventTypes = EventTypes;
    return hr;
}

//
//=================== GET REGISTERED EVENTS ===============================
//
STDMETHODIMP
CFaxServer::get_RegisteredEvents(
    /*[out, retval]*/ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes
)
/*++

Routine name : CFaxServer::get_RegisteredEvents

Routine description:

    Return Bit-Wise Combination of Events the Fax Server is Listening to

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pEventTypes                   [out]    - the Event Types to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxServer::get_RegisteredEvents"), hr);

    //
    //  Check the Fax Service Handle
    //
    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check the pointer we have got
    //
    if (::IsBadWritePtr(pEventTypes, sizeof(FAX_SERVER_EVENTS_TYPE_ENUM))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pEventTypes = m_EventTypes;
    return hr;
}


//
//=================== REGISTER DEVICE PROVIDER ===============================
//
STDMETHODIMP
CFaxServer::RegisterDeviceProvider(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ BSTR bstrFriendlyName,
    /*[in]*/ BSTR bstrImageName, 
    /*[in]*/ BSTR bstrTspName,
    /*[in]*/ long lFSPIVersion
)
/*++

Routine name : CFaxServer::RegisterDeviceProvider

Routine description:

    Register the FSP

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                      [in]    - GUID of the FSP
    bstrFriendlyName              [in]    - Frienly Name of the FSP
    bstrImageName                 [in]    - Image Name of the FSP
    TspName                       [in]    - TspName of the FSP
    FSPIVersion                   [in]    - Version of the FSP interface

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::RegisterDeviceProvider"), 
        hr,
        _T("GUID=%s FriendlyName=%s ImageName=%s TspNameName=%s Version=%d"), 
        bstrGUID, 
        bstrFriendlyName, 
        bstrImageName, 
        bstrTspName,
        lFSPIVersion);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check if GUID is valid
    //
    hr = IsValidGUID(bstrGUID);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("IsValidGUID(bstrGUID)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    //
    //  Register the FSP
    //
    if (!FaxRegisterServiceProviderEx(m_faxHandle, 
        bstrGUID, 
        bstrFriendlyName, 
        bstrImageName, 
        bstrTspName, 
        lFSPIVersion,
        0))             //  capabilities
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxRegisterServiceProviderEx(m_faxHandle, bstrUniqueName, ...)"), hr);
        return hr;
    }

    return hr;
}

//
//================= REGISTER INBOUND ROUTING EXTENSION ================================
//
STDMETHODIMP
CFaxServer::RegisterInboundRoutingExtension(
    /*[in]*/ BSTR bstrExtensionName,
    /*[in]*/ BSTR bstrFriendlyName, 
    /*[in]*/ BSTR bstrImageName, 
    /*[in]*/ VARIANT vMethods
)
/*++

Routine name : CFaxServer::RegisterInboundRoutingExtension

Routine description:

    Register Inbound Routing Extension.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrExtensionName             [in]    - Extension Name
    bstrFriendlyName              [in]    - Friendly Name
    bstrImageName                 [in]    - Image Name
    vMethods                      [in]    - SafeArray of the Methods Data

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::RegisterInboundRoutingExtension"), hr, _T("Name=%s Friendly=%s Image=%s"),bstrExtensionName, bstrFriendlyName, bstrImageName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check the Validity of the SafeArray
    //
    if (vMethods.vt != (VT_ARRAY | VT_BSTR))
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("(vMethods.vt != VT_ARRAY | VT_BSTR)"), hr);
        return hr;
    }

    m_pRegMethods = vMethods.parray;
    if (!m_pRegMethods)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("!m_pRegMethods ( = vMethods.parray )"), hr);
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        return hr;        
    }

    if (SafeArrayGetDim(m_pRegMethods) != 1)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetDim(m_pRegMethods) != 1"), hr);
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        return hr;        
    }

    if (m_pRegMethods->rgsabound[0].lLbound != 0)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_pRegMethods->rgsabound[0].lLbound != 0"), hr);
        return hr;        
    }

    //
    //  Register the IR Extension
    //
    m_lLastRegisteredMethod = 0;
    if (!FaxRegisterRoutingExtension(m_faxHandle, 
        bstrExtensionName, 
        bstrFriendlyName, 
        bstrImageName, 
        RegisterMethodCallback, 
        this))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxRegisterRoutingExtension(m_faxHandle, bstrExtensionName, ...)"), hr);
        return hr;
    }

    return hr;
}

//
//========== UNREGISTER INBOUND ROUTING EXTENSION ==============================================
//
STDMETHODIMP
CFaxServer::UnregisterInboundRoutingExtension(
    /*[in]*/ BSTR bstrExtensionUniqueName
)
/*++

Routine name : CFaxServer::UnregisterExtensionUniqueName

Routine description:

    Unregister the Inbound Routing Extension

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrExtensionUniqueName     - Unique Name of the IR Extension to Unregister

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::UnregisterInboundRoutingExtension"), hr, _T("Unique Name =%s"), bstrExtensionUniqueName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Unregister the given Routing Extension
    //
    if (!FaxUnregisterRoutingExtension(m_faxHandle, bstrExtensionUniqueName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterRoutingExtension(m_faxHandle, bstrExtensionUniqueName)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//========== UNREGISTER DEVICE PROVIDER ==============================================
//
STDMETHODIMP
CFaxServer::UnregisterDeviceProvider(
    /*[in]*/ BSTR bstrUniqueName
)
/*++

Routine name : CFaxServer::UnregisterDeviceProvider

Routine description:

    Unregister the Device Provider

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrUniqueName      [in]    - UniqueName of the Device Provider to Unregister

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::UnregisterDeviceProvider"), hr, _T("UniqueName=%s"), bstrUniqueName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Unregister the given Device Provider
    //
    if (!FaxUnregisterServiceProviderEx(m_faxHandle, bstrUniqueName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterServiceProviderEx(m_faxHandle, bstrUniqueName)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//===================== GET EXTENSION PROPERTY ===============================================
//
STDMETHODIMP
CFaxServer::GetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : CFaxServer::GetExtensionProperty

Routine description:

    Retrieves the global Extension Data from the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::GetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::GetExtensionProperty(this, 0, bstrGUID, pvProperty);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
};

//
//============= SET EXTENSION PROPERTY =============================
//
STDMETHODIMP
CFaxServer::SetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : CFaxServer::SetExtensionProperty

Routine description:

    Stores Extension Configuration Property at Server level.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                      [in]    - GUID of the Property
    vProperty                     [in]    - the Property to Store : SafeArray of Bytes

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::SetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::SetExtensionProperty(this, 0, bstrGUID, vProperty);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;

}

//
//================== GET DEBUG ==============================
//
STDMETHODIMP
CFaxServer::get_Debug(
    /*[out, retval]*/ VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxServer::get_Debug

Routine description:

    Return Whether Server is in Debug Mode.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbDebug                     [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_Debug"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetVariantBool(pbDebug, bool2VARIANT_BOOL((m_Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false));
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MINOR BUILD ==============================
//
STDMETHODIMP
CFaxServer::get_MinorBuild(
    /*[out, retval]*/ long *plMinorBuild
)
/*++

Routine name : CFaxServer::get_MinorBuild

Routine description:

    Return Minor Build of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMinorBuild                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MinorBuild"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMinorBuild, m_Version.wMinorBuildNumber);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MAJOR BUILD ==============================
//
STDMETHODIMP
CFaxServer::get_MajorBuild(
    /*[out, retval]*/ long *plMajorBuild
)
/*++

Routine name : CFaxServer::get_MajorBuild

Routine description:

    Return Major Build of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMajorBuild                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MajorBuild"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMajorBuild, m_Version.wMajorBuildNumber);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MINOR VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_MinorVersion(
    /*[out, retval]*/ long *plMinorVersion
)
/*++

Routine name : CFaxServer::get_MinorVersion

Routine description:

    Return Minor Version of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMinorVersion                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MinorVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMinorVersion, m_Version.wMinorVersion);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET VERSION ==============================
//
STDMETHODIMP
CFaxServer::GetVersion()
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::GetVersion"), hr);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Get Version from the Fax Server
    //
    ZeroMemory(&m_Version, sizeof(FAX_VERSION));
    m_Version.dwSizeOfStruct = sizeof(FAX_VERSION);
    if (!FaxGetVersion(m_faxHandle, &m_Version))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetVersion(m_faxHandle, &m_Version))"), hr);
        return hr;
    }

    //
    //  Check that we have got good Version struct
    //
    if (m_Version.dwSizeOfStruct != sizeof(FAX_VERSION))
    {
        hr = E_FAIL;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Version.dwSizeOfStruct != sizeof(FAX_VERSION)"), hr);
        return hr;
    }
    ATLASSERT(m_Version.bValid);

    //
    //  Get API Version from the Fax Server
    //
    if (!FaxGetReportedServerAPIVersion(m_faxHandle, LPDWORD(&m_APIVersion)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReportedServerAPIVersion(m_faxHandle, &m_APIVersion))"), hr);
        return hr;
    }

    //
    //  m_Version & m_APIVersion are valid and OK
    //  
    m_bVersionValid = true;
    return hr;
}

//
//================== GET MAJOR VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_MajorVersion(
    /*[out, retval]*/ long *plMajorVersion
)
/*++

Routine name : CFaxServer::get_MajorVersion

Routine description:

    Return Major Version of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMajorVersion                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MajorVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMajorVersion, m_Version.wMajorVersion);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET OUTBOUND ROUTING OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_OutboundRouting(
    IFaxOutboundRouting **ppOutboundRouting
)
/*++

Routine name : CFaxServer::get_OutboundRouting

Routine description:

    Return Outbound Routing Shortcut Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppOutboundRouting        [out]    - the Outbound Routing Object

Return Value:

    Standard HRESULT code

Notes:

    FaxOutboundRouting is Contained Object, because of :
    a)  It needs Ptr to Fax Server, to create Groups/Rules Collections 
        each time it is asked to.
    b)  Fax Server caches it, to allow fast dot notation ( Server.OutboundRouting.<...> )

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_OutboundRouting"), hr);

    CObjectHandler<CFaxOutboundRouting, IFaxOutboundRouting>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutboundRouting, &m_pOutboundRouting, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET DEVICES OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::GetDevices(
    IFaxDevices **ppDevices
)
/*++

Routine name : CFaxServer::get_Devices

Routine description:

    Return Devices Collection Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppDevices           [out]    - the Devices Collection Object

Return Value:

    Standard HRESULT code

Notes:
    
    Devices is a collection. It is not cached by the Server. 
    Each time the function is called, the new collection is created. 
    This enables the user to refresh the collection.

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Devices"), hr);

    CObjectHandler<CFaxDevices, IFaxDevices>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppDevices, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET DEVICE PROVIDERS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::GetDeviceProviders(
    IFaxDeviceProviders **ppDeviceProviders
)
/*++

Routine name : CFaxServer::get_DeviceProviders

Routine description:

    Return Device Providers Collection Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppDeviceProviders        [out]    - the Device Providers Collection Object

Return Value:

    Standard HRESULT code

Notes:
    
    Device Providers is a collection. It is not cached by the Server. 
    Each time the function is called, the new collection is created. 
    This enables the user to refresh the collection.

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_DeviceProviders"), hr);

    CObjectHandler<CFaxDeviceProviders, IFaxDeviceProviders>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppDeviceProviders, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET INBOUND ROUTING OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_InboundRouting(
    IFaxInboundRouting **ppInboundRouting
)
/*++

Routine name : CFaxServer::get_InboundRouting

Routine description:

    Return Inbound Routing Shortcut Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppInboundRouting        [out]    - the Inbound Routing Object

Return Value:

    Standard HRESULT code

Notes:

    FaxInboundRouting is Contained Object, because of :
    a)  It needs Ptr to Fax Server, to create Extensions/Methods Collections 
        each time it is asked to.
    b)  Fax Server caches it, to allow fast dot notation ( Server.InboundRouting.<...> )

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_InboundRouting"), hr);

    CObjectHandler<CFaxInboundRouting, IFaxInboundRouting>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppInboundRouting, &m_pInboundRouting, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET SECURITY OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Security(
    IFaxSecurity **ppSecurity
)
/*++

Routine name : CFaxServer::get_Security

Routine description:

    Return Security Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppSecurity        [out]    - the Security Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Security"), hr);

    CObjectHandler<CFaxSecurity, IFaxSecurity>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppSecurity, &m_pSecurity, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET ACTIVITY OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Activity(
    IFaxActivity **ppActivity
)
/*++

Routine name : CFaxServer::get_Activity

Routine description:

    Return Activity Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppActivity        [out]    - the Activity Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Activity"), hr);

    CObjectHandler<CFaxActivity, IFaxActivity>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppActivity, &m_pActivity, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET LOGGING OPTIONS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_LoggingOptions(
    IFaxLoggingOptions **ppLoggingOptions
)
/*++

Routine name : CFaxServer::get_LoggingOptions

Routine description:

    Return Logging Options Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppLoggingOptions        [out]    - the Logging Options Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_LoggingOptions"), hr);

    CObjectHandler<CFaxLoggingOptions, IFaxLoggingOptions>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppLoggingOptions, &m_pLoggingOptions, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//==================== GET HANDLE =====================================
//
STDMETHODIMP
CFaxServer::GetHandle(
    /*[out, retval]*/ HANDLE* pFaxHandle
)
/*++

Routine name : CFaxServer::GetHandle

Routine description:

    Return Handle to the Fax Server, if possible

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    seqId                         [in]    - the seqId of the Caller

Return Value:

    HANDLE to the Fax Server

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::GetHandle"), hr);

    if (::IsBadWritePtr(pFaxHandle, sizeof(HANDLE *))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pFaxHandle = m_faxHandle;
    return hr;

}   //  CFaxServer::GetHandle

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxServer::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxServer::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxServer,
        &IID_IFaxFolders,           // Contained object
        &IID_IFaxActivity,          // Contained object
        &IID_IFaxSecurity,          // Contained object
        &IID_IFaxReceiptOptions,    // Contained object
        &IID_IFaxLoggingOptions,    // Contained object
        &IID_IFaxInboundRouting,    // Contained object
        &IID_IFaxOutboundRouting    // Contained object
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
//================== GET FOLDERS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Folders(
IFaxFolders **ppFolders
)
/*++

Routine name : CFaxServer::get_Folders

Routine description:

    Return Folders Shortcut Object

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pFaxFolders                  [out]    - Fax Folders Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Folders"), hr);

    CObjectHandler<CFaxFolders, IFaxFolders>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppFolders, &m_pFolders, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== DISCONNECT =============================================
// {CR}
STDMETHODIMP 
CFaxServer::Disconnect()
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::Disconnect"), hr);

    if (!m_faxHandle)
    {
        return hr;
    }

    //
    //  first UnListen, while we still connected
    //
    hr = ListenToServerEvents(fsetNONE);
    if (FAILED(hr))
    {
        //
        //  Show the error, but continue
        //
        CALL_FAIL(GENERAL_ERR, _T("ListenToServerEvents(fsetNONE)"), hr);
    }

    if (!FaxClose(m_faxHandle))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxClose()"), hr);
        return hr;
    }

    m_faxHandle = NULL;
    m_bstrServerName.Empty();
    return hr;
}


//
//=================== CONNECT =======================================
//{CR}
STDMETHODIMP CFaxServer::Connect(
    BSTR bstrServerName
)
/*++

Routine name : CFaxServer::Connect

Routine description:

    Connect to the given Fax Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrServerName                [in]    - Name of the Fax Server to Connect to

Return Value:

    Standard HRESULT code

--*/
{
    HANDLE      h_tmpFaxHandle;
    DWORD       dwServerAPIVersion;
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::Connect"), hr, _T("%s"), bstrServerName);

    if (!FaxConnectFaxServer(m_bstrServerName, &h_tmpFaxHandle))
    {
        //
        //  Failed to Connect to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxConnectFaxServer()"), hr);
        return hr;
    }
    ATLASSERT(h_tmpFaxHandle);

    //
    //  Get API Version from the Fax Server
    //
    if (!FaxGetReportedServerAPIVersion(h_tmpFaxHandle, &dwServerAPIVersion))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReportedServerAPIVersion(h_tmpFaxHandle, &dwServerAPIVersion))"), hr);
        FaxClose(h_tmpFaxHandle);
        return hr;
    }

    //
    // Block Whistler clients from connection to BOS servers
    //
    if (FAX_API_VERSION_1 > dwServerAPIVersion)
    {
        hr = Fax_HRESULT_FROM_WIN32(FAX_ERR_VERSION_MISMATCH);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("Mismatch client and server versions"), hr);
        FaxClose(h_tmpFaxHandle);
        return hr;
    }

    if (m_faxHandle)
    {
        //
        //  Reconnect 
        //
        hr = Disconnect();
        if (FAILED(hr))
        {
            //
            //  Failed to DisConnect from the Previous Server
            //
            CALL_FAIL(DBG_MSG, _T("Disconnect()"), hr);
        }
    }

    m_faxHandle = h_tmpFaxHandle;
    m_bstrServerName = bstrServerName;
    return hr;
}

//
//============== GET & PUT PROPERTIES ===============================
//
STDMETHODIMP CFaxServer::get_ServerName(
    BSTR *pbstrServerName
)
/*++

Routine name : CFaxServer::get_ServerName

Routine description:

    Return Name of the Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrServerName               [out]    - Name of the Server to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_ServerName"), hr);

    hr = GetBstr(pbstrServerName, m_bstrServerName);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }
    return hr;
}

//
//============== MAIL OPTIONS OBJECT =========================================
//
STDMETHODIMP 
CFaxServer::get_ReceiptOptions(
    IFaxReceiptOptions **ppReceiptOptions
)
/*++

Routine name : CFaxServer::get_ReceiptOptions

Routine description:

    Return Mail Options Object.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppReceiptOptions              [out, retval]    - Ptr to the place to put the object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_ReceiptOptions"), hr);

    CObjectHandler<CFaxReceiptOptions, IFaxReceiptOptions>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppReceiptOptions, &m_pReceiptOptions, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\faxstrings.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	FaxStrings.h

Abstract:

	Declaration of the strings that do not get localized.

Author:

	 Ishai Nadler	Oct, 2001

Revision History:

--*/

#define    IDS_ERROR_INVALID_ARGUMENT		L"Invalid argument."
#define    IDS_ERROR_NO_RECIPIENTS			L"At least one recipient must exist."
#define    IDS_ERROR_OPERATION_FAILED		L"Operation failed."
#define    IDS_ERROR_NOTHING_TO_SUBMIT		L"FaxDocument must have either cover page or body."
#define    IDS_ERROR_SCHEDULE_TYPE			L"If ScheduleType property is set to fstSPECIFIC_TIME, then ScheduleTime property must be set."
#define    IDS_ERROR_SERVER_NOT_CONNECTED	L"Fax server must be connected."
#define    IDS_ERROR_OUTOFMEMORY			L"Not enough memory to complete the operation."
#define    IDS_ERROR_EMPTY_ARGUMENT			L"Argument cannot be empty."
#define    IDS_ERROR_OUTOFRANGE				L"Argument is out of its legal range."
#define    IDS_ERROR_ACCESSDENIED			L"Access denied."
#define    IDS_ERROR_ZERO_PREFETCHSIZE		L"PrefetchSize property cannot be less then 1."
#define    IDS_ERROR_ITERATOR_NOTSTARTED	L"Please call MoveFirst() before trying to get a message."
#define    IDS_ERROR_EMPTY_FOLDER			L"The folder is empty."
#define    IDS_ERROR_INVALIDMSGID			L"Invalid message/job ID."
#define    IDS_ERROR_EOF					L"No more messages."
#define    IDS_ERROR_CONNECTION_FAILED		L"Connection to fax server failed."
#define    IDS_ERROR_INVALIDINDEX			L"Index should be either number or string."
#define    IDS_ERROR_NOUSERPASSWORD			L"For fsatNTLM/fsatBASIC authentication types, please supply the User property. The Password property is optional."
#define    IDS_ERROR_NOSERVERSENDERPORT		L"Server, Sender, and Port properties are mandatory."
#define    IDS_ERROR_SDNOTSELFRELATIVE		L"Security descriptor should be in the self-relative mode."
#define    IDS_ERROR_INVALIDMETHODGUID		L"Method with given GUID is not found."
#define    IDS_ERROR_INVALIDDEVPROVGUID		L"DeviceProvider with given GUID is not found."
#define    IDS_ERROR_INVALIDDEVICEID		L"Device with given ID is not found."
#define    IDS_ERROR_REMOVEDEFAULTRULE		L"You cannot remove the default rule."
#define    IDS_ERROR_INVALIDDEVICE			L"Device with given Name/Index is not found."
#define    IDS_ERROR_ALLDEVICESGROUP		L"The \"<All Devices>\" outbound routing group is read-only."
#define    IDS_ERROR_METHODSNOTARRAY		L"Methods data should be passed in a one-dimensional zero-based array of strings."
#define    IDS_ERROR_WRONGEXTENSIONNAME		L"Extension with given name is not found."
#define    IDS_ERROR_NOCOVERPAGE			L"Please supply cover page file name."
#define    IDS_ERROR_QUEUE_BLOCKED			L"Queue is blocked. Cannot submit."
#define    IDS_ERROR_GROUP_NOT_FOUND		L"The fax server failed to locate an outbound routing group by name."
#define    IDS_ERROR_BAD_GROUP_CONFIGURATION   L"The fax server encountered an outbound routing group with bad configuration."
#define    IDS_ERROR_GROUP_IN_USE			L"The fax server cannot remove an outbound routing group because it is in use by one or more outbound routing rules."
#define    IDS_ERROR_RULE_NOT_FOUND			L"The fax server failed to locate an outbound routing rule by country code and area code."
#define    IDS_ERROR_NOT_NTFS				L"The fax server cannot set an archive folder to a non-NTFS partition."
#define    IDS_ERROR_DIRECTORY_IN_USE		L"The fax server cannot use the same folder for both the inbox and the sent-items archives."
#define    IDS_ERROR_MESSAGE_NOT_FOUND		L"The fax server cannot find the job or message by its ID."
#define    IDS_ERROR_DEVICE_NUM_LIMIT_EXCEEDED L"The fax server cannot complete the operation because the number of active fax devices allowed for this version of Windows was exceeded."
#define    IDS_ERROR_NOT_SUPPORTED_ON_THIS_SKU L"The fax server cannot complete the operation because it is not supported for this version of Windows."
#define    IDS_ERROR_VERSION_MISMATCH		L"The fax server API version does not support the requested operation."
#define    IDS_ERROR_FILE_ACCESS_DENIED		L"The fax server cannot access the specified file or folder."
#define    IDS_ERROR_SRV_OUTOFMEMORY		L"The fax server failed to allocate memory."
#define    IDS_ERROR_ILLEGAL_RECIPIENTS		L"When TapiConnection or CallHandle properties are specified, these properties identify the fax number of the recipient. In this case, only one recipient is allowed, and the recipient's fax number is not used for sending a document, but only for tracking the fax message."
#define    IDS_ERROR_UNSUPPORTED_RECEIPT_TYPE L"The fax server does not support the requested receipt type."
#define    IDS_ERROR_NO_END_TIME			L"The job is in transmission. Transmission end time is not available yet."
#define    IDS_ERROR_RECIPIENTS_LIMIT		L"The limit on the number of recipients for a single fax broadcast was reached."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\fxscomexcp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FXSCOMEXCP.h

Abstract:

	ATL's implementation of IConnectionPoint Ifc.
    Generated by ATL's Wizard.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef _FXSCOMEXCP_H_
#define _FXSCOMEXCP_H_

template <class T>
class CProxyIFaxServerNotify : public IConnectionPointImpl<T, &DIID_IFaxServerNotify, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_OnIncomingJobAdded(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingJobRemoved(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingJobChanged(IFaxServer * pFaxServer, BSTR bstrJobId, IFaxJobStatus * pJobStatus)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[3];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = pFaxServer;
				pvars[1] = bstrJobId;
				pvars[0] = pJobStatus;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobAdded(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobRemoved(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobChanged(IFaxServer * pFaxServer, BSTR bstrJobId, IFaxJobStatus * pJobStatus)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[3];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = pFaxServer;
				pvars[1] = bstrJobId;
				pvars[0] = pJobStatus;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingMessageAdded(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingMessageRemoved(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingMessageAdded(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingMessageRemoved(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[2];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0xa, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnReceiptOptionsChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xb, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnActivityLoggingConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnSecurityConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnEventLoggingConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xe, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingQueueConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xf, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingArchiveConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingArchiveConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnDevicesConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutboundRoutingGroupsConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutboundRoutingRulesConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnServerActivityChange(IFaxServer * pFaxServer, 
										LONG lIncomingMessages, 
										LONG lRoutingMessages, 
										LONG lOutgoingMessages, 
										LONG lQueuedMessages)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[5];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[4] = pFaxServer;
				pvars[3] = lIncomingMessages;
				pvars[2] = lRoutingMessages;
				pvars[1] = lOutgoingMessages;
				pvars[0] = lQueuedMessages;
				DISPPARAMS disp = { pvars, NULL, 5, 0 };
				pDispatch->Invoke(0x15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnQueuesStatusChange(	IFaxServer * pFaxServer, 
										VARIANT_BOOL bOutgoingQueueBlocked, 
										VARIANT_BOOL bOutgoingQueuePaused, 
										VARIANT_BOOL bIncomingQueueBlocked)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[4];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = pFaxServer;
				pvars[2] = bOutgoingQueueBlocked;
				pvars[1] = bOutgoingQueuePaused;
				pvars[0] = bIncomingQueueBlocked;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnNewCall(IFaxServer * pFaxServer, LONG lCallId, LONG lDeviceId, BSTR bstrCallerId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[4];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = pFaxServer;
				pvars[2] = lCallId;
				pvars[1] = lDeviceId;
				pvars[0] = bstrCallerId;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x17, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnServerShutDown(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[1];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x18, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}

	HRESULT Fire_OnDeviceStatusChange(  IFaxServer * pFaxServer, 
                                        LONG lDeviceId, 
                                        VARIANT_BOOL bPoweredOff, 
                                        VARIANT_BOOL bSending, 
                                        VARIANT_BOOL bReceiving, 
                                        VARIANT_BOOL bRinging)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		CComVariant* pvars = new (std::nothrow) CComVariant[6];
		if (!pvars)
		{
            return E_OUTOFMEMORY;
		}
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[5] = pFaxServer;
				pvars[4] = lDeviceId;
				pvars[3] = bPoweredOff;
				pvars[2] = bSending;
				pvars[1] = bReceiving;
				pvars[0] = bRinging;
				DISPPARAMS disp = { pvars, NULL, 6, 0 };
				pDispatch->Invoke(0x19, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FaxComEx.rc
//
#define IDR_FAXSERVER                   101
#define IDR_FAXDEVICEPROVIDERS          102
#define IDR_FAXDEVICES                  103
#define IDR_FAXINBOUNDROUTING           104
#define IDR_FAXFOLDERS                  105
#define IDR_FAXLOGGINGOPTIONS           106
#define IDR_FAXACTIVITY                 107
#define IDR_FAXOUTBOUNDROUTING          108
#define IDR_FAXRECEIPTOPTIONS           109
#define IDR_FAXSECURITY                 110
#define IDR_FAXDOCUMENT                 111
#define IDR_FAXSENDER                   113
#define IDR_FAXRECIPIENTS               114
#define IDR_FAXINCOMINGARCHIVE          115
#define IDR_FAXINCOMINGQUEUE            116
#define IDR_FAXOUTGOINGARCHIVE          117
#define IDR_FAXOUTGOINGQUEUE            118
#define IDR_FAXINCOMINGMESSAGEITERATOR  119
#define IDR_FAXINCOMINGMESSAGE          120
#define IDR_FAXOUTGOINGJOBS             123
#define IDR_FAXOUTGOINGJOB              128
#define IDR_FAXOUTGOINGMESSAGEITERATOR  129
#define IDR_FAXOUTGOINGMESSAGE          130
#define IDR_FAXINCOMINGJOBS             131
#define IDR_FAXINCOMINGJOB              132
#define IDR_FAXDEVICEPROVIDER           133
#define IDR_FAXDEVICE                   134
#define IDR_FAXACTIVITYLOGGING          135
#define IDR_FAXEVENTLOGGING             136
#define IDR_FAXOUTBOUNDROUTINGGROUPS    137
#define IDR_FAXOUTBOUNDROUTINGGROUP     138
#define IDR_FAXDEVICEIDS                139
#define IDR_FAXOUTBOUNDROUTINGRULES     140
#define IDR_FAXOUTBOUNDROUTINGRULE      141
#define IDR_FAXINBOUNDROUTINGEXTENSIONS 142
#define IDR_FAXINBOUNDROUTINGEXTENSION  143
#define IDR_FAXINBOUNDROUTINGMETHODS    144
#define IDR_FAXINBOUNDROUTINGMETHOD     145
#define IDS_FAXARCHIVEINNERIMPL_DESC    146
#define IDR_FAXJOBSTATUS                147
#define IDR_FAXRECIPIENT                148

//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           148
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED_)
#define AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <fxsapip.h>
#include <comdef.h>

#include <debugex.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\vcue_copy.h ===
// This is a part of the Active Template Library. 
// Copyright (C) 1995-1999 Microsoft Corporation
// All rights reserved. 
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// VCUE_Copy.h
//
// This file contains ATL-style copy policy classes
// ATL uses copy policy classes in its enumerator and collection interface implementations
//
//////////////////////////////////////////////////////////////////////

#if !defined(_GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
#define _GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <AtlCom.h>

namespace VCUE
{
	template <class DestinationType, class SourceType = DestinationType>
	class GenericCopy
	{
	public :
		typedef DestinationType	destination_type;
		typedef SourceType		source_type;

		static void init(destination_type* p)
		{
			_Copy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			_Copy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return _Copy<destination_type>::copy(pTo, const_cast<source_type*>(pFrom));
		}

	}; // class GenericCopy

	template <>
	class GenericCopy<VARIANT, BSTR>
	{
	public :
		typedef VARIANT	destination_type;
		typedef BSTR	source_type;

		static void init(destination_type* p)
		{
			GenericCopy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			GenericCopy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class GenericCopy<VARIANT, BSTR>

	template < class SourceType >
	class CopyIfc2Variant
	{
	public :
		static void init(VARIANT* p)
		{
			GenericCopy<VARIANT>::init(p);
		}
		static void destroy(VARIANT* p)
		{
			GenericCopy<VARIANT>::destroy(p);
		}
		static HRESULT copy(VARIANT* pTo, const SourceType* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class CopyIfc2Variant< SourceType >

	template < class TheType >
	class CopyIfc
	{
	public :
		static void init(TheType* p)
		{
			GenericCopy<TheType>::init(p);
		}
		static void destroy(TheType* p)
		{
			GenericCopy<TheType>::destroy(p);
		}
		static HRESULT copy(TheType* pTo, const TheType* pFrom)
		{
            ((IUnknown *)(* pFrom))->AddRef();
            *pTo = *pFrom;
			return S_OK;
		}

	}; // class CopyIfc< TheType >

	template <>
	class GenericCopy<VARIANT, long>
	{
	public :
		typedef VARIANT	destination_type;
		typedef long    source_type;

		static void init(destination_type* p)
		{
			GenericCopy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			GenericCopy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class GenericCopy<VARIANT, long>

}; // namespace VCUE

#endif // !defined(_GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxdoc.h ===
// FaxDoc.h : Declaration of the CFaxDoc

#ifndef __FAXDOC_H_
#define __FAXDOC_H_

#include "resource.h"       // main symbols
#include "faxsvr.h"
#include <winfax.h>
/////////////////////////////////////////////////////////////////////////////
// CFaxDoc
class ATL_NO_VTABLE CFaxDoc : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxDoc, &CLSID_FaxDoc>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDoc, &IID_IFaxDoc, &LIBID_FAXCOMLib>
{
public:
	CFaxDoc()
	{
        m_DiscountSend = FALSE;
        m_SendCoverpage = FALSE;
        m_FaxCoverpageInfo = NULL;
        m_FaxJobParams = NULL;
        m_FileName = NULL;
        m_JobId = 0;
        m_TapiConnectionObject = NULL;

        CFaxServer* m_pFaxServer = NULL;
        m_FaxNumber = NULL;
        m_Tsid = NULL;
        m_BillingCode = NULL;
        m_EmailAddress = NULL;;
        m_DocumentName = NULL;;    
        m_Note = NULL;
        m_Subject = NULL;
        m_CoverpageName = NULL;
        m_RecipientName = NULL;
        m_RecipientNumber = NULL;
        m_RecipientCompany = NULL;
        m_RecipientAddress = NULL;
        m_RecipientCity = NULL;
        m_RecipientState = NULL;
        m_RecipientZip = NULL;
        m_RecipientCountry = NULL;
        m_RecipientTitle = NULL;
        m_RecipientDepartment = NULL;
        m_RecipientOffice = NULL;
        m_RecipientHomePhone = NULL;
        m_RecipientOfficePhone = NULL;
        m_SenderName = NULL;
        m_SenderCompany = NULL;
        m_SenderAddress = NULL;
        m_SenderTitle = NULL;
        m_SenderDepartment = NULL;
        m_SenderOfficeLocation = NULL;
        m_SenderHomePhone = NULL;
        m_SenderOfficePhone = NULL;
        m_SenderFax = NULL;


        //
        // prefill in the params...
        //

        FaxCompleteJobParams(&m_FaxJobParams,&m_FaxCoverpageInfo);

        if (m_FaxJobParams && m_FaxCoverpageInfo) {
        
            m_CoverpageName        =SysAllocString(m_FaxCoverpageInfo->CoverPageName);
            m_RecipientName        =SysAllocString(m_FaxCoverpageInfo->RecName);
            m_RecipientNumber      =SysAllocString(m_FaxCoverpageInfo->RecFaxNumber);
            m_RecipientCompany     =SysAllocString(m_FaxCoverpageInfo->RecCompany);
            m_RecipientAddress     =SysAllocString(m_FaxCoverpageInfo->RecStreetAddress);
            m_RecipientCity        =SysAllocString(m_FaxCoverpageInfo->RecCity);
            m_RecipientState       =SysAllocString(m_FaxCoverpageInfo->RecState);
            m_RecipientZip         =SysAllocString(m_FaxCoverpageInfo->RecZip);
            m_RecipientCountry     =SysAllocString(m_FaxCoverpageInfo->RecCountry);
            m_RecipientTitle       =SysAllocString(m_FaxCoverpageInfo->RecTitle);
            m_RecipientDepartment  =SysAllocString(m_FaxCoverpageInfo->RecDepartment);
            m_RecipientOffice      =SysAllocString(m_FaxCoverpageInfo->RecOfficeLocation);
            m_RecipientHomePhone   =SysAllocString(m_FaxCoverpageInfo->RecHomePhone);
            m_RecipientOfficePhone =SysAllocString(m_FaxCoverpageInfo->RecOfficePhone);
            m_SenderName           =SysAllocString(m_FaxCoverpageInfo->SdrName);
            m_SenderFax            =SysAllocString(m_FaxCoverpageInfo->SdrFaxNumber);
            m_SenderCompany        =SysAllocString(m_FaxCoverpageInfo->SdrCompany);
            m_SenderAddress        =SysAllocString(m_FaxCoverpageInfo->SdrAddress);
            m_SenderTitle          =SysAllocString(m_FaxCoverpageInfo->SdrTitle);
            m_SenderDepartment     =SysAllocString(m_FaxCoverpageInfo->SdrDepartment);
            m_SenderOfficeLocation =SysAllocString(m_FaxCoverpageInfo->SdrOfficeLocation);
            m_SenderHomePhone      =SysAllocString(m_FaxCoverpageInfo->SdrHomePhone);
            m_SenderOfficePhone    =SysAllocString(m_FaxCoverpageInfo->SdrOfficePhone);
            m_Note                 =SysAllocString(m_FaxCoverpageInfo->Note);
            m_Subject              =SysAllocString(m_FaxCoverpageInfo->Subject);               
            m_Tsid                 =SysAllocString(m_FaxJobParams->Tsid);
            m_BillingCode          =SysAllocString(m_FaxJobParams->BillingCode);
            m_EmailAddress         =SysAllocString(m_FaxJobParams->DeliveryReportAddress);
            m_DocumentName         =SysAllocString(m_FaxJobParams->DocumentName);
        
        }

	}
    

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDOC)

BEGIN_COM_MAP(CFaxDoc)
	COM_INTERFACE_ENTRY(IFaxDoc)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxDoc
public:
    ~CFaxDoc();
	BOOL Init(BSTR FileName,CFaxServer *pFaxServer);
	BOOL SetJob();
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR newVal);
	STDMETHOD(Send)(/*[out, retval]*/long *pVal);
	STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DisplayName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_EmailAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EmailAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageSubject)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageSubject)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageNote)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageNote)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_SenderFax)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderFax)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCountry)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCountry)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientZip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientZip)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientState)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientState)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCity)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCity)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_DiscountSend)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_SendCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_SendCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_CoverpageName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
   STDMETHOD(putref_ConnectionObject)(/*[in]*/ IDispatch* newVal);
   STDMETHOD(get_CallHandle)(/*[out, retval]*/ long *pVal);
   STDMETHOD(put_CallHandle)(/*[in]*/ long newVal);

private:
	CFaxServer* m_pFaxServer;
	BOOL m_DiscountSend;
	BOOL m_SendCoverpage;
	DWORD m_JobId;
	PFAX_COVERPAGE_INFO m_FaxCoverpageInfo;
	PFAX_JOB_PARAM m_FaxJobParams;
	BSTR m_FileName;
   IDispatch* m_TapiConnectionObject;
   
   VARIANT* m_pVariant;

    //
    // job info
    //
    BSTR m_FaxNumber;
    BSTR m_Tsid;
    BSTR m_BillingCode;
    BSTR m_EmailAddress;
    BSTR m_DocumentName;
    //
    // coverpage info
    //
    BSTR m_Note;
    BSTR m_Subject;
    BSTR m_CoverpageName;
    BSTR m_RecipientName;
    BSTR m_RecipientNumber;
    BSTR m_RecipientCompany;
    BSTR m_RecipientAddress;
    BSTR m_RecipientCity;
    BSTR m_RecipientState;
    BSTR m_RecipientZip;
    BSTR m_RecipientCountry;
    BSTR m_RecipientTitle;
    BSTR m_RecipientDepartment;
    BSTR m_RecipientOffice;
    BSTR m_RecipientHomePhone;
    BSTR m_RecipientOfficePhone;
    BSTR m_SenderName;    
    BSTR m_SenderCompany;
    BSTR m_SenderAddress;
    BSTR m_SenderTitle;
    BSTR m_SenderDepartment;
    BSTR m_SenderOfficeLocation;
    BSTR m_SenderHomePhone;
    BSTR m_SenderOfficePhone;
    BSTR m_SenderFax;

};

#endif //__FAXDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\whistler\vcue_collection.h ===
// This is a part of the Active Template Library. 
// Copyright (C) 1995-1999 Microsoft Corporation
// All rights reserved. 
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// VCUE_Collection.h
//
// This header contains code that simplifies or enhances use of ATL's collection
// and enumerator classes, ICollectionOnSTLImpl, IEnumOnSTLImpl, CComEnumOnSTL, CComEnumImpl, and CComEnum
//
//////////////////////////////////////////////////////////////////////

#if !defined(_COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
#define _COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <AtlCom.h>

namespace VCUE
{

// CGenericDataHolder is a class that stores data
// The lifetime of objects of this class is managed via the IUnknown interface
// which makes objects of this class suitable as a source of shared data
// Clients that need access to the data can keep a CGenericDataHolder object alive
// just by holding a COM reference on that object

// This class is used (by default) by ICollectionOnSTLCopyImpl::get__NewEnum to provide data
// to be shared between an enumerator and its clones.

	template < class DataType, class ThreadModel = CComObjectThreadModel >
	class ATL_NO_VTABLE CGenericDataHolder :
		public IUnknown,
		public CComObjectRootEx< ThreadModel >
	{
	public:
		typedef CGenericDataHolder< DataType, ThreadModel > thisClass;

		BEGIN_COM_MAP(thisClass)
			COM_INTERFACE_ENTRY(IUnknown)
		END_COM_MAP()

		template < class SourceType >
		HRESULT Copy(const SourceType& c)
		{
			m_Data = c;
			return S_OK;

		} // HRESULT Copy(const SourceType& c)

		DataType m_Data;

	}; // class ATL_NO_VTABLE CGenericDataHolder

// CreateSTLEnumerator wraps the necessary creation, initialization 
// and error handling code for the the creation of a CComEnumOnSTL-style enumerator
	
// *** EXAMPLE : Using CreateSTLEnumerator to implement get__NewEnum ***
//		typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
//	                     _Copy<VARIANT>, std::vector<CComVariant> > VarVarEnum;
//		std::vector<CComVariant> m_vec;
//		STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
//		{
//			return CreateSTLEnumerator<VarVarEnum>(ppUnk, this, m_vec);
//		}

	template <class EnumType, class CollType>
	HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;

		CComObject<EnumType>* pEnum = NULL;
		HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

		if (FAILED(hr))
			return hr;

		hr = pEnum->Init(pUnkForRelease, collection);

		if (SUCCEEDED(hr))
			hr = pEnum->QueryInterface(ppUnk);

		if (FAILED(hr))
			delete pEnum;

		return hr;

	} // HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)

// CreateEnumerator wraps the necessary creation, initialization 
// and error handling code for the the creation of a CComEnum-style enumerator

	template <class EnumType, class ElementType>
	HRESULT CreateEnumerator(IUnknown** ppUnk,
							 ElementType* begin, ElementType* end,
							 IUnknown* pUnk,
							 CComEnumFlags flags)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;

		CComObject<EnumType>* pEnum = NULL;
		HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

		if (FAILED(hr))
			return hr;

		hr = pEnum->Init(begin, end, pUnk, flags);

		if (SUCCEEDED(hr))
			hr = pEnum->QueryInterface(ppUnk);

		if (FAILED(hr))
			delete pEnum;

		return hr;

	} // CreateEnumerator


// ICollectionOnSTLCopyImpl derives from ICollectionOnSTLImpl and overrides get__NewEnum
// The new implementation provides each enumerator with its own copy of the collection data.
// (Note that this only applies to enumerators returned directly by get__NewEnum.
//  Cloned enumerators use their parent's data as before.
//	This is OK because the enumerator never changes the data)

// Use this class when:
//		The collection can change while there are outstanding enumerators
// And	You don't want to invalidate those enumerators when that happens
// And	You are sure that the performance hit is worth it
// And	You are sure that the way items are copied between containers works correctly
//			(You can adjust this by passing a different class as the Holder parameter)

// Mostly you can use this class in exactly the same 
// way that you would use ICollectionOnSTLImpl.

	template <class T, class CollType, class ItemType, class CopyItem, class EnumType, class Holder = CGenericDataHolder< CollType > >
	class ICollectionOnSTLCopyImpl :
		public ICollectionOnSTLImpl<T, CollType, ItemType, CopyItem, EnumType>
	{
	public :
		STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
		{
			typedef CComObject< Holder > HolderObject;
			HolderObject* p = NULL;
			HRESULT hr = HolderObject::CreateInstance(&p);
			if (FAILED(hr))
				return hr;

			hr = p->Copy(m_coll);
			if (FAILED(hr))
				return hr;

			return CreateSTLEnumerator<EnumType>(ppUnk, p, p->m_Data);
		
		} // STDMETHOD(get__NewEnum)(IUnknown** ppUnk)

	}; // class ICollectionOnSTLCopyImpl

}; // namespace VCUE

#endif // !defined(_COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxcom.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the dll exports from this
    control(s).

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"


#include "faxcom_i.c"
#include "faxtiff.h"
#include "faxsvr.h"
#include "Status.h"
#include "FaxJob.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FaxTiff, CFaxTiff)
    OBJECT_ENTRY(CLSID_FaxServer, CFaxServer)	
END_OBJECT_MAP()

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }
    return TRUE;
}


STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxjob.h ===
// FaxJob.h : Declaration of the CFaxJobs

#ifndef __FAXJOBS_H_
#define __FAXJOBS_H_

#include "resource.h"       // main symbols
#include <winfax.h>
#include "faxsvr.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs
class ATL_NO_VTABLE CFaxJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJobs, &CLSID_FaxJobs>,
	public IDispatchImpl<IFaxJobs, &IID_IFaxJobs, &LIBID_FAXCOMLib>
{
public:
	CFaxJobs()
	{
		m_Jobs = 0;
		m_LastFaxError = 0;
		m_pFaxServer = NULL;
		m_VarVect = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOBS)

BEGIN_COM_MAP(CFaxJobs)
	COM_INTERFACE_ENTRY(IFaxJobs)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJobs
public:
	STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
	BOOL Init(CFaxServer *pFaxServer);
	 ~CFaxJobs();
private:
	CComVariant* m_VarVect;
	CFaxServer* m_pFaxServer;
	DWORD m_Jobs;
	DWORD m_LastFaxError;
};


/////////////////////////////////////////////////////////////////////////////
// CFaxJob
class ATL_NO_VTABLE CFaxJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJob, &CLSID_FaxJob>,
	public IDispatchImpl<IFaxJob, &IID_IFaxJob, &LIBID_FAXCOMLib>
{
public:
	CFaxJob()
	{
		m_JobId = 0;
		m_UserName = NULL;
		m_JobType = JT_UNKNOWN;
		m_QueueStatus = 0 ;
		m_DeviceStatus = 0 ;
		m_szQueueStatus = NULL;
		m_szDeviceStatus = NULL;
		m_PageCount=0;
		m_RecipientNumber = NULL;
		m_RecipientName = NULL;
		m_Tsid = NULL;
		m_SenderName = NULL;
		m_SenderCompany = NULL;
		m_SenderDept = NULL;
		m_BillingCode = NULL;
		m_DiscountTime = FALSE;
		m_DisplayName = NULL;
		m_Command = JC_UNKNOWN;
		m_pFaxServer = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOB)

BEGIN_COM_MAP(CFaxJob)
	COM_INTERFACE_ENTRY(IFaxJob)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJob
public:
	STDMETHOD(Refresh)();
	STDMETHOD(SetStatus)(long Command);
	BOOL SetJob();
	 ~CFaxJob();
	BOOL Initialize(CFaxServer *pFaxServer,DWORD JobId,LPCWSTR UserName,DWORD JobType,DWORD QueueStatus,DWORD DeviceStatus,DWORD PageCount,LPCWSTR RecipientNumber,LPCWSTR RecipientName,LPCWSTR Tsid,LPCWSTR SenderName,LPCWSTR SenderCompany,LPCWSTR SenderDept,LPCWSTR BillingCode,DWORD ScheduleAction,LPCWSTR DisplayName);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderDept)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_DeviceStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_QueueStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_UserName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_JobId)(/*[out, retval]*/ long *pVal);
private:
	DWORD m_JobId;
	BSTR  m_UserName;
	DWORD m_JobType;
	DWORD m_QueueStatus;
	DWORD m_DeviceStatus;
	BSTR  m_szQueueStatus;
	BSTR  m_szDeviceStatus;
	DWORD m_PageCount;
	BSTR  m_RecipientNumber;
	BSTR  m_RecipientName;
	BSTR  m_Tsid;
	BSTR  m_SenderName;
	BSTR  m_SenderCompany;
	BSTR  m_SenderDept;
	BSTR  m_BillingCode;
	BOOL  m_DiscountTime;
	BSTR  m_DisplayName;
	DWORD m_Command;
	CFaxServer * m_pFaxServer;
};

#endif //__FAXJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxjob.cpp ===
// FaxJob.cpp : Implementation of CFaxJobs
#include "stdafx.h"
#include "FaxJob.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs


CFaxJobs::~CFaxJobs()
{
    if (m_pFaxServer) 
    {
        m_pFaxServer->Release();
    }

    if (m_VarVect) 
    {
        delete [] m_VarVect;
    }
}


BOOL CFaxJobs::Init(CFaxServer * pFaxServer)
{
    PFAX_JOB_ENTRYW     JobEntry = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) 
    {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) 
    {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumJobsW( m_pFaxServer->GetFaxHandle(), &JobEntry, &m_Jobs)) 
    {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_Jobs];
    if (!m_VarVect) 
    {
        FaxFreeBuffer( JobEntry );
        m_LastFaxError = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    for (DWORD i=0; i<m_Jobs; i++) 
    {
        //
        // create the object
        //
        CComObject<CFaxJob> *pFaxJob;
        hr = CComObject<CFaxJob>::CreateInstance( &pFaxJob );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }
        //
        // set the values
        //
        if (!pFaxJob->Initialize(
            m_pFaxServer,
            JobEntry[i].JobId,
            JobEntry[i].UserName,
            JobEntry[i].JobType,
            JobEntry[i].QueueStatus,
            JobEntry[i].Status,
            JobEntry[i].PageCount,
            JobEntry[i].RecipientNumber,
            JobEntry[i].RecipientName,
            JobEntry[i].Tsid,
            JobEntry[i].SenderName,
            JobEntry[i].SenderCompany,
            JobEntry[i].SenderDept,
            JobEntry[i].BillingCode,
            JobEntry[i].ScheduleAction,
            JobEntry[i].DocumentName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxJob->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        var.vt = VT_DISPATCH;
        var.pdispVal = lpDisp;
    }

    FaxFreeBuffer( JobEntry );
    return TRUE;
}


STDMETHODIMP CFaxJobs::get_Count(long * pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }
    
    __try 
    {

        *pVal = m_Jobs;
        return S_OK;

    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJobs::get_Item(long Index, VARIANT * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_Jobs)) 
    {
        return E_INVALIDARG;
    }


    __try 
    {                 
        VariantInit( pVal );

        pVal->vt = VT_UNKNOWN;
        pVal->punkVal = NULL;
    
        return VariantCopy( pVal, &m_VarVect[Index-1] );        
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }

    return E_UNEXPECTED;    

}


/////////////////////////////////////////////////////////////////////////////
// CFaxJob


STDMETHODIMP CFaxJob::get_JobId(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_JobId;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }
        
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_Type(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_JobType;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_UserName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_UserName);
    if (!Copy  && m_UserName) 
    {
        return E_OUTOFMEMORY;
    }    

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);    
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_QueueStatus(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szQueueStatus);
    if (!Copy  && m_szQueueStatus) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DeviceStatus(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szDeviceStatus);
    if (!Copy  && m_szDeviceStatus) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_PageCount(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_PageCount;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_FaxNumber(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientNumber);
    if (!Copy  && m_RecipientNumber) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_RecipientName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientName);
    if (!Copy  && m_RecipientName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxJob::get_Tsid(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);
    if (!Copy  && m_Tsid) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderName);
    if (!Copy  && m_SenderName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderCompany(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderCompany);
    if (!Copy  && m_SenderCompany) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderDept(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderDept);
    if (!Copy  && m_SenderDept) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_BillingCode(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_BillingCode);
    if (!Copy  && m_BillingCode) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DisplayName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DisplayName);
    if (!Copy  && m_DisplayName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DiscountSend(BOOL * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_DiscountTime;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;    
}


CFaxJob::~CFaxJob()
{
    SysFreeString(m_UserName);
    SysFreeString(m_szQueueStatus);
    SysFreeString(m_szDeviceStatus);
    SysFreeString(m_RecipientNumber);
    SysFreeString(m_RecipientName);
    SysFreeString(m_Tsid);
    SysFreeString(m_SenderName);
    SysFreeString(m_SenderCompany);
    SysFreeString(m_SenderDept);
    SysFreeString(m_BillingCode);
    SysFreeString(m_DisplayName);

    if (m_pFaxServer) 
    {
        m_pFaxServer->Release();
    }
}


BOOL CFaxJob::Initialize(
    CFaxServer *pFaxServer,
    DWORD JobId,
    LPCWSTR UserName,
    DWORD JobType,
    DWORD QueueStatus,
    DWORD DeviceStatus,
    DWORD PageCount,
    LPCWSTR RecipientNumber,
    LPCWSTR RecipientName,
    LPCWSTR Tsid,
    LPCWSTR SenderName,
    LPCWSTR SenderCompany,
    LPCWSTR SenderDept,
    LPCWSTR BillingCode,
    DWORD ScheduleAction,
    LPCWSTR DisplayName)
{
    if (!pFaxServer) 
    {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;

    if ( FAILED(m_pFaxServer->AddRef()) )
    {
        m_pFaxServer = NULL;
        return FALSE;
    }

    m_UserName = SysAllocString(UserName);
    m_szQueueStatus = GetQueueStatus(m_QueueStatus);
    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
    m_RecipientNumber = SysAllocString(RecipientNumber);
    m_RecipientName = SysAllocString(RecipientName);
    m_Tsid = SysAllocString(Tsid);
    m_SenderName = SysAllocString(SenderName);
    m_SenderCompany = SysAllocString(SenderCompany);
    m_SenderDept = SysAllocString(SenderDept);
    m_BillingCode = SysAllocString(BillingCode);
    m_DisplayName = SysAllocString(DisplayName);

    if ( (!m_UserName && UserName) ||
         (!m_szQueueStatus) ||
         (!m_szDeviceStatus) ||
         (!m_RecipientNumber && RecipientNumber) ||
         (!m_RecipientName && RecipientName) ||
         (!m_Tsid && Tsid) ||
         (!m_SenderName && SenderName) ||
         (!m_SenderCompany && SenderCompany) ||
         (!m_SenderDept && SenderDept) ||
         (!m_BillingCode && BillingCode) ||
         (!m_DisplayName && DisplayName) )
    {
        goto error;
    }

    m_JobId = JobId;
    m_JobType = JobType;
    m_QueueStatus = QueueStatus;
    m_DeviceStatus = DeviceStatus;
    m_PageCount = PageCount;
    m_DiscountTime = (ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    return TRUE;

error:
    SysFreeString(m_DisplayName);
    SysFreeString(m_BillingCode);
    SysFreeString(m_SenderDept);
    SysFreeString(m_SenderCompany);
    SysFreeString(m_SenderName);
    SysFreeString(m_Tsid);
    SysFreeString(m_RecipientName);
    SysFreeString(m_RecipientNumber);
    SysFreeString(m_szDeviceStatus);
    SysFreeString(m_szQueueStatus);
    SysFreeString(m_UserName);

    m_pFaxServer->Release();
    m_pFaxServer = NULL;
    return FALSE;
}


BOOL CFaxJob::SetJob()
{
    FAX_JOB_ENTRYW FaxJobEntry;

    ZeroMemory(&FaxJobEntry,sizeof(FAX_JOB_ENTRYW) );
    FaxJobEntry.SizeOfStruct = sizeof(FAX_JOB_ENTRYW);
    FaxJobEntry.JobId = m_JobId;
    FaxJobEntry.UserName = m_UserName;
    FaxJobEntry.JobType = m_JobType;
    FaxJobEntry.QueueStatus = m_QueueStatus;
    FaxJobEntry.Status = m_DeviceStatus;
    FaxJobEntry.PageCount = m_PageCount;
    FaxJobEntry.RecipientNumber = m_RecipientNumber;
    FaxJobEntry.RecipientName = m_RecipientName;
    FaxJobEntry.Tsid = m_Tsid;
    FaxJobEntry.SenderName = m_SenderName;
    FaxJobEntry.SenderCompany = m_SenderCompany;
    FaxJobEntry.SenderDept = m_SenderDept;
    FaxJobEntry.BillingCode = m_BillingCode;
    FaxJobEntry.ScheduleAction = m_DiscountTime ? JSA_DISCOUNT_PERIOD : JSA_NOW;
    FaxJobEntry.DocumentName = m_DisplayName;


    if (!FaxSetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,m_Command,&FaxJobEntry) ) 
    {
        return FALSE;
    }

    return TRUE;
}


STDMETHODIMP CFaxJob::SetStatus(long Command)
{
    m_Command = Command;

    if (!SetJob())
    {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CFaxJob::Refresh()
{
    PFAX_JOB_ENTRYW FaxJobEntry;
    HRESULT hr = S_OK;

    if (!FaxGetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,&FaxJobEntry) ) 
    {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_UserName) 
    {
        SysFreeString(m_UserName);      
    }   
    m_UserName = SysAllocString(FaxJobEntry->UserName);
    
    m_JobType = FaxJobEntry->JobType;
    m_QueueStatus = FaxJobEntry->QueueStatus;
    m_DeviceStatus = FaxJobEntry->Status;

    if (m_szQueueStatus) 
    {
        SysFreeString(m_szQueueStatus);
    }
    m_szQueueStatus = GetQueueStatus(m_QueueStatus);

    if (m_szDeviceStatus) 
    {
        SysFreeString(m_szDeviceStatus);
    }
    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
    
    m_PageCount = FaxJobEntry->PageCount;

    if (m_RecipientNumber ) 
    {
        SysFreeString(m_RecipientNumber);
    }
    m_RecipientNumber = SysAllocString(FaxJobEntry->RecipientNumber);

    if (m_RecipientName ) 
    {
        SysFreeString(m_RecipientName);
    }
    m_RecipientName = SysAllocString(FaxJobEntry->RecipientName);

    if (m_Tsid ) 
    {
        SysFreeString(m_Tsid);
    }
    m_Tsid = SysAllocString(FaxJobEntry->Tsid);

    if (m_SenderName  ) 
    {
        SysFreeString(m_SenderName);
    }
    m_SenderName = SysAllocString(FaxJobEntry->SenderName);

    if (m_SenderCompany) 
    {
        SysFreeString(m_SenderCompany);
    }
    m_SenderCompany = SysAllocString(FaxJobEntry->SenderCompany);

    if (m_SenderDept) 
    {
        SysFreeString(m_SenderDept);
    }
    m_SenderDept = SysAllocString(FaxJobEntry->SenderDept);

    if (m_BillingCode ) 
    {
        SysFreeString(m_BillingCode);
    }
    m_BillingCode = SysAllocString(FaxJobEntry->BillingCode);

    if (m_DisplayName) 
    {
        SysFreeString(m_DisplayName);
    }
    m_DisplayName = SysAllocString(FaxJobEntry->DocumentName);

    m_DiscountTime = (FaxJobEntry->ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    if (!m_szQueueStatus || !m_szDeviceStatus  ||
        (!m_UserName && FaxJobEntry->UserName) ||
        (!m_RecipientNumber && FaxJobEntry->RecipientNumber) ||
        (!m_RecipientName && FaxJobEntry->RecipientName) ||
        (!m_Tsid && FaxJobEntry->Tsid) ||
        (!m_SenderName && FaxJobEntry->SenderName) ||
        (!m_SenderCompany && FaxJobEntry->SenderCompany) ||
        (!m_SenderDept && FaxJobEntry->SenderDept) ||
        (!m_BillingCode && FaxJobEntry->BillingCode) ||
        (!m_DisplayName && FaxJobEntry->DocumentName) ) 
    {
        
        hr = E_OUTOFMEMORY;

        SysFreeString(m_DisplayName);
        SysFreeString(m_BillingCode);
        SysFreeString(m_SenderDept);
        SysFreeString(m_SenderCompany);
        SysFreeString(m_SenderName);
        SysFreeString(m_Tsid);
        SysFreeString(m_RecipientName);
        SysFreeString(m_RecipientNumber);
        SysFreeString(m_szDeviceStatus);
        SysFreeString(m_szQueueStatus);
        SysFreeString(m_UserName);
    }

    FaxFreeBuffer(FaxJobEntry);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxdoc.cpp ===
// FaxDoc.cpp : Implementation of CFaxDoc
#include "stdafx.h"
#include "FaxDoc.h"
#include "faxutil.h"

long TotalRows;
long IndexMax = 2;


/////////////////////////////////////////////////////////////////////////////
// CFaxDoc

STDMETHODIMP CFaxDoc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxDoc,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CFaxDoc::get_FileName(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FileName);
    if (!tmp && m_FileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_FileName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FileName) {
        SysFreeString( m_FileName);
    }
    m_FileName = tmp;    
    
	return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->CoverPageName);
    if (!tmp && m_FaxCoverpageInfo->CoverPageName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
       
}

STDMETHODIMP CFaxDoc::put_CoverpageName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    m_CoverpageName = tmp;

    m_FaxCoverpageInfo->CoverPageName = m_CoverpageName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SendCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_SendCoverpage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SendCoverpage(BOOL newVal)
{
	m_SendCoverpage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_FaxCoverpageInfo->UseServerCoverPage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_ServerCoverpage(BOOL newVal)
{
	m_FaxCoverpageInfo->UseServerCoverPage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_DiscountSend(BOOL * pVal)
{
    
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_DiscountSend;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_DiscountSend(BOOL newVal)
{
	m_DiscountSend = newVal;
	m_FaxJobParams->ScheduleAction = m_DiscountSend ? JSA_DISCOUNT_PERIOD : JSA_NOW;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecName);
    if (!tmp && m_FaxCoverpageInfo->RecName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    m_RecipientName = tmp;

    m_FaxCoverpageInfo->RecName = m_RecipientName;
    m_FaxJobParams->RecipientName = m_RecipientName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCompany);
    if (!tmp && m_FaxCoverpageInfo->RecCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    m_RecipientCompany = tmp;

    m_FaxCoverpageInfo->RecCompany= m_RecipientCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecStreetAddress);
    if (!tmp && m_FaxCoverpageInfo->RecStreetAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_RecipientAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientAddress) {
        SysFreeString( m_RecipientAddress);
    }
    m_RecipientAddress = tmp;

    m_FaxCoverpageInfo->RecStreetAddress = m_RecipientAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCity(BSTR * pVal)
{

    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCity);
    if (!tmp && m_FaxCoverpageInfo->RecCity) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_RecipientCity(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCity) {
        SysFreeString( m_RecipientCity);
    }
    m_RecipientCity = tmp;

    m_FaxCoverpageInfo->RecCity = m_RecipientCity;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientState(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecState);
    if (!tmp && m_FaxCoverpageInfo->RecState) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientState(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientState) {
        SysFreeString( m_RecipientState);
    }
    m_RecipientState = tmp;

    m_FaxCoverpageInfo->RecState = m_RecipientState;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientZip(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecZip);
    if (!tmp && m_FaxCoverpageInfo->RecZip) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientZip(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientZip) {
        SysFreeString( m_RecipientZip);
    }
    m_RecipientZip = tmp;

    m_FaxCoverpageInfo->RecZip = m_RecipientZip;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCountry(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCountry);
    if (!tmp && m_FaxCoverpageInfo->RecCountry) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientCountry(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCountry) {
        SysFreeString( m_RecipientCountry);
    }
    m_RecipientCountry = tmp;

    m_FaxCoverpageInfo->RecCountry = m_RecipientCountry;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecTitle);
    if (!tmp && m_FaxCoverpageInfo->RecTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientTitle) {
        SysFreeString( m_RecipientTitle);
    }
    m_RecipientTitle = tmp;

    m_FaxCoverpageInfo->RecTitle = m_RecipientTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecDepartment);
    if (!tmp && m_FaxCoverpageInfo->RecDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientDepartment) {
        SysFreeString( m_RecipientDepartment);
    }
    m_RecipientDepartment = tmp;

    m_FaxCoverpageInfo->RecDepartment = m_RecipientDepartment;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->RecOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOffice) {
        SysFreeString( m_RecipientOffice);
    }
    m_RecipientOffice = tmp;

    m_FaxCoverpageInfo->RecOfficeLocation = m_RecipientOffice;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecHomePhone);
    if (!tmp && m_FaxCoverpageInfo->RecHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientHomePhone) {
        SysFreeString( m_RecipientHomePhone);
    }
    m_RecipientHomePhone = tmp;

    m_FaxCoverpageInfo->RecHomePhone = m_RecipientHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->RecOfficePhone ) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_RecipientOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOfficePhone) {
        SysFreeString( m_RecipientOfficePhone);
    }
    m_RecipientOfficePhone = tmp;

    m_FaxCoverpageInfo->RecOfficePhone = m_RecipientOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderFax(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_SenderFax);
    if (!tmp && m_SenderFax) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderFax(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderFax) {
        SysFreeString( m_SenderFax);
    }
    m_SenderFax = tmp;

    m_FaxCoverpageInfo->SdrFaxNumber = m_SenderFax;

    return S_OK;
}


STDMETHODIMP CFaxDoc::get_SenderName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrName);
    if (!tmp && m_FaxCoverpageInfo->SdrName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderName) {
        SysFreeString( m_SenderName);
    }
    m_SenderName = tmp;

    m_FaxCoverpageInfo->SdrName = m_SenderName;
    m_FaxJobParams->SenderName = m_SenderName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrCompany);
    if (!tmp && m_FaxCoverpageInfo->SdrCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderCompany) {
        SysFreeString( m_SenderCompany);
    }
    m_SenderCompany = tmp;

    m_FaxCoverpageInfo->SdrCompany = m_SenderCompany;
    m_FaxJobParams->SenderCompany = m_SenderCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderAddress(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrAddress);
    if (!tmp && m_FaxCoverpageInfo->SdrAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderAddress) {
        SysFreeString( m_SenderAddress);
    }
    m_SenderAddress = tmp;

    m_FaxCoverpageInfo->SdrAddress = m_SenderAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrTitle);
    if (!tmp && m_FaxCoverpageInfo->SdrTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SenderTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderTitle) {
        SysFreeString( m_SenderTitle);
    }
    m_SenderTitle = tmp;

    m_FaxCoverpageInfo->SdrTitle = m_SenderTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrDepartment);
    if (!tmp && m_FaxCoverpageInfo->SdrDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderDepartment) {
        SysFreeString( m_SenderDepartment);
    }
    m_SenderDepartment = tmp;

    m_FaxCoverpageInfo->SdrDepartment = m_SenderDepartment;
    m_FaxJobParams->SenderDept = m_SenderDepartment;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderOfficeLocation) {
        SysFreeString( m_SenderOfficeLocation);
    }
    m_SenderOfficeLocation = tmp;

    m_FaxCoverpageInfo->SdrOfficeLocation = m_SenderOfficeLocation;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrHomePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderHomePhone) {
        SysFreeString( m_SenderHomePhone);
    }
    m_SenderHomePhone = tmp;

    m_FaxCoverpageInfo->SdrHomePhone = m_SenderHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_SenderOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_SenderOfficePhone) {
        SysFreeString( m_SenderOfficePhone);
    }
    m_SenderOfficePhone = tmp;

    m_FaxCoverpageInfo->SdrOfficePhone = m_SenderOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageNote(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Note);
    if (!tmp && m_FaxCoverpageInfo->Note) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_CoverpageNote(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Note) {
        SysFreeString( m_Note);
    }
    m_Note = tmp;

    m_FaxCoverpageInfo->Note = m_Note;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageSubject(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Subject);
    if (!tmp && m_FaxCoverpageInfo->Subject) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_CoverpageSubject(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    m_Subject = tmp;

    m_FaxCoverpageInfo->Subject = m_Subject;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_Tsid(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->Tsid);
    if (!tmp && m_FaxJobParams->Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_Tsid(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    m_Tsid = tmp;

    m_FaxJobParams->Tsid = m_Tsid;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_BillingCode(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->BillingCode);
    if (!tmp && m_FaxJobParams->BillingCode) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_BillingCode(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_BillingCode) {
        SysFreeString( m_BillingCode );
    }
    m_BillingCode = tmp;

    m_FaxJobParams->BillingCode = m_BillingCode;
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::get_EmailAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DeliveryReportAddress);
    if (!tmp && m_FaxJobParams->DeliveryReportAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_EmailAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    m_EmailAddress = tmp;

    m_FaxJobParams->DeliveryReportAddress = m_EmailAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_DisplayName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DocumentName);
    if (!tmp && m_FaxJobParams->DocumentName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_DisplayName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_DocumentName) {
        SysFreeString( m_DocumentName);
    }
    m_DocumentName = tmp;

    m_FaxJobParams->DocumentName = m_DocumentName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::Send(long * pVal)
{
    
    //
    // user must specify a file name.
    // if user specifies a fax number, use that. 
    // else use the tapi call handle or connection object if it's there
    //
    if (!m_FileName) {
       return E_INVALIDARG;
    }

    if (!m_FaxJobParams->RecipientNumber) {
       //
       // see if they have a call handle or a connection object
       //
       if (!m_FaxJobParams->CallHandle) {       
          if (!m_TapiConnectionObject) {        
              return E_INVALIDARG;
          } else {
             m_FaxJobParams->Reserved[0] = 0xFFFF1234;
             m_FaxJobParams->Reserved[1] = (ULONG_PTR)m_TapiConnectionObject;
          }
       }
    }
    
    if (!FaxSendDocument(m_pFaxServer->GetFaxHandle(),
                         m_FileName,
                         m_FaxJobParams,
                         m_SendCoverpage ? m_FaxCoverpageInfo : NULL,
                         &m_JobId) ) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_TapiConnectionObject) {
       m_TapiConnectionObject->Release();
       m_TapiConnectionObject = NULL;
    }

    *pVal = m_JobId;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_FaxNumber(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->RecipientNumber);
    if (!tmp && m_FaxJobParams->RecipientNumber) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_FaxNumber(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }
    m_FaxNumber = tmp;

    m_FaxCoverpageInfo->RecFaxNumber = m_FaxNumber;
    m_FaxJobParams->RecipientNumber = m_FaxNumber;

    return S_OK;
}

CFaxDoc::~CFaxDoc()
{
    if (m_FaxJobParams) {
        FaxFreeBuffer(m_FaxJobParams);
    }

    if (m_FaxCoverpageInfo) {
    FaxFreeBuffer(m_FaxCoverpageInfo);
    }

    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_FileName) {
        SysFreeString( m_FileName);
    }

    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }

    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    if (m_BillingCode) {
        SysFreeString( m_BillingCode);
    }
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    if (m_DocumentName) {
        SysFreeString(m_DocumentName);
    }
    if (m_Note) {
        SysFreeString( m_Note);
    }
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    if (m_RecipientNumber) {
        SysFreeString( m_RecipientNumber);
    }
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    if (m_RecipientAddress) {
        SysFreeString(m_RecipientAddress);
    }
    if (m_RecipientCity) {
        SysFreeString(m_RecipientCity);
    }
    if (m_RecipientState) {
        SysFreeString(m_RecipientState);
    }
    if (m_RecipientZip) {
        SysFreeString(m_RecipientZip);
    }
    if (m_RecipientCountry) {
        SysFreeString(m_RecipientCountry);
    }
    if (m_RecipientTitle) {
        SysFreeString(m_RecipientTitle);
    }
    if (m_RecipientDepartment) {
        SysFreeString(m_RecipientDepartment);
    }
    if (m_RecipientOffice) {
        SysFreeString(m_RecipientOffice);
    }
    if (m_RecipientHomePhone) {
        SysFreeString(m_RecipientHomePhone);
    }
    if (m_RecipientOfficePhone) {
        SysFreeString(m_RecipientOfficePhone);
    }
    if (m_SenderName) {
        SysFreeString(m_SenderName);
    }
    if (m_SenderCompany) {
        SysFreeString(m_SenderCompany);
    }
    if (m_SenderAddress) {
        SysFreeString(m_SenderAddress);
    }
    if (m_SenderTitle) {
        SysFreeString(m_SenderTitle);
    }
    if (m_SenderDepartment) {
        SysFreeString(m_SenderDepartment);
    }
    if (m_SenderFax) {
        SysFreeString(m_SenderFax);
    }    
    if (m_SenderOfficeLocation) {
        SysFreeString(m_SenderOfficeLocation);
    }
    if (m_SenderHomePhone) {
        SysFreeString(m_SenderHomePhone);
    }
    if (m_SenderOfficePhone) {
        SysFreeString(m_SenderOfficePhone);
    }

}

BOOL CFaxDoc::Init(BSTR FileName, CFaxServer * pFaxServer)
{
    HRESULT hr;
    
    m_pFaxServer = pFaxServer;

    //
    // make sure our fax handle doesn't get destroyed
    //
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    //
    // save our filename
    // 
    hr = put_FileName(FileName);
    if (FAILED(hr)) {
        return FALSE;
    }

    return TRUE;

}

STDMETHODIMP CFaxDoc::putref_ConnectionObject(IDispatch* newVal)
{
    if (!newVal) {
       return E_POINTER;
    }

    if (m_TapiConnectionObject) {
        m_TapiConnectionObject->Release();
        m_TapiConnectionObject = NULL;
    }

    HRESULT hr = newVal->QueryInterface(IID_IDispatch,(void**) &m_TapiConnectionObject);
    if (FAILED(hr)) {
       return hr;
    }
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::put_CallHandle(long newVal)
{
    if (!newVal) {
       return E_INVALIDARG;
    }
    
    m_FaxJobParams->CallHandle = (HCALL)newVal;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CallHandle(long *pVal)
{	    
    if (!pVal) {
       return E_POINTER;
    }
    
    __try {
        *pVal = (long)m_FaxJobParams->CallHandle;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxport.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.cpp

Abstract:

    This module implements the port interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997

Revision History:

--*/

#include "stdafx.h"
#include "faxport.h"
#include "faxroute.h"
#include "status.h"



CFaxPort::CFaxPort()
{
    m_pFaxServer    = NULL;
    m_FaxPortHandle = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Rings         = 0;
    m_Send          = FALSE;
    m_Receive       = FALSE;
    m_Name          = NULL;
    m_Csid          = NULL;
    m_Tsid          = NULL;
    m_Modify        = FALSE;
}


CFaxPort::~CFaxPort()
{
    if (m_FaxPortHandle) {
        FaxClose( m_FaxPortHandle );
    }
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }
    if (m_Name) {
        SysFreeString( m_Name );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
}


BOOL
CFaxPort::Initialize(
    CFaxServer *i_pFaxServer,
    DWORD       i_DeviceId,
    DWORD       i_Rings,
    DWORD       i_Priority,
    DWORD       i_Flags,
    LPCWSTR     i_Csid,
    LPCWSTR     i_Tsid,
    LPCWSTR     i_DeviceName
    )
{
    HRESULT hr;
    
    m_pFaxServer = i_pFaxServer;
    m_DeviceId   = i_DeviceId;
    m_Rings      = i_Rings;
    m_Priority   = i_Priority;
    m_Csid       = SysAllocString( i_Csid);
    m_Tsid       = SysAllocString( i_Tsid);
    m_Name       = SysAllocString( i_DeviceName );
    m_Send       = i_Flags & FPF_SEND;
    m_Receive    = i_Flags & FPF_RECEIVE;    

    if ((!m_Csid && i_Csid) ||
        (!m_Tsid && i_Tsid) ||
        (!m_Name && i_DeviceName)) {
        SysFreeString( m_Csid );
        SysFreeString( m_Tsid );
        SysFreeString( m_Name );
        return FALSE;
    }

    if (!m_pFaxServer) {
        return FALSE;
    }

    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_MODIFY | PORT_OPEN_QUERY, &m_FaxPortHandle )) {
        if (GetLastError() == ERROR_ACCESS_DENIED) {
            if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_QUERY, &m_FaxPortHandle )) {
                m_LastFaxError = GetLastError();
                return FALSE;
            }
        } else {
            m_LastFaxError = GetLastError();
            return FALSE;
        }
    } else {
        m_Modify = TRUE;
    }

    return TRUE;
}


STDMETHODIMP CFaxPort::get_CanModify(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Modify;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


BOOL CFaxPort::ChangePort()
{
    if (!m_Modify) {
        return FALSE;
    }

    //
    // get the current port configuration
    //

    PFAX_PORT_INFOW PortInfo = NULL;
    DWORD PortInfoSize = 0;

    if (!FaxGetPort( m_FaxPortHandle, &PortInfo )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // set the values
    //

    PortInfo->Rings     = m_Rings;
    PortInfo->Priority  = m_Priority;
    PortInfo->Flags     = (PortInfo->Flags &~ (FPF_SEND | FPF_RECEIVE)) | (m_Send ? FPF_SEND : 0) | (m_Receive ? FPF_RECEIVE : 0);
    PortInfo->Csid      = m_Csid;
    PortInfo->Tsid      = m_Tsid;

    //
    // change the server's port configuration
    //

    if (!FaxSetPort( m_FaxPortHandle, PortInfo )) {
        m_LastFaxError = GetLastError();
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    //
    // clean up and bail
    //

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPort::get_Name(BSTR *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Name);

    if (!Copy  && m_Name) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
        
}


STDMETHODIMP CFaxPort::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
    
}


STDMETHODIMP CFaxPort::get_Rings(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Rings;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Rings(long newVal)
{
    long old = m_Rings;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Rings = newVal;

    if (!ChangePort()) {
        m_Rings = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Csid(BSTR newVal)
{
    BSTR old = m_Csid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Csid = tmp;
    
    if (!ChangePort()) {
        m_Csid = old;
        SysFreeString(tmp);
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);

    return S_OK;

}


STDMETHODIMP CFaxPort::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( m_Csid );
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Tsid(BSTR newVal)
{
    BSTR old = m_Tsid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Tsid = tmp;
    
    if (!ChangePort()) {
        m_Tsid = old;
        SysFreeString(tmp);
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Send(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Send;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::put_Send(BOOL newVal)
{
    BOOL old = m_Send;

    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Send = newVal;
    
    if (!ChangePort()) {
        m_Send = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Receive(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Receive(BOOL newVal)
{
    BOOL old = m_Receive;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Receive = newVal;

    if (!ChangePort()) {
        m_Receive = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Priority(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Priority;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Priority(long newVal)
{
    if (newVal < 0)
    {
        return E_INVALIDARG;
    }

    long old = m_Priority;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }

    m_Priority = newVal;

    if (!ChangePort()) {
        m_Priority = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::GetRoutingMethods(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxRoutingMethods>* p = new CComObject<CFaxRoutingMethods>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::GetStatus(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxStatus>* p = new CComObject<CFaxStatus>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;           
}


CFaxPorts::CFaxPorts()
{
    m_pFaxServer    = NULL;
    m_LastFaxError  = 0;
    m_PortCount     = 0;
    m_VarVect       = NULL;
}


CFaxPorts::~CFaxPorts()
{
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
    
}


BOOL CFaxPorts::Init(CFaxServer *pFaxServer)
{
    PFAX_PORT_INFOW     PortInfo = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumPortsW( m_pFaxServer->GetFaxHandle(), &PortInfo, &m_PortCount )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_PortCount];
    if (!m_VarVect) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    for (DWORD i=0; i<m_PortCount; i++) 
    {
        //
        // create the object
        //
        CComObject<CFaxPort> *pFaxPort;
        hr = CComObject<CFaxPort>::CreateInstance( &pFaxPort );

        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;            
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        if (!pFaxPort->Initialize(
            pFaxServer,
            PortInfo[i].DeviceId,
            PortInfo[i].Rings,
            PortInfo[i].Priority,
            PortInfo[i].Flags,
            PortInfo[i].Csid,
            PortInfo[i].Tsid,
            PortInfo[i].DeviceName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = GetLastError();
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxPort->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //
        __try {
            CComVariant &var = m_VarVect[i];
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;

            hr = S_OK;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_UNEXPECTED;
        }

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

    }

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPorts::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PortCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPorts::get_Item(long Index, VARIANT *retval)
{       
    if (!retval) {
        return E_POINTER;
    }

    if ((Index < 1) || (Index > (long) m_PortCount)) {
        return E_INVALIDARG;
    }
    
    

    __try {
        VariantInit( retval );

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        //
        // use 1-based index, VB like
        //
    
        return VariantCopy( retval, &m_VarVect[Index-1] );        

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxport.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.h

Abstract:

    This module contains the port class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXPORT_H_
#define __FAXPORT_H_

#include "resource.h"
#include <winfax.h>
#include "faxsvr.h"


class ATL_NO_VTABLE CFaxPorts :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CFaxPorts, &CLSID_FaxPorts>,
        public IDispatchImpl<IFaxPorts, &IID_IFaxPorts, &LIBID_FAXCOMLib>
{
public:
        CFaxPorts();
        ~CFaxPorts();
        BOOL Init(CFaxServer *pFaxServer);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORTS)

BEGIN_COM_MAP(CFaxPorts)
        COM_INTERFACE_ENTRY(IFaxPorts)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxPorts
public:
        STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
        STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

private:
    CFaxServer         *m_pFaxServer;
    DWORD               m_LastFaxError;
    DWORD               m_PortCount;
    CComVariant        *m_VarVect;

};

class ATL_NO_VTABLE CFaxPort :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxPort, &CLSID_FaxPort>,
    public IDispatchImpl<IFaxPort, &IID_IFaxPort, &LIBID_FAXCOMLib>
{
public:
    CFaxPort();
    ~CFaxPort();
    BOOL Initialize(CFaxServer*,DWORD,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
    HANDLE GetPortHandle() { return m_FaxPortHandle; };
    DWORD GetDeviceId() { return m_DeviceId; };
    BSTR GetDeviceName() { return m_Name; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORT)

BEGIN_COM_MAP(CFaxPort)
    COM_INTERFACE_ENTRY(IFaxPort)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(GetStatus)(/*[out, retval]*/ VARIANT* retval);
    STDMETHOD(GetRoutingMethods)(VARIANT* retval);
    STDMETHOD(get_CanModify)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Priority)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Priority)(/*[in]*/ long newVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Receive)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Send)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Csid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Rings)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Rings)(/*[in]*/ long newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);

private:
    BOOL ChangePort();

    CFaxServer         *m_pFaxServer;
    HANDLE              m_FaxPortHandle;
    BOOL                m_Send;
    BOOL                m_Receive;
    BOOL                m_Modify;
    BSTR                m_Name;
    BSTR                m_Csid;
    BSTR                m_Tsid;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    DWORD               m_Rings;
    DWORD               m_Priority;

};

#endif //__FAXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxtiff.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    This file contains the class definition for the faxtiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXTIFF_H_
#define __FAXTIFF_H_

#include "resource.h"       // main symbols
#include "tiff.h"
#include "faxutil.h"


class ATL_NO_VTABLE CFaxTiff :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxTiff, &CLSID_FaxTiff>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxTiff, &IID_IFaxTiff, &LIBID_FAXCOMLib>
{
public:
    CFaxTiff();
    ~CFaxTiff();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXTIFF)

BEGIN_COM_MAP(CFaxTiff)
    COM_INTERFACE_ENTRY(IFaxTiff)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxTiff
public:
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Routing)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Image)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Image)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ReceiveTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RawReceiveTime)(/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_TiffTagString)(/*[in]*/ int tagID, /*[out, retval]*/ BSTR* pVal);       

private:
    LPWSTR      GetStringTag(WORD TagId);
    DWORD       GetDWORDTag(WORD TagId);
    DWORDLONG   GetQWORDTag(WORD TagId);
    BSTR        GetString( LPCTSTR ResStr )
	{
		return SysAllocString(ResStr);
	}
    LPWSTR      AnsiStringToUnicodeString(LPSTR AnsiString);
    LPSTR       UnicodeStringToAnsiString(LPWSTR UnicodeString);


private:
    WCHAR                   m_wszTiffFileName[MAX_PATH+1];
    WCHAR                   m_wszStrBuf[128];
    HANDLE                  m_hFile;
    HANDLE                  m_hMap;
    LPBYTE                  m_pfPtr;
    PTIFF_HEADER            m_TiffHeader;
    DWORD                   m_dwNumDirEntries;
    UNALIGNED TIFF_TAG*     m_TiffTags;
};

#endif //__FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxroute.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.h

Abstract:

    This file implements the faxroute interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXROUTE_H_
#define __FAXROUTE_H_

#include "resource.h"       // main symbols
#include "faxport.h"
#include <winfax.h>


class ATL_NO_VTABLE CFaxRoutingMethods :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethods, &CLSID_FaxRoutingMethods>,
    public IDispatchImpl<IFaxRoutingMethods, &IID_IFaxRoutingMethods, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethods();
    ~CFaxRoutingMethods();
    BOOL Init(CFaxPort *pFaxPort);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHODS)

BEGIN_COM_MAP(CFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:    
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ long Index, /*[out, retval]*/ VARIANT *pVal);

private:
    DWORD               m_LastFaxError;
    CFaxPort           *m_pFaxPort;
    DWORD               m_MethodCount;
    CComVariant        *m_VarVect;
};


class ATL_NO_VTABLE CFaxRoutingMethod :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethod, &CLSID_FaxRoutingMethod>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxRoutingMethod, &IID_IFaxRoutingMethod, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethod();
    ~CFaxRoutingMethod();
    BOOL Initialize(CFaxPort *pFaxPort,DWORD,BOOL,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHOD)
DECLARE_NOT_AGGREGATABLE(CFaxRoutingMethod)

BEGIN_COM_MAP(CFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(get_RoutingData)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ExtensionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FunctionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Guid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Enable)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Enable)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);

private:
    CFaxPort           *m_pFaxPort;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    BOOL                m_Enabled;
    BSTR                m_DeviceName;
    BSTR                m_Guid;
    BSTR                m_FunctionName;
    BSTR                m_ImageName;
    BSTR                m_FriendlyName;
    BSTR                m_ExtensionName;
    LPBYTE              m_RoutingData;

};

#endif //__FAXROUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxstrings.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	FaxStrings.h

Abstract:

	Declaration of the strings that do not get localized.

Author:

	 Ishai Nadler	Oct, 2001

Revision History:

--*/

#define    IDS_PROJNAME            L"Faxcom"
#define    IDS_UNAVAILABLE         L"Unavailable"
#define    IDS_JOB_PENDING         L"Pending"
#define    IDS_JOB_INPROGRESS      L"In Progress"
#define    IDS_JOB_DELETING        L"Deleting"
#define    IDS_JOB_FAILED          L"Failed"
#define    IDS_JOB_PAUSED          L"Paused"
#define    IDS_JOB_UNKNOWN         L"Unknown"
#define    IDS_DEVICE_DIALING      L"Dialing"
#define    IDS_DEVICE_SENDING      L"Sending"
#define    IDS_DEVICE_RECEIVING    L"Receiving"
#define    IDS_DEVICE_COMPLETED    L"Completed"
#define    IDS_JOB_NOLINE          L"No Line"
#define    IDS_JOB_RETRYING        L"Retrying"
#define    IDS_JOB_RETRIESEXCEEDED L"Retries Exceeded"

#define    IDS_DEVICE_HANDLED      L"Handled"
#define    IDS_DEVICE_UNAVAILABLE  L"Unavailable"
#define    IDS_DEVICE_BUSY         L"Busy"
#define    IDS_DEVICE_NOANSWER     L"No Answer"
#define    IDS_DEVICE_BADADDRESS   L"Bad Address"
#define    IDS_DEVICE_NODIALTONE   L"No Dial Tone"
#define    IDS_DEVICE_DISCONNECTED L"Disconnected"
#define    IDS_DEVICE_FATALERROR   L"Fatal Error"
#define    IDS_DEVICE_NOTFAXCALL   L"Not a Fax Call"
#define    IDS_DEVICE_CALLDELAYED  L"Call Delayed"
#define    IDS_DEVICE_BLACKLISTED  L"Call Blacklisted"
#define    IDS_DEVICE_INITIALIZING L"Initializing"
#define    IDS_DEVICE_OFFLINE      L"Offline"
#define    IDS_DEVICE_RINGING      L"Ringing"
#define    IDS_DEVICE_AVAILABLE    L"Available"
#define    IDS_DEVICE_ABORTING     L"Aborting"

#define    IDS_DEVICE_ROUTING      L"Routing"
#define    IDS_DEVICE_ANSWERED     L"Answered"
#define    IDS_DEVICE_UNKNOWN      L"Unknown"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxtiff.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.cpp

Abstract:

    This file implements the FaxTiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "FaxTiff.h"
#include "FaxStrings.h"


CFaxTiff::CFaxTiff()
{
    m_hFile = INVALID_HANDLE_VALUE;
    m_hMap = NULL;
    m_pfPtr = NULL;
}


CFaxTiff::~CFaxTiff()
{
    if (m_hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( m_pfPtr );
        CloseHandle( m_hMap );
        CloseHandle( m_hFile );
    }
}


LPWSTR
CFaxTiff::AnsiStringToUnicodeString(
    LPSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) LocalAlloc( LPTR, Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}

LPSTR
CFaxTiff::UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) LocalAlloc( LPTR, Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}



LPWSTR CFaxTiff::GetStringTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_ASCII) {
                return NULL;
            }
            if (m_TiffTags[i].DataCount > 4) {
                return AnsiStringToUnicodeString( (LPSTR) (m_pfPtr + m_TiffTags[i].DataOffset) );
            }
            return AnsiStringToUnicodeString( (LPSTR) &m_TiffTags[i].DataOffset );
        }
    }

    return NULL;
}


DWORD CFaxTiff::GetDWORDTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_LONG) {
                return 0;
            }
            return m_TiffTags[i].DataOffset;
        }
    }
    return 0;
}


DWORDLONG CFaxTiff::GetQWORDTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_SRATIONAL) {
                return 0;
            }
            return *(UNALIGNED DWORDLONG*) (m_pfPtr + m_TiffTags[i].DataOffset);
        }
    }
    return 0;
}


STDMETHODIMP CFaxTiff::InterfaceSupportsErrorInfo(REFIID riid)
{
        static const IID* arr[] =
        {
                &IID_IFaxTiff,
        };
        for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
        {
                if (InlineIsEqualGUID(*arr[i],riid))
                        return S_OK;
        }
        return S_FALSE;
}

STDMETHODIMP CFaxTiff::get_ReceiveTime(BSTR * pVal)
{
    BSTR Copy = NULL;
    DWORD StrSize = 0;
    WCHAR DateStr[256];
    WCHAR TimeStr[128];
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;
    DWORDLONG ReceiveTime;
    BOOL bFail = FALSE;

    if (!pVal) 
    {
        return E_POINTER;
    }
    
    ReceiveTime = GetQWORDTag( TIFFTAG_FAX_END_TIME );
    if (ReceiveTime == 0) 
    {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
        goto copy;
    }

    if (!FileTimeToLocalFileTime( (FILETIME*) &ReceiveTime, &LocalTime ))
    {
        return HRESULT_FROM_WIN32 (GetLastError ());
    }
    if (!FileTimeToSystemTime( &LocalTime, &SystemTime ))
    {
        return HRESULT_FROM_WIN32 (GetLastError ());
    }

    StrSize = GetY2KCompliantDate (
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        DateStr,
        sizeof(DateStr)/sizeof(DateStr[0])
        );
    if (StrSize == 0) 
    {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    StrSize = FaxTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeStr,
        ARR_SIZE(TimeStr)
        );
    if (StrSize == 0) 
    {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    wcscat( DateStr, L" @ " );
    wcscat( DateStr, TimeStr );

    Copy = SysAllocString(DateStr);
                                     
copy:

    if (!Copy) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        if (bFail) 
        {
            return S_FALSE;
        }
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString( Copy );
    }
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Image(BSTR *FileName)
{
    if (!FileName) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_wszTiffFileName);

    if (!Copy  && m_wszTiffFileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *FileName = Copy;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::put_Image(BSTR FileName)
{
    if (!FileName) 
    {
        return E_POINTER;
    }    
    
    HRESULT Rslt = E_FAIL;
    //
    // if a file was previously open, then close it
    //
    if (m_hFile != INVALID_HANDLE_VALUE) 
    {
        UnmapViewOfFile( m_pfPtr );
        CloseHandle( m_hMap );
        CloseHandle( m_hFile );
    }
    //
    // open the tiff file
    //

    m_hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (m_hFile == INVALID_HANDLE_VALUE) 
    {
        goto exit;
    }

    m_hMap = CreateFileMapping(
        m_hFile,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!m_hMap) 
    {
        goto exit;
    }

    m_pfPtr = (LPBYTE) MapViewOfFile(
        m_hMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!m_pfPtr) 
    {
        goto exit;
    }

    m_TiffHeader = (PTIFF_HEADER) m_pfPtr;
    //
    // validate that the file is really a tiff file
    //
    if ((m_TiffHeader->Identifier != TIFF_LITTLEENDIAN) || (m_TiffHeader->Version != TIFF_VERSION)) 
    {
        goto exit;
    }
    //
    // get the tag count
    //
    m_dwNumDirEntries = *(LPWORD)(m_pfPtr + m_TiffHeader->IFDOffset);
    //
    // get a pointer to the tags
    //
    m_TiffTags = (UNALIGNED TIFF_TAG*) (m_pfPtr + m_TiffHeader->IFDOffset + sizeof(WORD));
    //
    // save the file name
    //
    wcscpy( m_wszTiffFileName, FileName );
    //
    // set a good return value
    //
    Rslt = 0;

exit:
    if (FAILED(Rslt)) 
    {
        if (m_hFile != INVALID_HANDLE_VALUE) 
        {
            if (m_pfPtr) 
            {
                UnmapViewOfFile( m_pfPtr );
            }
            if (m_hMap) 
            {
                CloseHandle( m_hMap );
            }
            CloseHandle( m_hFile );
            m_hFile = INVALID_HANDLE_VALUE;
            m_hMap = NULL;
            m_pfPtr = NULL;
        }
    }
    return Rslt;
}

STDMETHODIMP CFaxTiff::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipName = GetStringTag( TIFFTAG_RECIP_NAME );
    if (!RecipName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = FALSE;
    } else {
        Copy = SysAllocString(RecipName);
        LocalFree( RecipName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try { 
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}


STDMETHODIMP CFaxTiff::get_RecipientNumber(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipNumber = GetStringTag( TIFFTAG_RECIP_NUMBER );
    if (!RecipNumber) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString(RecipNumber);
        LocalFree( RecipNumber );
    }
    
    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

     } __except (EXCEPTION_EXECUTE_HANDLER) {

         SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR SenderName = GetStringTag( TIFFTAG_SENDER_NAME );
    if (!SenderName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString(SenderName);
        LocalFree( SenderName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_Routing(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
   
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Routing = GetStringTag( TIFFTAG_ROUTING );
    if (!Routing) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString(Routing);
        LocalFree( Routing );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR CallerId = GetStringTag( TIFFTAG_CALLERID );
    if (!CallerId) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( CallerId );
        LocalFree( CallerId );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Csid = GetStringTag( TIFFTAG_CSID );
    if (!Csid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Csid );
        LocalFree( Csid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Tsid = GetStringTag( TIFFTAG_TSID );
    if (!Tsid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Tsid );
        LocalFree( Tsid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_RawReceiveTime(VARIANT *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    VARIANT local;
    DWORDLONG ReceiveTime = GetQWORDTag( TIFFTAG_FAX_END_TIME );
    
    ZeroMemory(&local, sizeof(local));

    local.vt = VT_CY;
    local.cyVal.Lo = (DWORD)(ReceiveTime & 0xFFFFFFFF);
    local.cyVal.Hi = (LONG) (ReceiveTime >> 32);    

    //
    // can't use VariantCopy because this is a caller allocated variant
    //
    __try {
        
        pVal->vt       = local.vt;
        pVal->cyVal.Lo = local.cyVal.Lo;
        pVal->cyVal.Hi = local.cyVal.Hi;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
    
    return E_UNEXPECTED;

}   

STDMETHODIMP CFaxTiff::get_TiffTagString(
    int tagID,
    BSTR* pVal
    )
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    LPWSTR  lpwstrValue = NULL;
    BSTR    bstrResult = NULL;
    bool    bFail = FALSE;

    //
    //  This does LocalAlloc and returns LPWSTR
    //
    lpwstrValue = GetStringTag( (WORD)tagID );
    if (!lpwstrValue) 
    {
        //
        //  This does SysAllocString and returns BSTR
        //
        bstrResult = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } 
    else
    {
        bstrResult = SysAllocString(lpwstrValue);
        LocalFree(lpwstrValue);
    }

    //
    //  Failed to SysAllocString in either case
    //
    if (!bstrResult)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Now try to return bstrResult
    //
    __try 
    {
        
        *pVal = bstrResult;
        if (bFail) 
        {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        //
        //  Failed to return bstrResult
        //
        SysFreeString(bstrResult);
    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxsvr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxsvr.h

Abstract:

    This module contains the fax server class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXSERVER_H_
#define __FAXSERVER_H_

#include "resource.h"       // main symbols
#include "winfax.h"

class ATL_NO_VTABLE CFaxServer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxServer, &CLSID_FaxServer>,
    public IDispatchImpl<IFaxServer, &IID_IFaxServer, &LIBID_FAXCOMLib>
{
public:
    CFaxServer();
    ~CFaxServer();
    HANDLE GetFaxHandle() { return m_FaxHandle; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSERVER)

BEGIN_COM_MAP(CFaxServer)
    COM_INTERFACE_ENTRY(IFaxServer)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
	STDMETHOD(get_DiscountRateEndMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateEndHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndHour)(/*[in]*/ short newVal);
    STDMETHOD(get_DiscountRateStartMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateStartHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartHour)(/*[in]*/ short newVal);
	STDMETHOD(get_ServerMapiProfile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ServerMapiProfile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ArchiveDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveOutboundFaxes)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ArchiveOutboundFaxes)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_PauseServerQueue)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PauseServerQueue)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_UseDeviceTsid)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_UseDeviceTsid)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_Branding)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Branding)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_DirtyDays)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DirtyDays)(/*[in]*/ long newVal);
	STDMETHOD(get_RetryDelay)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_RetryDelay)(/*[in]*/ long newVal);
	STDMETHOD(get_Retries)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Retries)(/*[in]*/ long newVal);
	STDMETHOD(GetJobs)(VARIANT *retval);
	STDMETHOD(CreateDocument)(BSTR FileName, VARIANT *retval);
    STDMETHOD(GetPorts)(VARIANT* retval);
    STDMETHOD(Disconnect)();
    STDMETHOD(Connect)(BSTR ServerName);

private:
	BOOL UpdateConfiguration();
	BOOL RetrieveConfiguration();
    DWORD   m_LastFaxError;
    HANDLE  m_FaxHandle;
    BOOL		m_Branding;
	DWORD		m_Retries;
	DWORD		m_RetryDelay;
	DWORD		m_DirtyDays;
	BOOL		m_UseDeviceTsid;
	BOOL		m_ServerCp;
	BOOL		m_PauseServerQueue;
	FAX_TIME	m_StartCheapTime;
	FAX_TIME	m_StopCheapTime;
	BOOL		m_ArchiveOutgoingFaxes;
	BSTR		m_ArchiveDirectory;
};


BSTR GetDeviceStatus(DWORD);
BSTR GetQueueStatus(DWORD);

#endif //__FAXSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxroute.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.cpp

Abstract:

    This file implements the CFaxRoutingMethod and
    CFaxRoutingMethods interfaces.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxroute.h"



CFaxRoutingMethod::CFaxRoutingMethod()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Enabled       = FALSE;
    m_DeviceName    = NULL;
    m_Guid          = NULL;
    m_FunctionName  = NULL;
    m_ImageName     = NULL;
    m_FriendlyName  = NULL;
}


CFaxRoutingMethod::~CFaxRoutingMethod()
{
    if (m_pFaxPort) 
    {
        m_pFaxPort->Release();
    }

    SysFreeString( m_DeviceName );
    SysFreeString( m_Guid );
    SysFreeString( m_FunctionName );
    SysFreeString( m_ImageName );
    SysFreeString( m_FriendlyName );
    SysFreeString( m_ExtensionName );
    FaxFreeBuffer( m_RoutingData );
}


BOOL
CFaxRoutingMethod::Initialize(
    CFaxPort *i_pFaxPort,
    DWORD  i_DeviceId,
    BOOL   i_Enabled,
    LPCWSTR i_DeviceName,
    LPCWSTR i_Guid,
    LPCWSTR i_FunctionName,
    LPCWSTR i_FriendlyName,
    LPCWSTR i_ImageName,
    LPCWSTR i_ExtensionName
    )
{
    m_pFaxPort = i_pFaxPort;
    if (!m_pFaxPort) 
    {
        return FALSE;
    }

    if ( FAILED(m_pFaxPort->AddRef()) )
    {
        m_pFaxPort = NULL;
        return FALSE;
    }

    m_DeviceId          = i_DeviceId;
    m_Enabled           = i_Enabled;
    m_DeviceName        = SysAllocString(i_DeviceName);
    m_Guid              = SysAllocString(i_Guid);
    m_FunctionName      = SysAllocString(i_FunctionName);
    m_ImageName         = SysAllocString(i_ImageName);
    m_FriendlyName      = SysAllocString(i_FriendlyName);
    m_ExtensionName     = SysAllocString(i_ExtensionName);
    m_RoutingData       = NULL;

    if ( (!m_DeviceName && i_DeviceName) ||
         (!m_Guid && i_Guid) ||
         (!m_FunctionName && i_FunctionName) ||
         (!m_ImageName && i_ImageName) ||
         (!m_FriendlyName && i_FriendlyName) ||
         (!m_ExtensionName && i_ExtensionName)
       ) 
    {
        m_LastFaxError = E_OUTOFMEMORY;
        goto error;
    }

    DWORD Size = 0;
    if (!FaxGetRoutingInfoW( m_pFaxPort->GetPortHandle(), m_Guid, &m_RoutingData, &Size )) 
    {
        m_RoutingData = NULL;
        m_LastFaxError = GetLastError();
        goto error;
    }

    if (Size == 0) 
    {
        FaxFreeBuffer( m_RoutingData );
        m_RoutingData = NULL;
    }

    return TRUE;

error:
    SysFreeString(m_DeviceName);   
    SysFreeString(m_Guid);         
    SysFreeString(m_FunctionName); 
    SysFreeString(m_ImageName);    
    SysFreeString(m_FriendlyName); 
    SysFreeString(m_ExtensionName);

    m_pFaxPort->Release();
    m_pFaxPort = NULL;

    return FALSE;

}


STDMETHODIMP CFaxRoutingMethod::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxRoutingMethod };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethod::get_Enable(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Enabled;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
    
}


STDMETHODIMP CFaxRoutingMethod::put_Enable(BOOL newVal)
{
    if (!FaxEnableRoutingMethodW( m_pFaxPort->GetPortHandle(), m_Guid, newVal)) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }
    m_Enabled = newVal;
    return S_OK;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DeviceName);
    if (!Copy  && m_DeviceName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_Guid(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Guid);
    if (!Copy  && m_Guid) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_FunctionName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FunctionName);
    if (!Copy && m_FunctionName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_ImageName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ImageName);
    if (!Copy && m_ImageName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;        
}


STDMETHODIMP CFaxRoutingMethod::get_FriendlyName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FriendlyName);
    if (!Copy  && m_FriendlyName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_ExtensionName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ExtensionName);
    if (!Copy  && m_ExtensionName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_RoutingData(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = NULL;

    __try 
    {
        if (m_RoutingData == NULL) 
        {        
            Copy = SysAllocString(_T(""));            
            if (!Copy) 
            {
                return E_OUTOFMEMORY;
            }
        } 
        else if (*((LPDWORD)m_RoutingData) == 0 || *((LPDWORD)m_RoutingData) == 1) 
        {
            Copy = SysAllocString((LPWSTR)(m_RoutingData + sizeof(DWORD)) );
            if (!Copy && ((LPWSTR)(m_RoutingData + sizeof(DWORD))) )
            {
                return E_OUTOFMEMORY;
            }
        } 
        else 
        {
            return E_UNEXPECTED;
        }

        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


CFaxRoutingMethods::CFaxRoutingMethods()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = 0;
    m_MethodCount   = 0;
    m_VarVect       = NULL;
}


CFaxRoutingMethods::~CFaxRoutingMethods()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
}


BOOL CFaxRoutingMethods::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    if (!pFaxPort) 
    {
        return FALSE;
    }

    m_pFaxPort = pFaxPort;
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) 
    {
        m_pFaxPort = NULL;
        return FALSE;
    }

    PFAX_ROUTING_METHODW RoutingMethod = NULL;
    DWORD Size = 0;

    //
    // get the routing methods from the server
    //

    if (!FaxEnumRoutingMethodsW( m_pFaxPort->GetPortHandle(), &RoutingMethod, &m_MethodCount )) 
    {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the methods
    //

    m_VarVect = new CComVariant[m_MethodCount];
    if (!m_VarVect) 
    {
        FaxFreeBuffer( RoutingMethod );
        return FALSE;
    }

    for (DWORD i=0; i<m_MethodCount; i++) 
    {
        //
        // create the object
        //
        CComObject<CFaxRoutingMethod> *pFaxRoutingMethod;
        hr = CComObject<CFaxRoutingMethod>::CreateInstance( &pFaxRoutingMethod );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }
        //
        // set the values
        //
        if (!pFaxRoutingMethod->Initialize(
            m_pFaxPort,
            RoutingMethod[i].DeviceId,
            RoutingMethod[i].Enabled,
            RoutingMethod[i].DeviceName,
            RoutingMethod[i].Guid,
            RoutingMethod[i].FunctionName,
            RoutingMethod[i].FriendlyName,
            RoutingMethod[i].ExtensionImageName,
            RoutingMethod[i].ExtensionFriendlyName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxRoutingMethod->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        __try 
        {
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;
            hr = S_OK;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            hr = E_UNEXPECTED;            
        }

        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }
    }

    FaxFreeBuffer( RoutingMethod );

    return TRUE;
}


STDMETHODIMP CFaxRoutingMethods::get_Item(long Index, VARIANT * retval)
{
    if (!retval) 
    {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_MethodCount)) {
        return E_INVALIDARG;
    }

    __try 
    {
        VariantInit( retval );
    
        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        return VariantCopy( retval, &m_VarVect[Index-1] );
        
    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }    

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethods::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_MethodCount;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\faxsvr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsvr.cpp

Abstract:

    This file implements the CFaxServer interface.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxsvr.h"
#include "faxport.h"
#include "FaxDoc.h"
#include "FaxJob.h"




CFaxServer::CFaxServer()
{
    m_LastFaxError			= NO_ERROR;
    m_FaxHandle				= 0;
	m_Retries				= 0;
	m_RetryDelay			= 0;
	m_DirtyDays				= 0;
	m_UseDeviceTsid			= FALSE;
	m_ServerCp				= FALSE;
	m_PauseServerQueue		= FALSE;;
	m_StartCheapTime.Hour	= 0;
    m_StartCheapTime.Minute	= 0;
	m_StopCheapTime.Hour    = 0;
    m_StartCheapTime.Minute	= 0;
	m_ArchiveOutgoingFaxes  = FALSE;;
	m_ArchiveDirectory		= NULL;
}


CFaxServer::~CFaxServer()
{
    if (m_FaxHandle) 
    {
        FaxClose( m_FaxHandle );
    }

	if (m_ArchiveDirectory)
    {
        SysFreeString(m_ArchiveDirectory);	
    }
}


STDMETHODIMP CFaxServer::Connect(BSTR ServerName)
{
    if (!FaxConnectFaxServer( ServerName, &m_FaxHandle )) {
        m_LastFaxError = GetLastError();
        m_FaxHandle = NULL;
        return E_FAIL;
    }

	if (!RetrieveConfiguration()) {
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	
    return S_OK;
}

STDMETHODIMP CFaxServer::Disconnect()
{
    if (m_FaxHandle == NULL) {
        return E_FAIL;
    }

    if (!FaxClose( m_FaxHandle )) {
        return E_FAIL;
    }

    m_FaxHandle = NULL;
	m_Retries = 0;
	m_RetryDelay = 0;
	m_DirtyDays = 0 ;
	m_Branding = FALSE;
	m_UseDeviceTsid = FALSE;
	m_ServerCp = FALSE;
	m_PauseServerQueue = FALSE;
	m_StartCheapTime.Hour = 0;
	m_StartCheapTime.Minute = 0;
	m_StopCheapTime.Hour = 0;
	m_StopCheapTime.Minute = 0;
	m_StartCheapTime.Hour = 0;
	m_ArchiveOutgoingFaxes = FALSE;

	if (m_ArchiveDirectory)
    {
        SysFreeString(m_ArchiveDirectory);
    }
	m_ArchiveDirectory = NULL;

    return S_OK;
}


STDMETHODIMP CFaxServer::GetPorts(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }

    CComObject<CFaxPorts>* p = new CComObject<CFaxPorts>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;        
    }

    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxServer::CreateDocument(BSTR FileName, VARIANT * retval)
{
    HRESULT hr;

    if (!FileName || !retval) {
        return E_POINTER;
    }

    CComObject<CFaxDoc>* p = new CComObject<CFaxDoc>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(FileName,this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::GetJobs(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return(E_POINTER);
    }
    
    CComObject<CFaxJobs>* p = new CComObject<CFaxJobs>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }
    
    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }
    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::get_Retries(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Retries;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_Retries(long newVal)
{
    long oldval = m_Retries;

	m_Retries = newVal;
	
	if (!UpdateConfiguration() ) {
        m_Retries = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_RetryDelay(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_RetryDelay;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_RetryDelay(long newVal)
{
    long oldval = m_RetryDelay;
	m_RetryDelay = newVal;
	
    if (!UpdateConfiguration() ) {
        m_RetryDelay = oldval;    
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;
}

STDMETHODIMP CFaxServer::get_DirtyDays(long * pVal)
{
    if (!pVal) {
    return E_POINTER;
    }

    __try {
        *pVal = m_DirtyDays;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    
    }

    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxServer::put_DirtyDays(long newVal)
{
	long oldval = m_DirtyDays;
    m_DirtyDays = newVal;
	
    if (!UpdateConfiguration() ) {
        m_DirtyDays = oldval;    
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_Branding(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Branding;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_Branding(BOOL newVal)
{
	BOOL oldval = m_Branding;
    m_Branding = newVal;
	
    if (!UpdateConfiguration() ) {
        m_Branding = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_UseDeviceTsid(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_UseDeviceTsid;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_UseDeviceTsid(BOOL newVal)
{
	BOOL oldval = m_UseDeviceTsid;
    m_UseDeviceTsid= newVal;
	
	if (!UpdateConfiguration() ) {
        m_UseDeviceTsid = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ServerCp;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_ServerCoverpage(BOOL newVal)
{
	BOOL oldval = m_ServerCp;
    m_ServerCp = newVal;
	
	if (!UpdateConfiguration() ) {
		m_ServerCp = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_PauseServerQueue(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_PauseServerQueue;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_PauseServerQueue(BOOL newVal)
{
	BOOL oldval = m_PauseServerQueue;
    m_PauseServerQueue = newVal;
	
	if (!UpdateConfiguration() ) {
		m_PauseServerQueue = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_ArchiveOutboundFaxes(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ArchiveOutgoingFaxes;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_ArchiveOutboundFaxes(BOOL newVal)
{
	BOOL oldval = m_ArchiveOutgoingFaxes;
    m_ArchiveOutgoingFaxes = newVal;
	
	if (!UpdateConfiguration() ) {
        m_ArchiveOutgoingFaxes = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ArchiveDirectory(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_ArchiveDirectory);

    if (!Copy  && m_ArchiveDirectory) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_ArchiveDirectory(BSTR newVal)
{
	BSTR tmp = SysAllocString(newVal);
    BSTR old = m_ArchiveDirectory;
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
        
    m_ArchiveDirectory = tmp;    
	
	if (!UpdateConfiguration() ) {
        SysFreeString(tmp);
        m_ArchiveDirectory = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    } else {
        SysFreeString(old);        
        return S_OK;
    }
}

STDMETHODIMP CFaxServer::get_ServerMapiProfile(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(_T(""));
    if (!Copy) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
    
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxServer::put_ServerMapiProfile(BSTR newVal)
{
    return E_NOTIMPL;
}


STDMETHODIMP CFaxServer::get_DiscountRateStartHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartHour(short newVal)
{
	short old = m_StartCheapTime.Hour;
    m_StartCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Hour = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateStartMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartMinute(short newVal)
{
	short old = m_StartCheapTime.Minute;
    m_StartCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Minute = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndHour(short newVal)
{
	short old = m_StopCheapTime.Hour;
    m_StopCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Hour = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndMinute(short newVal)
{
	short old = m_StopCheapTime.Minute;
    m_StopCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Minute = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}


BOOL CFaxServer::RetrieveConfiguration()
{	    
    if (!m_FaxHandle) {
		return FALSE;
	}

	PFAX_CONFIGURATIONW FaxConfig;

	if (!FaxGetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

	m_Retries = FaxConfig->Retries;
	m_RetryDelay =FaxConfig->RetryDelay;
	m_DirtyDays = FaxConfig->DirtyDays;
	m_Branding = FaxConfig->Branding;
	m_UseDeviceTsid = FaxConfig->UseDeviceTsid;
	m_ServerCp = FaxConfig->ServerCp;
	m_PauseServerQueue = FaxConfig->PauseServerQueue;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_StartCheapTime.Minute = FaxConfig->StartCheapTime.Minute;
	m_StopCheapTime.Hour = FaxConfig->StopCheapTime.Hour;
	m_StopCheapTime.Minute = FaxConfig->StopCheapTime.Minute;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_ArchiveOutgoingFaxes = FaxConfig->ArchiveOutgoingFaxes;
	m_ArchiveDirectory = SysAllocString(FaxConfig->ArchiveDirectory);
    if ((!m_ArchiveDirectory && FaxConfig->ArchiveDirectory)) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
    }

    FaxFreeBuffer(FaxConfig);    

    return (m_LastFaxError == NO_ERROR) ? TRUE : FALSE;

}

BOOL CFaxServer::UpdateConfiguration()
{
	if (!m_FaxHandle) {
		return FALSE;
	}

	FAX_CONFIGURATIONW FaxConfig;

	ZeroMemory(&FaxConfig,sizeof(FAX_CONFIGURATIONW) );
    FaxConfig.SizeOfStruct = sizeof(FAX_CONFIGURATIONW);
	FaxConfig.Retries = m_Retries;
	FaxConfig.RetryDelay = m_RetryDelay ;
	FaxConfig.DirtyDays = m_DirtyDays;
	FaxConfig.Branding = m_Branding;
	FaxConfig.UseDeviceTsid = m_UseDeviceTsid;
	FaxConfig.ServerCp = m_ServerCp;
	FaxConfig.PauseServerQueue = m_PauseServerQueue;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.StartCheapTime.Minute = m_StartCheapTime.Minute;
	FaxConfig.StopCheapTime.Hour = m_StopCheapTime.Hour;
	FaxConfig.StopCheapTime.Minute = m_StopCheapTime.Minute;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.ArchiveOutgoingFaxes = m_ArchiveOutgoingFaxes;
	FaxConfig.ArchiveDirectory = m_ArchiveDirectory;

	if (!FaxSetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxcom.rc
//

#define IDR_FAXTIFF                     101
#define IDR_FAXSERVER                   102
#define IDR_FAXPORT                     103
#define IDR_FAXPORTS                    104
#define IDR_FAXROUTINGMETHOD            105
#define IDR_FAXROUTINGMETHODS           106
#define IDR_FAXSTATUS                   107
#define IDR_FAXDOC                      108
#define IDR_FAXJOBS                     109
#define IDR_FAXJOB                      111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\stdafx.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stdafx.cpp

Abstract:

    This file contains the static support code for the
    atl controls in this project.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\util.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <winfax.h>
#include "FaxStrings.h"

extern CComModule _Module;

BSTR GetQueueStatus(DWORD QueueStatus) 
{
    LPCTSTR lpcstrQueueStatus = NULL;

    if (QueueStatus & JS_INPROGRESS)      
    {
        lpcstrQueueStatus = IDS_JOB_INPROGRESS;
    } 
    if (QueueStatus & JS_NOLINE)      
    {
        lpcstrQueueStatus = IDS_JOB_NOLINE;
    } 
    else if (QueueStatus & JS_DELETING) 
    {
        lpcstrQueueStatus = IDS_JOB_DELETING;
    } 
    else if (QueueStatus & JS_FAILED)   
    {
        lpcstrQueueStatus = IDS_JOB_FAILED;
    } 
    else if (QueueStatus & JS_PAUSED)   
    {
        lpcstrQueueStatus = IDS_JOB_PAUSED;
    } 
    if (JS_RETRYING == QueueStatus)      
    {
        lpcstrQueueStatus = IDS_JOB_RETRYING;
    } 
    if (JS_RETRIES_EXCEEDED == QueueStatus)      
    {
        lpcstrQueueStatus = IDS_JOB_RETRIESEXCEEDED;
    } 
    else if (JS_PENDING == QueueStatus) 
    {
        lpcstrQueueStatus = IDS_JOB_PENDING;
    } 
    else
    {
        lpcstrQueueStatus = IDS_JOB_UNKNOWN;
    }
    return SysAllocString(lpcstrQueueStatus);
}


BSTR GetDeviceStatus(DWORD DeviceStatus)
{
    LPCTSTR  lpcstrDeviceStatus = NULL;

    if (DeviceStatus == FPS_DIALING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_DIALING;
    } 
    else if (DeviceStatus == FPS_SENDING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_SENDING;
    } 
    else if (DeviceStatus == FPS_RECEIVING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_RECEIVING;
    } 
    else if (DeviceStatus == FPS_COMPLETED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_COMPLETED;
    } 
    else if (DeviceStatus == FPS_HANDLED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_HANDLED;
    } 
    else if (DeviceStatus == FPS_UNAVAILABLE) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_UNAVAILABLE;
    } 
    else if (DeviceStatus == FPS_BUSY) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_BUSY;
    } 
    else if (DeviceStatus == FPS_NO_ANSWER) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_NOANSWER;
    } 
    else if (DeviceStatus == FPS_BAD_ADDRESS) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_BADADDRESS; 
    } 
    else if (DeviceStatus == FPS_NO_DIAL_TONE) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_NODIALTONE;
    } 
    else if (DeviceStatus == FPS_DISCONNECTED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_DISCONNECTED;
    } 
    else if (DeviceStatus == FPS_FATAL_ERROR) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_FATALERROR;
    } 
    else if (DeviceStatus == FPS_NOT_FAX_CALL) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_NOTFAXCALL;
    } 
    else if (DeviceStatus == FPS_CALL_DELAYED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_CALLDELAYED;
    } 
    else if (DeviceStatus == FPS_CALL_BLACKLISTED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_BLACKLISTED;
    } 
    else if (DeviceStatus == FPS_INITIALIZING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_INITIALIZING;
    } 
    else if (DeviceStatus == FPS_OFFLINE) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_OFFLINE;
    } 
    else if (DeviceStatus == FPS_RINGING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_RINGING;
    } 
    else if (DeviceStatus == FPS_AVAILABLE) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_AVAILABLE;
    } 
    else if (DeviceStatus == FPS_ABORTING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_ABORTING;
    } 
    else if (DeviceStatus == FPS_ROUTING) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_ROUTING;
    } 
    else if (DeviceStatus == FPS_ANSWERED) 
    {
        lpcstrDeviceStatus = IDS_DEVICE_ANSWERED;
    } 
    else 
    {
        lpcstrDeviceStatus = IDS_DEVICE_UNKNOWN;
    }
    return SysAllocString(lpcstrDeviceStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\status.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    status.cpp

Abstract:

    This module implements the status interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#include "stdafx.h"
#include "faxcom.h"
#include "status.h"



CFaxStatus::CFaxStatus()
{
    m_pFaxPort          = NULL;
    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


CFaxStatus::~CFaxStatus()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    FreeMemory();
}


void CFaxStatus::FreeMemory()
{
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
    if (m_Description) {
        SysFreeString( m_Description );
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName );
    }
    if (m_SenderName) {
        SysFreeString( m_SenderName );
    }
    if (m_RoutingString) {
        SysFreeString( m_RoutingString );
    }    
    if (m_Address) {
        SysFreeString( m_Address );
    }
    if (m_DocName) {
        SysFreeString( m_DocName );
    }
    if (m_DeviceName) {
        SysFreeString( m_DeviceName );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_CallerId) {
        SysFreeString( m_CallerId );
    }

    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;    
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;    
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


BOOL CFaxStatus::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    m_pFaxPort = pFaxPort;
    
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) {
        m_pFaxPort = NULL;
        return FALSE;
    }

    hr = Refresh();
    if (FAILED(hr)) {
        return FALSE;
    }
    return TRUE;
}


STDMETHODIMP CFaxStatus::Refresh()
{
    PFAX_DEVICE_STATUSW FaxStatus = NULL;
    DWORD Size = 0;
    DWORDLONG ElapsedTime;
    DWORDLONG CurrentFileTime;
    SYSTEMTIME CurrentTime;
    HRESULT hr = S_OK;


    if (!FaxGetDeviceStatusW( m_pFaxPort->GetPortHandle(), &FaxStatus )) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    FreeMemory();

    m_PageCount         = FaxStatus->TotalPages;
    m_DocSize           = FaxStatus->Size;
    m_DeviceId          = m_pFaxPort->GetDeviceId();
    m_CurrentPage       = FaxStatus->CurrentPage;

    m_Receive           = FaxStatus->JobType == JT_RECEIVE ? TRUE : FALSE;
    m_Send              = FaxStatus->JobType == JT_SEND ? TRUE : FALSE;

    if (FaxStatus->Tsid) {
        m_Tsid = SysAllocString( FaxStatus->Tsid );
        if (!m_Tsid) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->StatusString) {
        m_Description = SysAllocString( FaxStatus->StatusString );
        if (!m_Description) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->RecipientName) {
        m_RecipientName = SysAllocString( FaxStatus->RecipientName );
        if (!m_RecipientName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->SenderName) {
        m_SenderName = SysAllocString( FaxStatus->SenderName );
        if (!m_SenderName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->RoutingString) {
        m_RoutingString = SysAllocString( FaxStatus->RoutingString );
        if (!m_RoutingString) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->PhoneNumber) {
        m_Address = SysAllocString( FaxStatus->PhoneNumber );
        if (!m_Address) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->DocumentName) {
        m_DocName = SysAllocString( FaxStatus->DocumentName );
        if (!m_DocName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->DeviceName) {
        m_DeviceName = SysAllocString( FaxStatus->DeviceName );
        if (!m_DeviceName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->Csid) {
        m_Csid = SysAllocString( FaxStatus->Csid );
        if (!m_Csid) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->CallerId) {
        m_CallerId = SysAllocString( FaxStatus->CallerId );
        if (!m_CallerId) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    m_Description = GetDeviceStatus(FaxStatus->Status);
    if (!m_Description) {
            hr = E_OUTOFMEMORY;
            goto error;
    }

    if (!FileTimeToSystemTime( &FaxStatus->StartTime, &m_StartTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (!FileTimeToSystemTime( &FaxStatus->SubmittedTime, &m_SubmittedTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    GetSystemTime( &CurrentTime );

    if (!SystemTimeToFileTime( &CurrentTime, (FILETIME*)&ElapsedTime ))
    {
        //
        //  Failed to convert System Time to File Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (!SystemTimeToFileTime( &m_StartTime, (FILETIME*)&CurrentFileTime ))
    {
        //
        //  Failed to convert System Time to File Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    ElapsedTime = ElapsedTime - CurrentFileTime;

    if (!FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &m_ElapsedTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    hr = ERROR_SUCCESS;

error:

    if (FAILED(hr))
    {
        //
        //  Make the object consistent
        //
        FreeMemory();
    }

    FaxFreeBuffer( FaxStatus );
    return hr;
}


STDMETHODIMP CFaxStatus::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxStatus };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxStatus::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_CallerId);

    if (!Copy  && m_CallerId) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_CurrentPage(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_CurrentPage;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceId(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DeviceName);

    if (!Copy  && m_DeviceName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DocName);

    if (!Copy  && m_DocName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Send(BOOL * pVal)
{
    *pVal = m_Send;
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_Receive(BOOL * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Address(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Address);

    if (!Copy  && m_Address) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;}


STDMETHODIMP CFaxStatus::get_RoutingString(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RoutingString);

    if (!Copy  && m_RoutingString) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_SenderName);

    if (!Copy  && m_SenderName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RecipientName);

    if (!Copy  && m_RecipientName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentSize(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DocSize;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Description(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Description);

    if (!Copy  && m_Description) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_PageCount(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PageCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy ;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_StartTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_StartTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_SubmittedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_SubmittedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_ElapsedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_ElapsedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_)
#define AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "faxcom.h"
#include "winfax.h"

inline 
HRESULT Fax_HRESULT_FROM_WIN32 (DWORD dwWin32Err)
{
    if (dwWin32Err >= FAX_ERR_START && dwWin32Err <= FAX_ERR_END)
    {
        //
        // Fax specific error code - make a HRESULT using FACILITY_ITF
        //
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, dwWin32Err);
    }
    else
    {
        return HRESULT_FROM_WIN32(dwWin32Err);
    }
}   // Fax_HRESULT_FROM_WIN32

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\com\win2k\status.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    status.h

Abstract:

    This file implements the status interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXSTATUS_H_
#define __FAXSTATUS_H_

#include "resource.h"
#include "faxport.h"
#include <winfax.h>

class ATL_NO_VTABLE CFaxStatus :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxStatus, &CLSID_FaxStatus>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxStatus, &IID_IFaxStatus, &LIBID_FAXCOMLib>
{
public:
    CFaxStatus();
    ~CFaxStatus();
    BOOL Init(CFaxPort *pFaxPort);
    void FreeMemory();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSTATUS)
DECLARE_NOT_AGGREGATABLE(CFaxStatus)

BEGIN_COM_MAP(CFaxStatus)
    COM_INTERFACE_ENTRY(IFaxStatus)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(Refresh)();
    STDMETHOD(get_ElapsedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_SubmittedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DocumentSize)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RoutingString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Address)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);

private:
    CFaxPort       *m_pFaxPort;
    BOOL            m_Receive;
    BOOL            m_Send;
    BSTR            m_Tsid;
    BSTR            m_Description;
    BSTR            m_RecipientName;
    BSTR            m_SenderName;
    BSTR            m_RoutingString;
    BSTR            m_Address;
    BSTR            m_DocName;
    BSTR            m_DeviceName;
    BSTR            m_Csid;
    BSTR            m_CallerId;
    DWORD           m_PageCount;
    DWORD           m_DocSize;
    DWORD           m_DeviceId;
    DWORD           m_CurrentPage;
    SYSTEMTIME      m_StartTime;
    SYSTEMTIME      m_SubmittedTime;
    SYSTEMTIME      m_ElapsedTime;

};

#endif //__FAXSTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix ConfigDlgProc to view proper printer properties.

    dd/mm/yy -author-
        description

--*/
#include "faxext.h"
#include "faxutil.h"
#include "faxreg.h"
#include "resource.h"
#include "debugex.h"


extern HINSTANCE g_hModule;    // DLL handle
extern HINSTANCE g_hResource;  // Resource DLL handle


VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPTSTR      pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           tszDirName[MAX_PATH] = {0};
    TCHAR           CpName[MAX_PATH] = {0};
    HANDLE          hFindFile = INVALID_HANDLE_VALUE;
    TCHAR           tszFileName[MAX_PATH] = {0};
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;
    LPTSTR          pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    BOOL            bGotFile = FALSE;

    DBG_ENTER(TEXT("AddCoverPagesToList"));

    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) 
    {
        return;
    }

    if ((dirLen = _tcslen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        return;
    }

    _tcscpy( tszDirName, pDirPath );

    TCHAR* pLast = NULL;
    pLast = _tcsrchr(tszDirName,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(tszDirName, TEXT("\\"));
        dirLen += sizeof(TCHAR);
    }

    _tcsncpy(tszPathName, tszDirName, ARR_SIZE(tszPathName)-1);
    pPathEnd = _tcschr(tszPathName, '\0');

    TCHAR file_to_find[MAX_PATH] = {0};
        
    _tcscpy(file_to_find,tszDirName);

    _tcscat(file_to_find, FAX_COVER_PAGE_MASK );
    //
    // Call FindFirstFile/FindNextFile to enumerate the files
    // matching our specification
    //

    hFindFile = FindFirstFile( file_to_find, &findData );
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("FindFirstFile"), ::GetLastError());
        bGotFile = FALSE;
    }
    else
    {
        bGotFile = TRUE;
    }

    while (bGotFile) 
    {
        _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
        if(!IsValidCoverPage(tszPathName))
        {
            goto next;
        }                

        //
        // Exclude directories and hidden files
        //
        if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY)) 
        {
            continue;
        }

        //
        // Make sure we have enough room to store the full pathname
        //
        if ((fileLen = _tcslen( findData.cFileName)) <= MAX_FILENAME_EXT ) 
        {
            continue;
        }

        if (fileLen + dirLen >= MAX_PATH) 
        {
            continue;
        }

        //
        // Add the cover page name to the list window, 
        // but don't display the filename extension
        //
        _tcscpy( CpName, findData.cFileName );
        
        if (pExtension = _tcsrchr(CpName,TEXT('.'))) 
        {
            *pExtension = NULL;
        }

        if ( ! ServerCoverPage )
        {
            TCHAR szPersonal[30];
            LoadString( g_hResource, IDS_PERSONAL, szPersonal, 30 );
            _tcscat( CpName, TEXT(" "));
            _tcscat( CpName, szPersonal );
        }

        listIndex = (INT)SendMessage(
                    hwndList,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) CpName);

        if (listIndex != LB_ERR) 
        {
            SendMessage(hwndList, 
                        LB_SETITEMDATA, 
                        listIndex, 
                        ServerCoverPage ? SERVER_COVER_PAGE : 0);
        }

next:     
        bGotFile = FindNextFile(hFindFile, &findData);
        if (! bGotFile)
        {
            VERBOSE(DBG_MSG, TEXT("FindNextFile"), ::GetLastError());
            break;
        }            
    }
    
    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }
}


void EnableCoverPageList(HWND hDlg)
{
    DBG_ENTER(TEXT("EnableCoverPageList"));

    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
        EnableWindow( GetDlgItem( hDlg, IDC_STATIC_COVERPAGE ), TRUE  );
    } 
    else 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_STATIC_COVERPAGE ), FALSE );
    }
}


INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )


/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static PFAXXP_CONFIG FaxConfig = NULL;
    static HWND hwndListPrn = NULL;
    static HWND hwndListCov = NULL;

    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD   CountPrinters = 0;
    DWORD   dwSelectedItem = 0;
    DWORD   dwNewSelectedItem = 0;
    TCHAR   Buffer [256] = {0};
    TCHAR   CpDir[MAX_PATH] = {0};
    LPTSTR  p = NULL;
    HANDLE  hFax = NULL;
    DWORD   dwError = 0;
    DWORD   dwMask = 0;
    BOOL    bShortCutCp = FALSE;
    BOOL    bGotFaxPrinter = FALSE;
    BOOL    bIsCpLink = FALSE;

    DBG_ENTER(TEXT("ConfigDlgProc"));

    switch( message ) 
    {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );

            //
            // populate the printers combobox
            //
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                           2,
                                                           &CountPrinters,
                                                           PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);
            if (NULL != PrinterInfo)
            {
                DWORD j = 0;
                for (DWORD i=0; i < CountPrinters; i++)
                {
                    if ((NULL != PrinterInfo[i].pDriverName) && 
			            (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)) 
                    {
                        //
                        //if the current printer is a fax printer, add it to the CB list
                        //
                        bGotFaxPrinter = TRUE;
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );

                        if ((NULL != FaxConfig->PrinterName)      && 
			                (NULL != PrinterInfo[i].pPrinterName) &&
			                (_tcscmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0))
                        {
                            //
                            //if it is also the default printer according to transport config.
                            //place the default selection on it
                            //
                            dwSelectedItem = j;
                        }

                        if(FaxConfig->PrinterName == NULL || _tcslen(FaxConfig->PrinterName) == 0)
                        {
                            //
                            // There is no default fax printer
                            // Choose the first one
                            //
                            MemFree(FaxConfig->PrinterName);
                            FaxConfig->PrinterName = StringDup(PrinterInfo[i].pPrinterName);
                            if(FaxConfig->PrinterName == NULL)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }

                            if(PrinterInfo[i].pServerName)
                            {
                                MemFree(FaxConfig->ServerName);
                                FaxConfig->ServerName = StringDup(PrinterInfo[i].pServerName);
                                if(FaxConfig->ServerName == NULL)
                                {
                                    CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                    ErrorMsgBox(g_hResource, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                    EndDialog( hDlg, IDABORT);
                                    return FALSE;
                                }
                            }

                            dwSelectedItem = j;
                        }

                        j += 1;
                    } // if fax printer
                } // for

                MemFree( PrinterInfo );
                PrinterInfo = NULL;
                SendMessage( hwndListPrn, CB_SETCURSEL, (WPARAM)dwSelectedItem, 0 );
            }
            if (! bGotFaxPrinter)
            {
                //
                //  there were no printers at all, or non of the printers is a fax printer.
                //
                CALL_FAIL(GENERAL_ERR, TEXT("MyEnumPrinters"), ::GetLastError());
                ErrorMsgBox(g_hResource, hDlg, IDS_NO_FAX_PRINTER);

                EndDialog( hDlg, IDABORT);
                break;
            }


            //            
            // Get the Server CP flag and receipts options
            //
            FaxConfig->ServerCpOnly = FALSE;
            if (FaxConnectFaxServer(FaxConfig->ServerName, &hFax) )
            {
                DWORD dwReceiptOptions;
                BOOL  bEnableReceiptsCheckboxes = FALSE;

                if(!FaxGetPersonalCoverPagesOption(hFax, &FaxConfig->ServerCpOnly))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), ::GetLastError());
                    ErrorMsgBox(g_hResource, hDlg, IDS_CANT_ACCESS_SERVER);
                }
                else
                {
                    //
                    // Inverse logic
                    //
                    FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                }
                if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                }
                else
                {
                    if (DRT_EMAIL & dwReceiptOptions)
                    {
                        //
                        // Server supports receipts by email - enable the checkboxes
                        //
                        bEnableReceiptsCheckboxes = TRUE;
                    }
                }
                EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                FaxClose(hFax);
                hFax = NULL;
            }
            else
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError())
                ErrorMsgBox(g_hResource, hDlg, IDS_CANT_ACCESS_SERVER);
            }

            //
            //send single receipt for a fax sent to multiple recipients?
            //
            if(FaxConfig->SendSingleReceipt)
            {
                CheckDlgButton( hDlg, IDC_SEND_SINGLE_RECEIPT, BST_CHECKED );
            }

            if (FaxConfig->bAttachFax)
            {
                CheckDlgButton( hDlg, IDC_ATTACH_FAX, BST_CHECKED );
            }

            //
            // cover page CB & LB enabling
            //
            if (FaxConfig->UseCoverPage)
            {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            }
            EnableCoverPageList(hDlg);

            //
            // Emulate printer's selection change, in order to collect printer config info.
            // including cover pages LB population
            //
            ConfigDlgProc(hDlg, WM_COMMAND,MAKEWPARAM(IDC_PRINTER_LIST,CBN_SELCHANGE),(LPARAM)0);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE)
                {
                    EnableCoverPageList(hDlg);
                    return FALSE;
                }
            }

            if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST)
            {
                //
                // refresh cover pages list
                //
                TCHAR SelectedPrinter[MAX_PATH];
				DWORD dwPrinterNameLength = 0;
                //
                //  a new fax printer was selected - delete all old coverpages from the list
                //  because they might include the old fax server's cover pages
                //
                SendMessage(hwndListCov, LB_RESETCONTENT, 0, 0);

                if (CB_ERR != (dwSelectedItem =(DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0)))
                //
                // get the 0 based index of the currently pointed printer
                //
                {
					if (CB_ERR != (dwPrinterNameLength = (DWORD)SendMessage( hwndListPrn, CB_GETLBTEXTLEN, dwSelectedItem, 0)))
					{
						if (dwPrinterNameLength < MAX_PATH)
						{
							if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) SelectedPrinter ))
							//
							// get that printer's name into SelectedPrinter
							//
							{
								if(NULL != (PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( SelectedPrinter, 2 )))
								{
									LPTSTR lptszServerName = NULL;
									if (GetServerNameFromPrinterInfo(PrinterInfo,&lptszServerName))
									{
										if (GetServerCpDir( lptszServerName, CpDir, sizeof(CpDir)/sizeof(CpDir[0]) ))
										{
											AddCoverPagesToList( hwndListCov, CpDir, TRUE );
										}
										if ((NULL == FaxConfig->ServerName) || (NULL == lptszServerName) ||
											(_tcscmp(FaxConfig->ServerName,lptszServerName) != 0) )
										{
											//
											// the server's name and config are not updated - refresh them
											//
											MemFree(FaxConfig->ServerName);
											FaxConfig->ServerName = lptszServerName;

											FaxConfig->ServerCpOnly = FALSE;
											if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) )
											{
												DWORD dwReceiptOptions;
												BOOL  bEnableReceiptsCheckboxes = FALSE;
												//
												// Get the new server's ServerCpOnly flag
												//
												if (!FaxGetPersonalCoverPagesOption(hFax,&FaxConfig->ServerCpOnly))
												{
													CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
												}
												else
												{
													//
													// Inverse logic
													//
													FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
												}
												if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
												{
													CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
												}
												else
												{
													if (DRT_EMAIL & dwReceiptOptions)
													{
														//
														// Server supports receipts by email - enable the checkboxes
														//
														bEnableReceiptsCheckboxes = TRUE;
													}
												}
												EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
												EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

												FaxClose(hFax);
												hFax = NULL;
											}
										}
										else
										//
										// the server's name hasn't changed, all details are OK
										//
										{
											MemFree(lptszServerName);
											lptszServerName = NULL;
										}
									}
									else
									//
									// GetServerNameFromPrinterInfo failed
									//
									{
										FaxConfig->ServerCpOnly = FALSE;
									}

									//
									// don't add client coverpages if FaxConfig->ServerCpOnly is set to true
									//
									if (!FaxConfig->ServerCpOnly)
									{
										if(GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0])))
										{
										//
										// if the function failes- the ext. is installed on a machine 
										// that doesn't have a client on it, 
										// so we shouldn't look for personal cp
										//                                
											AddCoverPagesToList( hwndListCov, CpDir, FALSE );
										}
									}
									MemFree(PrinterInfo);
									PrinterInfo = NULL;

									//
									// check if we have any cp in the LB, if not-  don't allow the user to 
									// ask for a cp with he's fax
									//
									DWORD dwItemCount = (DWORD)SendMessage(hwndListCov, LB_GETCOUNT, NULL, NULL);
									if(LB_ERR == dwItemCount)
									{
										CALL_FAIL(GENERAL_ERR, TEXT("SendMessage (LB_GETCOUNT)"), ::GetLastError());
									}
									else
									{
										EnableWindow( GetDlgItem( hDlg, IDC_USE_COVERPAGE ), dwItemCount ? TRUE : FALSE );
									}

									if (FaxConfig->CoverPageName)
									{
										_tcscpy( Buffer, FaxConfig->CoverPageName );
									}
									if ( ! FaxConfig->ServerCoverPage )
									{
										TCHAR szPersonal[30] = _T("");
										LoadString( g_hResource, IDS_PERSONAL, szPersonal, 30 );
										_tcscat( Buffer, _T(" ") );
										_tcscat( Buffer, szPersonal );
									}

									dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, -1, (LPARAM) Buffer );
									//
									// get the index of the default CP
									//
									if (dwSelectedItem == LB_ERR) 
									{
										dwSelectedItem = 0;
									}

									SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) dwSelectedItem, 0 );
									//
									// place the default selection on that CP
									//
								}
							}
                        }
                    }
                }
                break;
            }

            switch (wParam) 
            {
                case IDOK :

                    //
                    // Update UseCoverPage
                    //
                    FaxConfig->UseCoverPage = (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED);

                    //
                    //  Update SendSingleReceipt
                    //
                    FaxConfig->SendSingleReceipt = (IsDlgButtonChecked(hDlg, IDC_SEND_SINGLE_RECEIPT) == BST_CHECKED);

                    FaxConfig->bAttachFax = (IsDlgButtonChecked(hDlg, IDC_ATTACH_FAX) == BST_CHECKED);

                    //
                    // Update selected printer
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR)
                    {
                        if (LB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) Buffer ))/***/
                        {
                            MemFree( FaxConfig->PrinterName );
                            FaxConfig->PrinterName = StringDup( Buffer );
                            if(!FaxConfig->PrinterName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }
                        }
                    }
                    
                    //
                    // Update cover page
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR)// LB_ERR when no items in list
                    {
                        if (LB_ERR != SendMessage( hwndListCov, LB_GETTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        //
                        // get the selected CP name into the buffer
                        //
                        {
                            dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                            if (dwMask != LB_ERR)
                            {
                                FaxConfig->ServerCoverPage = (dwMask & SERVER_COVER_PAGE) == SERVER_COVER_PAGE;
                                if (!FaxConfig->ServerCoverPage)
                                {
                                    //
                                    // if the selected CP in the LB is not a server's CP
                                    // Omit the suffix: "(personal)"
                                    //
                                    p = _tcsrchr( Buffer, '(' );
                                    Assert(p);
                                    if( p )
                                    {
                                        p = _tcsdec(Buffer,p);
                                        if( p )
                                        {
                                            _tcsnset(p,TEXT('\0'),1);
                                        }
                                    }
								}
                            }
                            //
                            // update CP name to the selected one in the LB
                            //
                            MemFree( FaxConfig->CoverPageName );
                            FaxConfig->CoverPageName = StringDup( Buffer );
                            if(!FaxConfig->CoverPageName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }
                        }            
                    }
                    EndDialog( hDlg, IDOK );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;
                }
                break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Outlook Extension resource ID file               //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [11000 - 11499]                                  //
//                                                  //
//////////////////////////////////////////////////////

#include "..\..\admin\faxres\resource.h"

#define IDC_STATIC_COVERPAGE_GRP       11004 
#define IDC_STATIC_COVERPAGE           11005 
#define IDC_STATIC_PRINTER_LIST        11006 
#define FAX_CONFIG_DIALOG              11009 
#define IDB_EXTBTN                     11010 
#define IDI_FAX                        11011 
#define IDS_MSGBOXCAPTION              11012 
#define IDS_FAX_ATTRIBUTES_MENU        11013 
#define IDS_FAX_ATTRIBUTES_TOOLTIP     11014 
#define IDS_FAX_ATTRIBUTES_CUST        11015 
#define IDS_FAX_EXT_MESSAGE            11018 
#define IDS_NOT_ENOUGH_MEMORY          11020 

//////////////////////////////////////////////////////
//                                                  //
// Outlook Extension resource ID file               //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [11000 - 11499]                                  //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXEXT32)
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\faxext32.def
UMTYPE=windows


DLLENTRY=_DllMainCRTStartup
USE_CRTDLL=1

INCLUDES=                       \
  $(INCLUDES);                  \
  $(FAXROOT)\exchange\inc;      \
  $(FAXROOT)\inc;             

!ifndef NOUNICODE
TARGETLIBS = $(FAXROOT)\util\debugex\unicode\$(O)\debugex.lib \
             $(FAXLIB)\*\$(WINFAX).lib
!else
TARGETLIBS = $(FAXROOT)\util\debugex\ansii\$(O)\debugex.lib \
             $(FAXLIB95)\*\$(WINFAX).lib 
!endif
  
TARGETLIBS = $(TARGETLIBS)                    \
  $(SDK_LIB_PATH)\kernel32.lib    \
  $(SDK_LIB_PATH)\advapi32.lib    \
  $(SDK_LIB_PATH)\uuid.lib        \
  $(SDK_LIB_PATH)\gdi32.lib       \
  $(SDK_LIB_PATH)\user32.lib      \
  $(SDK_LIB_PATH)\ole32.lib       \
  $(SDK_LIB_PATH)\mapi32.lib      \
  $(SDK_LIB_PATH)\winspool.lib    \
  $(SDK_LIB_PATH)\shell32.lib     \
  $(SDK_LIB_PATH)\comdlg32.lib

SOURCES=\
  ..\config.cpp  \
  ..\faxext.cpp  \
  ..\util.cpp    \
  ..\version.rc   
  
#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
SXS_ASSEMBLY_NAME=Microsoft.Windows.Fax.FxsExt32
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=faxext.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\faxext.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Handle errors, and get appropriate server name in GetFaxConfig.

    dd/mm/yy -author-
        description
--*/

#define INITGUID
#define USES_IID_IExchExt
#define USES_IID_IExchExtAdvancedCriteria
#define USES_IID_IExchExtAttachedFileEvents
#define USES_IID_IExchExtCommands
#define USES_IID_IExchExtMessageEvents
#define USES_IID_IExchExtPropertySheets
#define USES_IID_IExchExtSessionEvents
#define USES_IID_IExchExtUserEvents
#define USES_IID_IMAPIFolder
#define USES_IID_IProfAdmin
#define USES_IID_IProfSect
#define USES_IID_IMAPISession
#define USES_PS_PUBLIC_STRINGS
#define USES_IID_IDistList

#include "faxext.h"
#include <initguid.h>
#include "debugex.h"
#include <mbstring.h>
#include <faxres.h>

HINSTANCE g_hModule = NULL;    // DLL handle
HINSTANCE g_hResource = NULL;  // Resource DLL handle


BOOL WINAPI
DllMain(
    HINSTANCE  hinstDLL,
    DWORD  fdwReason,
    LPVOID  lpvReserved
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
		DisableThreadLibraryCalls(hinstDLL);
        g_hModule = hinstDLL;
        g_hResource = GetResInstance(hinstDLL);
        if(!g_hResource)
        {
            return FALSE;
        }

        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, MapiMemReAlloc);
    }    
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        FreeResInstance();
    }
    return TRUE;
}



BOOL
VerifyDistributionList(
    LPEXCHEXTCALLBACK pmecb,
    DWORD EntryIdSize,
    LPENTRYID EntryId
    )
{
    HRESULT hr = S_OK;
    LPMAPISESSION Session = NULL;
    LPDISTLIST DistList = NULL;
    DWORD ObjType = 0;
    LPMAPITABLE DistTable = NULL;
    LPSRowSet DistRows = NULL;
    LPSPropValue Dist = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;


    hr = pmecb->GetSession( &Session, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = Session->OpenEntry(
        EntryIdSize,
        EntryId,
        &IID_IDistList,
        MAPI_DEFERRED_ERRORS,
        &ObjType,
        (LPUNKNOWN *) &DistList
        );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = DistList->GetContentsTable(
        MAPI_DEFERRED_ERRORS,
        &DistTable
        );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = HrQueryAllRows( DistTable, NULL, NULL, NULL, 0, &DistRows );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    for (i=0; i<DistRows->cRows; i++) 
    {
        Dist = DistRows->aRow[i].lpProps;
        for (j=0; j<DistRows->aRow[i].cValues; j++) 
        {
            if (Dist[j].ulPropTag == PR_ADDRTYPE_A) 
            {
                if (!strcmp( Dist[j].Value.lpszA, "FAX" )) 
                {
                    FaxAddress = TRUE;
                }
            }
            else if (Dist[j].ulPropTag == PR_ADDRTYPE_W) 
            {
                if (!wcscmp( Dist[j].Value.lpszW, L"FAX" )) 
                {
                    FaxAddress = TRUE;
                }
            }
        }
    }

exit:
    if (Session) {
        Session->Release();
    }
    if (DistList) {
        DistList->Release();
    }
    if (DistTable) {
        MemFree( DistTable );
    }
    if (DistRows) {
        FreeProws( DistRows );
    }

    return FaxAddress;
}




BOOL 
VerifyFaxRecipients(
    LPEXCHEXTCALLBACK pmecb
    )
/*++

Routine name : VerifyFaxRecipients

Routine description:

	Gets the recipients list of the currently open item, and checks wheather there 
    are any fax recipients in it. for a DL recipient - calls VerifyDistributionList 
    to check if there are any fax recipients in the DL. 

Author:

	Keren Ellran (t-KerenE),	Mar, 2000

Arguments:

    pmecb     -- [IN] pointer to Exchange Extension callback function

Return Value:

    BOOL: TRUE if there's one or more fax recipients, FALSE if none

--*/
{
    HRESULT hr = S_OK;
    LPADRLIST AdrList = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;
    BOOL IsDistList = FALSE;
    LPENTRYID EntryId = NULL;
    DWORD EntryIdSize;

	hr = pmecb->GetRecipients( &AdrList );
    if (FAILED(hr)) 
    {
       goto exit;
    }

    if (AdrList) 
    {
        for (i=0; i<AdrList->cEntries; i++) 
        {
            EntryId = NULL;
            IsDistList = FALSE;
            for (j=0; j<AdrList->aEntries[i].cValues; j++)
            {
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ENTRYID) 
                {
                    EntryId = (LPENTRYID) AdrList->aEntries[i].rgPropVals[j].Value.bin.lpb;
                    EntryIdSize = AdrList->aEntries[i].rgPropVals[j].Value.bin.cb;
                } 
                else if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE_A) 
                {
                    if (!strcmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszA, "FAX"))
                    {
                        FaxAddress = TRUE;
                        goto exit;
                    } 
                    else if ((!strcmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszA, "MAPIPDL" )))
                    {
                        IsDistList = TRUE;
                    }
                }
                else if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE_W) 
                {
                    //
                    // Outlook Beta 2 (10.2202.2202) does not supply PR_ADDRTYPE_A property
                    // so we are looking for a PR_ADDRTYPE_W
                    //
                    if (!wcscmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszW, L"FAX" ))
                    {
                        FaxAddress = TRUE;
                        goto exit;
                    } 
                    else if ((!wcscmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszW, L"MAPIPDL")))
                    {
                        IsDistList = TRUE;
                    }
                }
            }
            //
            // after we finished going over all address's properties, if it is a DL, 
            // and if EntryId was detected, we can check if the DL includes a fax address.
            //
            if ((IsDistList)&&(EntryId))
            {
                FaxAddress = VerifyDistributionList( pmecb, EntryIdSize, EntryId );
                if (FaxAddress == TRUE)
                    goto exit;
            }
        }
    }
exit:   
    if(AdrList)
    {
        FreePadrlist(AdrList);
    }
    return FaxAddress;
}



HRESULT
EnableMenuAndToolbar(
    LPEXCHEXTCALLBACK pmecb,
    HWND hwndToolbar,
    DWORD CmdId
    )
{
    HRESULT hr = S_OK;
    LPADRLIST AdrList = NULL;
    BOOL FaxAddress = FALSE;
    HMENU hMenu;
    LPENTRYID EntryId = NULL;

    DBG_ENTER(TEXT("EnableMenuAndToolbar"));

    FaxAddress = VerifyFaxRecipients(pmecb);
    hr = pmecb->GetMenu( &hMenu );

    if (S_OK != hr)
    {
        goto exit;
    }

    if (FaxAddress) 
    {
        VERBOSE(DBG_MSG, TEXT("Enabling menu") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_ENABLED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(TRUE,0) );
    } 
    else 
    {
        VERBOSE(DBG_MSG, TEXT("Disabling menu") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_GRAYED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(FALSE,0) );
    }

exit:
    return hr;
}


HRESULT
GetFaxConfig(
    LPEXCHEXTCALLBACK pmecb,
    PFAXXP_CONFIG FaxConfig
    )
{
    HRESULT hr = S_FALSE;
    LPMAPISESSION lpSession = NULL;
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    LPSPropValue pProps = NULL;
    LPSERVICEADMIN lpServiceAdmin = NULL;
    LPPROVIDERADMIN lpProviderAdmin = NULL;
    LPMAPITABLE ptblSvc = NULL;
    LPSRowSet pSvcRows = NULL;
    LPSPropValue pSvc = NULL;
    DWORD i,j;
    BOOL FoundIt = FALSE;
    LPBYTE FaxXpGuid = NULL;
    MAPIUID FaxGuid = FAX_XP_GUID;


    hr = pmecb->GetSession( &lpSession, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpSession->AdminServices( 0, &lpServiceAdmin );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpServiceAdmin->GetMsgServiceTable( 0, &ptblSvc );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = HrQueryAllRows( ptblSvc, NULL, NULL, NULL, 0, &pSvcRows );
    if (FAILED(hr)) {
        goto exit;
    }

    for (i=0; i<pSvcRows->cRows; i++) 
    {
        pSvc = pSvcRows->aRow[i].lpProps;
        for (j=0; j<pSvcRows->aRow[i].cValues; j++) 
        {
            if (pSvc[j].ulPropTag == PR_SERVICE_NAME_A) 
            {
				// look for the name of the service as registered on XP and .NET
                if (_stricmp( pSvc[j].Value.lpszA, FAX_MESSAGE_SERVICE_NAME) == 0) 
                {
                    FoundIt = TRUE;
                }
				// look for the name of the service as registered on down level clients
                if (_stricmp( pSvc[j].Value.lpszA, FAX_MESSAGE_SERVICE_NAME_SBS50) == 0) 
                {
                    FoundIt = TRUE;
                }
            }

            if (pSvc[j].ulPropTag == PR_SERVICE_UID) 
            {
                FaxXpGuid = pSvc[j].Value.bin.lpb;
            }
        }
        if (FoundIt) 
        {
            break;
        }
    }

    if (!FoundIt) 
    {
        goto exit;
    }

    hr = lpServiceAdmin->AdminProviders( (LPMAPIUID) FaxXpGuid, 0, &lpProviderAdmin );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = lpProviderAdmin->OpenProfileSection(
                                            &FaxGuid,
                                            NULL,
                                            0,
                                            &pProfileObj);
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = pProfileObj->GetProps(
                                (LPSPropTagArray) &sptFaxProps,
		                        0,
                                &PropCount,
                                &pProps); 
    if (S_OK != hr) 
    {
        goto exit;
    }

    if(pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb)
    {
        FaxConfig->PrinterName = StringDup((LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb );
        if (!FaxConfig->PrinterName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    if(pProps[PROP_COVERPAGE_NAME].Value.bin.lpb)
    {
        FaxConfig->CoverPageName = StringDup( (LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb );
        if (!FaxConfig->CoverPageName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    FaxConfig->UseCoverPage = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig->SendSingleReceipt = pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul;
    FaxConfig->bAttachFax = pProps[PROP_ATTACH_FAX].Value.ul;
    FaxConfig->ServerCoverPage = pProps[PROP_SERVER_COVERPAGE].Value.ul;

    if(pProps[PROP_FONT].Value.bin.lpb && sizeof(LOGFONT) == pProps[PROP_FONT].Value.bin.cb)
    {
        if (!memcpy( &FaxConfig->FontStruct, pProps[PROP_FONT].Value.bin.lpb, pProps[PROP_FONT].Value.bin.cb ))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    if (!GetServerNameFromPrinterName(FaxConfig->PrinterName,&FaxConfig->ServerName))
    {
        hr = S_FALSE;
        goto exit;
    }
    hr = S_OK;
exit:

    if (pSvcRows) {
        FreeProws( pSvcRows );
    }
    if (pProps) {
        MAPIFreeBuffer( pProps );
    }
    if (pProfileObj) {
        pProfileObj->Release();
    }
    if (ptblSvc) {
        ptblSvc->Release();
    }
    if (lpProviderAdmin) {
        lpProviderAdmin->Release();
    }
    if (lpServiceAdmin) {
        lpServiceAdmin->Release();
    }
    if (lpSession) {
        lpSession->Release();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    FUNCTION: ExchEntryPoint
//
//    Parameters - none
//
//    Purpose
//    The entry point which Exchange calls.
//
//    Return Value
//    Pointer to Exchange Extension Object
//
//    Comments
//    This is called for each context entry.  Create a new MyExchExt object
//    every time so each context will get its own MyExchExt interface.
//
LPEXCHEXT CALLBACK ExchEntryPoint(void)
{
    MyExchExt* pExt = new MyExchExt;

    if (pExt && !pExt->IsValid())
    {
        //
        // Creation failed
        //
        delete pExt;
        pExt = NULL;
    }

    return pExt;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::MyExchExt()
//
//    Parameters - none
//
//    Purpose
//    Constructor. Initialize members and create supporting interface objects
//
//    Comments
//    Each context of Exchange gets its own set of interface objects.
//    Furthermore, interface objects per context are kept track of by Exchange
//    and the interface methods are called in the proper context.
//
MyExchExt::MyExchExt (): m_cRef(1), m_context(0), m_pExchExtCommands(NULL), m_pExchExtUserEvents(NULL)
{

    m_pExchExtCommands = new MyExchExtCommands;
    m_pExchExtUserEvents = new MyExchExtUserEvents;

    if(!m_pExchExtCommands || !m_pExchExtUserEvents)
    {
        delete m_pExchExtCommands;
        m_pExchExtCommands = NULL;

        delete m_pExchExtUserEvents;
        m_pExchExtUserEvents = NULL;
    }

    // in MyExchExtUserEvents methods I need a reference to MyExchExt
    if (m_pExchExtUserEvents)
    {
        m_pExchExtUserEvents->SetIExchExt( this );
    }
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExt virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Called by Exchage to request for interfaces
//
//    Return Value
//    S_OK  -- interface is supported and returned in ppvObj pointer
//    E_NOINTERFACE -- interface is not supported and ppvObj is NULL
//
//    Comments
//    Exchange client calls QueryInterface for each object.  Only
//    Need to support objects that apply to the extension.  QueryInterface
//    is called onces for each IID for each context.  We support two
//    contexts in this example so QueryInterface is called twice for
//    each IID.
//
STDMETHODIMP
MyExchExt::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ( (IID_IUnknown == riid) || (IID_IExchExt == riid) ) 
    {
        *ppvObj = (LPUNKNOWN) this;
    } 
    else if ( IID_IExchExtCommands == riid) 
    {
        if (!m_pExchExtCommands) 
        {
            hr = E_UNEXPECTED;
        } 
        else 
        {
            *ppvObj = (LPUNKNOWN)m_pExchExtCommands;
            m_pExchExtCommands->SetContext( m_context );
        }
    } 
    else if ( IID_IExchExtUserEvents == riid) 
    {
        *ppvObj = (LPUNKNOWN)m_pExchExtUserEvents;
        m_pExchExtUserEvents->SetContext( m_context );
    } 
    else 
    {
        hr = E_NOINTERFACE;
    }
    if (NULL != *ppvObj) 
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::Install()
//
//    Parameters
//    pmecb     -- pointer to Exchange Extension callback function
//    mecontext -- context code at time of being called.
//    ulFlags   -- flag to say if install is for modal or not
//
//    Purpose
//    Called once for each new contexted that is entered.  Proper version
//    number is checked here.
//
//    Return Value
//    S_OK -- object supported in the requested context
//    S_FALSE -- object is not supported in teh requested context
//
//    Comments
//
STDMETHODIMP
MyExchExt::Install(
    LPEXCHEXTCALLBACK pmecb,
    ULONG mecontext,
    ULONG ulFlags
    )
{
    ULONG ulBuildVersion;
    HRESULT hr;

    m_context = mecontext;

    // make sure this is the right version
    pmecb->GetVersion( &ulBuildVersion, EECBGV_GETBUILDVERSION );

    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion & EECBGV_BUILDVERSION_MAJOR_MASK)) {
        return S_FALSE;
    }

    switch (mecontext) {
        case EECONTEXT_SENDNOTEMESSAGE:
            hr = S_OK;
            break;

        default:
            hr = S_FALSE;
            break;
    }

    return hr;
}



MyExchExtCommands::MyExchExtCommands()
{
    m_cRef = 0;
    m_context = 0;
    m_cmdid = 0;
    m_itbb = 0;
    m_itbm = 0;
    m_hWnd = 0;
    m_hwndToolbar = NULL;
	memset(&m_FaxConfig, 0, sizeof(m_FaxConfig));
}


MyExchExtCommands::~MyExchExtCommands()
{
    MemFree( m_FaxConfig.PrinterName );
    MemFree( m_FaxConfig.CoverPageName );
}

STDMETHODIMP_(ULONG) MyExchExtCommands::AddRef() 
{ 
	++m_cRef; 
	return m_cRef; 
}

 STDMETHODIMP_(ULONG) MyExchExtCommands::Release()
{
	ULONG ulCount = --m_cRef;
	if (!ulCount) 
	{ 
        delete this; 
	}
	return ulCount;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtCommands::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtCommands::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if ( (riid == IID_IExchExtCommands) || (riid == IID_IUnknown) ) 
    {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InstallCommands()
//
//    Parameters
//    pmecb  -- Exchange Callback Interface
//    hWnd   -- window handle to main window of context
//    hMenu  -- menu handle to main menu of context
//    lptbeArray -- array of toolbar button entries
//    ctbe   -- count of button entries in array
//    ulFlags -- reserved
//
//    Purpose
//    This function is called when commands are installed for each context
//    the extension services.
//
//    Return Value
//    S_FALSE means the commands have been handled.
//
//    Comments
//    The hWnd and hMenu are in context.  If the context is for the SENDNOTE
//    dialog, then the hWnd is the window handle to the dialog and the hMenu is
//    the main menu of the dialog.
//
//    Call ResetToolbar so that Exchange will show it's toolbar
//


STDMETHODIMP
MyExchExtCommands::InstallCommands(
    LPEXCHEXTCALLBACK pmecb,
    HWND  hWnd,
    HMENU hMenu,
    UINT FAR * pcmdidBase,
    LPTBENTRY  lptbeArray,
    UINT  ctbe,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR   MenuItem[64];
    BOOL    bResult = 0;

    DBG_ENTER(TEXT("MyExchExtCommands::InstallCommands"));

    if (m_context == EECONTEXT_SENDNOTEMESSAGE) 
    {
        int tbindx;
        HMENU hCustomMenu;
        
        hr = pmecb->GetMenuPos( EECMDID_ToolsCustomizeToolbar, &hCustomMenu, NULL, NULL, 0);
        if(FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, TEXT("pmecb->GetMenuPos"), 0);
            hr = S_FALSE;
            goto exit;        
        }
        
        bResult = AppendMenu( hCustomMenu, MF_SEPARATOR, 0, NULL );
        if (!bResult)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("AppendMenu"), ::GetLastError);
            hr = S_FALSE;
            goto exit;
        }
        
        LoadString( g_hResource, IDS_FAX_ATTRIBUTES_MENU, MenuItem, sizeof(MenuItem)/sizeof(*MenuItem));
        bResult = AppendMenu( hCustomMenu, MF_BYPOSITION | MF_STRING, *pcmdidBase, MenuItem );
        if (!bResult)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("AppendMenu"), ::GetLastError);
            hr = S_FALSE;
            goto exit;
        }
        
        m_hWnd = hWnd;
        m_cmdid = *pcmdidBase;
        (*pcmdidBase)++;
        for (tbindx = ctbe-1; (int) tbindx > -1; --tbindx) 
        {
            if (lptbeArray[tbindx].tbid == EETBID_STANDARD) 
            {
                m_hwndToolbar = lptbeArray[tbindx].hwnd;
                m_itbb = lptbeArray[tbindx].itbbBase;
                lptbeArray[tbindx].itbbBase ++;
                break;
            }
        }
        
        if (m_hwndToolbar) 
        {
            TBADDBITMAP tbab;

            tbab.hInst = g_hResource;
            tbab.nID = IDB_EXTBTN;
            m_itbm = (INT)SendMessage( m_hwndToolbar, TB_ADDBITMAP, 1, (LPARAM)&tbab );
            EnableMenuAndToolbar( pmecb, m_hwndToolbar, m_cmdid );
            ResetToolbar( EETBID_STANDARD, 0 );
        }

        hr = GetFaxConfig( pmecb, &m_FaxConfig );
    }

exit:
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::DoCommand()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose7
//    This method is called by Exchange for each WM_COMMAND is sent to the
//    window in context.
//
//    Return Value
//    S_OK if command is handled
//    S_FALSE if command is not handled
//
//    Comments
//    Use this function to either respond to the command item (menu or toolbar)
//    added or modify an existing command in Exchange.  Return S_OK to let
//    Exchange know the command was handled.  Return S_OK on commands you are
//    taking over from Exchange.  Return S_FALSE to let Exchange know you want
//    it to carry out its command, even if you modify its action.
//

STDMETHODIMP
MyExchExtCommands::DoCommand(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    HRESULT hr = S_OK;
    HWND hwnd = NULL;
    INT_PTR Rslt;
    LPMESSAGE pMessage = NULL;
    LPMDB pMDB = NULL;
    LPSPropProblemArray lpProblems = NULL;
    SPropValue MsgProps[NUM_FAX_MSG_PROPS];
    LPSPropTagArray MsgPropTags = NULL;
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {
                                                &NameIds[0], 
                                                &NameIds[1], 
                                                &NameIds[2], 
                                                &NameIds[3], 
                                                &NameIds[4], 
                                                &NameIds[5]
                                              };
    LPENTRYID EntryId = NULL;

    DBG_ENTER(TEXT("MyExchExtCommands::DoCommand"));

    if (m_cmdid != cmdid) 
    {
        return S_FALSE;
    }

    hr = pmecb->GetWindow( &hwnd );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    Rslt = DialogBoxParam(
        g_hResource,
        MAKEINTRESOURCE(FAX_CONFIG_DIALOG),
        hwnd,
        ConfigDlgProc,
        (LPARAM) &m_FaxConfig
        );
    if (Rslt == IDOK) 
    {

        hr = pmecb->GetObject( &pMDB, (LPMAPIPROP *) &pMessage );
        if (FAILED(hr)) {
            goto exit;
        }

        NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

        NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

        NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

        NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].Kind.lpwstrName = MSGPS_FAX_SEND_SINGLE_RECEIPT;

        NameIds[MSGPI_FAX_ATTACH_FAX].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_ATTACH_FAX].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_ATTACH_FAX].Kind.lpwstrName = MSGPS_FAX_ATTACH_FAX;

        hr = pMessage->GetIDsFromNames( NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
        if (FAILED(hr)) {
            goto exit;
        }

        MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX]) );
        
        MsgProps[MSGPI_FAX_PRINTER_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME];
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME];
        MsgProps[MSGPI_FAX_USE_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE];
        MsgProps[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE];
        MsgProps[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT];
        MsgProps[MSGPI_FAX_ATTACH_FAX].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX];

        MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.cb = (_tcslen(m_FaxConfig.PrinterName) + 1) * sizeof(TCHAR);
        MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE )StringDup(m_FaxConfig.PrinterName);
        if(!MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb)
        {
            MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.cb = 0;

            CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
            ErrorMsgBox(g_hResource, hwnd, IDS_NOT_ENOUGH_MEMORY);
            hr = E_OUTOFMEMORY;
            goto exit;        
        }

        MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.cb =( _tcslen(m_FaxConfig.CoverPageName) + 1) * sizeof(TCHAR);
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb = (LPBYTE)StringDup(m_FaxConfig.CoverPageName);
        if(!MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb)
        {
            MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.cb = 0;

            CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
            ErrorMsgBox(g_hResource, hwnd, IDS_NOT_ENOUGH_MEMORY);
            hr = E_OUTOFMEMORY;
            goto exit;        
        }

		MsgProps[MSGPI_FAX_USE_COVERPAGE].Value.ul = m_FaxConfig.UseCoverPage;
		MsgProps[MSGPI_FAX_SERVER_COVERPAGE].Value.ul = m_FaxConfig.ServerCoverPage;

        MsgProps[MSGPI_FAX_SEND_SINGLE_RECEIPT].Value.ul = m_FaxConfig.SendSingleReceipt;
        MsgProps[MSGPI_FAX_ATTACH_FAX].Value.ul = m_FaxConfig.bAttachFax;
		
        hr = pMessage->SetProps( NUM_FAX_MSG_PROPS, MsgProps, &lpProblems );
        if (FAILED(hr)) {
            goto exit;
        }
        if (lpProblems) {
            hr = MAPI_E_NOT_FOUND;
            goto exit;
        }

    }

exit:

    if (MsgPropTags) 
    {
        MAPIFreeBuffer ( MsgPropTags );
    }

    if (lpProblems) 
    {
        MAPIFreeBuffer ( lpProblems );
    }

    if (pMessage) 
    {
        pMessage->Release();
    }

	if (pMDB)
	{
		pMDB->Release();
	}


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InitMenu()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose
//    This method is called by Exchange when the menu of context is about to
//    be activated.  See WM_INITMENU in the Windows API Reference for more
//    information.
//
//    Return Value - none
//

STDMETHODIMP_(VOID)
MyExchExtCommands::InitMenu(
    LPEXCHEXTCALLBACK pmecb
    )
{
    return;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::Help()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//    cmdid -- command id
//
//    Purpose
//    Respond when user presses F1 while custom menu item is selected.
//
//    Return Value
//    S_OK -- recognized the command and provided help
//    S_FALSE -- not our command and we didn't provide help
//

STDMETHODIMP MyExchExtCommands::Help(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    return S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryHelpText()
//
//    Parameters
//    cmdid -- command id corresponding to menu item activated
//    ulFlags -- identifies either EECQHT_STATUS or EECQHT_TOOLTIP
//    psz -- pointer to buffer to be populated with text to display
//    cch -- count of characters available in psz buffer
//
//    Purpose
//    Exchange calls this function each time it requires to update the status
//    bar text or if it is to display a tooltip on the toolbar.
//
//    Return Value
//    S_OK to indicate our command was handled
//    S_FALSE to tell Exchange it can continue with its function
//

STDMETHODIMP
MyExchExtCommands::QueryHelpText(
    UINT cmdid,
    ULONG ulFlags,
    LPTSTR psz,
    UINT cch
    )
{
    HRESULT hr;
    TCHAR HelpText[64];

    LoadString(g_hResource,IDS_FAX_ATTRIBUTES_TOOLTIP,HelpText,sizeof(HelpText)/sizeof(*HelpText));

    if (cmdid == m_cmdid) 
    {
        if (ulFlags == EECQHT_STATUS) 
        {
			_tcsncpy(psz,HelpText,cch/sizeof(TCHAR));
        }

        if (ulFlags == EECQHT_TOOLTIP) 
        {
			_tcsncpy(psz,HelpText,cch/sizeof(TCHAR));
        }

        hr = S_OK;
    } 
    else 
    {
        hr = S_FALSE;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryButtonInfo()
//
//    Parameters
//    tbid    -- toolbar identifier
//    itbb    -- toolbar button index
//    ptbb    -- pointer to toolbar button structure -- see TBBUTTON structure
//    lpsz    -- point to string describing button
//    cch     -- maximum size of lpsz buffer
//    ulFlags -- EXCHEXT_UNICODE may be specified
//
//    Purpose
//    For Exchange to find out about toolbar button information.
//
//    Return Value
//    S_FALSE - not our button
//    S_OK    - we filled information about our button
//
//    Comments
//    Called for every button installed for toolbars when IExchExtCommands
//    is installed for each context. The lpsz text is used when the Customize
//    Toolbar dialog is displayed.  The text will be displayed next to the
//    button.
//

STDMETHODIMP MyExchExtCommands::QueryButtonInfo(
    ULONG tbid,
    UINT itbb,
    LPTBBUTTON ptbb,
    LPTSTR lpsz,
    UINT cch,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR CustText[64];

    LoadString(g_hResource,IDS_FAX_ATTRIBUTES_CUST,CustText,sizeof(CustText)/sizeof(TCHAR));

    if (m_itbb == itbb) {
        ptbb->iBitmap = m_itbm;
        ptbb->idCommand = m_cmdid;
        ptbb->fsState = TBSTATE_ENABLED;
        ptbb->fsStyle = TBSTYLE_BUTTON;
        ptbb->dwData = 0;
        ptbb->iString = -1;
		_tcsncpy(lpsz,CustText,cch/sizeof(TCHAR));
        hr = S_OK;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::ResetToolbar()
//
//    Parameters
//    tbid
//    ulFlags
//
//    Purpose
//
//    Return Value  S_OK always
//
STDMETHODIMP
MyExchExtCommands::ResetToolbar(
    ULONG tbid,
    ULONG ulFlags
    )
{
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExtUserEvents virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtUserEvents::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtUserEvents::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if (( riid == IID_IExchExtUserEvents) || (riid == IID_IUnknown) ) {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnSelectionChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is changed.
//
//    Return Value - none
//
//    Comments
//    OnSelectionChange is called whenever the selection changes either within
//    a pane or is changed between panes.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnSelectionChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnObjectChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is to a different
//    of object on the left pane.
//
//    Return Value - none
//
//    Comments
//    OnObjectChange is called whenever the selection is changed between
//    objects in the left pane only.  Change in selection between folders,
//    subfolders or container object in the left pane will be reflected with a
//    call to OnObjectChange.  Change in selection between objects (messages,
//    subfolders) in the right pane will not call OnObjectChange, only
//    OnSelectionChange.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnObjectChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}

BOOL
GetServerNameFromPrinterName(
    LPTSTR lptszPrinterName,
    LPTSTR *pptszServerName
    )

/*++

Routine Description:

    retrieve the server name given a printer name

Arguments:

    [in] lptszPrinterName - Identifies the printer in question
    [out] lptszServerName - Address of pointer to output string buffer. 
                            NULL indicates local server.
                            The caller is responsible to free the buffer which 
                            pointer is given in this parameter.

Return Value:

    BOOL: TRUE - operation succeeded , FALSE: failed

--*/
{
    PPRINTER_INFO_2 ppi2 = NULL;
    LPTSTR  lptstrBuffer = NULL;
    BOOL    bRes = FALSE;

    if (lptszPrinterName) 
    {
        if (ppi2 = (PPRINTER_INFO_2) MyGetPrinter(lptszPrinterName,2))
        {
            if (GetServerNameFromPrinterInfo(ppi2,&lptstrBuffer))
            {
                if (lptstrBuffer)
                {
                    bRes = (NULL != (*pptszServerName = StringDup(lptstrBuffer)));
                }
                else
                {
                    bRes = TRUE;
                }
            }
            MemFree(ppi2);
        }
    }
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\faxext.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxext.h

Abstract:

    Fax exchange client extension header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Add GetServerNameFromPrinterInfo.
        Change GetServerName to GetServerNameFromPrinterName.

    dd/mm/yy -author-
        description
--*/

#ifndef _FAXEXT_H_
#define _FAXEXT_H_

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapiform.h>
#include <mapiguid.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <exchext.h>
#include <tapi.h>
#include <tchar.h>
#include <stdio.h>
#include <fxsapip.h>

#include "resource.h"
#include "faxmapip.h"
#include "faxreg.h"
#include "faxutil.h"

#define FAXUTIL_DEBUG
#define FAXUTIL_MEM
#define FAXUTIL_STRING
#define FAXUTIL_SUITE
#define FAXUTIL_REG
#include <faxutil.h>


#define MAX_FILENAME_EXT                    4

#define SERVER_COVER_PAGE                   1   



/*
 -  GetServerNameFromPrinterInfo
 -
 *  Purpose:
 *      Get the Server name, given a PRINTER_INFO_2 structure
 *
 *  Arguments:
 *      [in] ppi2 - Address of PRINTER_INFO_2 structure
 *      [out] lpptszServerName - Address of string pointer for returned name.
 *
 *  Returns:
 *      BOOL - TRUE: sucess , FALSE: failure.
 *
 *  Remarks:
 *      This inline function retrieves the server from a printer info structure
 *      in the appropriate way for win9x and NT. 
 */
_inline BOOL 
GetServerNameFromPrinterInfo(PPRINTER_INFO_2 ppi2,LPTSTR *lpptszServerName)
{   
    if (!ppi2)
    {
        return FALSE;
    }
#ifndef WIN95

    *lpptszServerName = NULL;
    if (ppi2->pServerName)
    {
        if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pServerName,2))))
        {
            return FALSE;
        }
    }
    return TRUE;

#else //WIN95
    
    //
    // Formatted: \\Server\port
    //
    if (!(ppi2->pPortName))
    {
        return FALSE;
    }
    if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pPortName,2))))
    {
        return FALSE;
    }
    _tcstok(*lpptszServerName,TEXT("\\"));

#endif //WIN95

    return TRUE;
}

LPVOID
MapiMemAlloc(
    SIZE_T Size
    );

LPVOID
MapiMemReAlloc(
	LPVOID ptr,
    SIZE_T Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

PVOID
MyGetPrinter(
    LPTSTR   PrinterName,
    DWORD   level
    );

BOOL
GetServerNameFromPrinterName(
    LPTSTR   PrinterName,
    LPTSTR   *lptszServerName
    );

void
ErrorMsgBox(
    HINSTANCE hInstance,
    HWND      hWnd,
    DWORD     dwMsgId
);

class MyExchExt;
class MyExchExtCommands;
class MyExchExtUserEvents;

extern "C"
{
    LPEXCHEXT CALLBACK ExchEntryPoint(void);
}

class MyExchExt : public IExchExt
{

 public:
    MyExchExt ();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                    () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                    () { ULONG ulCount = --m_cRef;
                         if (!ulCount) { delete this; }
                         return ulCount;};
    STDMETHODIMP Install (LPEXCHEXTCALLBACK pmecb,
                        ULONG mecontext, ULONG ulFlags);

    BOOL IsValid()   { return (m_pExchExtUserEvents && m_pExchExtCommands) ? TRUE : FALSE; }


 private:
    ULONG m_cRef;
    UINT  m_context;

    MyExchExtUserEvents * m_pExchExtUserEvents;
    MyExchExtCommands * m_pExchExtCommands;
};

class MyExchExtCommands : public IExchExtCommands
{
 public:
    MyExchExtCommands();
    ~MyExchExtCommands();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef();
    inline STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP InstallCommands(LPEXCHEXTCALLBACK pmecb,
                                HWND hwnd, HMENU hmenu,
                                UINT FAR * cmdidBase, LPTBENTRY lptbeArray,
                                UINT ctbe, ULONG ulFlags);
    STDMETHODIMP DoCommand(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP_(VOID) InitMenu(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP Help(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP QueryHelpText(UINT mni, ULONG ulFlags, LPTSTR sz, UINT cch);
    STDMETHODIMP QueryButtonInfo(ULONG tbid, UINT itbb, LPTBBUTTON ptbb,
                                LPTSTR lpsz, UINT cch, ULONG ulFlags);
    STDMETHODIMP ResetToolbar(ULONG tbid, ULONG ulFlags);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline UINT GetCmdID() { return m_cmdid; };

    inline HWND GetToolbarHWND() { return m_hwndToolbar; }

 private:
    ULONG m_cRef;          //
    ULONG m_context;       //
    UINT  m_cmdid;         // cmdid for menu extension command
    UINT  m_itbb;          // toolbar index
    HWND  m_hwndToolbar;   // toolbar window handle
    UINT  m_itbm;          //
    HWND  m_hWnd;          //
    FAXXP_CONFIG m_FaxConfig;
};


class MyExchExtUserEvents : public IExchExtUserEvents
{
 public:
    MyExchExtUserEvents() { m_cRef = 0; m_context = 0;
                            m_pExchExt = NULL; };
    STDMETHODIMP QueryInterface
                (REFIID                     riid,
                 LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                () { ULONG ulCount = --m_cRef;
                     if (!ulCount) { delete this; }
                     return ulCount;};

    STDMETHODIMP_(VOID) OnSelectionChange(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP_(VOID) OnObjectChange(LPEXCHEXTCALLBACK pmecb);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline VOID SetIExchExt
                (MyExchExt * pExchExt) { m_pExchExt = pExchExt; };

 private:
    ULONG m_cRef;
    ULONG m_context;

    MyExchExt * m_pExchExt;

};

#endif // _FAXEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\inc\faxmapip.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    Contains common fax mapi stuff.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

//
// 4.0;D:\nt\private\fax\faxext32\obj\i386\faxext32.dll;1;00000100000000
//
// \registry\machine\software\microsoft\exchange\client\extensions
//     FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
//

// {49A59282-9F30-11d2-912E-006094EB630B}
#define FAX_XP_GUID { 0x49, 0xa5, 0x92, 0x82, 0x9f, 0x30, 0x11, 0xd2, 0x91, 0x2e, 0x0, 0x60, 0x94, 0xeb, 0x63, 0xb };

//[RB] #define FAX_XP_GUID { 0x61, 0x85, 0x0a, 0x80, 0x0a, 0x47, 0x11, 0xd0, 0x88, 0x77, 0x0, 0xa0, 0x4, 0xff, 0x31, 0x28 }

#define MSGPS_FAX_PRINTER_NAME              L"FAX_PRINTER_NAME"
#define MSGPS_FAX_COVERPAGE_NAME            L"FAX_COVERPAGE_NAME"
#define MSGPS_FAX_USE_COVERPAGE             L"FAX_USE_COVERPAGE"
#define MSGPS_FAX_SERVER_COVERPAGE          L"FAX_SERVER_COVERPAGE"
#define MSGPS_FAX_SEND_SINGLE_RECEIPT       L"FAX_SEND_SINGLE_RECEIPT"
#define MSGPS_FAX_ATTACH_FAX                L"FAX_ATTACH_FAX"

#define NUM_FAX_MSG_PROPS                   6

#define MSGPI_FAX_PRINTER_NAME              0
#define MSGPI_FAX_COVERPAGE_NAME            1
#define MSGPI_FAX_USE_COVERPAGE             2
#define MSGPI_FAX_SERVER_COVERPAGE          3
#define MSGPI_FAX_SEND_SINGLE_RECEIPT       4
#define MSGPI_FAX_ATTACH_FAX                5


#define BASE_PROVIDER_ID                    0x6600

#define NUM_FAX_PROPERTIES                  7

#define PROP_FAX_PRINTER_NAME               0
#define PROP_USE_COVERPAGE                  1
#define PROP_COVERPAGE_NAME                 2
#define PROP_SERVER_COVERPAGE               3
#define PROP_FONT                           4
#define PROP_SEND_SINGLE_RECEIPT            5
#define PROP_ATTACH_FAX                     6


#define PR_FAX_PRINTER_NAME                 PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_FAX_PRINTER_NAME) )
#define PR_USE_COVERPAGE                    PROP_TAG( PT_LONG,  (BASE_PROVIDER_ID + PROP_USE_COVERPAGE)    )
#define PR_COVERPAGE_NAME	                PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_COVERPAGE_NAME)   )
#define PR_SERVER_COVERPAGE                 PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_SERVER_COVERPAGE) )
#define PR_FONT                             PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_FONT)             )
#define PR_SEND_SINGLE_RECEIPT              PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_SEND_SINGLE_RECEIPT))
#define PR_ATTACH_FAX                       PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_ATTACH_FAX)       )


typedef struct _FAXXP_CONFIG {
    LPTSTR  PrinterName;
    LPTSTR  CoverPageName;
    BOOL    UseCoverPage;
    BOOL    ServerCoverPage;
    LPTSTR  ServerName;
    BOOL    ServerCpOnly;
    LOGFONT FontStruct;
    BOOL    SendSingleReceipt;
    BOOL    bAttachFax;
} FAXXP_CONFIG, *PFAXXP_CONFIG;


const static SizedSPropTagArray( NUM_FAX_PROPERTIES, sptFaxProps ) =
{
    NUM_FAX_PROPERTIES,
    {
        PR_FAX_PRINTER_NAME,
        PR_USE_COVERPAGE,
        PR_COVERPAGE_NAME,
        PR_SERVER_COVERPAGE,
        PR_FONT,
        PR_SEND_SINGLE_RECEIPT,
        PR_ATTACH_FAX
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxext.h"
#include "debugex.h"


//
// globals
//

BOOL oleInitialized;

LPVOID
MapiMemAlloc(
    SIZE_T Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr=NULL;
    HRESULT hResult;

	// [Win64bug] MAPIAllocateBuffer should accpet size_t as allocating size
    hResult = MAPIAllocateBuffer( DWORD(Size), &ptr );
    if (S_OK == hResult) 
    {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}

LPVOID
MapiMemReAlloc(
	LPVOID ptr,
    SIZE_T Size
    )

/*++

Routine Description:

    Memory re-allocator.

Arguments:

	ptr		- pointer to pre allocated buffer

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID NewPtr = NULL;
    HRESULT hResult;

	// [Win64bug] MAPIAllocateBuffer should accpet size_t as allocating size
	hResult = MAPIAllocateMore(DWORD(Size), ptr ,&NewPtr);                
    if (S_OK == hResult) 
    {
        ZeroMemory( NewPtr, Size );
    }
    return NewPtr; 
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) {
        MAPIFreeBuffer( ptr );
    }
}


PVOID
MyGetPrinter(
    LPTSTR  PrinterName,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {
        return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}


LPTSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
	LPTSTR Pstr = NULL;

    if (Path == NULL || Path[0] == 0) 
	{
        return Path;
    }

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr && (*_tcsinc(Pstr)) == '\0' )
	{
		// the last character is a backslash, truncate it...
		_tcsset(Pstr,TEXT('\0'));
		Pstr = _tcsdec(Path,Pstr);
	}

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr )
	{
		_tcsnset(_tcsinc(Pstr),TEXT('\0'),1);
	}

    return Path;
}

void
ErrorMsgBox(
    HINSTANCE hInstance,
    HWND      hWnd,
    DWORD     dwMsgId
)
/*++

Routine Description:

    Display error message box

Arguments:

    hInstance  - [in] resource instance handle
    hWnd       - [in] window handle
    dwMsgId    - [in] string resource ID

Return Value:

    none

--*/
{
    TCHAR* ptCaption=NULL;
    TCHAR  tszCaption[MAX_PATH];
    TCHAR  tszMessage[MAX_PATH];

    DBG_ENTER(TEXT("ErrorMsgBox"));

    if(!LoadString( hInstance, IDS_FAX_EXT_MESSAGE, tszCaption, sizeof(tszCaption)/sizeof(TCHAR)))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
    }
    else
    {
        ptCaption = tszCaption;
    }

    if(!LoadString( hInstance, dwMsgId, tszMessage, sizeof(tszMessage)/sizeof(TCHAR)))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
        Assert(FALSE);
        return;
    }

    MessageBeep(MB_ICONEXCLAMATION);
    AlignedMessageBox(hWnd, tszMessage, ptCaption, MB_OK | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix ConfigDlgProc to view proper printer properties.

    dd/mm/yy -author-
        description


--*/

#include "faxxp.h"
#include "faxutil.h"
#include "faxreg.h"
#include "resource.h"
#include "debugex.h"
#pragma hdrstop



VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPTSTR      pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           tszDirName[MAX_PATH] = {0};
    TCHAR           CpName[MAX_PATH] = {0};
    HANDLE          hFindFile = INVALID_HANDLE_VALUE;
    TCHAR           tszFileName[MAX_PATH] = {0};
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;
    LPTSTR          pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    BOOL            bGotFile = FALSE;

    DBG_ENTER(TEXT("AddCoverPagesToList"));
    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) 
    {
        return;
    }

    if ((dirLen = _tcslen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        return;
    }

    _tcscpy( tszDirName, pDirPath );

	TCHAR* pLast = NULL;
    pLast = _tcsrchr(tszDirName,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(tszDirName, TEXT("\\"));
        dirLen += sizeof(TCHAR);
    }

    _tcsncpy(tszPathName, tszDirName, ARR_SIZE(tszPathName)-1);
    pPathEnd = _tcschr(tszPathName, '\0');

    TCHAR file_to_find[MAX_PATH] = {0};

    _tcscpy(file_to_find,tszDirName);

    _tcscat(file_to_find, FAX_COVER_PAGE_MASK );

    //
    // Call FindFirstFile/FindNextFile to enumerate the files
    // matching our specification
    //
    hFindFile = FindFirstFile( file_to_find, &findData );
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("FindFirstFile"), ::GetLastError());
        bGotFile = FALSE;
    }
    else
    {
        bGotFile = TRUE;
    }
    while (bGotFile) 
    {
        _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
        if(!IsValidCoverPage(tszPathName))
        {
            goto next;
        }                

        //
        // Exclude directories and hidden files
        //

        if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY)) 
        {
            continue;
        }

        //
        // Make sure we have enough room to store the full pathname
        //

        if ((fileLen = _tcslen( findData.cFileName)) <= MAX_FILENAME_EXT ) 
        {
            continue;
        }

        if (fileLen + dirLen >= MAX_PATH) 
        {
            continue;
        }
        
        //
        // Add the cover page name to the list window, 
        // but don't display the filename extension
        //
        _tcscpy( CpName, findData.cFileName );
        
        if (pExtension = _tcsrchr(CpName,TEXT('.'))) 
        {
            *pExtension = NULL;
        }

        if ( ! ServerCoverPage )
        {
            TCHAR szPersonal[30];
            LoadString( g_hResource, IDS_PERSONAL, szPersonal, 30 );
            _tcscat( CpName, TEXT(" "));
            _tcscat( CpName, szPersonal );
        }

        listIndex = (INT)SendMessage(
                    hwndList,
                    LB_ADDSTRING,
                    0,
                    (LPARAM) CpName);

        if (listIndex != LB_ERR) 
        {
            SendMessage(hwndList, 
                        LB_SETITEMDATA, 
                        listIndex, 
                        ServerCoverPage ? SERVER_COVER_PAGE : 0);
        }

next:     
        bGotFile = FindNextFile(hFindFile, &findData);
        if (! bGotFile)
        {
            VERBOSE(DBG_MSG, TEXT("FindNextFile"), ::GetLastError());
            break;
        }            
    }
    
    if(INVALID_HANDLE_VALUE != hFindFile)
    {
        FindClose(hFindFile);
    }
}



VOID
DrawSampleText(
    HWND hDlg,
    HDC hDC,
    PFAXXP_CONFIG FaxConfig
    )
{

    int PointSize;
    TCHAR PointSizeBuffer[16];
    TCHAR FontTypeBuffer[32];
    BOOL bItalic = FALSE;
    BOOL bBold = FALSE;

    DBG_ENTER(TEXT("DrawSampleText"));    

    PointSize = abs ( MulDiv((int) FaxConfig->FontStruct.lfHeight, 72, GetDeviceCaps( hDC, LOGPIXELSY)));
    _stprintf( PointSizeBuffer, TEXT("%d"), PointSize );
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_SIZE ), PointSizeBuffer );

    SetWindowText( GetDlgItem( hDlg, IDC_FONT_NAME), FaxConfig->FontStruct.lfFaceName );

    //
    // get the font type
    //
    ZeroMemory(FontTypeBuffer, sizeof(FontTypeBuffer) );
    if (FaxConfig->FontStruct.lfItalic)  
    {
        bItalic = TRUE;
    }

    if ( FaxConfig->FontStruct.lfWeight == FW_BOLD ) 
    {
        bBold = TRUE;
    }

    if (bBold) 
    {
        LoadString(g_hResource, IDS_FONT_BOLD, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
        // concat "italic"
        if (bItalic) 
        {
            LoadString(g_hResource, 
                       IDS_FONT_ITALIC, 
                       &FontTypeBuffer[lstrlen(FontTypeBuffer)],
                       sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) - lstrlen(FontTypeBuffer) );
        }
    } 
    else if (bItalic) 
    {
        LoadString(g_hResource, IDS_FONT_ITALIC, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
    } 
    else 
    {
        LoadString(g_hResource, IDS_FONT_REGULAR, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
    }

    
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_STYLE), FontTypeBuffer );

    
}


void EnableCoverPageList(HWND hDlg)
{

    DBG_ENTER(TEXT("EnableCoverPageList"));   

    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), TRUE  );
    } 
    else 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), FALSE );
    }
}

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )

/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static PFAXXP_CONFIG FaxConfig = NULL;
    static HWND hwndListPrn = NULL;
    static HWND hwndListCov = NULL;

    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD  CountPrinters = 0;
    DWORD  dwSelectedItem = 0;    
    DWORD  dwNewSelectedItem = 0;    
    TCHAR  Buffer[256] = {0};
    TCHAR  CpDir[MAX_PATH] = {0};
    LPTSTR p = NULL;
    PAINTSTRUCT ps;    
    HANDLE hFax = NULL;
    DWORD   dwError = 0;
    DWORD   dwMask = 0;
    BOOL    bShortCutCp = FALSE;
    BOOL    bGotFaxPrinter = FALSE;
    BOOL    bIsCpLink = FALSE;

    DBG_ENTER(TEXT("ConfigDlgProc"));

	switch( message ) 
    {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );            
            
            //
            // populate the printers combobox
            //
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 
                                                           2, 
                                                           &CountPrinters);
            if (NULL != PrinterInfo) 
            {
                DWORD j = 0;
                for (DWORD i=0; i<CountPrinters; i++) 
                {
                    if ((NULL != PrinterInfo[i].pDriverName) && 
						(_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)) 
                    {
                        //
                        //if the current printer is a fax printer, add it to the CB list
                        //
                        bGotFaxPrinter = TRUE;
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );

                        if ((NULL != FaxConfig->PrinterName)      && 
                            (NULL != PrinterInfo[i].pPrinterName) &&
                            (_tcscmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0))
                        {
                            //
                            //if it is also the default printer according to transport config.
                            //place the default selection on it
                            //
                        
                            dwSelectedItem = j;
                        }

                        if(FaxConfig->PrinterName == NULL || _tcslen(FaxConfig->PrinterName) == 0)
                        {
                            //
                            // There is no default fax printer
                            // Choose the first one
                            //
                            MemFree(FaxConfig->PrinterName);
                            FaxConfig->PrinterName = StringDup(PrinterInfo[i].pPrinterName);
                            if(FaxConfig->PrinterName == NULL)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }

                            if(PrinterInfo[i].pServerName)
                            {
                                MemFree(FaxConfig->ServerName);
                                FaxConfig->ServerName = StringDup(PrinterInfo[i].pServerName);
                                if(FaxConfig->ServerName == NULL)
                                {
                                    CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                    ErrorMsgBox(g_hResource, IDS_OUT_OF_MEM);
                                    EndDialog( hDlg, IDABORT);
                                    return FALSE;
                                }
                            }

                            dwSelectedItem = j;
                        }

                        j += 1;
                    } // if fax printer
                } // for

                MemFree( PrinterInfo );
                PrinterInfo = NULL;
                SendMessage( hwndListPrn, CB_SETCURSEL, (WPARAM)dwSelectedItem, 0 );
            }
            if (! bGotFaxPrinter)
            {
                //
                //  there were no printers at all, or non of the printers is a fax printer.
                //
                CALL_FAIL(GENERAL_ERR, TEXT("MyEnumPrinters"), ::GetLastError());
                ErrorMsgBox(g_hResource, IDS_NO_FAX_PRINTER);
                EndDialog( hDlg, IDABORT);
				break;
            }

            //            
            // Get the Server CP flag and receipts options
            //
            FaxConfig->ServerCpOnly = FALSE;
            if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax))
            {
                DWORD dwReceiptOptions;
                BOOL  bEnableReceiptsCheckboxes = FALSE;

                if(!FaxGetPersonalCoverPagesOption(hFax, &FaxConfig->ServerCpOnly))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), ::GetLastError());
                    ErrorMsgBox(g_hResource, IDS_CANT_ACCESS_SERVER);
                }
                else
                {
                    //
                    // Inverse logic
                    //
                    FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                }
                if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                }
                else
                {
                    if (DRT_EMAIL & dwReceiptOptions)
                    {
                        //
                        // Server supports receipts by email - enable the checkboxes
                        //
                        bEnableReceiptsCheckboxes = TRUE;
                    }
                }
                EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                FaxClose(hFax);
                hFax = NULL;
            }

            else
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError());
                ErrorMsgBox(g_hResource, IDS_CANT_ACCESS_SERVER);
            }
            //
            //send single receipt for a fax sent to multiple recipients?
            //
            if(FaxConfig->SendSingleReceipt)
            {
                CheckDlgButton( hDlg, IDC_SEND_SINGLE_RECEIPT, BST_CHECKED );
            }
            //
            // Attach fax document?
            //
            if (FaxConfig->bAttachFax)
            {
                CheckDlgButton( hDlg, IDC_ATTACH_FAX, BST_CHECKED );
            }
            //
            //cover page CB & LB enabling
            //
            if (FaxConfig->UseCoverPage)
            {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            }
            EnableCoverPageList(hDlg);

            //
            // Emulate printer's selection change, in order to collect printer config info.
            // including cover pages LB population
            //
            ConfigDlgProc(hDlg, WM_COMMAND,MAKEWPARAM(IDC_PRINTER_LIST,CBN_SELCHANGE),(LPARAM)0);
            break;

        case ( WM_PAINT ) :
            if (BeginPaint( hDlg, &ps )) 
            {
                DrawSampleText( hDlg, ps.hdc, FaxConfig );
                EndPaint( hDlg, &ps );
            }
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) 
            {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE) 
                {
                    EnableCoverPageList(hDlg);
                    return FALSE;
                }  
            }

            if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST) 
            {
                //
                // refresh cover pages list
                //

                TCHAR SelectedPrinter[MAX_PATH];
				DWORD dwPrinterNameLength = 0;
                //
                // a new fax printer was selected - delete all old coverpages from the list
                // because they might include the old fax server's cover pages
                //
                SendMessage(hwndListCov, LB_RESETCONTENT, 0, 0);

                if (CB_ERR != (dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 )))
                //
                // get the 0 based index of the currently pointed printer
                //
                {
					if (CB_ERR != (dwPrinterNameLength = (DWORD)SendMessage( hwndListPrn, CB_GETLBTEXTLEN, dwSelectedItem, 0)))
					{
						if (dwPrinterNameLength < MAX_PATH)
						{
							if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) SelectedPrinter )) 
							//
							// get that printer's name into SelectedPrinter
							//
							{
								if (NULL != (PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( SelectedPrinter, 2 )))
								{
									LPTSTR lptszServerName = NULL;
									if (GetServerNameFromPrinterInfo(PrinterInfo,&lptszServerName))
									{
										if (GetServerCpDir( lptszServerName, CpDir, sizeof(CpDir)/sizeof(CpDir[0]) ))
										{
											AddCoverPagesToList( hwndListCov, CpDir, TRUE );
										}
										if ((NULL == FaxConfig->ServerName) ||(NULL == lptszServerName) ||
											(_tcscmp(FaxConfig->ServerName,lptszServerName) != 0)) 
										{
											//
											// the server's name and config are not updated - refresh them
											//
											MemFree(FaxConfig->ServerName);
											FaxConfig->ServerName = lptszServerName;

											//
											// get the new server's ServerCpOnly flag
											//
											FaxConfig->ServerCpOnly = FALSE;
											if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) )
											{
												DWORD dwReceiptOptions;
												BOOL  bEnableReceiptsCheckboxes = FALSE;
												if (!FaxGetPersonalCoverPagesOption(hFax,&FaxConfig->ServerCpOnly))
												{
													CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
												}
												else
												{
													//
													// inverse logic
													//
													FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
												}
												if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
												{
													CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
												}
												else
												{
													if (DRT_EMAIL & dwReceiptOptions)
													{
														//
														// Server supports receipts by email - enable the checkboxes
														//
														bEnableReceiptsCheckboxes = TRUE;
													}
												}
												EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
												EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

												FaxClose(hFax);
												hFax = NULL;
											}
										}
										else 
										{
											//
											// The server's name hasn't changed, all details are OK
											//
											MemFree(lptszServerName);
											lptszServerName = NULL;
										}
									}
									else 
									//
									// GetServerNameFromPrinterInfo failed
									//
									{
										FaxConfig->ServerCpOnly = FALSE;
									}

									//
									// don't add client coverpages if FaxConfig->ServerCpOnly is set to true
									//
									if (! FaxConfig->ServerCpOnly) 
									{
										if(GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0])))
										{
											//
											// if the function failes- the ext. is installed on a machine 
											// that doesn't have a client on it, 
											// so we shouldn't look for personal cp
											//
											AddCoverPagesToList( hwndListCov, CpDir, FALSE );
										}
									}
									MemFree( PrinterInfo );
									PrinterInfo = NULL;

									//
									// check if we have any cp in the LB, if not-  don't allow the user to 
									// ask for a cp with he's fax
									//
									DWORD dwItemCount = (DWORD)SendMessage(hwndListCov, LB_GETCOUNT, NULL, NULL);
									if(LB_ERR == dwItemCount)
									{
										CALL_FAIL(GENERAL_ERR, TEXT("SendMessage (LB_GETCOUNT)"), ::GetLastError());
									}
									else
									{
										EnableWindow( GetDlgItem( hDlg, IDC_USE_COVERPAGE ), dwItemCount ? TRUE : FALSE );
									}

									if(FaxConfig->CoverPageName)
									{
										_tcscpy( Buffer, FaxConfig->CoverPageName );
									}
									if ( ! FaxConfig->ServerCoverPage )
									{   
										TCHAR szPersonal[30] = _T("");
										LoadString( g_hResource, IDS_PERSONAL, szPersonal, 30 );
										_tcscat( Buffer, _T(" ") );
										_tcscat( Buffer, szPersonal );
									}

									dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, -1, (LPARAM) Buffer );
									//
									// get the index of the default CP
									// if it is supposed to be a link, and the cp that we found is not a link, 
									// find the next string that matches.
									// this can happen if there's al ink to a cp named X, and a regular cp named X.
									//
									if (dwSelectedItem == LB_ERR) 
									{
										dwSelectedItem = 0;
									}

									SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) dwSelectedItem, 0 );
									//
									// place the default selection on that CP
									//
								}
							}
                        }
                    }
                }
                break;
            }

            switch (wParam) 
            {
                case IDC_SET_FONT:
                    {
                        CHOOSEFONT  cf;
                        LOGFONT     FontStruct;

                        CopyMemory( &FontStruct, &FaxConfig->FontStruct, sizeof(LOGFONT) );

                        cf.lStructSize = sizeof(CHOOSEFONT);
                        cf.hwndOwner = hDlg;
                        cf.lpLogFont = &FontStruct;
                        cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS;
                        cf.rgbColors = 0;
                        cf.lCustData = 0;
                        cf.lpfnHook = NULL;
                        cf.lpTemplateName = NULL;
                        cf.hInstance = NULL;
                        cf.lpszStyle = NULL;
                        cf.nFontType = SCREEN_FONTTYPE;
                        cf.nSizeMin = 0;
                        cf.nSizeMax = 0;

                        if (ChooseFont(&cf)) 
                        {
                            CopyMemory( &FaxConfig->FontStruct, &FontStruct, sizeof(LOGFONT) );
                            InvalidateRect(hDlg, NULL, TRUE);
                            UpdateWindow( hDlg );
                        }
                    }
                    break;

                case IDOK :
                    //
                    // Update UseCoverPage
                    //
                    FaxConfig->UseCoverPage = (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED);
                    
                    //
                    // Update SendSingleReceipt
                    //
                    FaxConfig->SendSingleReceipt = (IsDlgButtonChecked(hDlg, IDC_SEND_SINGLE_RECEIPT) == BST_CHECKED);
                    
                    //
                    // Update AttachFax
                    //
                    FaxConfig->bAttachFax = (IsDlgButtonChecked(hDlg, IDC_ATTACH_FAX) == BST_CHECKED);

                    //
                    // Update selected printer
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != CB_ERR)
                    {
                        if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        {
                            MemFree( FaxConfig->PrinterName );
                            FaxConfig->PrinterName = StringDup( Buffer );
                            if(!FaxConfig->PrinterName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                break;
                            }                            
                        }
                    }

                    //
                    // Update cover page
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR) //LB_ERR when no items in list
                    {
                        if (LB_ERR != SendMessage( hwndListCov, LB_GETTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        //
                        // get the selected CP name into the buffer
                        //
                        {
                            dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                            if (dwMask != LB_ERR)
                            {
                                FaxConfig->ServerCoverPage = (dwMask & SERVER_COVER_PAGE) == SERVER_COVER_PAGE;
                                if (!FaxConfig->ServerCoverPage)
                                {
                                    //
                                    // if the selected CP in the LB is not a server's CP
                                    // Omit the suffix: "(personal)"
                                    //
                                    p = _tcsrchr( Buffer, '(' );
                                    Assert(p);
									if( p )
									{
										p = _tcsdec(Buffer,p);
										if( p )
										{
											_tcsnset(p,TEXT('\0'),1);
										}
									}
                                }
                            }
                            
                            //
                            // update CP name to the selected one in the LB
                            //
                            MemFree( FaxConfig->CoverPageName );
                            FaxConfig->CoverPageName = StringDup( Buffer );
                            if(!FaxConfig->CoverPageName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_hResource, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                break;
                            }                            
                        }
                    }
                    
                    EndDialog( hDlg, IDOK );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;
            }
            break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;
        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\faxxp.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.cpp

Abstract:

    This module contains routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Handle errors and get proper server name in ServiceEntry.

    dd/mm/yy -author-
        description

--*/

#include "faxxp.h"
#include "debugex.h"
#include <faxres.h>

#pragma hdrstop


//
// globals
//

LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
HINSTANCE           g_hModule = NULL;    // DLL handle
HINSTANCE           g_hResource = NULL;  // Resource DLL handle
HMODULE             g_hModRichEdit;
MAPIUID             g_FaxGuid = FAX_XP_GUID;



extern "C"
DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    DWORD dwRet = TRUE;
    DBG_ENTER(TEXT("DllMain"),dwRet,TEXT("Reason=%d,Context=%d"),Reason,Context);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, MapiMemReAlloc );

        g_hModule = hInstance;
        g_hResource = GetResInstance(hInstance);
        if(!g_hResource)
        {
            return FALSE;
        }
    }  
    else if (Reason == DLL_PROCESS_DETACH)
    {
        FreeResInstance();
    }

    return dwRet;
}


STDINITMETHODIMP
XPProviderInit(
    HINSTANCE hInstance,
    LPMALLOC lpMalloc,
    LPALLOCATEBUFFER lpAllocateBuffer,
    LPALLOCATEMORE lpAllocateMore,
    LPFREEBUFFER lpFreeBuffer,
    ULONG ulFlags,
    ULONG ulMAPIVer,
    ULONG * lpulProviderVer,
    LPXPPROVIDER * lppXPProvider
    )

/*++

Routine Description:

    Entry point called by the MAPI spooler when a profile uses this
    transport. The spooler calls this method and expects a pointer to an
    implementation of the IXPProvider interface. MAPI uses the returned
    IXPProvider interface pointer to logon on the transport provider.

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hr = S_OK;
    CXPProvider * pXPProvider = NULL;
    DBG_ENTER(TEXT("XPProviderInit"),hr,TEXT("ulFlags=%d,ulMAPIVer=%d"),ulFlags,ulMAPIVer);

    gpfnAllocateBuffer = lpAllocateBuffer;
    gpfnAllocateMore = lpAllocateMore;
    gpfnFreeBuffer = lpFreeBuffer;

    if (!g_hModRichEdit)
    {
        g_hModRichEdit = LoadLibrary( _T("RICHED32.DLL") );
    }

    __try
    {
        pXPProvider = new CXPProvider( hInstance );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // Do nothing (InitializeCriticalSection threw exception)
        //
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (!pXPProvider)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    *lppXPProvider = (LPXPPROVIDER)pXPProvider;
    *lpulProviderVer = CURRENT_SPI_VERSION;

exit:
    return hr;
}


HRESULT STDAPICALLTYPE
CreateDefaultPropertyTags(
    LPPROFSECT pProfileObj
    )

/*++

Routine Description:

    Creates the default property tags & values.

Arguments:

    pProfileObj - Profile object.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult;
    DBG_ENTER(TEXT("CreateDefaultPropertyTags"),hResult);

    SPropValue spvProps[NUM_FAX_PROPERTIES] = { 0 };
    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD CountPrinters;
    LPTSTR FaxPrinterName = NULL;
    TCHAR  szEmpty[2] = {0};
    LOGFONT FontStruct;
    HFONT hFont;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters );
    if (PrinterInfo)
    {
        DWORD i;
        for (i=0; i<CountPrinters; i++)
        {
            if (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)
            {
                FaxPrinterName = StringDup( PrinterInfo[i].pPrinterName );
                if(NULL == FaxPrinterName)
                {
                    VERBOSE(MEM_ERR, TEXT("StringDup Failed in xport\\faxxp.cpp\\CreateDefaultPropertyTags"));
                    hResult = E_OUTOFMEMORY;
                    goto exit;
                }
                break;
            }
        }
    }

    spvProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;
    spvProps[PROP_FAX_PRINTER_NAME].Value.bin.cb = FaxPrinterName ? (_tcslen(FaxPrinterName) + 1) * sizeof(TCHAR)
                                                                  : (_tcslen(szEmpty) + 1) * sizeof(TCHAR);
    spvProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE) ((FaxPrinterName) ? FaxPrinterName : szEmpty);

    spvProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    spvProps[PROP_COVERPAGE_NAME].Value.bin.cb = (_tcslen(szEmpty) + 1) * sizeof(TCHAR);
    spvProps[PROP_COVERPAGE_NAME].Value.bin.lpb= (LPBYTE)szEmpty;

    spvProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    spvProps[PROP_USE_COVERPAGE].Value.ul      = 0;

    spvProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    spvProps[PROP_SERVER_COVERPAGE].Value.ul   = 0;

    hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
    GetObject( hFont, sizeof(LOGFONT), &FontStruct );
    if(FontStruct.lfHeight > 0)
    {
        FontStruct.lfHeight *= -1;
    }
    FontStruct.lfWidth = 0;

    spvProps[PROP_FONT].ulPropTag              = PR_FONT;
    spvProps[PROP_FONT].Value.bin.cb           = sizeof(LOGFONT);
    spvProps[PROP_FONT].Value.bin.lpb          = (LPBYTE) &FontStruct;

    spvProps[PROP_SEND_SINGLE_RECEIPT].ulPropTag     = PR_SEND_SINGLE_RECEIPT;
    spvProps[PROP_SEND_SINGLE_RECEIPT].Value.ul      = TRUE;

    spvProps[PROP_ATTACH_FAX].ulPropTag     = PR_ATTACH_FAX;
    spvProps[PROP_ATTACH_FAX].Value.ul      = FALSE;

    LPSPropProblemArray lpProblems = NULL;

    hResult = pProfileObj->SetProps( sizeof(spvProps)/sizeof(SPropValue), spvProps, &lpProblems);

    if(FAILED(hResult))
    {
        hResult = ::GetLastError();
        CALL_FAIL(GENERAL_ERR, TEXT("SetProps"), hResult);
        goto exit;
    }

    if (lpProblems)
    {
        hResult =  MAPI_E_NOT_FOUND;
        MAPIFreeBuffer(lpProblems);
    }

exit:
    MemFree(PrinterInfo);
    MemFree(FaxPrinterName);

    return hResult;
}


HRESULT STDAPICALLTYPE
ServiceEntry(
    HINSTANCE          hInstance,
    LPMALLOC           pMallocObj,
    LPMAPISUP          pSupObj,
    ULONG              ulUIParam,
    ULONG              ulFlags,
    ULONG              ulContext,
    ULONG              ulCfgPropCount,
    LPSPropValue       pCfgProps,
    LPPROVIDERADMIN    pAdminProvObj,
    LPMAPIERROR *      ppMAPIError
    )

/*++

Routine Description:

    Called by the profile setup API to display the provider
    configuration properties for this transport provider

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult = S_OK;
    DBG_ENTER(TEXT("ServiceEntry"),hResult,TEXT("ulFlags=%d,ulContext=%d"),ulFlags,ulContext);

    LPPROFSECT   pProfileObj = NULL;
    ULONG        PropCount = 0;
    LPSPropValue pProps = NULL;
    FAXXP_CONFIG FaxConfig = {0};
    INT_PTR      nDlgRes;

    //
    // First check if the context of the call is UNINSTALL
    // If it is then pSupObj == NULL
    //
    if (ulContext == MSG_SERVICE_UNINSTALL)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_DELETE)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_INSTALL)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_PROVIDER_CREATE || 
        ulContext == MSG_SERVICE_PROVIDER_DELETE)
    {
        hResult = MAPI_E_NO_SUPPORT;
        goto exit;
    }

    Assert(NULL != pSupObj);
    
    hResult = pSupObj->GetMemAllocRoutines( &gpfnAllocateBuffer, &gpfnAllocateMore, &gpfnFreeBuffer );
    if(FAILED(hResult))
    {        
        CALL_FAIL(GENERAL_ERR, TEXT("IMAPISupport::GetMemAllocRoutines"), hResult);
        goto exit;
    }

    hResult = pAdminProvObj->OpenProfileSection(&g_FaxGuid,
                                                NULL,
                                                MAPI_MODIFY,
                                                &pProfileObj);
    if (FAILED(hResult))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("IProviderAdmin::OpenProfileSection"), hResult);
        goto exit;
    }

    if (ulContext == MSG_SERVICE_CREATE)
    {
        hResult = CreateDefaultPropertyTags( pProfileObj );
        goto exit;
    }
    
    if (ulContext != MSG_SERVICE_CONFIGURE)
    {
        goto exit;
    }

    //
    //get fax related props from profileObj, to give them as initial values for the DlgBox
    //
    hResult = pProfileObj->GetProps((LPSPropTagArray) &sptFaxProps,
                                    0,
                                    &PropCount,
                                    &pProps);
    if (!HR_SUCCEEDED(hResult))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProps"), hResult);
        goto exit;
    }

    FaxConfig.PrinterName = StringDup( (LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb);
    if (NULL == FaxConfig.PrinterName)
    {
        hResult = E_OUTOFMEMORY;
        goto exit;
    }

    FaxConfig.CoverPageName = StringDup((LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb);
    if (NULL == FaxConfig.CoverPageName)
    {
        hResult = E_OUTOFMEMORY;
        goto exit;
    }

    FaxConfig.UseCoverPage      = GetDwordProperty( pProps, PROP_USE_COVERPAGE );
    FaxConfig.ServerCoverPage   = GetDwordProperty( pProps, PROP_SERVER_COVERPAGE );
    FaxConfig.SendSingleReceipt = GetDwordProperty( pProps, PROP_SEND_SINGLE_RECEIPT );
    FaxConfig.bAttachFax        = GetDwordProperty( pProps, PROP_ATTACH_FAX );

    FaxConfig.ServerName = NULL;
    if(!GetServerNameFromPrinterName(FaxConfig.PrinterName,&FaxConfig.ServerName))
    {
        //
        // If we fail getting server name we will default to local
        //
        CALL_FAIL(GENERAL_ERR, TEXT("GetServerNameFromPrinterName"), 0);
    }

    if (!GetBinaryProperty( pProps, PROP_FONT, &FaxConfig.FontStruct, sizeof(FaxConfig.FontStruct)))
    {
        HFONT hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
        GetObject( hFont, sizeof(LOGFONT), &FaxConfig.FontStruct );
        if(FaxConfig.FontStruct.lfHeight > 0)
        {
            FaxConfig.FontStruct.lfHeight *= -1;
        }
        FaxConfig.FontStruct.lfWidth = 0;
    }

    //
    //open a dialogBox to let user config those props
    //    
    nDlgRes = DialogBoxParam(g_hResource,
                             MAKEINTRESOURCE(IDD_FAX_PROP_CONFIG),
                             (HWND)ULongToHandle(ulUIParam),
                             ConfigDlgProc,
                             (LPARAM) &FaxConfig);
    if(IDOK != nDlgRes)
    {
        if(-1 == nDlgRes)
        {
            hResult = E_FAIL;
            CALL_FAIL(GENERAL_ERR, TEXT("DialogBoxParam"), GetLastError());
        }
        goto exit;
    }

    //
    //update props' value in the profileObj
    //
    pProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;

    pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE) FaxConfig.PrinterName;
    pProps[PROP_FAX_PRINTER_NAME].Value.bin.cb =  (_tcslen(FaxConfig.PrinterName) + 1)*sizeof(TCHAR) ;
                                                                
    pProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    pProps[PROP_COVERPAGE_NAME].Value.bin.lpb   = (LPBYTE)FaxConfig.CoverPageName;
    pProps[PROP_COVERPAGE_NAME].Value.bin.cb =  (_tcslen(FaxConfig.CoverPageName) + 1)*sizeof(TCHAR) ;

    pProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    pProps[PROP_USE_COVERPAGE].Value.ul      = FaxConfig.UseCoverPage;

    pProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    pProps[PROP_SERVER_COVERPAGE].Value.ul   = FaxConfig.ServerCoverPage;

    pProps[PROP_FONT].ulPropTag              = PR_FONT;
    pProps[PROP_FONT].Value.bin.lpb          = (LPBYTE)&FaxConfig.FontStruct;
    pProps[PROP_FONT].Value.bin.cb           = sizeof(FaxConfig.FontStruct);

    pProps[PROP_SEND_SINGLE_RECEIPT].ulPropTag     = PR_SEND_SINGLE_RECEIPT;
    pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul      = FaxConfig.SendSingleReceipt;

    pProps[PROP_ATTACH_FAX].ulPropTag      = PR_ATTACH_FAX;
    pProps[PROP_ATTACH_FAX].Value.ul       = FaxConfig.bAttachFax;

    hResult = pProfileObj->SetProps( PropCount, pProps, NULL);

exit:

    if (FaxConfig.PrinterName)
    {
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = NULL;
    }
    if (FaxConfig.CoverPageName)
    {
        MemFree( FaxConfig.CoverPageName );
        FaxConfig.CoverPageName = NULL;
    }
    if (FaxConfig.ServerName)
    {
        MemFree(FaxConfig.ServerName);
        FaxConfig.ServerName = NULL;
    }

    if (pProfileObj)
    {
        pProfileObj->Release();
    }

    if (pProps)
    {
        MAPIFreeBuffer( pProps );
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// MAPI Transport Provider resource ID file         //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [11500 - 11999]                                  //
//                                                  //
//////////////////////////////////////////////////////

#include "..\..\admin\faxres\resource.h"

#define IDD_FAX_PROP_CONFIG            11500 
#define IDI_FAX_EXT                    11501 
#define IDS_CANT_ACCESS_PRINTER        11503 
#define IDS_RESOURCES_UNAVAIL          11504 
#define IDS_CANT_PRINT                 11505 
#define IDS_CANT_ACCESS_MSG_DATA       11506 
#define IDS_CANT_ACCESS_PROFILE        11507 
#define IDS_BAD_ATTACHMENTS            11508 
#define IDS_FONT_REGULAR               11509 
#define IDS_FONT_ITALIC                11510 
#define IDS_FONT_BOLD                  11511 
#define IDS_FAX_MESSAGE                11513 
#define IDS_CANT_PRINT_BODY            11515 
#define IDS_FAILED_MESSAGE             11516 
#define IDS_OUT_OF_MEM                 11517 
#define IDS_INTERNAL_ERROR             11518 
#define IDS_SUBJECT_FORMAT             11519 
#define IDS_PERSONAL_CP_FORBIDDEN      11520 
#define IDS_BAD_CANNONICAL_ADDRESS     11521 
#define IDS_NO_MSG_ATTACHMENTS         11522 
#define IDS_NO_MSG_BODY                11523 
#define IDS_EMPTY_MESSAGE              11524 
#define IDC_SET_FONT                   11528 
#define IDC_FONT_NAME                  11529 
#define IDC_FONT_STYLE                 11530 
#define IDC_FONT_SIZE                  11531 
#define IDCSTATIC_FONT                 11532 
#define IDCSTATIC_FONTSTYLE            11533 
#define IDCSTATIC_FONTSIZE             11534 
#define IDC_COVERPAGE_LIST_LABEL       11535 
#define IDCSTATIC_FONT_GROUP           11536 
#define IDC_STATIC_ICON                11537 
#define IDC_STATIC_TITLE               11538 
#define IDC_STATIC_PRINTERS            11539 
#define IDS_NO_SUBMIT_RITHTS           11541 
#define IDS_RECIPIENTS_LIMIT		   11542	
#define IDS_MESSAGE_DOC_NAME           11543 

//////////////////////////////////////////////////////
//                                                  //
// MAPI Transport Provider resource ID file         //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [11500 - 11999]                                  //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\faxdoc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxdoc.cpp

Abstract:

    This module contains all code necessary to print an
    exchange message as a fax document.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Connect to appropriate server, get basenote from windir

    dd/mm/yy -author-
        description

--*/
#include "faxxp.h"
#include "emsabtag.h"
#include "mapiutil.h"
#include "debugex.h"

#include <set>
using namespace std;

#pragma hdrstop


struct CRecipCmp
{
/*
    Comparison operator 'less'
    Compare two FAX_PERSONAL_PROFILEs by recipient's name and fax number
*/
    bool operator()(LPCFAX_PERSONAL_PROFILE lpcRecipient1, 
                    LPCFAX_PERSONAL_PROFILE lpcRecipient2) const
    {
        bool bRes = false;
        int  nFaxNumberCpm = 0;

        if(!lpcRecipient1 ||
           !lpcRecipient2 ||
           !lpcRecipient1->lptstrFaxNumber ||
           !lpcRecipient2->lptstrFaxNumber)
        {
            Assert(false);
            return bRes;
        }
       
        nFaxNumberCpm = _tcscmp(lpcRecipient1->lptstrFaxNumber, lpcRecipient2->lptstrFaxNumber);

        if(nFaxNumberCpm < 0)
        {
            bRes = true;
        }
        else if(nFaxNumberCpm == 0)
        {
            //
            // The fax numbers are same
            // lets compare the names
            //
            if(lpcRecipient1->lptstrName && lpcRecipient2->lptstrName)
            {
                bRes = (_tcsicmp(lpcRecipient1->lptstrName, lpcRecipient2->lptstrName) < 0);
            }
            else
            {
                bRes = (lpcRecipient1->lptstrName < lpcRecipient2->lptstrName);
            }
        }

        return bRes;
    }
};

typedef set<LPCFAX_PERSONAL_PROFILE, CRecipCmp> RECIPIENTS_SET;

// prototypes
LPTSTR ConvertAStringToTString(LPCSTR lpcstrSource);

extern "C"
BOOL MergeTiffFiles(
    LPTSTR BaseTiffFile,
    LPTSTR NewTiffFile
    );

extern "C"
BOOL PrintRandomDocument(
    LPCTSTR FaxPrinterName,
    LPCTSTR DocName,
    LPTSTR OutputFile
    );


PVOID
CXPLogon::MyGetPrinter(
    LPTSTR PrinterName,
    DWORD Level
    )

/*++

Routine Description:

    Gets the printer data for a specific printer

Arguments:

    PrinterName - Name of the desired printer

Return Value:

    Pointer to a printer info structure or NULL for failure.

--*/

{
    DBG_ENTER(TEXT("CXPLogon::MyGetPrinter"));

    PVOID PrinterInfo = NULL;
    HANDLE hPrinter = NULL;
    DWORD Bytes;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenPrinter"),::GetLastError());
        goto exit;
    }

    
    if ((!GetPrinter( hPrinter, Level, NULL, 0, &Bytes )) && (::GetLastError() != ERROR_INSUFFICIENT_BUFFER)) 
    {
        // we just want to know how much memory we need, so we pass NULL and 0, 
        // this way, the function will fail, but will return us the number of 
        // bytes required in Bytes
        CALL_FAIL (GENERAL_ERR, TEXT("GetPrinter"), ::GetLastError());
        goto exit;
    }

    PrinterInfo = (LPPRINTER_INFO_2) MemAlloc( Bytes );
    if (!PrinterInfo) 
    {
        goto exit;
    }

    if (!GetPrinter( hPrinter, Level, (LPBYTE) PrinterInfo, Bytes, &Bytes )) 
    {
        MemFree(PrinterInfo);
        PrinterInfo = NULL;
        goto exit;
    }
    
exit:
    if(hPrinter)
    {
        ClosePrinter( hPrinter );
    }
    return PrinterInfo;
}

static BOOL
GetFaxTempFileName(
    OUT LPTSTR lpstrTempName,
    IN DWORD dwOutStrSize
                  )
/*++

Routine Description:

    Generates a temporal file with prefix 'fax' in directory
    designated for temporal files.
Arguments:

    [OUT]   lpstrTempName   - Output paramter. Pointer to the temporal file name.
                       The buffer should be MAX_PATH characters.
    [IN]    dwOutStrSize    - Size of buffer lpstrTempName in TCHARs

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("GetFaxTempFileName"),bRes);

    TCHAR strTempPath[MAX_PATH] = {0};
    TCHAR strTempFile[MAX_PATH] = {0};
    DWORD ec = ERROR_SUCCESS; // LastError for this function.

    Assert(lpstrTempName);

    if (!GetTempPath( sizeof(strTempPath)/sizeof(TCHAR), strTempPath )) 
    {
        ec=::GetLastError();
        goto Exit;
    }

    if (GetTempFileName( strTempPath, _T("fax"), 0, strTempFile ) == 0)
    {
        ec=::GetLastError();
        goto Exit;

    }
	
	//
	//Copy the source string and leave space for the NULL char
	//
    _tcsncpy(lpstrTempName, strTempFile, dwOutStrSize-1);

Exit:
    if (ERROR_SUCCESS != ec) 
    {
        SetLastError(ec);
        bRes = FALSE;
    }
    return bRes;
}

BOOL
CXPLogon::PrintRichText(
    HWND hWndRichEdit,
    HDC  hDC
    )

/*++

Routine Description:

    Prints the rich text contained in a rich text
    window into a DC.

Arguments:

    hWndRichEdit    - Window handle for the rich text window
    hDC             - Printer device context

Return Value:

    None.

--*/

{
    BOOL bRet = FALSE;
    DBG_ENTER(TEXT("CXPLogon::PrintRichText"), bRet);

    FORMATRANGE fr;
    LONG lTextOut;
    LONG lTextCurr;
    RECT rcTmp;

    fr.hdc           = hDC;
    fr.hdcTarget     = hDC;
    fr.chrg.cpMin    = 0;
    fr.chrg.cpMax    = -1;

    //
    // Set page rect to phys page size in twips
    //
    fr.rcPage.top    = 0;
    fr.rcPage.left   = 0;
    fr.rcPage.right  = MulDiv(GetDeviceCaps(hDC, PHYSICALWIDTH),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSX));
    fr.rcPage.bottom = MulDiv(GetDeviceCaps(hDC, PHYSICALHEIGHT),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSY));

    //
    // Set up 3/4" horizontal and 1" vertical margins, but leave a minimum of 1"
    // printable space in each direction.  Otherwise, use full page.
    //
    fr.rc = fr.rcPage; // start with full page
    if (fr.rcPage.right > 2*3*1440/4 + 1440) 
    {
        fr.rc.right -= (fr.rc.left = 3*1440/4);
    }
    if (fr.rcPage.bottom > 3*1440) 
    {
        fr.rc.bottom -= (fr.rc.top = 1440);
    }

    //
    // save the formatting rectangle
    //
    rcTmp = fr.rc;

    if (!SetMapMode( hDC, MM_TEXT ))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetMapMode"), ::GetLastError());
        goto error;
    }

    lTextOut  = 0;
    lTextCurr = 0;

    while (TRUE) 
    {
        //
        // Just measure the text
        //
        lTextOut = (LONG)SendMessage( hWndRichEdit, EM_FORMATRANGE, FALSE, (LPARAM) &fr );
        if(lTextOut <= lTextCurr)
        {
            //
            // The end of the text
            //
            break;
        }

        lTextCurr = lTextOut;

        if (StartPage( hDC ) <= 0)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("StartPage"), ::GetLastError());
            goto error;
        }

        //
        // Render the page
        //
        lTextOut = (LONG)SendMessage( hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) &fr );

        if (EndPage( hDC ) <= 0)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("EndPage"), ::GetLastError());
            goto error;
        }

        fr.chrg.cpMin = lTextOut;
        fr.chrg.cpMax = -1;

        //
        // EM_FORMATRANGE tends to modify fr.rc.bottom, reset here
        //
        fr.rc = rcTmp;
    }
    bRet = TRUE;

error:
    //
    // flush the cache
    //
    SendMessage( hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) NULL );
    return bRet;
}

DWORD
CXPLogon::PrintPlainText(
    HDC hDC,
    LPSTREAM lpstmT,
    LPTSTR   tszSubject,
    PFAXXP_CONFIG FaxConfig
    )

/*++

Routine Description:

    Prints a stream of plain text into the printer DC provided.
    Note: this code was stolen from notepad.

Arguments:

    hDC         - Printer DC
    lpstmT      - Stream pointer for rich text.
    tszSubject  - Subject
    FaxConfig   - Fax configuration data

Return Value:

    ERROR_SUCCESS - if success
    Error IDS_... code if failed.

--*/

{
    DWORD  rVal = ERROR_SUCCESS;
    LPTSTR BodyText = NULL;
    LPTSTR lpLine;
    LPTSTR pLineEOL;
    LPTSTR pNextLine;
    HRESULT hResult;
    HFONT hFont = NULL;
    HFONT hPrevFont = NULL;
    TEXTMETRIC tm;
    INT nLinesPerPage;
    INT dyTop;              // width of top border (pixels)
    INT dyBottom;           // width of bottom border
    INT dxLeft;             // width of left border
    INT dxRight;            // width of right border
    INT yPrintChar;         // height of a character
    INT tabSize;            // Size of a tab for print device in device units
    INT yCurpos = 0;
    INT xCurpos = 0;
    INT nPixelsLeft = 0;
    INT guess = 0;
    SIZE Size;                 // to see if text will fit in space left
    INT nPrintedLines = 0;
    BOOL fPageStarted = FALSE;
    INT iPageNum = 0;
    INT xPrintRes;          // printer resolution in x direction
    INT yPrintRes;          // printer resolution in y direction
    INT yPixInch;           // pixels/inch
    INT xPixInch;           // pixels/inch
    INT xPixUnit;           // pixels/local measurement unit
    INT yPixUnit;           // pixels/local measurement unit
    BOOL fEnglish;
    DWORD Chars=0;
    DWORD dwBodyLen=0;
    DWORD dwSubjectLen=0;
    STATSTG Stats;
    INT PrevBkMode = 0;

    DBG_ENTER(TEXT("CXPLogon::PrintPlainText"),rVal);

    Assert(hDC);
    Assert(FaxConfig);

    if(lpstmT)
    {
        hResult = lpstmT->Stat( &Stats, 0 );
        if (FAILED(hResult)) 
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    
        dwBodyLen = (INT) Stats.cbSize.QuadPart;
    }

    if(tszSubject)
    {
        dwSubjectLen = _tcslen(tszSubject);
    }

    BodyText = (LPTSTR) MemAlloc(dwSubjectLen * sizeof(TCHAR) + dwBodyLen + 4 );
    if (!BodyText) 
    {
        rVal = IDS_OUT_OF_MEM;
        goto exit;
    }

    if(tszSubject)
    {
        _tcscpy(BodyText, tszSubject);
        lpLine = _tcsninc(BodyText, dwSubjectLen);
    }
    else
    {
        lpLine = BodyText;
    }

    if(lpstmT)
    {
        hResult = lpstmT->Read( (LPVOID)lpLine, dwBodyLen, (LPDWORD) &dwBodyLen );
        if (FAILED(hResult))
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    }

    lpLine = BodyText;
    Chars  = _tcslen(lpLine);

    //
    // check if the body is not empty
    // if the message length is shorter then 32(arbitrary number) 
    // and all the carachters are control or space.
    //
    if(Chars < 32)
    {
        BOOL bEmpty = TRUE;
        TCHAR* pTchar = lpLine;
        for(DWORD dw = 0; dw < Chars; ++dw)
        {
            if(!_istspace(*pTchar) && !_istcntrl(*pTchar))
            {
                bEmpty = FALSE;
                break;
            }
            pTchar = _tcsinc(pTchar);
        }
        if(bEmpty)
        {
            rVal = IDS_NO_MSG_BODY;
            goto exit;
        }
    }

    fEnglish = GetProfileInt( _T("intl"), _T("iMeasure"), 1 );

    xPrintRes = GetDeviceCaps( hDC, HORZRES );
    yPrintRes = GetDeviceCaps( hDC, VERTRES );
    xPixInch  = GetDeviceCaps( hDC, LOGPIXELSX );
    yPixInch  = GetDeviceCaps( hDC, LOGPIXELSY );
    //
    // compute x and y pixels per local measurement unit
    //
    if (fEnglish) 
    {
        xPixUnit= xPixInch;
        yPixUnit= yPixInch;
    } 
    else 
    {
        xPixUnit= CMToInches( xPixInch );
        yPixUnit= CMToInches( yPixInch );
    }

    SetMapMode( hDC, MM_TEXT );

    //
    // match font size to the device point size
    //
    FaxConfig->FontStruct.lfHeight = -MulDiv(FaxConfig->FontStruct.lfHeight, yPixInch, 72);

    hFont = CreateFontIndirect( &FaxConfig->FontStruct );

    hPrevFont = (HFONT) SelectObject( hDC, hFont );
    SetBkMode( hDC, TRANSPARENT );
    if (!GetTextMetrics( hDC, &tm )) 
    {
        rVal = IDS_CANT_PRINT_BODY;
        goto exit;
    }

    yPrintChar = tm.tmHeight + tm.tmExternalLeading;
    tabSize = tm.tmAveCharWidth * 8;

    //
    // compute margins in pixels
    //
    dxLeft     = LEFT_MARGIN    *  xPixUnit;
    dxRight    = RIGHT_MARGIN   *  xPixUnit;
    dyTop      = TOP_MARGIN     *  yPixUnit;
    dyBottom   = BOTTOM_MARGIN  *  yPixUnit;

    //
    // Number of lines on a page with margins
    //
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    while (*lpLine) 
    {
        if ( _tcsncmp(lpLine,TEXT("\r"),1) == 0 ) 
        {
            lpLine = _tcsninc(lpLine,2);
            yCurpos += yPrintChar;
            nPrintedLines++;
            xCurpos= 0;
            continue;
        }

        pLineEOL = lpLine;
        pLineEOL = _tcschr(pLineEOL,TEXT('\r'));

        do 
        {
            if ((nPrintedLines == 0) && (!fPageStarted)) 
            {
                StartPage( hDC );
                fPageStarted = TRUE;
                yCurpos = 0;
                xCurpos = 0;
            }

            if ( _tcsncmp(lpLine,TEXT("\t"),1) == 0 ) 
            {
                //
                // round up to the next tab stop
                // if the current position is on the tabstop, goto next one
                //
                xCurpos = ((xCurpos + tabSize) / tabSize ) * tabSize;
                lpLine = _tcsinc(lpLine);
            } 
            else 
            {
                //
                // find end of line or tab
                //
                pNextLine = lpLine;
                while (*pNextLine &&
                       (pNextLine != pLineEOL) && 
                       ( _tcsncmp(pNextLine,TEXT("\t"),1) ) )
                {
                    pNextLine = _tcsinc(pNextLine);
                }

                //
                // find out how many characters will fit on line
                //
                Chars = (INT)(pNextLine - lpLine);
                nPixelsLeft = xPrintRes - dxRight - dxLeft - xCurpos;
                GetTextExtentExPoint( hDC, lpLine, Chars, nPixelsLeft, &guess, NULL, &Size );

                if (guess) 
                {
                    //
                    // at least one character fits - print
                    //
                    TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, guess );

                    xCurpos += Size.cx;   // account for printing
                    lpLine = _tcsninc(lpLine,guess);// printed characters
                } 
                else 
                {
                    //
                    // no characters fit what's left
                    // no characters will fit in space left
                    // if none ever will, just print one
                    // character to keep progressing through
                    // input file.
                    //
                    if (xCurpos == 0) 
                    {
                        if( lpLine != pNextLine ) 
                        {
                            //
                            // print something if not null line
                            // could use exttextout here to clip
                            //
                            TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, 1 );
                            lpLine = _tcsinc(lpLine);
                        }
                    } 
                    else 
                    {
                        //
                        // perhaps the next line will get it
                        //
                        xCurpos = xPrintRes;  // force to next line
                    }
                }

                //
                // move printhead in y-direction
                //
                if ((xCurpos >= (xPrintRes - dxRight - dxLeft) ) || (lpLine == pLineEOL)) 
                {
                   yCurpos += yPrintChar;
                   nPrintedLines++;
                   xCurpos = 0;
                }

                if (nPrintedLines >= nLinesPerPage) 
                {
                   EndPage( hDC );
                   fPageStarted = FALSE;
                   nPrintedLines = 0;
                   xCurpos = 0;
                   yCurpos = 0;
                   iPageNum++;
                }

            }

        } while (*lpLine &&  (lpLine != pLineEOL));

        if ( _tcsncmp(lpLine,TEXT("\r"),1) == 0 ) 
        {
            lpLine = _tcsinc(lpLine);
        }
        if ( _tcsncmp(lpLine,TEXT("\n"),1) == 0 ) 
        {
            lpLine = _tcsinc(lpLine);
        }

    }

    if (fPageStarted) 
    {
        EndPage( hDC );
    }

exit:
    MemFree( BodyText );
    if (hPrevFont) 
    {
        SelectObject( hDC, hPrevFont );
        DeleteObject( hFont );
    }
    if (PrevBkMode) 
    {
        SetBkMode( hDC, PrevBkMode );
    }
    return rVal;
}

extern "C"
DWORD CALLBACK
EditStreamRead(
    DWORD_PTR dwCookie,
    OUT LPBYTE pbBuff,
    LONG cb,
    LONG *pcb
    )

/*++

Routine Description:

    Wrapper function for the IStream read method.
    This function is used to read rich text from
    an exchange stream.

Arguments:

    dwCookie    - This pointer for the IStream object
    pbBuff      - Pointer to the data buffer
    cb          - Size of the data buffer
    pcb         - Returned byte count

Return Value:

    Return code from IStream::Read

--*/

{
    return ((LPSTREAM)dwCookie)->Read( pbBuff, cb, (ULONG*) pcb );
}

DWORD
CXPLogon::PrintAttachmentToFile(
        IN  LPMESSAGE       pMsgObj,
        IN  PFAXXP_CONFIG   pFaxConfig,
        OUT LPTSTR  *       lpptstrOutAttachments
                     )
/*++

Routine Description:

    Prints all attachments to the output file, by itearating
    over the attachment table
Arguments:

    pMsgObj    -  Pointer to message object. Used to get an attachmnet table
    pFaxConfig - Pointer to fax configuration
    lpptstrOutAttachments - Name of the output tiff file. The string should be empty

Return Value:

    0 - if success
    Last error code from if failed.

Comments:
    If this function succeeded it allocates a memory for *lpptstrOutAttachments
    and creates a temporal file *lpptstrOutAttachments.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrOutAttachments);
        MemFree(*lpptstrOutAttachments);

--*/
{
    DWORD   rVal = 0;
    DBG_ENTER(TEXT("CXPLogon::PrintAttachmentToFile"),rVal);

    LPSPropValue pPropsAttachTable = NULL;
    LPSPropValue pPropsAttach = NULL;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPATTACH lpAttach = NULL;
    LPSTREAM lpstmA = NULL;
    LPTSTR AttachFileName = NULL;
    TCHAR TempPath[MAX_PATH];
    TCHAR TempFile[MAX_PATH];
    TCHAR DocFile[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTSTR DocType = NULL;
    LPSTR p = NULL;
    BOOL DeleteAttachFile = FALSE;
    LPTSTR FileName = NULL;
    BOOL AllAttachmentsGood = TRUE;
    TCHAR   strTempTiffFile[MAX_PATH] = {0};
    TCHAR   strMergedTiffFile[MAX_PATH] = {0};
    HRESULT hResult = S_OK;
    DWORD   i = 0;
    ULONG   PropCount = 0;
    DWORD   Bytes;
    LPTSTR  lptstrTempStr = NULL;
    
    Assert(lpptstrOutAttachments);
    Assert(*lpptstrOutAttachments == NULL);
    //
    // get the attachment table, if it is available
    //

    hResult = pMsgObj->GetAttachmentTable( 0, &AttachmentTable );
    if (HR_SUCCEEDED(hResult)) 
    {
        hResult = HrAddColumns(
            AttachmentTable,
            (LPSPropTagArray) &sptAttachTableProps,
            gpfnAllocateBuffer,
            gpfnFreeBuffer
            );
        if (HR_SUCCEEDED(hResult)) 
        {
            hResult = HrQueryAllRows(
                AttachmentTable,
                NULL,
                NULL,
                NULL,
                0,
                &pAttachmentRows
                );
            if (FAILED(hResult)) 
            {
                pAttachmentRows = NULL;
            } 
            else 
            {
                if (pAttachmentRows->cRows == 0) 
                {
                    FreeProws( pAttachmentRows );
                    pAttachmentRows = NULL;
                }
            }
        }
    }

    if (pAttachmentRows) 
    {

        //
        // this loop verifies that each document's attachment registration
        // supports the printto verb.
        //

        AllAttachmentsGood = TRUE;

        for (i = 0; i < pAttachmentRows->cRows; ++i) 
        {

            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) 
            {
                goto next_attachment1;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) 
            {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) 
            {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                } 
                else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                }

            } 
            else 
            {
                DocType = ConvertAStringToTString( pPropsAttach[MSG_ATTACH_EXTENSION].Value.lpszA );
                if(!DocType)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            if (!DocType) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, DocType, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA))
            {
                VERBOSE (DBG_MSG, TEXT("File Type: %s: isn't associated to any application"), DocType);
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            wsprintf( TempPath, _T("%s\\shell\\printto\\command"), TempFile );

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, TempPath, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA))
            {
                VERBOSE (DBG_MSG, TEXT("File extension \"*%s\" doesn't have the PrintTo verb"), DocType);
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }
    next_attachment1:

            if (lpAttach) 
            {
                lpAttach->Release();
            }

            if (pPropsAttach) 
            {
                MAPIFreeBuffer( pPropsAttach );
                pPropsAttach = NULL;
            }

        }

        if (!AllAttachmentsGood) 
        {
            rVal = IDS_BAD_ATTACHMENTS;
            goto exit;
        }

        for (i = 0; i < pAttachmentRows->cRows; ++i) 
        {
            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) 
            {
                goto next_attachment2;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) 
            {
                goto next_attachment2;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) 
            {
                goto next_attachment2;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) 
            {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) 
            {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                } 
                else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                }
            } 
            else 
            {
                DocType = ConvertAStringToTString( pPropsAttach[MSG_ATTACH_EXTENSION].Value.lpszA );
                if(!DocType)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            if (!DocType) 
            {
                goto next_attachment2;
            }

            lpstmA = NULL;
            AttachFileName = NULL;
            DeleteAttachFile = FALSE;

            //
            // get the attached file name
            //

            if (FileName)
                MemFree(FileName);

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_PATHNAME].ulPropTag) != PT_ERROR) 
            {
                FileName = ConvertAStringToTString(pPropsAttach[MSG_ATTACH_PATHNAME].Value.lpszA);
                if(!FileName)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            } 
            else 
            {
                FileName = NULL;
            }

            if (FileName) 
            {
                AttachFileName = StringDup( FileName );
                if(!AttachFileName)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            //
            // get the stream object
            //

            switch( pPropsAttach[MSG_ATTACH_METHOD].Value.ul ) 
            {
                case ATTACH_BY_VALUE:
                            hResult = lpAttach->OpenProperty(
                                PR_ATTACH_DATA_BIN,
                                &IID_IStream,
                                0,
                                0,
                                (LPUNKNOWN*) &lpstmA
                                );
                            if (FAILED(hResult)) 
                            {
                                goto next_attachment2;
                            }
                            break;

                case ATTACH_EMBEDDED_MSG:
                case ATTACH_OLE:
                            hResult = lpAttach->OpenProperty(
                                PR_ATTACH_DATA_OBJ,
                                &IID_IStreamDocfile,
                                0,
                                0,
                                (LPUNKNOWN*) &lpstmA
                                );
                            if (FAILED(hResult)) 
                            {
                                hResult = lpAttach->OpenProperty(
                                    PR_ATTACH_DATA_BIN,
                                    &IID_IStreamDocfile,
                                    0,
                                    0,
                                    (LPUNKNOWN*) &lpstmA
                                    );
                                if (FAILED(hResult)) 
                                {
                                    hResult = lpAttach->OpenProperty(
                                        PR_ATTACH_DATA_OBJ,
                                        &IID_IStorage,
                                        0,
                                        0,
                                        (LPUNKNOWN*) &lpstmA
                                        );
                                    if (FAILED(hResult)) 
                                    {
                                        goto next_attachment2;
                                    }
                                }
                            }
                            break;

            }

            if (lpstmA) 
            {
                DWORD dwSize = GetTempPath( sizeof(TempPath)/sizeof(TCHAR) , TempPath );
                Assert( dwSize != 0);
                GetTempFileName( TempPath, _T("Fax"), 0, TempFile );
                hFile = CreateFile(
                    TempFile,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );
                if (hFile != INVALID_HANDLE_VALUE) 
                {

                    #define BLOCK_SIZE (64*1024)
                    LPBYTE StrmData;
                    DWORD BytesWrite;

                    StrmData = (LPBYTE) MemAlloc( BLOCK_SIZE );
                    if(!StrmData)
                    {
                        rVal = IDS_OUT_OF_MEM;
                        goto exit;
                    }

                    do 
                    {

                        hResult = lpstmA->Read( StrmData, BLOCK_SIZE, &Bytes );
                        if (FAILED(hResult)) 
                        {
                            break;
                        }

                        WriteFile( hFile, StrmData, Bytes, &BytesWrite, NULL );

                    } while (Bytes == BLOCK_SIZE);

                    CloseHandle( hFile );

                    if(StrmData)
                    {
                        MemFree( StrmData );
                        StrmData = NULL;
                    }

                    if (AttachFileName) 
                    {
                        MemFree( AttachFileName );
                        AttachFileName = NULL;
                    }

                    _tcscpy( DocFile, TempFile );
                    lptstrTempStr = _tcsrchr( DocFile, '.' );
                    if (lptstrTempStr) 
                    {
                        _tcscpy( lptstrTempStr, DocType );
                        MoveFile( TempFile, DocFile );
                        AttachFileName = StringDup( DocFile );
                        if(!AttachFileName)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    } 
                    else 
                    {
                        AttachFileName = StringDup( TempFile );
                        if(!AttachFileName)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }

                    DeleteAttachFile = TRUE;

                }

                lpstmA->Release();

            }

            if (AttachFileName) 
            {

                if (!GetFaxTempFileName(strTempTiffFile, ARR_SIZE(strTempTiffFile)))
                {
                    rVal = IDS_BAD_ATTACHMENTS;//GetLastError();
                    goto exit;
                }
                //
                // print the attachment
                //
                if (!PrintRandomDocument(   pFaxConfig->PrinterName,
                                            AttachFileName,
                                            strTempTiffFile))
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("PrintRandomDocument"), ::GetLastError());
                    rVal = IDS_BAD_ATTACHMENTS;//GetLastError(); 

                    if (!DeleteFile( strTempTiffFile ))
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
                    }

                    goto exit;
                }

                if (strMergedTiffFile[0] != 0) 
                {
                    //
                    // merge the attachments
                    //
                    if (!MergeTiffFiles( strMergedTiffFile,
                                         strTempTiffFile))
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("MergeTiffFiles"), ::GetLastError());
                        rVal = IDS_BAD_ATTACHMENTS;//GetLastError();

                        if (!DeleteFile( strTempTiffFile ))
                        {
                            CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
                        }

                        goto exit;
                    }
                    if (!DeleteFile( strTempTiffFile ))
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
                    }

                }
                else 
                {  // copies a first attachment
                    _tcscpy(strMergedTiffFile,strTempTiffFile);
                }
                if (DeleteAttachFile) 
                {
                    if (!DeleteFile( AttachFileName ))
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
                    }
                }

                if(AttachFileName)
                {
                    MemFree( AttachFileName );
                    AttachFileName = NULL;
                }

            }
    next_attachment2:

            if (lpAttach) 
            {
                lpAttach->Release();
            }

            if (pPropsAttach) 
            {
                MAPIFreeBuffer( pPropsAttach ); 
                pPropsAttach = NULL;
            }

        }

    }
    else
    {
        //
        // no attachments
        //
        rVal = IDS_NO_MSG_ATTACHMENTS;
    }

    if (strMergedTiffFile[0] != 0) 
    {
        if (!(*lpptstrOutAttachments = StringDup(strMergedTiffFile)))
        {
            rVal = IDS_OUT_OF_MEM;
        }
    }
exit:
    if (FileName) 
    {
        MemFree( FileName );
    }
    if (DocType) 
    {
        MemFree( DocType );
    }
    if (pAttachmentRows) 
    {
        FreeProws( pAttachmentRows );
    }
    if (AttachmentTable) 
    {
        AttachmentTable->Release();
    }

    if (AttachFileName) 
    {
        MemFree( AttachFileName );
    }

    return rVal;
}

DWORD
CXPLogon::PrintMessageToFile(
        IN  LPSTREAM        lpstmT,
        IN  BOOL            UseRichText,
        IN  PFAXXP_CONFIG   pFaxConfig,
        IN  LPTSTR          tszSubject,
        OUT LPTSTR*         lpptstrOutDocument
)
/*++

Routine Description:

    Prints the message body to the output file.

Arguments:

    lpstmT             - Pointer to the message body stream
    UseRichText        - boolean value. TRUE if the message is in Rich format,
                         FALSE - if this is a plain text
    pFaxConfig         - Pointer to fax configuration (used by plain text printing)
    tszSubject         - Subject
    lpptstrOutDocument - Name of the output tiff file. The string should be empty


Return Value:

    ERROR_SUCCESS - if success
    Error IDS_... code if failed.

Comments:
    If this function succeeded it allocates a memory for *lpptstrOutDocument
    and creates a temporal file *lpptstrOutDocument.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrOutDocument);
        MemFree(*lpptstrOutDocument);

--*/
{
    DWORD           rVal = ERROR_SUCCESS;
    LARGE_INTEGER   BigZero = {0};
    LPSTREAM        lpstm = NULL;
    HRESULT         hResult;
    
    HWND       hWndRichEdit = NULL;
    HDC        hDC = NULL;
    EDITSTREAM es = {0};
    TCHAR      strOutputTiffFile[MAX_PATH] = {0};
    TCHAR      DocName[64];

    TCHAR      tszSubjectFormat[64];
    TCHAR*     ptszSubjectText = NULL;
    DWORD      dwSubjectSize = 0;

    DOCINFO  docInfo = 
    {
        sizeof(DOCINFO),
        NULL,
        NULL,
        NULL,
        0,
    };

    DBG_ENTER(TEXT("CXPLogon::PrintMessageToFile"),rVal);

    Assert(pFaxConfig);
    Assert(lpptstrOutDocument);
    Assert(*lpptstrOutDocument==NULL);

    if (!(hDC = CreateDC( NULL,
                        pFaxConfig->PrinterName,
                        NULL,
                        NULL)))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateDC"), ::GetLastError());
        rVal = IDS_CANT_PRINT_BODY; 
        goto exit;
    }

    LoadString(g_hResource, IDS_MESSAGE_DOC_NAME, DocName, sizeof(DocName) / sizeof(DocName[0]));
    docInfo.lpszDocName = DocName;

    if (!GetFaxTempFileName(strOutputTiffFile, ARR_SIZE(strOutputTiffFile)))
    {
        rVal = IDS_CANT_PRINT_BODY; 
        goto exit;

    }
    docInfo.lpszOutput = strOutputTiffFile ;
    docInfo.lpszDatatype = _T("RAW");

    if (StartDoc(hDC, &docInfo) <= 0)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("StartDoc"), ::GetLastError());
        rVal = IDS_CANT_PRINT_BODY; 
        goto exit;
    }

    //
    // position the stream to the beginning
    //
    if(lpstmT)
    {
        hResult = lpstmT->Seek( BigZero, STREAM_SEEK_SET, NULL );
        if (HR_FAILED (hResult)) 
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    }

    if(!pFaxConfig->UseCoverPage && tszSubject && _tcslen(tszSubject))
    {
        //
        // get subject string
        //
        dwSubjectSize = _tcslen(tszSubject) * sizeof(TCHAR) + sizeof(tszSubjectFormat);
        ptszSubjectText = (TCHAR*)MemAlloc(dwSubjectSize);
        if(!ptszSubjectText)
        {
            rVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(!LoadString(g_hResource, IDS_SUBJECT_FORMAT, tszSubjectFormat, sizeof(tszSubjectFormat) / sizeof(tszSubjectFormat[0])))
        {
            Assert(FALSE);
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
            _tcscpy(tszSubjectFormat, TEXT("%s"));
        }

        _stprintf(ptszSubjectText, tszSubjectFormat, tszSubject);
        dwSubjectSize = _tcslen(ptszSubjectText);
    }

    if (UseRichText)
    {
        if(lpstmT)
        {
            hResult = WrapCompressedRTFStream( lpstmT, 0, &lpstm );
            if (HR_FAILED (hResult)) 
            {
                rVal = IDS_CANT_ACCESS_MSG_DATA;
                goto exit;
            }
        }

        hWndRichEdit = CreateWindowEx(
                                        0,                // extended window style
                                        TEXT("RICHEDIT"), // registered class name
                                        TEXT(""),         // window name
                                        ES_MULTILINE,     // window style
                                        0,                // horizontal position of window
                                        0,                // vertical position of window
                                        0,                // window width
                                        0,                // window height
                                        NULL,             // handle to parent or owner window
                                        NULL,             // menu handle or child identifier
                                        g_hModule,        // handle to application instance
                                        NULL);            // window-creation data
        
        if (!hWndRichEdit) 
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CreateWindowEx"), ::GetLastError());
            rVal = IDS_CANT_PRINT_BODY;
            goto exit;
        }

        if(ptszSubjectText && _tcslen(ptszSubjectText))
        {
            //
            // add subject to body
            //
            SendMessage(hWndRichEdit, 
                        WM_SETTEXT,  
                        0,          
                        (LPARAM)ptszSubjectText);
            //
            // Set the subject's font
            //                                              
            CHARFORMAT CharFormat = {0};
            CharFormat.cbSize = sizeof (CHARFORMAT);
            CharFormat.dwMask = CFM_BOLD        |
                                CFM_CHARSET     |
                                CFM_FACE        |
                                CFM_ITALIC      |
                                CFM_SIZE        |
                                CFM_STRIKEOUT   |
                                CFM_UNDERLINE;
            CharFormat.dwEffects = ((FW_BOLD <= pFaxConfig->FontStruct.lfWeight) ? CFE_BOLD : 0) |
                                   ((pFaxConfig->FontStruct.lfItalic) ? CFE_ITALIC : 0)          |
                                   ((pFaxConfig->FontStruct.lfStrikeOut) ? CFE_STRIKEOUT : 0)    |
                                   ((pFaxConfig->FontStruct.lfUnderline) ? CFE_UNDERLINE : 0);
            //
            // Height is already in point size.
            //
            CharFormat.yHeight =  abs ( pFaxConfig->FontStruct.lfHeight );
            //
            // Convert point to twip
            //
            CharFormat.yHeight *= 20;   

            CharFormat.bCharSet = pFaxConfig->FontStruct.lfCharSet;
            CharFormat.bPitchAndFamily = pFaxConfig->FontStruct.lfPitchAndFamily;
            lstrcpyn (CharFormat.szFaceName, pFaxConfig->FontStruct.lfFaceName, LF_FACESIZE);

            SendMessage(hWndRichEdit,
                        EM_SETCHARFORMAT,   
                        SCF_ALL,        // Apply font formatting to all the control's text
                        (LPARAM)&CharFormat);   // New font settings
            //
            // Place insertion point at the end of the subject text
            // See MSDN under "HOWTO: Place a Caret After Edit-Control Text"
            //
            SendMessage(hWndRichEdit,
                        EM_SETSEL,   
                        MAKELONG(0xffff,0xffff),
                        MAKELONG(0xffff,0xffff));
        }

        if(lpstm)
        {
            es.pfnCallback = EditStreamRead;
            es.dwCookie = (DWORD_PTR) lpstm;

            SendMessage(hWndRichEdit,
                        EM_STREAMIN,
                        SF_RTF | SFF_SELECTION | SFF_PLAINRTF,
                        (LPARAM) &es);
        }

        //
        // Check if the body is not empty.
        // If the message length is shorter then 32 (arbitrary number) 
        // and all the characters are control or space.
        //
        TCHAR tszText[32] = {0};
        DWORD dwTextSize;
        if (!GetWindowText(hWndRichEdit, tszText, sizeof(tszText)/sizeof(tszText[0])-1))
        {
            if (ERROR_INSUFFICIENT_BUFFER == ::GetLastError ())
            {
                //
                // Subject + Body are longer than 31 characters.
                // We're assuming they have valid printable text and
                // that this is not an empty message.
                //
                goto DoPrintRichText;
            }
            //
            // This is another type of error
            //
            rVal = ::GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT("GetWindowText"), rVal);
            goto exit;
        }
        dwTextSize = _tcslen(tszText);
        if(dwTextSize < sizeof(tszText)/sizeof(tszText[0])-2)
        {
            BOOL bEmpty = TRUE;
            TCHAR* pTchar = tszText;
            for(DWORD dw = 0; dw < dwTextSize; ++dw)
            {
                if(!_istspace(*pTchar) && !_istcntrl(*pTchar))
                {
                    bEmpty = FALSE;
                    break;
                }
                pTchar = _tcsinc(pTchar);
            }
            if(bEmpty)
            {
                rVal = IDS_NO_MSG_BODY;
                goto exit;
            }
        }

DoPrintRichText:
        if (!PrintRichText(hWndRichEdit, hDC))
        {
            rVal = IDS_CANT_PRINT_BODY;
            goto exit;
        }

    } 
    else 
    {        
        rVal = PrintPlainText(hDC, lpstmT, ptszSubjectText, pFaxConfig);
        if (rVal)
        {
            goto exit;
        }
    }
    // closes DC
    if (EndDoc(hDC) <=0)
    {
        Assert(FALSE);  // better not to be here
        goto exit;
    }
    if (!DeleteDC(hDC))
    {
        Assert(FALSE);  // better not to be here
        goto exit;
    }
    hDC = NULL;
        

    if (strOutputTiffFile[0] != 0)
    {
        if (!(*lpptstrOutDocument = StringDup(strOutputTiffFile)))
        {
            rVal = IDS_OUT_OF_MEM; //ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        VERBOSE (DBG_MSG, TEXT("Attachment File is %s:"), *lpptstrOutDocument);
    }

    rVal = ERROR_SUCCESS;
exit:
    if (lpstm) 
    {
        lpstm->Release();
    }
    if (hDC) 
    {
        DeleteDC(hDC);
    }

    MemFree(ptszSubjectText);

    if(ERROR_SUCCESS != rVal && _tcslen(strOutputTiffFile))
    {
        if (!DeleteFile( strOutputTiffFile ))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
        }        
    }

    return rVal;
}

DWORD
CXPLogon::PrintFaxDocumentToFile(
       IN  LPMESSAGE        pMsgObj,
       IN  LPSTREAM         lpstmT,
       IN  BOOL             UseRichText,
       IN  PFAXXP_CONFIG    pFaxConfig,
       IN  LPTSTR           tszSubject,
       OUT LPTSTR*          lpptstrMessageFileName
       )
/*++

Routine Description:

    Runs printing of the message body and attachments to the output file.

Arguments:

    pMsgObj                - Pointer to the message object
    lpstmT                 - Pointer to the message body stream
    UseRichText            - boolean value. TRUE if the message is in Rich format,
                             FALSE - if this is a plain text
    pFaxConfig             - Pointer to fax configuration (used by plain text printing)
    tszSubject             - Subject
    lpptstrMessageFileName - Name of the output tiff file. The string should be empty


Return Value:

    0 - if success
    Error code if failed.
Comments:
    If this function succeeded it returns an allocated memory for
    *lpptstrMessageFileName and a temporal file *lpptstrMessageFileName.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrMessageFileName);
        MemFree(*lpptstrMessageFileName);

--*/
{
    DWORD    rVal = 0;
    LPTSTR   lptstrAttachmentsTiff = NULL;
    BOOL     bAttachment = TRUE;
    BOOL     bBody = TRUE;

    DBG_ENTER(TEXT("CXPLogon::PrintFaxDocumentToFile"),rVal);


    Assert(lpptstrMessageFileName);
    Assert(*lpptstrMessageFileName == NULL);

    //
    // prints attachments
    //
    rVal = PrintAttachmentToFile(pMsgObj,
                                 pFaxConfig,
                                 &lptstrAttachmentsTiff);
    if(rVal)
    {
        if(IDS_NO_MSG_ATTACHMENTS == rVal)
        {
            rVal = 0;
            bAttachment = FALSE;
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("PrintAttachmentToFile"), 0);
            goto error;
        }            
    }

    //
    // prints the body
    //
    rVal = PrintMessageToFile(lpstmT,
                              UseRichText,
                              pFaxConfig,
                              tszSubject,
                              lpptstrMessageFileName);
    if(rVal)
    {
        if(IDS_NO_MSG_BODY == rVal)
        {
            rVal = 0;
            bBody = FALSE;
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("PrintMessageToFile"), 0);
            goto error;
        }            
    }

    if(!bBody && !bAttachment)
    {
        rVal = IDS_EMPTY_MESSAGE; 
        goto error;
    }

    if (!*lpptstrMessageFileName)   // empty body
    {
        if (lptstrAttachmentsTiff)  // the message contains attachments
        {
            if (!(*lpptstrMessageFileName = StringDup(lptstrAttachmentsTiff)))
            {
                rVal = IDS_OUT_OF_MEM; 
                goto error;
            }
        }
    }
    else    // the message contains body
    {
        if (lptstrAttachmentsTiff)  // the message contains attachments
        {
            // merges message and attachements
            if (!MergeTiffFiles( *lpptstrMessageFileName, lptstrAttachmentsTiff))
            {
                rVal = IDS_CANT_PRINT_BODY; 
                goto error;
            }
            // deletes attachements
            if(!DeleteFile(lptstrAttachmentsTiff))
            {
                VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
            }

            MemFree(lptstrAttachmentsTiff);
            lptstrAttachmentsTiff = NULL;
        }
    }

    return rVal;
error:
    if (lptstrAttachmentsTiff) 
    {
        if(!DeleteFile(lptstrAttachmentsTiff))
        {
            VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
        }
        
        MemFree(lptstrAttachmentsTiff);
        lptstrAttachmentsTiff = NULL;
    }
    if (*lpptstrMessageFileName) 
    {
        if(!DeleteFile(*lpptstrMessageFileName))
        {
            VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
        }
        
        MemFree(*lpptstrMessageFileName);
        *lpptstrMessageFileName = NULL;
    }

    return rVal;
}


DWORD
CXPLogon::SendFaxDocument(
    LPMESSAGE pMsgObj,
    LPSTREAM lpstmT,
    BOOL UseRichText,
    LPSPropValue pMsgProps,
    LPSRowSet pRecipRows,
    LPDWORD lpdwRecipientsLimit
    )

/*++

Routine Description:

    Prints an exchange message and attachments to the fax printer.

Arguments:

    pMsgObj     - Pointer to message object
    lpstmT      - Stream pointer for rich text.
    UseRichText - boolean value. TRUE if the message is in Rich format,
                                 FALSE - if this is a plain text
    pMsgProps   - Message properties (those that are defined in sptPropsForHeader)
    pRecipRows  - Properties of recipients
    lpdwRecipientsLimit - recieves the recipietns limit in case of failure. '0' means no limit

Return Value:

    Zero for success, otherwise error code.

--*/

{
    DWORD dwRetVal = 0;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter = NULL;
    DWORD ec = 0;
    HRESULT hResult = S_OK;
    EDITSTREAM es = {0};
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    ULONG PropMsgCount = 0;
    LPSPropValue pProps = NULL;
    LPSPropValue pPropsMsg = NULL;
    FAXXP_CONFIG FaxConfig = {0};
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {
                                                &NameIds[0], 
                                                &NameIds[1], 
                                                &NameIds[2], 
                                                &NameIds[3], 
                                                &NameIds[4], 
                                                &NameIds[5]};
    LPSPropTagArray MsgPropTags = NULL;
    HKEY  hKey = 0;
    DWORD RegSize = 0;
    DWORD RegType = 0;
    DWORD CountPrinters = 0;

    LPTSTR lptstrRecipientName   = NULL ;
    LPTSTR lptstrRecipientNumber = NULL ;
    LPTSTR lptstrRecName         = NULL ;
    LPTSTR lptstrRecFaxNumber    = NULL ;
    LPTSTR lptstrSubject         = NULL ;
    LPTSTR lptszServerName       = NULL;

    LPTSTR                  lptstrDocumentFileName = NULL;
    HANDLE                  FaxServer = NULL;
    FAX_COVERPAGE_INFO_EX   CovInfo = {0};
    FAX_PERSONAL_PROFILE    SenderProfile = {0};
    FAX_JOB_PARAM_EX        JobParamsEx = {0};      
    PFAX_PERSONAL_PROFILE   pRecipients = NULL;
    DWORDLONG               dwlParentJobId = 0;
    DWORDLONG*              lpdwlRecipientJobIds = NULL;
    BOOL                    bRslt = FALSE;
    LPSPropValue            pRecipProps = NULL; 
    DWORD                   dwRecipient = 0;

    TCHAR                   strCoverpageName[MAX_PATH] = {0};
    BOOL                    bServerBased = TRUE;
    DWORD                   dwRecipientNumber = 0;

    DWORD                   dwRights = 0;  //access rights of fax sender

    LPADRBOOK               lpAdrBook = NULL; 
    LPTSTR                  lpstrSenderSMTPAdr = NULL;//sender's SMTP adr, including "SMTP:" prefix
    LPTSTR                  lpstrSMTPPrefix = NULL;
    LPTSTR                  lpstrSenderAdr = NULL;//sender's SMTP adr. without prefix
    ULONG                   cValues = 0;
    ULONG                   ulObjType = NULL;
    LPMAILUSER              pMailUser = NULL;
    LPSPropValue            lpPropValue = NULL;
    ULONG                   i, j;
    BOOL                    bGotSenderAdr = FALSE;

    LPTSTR                  lptstrCPFullPath = NULL;
    LPTSTR                  lptstrCPName = NULL;
    DWORD                   dwError = 0;
    BOOL                    bResult = FALSE;
    DWORD                   dwReceiptsOptions = DRT_NONE;

    RECIPIENTS_SET          setRecip; // Recipients set used to remove the duplications

    SizedSPropTagArray(1, sptPropxyAddrProp) = {1, PR_EMS_AB_PROXY_ADDRESSES_A};
    DWORD dwRecipientsLimit = 0;

    DBG_ENTER(TEXT("CXPLogon::SendFaxDocument"), dwRetVal);    

    //
    // *****************************
    // get the fax config properties
    // *****************************
    //
    hResult = m_pSupObj->OpenProfileSection(
        &g_FaxGuid,
        MAPI_MODIFY,
        &pProfileObj
        );
    if (HR_FAILED (hResult)) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenProfileSection"), hResult);
        dwRetVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    hResult = pProfileObj->GetProps(
                (LPSPropTagArray) &sptFaxProps,
                0,
                &PropCount,
                &pProps
                );
    if ((FAILED(hResult))||(hResult == ResultFromScode(MAPI_W_ERRORS_RETURNED)) )
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetProps"), hResult);
        dwRetVal = IDS_INTERNAL_ERROR;
        goto exit;
    }
    
  
    FaxConfig.PrinterName = StringDup( (LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb );
    if(! FaxConfig.PrinterName)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    FaxConfig.CoverPageName = StringDup( (LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb );
    if(! FaxConfig.CoverPageName)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    FaxConfig.UseCoverPage = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig.ServerCoverPage = pProps[PROP_SERVER_COVERPAGE].Value.ul;
    CopyMemory( 
            &FaxConfig.FontStruct, 
            pProps[PROP_FONT].Value.bin.lpb, 
            pProps[PROP_FONT].Value.bin.cb 
            );
    FaxConfig.SendSingleReceipt= pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul;
    FaxConfig.bAttachFax = pProps[PROP_ATTACH_FAX].Value.ul;
    
    //
    // *************************************
    // now get the message config properties
    // *************************************
    // 
    NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

    NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

    NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

    NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].Kind.lpwstrName = MSGPS_FAX_SEND_SINGLE_RECEIPT;

    NameIds[MSGPI_FAX_ATTACH_FAX].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_ATTACH_FAX].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_ATTACH_FAX].Kind.lpwstrName = MSGPS_FAX_ATTACH_FAX;

    hResult = pMsgObj->GetIDsFromNames( (ULONG) NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
    if (HR_FAILED(hResult)) 
    {   
        if(hResult == MAPI_E_NOT_ENOUGH_MEMORY)
        {
            dwRetVal = IDS_OUT_OF_MEM;
        }
        else
        {
            dwRetVal = IDS_INTERNAL_ERROR;
        }
        CALL_FAIL (GENERAL_ERR, TEXT("GetIDsFromNames"), hResult);
        goto exit;
    }
    
    MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]));
    MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]));
    MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]));
    MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]));
    MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT]));
    MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX]));
    
    hResult = pMsgObj->GetProps( MsgPropTags, 0, &PropMsgCount, &pPropsMsg );
    if(hResult == ResultFromScode(MAPI_W_ERRORS_RETURNED))
    {
        VERBOSE (DBG_MSG, TEXT("GetProps in SendFaxDocument returned MAPI_W_ERRORS_RETURNED"));
    }
    
    if (FAILED(hResult)) 
    //
    // happens if user did not press ok on the "fax attributes" DlgBox - it's not an error!
    //
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetProps"), hResult);
        hResult = S_OK;
    }
    
    //
    //prefer the config props defined for the message (if they exist) on those defined for the fax.    
    //
    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_PRINTER_NAME].ulPropTag) != PT_ERROR) 
    {
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup((LPTSTR)pPropsMsg[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb);
        if(! FaxConfig.PrinterName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].ulPropTag) != PT_ERROR) 
    {
        MemFree( FaxConfig.CoverPageName);
        FaxConfig.CoverPageName = StringDup((LPTSTR)pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb);
        if(! FaxConfig.CoverPageName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_USE_COVERPAGE].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.UseCoverPage = pPropsMsg[MSGPI_FAX_USE_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.ServerCoverPage = pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.SendSingleReceipt = pPropsMsg[MSGPI_FAX_SEND_SINGLE_RECEIPT].Value.ul;
    }
     
    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_ATTACH_FAX].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.bAttachFax = pPropsMsg[MSGPI_FAX_ATTACH_FAX].Value.ul;
    }

    if (PROP_TYPE(pMsgProps[MSG_SUBJECT].ulPropTag) != PT_ERROR) 
    {
        lptstrSubject = ConvertAStringToTString(pMsgProps[MSG_SUBJECT].Value.lpszA);
        if(! lptstrSubject)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }

    //
    // ******************************************
    // open the printer, and create the tiff file
    // ******************************************
    //

    //
    // open the printer - first try to get info on the printer in FaxConfig, 
    // if you fail, search all the printers until the first fax printer is found.
    //

    PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
    if (NULL == PrinterInfo) 
    {
        // if the chosen printer is not accessable, try to locate another SharedFax printer 
        PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters );
        if (NULL != PrinterInfo) 
        {
            for (i=0; i<(int)CountPrinters; i++) 
            {
                if (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) 
                {
                    break;
                }
            }
        } 
        else 
        {
            CountPrinters = i = 0; //no printers were found
        }
        if (i == (int)CountPrinters) //if there are no printers, or none of them is a fax printer
        {
            dwRetVal = IDS_NO_FAX_PRINTER;
            goto exit;
        }

        // 
        // if a SharedFax printer was found, update it as the printer that we'll send the fax threw
        //
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup( PrinterInfo[i].pPrinterName );
        if(! FaxConfig.PrinterName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
        MemFree( PrinterInfo );

        PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
        if (NULL == PrinterInfo) 
        {
            dwRetVal = IDS_CANT_ACCESS_PRINTER; 
            goto exit;
        }
    }

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( FaxConfig.PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        dwRetVal = IDS_CANT_ACCESS_PRINTER;
        goto exit;
    }

    dwRetVal = PrintFaxDocumentToFile( pMsgObj,
                                       lpstmT,
                                       UseRichText,
                                       &FaxConfig ,
                                       lptstrSubject,
                                       &lptstrDocumentFileName);                                      
    if (IDS_EMPTY_MESSAGE == dwRetVal)
    {
        //
        // The message is empty. This is not really an error.
        //
        dwRetVal = 0;

        if(!FaxConfig.UseCoverPage)
        {
            //
            // If the message is empty and no cover page is specified there is
            // nothing more to do.
            //
            goto exit;
        }
    }

    if(dwRetVal)
    {
        goto exit;
    }
    
    VERBOSE (DBG_MSG, TEXT("Final Tiff is %s:"), lptstrDocumentFileName);

    //
    // **************************************
    // initializes sender and recipients info
    // **************************************
    //
    
    //
    // sender's info
    //
    SenderProfile.dwSizeOfStruct = sizeof(SenderProfile);
    hResult = FaxGetSenderInformation(&SenderProfile);
    if(S_OK != hResult)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FaxGetSenderInformation"), hResult);
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hResult) 
        {
            dwRetVal = IDS_INTERNAL_ERROR;
        }
        else if (HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) == hResult )
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }    
         
    //
    // recipients' info
    // pRecipRows includes rows coresponding only to recipients that their PR_RESPONSIBILITY == FALSE
    // 
    dwRecipientNumber = pRecipRows->cRows;
    pRecipients = (PFAX_PERSONAL_PROFILE)MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * dwRecipientNumber);
    if(! pRecipients)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    ZeroMemory(pRecipients, sizeof(FAX_PERSONAL_PROFILE) * dwRecipientNumber);
           
    dwRecipient = 0;    
    for (DWORD dwRecipRow=0; dwRecipRow < pRecipRows->cRows ; ++dwRecipRow) 
    {
        pRecipProps = pRecipRows->aRow[dwRecipRow].lpProps;

        lptstrRecipientName = ConvertAStringToTString(pRecipProps[RECIP_NAME].Value.lpszA);
        if(! lptstrRecipientName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        lptstrRecipientNumber = ConvertAStringToTString(pRecipProps[RECIP_EMAIL_ADR].Value.lpszA);
        if(! lptstrRecipientNumber)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(_tcsstr(lptstrRecipientName, lptstrRecipientNumber))
        {
            //
            // PR_EMAIL_ADDRESS_A is substring of PR_DISPLAY_NAME_A
            // so we suppose that PR_DISPLAY_NAME_A was not specified.
            // Try to get the recipient name from PR_EMAIL_ADDRESS_A
            //
            MemFree( lptstrRecipientName );
            lptstrRecipientName = NULL;    
        }

        //
        // finds a fax number from the name string, 
        // e.g. "Fax Number@+14 (2) 324324" --> +14 (2) 324324)
        //
        LPTSTR pRecipientNumber = _tcschr(lptstrRecipientNumber, '@');
        if (pRecipientNumber)
        {
            //
            //if there was a @, increment the pointer to point to the next char after it. 
            //
            *pRecipientNumber = '\0';
            pRecipientNumber = _tcsinc(pRecipientNumber);

            if(!lptstrRecipientName)
            {
                lptstrRecipientName = StringDup(lptstrRecipientNumber);
                if(! lptstrRecipientName)
                {
                    dwRetVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }
        }
        else
        {
            //
            //if there's no @ in the string, it's OK as it was.
            //
            pRecipientNumber = lptstrRecipientNumber;
        }
            
        //
        // initializes recipient info
        //
        pRecipients[dwRecipient].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        
        pRecipients[dwRecipient].lptstrFaxNumber    = StringDup(pRecipientNumber);
        if(! pRecipients[dwRecipient].lptstrFaxNumber)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(lptstrRecipientName)
        {
            pRecipients[dwRecipient].lptstrName = StringDup(lptstrRecipientName);
            if(! pRecipients[dwRecipient].lptstrName)
            {
                dwRetVal = IDS_OUT_OF_MEM;
                goto exit;
            }
        }
        
        __try
        {
            //
            // Insert all the recipients into a set.
            // If there are any duplications insert() failes
            //
            if(setRecip.insert(&pRecipients[dwRecipient]).second == true)
            {
                ++dwRecipient;
            }
            else
            {
                //
                // Such recipients already exists
                //
                MemFree(pRecipients[dwRecipient].lptstrName);
                pRecipients[dwRecipient].lptstrName = NULL;
                MemFree(pRecipients[dwRecipient].lptstrFaxNumber);
                pRecipients[dwRecipient].lptstrFaxNumber = NULL;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(lptstrRecipientName)
        {
            MemFree( lptstrRecipientName );
            lptstrRecipientName = NULL;    
        }

        if(lptstrRecipientNumber)
        {
            MemFree( lptstrRecipientNumber );
            lptstrRecipientNumber = NULL;
        }       
    } // for

    //
    // Update the recipient number to the actual size without duplications
    //
    dwRecipientNumber = dwRecipient;

    //
    // *******************
    // get cover page info
    // *******************
    //
    if (FaxConfig.UseCoverPage)
    {
        bServerBased = FaxConfig.ServerCoverPage;
        if(bServerBased)
        {
            _tcscpy(strCoverpageName,FaxConfig.CoverPageName);
        }
        else
        {
            //
            // this is a personal CP, we have to add to it's name the full UNC path
            //
            TCHAR   CpDir[MAX_PATH] = {0};
            TCHAR*  pCpName = NULL;

            bResult = GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0]));
            if(! bResult) 
            {
                CALL_FAIL(GENERAL_ERR, TEXT("GetClientCpDir"), ::GetLastError());
                dwRetVal = IDS_INTERNAL_ERROR;
                goto exit;
            }

            _tcscat(CpDir,FaxConfig.CoverPageName);
            
            if((_tcslen(CpDir)/sizeof(TCHAR) + _tcslen(FAX_COVER_PAGE_FILENAME_EXT)/sizeof(TCHAR) + 1) > MAX_PATH)
            {
                dwRetVal = IDS_INTERNAL_ERROR;
                goto exit;
            }
            _tcscat(CpDir, FAX_COVER_PAGE_FILENAME_EXT);
            _tcscpy(strCoverpageName, CpDir);

        }
        VERBOSE (DBG_MSG, TEXT("Sending Fax with Coverpage: %s"), strCoverpageName);

        //
        // initializes a cover page info
        //
        CovInfo.dwSizeOfStruct          = sizeof( FAX_COVERPAGE_INFO_EX);
        CovInfo.dwCoverPageFormat       = FAX_COVERPAGE_FMT_COV;
        CovInfo.lptstrCoverPageFileName = strCoverpageName; 
        //if it's not a server's CP, should include exact path to the CP file
        CovInfo.bServerBased            = bServerBased ;
        CovInfo.lptstrNote              = NULL;
        CovInfo.lptstrSubject           = lptstrSubject;
    }
    else
    {
        //
        // no cover page
        //
        CovInfo.dwSizeOfStruct          = sizeof( FAX_COVERPAGE_INFO_EX);
        CovInfo.dwCoverPageFormat       = FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY;
        CovInfo.lptstrSubject           = lptstrSubject;
    }


    // 
    // *************************
    // connect to the fax server
    // *************************
    //

    if (!GetServerNameFromPrinterInfo(PrinterInfo ,&lptszServerName ) ||
        !FaxConnectFaxServer(lptszServerName,&FaxServer))   
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError());
        dwRetVal = IDS_CANT_ACCESS_SERVER;
        goto exit;
    }
    
    VERBOSE (DBG_MSG, TEXT("Connected to Fax Server: %s"), lptszServerName);

    // 
    // *****************************
    // initialize the job parameters
    // *****************************
    //
    JobParamsEx.dwSizeOfStruct = sizeof( FAX_JOB_PARAM_EX);
    VERBOSE (DBG_MSG, TEXT("******************JobParamsEx:***********************"));

    //
    // get the sender's SMTP address
    // pMsgProps hold PropsForHeader properties, including PR_SENDER_ENTRYID
    //
        
    hResult = m_pSupObj->OpenAddressBook(NULL, 0, &lpAdrBook);
    if (FAILED(hResult))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenAddressBook"), ::GetLastError());
    }

    else
    {  
        hResult = lpAdrBook->OpenEntry(
                pMsgProps[MSG_SENDER_ENTRYID].Value.bin.cb, 
                (LPENTRYID)pMsgProps[MSG_SENDER_ENTRYID].Value.bin.lpb, 
                NULL, 
                0, 
                &ulObjType, 
                (LPUNKNOWN*)&pMailUser
                );
        if (FAILED(hResult))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("OpenEntry"), ::GetLastError());
        }
        else
        {
            hResult = pMailUser->GetProps(
                    (LPSPropTagArray)&sptPropxyAddrProp, 
                    0, 
                    &cValues, 
                    &lpPropValue
                    );
            if (!HR_SUCCEEDED(hResult) ||
                PT_ERROR == PROP_TYPE(lpPropValue->ulPropTag))
            {
                //
                // We either failed to get the property or the property retrieved has some error.
                // If we're unable to locate sender's address, we won't be sending a Delivry Receipt,
                // but we won't fail the sending.
                //
                CALL_FAIL (GENERAL_ERR, TEXT("GetProps from MailUser failed, no receipt will be sent!"), hResult);
            }         
            else
            {
                //
                //loop through the proxy multivalue property
                //
                for(j=0;j<lpPropValue->Value.MVszA.cValues; j++)
                {
                    lpstrSenderSMTPAdr = ConvertAStringToTString(lpPropValue->Value.MVszA.lppszA[j]);
                    if(! lpstrSenderSMTPAdr)
                    {
                        dwRetVal = IDS_OUT_OF_MEM;
                        goto exit;
                    }
                    //
                    // check if address begins with "SMTP:":
                    // function returns pointer to begining of second param.'s appearance in first param.
                    // if it does not appear, returns NULL
                    //
                    lpstrSMTPPrefix = _tcsstr(lpstrSenderSMTPAdr, TEXT("SMTP:"));
                    if( lpstrSenderSMTPAdr == lpstrSMTPPrefix) 
                    {
                        //
                        // Remove this prefix from it, and store it in JobParamsEx.
                        //
                        lpstrSenderAdr = lpstrSenderSMTPAdr + _tcslen(TEXT("SMTP:"));
                        JobParamsEx.lptstrReceiptDeliveryAddress = _tcsdup(lpstrSenderAdr);
                        if(! JobParamsEx.lptstrReceiptDeliveryAddress)
                        {
                            dwRetVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                        bGotSenderAdr = TRUE;
                        VERBOSE(DBG_MSG, TEXT("Receipt delivery address is %s"), JobParamsEx.lptstrReceiptDeliveryAddress);
                        break;
                    }
                }
            }
        }
    }

    //
    // when to send, sort of delivery receipt
    //
    JobParamsEx.dwScheduleAction = JSA_NOW; 

    if(!FaxGetReceiptsOptions(FaxServer, &dwReceiptsOptions))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("FaxGetReceiptsOptions"), ::GetLastError());
    }

    JobParamsEx.dwReceiptDeliveryType = DRT_NONE;
    if (bGotSenderAdr && (dwReceiptsOptions & DRT_EMAIL))
    {
        if (TRUE == FaxConfig.SendSingleReceipt)
        {
            JobParamsEx.dwReceiptDeliveryType = DRT_EMAIL | DRT_GRP_PARENT;
        }
        else
        {
            JobParamsEx.dwReceiptDeliveryType = DRT_EMAIL;
        }      
        if (FaxConfig.bAttachFax)
        {
            JobParamsEx.dwReceiptDeliveryType |= DRT_ATTACH_FAX;
        }
    }
    VERBOSE(DBG_MSG, TEXT("Receipt Delivery Type = %ld"), JobParamsEx.dwReceiptDeliveryType);

    //
    // priority
    //
    if (pMsgProps[MSG_IMPORTANCE].ulPropTag == PR_IMPORTANCE)
    {
        if(FALSE == (FaxAccessCheckEx(FaxServer, MAXIMUM_ALLOWED, &dwRights)))
        {
            if((hResult = ::GetLastError()) != ERROR_SUCCESS)
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxAccessCheckEx"), hResult);
                dwRetVal = IDS_CANT_ACCESS_PROFILE;
                goto exit;
            }        
        }
        //
        //try to give the sender the prio he asked for. if it's not allowed, try a lower prio. 
        //
        switch(pMsgProps[MSG_IMPORTANCE].Value.l)
        {
            case (IMPORTANCE_HIGH):
                if ((FAX_ACCESS_SUBMIT_HIGH & dwRights) == FAX_ACCESS_SUBMIT_HIGH)
                {                
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_HIGH;
                    break;
                }
                //fall through
            case (IMPORTANCE_NORMAL):
                if ((FAX_ACCESS_SUBMIT_NORMAL & dwRights) == FAX_ACCESS_SUBMIT_NORMAL)
                {
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_NORMAL;
                    break;
                }
                //fall through
            case (IMPORTANCE_LOW):
                if ((FAX_ACCESS_SUBMIT & dwRights) == FAX_ACCESS_SUBMIT)
                {
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_LOW;     
                }
                else
                {
                    VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: user has no access rights!"));    
                    //the user has no right to submit faxes, at any priority!
                    dwRetVal = IDS_NO_SUBMIT_RITHTS;
                    goto exit;
                }
                break;
            default: 
                VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: message importance has undefined value"));
                ASSERTION_FAILURE
        }
    }
    else 
    {
       VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: Message had no importance property value!"));
       dwRetVal = IDS_INTERNAL_ERROR;
       ASSERTION_FAILURE;
       goto exit;
    }
    VERBOSE(DBG_MSG, TEXT("Message Priority is %ld (0=low, 1=normal, 2=high)"), JobParamsEx.Priority );
    
    //
    // doc name, number of pages, 
    //     
    TCHAR DocName[64];
    LoadString(g_hResource, IDS_MESSAGE_DOC_NAME, DocName, sizeof(DocName) / sizeof (DocName[0]));
    JobParamsEx.lptstrDocumentName = DocName;
    JobParamsEx.dwPageCount = 0; //means the server will count the number of pages in the job

    lpdwlRecipientJobIds = (DWORDLONG*)MemAlloc(sizeof(DWORDLONG)*dwRecipientNumber);
    if(! lpdwlRecipientJobIds)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }

    //
    // ************
    // Send the fax
    // ************
    //
    bRslt= FaxSendDocumentEx(
                                FaxServer,
                                (LPCTSTR) lptstrDocumentFileName,
                                &CovInfo,
                                &SenderProfile,
                                dwRecipientNumber,
                                pRecipients,
                                &JobParamsEx,
                                &dwlParentJobId,
                                lpdwlRecipientJobIds
                            );

    if (!bRslt)
    {
        hResult = ::GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("FaxSendDocumentEx"), hResult);
        // maybe we should swich possible retruned values from SendFaxDocEx, 
        // and choose a more informative IDS
        switch(hResult)
        {
            case ERROR_NOT_ENOUGH_MEMORY:
                                    dwRetVal = IDS_OUT_OF_MEM;
                                    break;
            case ERROR_NO_SYSTEM_RESOURCES:
                                    dwRetVal = IDS_INTERNAL_ERROR;
                                    break;
            case ERROR_CANT_ACCESS_FILE:
                                    dwRetVal = IDS_PERSONAL_CP_FORBIDDEN;
                                    break;     
            case ERROR_BAD_FORMAT:
                                    dwRetVal = IDS_BAD_CANNONICAL_ADDRESS;
                                    break;  
            case FAX_ERR_RECIPIENTS_LIMIT:          
                                    dwRetVal = IDS_RECIPIENTS_LIMIT;
                                    if (!FaxGetRecipientsLimit(FaxServer, &dwRecipientsLimit))
                                    {
                                        CALL_FAIL (GENERAL_ERR, TEXT("FaxGetRecipientsLimit"), ::GetLastError());
                                    }   
                                    break;     
            default:        
                                    dwRetVal = IDS_CANT_PRINT;
                                    break;
        }
        goto exit;
    }

    FaxClose(FaxServer);
    FaxServer = NULL;

    dwRetVal = 0;

exit:
    if(lpAdrBook)
    {
        lpAdrBook->Release();
    }
    if(pMailUser)
    {
        pMailUser->Release();
    }

    if (FaxServer) 
    {
        FaxClose(FaxServer);
    }

    if (pRecipients) 
    {
        for (dwRecipient=0; dwRecipient<dwRecipientNumber ; dwRecipient++) 
        {
            if (pRecipients[dwRecipient].lptstrName)
            {
                MemFree (pRecipients[dwRecipient].lptstrName);
            }

            if (pRecipients[dwRecipient].lptstrFaxNumber)
            {
                MemFree(pRecipients[dwRecipient].lptstrFaxNumber);
            }
        }
        MemFree(pRecipients);
        pRecipients = NULL;
    }

    if (pProfileObj) 
    {
        pProfileObj->Release();
    }
    if (pProps) 
    {
        MAPIFreeBuffer( pProps );
    }
    if (MsgPropTags) 
    {
        MAPIFreeBuffer( MsgPropTags );
    }
    if (pPropsMsg) 
    {
        MAPIFreeBuffer( pPropsMsg );
    }
    if (hPrinter) 
    {
        ClosePrinter( hPrinter );
    }
    if (PrinterInfo) 
    {
        MemFree( PrinterInfo );
    }
    if (FaxConfig.PrinterName) 
    {
        MemFree( FaxConfig.PrinterName );
    }
    if (FaxConfig.CoverPageName) 
    {
        MemFree( FaxConfig.CoverPageName );
    }
    if (lptstrRecipientName) 
    {
        MemFree(lptstrRecipientName);
    }
    if (lptstrRecipientNumber) 
    {
        MemFree(lptstrRecipientNumber);
    }
    if (lptstrRecName) 
    {
        MemFree(lptstrRecName);
    }
    if (lptstrRecFaxNumber) 
    {
        MemFree(lptstrRecFaxNumber);
    }
    if (lptstrSubject) 
    {
        MemFree(lptstrSubject);
    }
    if (lptstrDocumentFileName) 
    {
        DeleteFile(lptstrDocumentFileName);
        MemFree(lptstrDocumentFileName);
    }

    if (lpdwlRecipientJobIds) 
    {
        MemFree(lpdwlRecipientJobIds);
    }
    if (lptszServerName)
    {
        MemFree(lptszServerName);
    }

    FaxFreeSenderInformation(&SenderProfile);

    *lpdwRecipientsLimit = dwRecipientsLimit;

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\faxxp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.h

Abstract:

    Fax transport provider header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Change GetServerName to GetServerNameFromPrinterName.
        Add GetServerNameFromPrinterInfo.

    dd/mm/yy -author-
        description

--*/

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <tchar.h>
#include <stdio.h>
#include <fxsapip.h>

#include "resource.h"
#include "faxreg.h"
#include "faxmapip.h"
#include "faxutil.h"
#include "devmode.h"


#define MAX_FILENAME_EXT                    4

#define SERVER_COVER_PAGE                   1   

#define TRANSPORT_DLL_NAME_STRING           FAX_MAIL_TRANSPORT_MODULE_NAME

#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|

#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)

#define XPID_NAME                           0
#define XPID_EID                            1
#define XPID_SEARCH_KEY                     2
#define NUM_IDENTITY_PROPS                  3

#define RECIP_ROWID                         0
#define RECIP_NAME                          1
#define RECIP_EMAIL_ADR                     2
#define RECIP_TYPE                          3
#define RECIP_RESPONSIBILITY                4
#define RECIP_DELIVER_TIME                  5
#define RECIP_REPORT_TIME                   6
#define RECIP_REPORT_TEXT                   7
#define RECIP_ADDR_TYPE                     8
#define TABLE_RECIP_PROPS                   9

#define MSG_DISP_TO                         0
#define MSG_SUBJECT                         1
#define MSG_CLASS                           2
#define MSG_BODY                            3
#define MSG_FLAGS                           4
#define MSG_SIZE                            5
#define MSG_PRIORITY                        6
#define MSG_IMPORTANCE                      7
#define MSG_SENSITIVITY                     8
#define MSG_DR_REPORT                       9
#define MSG_SENDER_ENTRYID                 10
#define NUM_MSG_PROPS                      11

#define MSG_ATTACH_METHOD                   0
#define MSG_ATTACH_NUM                      1
#define MSG_ATTACH_EXTENSION                2
#define MSG_ATTACH_FILENAME                 3
#define MSG_ATTACH_PATHNAME                 4
#define MSG_ATTACH_LFILENAME                5
#define MSG_ATTACH_TAG                      6
#define NUM_ATTACH_PROPS                    7
#define NUM_ATTACH_TABLE_PROPS              2


typedef struct _USER_INFO {
    TCHAR BillingCode[64];
    TCHAR Company[128];
    TCHAR Dept[128];
} USER_INFO, *PUSER_INFO;


const static SizedSPropTagArray ( NUM_ATTACH_TABLE_PROPS, sptAttachTableProps) =
{
    NUM_ATTACH_TABLE_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM
    }
};

const static SizedSPropTagArray ( NUM_ATTACH_PROPS, sptAttachProps) =
{
    NUM_ATTACH_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_EXTENSION_A,
        PR_ATTACH_FILENAME_A,
        PR_ATTACH_PATHNAME_A,
        PR_ATTACH_LONG_FILENAME_A,
        PR_ATTACH_TAG
    }
};

const static SizedSPropTagArray (TABLE_RECIP_PROPS, sptRecipTable) =
{
    TABLE_RECIP_PROPS,
    {
        PR_ROWID,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_RECIPIENT_TYPE,
        PR_RESPONSIBILITY,
        PR_DELIVER_TIME,
        PR_REPORT_TIME,
        PR_REPORT_TEXT_A,
        PR_ADDRTYPE_A
    }
};

static const SizedSPropTagArray(NUM_MSG_PROPS, sptPropsForHeader) =
{
    NUM_MSG_PROPS,
    {
        PR_DISPLAY_TO_A,
        PR_SUBJECT_A,
        PR_BODY_A,
        PR_MESSAGE_CLASS_A,
        PR_MESSAGE_FLAGS,
        PR_MESSAGE_SIZE,
        PR_PRIORITY,
        PR_IMPORTANCE,
        PR_SENSITIVITY,
        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED,
        PR_SENDER_ENTRYID
    }
};

extern LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
extern LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
extern LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
extern HINSTANCE           g_hModule;           // DLL handle
extern HINSTANCE           g_hResource;         // Resource DLL handle
extern MAPIUID             g_FaxGuid;


LPVOID
MapiMemAlloc(
    SIZE_T Size
    );

LPVOID
MapiMemReAlloc(
    LPVOID ptr,
    SIZE_T Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters
    );

PVOID
MyGetPrinter(
    LPTSTR  PrinterName,
    DWORD   level
    );

void
ErrorMsgBox(
    HINSTANCE hInstance,
    DWORD     dwMsgId
);

/*
 -  GetServerNameFromPrinterInfo
 -
 *  Purpose:
 *      Get the Server name, given a PRINTER_INFO_2 structure
 *
 *  Arguments:
 *      [in] ppi2 - Address of PRINTER_INFO_2 structure
 *      [out] lpptszServerName - Address of string pointer for returned name.
 *
 *  Returns:
 *      BOOL - TRUE: sucess , FALSE: failure.
 *
 *  Remarks:
 *      This inline function retrieves the server from a printer info structure
 *      in the appropriate way for win9x and NT. 
 */
inline BOOL 
GetServerNameFromPrinterInfo(PPRINTER_INFO_2 ppi2,LPTSTR *lpptszServerName)
{   
    if (!ppi2)
    {
        return FALSE;
    }
#ifndef WIN95

    *lpptszServerName = NULL;
    if (ppi2->pServerName)
    {
        if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pServerName,2))))
        {
            return FALSE;
        }
    }
    return TRUE;

#else //WIN95
    
    //
    // Formatted: \\Server\port
    //
    if (!(ppi2->pPortName))
    {
        return FALSE;
    }
    if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pPortName,2))))
    {
        return FALSE;
    }
    _tcstok(*lpptszServerName,TEXT("\\"));

#endif //WIN95

    return TRUE;
}


BOOL
GetServerNameFromPrinterName(
    LPTSTR PrinterName,
    LPTSTR *ppszServerName
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    );

DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    LPVOID Buffer,
    DWORD SizeOfBuffer
    );



class CXPProvider : public IXPProvider
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    MAPI_IXPPROVIDER_METHODS(IMPL);

public :
    CXPProvider( HINSTANCE hInst );
    ~CXPProvider();

private :
    ULONG               m_cRef;
    CRITICAL_SECTION    m_csTransport;
    HINSTANCE           m_hInstance;
};


class CXPLogon : public IXPLogon
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP InitializeStatusRow(ULONG ulFlags);
    STDMETHODIMP GrowAddressList(LPADRLIST *ppAdrList, ULONG ulResizeBy, ULONG *pulOldAndNewCount);
    MAPI_IXPLOGON_METHODS(IMPL);

private:
    void WINAPI CheckSpoolerYield( BOOL fReset = FALSE );
    void WINAPI UpdateStatus( BOOL fAddValidate=FALSE, BOOL fValidateOkState=FALSE );
    BOOL WINAPI LoadStatusString( LPTSTR pString, UINT uStringSize );
    DWORD SendFaxDocument(LPMESSAGE pMsgObj,LPSTREAM lpstmT,BOOL UseRichText,LPSPropValue pMsgProps,LPSRowSet pRecipRows, LPDWORD lpdwRecipientsLimit);
    PVOID MyGetPrinter(LPTSTR PrinterName,DWORD Level);

    DWORD PrintAttachmentToFile(IN  LPMESSAGE      pMsgObj,
                                IN  PFAXXP_CONFIG  pFaxConfig,
                                OUT LPTSTR*        lpptstrOutAttachments);

    BOOL  PrintRichText(HWND hWndRichEdit,HDC hDC);
    DWORD PrintPlainText(HDC hDC,LPSTREAM lpstmT,LPTSTR tszSubject, PFAXXP_CONFIG FaxConfig);

    DWORD PrintFaxDocumentToFile(
	   IN  LPMESSAGE        pMsgObj,
	   IN  LPSTREAM         lpstmT,
	   IN  BOOL             UseRichText,
	   IN  PFAXXP_CONFIG    pFaxConfig, 
           IN  LPTSTR           tszSubject,
	   OUT LPTSTR*          lpptstrMessageFileName
	   );

    DWORD PrintMessageToFile(IN LPSTREAM         lpstmT,
                             IN BOOL             UseRichText,
                             IN PFAXXP_CONFIG    pFaxConfig,
                             IN  LPTSTR          tszSubject,
                             OUT LPTSTR*         lpptstrOutDocument);


public :
    CXPLogon( HINSTANCE hInstance, LPMAPISUP pSupObj, LPTSTR ProfileName );
    ~CXPLogon();

    inline void WINAPI AddStatusBits
                    (DWORD dwNewBits) { m_ulTransportStatus |= dwNewBits; }
    inline void WINAPI RemoveStatusBits
                    (DWORD dwOldBits) { m_ulTransportStatus &= ~dwOldBits; }
    inline DWORD WINAPI GetTransportStatusCode
                    () { return m_ulTransportStatus; }

private :
    ULONG               m_cRef;
    HINSTANCE           m_hInstance;
    BOOL                m_fABWDSInstalled;
    ULONG               m_ulTransportStatus;
    LPWSTR              m_CpBuffer;
    DWORD               m_CpBufferSize;

public :
    LPMAPISUP           m_pSupObj;
    HANDLE              m_hUIMutex;
    HRESULT             m_hRemoteActionErr;
    BOOL                m_fCancelPending;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix GetServerName as GetServerNameFromPrinterName.

    dd-mm-yy -author-
        description

--*/

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop


//
// globals
//

BOOL oleInitialized;



LPVOID
MapiMemAlloc(
    SIZE_T Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr=NULL;
    HRESULT hResult;

	// [Win64bug] gpfnAllocateBuffer should accpet size_t as allocating size
    hResult = gpfnAllocateBuffer( DWORD(Size), &ptr );
    if (S_OK == hResult) 
    {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}


LPVOID
MapiMemReAlloc(
	LPVOID ptr,
    SIZE_T Size
    )

/*++

Routine Description:

    Memory re-allocator.

Arguments:
	ptr		- pre-allocated buffer
    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID NewPtr = NULL;
    HRESULT hResult;

	// [Win64bug] gpfnAllocateBuffer should accpet size_t as allocating size
    hResult = gpfnAllocateMore( DWORD(Size), ptr, &NewPtr );
    if (S_OK == hResult) 
    {
        ZeroMemory( NewPtr, Size );
    }
    return NewPtr;
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) 
    {
        gpfnFreeBuffer( ptr );
    }
}

PVOID
MyEnumPrinters(
    LPTSTR   pServerName,
    DWORD   level,
    OUT PDWORD  pcPrinters
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
	DBG_ENTER(TEXT("MyEnumPrinters"));

    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;
    // first, we give no printer information buffer, so the function fails, but returns 
    // in cb the number of bytes needed. then we allocate enough memory, 
    // and call the function again, this time with all of the needed parameters.

    if (! EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                       pServerName,
                       level,
                       NULL,
                       0,
                       &cb,
                       pcPrinters)                         //the call failed
        && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) //this is the reason for failing
        && (pPrinterInfo = (PBYTE)MemAlloc(cb))            //we managed to allocate more memory
        && EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                     pServerName,
                     level,
                     pPrinterInfo,
                     cb,
                     &cb,
                     pcPrinters))                       //and now the call succeded
    {
        return pPrinterInfo;
    }

    MemFree(pPrinterInfo);
    return NULL;
}


HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    )

/*++

Routine Description:

    This function opens the profile section of this service, where the
    properties of a FAX provider (AB, MS, or XP) are stored.

Arguments:

    pSupObj         - Pointer to the provider support object
    ppProfSectObj   - Where we return a pointer to the service profile
                      section of the provider

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult;
	DBG_ENTER(TEXT("OpenServiceProfileSection"),hResult);

    SPropTagArray sptService = { 1, { PR_SERVICE_UID } };
    LPPROFSECT pProvProfSectObj;
    ULONG cValues;
    LPSPropValue pProp;
    

    //
    // Get the PROVIDER profile section
    //
    hResult = pSupObj->OpenProfileSection(
        NULL,
        MAPI_MODIFY,
        &pProvProfSectObj
        );
    if (SUCCEEDED(hResult)) 
    {
        // Get the UID of the profile section of the service where this provider is installed
        hResult = pProvProfSectObj->GetProps (&sptService, FALSE, &cValues, &pProp);
        if (SUCCEEDED(hResult)) 
        {
            if (S_OK == hResult) 
            {
                // Now, with the obtained UID, open the profile section of the service
                hResult = pSupObj->OpenProfileSection ((LPMAPIUID)pProp->Value.bin.lpb,
                                                       MAPI_MODIFY,
                                                       ppProfSectObj);
            } 
            else 
            {
                hResult = E_FAIL;
            }
            MemFree( pProp ); 
        }
        pProvProfSectObj->Release();
    }
    return hResult;
}


LPTSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
	LPTSTR Pstr = NULL;

    if (Path == NULL || Path[0] == 0) 
	{
        return Path;
    }

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr && (*_tcsinc(Pstr)) == '\0' )
	{
		// the last character is a backslash, truncate it...
		_tcsset(Pstr,TEXT('\0'));
		Pstr = _tcsdec(Path,Pstr);
	}

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr )
	{
		_tcsnset(_tcsinc(Pstr),TEXT('\0'),1);
	}

    return Path;
}


PDEVMODE
GetPerUserDevmode(
    LPTSTR PrinterName
    )
{
    PDEVMODE DevMode = NULL;
    LONG Size;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), ::GetLastError() ));
        return NULL;
    }

    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            NULL,
                            NULL,
                            0
                            );

    if (Size < 0) 
    {
        goto exit;
    }
    
    DevMode = (PDEVMODE) MemAlloc( Size );

    if (DevMode == NULL) 
    {
        goto exit;
    }
    
    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            DevMode,
                            NULL,
                            DM_OUT_BUFFER
                            );

    if (Size < 0) 
    {
        MemFree( DevMode );
        DevMode = NULL;
        goto exit;
    }


exit:
    
    ClosePrinter( hPrinter );
    return DevMode;
}



DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) 
    {
        return 0;
    }

    return pProps[PropId].Value.ul;
}


DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    OUT LPVOID Buffer,
    DWORD SizeOfBuffer
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) 
    {
        return 0;
    }

    if (pProps[PropId].Value.bin.cb > SizeOfBuffer) 
    {
        return 0;
    }

    CopyMemory( Buffer, pProps[PropId].Value.bin.lpb, pProps[PropId].Value.bin.cb );

    return pProps[PropId].Value.bin.cb;
}


PVOID
MyGetPrinter(
    LPTSTR   PrinterName,
    DWORD    level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
	DBG_ENTER(TEXT("MyGetPrinter"));

    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenPrinter"), ::GetLastError());
		return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        ::GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}


BOOL
GetServerNameFromPrinterName(
    LPTSTR lptszPrinterName,
    LPTSTR *pptszServerName
    )

/*++

Routine Description:

    retrieve the server name given a printer name

Arguments:

    [in] lptszPrinterName - Identifies the printer in question
    [out] lptszServerName - Address of pointer to output string buffer. 
                            NULL indicates local server.
                            The caller is responsible to free the buffer which 
                            pointer is given in this parameter.

Return Value:

    BOOL: TRUE - operation succeeded , FALSE: failed

--*/
{
	BOOL    bRes = FALSE;
	DBG_ENTER(TEXT("GetServerNameFromPrinterName"),bRes);

    PPRINTER_INFO_2 ppi2 = NULL;
    LPTSTR  lptstrBuffer = NULL;
    
    if (lptszPrinterName) 
    {
        if (ppi2 = (PPRINTER_INFO_2) MyGetPrinter(lptszPrinterName,2))
        {
            bRes = GetServerNameFromPrinterInfo(ppi2,&lptstrBuffer);
            MemFree(ppi2);
            if (bRes)
            {
                *pptszServerName = lptstrBuffer;
            }
        }
    }
    return bRes;
}

LPTSTR
ConvertAStringToTString(LPCSTR lpcstrSource)
{
	LPTSTR lptstrDestination;

	if (!lpcstrSource)
		return NULL;

#ifdef	UNICODE
    lptstrDestination = AnsiStringToUnicodeString( lpcstrSource );
#else	// !UNICODE
	lptstrDestination = StringDup( lpcstrSource );
#endif	// UNICODE
	
	return lptstrDestination;
}

LPSTR
ConvertTStringToAString(LPCTSTR lpctstrSource)
{
	LPSTR lpstrDestination;

	if (!lpctstrSource)
		return NULL;

#ifdef	UNICODE
    lpstrDestination = UnicodeStringToAnsiString( lpctstrSource );
#else	// !UNICODE
	lpstrDestination = StringDup( lpctstrSource );
#endif	// UNICODE
	
	return lpstrDestination;
}

void
ErrorMsgBox(
    HINSTANCE hInstance,
    DWORD     dwMsgId
)
/*++

Routine Description:

    Display error message box

Arguments:

    hInstance  - [in] resource instance handle
    dwMsgId    - [in] string resource ID

Return Value:

    none

--*/
{
    TCHAR* ptCaption=NULL;
    TCHAR  tszCaption[MAX_PATH];
    TCHAR  tszMessage[MAX_PATH];

    DBG_ENTER(TEXT("ErrorMsgBox"));

    if(!LoadString( hInstance, IDS_FAX_MESSAGE, tszCaption, sizeof(tszCaption) / sizeof(tszCaption[0])))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
    }
    else
    {
        ptCaption = tszCaption;
    }

    if(!LoadString( hInstance, dwMsgId, tszMessage, sizeof(tszMessage) / sizeof(tszMessage[0])))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
        Assert(FALSE);
        return;
    }

    MessageBeep(MB_ICONEXCLAMATION);
    AlignedMessageBox(NULL, tszMessage, ptCaption, MB_OK | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXXP32)
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
DLLDEF=..\faxxp32.def

DLLENTRY=_DllMainCRTStartup
USE_CRTDLL=1
USE_STL=1

INCLUDES=\
  $(INCLUDES); \
  $(FAXROOT)\print\faxprint\inc; \
  $(FAXROOT)\exchange\inc;

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
  $(FAXLIB)\*\faxtiffp.lib		\
  $(FAXLIB)\*\faxrend.lib		\
  $(FAXROOT)\util\debugex\unicode\$(O)\debugex.lib \
  $(SDK_LIB_PATH)\mapi32.lib \
  $(SDK_LIB_PATH)\version.lib

!else
LINKLIBS_INT=\
  $(FAXLIB95)\*\faxtiffp.lib		\
  $(FAXLIB95)\*\faxrend.lib			\
  $(FAXROOT)\util\debugex\ansii\$(O)\debugex.lib   \
  $(SDK_LIB_PATH)\mapi32.lib
!endif

TARGETLIBS=\
  $(SDK_LIB_PATH)\kernel32.lib    \
  $(SDK_LIB_PATH)\advapi32.lib    \
  $(SDK_LIB_PATH)\uuid.lib        \
  $(SDK_LIB_PATH)\winspool.lib    \
  $(SDK_LIB_PATH)\gdi32.lib       \
  $(SDK_LIB_PATH)\user32.lib      \
  $(SDK_LIB_PATH)\ole32.lib       \
  $(SDK_LIB_PATH)\shell32.lib     \
  $(SDK_LIB_PATH)\mapi32.lib      \
  $(SDK_LIB_PATH)\comdlg32.lib    \
  $(FAXLIB)\*\$(WINFAX).lib                   \
  $(LINKLIBS_INT)

SOURCES=\
  ..\config.cpp  \
  ..\faxdoc.cpp  \
  ..\faxxp.cpp   \
  ..\util.cpp    \
  ..\xplogon.cpp \
  ..\xpprov.cpp  \
  ..\version.rc

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
SXS_ASSEMBLY_NAME=Microsoft.Windows.Fax.FxsXP32
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=faxxp.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\xpprov.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xpprov.cpp

Abstract:

    This module contains the CXPProvider class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define INITGUID
#define USES_IID_IXPProvider
#define USES_IID_IXPLogon
#define USES_IID_IMAPIStatus
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIControl
#define USES_IID_IMAPIContainer
#define USES_IID_IMAPIFolder
#define USES_IID_IMAPITableData
#define USES_IID_IStreamDocfile
#define USES_PS_PUBLIC_STRINGS

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop



CXPProvider::CXPProvider(
    HINSTANCE hInst
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInst   - Handle to instance of this XP DLL

Return Value:

    None.

--*/

{
    m_hInstance = hInst;
    m_cRef = 1;
    InitializeCriticalSection( &m_csTransport );
}


CXPProvider::~CXPProvider()

/*++

Routine Description:

    Close down and release resources and libraries.

Arguments:

    None.

Return Value:

    None.

--*/

{
    m_hInstance = NULL;
    DeleteCriticalSection( &m_csTransport );
}


STDMETHODIMP
CXPProvider::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    *ppvObj = NULL;
    if (riid == IID_IXPProvider || riid == IID_IUnknown) {
        *ppvObj = (LPVOID)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPProvider::Shutdown(
    ULONG * pulFlags
    )

/*++

Routine Description:

    Stub method.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	DBG_ENTER(TEXT("CXPProvider::Shutdown"));
	
    return S_OK;
}


STDMETHODIMP
CXPProvider::TransportLogon(
    LPMAPISUP pSupObj,
    ULONG ulUIParam,
    LPTSTR pszProfileName,
    ULONG *pulFlags,
    LPMAPIERROR *ppMAPIError,
    LPXPLOGON *ppXPLogon
    )

/*++

Routine Description:

    Display the logon dialog to show the options saved in the profile for
    this provider and allow changes to it. Save new configuration settings
    back in the profile.
    Create a new CXPLogon object and return it to the spooler. Also,
    initialize the properties array for each address type handled
    by this transport. Check all the flags and return them to the spooler

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPProvider::TransportLogon"),hResult);

    CXPLogon *LogonObj = new CXPLogon( m_hInstance, pSupObj, pszProfileName );
    if (!LogonObj) {
		hResult = E_OUTOFMEMORY;
        goto exit;
    }

    hResult = LogonObj->InitializeStatusRow(0);

    if(HR_SUCCEEDED(hResult))
    {
        *ppXPLogon = LogonObj;
    }
    else
    {
        delete LogonObj;
    }

exit:
    return hResult;
}

STDMETHODIMP_(ULONG)
CXPProvider::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPProvider::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\renderer\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=faxrend
!ifndef NOUNICODE
TARGETPATH=$(FAXLIB)
!else
TARGETPATH=$(FAXLIB95)
!endif
TARGETTYPE=LIBRARY

UMTYPE=windows
USE_CRTDLL=1

INCLUDES=\
	..\;	\
    $(INCLUDES); \
    ..\..\inc;      \
    ..\..\src;

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
	..\..\util\unicode\$O\fautil.lib
!else
LINKLIBS_INT=\
	..\..\util\ansi\$O\fautil.lib

!endif

LINKLIBS=\
    $(LINKLIBS)\
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\gdi32.lib

SOURCES=\
    ..\prtcovpg.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\renderer\prtcovpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prtcovpg.c

Abstract

    Three componants of the composite page description file:
      1)  A header describing the other two componants.
      2)  An embebbed meta file of the page description objects.
      3)  Text strings (or resource ID's of string data
          requiring substitution of user data passed in to the
          function).

    Routine parses componants of composite page description file as
    created by the Windows XP "FaxCover" application; renders the
    objects to the DC, if hdc is not NULL.

Author:

    Julia J. Robinson

Revision History:

    Julia J. Robinson 6-7-96
    Julia J. Robinson 9-20-96       Allow passing paper size and orientation.
    Sasha    Bessonov 10-28-99      Fixed initialization of view port for non printer devices

Environment:

    Windows XP


--*/

#include <windows.h>
#include <commdlg.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "faxutil.h"

#include "prtcovpg.h"
#include "resource.h"

#include "strsafe.h"


#define INITIAL_SIZE_OF_STRING_BUFFER 64
#define NOTE_INDEX  22        // Index of "{Note}"  in the InsertionTitle array.

BYTE  UNICODE_Signature[20]= {0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};


//
// Resource ID's corresponding to fields of USERDATA.
//

WORD InsertionTagResourceID[]=
{
    IDS_PROP_RP_NAME,                           // "{Recipient Name}"
    IDS_PROP_RP_FXNO,                           // "{Recipient Fax Number}"
    IDS_PROP_RP_COMP,                           // "{Recipient's Company}"
    IDS_PROP_RP_ADDR,                           // "{Recipient's Street Address}"
    IDS_PROP_RP_CITY,                           // "{Recipient's City}"
    IDS_PROP_RP_STAT,                           // "{Recipient's State}"
    IDS_PROP_RP_ZIPC,                           // "{Recipient's Zip Code}"
    IDS_PROP_RP_CTRY,                           // "{Recipient's Country}"
    IDS_PROP_RP_TITL,                           // "{Recipient's Title}"
    IDS_PROP_RP_DEPT,                           // "{Recipient's Department}"
    IDS_PROP_RP_OFFI,                           // "{Recipient's Office Location}"
    IDS_PROP_RP_HTEL,                           // "{Recipient's Home Telephone #}"
    IDS_PROP_RP_OTEL,                           // "{Recipient's Office Telephone #}"
    IDS_PROP_SN_NAME,                           // "{Sender Name}"
    IDS_PROP_SN_FXNO,                           // "{Sender Fax #}"
    IDS_PROP_SN_COMP,                           // "{Sender's Company}"
    IDS_PROP_SN_ADDR,                           // "{Sender's Address}"
    IDS_PROP_SN_TITL,                           // "{Sender's Title}"
    IDS_PROP_SN_DEPT,                           // "{Sender's Department}"
    IDS_PROP_SN_OFFI,                           // "{Sender's Office Location}"
    IDS_PROP_SN_HTEL,                           // "{Sender's Home Telephone #}"
    IDS_PROP_SN_OTEL,                           // "{Sender's Office Telephone #}"
	IDS_PROP_SN_EMAL,							// "{Sender's E-mail}"
    IDS_PROP_MS_NOTE,                           // "{Note}"
    IDS_PROP_MS_SUBJ,                           // "{Subject}"
    IDS_PROP_MS_TSNT,                           // "{Time Sent}"
    IDS_PROP_MS_NOPG,                           // "{# of Pages}"
    IDS_PROP_RP_TOLS,                           // "{To: List}"
    IDS_PROP_RP_CCLS                            // "{Cc: List}"
};

LPTSTR
ConvertStringToTString(LPCWSTR lpcwstrSource)
/*++
Routine Description:

	Converts string to T format
Arguments:
	
	lpcwstrSource - source

Return Value:

	Copied string or NULL

Comment:
	The function returns NULL if lpcwstrSource == NULL or conversion failed

--*/
{
	LPTSTR lptstrDestination;

	if (!lpcwstrSource)
		return NULL;

#ifdef	UNICODE
    lptstrDestination = StringDup( lpcwstrSource );
#else	// !UNICODE
	lptstrDestination = UnicodeStringToAnsiString( lpcwstrSource );
#endif	// UNICODE
	
	return lptstrDestination;
}

DWORD
CopyWLogFontToTLogFont(
			IN const LOGFONTW * plfSourceW,
			OUT      LOGFONT  * plfDest)
{
/*++
Routine Description:

    This fuction copies a LogFont structure from UNICODE format
	to T format.

Arguments:
	
	  plfSourceW - reference to input UNICODE LongFont structure
	  plfDest - reference to output LongFont structure

Return Value:

	WINAPI last error

--*/
#ifndef UNICODE
	int iCount;
#else
	HRESULT hr;
#endif

    plfDest->lfHeight = plfSourceW->lfHeight ;
    plfDest->lfWidth = plfSourceW->lfWidth ;
    plfDest->lfEscapement = plfSourceW->lfEscapement ;
    plfDest->lfOrientation = plfSourceW->lfOrientation ;
    plfDest->lfWeight = plfSourceW->lfWeight ;
    plfDest->lfItalic = plfSourceW->lfItalic ;
    plfDest->lfUnderline = plfSourceW->lfUnderline ;
    plfDest->lfStrikeOut = plfSourceW->lfStrikeOut ;
    plfDest->lfCharSet = plfSourceW->lfCharSet ;
    plfDest->lfOutPrecision = plfSourceW->lfOutPrecision ;
    plfDest->lfClipPrecision = plfSourceW->lfClipPrecision ;
    plfDest->lfQuality = plfSourceW->lfQuality ;
    plfDest->lfPitchAndFamily = plfSourceW->lfPitchAndFamily ;

	SetLastError(0);

#ifdef UNICODE
	hr = StringCchCopy(
			plfDest->lfFaceName,
			LF_FACESIZE,
			plfSourceW->lfFaceName);
	if (FAILED(hr))
	{		
		return HRESULT_CODE(hr);
	}	
	
#else
    iCount = WideCharToMultiByte(
				CP_ACP,
				0,
				plfSourceW->lfFaceName,
				-1,
				plfDest->lfFaceName,
				LF_FACESIZE,
				NULL,
				NULL
				);

	if (!iCount)
	{
		return GetLastError();
	}
#endif
	return ERROR_SUCCESS;
}


DWORD WINAPI
PrintCoverPage(
    HDC              hDC,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo
    )
/*++

    Renders the coverpage into a printer DC using the size of a printer page.
    Also returns information on the cover page. See param documentation.

    Arguments:

        hDC                   - Device context.  If NULL, we just read the file and set *pFlags


        pUserData              - pointer to a structure containing user data
                                  for text insertions.  May be NULL.

        lpctstrTemplateFileName     - Name of the file created by the page editor,
                                      containing the META file.

        pCovDocInfo           - pointer to structure contining information about the cover page file.
                                This includes

                                    pCovDocInfo->NoteRect

                                        - Coordinates of the "Note" insertion rectangle, returned
                                          in device coordinates.  This will be all 0 if hDC is NULL


                                    pCovDocInfo->Flags

                                        - Returns bitwise OR of the following (or more):

                                             COVFP_NOTE      if .cov file contains a Note field.

                                             COVFP_SUBJECT   if .cov file contains a Subject field.

                                             COVFP_NUMPAGES  if .cov file contains Num Pages field.

                                    pCovDocInfo->PaperSize

                                        - may use in DEVMODE as dmPaperSize

                                    pCovDocInfo->Orientation

                                        - may use in DEVMODE as dmOrientation

                                    pCovDocInfo->NoteFont

                                        - Logfont structure to be used in rendering the NOTE.
                                          This will be meaningless if hDC is NULL.
--*/
{
    
    
    RECT   ClientRect;

    DEBUG_FUNCTION_NAME(TEXT("PrintCoverPage"));

    Assert(lpctstrTemplateFileName);

    memset(&ClientRect,0,sizeof(ClientRect));
    if (hDC)
    {

        DWORD                FullPrinterWidth;         // PHYSICALWIDTH
        DWORD                FullPrinterHeight;        // PHYSICALHEIGHT
        DWORD                PrinterUnitsX;            // PHYSICALWIDTH - (width of margins)
        DWORD                PrinterUnitsY;            // PHYSICALHEIGHT - (height of margins)

        FullPrinterWidth  = GetDeviceCaps( hDC, PHYSICALWIDTH );
        PrinterUnitsX     = FullPrinterWidth - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETX );
        FullPrinterHeight = GetDeviceCaps( hDC, PHYSICALHEIGHT );
        PrinterUnitsY     = FullPrinterHeight - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETY );
       

        ClientRect.top    = GetDeviceCaps( hDC, PHYSICALOFFSETY );
        ClientRect.left   = GetDeviceCaps( hDC, PHYSICALOFFSETX );
        ClientRect.right  = ClientRect.left + FullPrinterWidth -1;
        ClientRect.bottom = ClientRect.top  + PrinterUnitsY - 1;    
    }
    
    return RenderCoverPage(
                hDC,
                &ClientRect,
                pUserData,
                lpctstrTemplateFileName,
                pCovDocInfo,
                FALSE
            );
}


DWORD WINAPI
RenderCoverPage(
    HDC              hDC,
	LPCRECT			 lpcRect,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo,
    BOOL             bPreview
    )

/*++

   Renders a coverpage into a rectangle in the provided dc. Also returns information on the
   cover page. See param documentation.

    Arguments:

        hDC                   - Device context.  If NULL, we just read the file and set *pFlags

        lpcRect                - pointer to a RECT that specifies the rectangle into which the 
                                 cover page template will be rendered.

        pUserData              - pointer to a structure containing user data
                                  for text insertions.  May be NULL.

        lpctstrTemplateFileName     - Name of the file created by the page editor,
                                      containing the META file.

        pCovDocInfo           - pointer to structure contining information about the cover page file.
                                This includes

                                    pCovDocInfo->NoteRect

                                        - Coordinates of the "Note" insertion rectangle, returned
                                          in device coordinates.  This will be all 0 if hDC is NULL


                                    pCovDocInfo->Flags

                                        - Returns bitwise OR of the following (or more):

                                             COVFP_NOTE      if .cov file contains a Note field.

                                             COVFP_SUBJECT   if .cov file contains a Subject field.

                                             COVFP_NUMPAGES  if .cov file contains Num Pages field.

                                    pCovDocInfo->PaperSize

                                        - may use in DEVMODE as dmPaperSize

                                    pCovDocInfo->Orientation

                                        - may use in DEVMODE as dmOrientation

                                    pCovDocInfo->NoteFont

                                        - Logfont structure to be used in rendering the NOTE.
                                          This will be meaningless if hDC is NULL.

        pPreview        - boolean flag that is TRUE if the function should render the text for
                            cover page preview in the wizard and is FALSE for all other cases
                            of normal full-size rendering.
--*/

{
    ENHMETAHEADER        MetaFileHeader;
    UINT                 HeaderSize;
    LPBYTE               pMetaFileBuffer = NULL;
    const BYTE           *pConstMetaFileBuffer;
    DWORD                rVal = ERROR_SUCCESS;
    INT                  TextBoxNbr;
    COLORREF             PreviousColor;
    HFONT                hThisFont = NULL;
    HGDIOBJ              hPreviousFont;
    DWORD                NbrBytesRead;
    RECT                 TextRect;
    RECT                 NoteRect;
    TEXTBOX              TextBox;                  // buffer for reading in a TEXTBOX
    HENHMETAFILE         MetaFileHandle = NULL;
    HANDLE               CompositeFileHandle = INVALID_HANDLE_VALUE;
    COMPOSITEFILEHEADER  CompositeFileHeader;

    INT                  HeightDrawn;              // return value of DrawText()
    INT                  ReadBufferSize;           // size of buffer for reading in strings.
    INT                  ThisBufSize;              // size buffer needed for current text string.
    LPWSTR               pStringReadIn = NULL;     // buffer for reading in strings.
    LPWSTR               pTmpString = NULL;        // temporary pointer to realocated memory.
    LPTSTR               pWhichTextToRender = NULL;// pStringReadIn v. ArrayOfData[i]
    LPTSTR               lptstrStringReadIn = NULL;// LPTSTR of pStringReadIn 
    LPTSTR               lptstrArrayOfData  = NULL;// ArrayOfData[i]
    INT                  i;                        // loop index
    LPTSTR *             ArrayOfData;              // uses pointers in UserData as ragged array.
    int                  CallersDCState = 0;       // returned by SaveDC
    int                  MyDCState = 0;            // returned by SaveDC
    DWORD                ThisBit;                  // Flag field for current index.
    DWORD                Flags;                    // Return these if pFlags != NULL.
    WORD                 MoreWords[3];             // Scale, PaperSize, and Orientation
    LOGFONT              NoteFont;                 // Logfont structure found in the NOTE box
    LOGFONT              FontDef;                  // Logfont structure 
    
    HRGN                 hRgn = NULL;

	SIZE orgExt;
	POINT orgOrigin;
	SIZE orgPortExt;

    DWORD dwReadingOrder = 0;

    DEBUG_FUNCTION_NAME(TEXT("RenderCoverPage"));
    //
    // Initialize return values, handles, and pointers.
    //
    NoteRect.left = 0;
    NoteRect.right = 0;
    NoteRect.top = 0;
    NoteRect.bottom = 0;
    Flags = 0;
    hThisFont = NULL;
    CompositeFileHandle = INVALID_HANDLE_VALUE;
    MyDCState = 0;
    CallersDCState = 0;

    //
    // Initialize a Pointer so that
    //
    //       ArrayOfData[0] ===== pUserData->RecName ,
    //       ArrayOfData[1] ===== pUserData->RecFaxNumber ,
    //                   ... etc. ...

    if (pUserData){
        ArrayOfData = &pUserData->RecName;
    }

    ZeroMemory( &CompositeFileHeader, sizeof(COMPOSITEFILEHEADER) );
    ZeroMemory( &TextBox, sizeof(TEXTBOX) );

    //
    // Open the composite data file.
    //

    CompositeFileHandle = CreateFile(
        lpctstrTemplateFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (CompositeFileHandle == INVALID_HANDLE_VALUE) {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to open COV template file [%s] (ec: %ld)"),
                lpctstrTemplateFileName,
                rVal
                );
        rVal = GetLastError();
        goto exit;
    }

    if(!ReadFile(CompositeFileHandle, 
                &CompositeFileHeader, 
                sizeof(CompositeFileHeader), 
                &NbrBytesRead, 
                NULL))
    {
        rVal = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to read composite file header (ec: %ld)"),
                rVal
                );
        goto exit;
    }
        
    //
    // Check the 20-byte signature in the header to see if the file
    //     contains ANSI or UNICODE strings.
    //
    if ((sizeof(CompositeFileHeader) != NbrBytesRead) ||
        memcmp( UNICODE_Signature, CompositeFileHeader.Signature, 20 ))
    {
        rVal = ERROR_BAD_FORMAT;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("CompositeFile signature mismatch (ec: %ld)"),
                rVal
                );
        goto exit;
    }

    //
    // Extract the embedded META file from the composite file and move
    // into meta file buffer
    //

    pMetaFileBuffer = (LPBYTE) malloc( CompositeFileHeader.EmfSize );
    if (!pMetaFileBuffer){
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocated metafile buffer (ec: %ld)"),
                rVal
                );
        goto exit;
    }

    if ((!ReadFile( 
            CompositeFileHandle, 
            pMetaFileBuffer, 
            CompositeFileHeader.EmfSize, 
            &NbrBytesRead, 
            NULL ) ||
            CompositeFileHeader.EmfSize != NbrBytesRead))
    {
        rVal = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to read metafile (ec: %ld)"),
                rVal
                );
        goto exit;
    }

    if (hDC) {           // Rendering

        int CRComplexity;

        hRgn = CreateRectRgnIndirect( lpcRect);
        if (!hRgn)
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateRectRgnIndirect() failed (ec: %ld)"),
                rVal
                );
            goto exit;
        }
        CRComplexity = SelectClipRgn( hDC, hRgn );
        if (ERROR == CRComplexity)
        {
            rVal = ERROR_GEN_FAILURE;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SelectClipRgn() failed (reported region complexity: %ld)"),
                CRComplexity
                );
            goto exit;
        }
    
        //
        // Save Device Context state
        //

        CallersDCState = SaveDC( hDC );
        if (CallersDCState == 0) {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SaveDC() failed (ec: %ld)"),
                rVal
                );
            goto exit;
        }

        

        
        //
        // Set device context appropriately for rendering both text and metafile.
        //
        if (!CompositeFileHeader.EmfSize){
            //
            // No objects to render.
            //
            rVal = ERROR_NO_MORE_FILES;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("No objects to render in EMF file")
                );
            goto exit;
        }

        pConstMetaFileBuffer = pMetaFileBuffer;

        //
        // Create an enhanced metafile, in memory, from the data in the buffer.
        //

        MetaFileHandle = SetEnhMetaFileBits(
            CompositeFileHeader.EmfSize,
            pConstMetaFileBuffer
            );
        if (!MetaFileHandle) {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEnhMetaFileBits() failed (ec: %ld)"),
                rVal);
            goto exit;
        }

        //
        // verify the metafile header.
        //

        HeaderSize = GetEnhMetaFileHeader(
            MetaFileHandle,
            sizeof(ENHMETAHEADER),
            &MetaFileHeader
            );
        if (!HeaderSize){
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetEnhMetaFileHeader() failed (ec: %ld)"),
                rVal);
            goto exit;
        }

        //
        // Render the MetaFile
        //

        if (!PlayEnhMetaFile( hDC, MetaFileHandle, lpcRect )) {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PlayEnhMetaFile() failed (ec: %ld)"),
                rVal);
            goto exit;
        }

        //
        // Set Device Context for rendering text.
        // Undo any changes that occurred when rendering the metafile.
        //

        RestoreDC( hDC, MyDCState );
        MyDCState = 0;

        if (CLR_INVALID == SetBkMode( hDC, TRANSPARENT)){
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetBkMode() failed (ec: %ld)"),
                rVal);
            goto exit;
        }

    


		//
		// Set a mapping mode that will allow us to output the text boxes
		// in the same scale as the metafile.
		//
    	if (!SetMapMode(hDC,MM_ANISOTROPIC))
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetMapMode() failed (ec: %ld)"),
                rVal);
            goto exit;
        }
		// 
		// Set the logical coordinates to the total size (positve + negative) of the x and y axis
		// which is the same as the size of the cover page.
		//
		if (!SetWindowExtEx(
            hDC,
            CompositeFileHeader.CoverPageSize.cx,
            -CompositeFileHeader.CoverPageSize.cy,
            &orgExt
            ))
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetWindowExtEx() failed (ec: %ld)"),
                rVal);
            goto exit;
        };
		//
		// We map the logical space to a device space which is the size of the rectangle into 
        // which we played the meta file.
		// 
		if (!SetViewportExtEx(
            hDC,lpcRect->right - lpcRect->left,
            lpcRect->bottom - lpcRect->top,&orgPortExt
            ))
        
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetViewportExtEx() failed (ec: %ld)"),
                rVal);
            goto exit;
        };
        
		//
		// We map logical point (0,0) to the middle of the device space.
		//
		if (!SetWindowOrgEx(
            hDC,
            -CompositeFileHeader.CoverPageSize.cx/2,
            CompositeFileHeader.CoverPageSize.cy/2,
            &orgOrigin))
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetWindowOrgEx() failed (ec: %ld)"),
                rVal);
            goto exit;
        };
        

	
    }
	//
    //  Initialize buffer for reading in strings.
    //

    ReadBufferSize = INITIAL_SIZE_OF_STRING_BUFFER;

    pStringReadIn = (LPWSTR) malloc( ReadBufferSize );
    if (!pStringReadIn) {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate initial strings buffer (ec: %ld)"),
                rVal);
        goto exit;
    }

    //
    // Read in Text Box objects from the composite file and print out the text.
    //

    for (TextBoxNbr=0; TextBoxNbr < (INT) CompositeFileHeader.NbrOfTextRecords; ++TextBoxNbr)
    {
        if ((!ReadFile( CompositeFileHandle, &TextBox, sizeof(TEXTBOX), &NbrBytesRead, NULL)) ||
            NbrBytesRead != sizeof(TEXTBOX))
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to read text box number %ld (ec: %ld)"),
                TextBoxNbr,
                rVal);
            goto exit;
        }

        //
        // Check buffer size, lock buffer, and
        // read in variable length string of text.
        //

        ThisBufSize = sizeof(WCHAR) * (TextBox.NumStringBytes + 1);
        if (ReadBufferSize < ThisBufSize) {
            pTmpString = realloc( pStringReadIn, ThisBufSize );
            if (!pTmpString) 
			{
                rVal = ERROR_NOT_ENOUGH_MEMORY;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to realloc text box number %ld buffer. Requested size was %ld (ec: %ld)"),
                    TextBoxNbr,
                    ThisBufSize,
                    rVal);

                goto exit;
            }
			else
			{
				pStringReadIn = pTmpString;
				pTmpString = NULL;
			}
        }

        if ((!ReadFile( CompositeFileHandle, (void*)pStringReadIn, TextBox.NumStringBytes, &NbrBytesRead, NULL)) ||
            NbrBytesRead != TextBox.NumStringBytes)
        {
            rVal = GetLastError();
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to read text box number %ld content (ec: %ld)"),
                    TextBoxNbr,
                    rVal);
            goto exit;
        }

        pStringReadIn[TextBox.NumStringBytes / sizeof(WCHAR)] = 0;

		if (lptstrStringReadIn) {
			MemFree(lptstrStringReadIn);
			lptstrStringReadIn = NULL;
		}

        if (pStringReadIn && (!(lptstrStringReadIn = ConvertStringToTString(pStringReadIn))))
		{
			rVal = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to covert string to TString (ec: %ld)"),
                    rVal);
			goto exit;
		}

        if (hDC) 
        {
            //
            // Correct position of text box.
            //

            TextRect.top    = max( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
            TextRect.left   = min( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );
            TextRect.bottom = min( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
            TextRect.right  = max( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );

        }

        if (TextBox.ResourceID) 
        {
            //
            // Text box contains a FAX PROPERTY field.
            // Find appropriate field of USERDATA for this resource ID.
            //

            for (i=0,ThisBit=1; i<NUM_INSERTION_TAGS; ++i,ThisBit<<=1) 
            {
                if (TextBox.ResourceID == InsertionTagResourceID[i])
                {
                    lptstrArrayOfData = pUserData ? ArrayOfData[i] : NULL;

                    //
                    // Set Flags bit to indicate this FAX PROPERTY field is present.
                    //
                    Flags |= ThisBit;
                    break;
                }
            }

			if (TextBox.ResourceID == IDS_PROP_MS_NOTE && hDC) 
            {
                //
                // NOTE field found.  Return its rectangle in device coordinates.
                // Return its LOGFONT with height adjusted for device coordinates.
                //

                NoteRect = TextRect;
                LPtoDP( hDC, (POINT*)&NoteRect, 2 );
				if ((rVal = CopyWLogFontToTLogFont(&TextBox.FontDefinition,&NoteFont)) != ERROR_SUCCESS) 
				{
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CopyWLogFontToTLogFont() failed (ec: %ld)"),
                        rVal);
					goto exit;
				}
                NoteFont.lfHeight = (LONG)MulDiv(
                    (int)NoteFont.lfHeight,
                    GetDeviceCaps( hDC, LOGPIXELSY ),
                    100
                    );
            }
        }

		pWhichTextToRender = (lptstrStringReadIn[0] != (TCHAR)'\0') ? lptstrStringReadIn : lptstrArrayOfData;

        if (hDC && pWhichTextToRender) 
        {
            //
            // Set text color and font for rendering text.
            //

            PreviousColor = SetTextColor( hDC, TextBox.TextColor );
            if (PreviousColor == CLR_INVALID){
                rVal = GetLastError();

                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SetTextColor() failed (ec: %ld)"),
                        rVal);

                goto exit;
            }

			if ((rVal = CopyWLogFontToTLogFont(&TextBox.FontDefinition,&FontDef)) != ERROR_SUCCESS) 
			{
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CopyWLogFontToTLogFont() failed (ec: %ld)"),
                        rVal);
				goto exit;
			}

            if (bPreview)
            {
                //
                //  For CoverPage Preview, we want to get only TT font
                //  That is able to draw a small letters.
                //

                //
                //  Add OUT_TT_ONLY_PRECIS to force the TTF
                //
                FontDef.lfOutPrecision |= OUT_TT_ONLY_PRECIS;
            }

            hThisFont = CreateFontIndirect( &FontDef );
            if (!hThisFont) {
                rVal = GetLastError();
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateFontIndirect() failed (ec: %ld)"),
                        rVal);
                goto exit;
            }

            hPreviousFont = SelectObject( hDC, hThisFont );
            if (!hPreviousFont) {
                rVal = GetLastError();

                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SelectObject() failed (ec: %ld)"),
                        rVal);
                goto exit;
            }

            if (bPreview)
            {
                //
                //  Now check that created font is real TTF
                //

                TEXTMETRIC          TextMetric;
                HGDIOBJ             hPrevFont = NULL;

                if (!GetTextMetrics(hDC, &TextMetric))
                {
                    rVal = GetLastError();
                    DebugPrintEx(DEBUG_ERR, _T("GetTextMetrics() failed (ec: %ld)"), rVal);
                    goto exit;
                }

                if ( ! ( (TextMetric.tmPitchAndFamily & TMPF_TRUETYPE) > 0))
                {
                    //
                    //  This is not TT font
                    //  In this case, the selected font cannot correct represent
                    //      the small letters in the CoverPage preview.
                    //  So, we hard-coded put the font to be Tahoma, which is TTF
                    //
					HRESULT hr = StringCchCopy(
						FontDef.lfFaceName,
                        LF_FACESIZE,
						_T("Tahoma"));
					if (FAILED(hr))
					{
						//
						// Should never happen, large enough buffer.
						//
						ASSERT_FALSE;
					}                        

                    //
                    //  Create new font
                    //
                    hThisFont = CreateFontIndirect( &FontDef );
                    if (!hThisFont) 
                    {
                        rVal = GetLastError();
                        DebugPrintEx(DEBUG_ERR, _T("CreateFontIndirect(2) failed (ec: %ld)"), rVal);
                        goto exit;
                    }

                    hPrevFont = SelectObject( hDC, hThisFont );
                    if (!hPrevFont) 
                    {
                        rVal = GetLastError();
                        DebugPrintEx(DEBUG_ERR, _T("SelectObject(2) failed (ec: %ld)"), rVal);
                        goto exit;
                    }

                    //
                    //  Delete previous font - the one that was created wrong
                    //
                    DeleteObject(hPrevFont);

                }
            }

            dwReadingOrder = 0;
            if (TextBox.ResourceID && StrHasRTLChar(LOCALE_SYSTEM_DEFAULT, pWhichTextToRender))
            {
                dwReadingOrder = DT_RTLREADING;
            }

            //
            // Render the text.
            //				
            HeightDrawn = DrawText(hDC,
                                    pWhichTextToRender,
                                    -1,
                                    &TextRect,
                                    DT_NOPREFIX | DT_WORDBREAK | TextBox.TextAlignment | dwReadingOrder);
            if (!HeightDrawn) 
            {
                rVal = GetLastError();
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("DrawText() failed for textbox #%ld with content [%s] (ec: %ld)"),
                        TextBoxNbr,
                        pWhichTextToRender,
                        rVal);

                goto exit;
            }


            //
            //  Restore previous font and release the handle to the selected font
            //

            SelectObject( hDC, (HFONT)hPreviousFont );
            SetTextColor( hDC, PreviousColor );
            DeleteObject( hThisFont );
            hThisFont = NULL;
        }
		//
		// Null the data string so it won't be accidently used in the next data field.
		//
		lptstrArrayOfData = NULL;

    } // Ends loop over all textboxes.

    //
    // Read on to get Orientation and PaperSize
    //


    if ((!ReadFile( CompositeFileHandle, MoreWords, 3*sizeof(WORD), &NbrBytesRead, NULL )) ||
        NbrBytesRead != 3 * sizeof(WORD))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to read Orientation and PaperSize (ec: %ld)"),
            rVal);
        goto exit;
    }



exit:

    if (MetaFileHandle)
    {
        DeleteEnhMetaFile( MetaFileHandle );
    }

	if (lptstrStringReadIn) 
    {
		MemFree(lptstrStringReadIn);
	}

    if (hThisFont) 
    {
        DeleteObject( hThisFont );
    }

    if (pStringReadIn) {
        free( pStringReadIn );
    }

    if (pMetaFileBuffer) 
    {
        free( pMetaFileBuffer );
    }

    if (CompositeFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( CompositeFileHandle );
    }

    if( MyDCState )
    {
        RestoreDC( hDC, MyDCState );
    }

    if( CallersDCState )
    {
        RestoreDC( hDC, CallersDCState );
    }

    if (rVal == 0 && pCovDocInfo != NULL) 
    {
        pCovDocInfo->Flags = Flags;
        pCovDocInfo->NoteRect = NoteRect;
        pCovDocInfo->PaperSize = (short) MoreWords[1];
        pCovDocInfo->Orientation = (short) MoreWords[2];
        pCovDocInfo->NoteFont = NoteFont;
    }

    if (hRgn)
    {
        DeleteObject(hRgn);
    }

    return rVal;
}


DWORD
PrintCoverPageToFile(
    LPTSTR lptstrCoverPage,
    LPTSTR lptstrTargetFile,
    LPTSTR lptstrPrinterName,
    short sCPOrientation,
	short sCPYResolution,
    PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Ronen Barenboim 25-March-2000

Routine Description:

    Renders a cover page template into a TIFF file by printing it into file using the specified printer.

Arguments:

    [IN] lptstrCoverPage - Full path to the cover page template file.
    [IN] lptstrTargetFile - Full path to the file in which the TIFF will be stores.
                       The function will create this file.

    [IN] lptstrPrinterName - The name of the printer to which the cover page will be printed
                        in order to generate the TIFF file.

    [IN] sCPOrientation - The cover page orientation.

	[IN] sCPYResolution - coverpage Y resolution. 0 for the printer default

    [IN] pCPFields        - Points to a cover page information structure. Its fields will be used to
                       replace the cov template fields.

Return Value:

    ERROR_SUCCESS on success. A Win32 error code on failure.

--*/

{
    COVDOCINFO  covDocInfo;
    DOCINFO DocInfo;
    HDC hDC = NULL;
    INT JobId = 0;
    BOOL bRet = FALSE;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL bEndPage = FALSE;
    LONG lSize;
    HANDLE hPrinter = NULL;
    PDEVMODE pDevMode = NULL;
    DEBUG_FUNCTION_NAME(TEXT("PrintCoverPageToFile"));


    Assert(lptstrPrinterName);
    Assert(lptstrTargetFile);
    Assert(pCPFields);
    Assert(lptstrCoverPage);
    Assert (sCPOrientation == DMORIENT_LANDSCAPE || sCPOrientation == DMORIENT_PORTRAIT);
	Assert (sCPYResolution == 0 || sCPYResolution == 98 || sCPYResolution == 196);

    //
    // open the printer for normal access (this should always work)
    //
    if (!OpenPrinter( lptstrPrinterName, &hPrinter, NULL ))
    {
        dwRet = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("OpenPrinter failed. Printer Name = %s , ec = %ld"),
			lptstrPrinterName,
			dwRet);  
		goto exit;
    }

    //
    // Get the default devmode
    //
    lSize = DocumentProperties( NULL, hPrinter, NULL, NULL, NULL, 0 );
    if (lSize <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("DocumentProperties failed. ec = %ld"),
			dwRet);
        goto exit;
    }

    //
    // allocate memory for the DEVMODE
    //
    pDevMode = (PDEVMODE) MemAlloc( lSize );
    if (!pDevMode)
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Cant allocate DEVMODE."));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // get the default document properties
    //
    if (DocumentProperties( NULL, hPrinter, NULL, pDevMode, NULL, DM_OUT_BUFFER ) != IDOK)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("DocumentProperties failed. ec = %ld"),
			dwRet);
        goto exit;
    }
    
    //
    // Set the correct orientation
    //
	pDevMode->dmOrientation = sCPOrientation;

	//
    // Set the correct reolution
    //
    if (0 != sCPYResolution)
    {
        //
        // Set the coverpage resolution to the same value as the body tiff file
        //
        pDevMode->dmYResolution = sCPYResolution;
    }


    //
    // Create the device context
    //
    hDC = CreateDC( NULL, lptstrPrinterName, NULL, pDevMode);
    if (!hDC)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("CreateDC on printer %s failed (ec: %ld)"),
			lptstrPrinterName,
			dwRet);
        goto exit;
    }

    //
    // Set the document information
    //
    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = TEXT("");
    DocInfo.lpszOutput = lptstrTargetFile;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    //
    // Start the print job
    //
    JobId = StartDoc( hDC, &DocInfo );
    if (JobId <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("StartDoc failed (ec: %ld)"),
			dwRet);
        goto exit;
    }

    if (StartPage(hDC) <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("StartPage failed (ec: %ld)"),
			dwRet);
        goto exit;
    }
    bEndPage = TRUE;

    //
    // Do the actual rendering work.
    //
    dwRet = PrintCoverPage(
        hDC,
        pCPFields,
        lptstrCoverPage,
        &covDocInfo);

    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("PringCoverPage failed (ec: %ld). COV file: %s Target file: %s"),
			dwRet,
			lptstrCoverPage,
			lptstrTargetFile);
    }

exit:
    if (JobId)
    {
        if (TRUE == bEndPage)
        {
            if (EndPage(hDC) <= 0)
            {
                dwRet = GetLastError();
                DebugPrintEx(
					DEBUG_ERR,
					TEXT("EndPage failed - %d"),
					dwRet);
            }
        }

        if (EndDoc(hDC) <= 0)
        {
            dwRet = GetLastError();
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("EndDoc failed - %d"),
				dwRet);
        }
    }

    if (hDC)
    {
        bRet = DeleteDC( hDC );
        if (!bRet)
        {
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("DeleteDc failed - %d"),
				GetLastError());
        }

        Assert(bRet);
    }

    if (hPrinter)
    {
        if (!ClosePrinter (hPrinter))
        {
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("ClosePrinter failed - %d"),
				GetLastError());
        }
    }

    MemFree (pDevMode);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\xport\xplogon.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xplogon.cpp

Abstract:

    This module contains the XPLOGON class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop

#include <mbstring.h>

LPSTR gszFAXAddressType = FAX_ADDRESS_TYPE_A;
LPSTR *gpszXPAddressTypes;

LPSTR	ConvertTStringToAString(LPCTSTR lpctstrSource);


CXPLogon::CXPLogon(
    HINSTANCE       hInstance,
    LPMAPISUP       pSupObj,
    LPTSTR          ProfileName
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInstance   - Instance of the provider DLL
    pSupObj     - Pointer to IMAPISupport object used in
                  CXPLogon methods

Return Value:

    None.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::CXPLogon"));

    m_cRef           = 1;
    m_hInstance      = hInstance;
    m_pSupObj        = pSupObj;
    m_fABWDSInstalled = FALSE;

	m_ulTransportStatus = 0;

    m_pSupObj->AddRef();
}


CXPLogon::~CXPLogon()

/*++

Routine Description:

    Destructor of CXPLogon. Releases memory allocated for internal
    properties during the life of this transport logon object.

Arguments:

    None.

Return Value:

    None.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::~CXPLogon"));

    // Release the IMAPISupport object
    m_pSupObj->Release();
    m_pSupObj = NULL;
}


STDMETHODIMP
CXPLogon::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    // OLE requires NULLing parameter
    *ppvObj = NULL;
    // If this is one of the two IID return an interface pointer to it
    if (riid == IID_IXPLogon || riid == IID_IUnknown) 
    {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }
    // This object does not support the interface requested
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPLogon::AddressTypes(
    ULONG *        pulFlags,
    ULONG *        pcAdrType,
    LPTSTR **      pppAdrTypeArray,
    ULONG *        pcMAPIUID,
    LPMAPIUID **   pppMAPIUIDArray
    )

/*++

Routine Description:

    Called by the MAPI Spooler when initializing this XP logon object to
    allow the transport to register the address it will handle.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    S_OK always

--*/

{
	HRESULT hr = S_OK;
	DBG_ENTER(TEXT("CXPLogon::AddressTypes"),hr);

    *pcAdrType = 1;
    *pulFlags = 0;
    gpszXPAddressTypes = &gszFAXAddressType;
    *pppAdrTypeArray = (LPTSTR*)gpszXPAddressTypes;
    *pcMAPIUID = 0;
    *pppMAPIUIDArray = NULL;
    return hr;
}


STDMETHODIMP
CXPLogon::RegisterOptions(
    ULONG *         pulFlags,
    ULONG *         pcOptions,
    LPOPTIONDATA *  ppOptions
    )

/*++

Routine Description:

    This transport does not registers any per-recipient or per-message
    option processing, so we return 0 options. And NULL in the OPTIONDATA
    structure pointer.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::RegisterOptions"),hResult);

    *pulFlags = 0;
    *pcOptions = 0;
    *ppOptions = NULL;
    return hResult;
}


STDMETHODIMP
CXPLogon::InitializeStatusRow(
    ULONG ulFlags
    )

/*++

Routine Description:

    To initialize or modify the status properties of a CXPLogon
    object. This function allocates an array with NUM_STATUS_ROW_PROPS
    properties and initializes them.

Arguments:

    ulFlags - 0 if the properties are being created the first time.
              MODIFY_FLAGS if a change is being made to the properties

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::InitializeStatusRow"),hResult);

    #define NUM_STATUS_ROW_PROPS    7
    SPropValue spvStatusRow[NUM_STATUS_ROW_PROPS] = { 0 };
    ULONG i = 0;

    //
    // Set the PR_PROVIDER_DISPLAY property: The transport readable name
    //
    spvStatusRow[i].ulPropTag = PR_PROVIDER_DISPLAY_A;
    spvStatusRow[i++].Value.lpszA = TRANSPORT_DISPLAY_NAME_STRING;

    //
    // Set the PR_RESOURCE_METHODS property. These are the methods implemented
    // in the our IMAPIStatus implementation (CMAPIStatus class.)
    //
    spvStatusRow[i].ulPropTag = PR_RESOURCE_METHODS;
    //
    // we support ALL the methods in our implementation of IMAPIStatus interface (except the WRITABLE ones)
    //
    spvStatusRow[i++].Value.l = STATUS_SETTINGS_DIALOG |
                                STATUS_FLUSH_QUEUES |
                                STATUS_VALIDATE_STATE;

    //
    // Set the PR_STATUS_CODE property.
    //
    spvStatusRow[i].ulPropTag = PR_STATUS_CODE;
    spvStatusRow[i++].Value.l = GetTransportStatusCode();

    //
    // Set the PR_STATUS_STRING property
    //
    TCHAR szStatus[64];
    char* pcStatus = NULL;
    LoadStatusString (szStatus, ARR_SIZE(szStatus));
    spvStatusRow[i].ulPropTag = PR_STATUS_STRING_A;
    spvStatusRow[i++].Value.lpszA = pcStatus = ConvertTStringToAString(szStatus);
    if(!pcStatus)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set the PR_DISPLAY_NAME property
    //
    spvStatusRow[i].ulPropTag = PR_DISPLAY_NAME_A;
    spvStatusRow[i++].Value.lpszA = TRANSPORT_DISPLAY_NAME_STRING;

    //
    // Set the PR_REMOTE_PROGRESS property
    //
    spvStatusRow[i].ulPropTag = PR_REMOTE_PROGRESS;
    spvStatusRow[i++].Value.l = -1; // Not initialized

    //
    // Set the PR_REMOTE_VALIDATE_OK property
    //
    spvStatusRow[i].ulPropTag = PR_REMOTE_VALIDATE_OK;
    spvStatusRow[i++].Value.b = TRUE;

    //
    // Write the entries on the provider's session status row
    //
    hResult = m_pSupObj->ModifyStatusRow (i, spvStatusRow, ulFlags);

    MemFree(pcStatus);
    return hResult;
}


VOID WINAPI
CXPLogon::UpdateStatus(
    BOOL fAddValidate,
    BOOL fValidateOkState
    )

/*++

Routine Description:

    Updates the transport status row of this transport in the MAPI Mail
    subsystem. Updates the flags according the internal state flags
    maintained in status code of the transport and loads a readable status
    string to reset the status row. The caller of this method should update
    the status code member variable prior to calling UpdateStatus()

Arguments:

    fAddValidate
    fValidateOkState

Return Value:

    None.

--*/

{
	HRESULT hResult = S_OK;
    DBG_ENTER(TEXT("CXPLogon::UpdateStatus"),hResult);

    ULONG cProps = 1;
    SPropValue rgProps[1] = { 0 };

    rgProps[0].ulPropTag = PR_STATUS_CODE;
    rgProps[0].Value.l = GetTransportStatusCode();

    hResult = m_pSupObj->ModifyStatusRow( cProps, rgProps, STATUSROW_UPDATE );
}


BOOL WINAPI
CXPLogon::LoadStatusString(
    OUT LPTSTR pString,
    IN UINT uStringSize
    )

/*++

Routine Description:

    Loads a string from the transport's stringtable. This method is called
    by the CXPLogon::UpdateStatus method when updating a status row. This
    method loads the string based on the status bits of the transport
    status code

Arguments:

    pString      - Pointer to a string which will hold the status string
    uStringSize  - Maximum number of characters allowed in the string

Return Value:

   TRUE     - If the string was found in the string table.
   FALSE    - The string was not found. The String indicated by
              pString is set to hold 0 characters

--*/

{
	BOOL bRet = TRUE;
	DBG_ENTER(TEXT("CXPLogon::LoadStatusString"),bRet);

    //
	//Make sure we have a terminting NULL
	//
	pString[uStringSize-1] = '\0';
    
	//
	//Copy the string acroding to the size of uStringSize
	//
	_tcsncpy( pString, _T("Status String"), uStringSize-1);
	return bRet;
}


STDMETHODIMP
CXPLogon::TransportNotify(
    ULONG * pulFlags,
    LPVOID * ppvData
    )

/*++

Routine Description:

    Update the status row registered by this transport with MAPI.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::TransportNotify"),hResult,TEXT("ulFlags=%d"),*pulFlags);

    ULONG ulOldStatus = GetTransportStatusCode();

    if (*pulFlags & NOTIFY_BEGIN_INBOUND) 
    {
        RemoveStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_INBOUND) 
    {
        RemoveStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND) 
    {
        AddStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND) 
    {
        RemoveStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND_FLUSH) 
    {
        m_pSupObj->SpoolerNotify( NOTIFY_SENTDEFERRED, NULL );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND_FLUSH) 
    {
        RemoveStatusBits( STATUS_OUTBOUND_FLUSH );
    }
    if (*pulFlags & NOTIFY_END_INBOUND_FLUSH) 
    {
        RemoveStatusBits( STATUS_INBOUND_FLUSH );
    }

    if (ulOldStatus != GetTransportStatusCode()) 
    {
        UpdateStatus();
    }

    return hResult;
}

STDMETHODIMP
CXPLogon::Idle(
    ULONG ulFlags
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    S_OK always.

--*/

{
	//
	// We should not get called here, because we told
    // the spooler not to call us here.
	//
	DBG_ENTER(TEXT("CXPLogon::Idle"));

	Assert(false);
    return S_OK;
}


STDMETHODIMP
CXPLogon::TransportLogoff(
    ULONG ulFlags
    )

/*++

Routine Description:

    This method is called by the spooler when the transport should do final
    arragements before it gets released.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::TransportLogoff"),hResult,TEXT("ulFlags=%d"),ulFlags);

    //
    // We should attempt to remove the transport's status row from
    // the system
    //
    hResult = m_pSupObj->ModifyStatusRow (0, NULL, 0);

	if (S_OK != hResult)
	{
		CALL_FAIL (GENERAL_ERR, TEXT("ModifyStatusRow"), hResult);

		//
		// Don't fail the call
		//
		hResult = S_OK;
	}
    return hResult;
}


STDMETHODIMP
CXPLogon::SubmitMessage(
    ULONG     ulFlags,
    LPMESSAGE pMsgObj,
    ULONG *   pulMsgRef,
    ULONG *   pulReturnParm
    )

/*++

Routine Description:

    This method is called by the spooler when a client submits a
    message to a recipient whose address type this transport handles.
    The spooler calls this method twice for each deferred message.
    The first time (before the delivery time) when the message is
    submitted by the client, we simply return. The message is then queued
    by the spooler for later delivery. We keep track of when it's time
    to send deferred messages.

    The second time we're called, the state variable will be 'READY' and
    we go ahead and start the actual transmission. While we're in the
    body of this function, the implied state is 'SENDING'

    If the client logs out of this session, any pending messages get
    queued again the next time it logs in.

    In this transport we get a recipient table, we restrict the table for
    unmarked recipients. After the table is ready we invoke a helper
    method to do the actual transmission.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	LPADRLIST pOurAdrList = NULL;
    ULONG ulRow, ulRecipCount = 0;
    LPSPropValue pProps;
    FILETIME ft;
    SYSTEMTIME st;
    BOOL bSentSuccessfully;
    ULONG cValues;
    LPSPropValue pMsgProps = NULL;
    BOOL NeedDeliveryReport;
	TCHAR szHeaderText[1024] = {0};
    LPSTREAM lpstmT = NULL;
    DWORD dwRslt;
	TCHAR ErrorText[1024] = {0};
	TCHAR FailedText[1024] = {0};
    BOOL UseRichText = FALSE;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPMAPITABLE pTable = NULL;
    LPSRowSet pRecipRows = NULL;

    SPropValue   propResponsibility = {0};
    SPropValue   propAddrType = {0};
    SRestriction RestrictAnd[2] = {0};
    SRestriction Restriction = {0};
    DWORD        dwRowCount = 0;
	DWORD dwRecipientsLimit = 0;

    DBG_ENTER(TEXT("CXPLogon::SubmitMessage"),hResult,TEXT("ulFlags=%d"),ulFlags);

    CheckSpoolerYield( TRUE );
    
    //
    // Get the recipient table from the message
    //
    hResult = pMsgObj->GetRecipientTable( FALSE , &pTable );
    if (FAILED(hResult))
    {
        goto ErrorExit;
    }

    //
    // The spooler marks all the message recipients this transport has to
    // handle with PR_RESPONSIBILITY set to FALSE
    // and PR_ADDRTYPE_A is FAX
    //
    propResponsibility.ulPropTag = PR_RESPONSIBILITY;
    propResponsibility.Value.b   = FALSE;

    propAddrType.ulPropTag   = PR_ADDRTYPE_A;
    propAddrType.Value.lpszA = FAX_ADDRESS_TYPE_A;

    RestrictAnd[0].rt                        = RES_PROPERTY;
    RestrictAnd[0].res.resProperty.relop     = RELOP_EQ;
    RestrictAnd[0].res.resProperty.ulPropTag = PR_RESPONSIBILITY;
    RestrictAnd[0].res.resProperty.lpProp    = &propResponsibility;

    RestrictAnd[1].rt                        = RES_PROPERTY;
    RestrictAnd[1].res.resProperty.relop     = RELOP_EQ;
    RestrictAnd[1].res.resProperty.ulPropTag = PR_ADDRTYPE_A;
    RestrictAnd[1].res.resProperty.lpProp    = &propAddrType;

    Restriction.rt               = RES_AND;
    Restriction.res.resAnd.cRes  = 2;
    Restriction.res.resAnd.lpRes = RestrictAnd;

    hResult = pTable->Restrict( &Restriction, 0 );
    if (FAILED(hResult))
    {
        goto ErrorExit;
    }

    hResult = pTable->GetRowCount(0, &dwRowCount);
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    if(0 == dwRowCount)
    {
        //
        // There are no fax recipients
        //
        goto ErrorExit;
    }

    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();

    hResult = HrAddColumns(
        pTable,
        (LPSPropTagArray) &sptRecipTable,
        gpfnAllocateBuffer,
        gpfnFreeBuffer
        );
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    hResult = HrQueryAllRows(
        pTable,
        NULL,
        NULL,
        NULL,
        0,
        &pRecipRows
        );
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();

    //
    //Get the message properties
    //
    hResult = pMsgObj->GetProps(
                (LPSPropTagArray) &sptPropsForHeader, 
                0, 
                &cValues, 
                &pMsgProps
                );
    if (!HR_SUCCEEDED(hResult)) 
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProps"), hResult);
        goto ErrorExit;
    }

    hResult = pMsgObj->OpenProperty(
                PR_RTF_COMPRESSED, 
                &IID_IStream, 
                0, 
                0, 
                (LPUNKNOWN*) &lpstmT
                );
    if (FAILED(hResult)) 
    {
        hResult = pMsgObj->OpenProperty(
                    PR_BODY, 
                    &IID_IStream, 
                    0, 
                    0, 
                    (LPUNKNOWN*) &lpstmT
                    );
        if (FAILED(hResult)) 
        {
            //
            // the message body is empty
            //
            lpstmT = NULL;
        }
        hResult = S_OK;
    } 
    else 
    {
        UseRichText = TRUE;
    }
   
    
    if (PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED == pMsgProps[MSG_DR_REPORT].ulPropTag && pMsgProps[MSG_DR_REPORT].Value.b) 
    {
        NeedDeliveryReport = TRUE;
    } 
    else 
    {
        NeedDeliveryReport = FALSE;
    }

    GetSystemTime (&st);
  	if(!SystemTimeToFileTime(&st, &ft))
	{
        dwRslt = ::GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("SystemTimeToFileTime"), dwRslt);
    }
    //
    // submit the fax 
    //
    dwRslt = SendFaxDocument
            ( 
            pMsgObj, 
            lpstmT, 
            UseRichText, 
            pMsgProps, 
            pRecipRows,
			&dwRecipientsLimit
            );

    bSentSuccessfully = (dwRslt == S_OK);

    for (ulRow=0; ulRow<pRecipRows->cRows; ulRow++) 
    {
        pProps = pRecipRows->aRow[ulRow].lpProps;

        //
        // Update the PR_RESPONSIBILITY to TRUE, so that MAPI will ask another transport 
        // provider to try and send it.
        //
        pProps[RECIP_RESPONSIBILITY].ulPropTag = PR_RESPONSIBILITY;
        pProps[RECIP_RESPONSIBILITY].Value.b = TRUE;
            
        if (!bSentSuccessfully) 
        {
            //
            // for each recipient: insert NDR string as a property value, update delivery time as NULL, 
            // and live the PR_RESPONSIBILITY == false, so that MAPI will try to send the fax via another 
            // transport provider. 
            //
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_NULL;
            LoadString( g_hResource, IDS_FAILED_MESSAGE, FailedText, sizeof(FailedText) / sizeof(FailedText[0]));
			if (IDS_RECIPIENTS_LIMIT == dwRslt)
			{
				//
				// Recipient limit NDR
				//
				TCHAR TmpErrorText[1024] = {0};								

				LoadString( g_hResource, dwRslt, TmpErrorText, ARR_SIZE(TmpErrorText));
				_sntprintf( ErrorText, ARR_SIZE(ErrorText)-1, TmpErrorText, pRecipRows->cRows, dwRecipientsLimit);				
			}
			else
			{
				LoadString( g_hResource, dwRslt, ErrorText, sizeof(ErrorText) / sizeof(ErrorText[0]));
			}
            
            _sntprintf( szHeaderText, ARR_SIZE(szHeaderText)-1, _T("\t%s\r\n\t%s\r\n"),FailedText, ErrorText);
			LPSTR pTmpStr = ConvertTStringToAString(szHeaderText);
            if (!pTmpStr)
            {
                hResult = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;                
            }
            LPSTR pStrA;
            hResult = gpfnAllocateMore( CbtszsizeA(pTmpStr), pProps, (LPVOID *)&pStrA );
            if (SUCCEEDED(hResult)) 
            {
                //
                // Copy the formatted string and hook it into the pre-allocated (by MAPI) column
                //
                _mbscpy ((PUCHAR)pStrA, (PUCHAR)pTmpStr);//pStrA is preAllocated. no need to check for NULL
                pProps[RECIP_REPORT_TEXT].ulPropTag = PR_REPORT_TEXT_A;
                pProps[RECIP_REPORT_TEXT].Value.lpszA = pStrA;
            } 
            else 
            {
                pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
                pProps[RECIP_REPORT_TEXT].Value.err = hResult;
            }
			MemFree(pTmpStr);
            pTmpStr = NULL;
            gpfnFreeBuffer(pStrA); //allocated with gpfnAllocateMore which is MAPIAllocateMore
            pStrA = NULL;
        } 
        else 
        {
            //
            // for each recipient: insert DR string as a property value, update delivery time, 
            // For delivery report, each recipient must have this property set.
            // Otherwise the spooler will default to generate an NDR instead.
            //
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_DELIVER_TIME;
            pProps[RECIP_DELIVER_TIME].Value.ft = ft;

            pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
            pProps[RECIP_REPORT_TEXT].Value.err = S_OK;
        }

        //
        // add this recipient to a recipients list, that includes only the recipients we've tried 
        // to send to. (we either succeeded to queue all of them or we failed to queue all of them).
        //

        //
        // Does the list where this recipient goes have enough room for one more entry?
        // If not, resize the address list to hold QUERY_SIZE more entries.
        //
        if (!(pOurAdrList ) || ((pOurAdrList)->cEntries + 1 > ulRecipCount)) 
        {
            hResult= GrowAddressList( &pOurAdrList , 10, &ulRecipCount );
            if (FAILED(hResult))
            {
                goto ErrorExit;
            }
        }

        //
        // We have room now so store the new ADRENTRY. As part of the
        // storage, we're going to copy the SRow pointer from the SRowSet
        // into the ADRENTRY. Once we've done this, we won't need the
        // SRowSet any more ... and the SRow will be released when
        // we unwind OurAdrList
        //
        (pOurAdrList)->aEntries[(pOurAdrList)->cEntries].cValues = pRecipRows->aRow[ulRow].cValues;
        (pOurAdrList)->aEntries[(pOurAdrList)->cEntries].rgPropVals = pRecipRows->aRow[ulRow].lpProps;

        //
        // Increase the number of entries in the address list
        //
        (pOurAdrList)->cEntries++;
    }


    //
    // Now we need to save changes on the message and close it.
    // After this, the message object can't be used.
    //
    hResult = pMsgObj->SaveChanges(0);
    switch (hResult)
    {
        case S_OK:  
        case MAPI_E_NO_ACCESS:
                    break;
        case MAPI_E_OBJECT_DELETED:

        case MAPI_E_OBJECT_CHANGED:
                    goto ErrorExit;
        default:    break;
    }

    
    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();
     
    //
    // change our MsgObj's recipients list, so that it'll include only those that got the message.
    //
    if(pOurAdrList)
    {
        hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pOurAdrList);
        hResult = S_OK; 
        //
        // We'll drop the error code from the modify recipients call
        //
    }
        
    if (bSentSuccessfully) 
    {    
        if ((NeedDeliveryReport) && (pOurAdrList))
		{
			VERBOSE (DBG_MSG, TEXT("xport\\xplogon.cpp\\SubmitMessage: Sending delivery Report"));
        	//
            //let spooler know he has to send delivery rec. to those addresses. 
            //
			hResult = m_pSupObj->StatusRecips( pMsgObj, pOurAdrList);
            if (!HR_FAILED(hResult))
			{
				//
                // If we were successful, we should null out the pointer becase MAPI released
				// the memory for this structure. And we should not try to release it
				// again in the cleanup code.
                //
				pOurAdrList = NULL;
	        }
        }
    }

    if (! bSentSuccessfully) 
    {
        if(pOurAdrList)
        {
            hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pOurAdrList);

            //
            // We'll drop the error code from the modify recipients call
            //
            VERBOSE (DBG_MSG, TEXT("xport\\xplogon.cpp\\SubmitMessage: Sending UnDelivery Report"));
            //
            //let spooler know he has to send undelivery rec. to those addresses. 
            //
            hResult = m_pSupObj->StatusRecips( pMsgObj, pOurAdrList);
            if (!HR_FAILED(hResult)) 
            {
                //
                // If we were successful, we should null out the pointer becase MAPI released
                // the memory for this structure. And we should not try to release it
                // again in the cleanup code.
                //
                pOurAdrList = NULL;
            }
        }
    }

ErrorExit:
     //
     // Release the table, we're finished with it
     //
    if (pTable) 
    {
        pTable->Release();
    }

    if (pRecipRows) 
    {
        FreeProws( pRecipRows );
    }

    if (pMsgProps) 
	{
        MAPIFreeBuffer( pMsgProps );
		pMsgProps = NULL;
    }

    if (lpstmT) 
    {
        lpstmT->Release();
    }
    if(pOurAdrList)
    {
        MAPIFreeBuffer(pOurAdrList);    
    }
    
    //
    // In case there is a warning or error floating around, don't let it escape to the spooler.
    //
    if (FAILED(hResult)) 
    {
        //
        // We default to MAPI_E_NOT_ME so that the spooler would attempt handle
        // the message to other transport (currently running in this profile)
        // that handle the same address type as ours.
        //
        hResult = MAPI_E_NOT_ME;
    } 
    else 
    {
        hResult = S_OK;
    }
	return hResult;
}


STDMETHODIMP
CXPLogon::GrowAddressList(
    LPADRLIST *ppAdrList,
    ULONG     ulResizeBy,
    ULONG     *pulOldAndNewCount
    )

/*++

Routine Description:

    In this function, given an address list with pulOldAndNewCount of
    entries, we resize the address list to hold the old number of
    entries plus the ulResizeBy entries. The old address list contents
    are copied to the new list and the count reset. The memory for the
    old address list is released here.

Arguments:

    ppAdrList           - Pointer to an address where the old address list
                          is and where the new resized address list will
                          be returned
    ulResizeBy          - Number of new address entries to add to the list
    pulOldAndNewCount   - Number of entries in the old address list. In
                          this parameter, upon sucessful return, will have
                          the number of in the new address list

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::GrowAddressList"),hResult);

    LPADRLIST pNewAdrList;
    // Calculate how big the new buffer for the expanded address list should be
    ULONG cbSize = CbNewADRLIST ((*pulOldAndNewCount) + ulResizeBy);
    // Allocate the memory for it
    hResult = gpfnAllocateBuffer (cbSize, (LPVOID *)&pNewAdrList);
    if (FAILED(hResult))
    {
        // We can't continue
        return hResult;
    }

    // Zero-out all memory for neatness
    ZeroMemory (pNewAdrList, cbSize);

    // If we had entries in the old address list, copy the memory from
    // the old addres list into the new expanded list
    if ((*pulOldAndNewCount)) 
    {
        CopyMemory( pNewAdrList, *ppAdrList, CbNewADRLIST ((*pulOldAndNewCount)) );
    }

    // Set the number of entries in the new address list to the OLD size
    pNewAdrList->cEntries = (*pulOldAndNewCount);

    // We must return the number of available entries in the new expanded address list
    (*pulOldAndNewCount) += ulResizeBy;

    // Free the old memory and put the new pointer in place
    gpfnFreeBuffer (*ppAdrList);
    *ppAdrList = pNewAdrList;
    return hResult;
}


STDMETHODIMP
CXPLogon::EndMessage(
    ULONG ulMsgRef,
    ULONG *pulFlags
    )

/*++

Routine Description:

    This method is called by the spooler for each message we're to
    deliver. It's the mate to SubmitMessage. We're called here twice
    for each deferred message and once for non-deferred (realtime)
    messages.

    We first check the transport state, and if we're
    WAITING for the scheduled delivery time to arrive, we return
    END_DONT_RESEND in *pulFlags, which tells the spooler to queue this
    message for deferred delivery.

    If the state is SENDING, we're getting called here after
    a message has been dequeued and delivered. Return 0 in *pulFlags
    to tell the spooler the message has been delivered.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::EndMessage"),hResult);

    *pulFlags = 0;
    return hResult;
}


STDMETHODIMP
CXPLogon::Poll(
    ULONG *pulIncoming
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::StartMessage(
    ULONG      ulFlags,
    LPMESSAGE  pMsgObj,
    ULONG *    pulMsgRef
    )

/*++

Routine Description:

    This method gets called when an incoming message is pending to be
    processed.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::StartMessage"));
	
	//
	//We should not get called here since we don't deal with incoming messages
	//
	Assert(false);
    return S_OK;
}


STDMETHODIMP
CXPLogon::OpenStatusEntry(
    LPCIID          pInterface,
    ULONG           ulFlags,
    ULONG *         pulObjType,
    LPMAPISTATUS *  ppEntry
    )

/*++

Routine Description:

    This method is called to get an IMAPIStatus object for this XPLOGON
    session.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::OpenStatusEntry"),hResult);
	
    if (MAPI_MODIFY & ulFlags) 
    {
		hResult = E_ACCESSDENIED;
        goto exit;
    }

    *pulObjType = MAPI_STATUS;

exit:
    return hResult;
}


STDMETHODIMP
CXPLogon::ValidateState(
    ULONG ulUIParam,
    ULONG ulFlags
    )

/*++

Routine Description:

    This function gets caller by a client in order to validate the
    transport logon properties. This function open the profile with the
    most up-to-date properties and then compares them to what the transport
    has stored internally.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::FlushQueues(
    ULONG       ulUIParam,
    ULONG       cbTargetTransport,
    LPENTRYID   pTargetTransport,
    ULONG       ulFlags
    )

/*++

Routine Description:

    Called by the MAPI spooler when, upon request of the client or
    ourselves, we need to flush the inbound or outbound queue.
    Here we make connections to the server to download messages, refresh
    the remote message headers, and request the spooler to send us any
    deferred messages.
    Transport connecting only in FlushQueues() allow the MAPI spooler to
    better manage contention of multiple transport accessing common
    communication resources (such as COM ports) and let the spooler give us
    messages to process when is best for the overall subsystem.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}

void WINAPI
CXPLogon::CheckSpoolerYield(
    BOOL fReset
    )

/*++

Routine Description:

    Enforce the 0.2 second rule for transport that need to yield to the
    MAPI spooler.  Called periodically while processing a message to
    determine if we have used more than 0.2 seconds.  If so, then call
    SpoolerYield(), else just continue.
    This is called with fReset set to TRUE when we first enter one
    of the Transport Logon methods (usually one that is known to
    take a long time like StartMessage() or SubmitMessage(). )

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    DWORD dwStop;
    static DWORD dwStart;
    if (fReset)
    {
        dwStart = GetTickCount();
    }
    else
    {
        dwStop = GetTickCount();
        if ((dwStop - dwStart) > 200) // 200 milliseconds
        {
            m_pSupObj->SpoolerYield (0);
            dwStart = GetTickCount();
        }
    }
}

STDMETHODIMP_(ULONG)
CXPLogon::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPLogon::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) 
    {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\awcpe.cpp ===
//--------------------------------------------------------------------------
// AWCPE.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      main module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include <tchar.h>
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include <shlobj.h>
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"
#include <dos.h>
#include <direct.h>
#include <cderr.h>
#include "faxreg.h"
#include "faxutil.h"
#include <faxres.h>
#include "cvernum.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define ENFORCE_FILE_EXTENSION_ON_OPEN_FILE 0
#define SHOW_ALL_FILES_FILTER 1


#define BIGGERTHAN_RECT          1
#define NOTSETBY_RECT            0
#define SMALLERTHAN_RECT        -1





UINT NEAR WM_AWCPEACTIVATE = ::RegisterWindowMessage(TEXT("AWCPE_ACTIVATE"));

BYTE BASED_CODE _gheaderVer1[20]={0x41,0x57,0x43,0x50,0x45,0x2D,0x56,0x45,0x52,0x30,0x30,0x31,0x9C,0x87,0x00,0x00,0x00,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer2[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x32,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer3[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x33,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer4[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x34,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5w[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5a[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x61,0x87,0x00,0x00,0x00};

static TCHAR szShellPrintFmt[] = _T("%s\\shell\\print\\command");
static TCHAR szShellOpenFmt[] = _T("%s\\shell\\open\\command");
static TCHAR szShellDdeexecFmt[] = _T("%s\\shell\\open\\ddeexec");
static TCHAR szStdOpenArg[] = _T(" \"%1\"");
static TCHAR szStdPrintArg[] = _T(" /P \"%1\"");
static TCHAR szDocIcon[] = TEXT("%s\\DefaultIcon");
static const TCHAR szDocIconArg[] = _T(",1");






CDrawApp NEAR theApp;


//-------------------------------------------------------------------------
CDrawApp::CDrawApp() : 
   m_iErrorCode(EXIT_SUCCESS),
   m_pFaxMap(NULL),
   m_pIawcpe(NULL),
   m_hMod(NULL),
   m_note(NULL),
   m_note_wasread(FALSE),
   m_note_wasclipped(FALSE),
   m_extrapage_count(0),
   m_more_note(FALSE),
   m_last_note_box(NULL),
   m_note_wrench(NULL),
   m_extra_notepage(NULL),
   m_bRTLUI(FALSE)
{}

//-------------------------------------------------------------------------
CDrawApp::~CDrawApp()
{

   if (m_pFaxMap)
      delete m_pFaxMap;

        if( m_note != NULL )
                delete m_note;

        if( m_note_wrench != NULL )
                delete m_note_wrench;

        if( m_extra_notepage != NULL )
                delete m_extra_notepage;
    //
    // Bug 39861 :  The app crashes AFTER the above code is executed!
    // (only if bogus paths are entered on command line, and mostly only in the UNICODE
    //  version!!)
    // Time to try quick and dirty workarounds!
}


//-------------------------------------------------------------------------
int CDrawApp::ExitInstance()
{
#ifndef _AFXCTL
        SaveStdProfileSettings();
#endif

   if (m_hSem)
   {
      CloseHandle(m_hSem);
   }

   //clean up code if we were rendering
   if ( m_dwSesID!=0 && m_pIawcpe )
   {
        TRACE(TEXT("AWCPE: Release() interface object \n"));
        m_pIawcpe->Release();

        m_pIawcpe=NULL;
        if( m_hMod )
        {
            FreeLibrary( m_hMod );
        }
   }

   FreeResInstance();

   TRACE(TEXT("AWCPE: Fax cover page editor exiting with error code: '%i'\n"),m_iErrorCode);

   return m_iErrorCode;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileOpen()
{
   //
   // If a document is open, query user for saving changes.
   //
   // This fixes part of the problem described in NT bug 53830.
   //
   CDrawDoc * pDoc = CDrawDoc::GetDoc();

#if 0

   // I really wish we could prompt for saving changes BEFORE we prompt for the file name.
   // But this MAY lead to double prompting.  If the user choses not to save on this prompt, then
   // there will be a second SAVE CHANGES prompt.

   if( pDoc && !pDoc->/*COleDocument::*/SaveModified()) return ; /// SaveModified now overridden!!
#endif

   CString newName;

   if (!DoPromptFileName(newName, AFX_IDS_OPENFILE,
     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, NULL))
        return;
   OpenDocumentFile(newName);
}


//-------------------------------------------------------------------------
CDocument* CDrawApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
#ifdef _DEBUG
   if (lpszFileName != NULL)
       TRACE1("AWCPE: opening document '%s'\n",lpszFileName);
   else
       TRACE(TEXT("AWCPE: opening new document\n"));
#endif

    BOOL OldFileVersion = TRUE ;
   _tcsupr((TCHAR *)lpszFileName);

   CString FileName = lpszFileName ;
   FileName.MakeUpper();
#if ENFORCE_FILE_EXTENSION_ON_OPEN_FILE
   CString Tail = FileName;
   if( Tail.Right(4) != FAX_COVER_PAGE_FILENAME_EXT && Tail.Right(4) != TEXT( ".CPE" )){
       FileName += FAX_COVER_PAGE_FILENAME_EXT;
   }
#endif

   if (*lpszFileName != 0) 
   {
      CFile file;
      if (!file.Open(FileName,CFile::modeRead)) 
      {
          if (m_dwSesID!=0) 
          {   
              //rendering // Not using this command line option! a-juliar
              TRACE1("AWCPE error:  unable to find file '%s'\n",(LPCTSTR)FileName);
              return NULL;
          }
          else 
          {
              CString sz;
              CString szFmt;
              sz.LoadString(IDS_MISSING_FILE);
              int iLength=sz.GetLength() + FileName.GetLength() + 2; //// ??????????????????
              wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
              szFmt.ReleaseBuffer();
              CPEMessageBox(MSG_ERROR_MISSINGFILE, szFmt, MB_OK | MB_ICONEXCLAMATION);
          }
          return NULL;
      }
      int i = sizeof(_gheaderVer1);
      BYTE* p = new BYTE[i];
      CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = TRUE ;
      file.Read(p,i);
      if (memcmp(_gheaderVer1,p,i)==0) {
              CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION1;
                  TRACE(TEXT("AWCPE info:  loading version 1 document\n"));
      }
      else if (memcmp(_gheaderVer2,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION2;
             TRACE(TEXT("AWCPE info:  loading version 2 document\n"));
      }
      else if (memcmp(_gheaderVer3,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION3;
             TRACE(TEXT("AWCPE info:  loading version 3 document\n"));
      }
      else if (memcmp(_gheaderVer4,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION4;
             TRACE(TEXT("AWCPE info:  loading version 4 document\n"));
      }
      else if (memcmp(_gheaderVer5w,p,i)==0) 
      {
             CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = FALSE ;
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
             TRACE(TEXT("AWCPE info:  loading version 5w document\n"));
             OldFileVersion = FALSE ;
      }
      else if (memcmp(_gheaderVer5a,p,i)==0){
          CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
          TRACE(TEXT("AWCPE info:  loading version 5a document\n"));
      }
      else {
          CDrawDoc::GetDoc()->m_iDocVer=-1;
      }
      if (CDrawDoc::GetDoc()->m_iDocVer==-1) {
              if (m_dwSesID!=0) {
                  TRACE1(
                    "AWCPE error:  '%s' is not a valid version .COV file-cannot open\n",lpszFileName); // FILE EXTENSION
                    return NULL;
              }
              CString sz;
              CString szFmt;
              sz.LoadString(IDS_INVALID_FILE);
              int iLength=sz.GetLength()+ FileName.GetLength() + 2; //?????????????????????
              wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
              szFmt.ReleaseBuffer();
              CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
              return NULL;
      }
           if (p)
               delete [] p;
   }

   CDocument* pDoc =  CWinApp::OpenDocumentFile((LPCTSTR)FileName); // Calls Serialize()

   if( !pDoc ) return NULL ; /// This will help fix NT bug 53830 for the case when
                             /// CDrawApp::OpenDocumentFile is called by the FRAMEWORK,
                             /// byapssing CDrawApp::OnFileNew.  When the serialization
                             /// fails, pDoc is not NULL, and this is handled below.
                             /// This is not a perfect fix --- If the document being opened
                             /// came from the MRU list, it gets removed from the MRU list.

   if( pDoc && !( CDrawDoc::GetDoc()->m_bSerializeFailed )){
       CDrawDoc::GetDoc()->UpdateAllViews(NULL);
   }
   else {
       CString sz;
       CString szFmt;
       sz.LoadString(IDS_CORRUPT_FILE);
       int iLength=sz.GetLength() + FileName.GetLength() + 2;
       wsprintf(szFmt.GetBuffer(iLength), sz, lpszFileName);
       szFmt.ReleaseBuffer();
       CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
       OnFileNew();
       return NULL ;
   }
   if( pDoc && OldFileVersion ){
       pDoc->SetModifiedFlag(); /// Conversion to this file format is a change worth prompting to save.
   }
   return pDoc;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileNew()
{
   CWinApp::OnFileNew();

   if (CDrawDoc::GetDoc()->m_wOrientation!=DMORIENT_PORTRAIT) {
       CDrawDoc::GetDoc()->m_wPaperSize = GetLocaleDefaultPaperSize();
       CDrawDoc::GetDoc()->m_wOrientation=DMORIENT_PORTRAIT;
       CDrawDoc::GetDoc()->m_wScale = 100;
       CDrawDoc::GetDoc()->ComputePageSize();
   }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::IsSecondInstance()
{
    m_hSem = CreateSemaphore(NULL,0,1,TEXT("AWCPE-Instance Semaphore"));
    if (m_hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(m_hSem);
        m_hSem=NULL;
        if (::SendMessage(HWND_TOPMOST,WM_AWCPEACTIVATE,0,0)==1L)
           return TRUE;  // 1st instance app responded;  close this instance
                else
           return FALSE; // 1st instance app didnt respond; may have crashed.  open this instance.
    }
    return FALSE;
}


void CDrawApp::filter_mru_list( void )
{
        int num_files;
        int i, j;
        TCHAR keystr[100];

        num_files = m_pRecentFileList->m_nSize;

        for( i=0; i<num_files; i++ ) {
                if( m_pRecentFileList->m_arrNames[i].IsEmpty() ) // i.e. == ""
                        break;

                if( GetFileAttributes( m_pRecentFileList->m_arrNames[i] ) == 0xffffffff ) {
                        for( j=i+1; j<num_files; j++ ) {
                                m_pRecentFileList->m_arrNames[j-1] =
                                        m_pRecentFileList->m_arrNames[j];
                        }

                        m_pRecentFileList->m_arrNames[j-1] = "";

                        i--; // back up so we start at first one that got schooted
                        }
                }

        if ( i < num_files ) {
                // have to clean up ini or they might come back next time
                for( ;i < num_files; i++ ) {
                        wsprintf( keystr, m_pRecentFileList->m_strEntryFormat, i+1 ); //???????????

                        // delete empty key
                        WriteProfileString( m_pRecentFileList->m_strSectionName,
                                                                keystr, NULL );
                        }

                // now have to write out modified list so that the right
                // keys are associated with the right names
                m_pRecentFileList->WriteList();
                }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::InitInstance()
{  
    HINSTANCE hRes = GetResInstance(NULL);
    if(!hRes)
    {
        return FALSE;
    }

    AfxSetResourceHandle(hRes);


    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        m_bRTLUI = TRUE;
        SetRTLProcessLayout();
    }

    //
    // GetClientCpDir() creates Personal cover pages folder
    // if it is not exist
    // 
    TCHAR tszCovDir[MAX_PATH+1];
    GetClientCpDir(tszCovDir, ARR_SIZE(tszCovDir));


    SetErrorMode( SetErrorMode( 0 ) | SEM_NOALIGNMENTFAULTEXCEPT );

    ParseCmdLine();                     //1st thing done
    m_bUseDefaultDirectory = TRUE ;     // Used only the first time we open a file.
    SetRegistryKey( _T("Microsoft") );  //caused MFC to write app settings to registry

    AfxEnableWin40Compatibility();    //this app is intended for Windows 4.0 compatibility

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        CPEMessageBox(MSG_ERROR_OLEINIT_FAILED, NULL, MB_OK | MB_ICONSTOP,IDP_OLE_INIT_FAILED);
        return FALSE;
    }

    Enable3dControls();        // loads CTL3D32.DLL
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    filter_mru_list();

    /*
        Register the application's document templates.  Document templates
        serve as the connection between documents, frame windows and views.

                CCpeDocTemplate is a derivation of CSingleDocTemplate used to
                override some default MFC behavior. See CCpeDocTemplate::MatchDocType
                below.
         */
    CCpeDocTemplate* pDocTemplate;
    pDocTemplate = new CCpeDocTemplate(
        IDR_AWCPETYPE,
        RUNTIME_CLASS(CDrawDoc),
        RUNTIME_CLASS(CMainFrame),
        RUNTIME_CLASS(CDrawView));
    pDocTemplate->SetContainerInfo(IDR_AWCPETYPE_CNTR_IP);
    AddDocTemplate(pDocTemplate);

    EnableShellOpen();
    RegistryEntries();

    InitFaxProperties();

    if (m_bCmdLinePrint) 
    {
       CmdLinePrint();
           return FALSE;
    }
    if (m_dwSesID!=0) 
    {
     ////  CmdLineRender();
           return FALSE;
    }
    CDocument * pDoc = NULL ;
    if (m_szFileName.IsEmpty())
       OnFileNew();
    else 
    {
       OnFileNew();   //m_pMainWnd needs to be initialized
       pDoc = OpenDocumentFile(m_szFileName);
    }
    if(!pDoc)
    {
        TCHAR tmpEnv[20];
        TCHAR DefaultDir[MAX_PATH];
        DWORD InstalledType = 0 ;
        HKEY hKey = NULL;
        DWORD dwKeyValueType ;
        DWORD dwsz = sizeof(DWORD)/sizeof(BYTE);
        DWORD dwSize = MAX_PATH;

        //
        // this gets set by fax control panel coverpage tab
        //
        if (GetEnvironmentVariable(TEXT("ClientCoverpage"),tmpEnv,sizeof(tmpEnv)/sizeof(TCHAR)) != 0 ) 
        {
            if(!GetClientCpDir(DefaultDir, sizeof(DefaultDir) / sizeof(DefaultDir[0])))
            {
                DefaultDir[0] = 0;
            }
        }   
        else 
        {
            
            //
            // Set default directory to
            //     server:      %SystemRoot%\system\spool\drivers\CoverPage
            //     workstation: %SystemRoot%\system32\spool\drivers\CoverPage
            //     client:      ...\My Documents\Fax\Peronal Coverpages
            //            
            if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                                REGKEY_FAX_SETUP,
                                                0,
                                                KEY_READ,
                                                &hKey)
                && ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                    REGVAL_FAXINSTALL_TYPE,
                                                    0,
                                                    &dwKeyValueType,
                                                    (LPBYTE)&InstalledType,
                                                    &dwsz)) 
            {
                //
                // set the default dir
                //
                
                if ((InstalledType & FAX_INSTALL_SERVER) || (InstalledType & FAX_INSTALL_WORKSTATION)) 
                {
                    ExpandEnvironmentStrings( DEFAULT_COVERPAGE_DIR , DefaultDir, MAX_PATH );
                } 
                else if (InstalledType & FAX_INSTALL_NETWORK_CLIENT) 
                {
                    if(!GetClientCpDir(DefaultDir, sizeof(DefaultDir) / sizeof(DefaultDir[0])))
                    {
                        DefaultDir[0] = 0;
                    }
                } 
                else 
                {
                    DefaultDir[0] = 0;
                }
            }        
        }

        //
        // this invokes a copy constructor that copies the data from the array
        //
        m_szDefaultDir = DefaultDir;            
                
        if (hKey) {
            RegCloseKey( hKey );
        }
        
    }

    OnIdle(0);  // updates buttons before showing the window

    if (m_pMainWnd) 
    {
       m_pMainWnd->DragAcceptFiles();
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(1,_T(""));
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(2,_T(""));
    }

    if (!m_pMainWnd->IsIconic()) 
    {
        CString sz = GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
        if ((sz==_T("YES")) && (!IsInConvertMode()))
        {
            //
            // supress the tool tips dialog in case the user ask to suppress it OR the 
            // application was launched to convert old cover pages CPE to COV.
            //
            CSplashTipsDlg m_SplashDlg (TRUE);
            m_SplashDlg.DoModal();
        }
    }

    InitRegistry();

    m_hMoveCursor = LoadCursor(IDC_MOVE);
    
    if (IsInConvertMode())
    {
        OnAppExit();
    }

    return TRUE;
}


//------------------------------------------------------------------------------------------------
void CDrawApp::RegistryEntries()
{
    CString PrintCmdLine;
    CString OpenCmdLine;
    CString DefaultIconCmdLine;
    CString szBuff;
    TCHAR szExe[MAX_PATH+1]={0};
    CString strFilterExt, strFileTypeId, strFileTypeName;

    RegisterShellFileTypes();

#if _MFC_VER >= 0x0400
//  ASSERT( !GetFirstDocTemplatePosition() );
#else
    ASSERT(!m_templateList.IsEmpty());  // must have some doc templates
#endif

    ::GetModuleFileName(AfxGetInstanceHandle(), szExe, ARR_SIZE(szExe)-1);

    PrintCmdLine.Format( TEXT("%s%s"), szExe, szStdPrintArg );
    OpenCmdLine.Format( TEXT("%s%s"), szExe, szStdOpenArg  );
    DefaultIconCmdLine.Format( TEXT("%s%s"), szExe, szDocIconArg  );

#if _MFC_VER >= 0x0400
    POSITION pos = GetFirstDocTemplatePosition();
#else
    POSITION pos = m_templateList.GetHeadPosition();
#endif
    if (pos != NULL)    {       //only 1 document type
#if _MFC_VER >= 0x0400
           CDocTemplate* pTemplate =
                        (CDocTemplate*)GetNextDocTemplate( pos );
#else
           CDocTemplate* pTemplate =
                        (CDocTemplate*)m_templateList.GetNext(pos);
#endif
           if (pTemplate->GetDocString(strFileTypeId,
              CDocTemplate::regFileTypeId) && !strFileTypeId.IsEmpty()) {

                if (!pTemplate->GetDocString(strFileTypeName,
                      CDocTemplate::regFileTypeName))
                        strFileTypeName = strFileTypeId;    // use id name

                ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed

                szBuff.Format( szShellOpenFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)OpenCmdLine,
                                          OpenCmdLine.GetLength() );

                szBuff.Format( szShellPrintFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)PrintCmdLine,
                                          PrintCmdLine.GetLength() );

                        szBuff.Format( szDocIcon, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)DefaultIconCmdLine,
                                          DefaultIconCmdLine.GetLength() );

            //delete the shell\open\ddeexec key to force second instance
                //Normally, this would be done by not calling EnableShellOpen(instead of removing the ddeexec key),
                //but there seems to be a bug in MFC or Win95 shell
                szBuff.Format( szShellDdeexecFmt, (LPCTSTR)strFileTypeId );
            ::RegDeleteKey(HKEY_CLASSES_ROOT, (LPCTSTR)szBuff);
           }
    }
}



//------------------------------------------------------------------------------------------------
void CDrawApp::InitRegistry()
{
        //set registry section
    HKEY hKey = NULL;
    DWORD dwsz;
    DWORD dwType;
    DWORD dwDisposition;
    const LPCTSTR szCmdLineExt=_T(" /SSESS_ID");
    HINSTANCE hInst = AfxGetInstanceHandle();

    TCHAR szExeName[_MAX_PATH + 10] = {0};

    if (!hInst)
    {
        //
        //  Failed to get Module instance
        //
        TRACE1("AWCPE Error: AfxGetInstanceHandle() failed: '%ld'.\n", GetLastError());
        return;
    }

    if ( 0 == ::GetModuleFileName(hInst, szExeName, _MAX_PATH))
    {
        //
        //  Failed to get Module File Name
        //
        TRACE1("AWCPE Error: GetModuleFileName() failed: '%ld'.\n", GetLastError());
        return;
    }

    _tcscat(szExeName,szCmdLineExt);

    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS) 
    {
       if (::RegQueryValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, &dwType, NULL, &dwsz) == ERROR_SUCCESS) 
       {
          if (dwsz==0) 
          {
                if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, _tcsclen(szExeName)+1) != ERROR_SUCCESS)
                {
                    TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
                }
          }
       }
       else 
       {
            if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, _tcsclen(szExeName)+1) != ERROR_SUCCESS) 
            {
                TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
            }
       }
    }
    else 
    {
        DWORD dwRes;
        dwRes = ::RegCreateKeyEx(HKEY_CURRENT_USER, 
            CPE_SUPPORT_ROOT_KEY, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE, 
            KEY_READ | KEY_WRITE, 
            NULL, 
            &hKey, 
            &dwDisposition);

        if ( dwRes == ERROR_SUCCESS )
        {
            ::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ, (LPBYTE)szExeName, _tcsclen(szExeName)+1 ); ///????????????
            TRACE1("AWCPE Information: Created and added my key '%s' \n", szExeName);
        }
        else
        {
            TRACE1("AWCPE Error: RegCreateKeyEx failed: '%ld' \n", dwRes);
        }
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }
}


//-------------------------------------------------------------------
void CDrawApp::CmdLinePrint()
{
    try {
       if (!Print() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

        if (m_pMainWnd)
            m_pMainWnd->SendMessage(WM_CLOSE);
 }

//-------------------------------------------------------------------
///#if 0
void CDrawApp::CmdLineRender()
{
    try {
       if (! Render() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

    if (m_pMainWnd)
           m_pMainWnd->SendMessage(WM_CLOSE);
 }
///#endif

//-------------------------------------------------------------------
BOOL CDrawApp::Print()
{
   m_nCmdShow = SW_MINIMIZE;
   OnFileNew();
   m_nCmdShow = SW_MINIMIZE;

   if (OpenDocumentFile(m_szFileName)==NULL) {
      TRACE1("AWCPE: unable to open file: '%s'\n",m_lpCmdLine);
      return FALSE;
   }

   ((CFrameWnd*)m_pMainWnd)->GetActiveView()->SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));
   return TRUE;
}



//-------------------------------------------------------------------
///#if 0
BOOL CDrawApp::Render()
{
    return FALSE ;

//
// Not sure what to do about the GetProcAddress call, so I have commented it out.
//
#if 0
    int i=1;
    TCHAR szTemp[_MAX_PATH];
    ULONG lLen=_MAX_PATH;
    LPTSTR szDLL=NULL;       //render DLL
    LPTSTR szfName=NULL;     //entry point name
    SCODE sc;
    DWORD lszDLL=_countof(szDLL);
    DWORD lszfName = _countof(szfName);
    LPVOID lpMsgBuf;
    DWORD dwType;
    BOOL bReturn=TRUE;
    HKEY hKey = NULL;
        UINT OldErrMode;
        CDocTemplate* pTemplate = NULL;
        CDrawDoc *pDoc;


    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0,KEY_READ, &hKey) != ERROR_SUCCESS) {
            TRACE1("AWCPE Critical: registration database openkey failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

//ALLOCATE SPACE FOR RENDER DLL AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, NULL, &lszDLL) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
        szDLL = new TCHAR[lszDLL+sizeof(TCHAR)];
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, NULL, &lszfName) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
           szfName = new TCHAR[lszfName+sizeof(TCHAR)]; //????????????? was TCHAR.

//FETCH RENDER DLL NAME AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, (LPBYTE)szDLL, &lszDLL) != ERROR_SUCCESS) {
            TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, (LPBYTE)szfName, &lszfName) != ERROR_SUCCESS) { ///???????
        TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

    if (*szDLL==0 || *szfName==0) {
            TRACE(TEXT("AWCPE Warning: registration database fetch failed\n"));
            bReturn=FALSE;
                goto exit;
    }

//FETCH ENTRY POINT ADDRESS

    OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
    m_hMod = ::LoadLibrary(szDLL);
    if (m_hMod==NULL) 
    {
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                        NULL,
                        ::GetLastError(), 
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &lpMsgBuf, 
                        0, 
                        NULL );
        TRACE3("AWCPE error: %s %s %s\n",lpMsgBuf, szDLL, szfName);
        bReturn=FALSE;
        goto exit;
    }
    ::SetErrorMode (OldErrMode);

    AWCPESUPPORTPROC pfn;
    if ( (pfn = (AWCPESUPPORTPROC) ::GetProcAddress(m_hMod, szfName))==NULL) 
    {
        LPVOID lpMsgBuf;
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                        NULL,
                        ::GetLastError(), 
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &lpMsgBuf, 
                        0, 
                        NULL );
        TRACE1("AWCPE error: GetProcAddress returns %s\n",lpMsgBuf);
        bReturn=FALSE;
        goto exit;
    }

//FETCH WINDOWS OBJECT (USED TO FETCH FAX PROPERTIES)
    if ((sc=(*pfn)(m_dwSesID,&m_pIawcpe))!=S_OK) 
    {
        LPVOID lpMsgBuf;
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                        NULL,
                        ::GetLastError(), 
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &lpMsgBuf, 
                        0, 
                        NULL );
        TRACE1("AWCPE error: CPESupportEntry returns %8.8lx\n",sc);
        bReturn=FALSE;
        goto exit;
    }

        try
                {
                // set up innards for printing
                OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                         //   from showing

                if( (m_note_wrench = new CFaxProp( CRect( 0,0,0,0 ),
                                                                                   IDS_PROP_MS_NOTE ))
                        == NULL )
                        return( FALSE );

                // Read note so we can print it even if there are no note objects
                //      on cpe
                read_note();
                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


//LOOP THROUGH ALL RECIPIENTS
    do {

            sc = m_pIawcpe->GetProp(CPE_CONFIG_PRINT_DEVICE, &lLen, szTemp);
            if ( (sc != S_OK) || *szTemp==0) {
                   TRACE(TEXT("AWCPE.render() : GetProp for print device failed\n"));
                   bReturn=FALSE;
                   goto exit;
            }
            m_szRenderDevice=szTemp;

       sc = m_pIawcpe->GetProp(CPE_CONFIG_CPE_TEMPLATE, &lLen, szTemp);
       if ( (sc!=S_OK) || *szTemp==0) {
              TRACE(TEXT("AWCPE.render() : GetProp for template file failded\n"));
              bReturn=FALSE;
                  goto exit;
       }

       if ( !_tcschr(szTemp,(TCHAR)'\\') ) {      //prefix with extension if missing
              TCHAR szTemplate[_MAX_PATH];
              ::GetWindowsDirectory(szTemplate,MAX_PATH);
              _tcscat(szTemplate,TEXT("\\"));
              _tcscat(szTemplate,szTemp);
              _tcscpy(szTemp,szTemplate);
           }


       if( (pDoc = (CDrawDoc *)OpenDocumentFile(szTemp))==NULL) {
              bReturn=FALSE;
                  goto exit;
           }


           // move all "sent pages" prop obs to end of list so extra
           // pages calc can be done after all motes have printed.
           pDoc->schoot_faxprop_toend( IDS_PROP_MS_NOPG );

       TRACE1("AWCPE:  SendMessage to print recipient #%i\n",i);

        try
                {
        ((CFrameWnd*)m_pMainWnd)->GetActiveView()->
                SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));

           // close so next one will reopen again if same name
           OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                        //   from showing

                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


           i++;
    } while (m_pIawcpe->Finish(CPE_FINISH_PAGE)==CPE_NEXT_PAGE);


exit:
        if( !bReturn && (m_pIawcpe != NULL) )      // added 2/1/95 by v-randr
                m_pIawcpe->Finish( CPE_FINISH_ERROR ); // added 2/1/95 by v-randr

    if (szDLL)
       delete [] szDLL;
    if (szfName)
       delete [] szfName;

    return bReturn;
#endif
 }
///#endif




void CDrawApp::read_note( void )
        {
    SCODE sc;
    TCHAR note_filename[_MAX_PATH];
    ULONG lLen;
        CFile note_file;
        DWORD filelen, actuallen;

        if( (m_dwSesID == 0)||(m_pIawcpe == NULL) )
                return;

        if( m_note != NULL )
                {
                delete m_note;
                m_note = NULL;
                }

        m_note_wasread = FALSE;
        m_note_wasclipped = FALSE;

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, NULL );
        if( sc != S_OK )
        {
            /***CAN'T GET FILENAME LENGTH***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        if( lLen == 0 )
                return; // no note to read

        if( lLen > _MAX_PATH )
                {
                /***NAME TOO LONG***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, note_filename );
        if( sc != S_OK )
        {
            /***CAN'T GET FILENAME***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        // try to open the file
        if( !note_file.Open( (LPCTSTR)note_filename,
                                                  CFile::modeRead|CFile::shareDenyNone,
                                                  NULL ) )
        {
            /***CAN'T OPEN FILE***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        TRY
                filelen = note_file.GetLength();
        CATCH_ALL( e )
                {
                /***CAN'T GET FILE LENGTH***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL


        m_note = new TCHAR[ filelen + sizeof (TCHAR) ];
        if( m_note == NULL )
                {
                /**CAN'T MAKE NOTE BUFFER**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }


        TRY
                actuallen = note_file.ReadHuge( m_note, filelen );

        CATCH_ALL( e )
                {
                /**CAN'T READ NOTE**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL

        *(m_note + actuallen) = _T('\0');
        reset_note();
        m_note_wasread = TRUE;


        note_file.Close();
        }




void CDrawApp::reset_note( void )
        {

        if( m_note != NULL )
                {
                m_note_wrench->SetText( CString( m_note ), NULL );
                m_more_note = TRUE;
                }
        else
                m_more_note = FALSE;

        }




int CDrawApp::clip_note( CDC *pdc,
                                                 LPTSTR *drawtext, LONG *numbytes,
                                                 BOOL   delete_usedtext,
                                                 LPRECT drawrect )
        /*
                Sets drawtext to the next page's worth of note text. Returns
                how many pages are left if delete_usedtext is TRUE. If FALSE,
                the page count includes the current page.
         */
        {
        TEXTMETRIC tm;
        LONG boxheight;
        LONG boxwidth;
        LONG numlines;
        int  total_lines;

        m_note_wasclipped = TRUE;
        *drawtext = NULL;
        *numbytes = 0;

        if( !more_note() )
                return( 0 );

        if( !pdc->GetTextMetrics( &tm ) )
                {
                m_more_note = FALSE;
                return( 0 );
                }

        boxheight = drawrect->bottom - drawrect->top;
        boxwidth = drawrect->right - drawrect->left;

        numlines = boxheight/tm.tmHeight;
        if( numlines <= 0 )
                return( 0 );

        m_note_wrench->m_pEdit->SetFont( pdc->GetCurrentFont(), FALSE );
        m_note_wrench->m_position = *drawrect;
        m_note_wrench->FitEditWnd( NULL, FALSE, pdc );

        total_lines = m_note_wrench->GetText( numlines, delete_usedtext );

        m_more_note = (total_lines > 0);

        *drawtext = m_note_wrench->GetRawText();
        *numbytes = lstrlen( *drawtext );

        // return number of pages left
        if( total_lines > 0 )
                return( (total_lines-1)/numlines + 1 );
        else
                return( 0 );

        }








TCHAR *CDrawApp::
        pos_to_strptr( TCHAR *src, long pos,
                                   TCHAR break_char,
                                   TCHAR **last_break, long *last_break_pos )
        /*
                Used for DBCS fiddling. Find str loc for char at pos.

                        pos == 0 -> 1st char,
                        pos == 1 -> 2st char,
                        etc.

                Returned ptr will point at char
                                                                           [pos]

                *last_break will point to last break_char found before
                char
                        [pos]

                If last_break is NULL it is ignored.

         */
        {
        TCHAR *last_break_ptr = NULL;
        long i;

        if( _tcsncmp(src,&break_char,1) == 0 )
                last_break_ptr = src;

        for( i=0; i<pos; i++ )
                {
                src = _tcsinc(src);
                if( _tcsncmp(src,TEXT("\0"),1) == 0 )
                        break;

                if( _tcsncmp(src,&break_char,1) == 0 )
                        {
                        last_break_ptr = src;
                        *last_break_pos = i;
                        }
                }

        if( last_break != NULL )
                *last_break = last_break_ptr;

        return( src );

        }




//-------------------------------------------------------------------
void CDrawApp::ParseCmdLine()
{
    BOOL bUseCommonCPDir = FALSE;   // Start in the common coverpages folder?
#ifdef _DEBUG
    if (m_lpCmdLine)
    {
       TRACE(TEXT("AWCPE:  command line: '%s'\n"),m_lpCmdLine);
    }
#endif

    m_bCmdLinePrint=FALSE;
    m_bConvertCpeToCov=FALSE;
    m_dwSesID=0;
    m_szDefaultDir=_T("");
    m_szFileName=_T("");

    TCHAR **argv ; /////////= __argv;    /////////????????????????????
    int iArgs ;    ///////////=__argc;   /////////????????????????????

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &iArgs );
#else
    argv = __argv;
    iArgs = __argc;
#endif

    if (m_lpCmdLine==NULL || *m_lpCmdLine==0 || !argv)
    {
        goto exit;
    }
    for (int i=1; i < iArgs; i++) 
    {
        _tcsupr(*(argv+i));
        if (_tcsstr(*(argv+i),TEXT("/P"))) 
        {
            m_bCmdLinePrint=TRUE;
            TRACE(TEXT("AWCPE:  command line printing mode set\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/COMMON"))) 
        {
            bUseCommonCPDir = TRUE ;
            TRACE(TEXT("AWCPE: Common coverpages folder is requested\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/W"))) 
        {
            TCHAR szDir[MAX_PATH] = {0};
            if(::GetWindowsDirectory(szDir, MAX_PATH-1))
            {
                m_szDefaultDir = szDir;
                TRACE1("AWCPE:  default directory set to '%s'\n",m_szDefaultDir);
            }
            else
            {
                TRACE1("AWCPE:  GetWindowsDirectory failed with %d\n", GetLastError());
            }
        }
        else if (_tcsstr(*(argv+i),TEXT("/CONVERT"))) 
        {
            //
            // Launch the cover page editor just to convert the cover page from CPE (w9x format, Version 4)
            // to COV latest version (Version 5)
            //
            m_bConvertCpeToCov = TRUE;
        }
        else 
        {
            m_szFileName = *(argv+i);
        }
    }
    if (m_szFileName.GetLength() > 0) 
    {
        TCHAR szDrive[_MAX_DRIVE];
        TCHAR szDir[_MAX_DIR];
        TCHAR szFName[_MAX_FNAME];
        TCHAR szExt[_MAX_EXT];
        _tsplitpath(m_szFileName,szDrive,szDir,szFName,szExt);
        if (_tcsclen(szDir)>0 && m_szDefaultDir.GetLength()<= 0)
        m_szDefaultDir=szDir;    ////// Wrong!!!!!!! a-juliar, 8-27-96
        m_szDefaultDir = szDrive ;
        m_szDefaultDir += szDir ;
    }

exit:
#ifdef UNICODE
    LocalFree( argv );
#endif

    TCHAR tszStartDir[MAX_PATH * 2];
    BOOL  bGotStartDir;

    if (bUseCommonCPDir)
    {
        bGotStartDir = GetServerCpDir (NULL, tszStartDir, ARR_SIZE(tszStartDir));
    }
    else
    {
        bGotStartDir = GetClientCpDir (tszStartDir, ARR_SIZE(tszStartDir));
    }
    if (bGotStartDir)
    {
        SetCurrentDirectory(tszStartDir);
    }
        

}


//-------------------------------------------------------------------------
//Add properties to dictionary
//  (1) CProp, param 1:  string table index of description
//  (2) CProp, param 2:  length of property, in characters
//  (3) CProp, param 3:  width of property, in lines
//  (4) CProp, param 4:  index to property value (obtained via transport(awcpesup.h))
//-------------------------------------------------------------------------
//	The function creates static objects of type CProp for each property of the cover page.
//	The CProp constructor calls a static member of CFaxPropMap structure - m_PropMap (of type CMapWordToPtr)
//	with  CFaxPropMap::m_PropMap[IDS_PROP_**_****]=this in order to insert each of the properties to the map
//	which is later used to restore properties data. In other words - the map points to all the static 
//  CProp's we create and with the map we can find the CProp we need BY A MATCH OF ONE OF ITS FIELDS 
//  (and we do not need his name - for example "recipient_name").
//
void CDrawApp::InitFaxProperties()  // Make some numbers too small for test purposes.
{
   static CProp recipient_name(IDS_PROP_RP_NAME,15,1,IDS_CAPT_RP_NAME,CPE_RECIPIENT_NAME);
   static CProp recipient_fxno(IDS_PROP_RP_FXNO,15,1,IDS_CAPT_RP_FXNO,CPE_RECIPIENT_FAX_PHONE);
   static CProp recipient_comp(IDS_PROP_RP_COMP,5,1,IDS_CAPT_RP_COMP,CPE_RECIPIENT_COMPANY);
   static CProp recipient_addr(IDS_PROP_RP_ADDR,35,1,IDS_CAPT_RP_ADDR,CPE_RECIPIENT_STREET_ADDRESS);
   static CProp recipient_pobx(IDS_PROP_RP_POBX,20,1,IDS_CAPT_RP_POBX,CPE_RECIPIENT_POST_OFFICE_BOX);
   static CProp recipient_city(IDS_PROP_RP_CITY,5,1,IDS_CAPT_RP_CITY,CPE_RECIPIENT_LOCALITY);
   static CProp recipient_stat(IDS_PROP_RP_STAT,5,1,IDS_CAPT_RP_STAT,CPE_RECIPIENT_STATE_OR_PROVINCE);
   static CProp recipient_zipc(IDS_PROP_RP_ZIPC,5,1,IDS_CAPT_RP_ZIPC,CPE_RECIPIENT_POSTAL_CODE);
   static CProp recipient_ctry(IDS_PROP_RP_CTRY,5,1,IDS_CAPT_RP_CTRY,CPE_RECIPIENT_COUNTRY);
   static CProp recipient_titl(IDS_PROP_RP_TITL,20,1,IDS_CAPT_RP_TITL,CPE_RECIPIENT_TITLE);
   static CProp recipient_dept(IDS_PROP_RP_DEPT,5,1,IDS_CAPT_RP_DEPT,CPE_RECIPIENT_DEPARTMENT);
   static CProp recipient_offi(IDS_PROP_RP_OFFI,5,1,IDS_CAPT_RP_OFFI,CPE_RECIPIENT_OFFICE_LOCATION);
   static CProp recipient_htel(IDS_PROP_RP_HTEL,4,1,IDS_CAPT_RP_HTEL,CPE_RECIPIENT_HOME_PHONE);
   static CProp recipient_otel(IDS_PROP_RP_OTEL,4,1,IDS_CAPT_RP_OTEL,CPE_RECIPIENT_WORK_PHONE);
   static CProp recipient_tols(IDS_PROP_RP_TOLS,50,3,IDS_CAPT_RP_TOLS,CPE_RECIPIENT_TO_LIST);
   static CProp recipient_ccls(IDS_PROP_RP_CCLS,50,3,IDS_CAPT_RP_CCLS,CPE_RECIPIENT_CC_LIST);
   static CProp message_subj(IDS_PROP_MS_SUBJ,50,2,IDS_CAPT_MS_SUBJ,CPE_MESSAGE_SUBJECT);
   static CProp message_tsnt(IDS_PROP_MS_TSNT,35,1,IDS_CAPT_MS_TSNT,CPE_MESSAGE_SUBMISSION_TIME);
   static CProp message_nopg(IDS_PROP_MS_NOPG,5,1,IDS_CAPT_MS_NOPG,CPE_COUNT_PAGES);
   static CProp message_noat(IDS_PROP_MS_NOAT,23,1,IDS_CAPT_MS_NOAT,CPE_COUNT_ATTACHMENTS);
   static CProp message_bcod(IDS_PROP_MS_BCOD,30,1,IDS_CAPT_MS_BCOD,CPE_MESSAGE_BILLING_CODE);
   static CProp message_text(IDS_PROP_MS_TEXT,40,8,IDS_CAPT_MS_TEXT,CPE_MESSAGE_BILLING_CODE); //CPE constant needs updating
   static CProp message_note(IDS_PROP_MS_NOTE,90,12,IDS_CAPT_MS_NOTE,CPE_MESSAGE_NOTE);
   static CProp sender_name(IDS_PROP_SN_NAME,5,1,IDS_CAPT_SN_NAME,CPE_SENDER_NAME);
   static CProp sender_fxno(IDS_PROP_SN_FXNO,5,1,IDS_CAPT_SN_FXNO,CPE_SENDER_FAX_PHONE);
   static CProp sender_comp(IDS_PROP_SN_COMP,5,1,IDS_CAPT_SN_COMP,CPE_SENDER_COMPANY);
   static CProp sender_addr(IDS_PROP_SN_ADDR,35,6,IDS_CAPT_SN_ADDR,CPE_SENDER_ADDRESS);
   static CProp sender_titl(IDS_PROP_SN_TITL,5,1,IDS_CAPT_SN_TITL,CPE_SENDER_TITLE);
   static CProp sender_dept(IDS_PROP_SN_DEPT,5,1,IDS_CAPT_SN_DEPT,CPE_SENDER_DEPARTMENT);
   static CProp sender_offi(IDS_PROP_SN_OFFI,5,1,IDS_CAPT_SN_OFFI,CPE_SENDER_OFFICE_LOCATION);
   static CProp sender_htel(IDS_PROP_SN_HTEL,5,1,IDS_CAPT_SN_HTEL,CPE_SENDER_HOME_PHONE);
   static CProp sender_otel(IDS_PROP_SN_OTEL,5,1,IDS_CAPT_SN_OTEL,CPE_SENDER_WORK_PHONE);
   static CProp sender_emal(IDS_PROP_SN_EMAL,35,1,IDS_CAPT_SN_EMAL,CPE_SENDER_EMAIL);
   m_pFaxMap=new CFaxPropMap;
}


//-------------------------------------------------------------------------
BOOL CDrawApp::DoFilePageSetup(CMyPageSetupDialog& dlg)
{
   UpdatePrinterSelection(FALSE);

     dlg.m_psd.hDevMode = m_hDevMode;
     dlg.m_psd.hDevNames = m_hDevNames;

   if (dlg.DoModal() != IDOK)
      return FALSE;

   m_hDevMode=dlg.m_psd.hDevMode;
   m_hDevNames=dlg.m_psd.hDevNames;

   return TRUE;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFilePageSetup()
{
   WORD old_orientation;
   WORD old_papersize;
   WORD old_scale;
   CDrawDoc *pdoc = CDrawDoc::GetDoc();

   CMyPageSetupDialog dlg;
   if (dlg.m_pPageSetupDlg) 
   {
      if (!DoFilePageSetup(dlg))
      {
         return;
      }
   }
   else
   {
      CWinApp::OnFilePrintSetup();                //call printsetup if no existing page setup
   }

   // save old ones so we can do a dirty check
   old_orientation = pdoc->m_wOrientation;
   old_papersize   = pdoc->m_wPaperSize;
   old_scale       = pdoc->m_wScale;

   // get (possibly) new values
   LPDEVMODE  lpDevMode = (m_hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(m_hDevMode) : NULL;
   if (lpDevMode)
   {
       pdoc->m_wOrientation =lpDevMode->dmOrientation;
       pdoc->m_wPaperSize   =lpDevMode->dmPaperSize;
/** DISABLE SCALEING - SEE 2868's BUG LOG **/
       if( FALSE )//lpDevMode->dmFields & DM_SCALE  )
       {
               // change scale only if printer supports it
           pdoc->m_wScale = lpDevMode->dmScale;
       }
       // dirty check
       if( (pdoc->m_wOrientation != old_orientation)||
           (pdoc->m_wPaperSize   != old_papersize)  ||
           (pdoc->m_wScale       != old_scale)
         )
       {
          pdoc->SetModifiedFlag();
       }
   }
   if (m_hDevMode != NULL)
   {
     ::GlobalUnlock(m_hDevMode);
   }
   pdoc->ComputePageSize();
}//CDrawApp::OnFilePageSetup

//-------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    CString m_cstrVersion;

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_CPE_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_ABOUT_CPE_VERSION, m_cstrVersion);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////////////////////
// App command to run the dialog
void CDrawApp::OnAppAbout()
{
    DWORD dwRes = ERROR_SUCCESS;
    TRACE (TEXT("CClientConsoleApp::OnAppAbout"));

    ASSERT_VALID (m_pMainWnd);
    
    if (IsWinXPOS())
	{
		HICON hIcon = LoadIcon(IDR_AWCPETYPE);
		if(!hIcon)
		{
			dwRes = GetLastError();
			TRACE1("AWCPE Error: LoadIcon failed: '%ld' \n", dwRes);
			return;
		}
		
		TCHAR tszTitleBuf[100] = {'\0'};
		if (!LoadString (AfxGetResourceHandle(), AFX_IDS_APP_TITLE, tszTitleBuf, 100))
		{
			dwRes = GetLastError();
			TRACE1("AWCPE Error: LoadString failed: '%ld' \n", dwRes);
			return;
		}
		
		if(!::ShellAbout(AfxGetMainWnd()->m_hWnd, tszTitleBuf, TEXT(""), hIcon))
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
			TRACE1("AWCPE Error: ShellAbout failed: '%ld' \n", dwRes);
			return;
		}
		return;
	}
	CAboutDlg aboutDlg;
	//
	// get version
	//
	TCHAR tszVersionNum[100] = {0};
	TCHAR tszBuildNum[100] = {0};

	_sntprintf(tszVersionNum, ARR_SIZE(tszVersionNum) - 1, TEXT("%d.%d"), VERMAJOR, VERMINOR);

#ifdef DEBUG
	_sntprintf(tszBuildNum, ARR_SIZE(tszBuildNum) - 1, TEXT("%dchk"), BUILD);
#else
	_sntprintf(tszBuildNum, ARR_SIZE(tszBuildNum) - 1, TEXT("%d"), BUILD);
#endif

	try
	{
		AfxFormatString2(aboutDlg.m_cstrVersion, 
						 IDS_CPE_VERSION_FORMAT, 
						 tszVersionNum, 
						 tszBuildNum);
	}
	catch(...)
	{
		dwRes = ERROR_NOT_ENOUGH_MEMORY;
		TRACE1("AWCPE Error: AfxFormatString2 failed: '%ld' \n", dwRes);
		return;
	}
	
	aboutDlg.DoModal();
}//CDrawApp::OnAppAbout


//--------------------------------------------------------------------------------
static void AppendFilterSuffix(CString& filter, OPENFILENAME &ofn,
        CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
        ASSERT_VALID(pTemplate);
        ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

        CString strFilterExt, strFilterName;
        if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
         !strFilterExt.IsEmpty() &&
         pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
         !strFilterName.IsEmpty())
        {
                // a file based document template - add to filter list
#ifndef _MAC
                ASSERT(strFilterExt[0] == '.');
#endif
                if (pstrDefaultExt != NULL)
                {
                        // set the default extension
#ifndef _MAC
                        *pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
#else
                        *pstrDefaultExt = strFilterExt;
#endif
                        ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
                }

                // add to filter
                filter += strFilterName;
                ASSERT(!filter.IsEmpty());  // must have a file type name
                filter += (TCHAR)'\0';  // next string please
#ifndef _MAC
                filter += (TCHAR)'*';
#endif
                filter += strFilterExt;
                filter += (TCHAR)'\0';  // next string please
        }
}

//--------------------------------------------------------------------------------
BOOL CDrawApp::DoPromptFileName(
    CString& fileName,
    UINT nIDSTitle,
    DWORD lFlags,
    BOOL bOpenFileDialog,
    CDocTemplate* pTemplate,
    LPOFNHOOKPROC lpOFNHook /*= NULL*/
)
{
    OPENFILENAME ofn = {0};

    ofn.lStructSize = GetOpenFileNameStructSize();

    ofn.Flags = OFN_HIDEREADONLY       | 
                OFN_OVERWRITEPROMPT    |
                OFN_ENABLESIZING       |
                OFN_EXPLORER           |
                lFlags;
    ofn.hInstance = AfxGetResourceHandle();
    if (lpOFNHook)
    {
        ofn.Flags |= OFN_ENABLEHOOK;
        ofn.lpfnHook = lpOFNHook;
    }

    TCHAR tszCovDir[MAX_PATH+1];
    if(GetCurrentDirectory(MAX_PATH, tszCovDir))
    {
        ofn.lpstrInitialDir = tszCovDir;
    }
    else
    {
        TRACE(TEXT("GetCurrentDirectory failed"));

        if (m_szDefaultDir.GetLength()>0 && m_bUseDefaultDirectory)
        {   // Added to set initial directory
            ofn.lpstrInitialDir = m_szDefaultDir;
        }
    }

    //
    // Make sure all object are NOT selected.
    //
    CDrawView* pView = CDrawView::GetView();
    if (pView)
    {
        pView->Select(NULL, FALSE, TRUE);
    }

    CString strFilter;
    CString strDefault;

    if (pTemplate != NULL) 
    {
        ASSERT_VALID(pTemplate);
        AppendFilterSuffix(strFilter, ofn, pTemplate, &strDefault);
    }
    else  
    {
        // Do for all doc template
        POSITION pos = GetFirstDocTemplatePosition();
        while (pos != NULL)  
        {
            AppendFilterSuffix(
                strFilter,
                ofn,
                (CDocTemplate*)GetNextDocTemplate( pos ),
                NULL
                );
        }
    }

    if (bOpenFileDialog)
    {
        //
        // This is an open file dialog
        //

        //
        // Append the "*.cpe" filter -- Windows 95 Cover Page Files -- 9-20-96 a-juliar
        //
        CString Win95filter ;
        VERIFY( Win95filter.LoadString( IDS_OLD_FILE_FILTER ));
        strFilter += Win95filter ;
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.cpe");
        strFilter += (TCHAR)'\0';   // next string please
    }

    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));

    strFilter += allFilter;
    strFilter += (TCHAR)'\0';    // next string please

    strFilter += _T("*.*");


    strFilter += (TCHAR)'\0';    // last string
    ofn.lpstrFilter = strFilter;

    ofn.lpstrDefExt = FAX_COVER_PAGE_EXT_LETTERS; // Fix bug 57706

    CString title;
    VERIFY(title.LoadString(nIDSTitle));
    ofn.lpstrTitle = title;

    TCHAR tszFileName[MAX_PATH+1] = {0};
    _tcscpy (tszFileName, fileName);
    ofn.lpstrFile = tszFileName;
    ofn.nMaxFile = (sizeof (tszFileName) / sizeof (tszFileName[0])) - 1;

    CWnd *pMainWnd = AfxGetMainWnd();
    ofn.hwndOwner = pMainWnd ? pMainWnd->m_hWnd : NULL;

    BOOL bRes;
    if (bOpenFileDialog)
    {
        bRes = ::GetOpenFileName(&ofn);
    }
    else
    {
        bRes = ::GetSaveFileName(&ofn);
    }

    m_bUseDefaultDirectory = FALSE ; //// After first time, use the CURRENT DIRECTORY instead.
    if (bRes)
    {
        fileName = tszFileName;
    }
    return bRes;
}   // CDrawApp::DoPromptFileName


//--------------------------------------------------------------------------------
WORD
CDrawApp::GetLocaleDefaultPaperSize(
    void
    ) const

/*++

Routine Description:

    Retrieves the current locale defualt paper size.

Arguments:

    NONE

Return Value:

    One of the following values:  1 = letter, 5 = legal, 9 = a4

--*/

{

// 
// LOCALE_IPAPERSIZE is defined in Winnls.h only if (WINVER >= 0x0500).
// At this point we do not want to split the binaries of NT4 and W2K, so we define LOCALE_IPAPERSIZE localy.
//
#define LOCALE_IPAPERSIZE             0x0000100A   // 1 = letter, 5 = legal, 8 = a3, 9 = a4


    TCHAR   tszMeasure[2] = TEXT("9"); // 2 is maximum size for the LOCALE_IPAPERSIZE
                                      // value as defined is MSDN.

    if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IPAPERSIZE, tszMeasure,2))
    {
        if (!_tcscmp(tszMeasure,TEXT("9")))
        {
            // A4
            return DMPAPER_A4;
        }

        if (!_tcscmp(tszMeasure,TEXT("5")))
        {
            // legal
            return DMPAPER_LEGAL;
        }
    }

    //
    // Defualt value is Letter.
    //
    return DMPAPER_LETTER;
}
//-------------------------------------------------------------------------




//Map for CS help system
DWORD cshelp_map[] =
{
    IDC_CB_DRAWBORDER,  IDC_CB_DRAWBORDER,
        IDC_LB_THICKNESS,       IDC_LB_THICKNESS,
        IDC_LB_LINECOLOR,       IDC_LB_LINECOLOR,
        IDC_RB_FILLTRANS,       IDC_RB_FILLTRANS,
        IDC_RB_FILLCOLOR,       IDC_RB_FILLCOLOR,
        IDC_LB_FILLCOLOR,       IDC_LB_FILLCOLOR,
        IDC_LB_TEXTCOLOR,       IDC_LB_TEXTCOLOR,
        IDC_GRP_FILLCOLOR,  IDC_COMM_GROUPBOX,
        IDC_ST_TEXTCOLOR,   IDC_COMM_STATIC,
        IDC_ST_THICKNESS,   IDC_COMM_STATIC,
        IDC_ST_COLOR,       IDC_COMM_STATIC,
    0,0
};




//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawApp, CWinApp)
   //{{AFX_MSG_MAP(CDrawApp)
   ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
   //}}AFX_MSG_MAP
   // Standard file based document commands
   ON_COMMAND(ID_FILE_NEW, OnFileNew)
   ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
   ON_COMMAND(ID_FILE_SAVE, CDrawDoc::OnFileSave)
   ON_COMMAND(ID_FILE_SAVE_AS, CDrawDoc::OnFileSaveAs)
   // Standard print setup command
   ON_COMMAND(ID_FILE_PAGE_SETUP, OnFilePageSetup)
   ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
/// Experimental entries --- a-juliar, 7-18-96
   ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex )
//   ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing )
   ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex )
   ON_COMMAND(ID_HELP, CWinApp::OnHelp )
END_MESSAGE_MAP()






/*
        This override of MatchDocType forces MFC to reload a file that is
        already loaded and that has been modified. MFC will put up the
        standard "save changes?" dialog before reloading the file.

        This defeats MFC's default behavior of just doing nothing if you
        try to FileOpen a file that is already opened.

        This was done to fix bug 2628.
 */
#ifndef _MAC
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType( LPCTSTR lpszPathName,
                                  CDocument*& rpDocMatch )
#else
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType(LPCTSTR lpszFileName, DWORD dwFileType,
                                 CDocument*& rpDocMatch)
#endif
        {
        CDocTemplate::Confidence congame;       

        congame =
#ifndef _MAC
                CSingleDocTemplate::MatchDocType( lpszPathName, rpDocMatch );
#else
                CSingleDocTemplate::MatchDocType( lpszFileName, dwFileType,
                                                                                  rpDocMatch );
#endif


        if( congame == CDocTemplate::yesAlreadyOpen )
                {
                if( rpDocMatch->IsModified() )
                        {
                        // force a reload after "save changes?" dialog
                        congame = CDocTemplate::yesAttemptNative;
                        rpDocMatch = NULL;
                        }
                }

        return( congame );

        }/* CCpeDocTemplate::MatchDocType */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\awcpe.h ===
//--------------------------------------------------------------------------
// AWCPE.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
//--------------------------------------------------------------------------
#ifndef __AWCPE_H__
#define __AWCPE_H__

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "awcpesup.h"
#include <stdio.h>
#include <faxreg.h>

/*****************TEMPORARY*********************/
#define CPE_MESSAGE_NOTE        CPE_RECIPIENT_NAME
/***********************************************/



//
// Look in the registry under HKEY_LOCAL_MACHINE for the following DWORD key.  Hidden fields
//    will be enabled if their corresponding bit is set.
//
//[RB] #define EFC_COVER_PAGE_FIELDS (TEXT("Software\\Microsoft\\Fax\\Setup\\EFC_CoverPageFields")) //[RB] Not used
#define COVFP_REC_COMPANY                0x00000004
#define COVFP_REC_STREET_ADDRESS         0x00000008
#define COVFP_REC_CITY                   0x00000010
#define COVFP_REC_STATE                  0x00000020
#define COVFP_REC_ZIP_CODE               0x00000040
#define COVFP_REC_COUNTRY                0x00000080
#define COVFP_REC_TITLE                  0x00000100
#define COVFP_REC_DEPARTMENT             0x00000200
#define COVFP_REC_OFFICE_LOCATION        0x00000400
#define COVFP_REC_HOME_PHONE             0x00000800
#define COVFP_REC_OFFICE_PHONE           0x00001000
#define COVFP_TO_LIST                    0x04000000
#define COVFP_CC_LIST                    0x08000000

#define _countof(array) (sizeof(array)/sizeof(array[0]))
#define TIPSECTION _T("Tips Section")
#define TIPENTRY _T("ShowTips")

extern DWORD cshelp_map[];

extern BYTE BASED_CODE _gheaderVer1[20];
extern BYTE BASED_CODE _gheaderVer2[20];
extern BYTE BASED_CODE _gheaderVer3[20];
extern BYTE BASED_CODE _gheaderVer4[20];
extern BYTE BASED_CODE _gheaderVer5w[20];
extern BYTE BASED_CODE _gheaderVer5a[20];

class CMyPageSetupDialog;
class CFaxPropMap;
class CFaxProp;





/*
        CCpeDocTemplate is a derivation of CSingleDocTemplate used to
        override some default MFC behavior. See CCpeDocTemplate::MatchDocType
        in AWCPE.CPP
 */
class CCpeDocTemplate : public CSingleDocTemplate
        {
public:
        CCpeDocTemplate( UINT nIDResource, CRuntimeClass* pDocClass,
                                     CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass):
                CSingleDocTemplate( nIDResource, pDocClass,     pFrameClass, pViewClass )
                {;}



#ifndef _MAC
        virtual Confidence MatchDocType(LPCTSTR lpszPathName,
                                        CDocument*& rpDocMatch);
#else
        virtual Confidence MatchDocType(LPCTSTR lpszFileName,
                                        DWORD dwFileType, CDocument*& rpDocMatch);
#endif

        };








class CDrawApp : public CWinApp
{
public:
   HCURSOR m_hMoveCursor;
   BOOL m_bCmdLinePrint;
   LPAWCPESUPPORT m_pIawcpe;
   CString m_szRenderDevice;
   CString m_szRenderName;
   CFaxPropMap* m_pFaxMap;
   DWORD m_dwSesID;

/***CHANGES FOR M8 bug 2988***/
   LOGFONT m_last_logfont;
/*****************************/


// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
   LOGFONT m_default_logfont;
////////////////////////////////

   void filter_mru_list();
   BOOL DoPromptFileName(CString&, UINT, DWORD, BOOL, CDocTemplate*, LPOFNHOOKPROC lpOFNHook = NULL);
   CDrawApp();
   ~CDrawApp();

   // stuff for putting message notes on cover page
   TCHAR *m_note;
   BOOL m_note_wasread;
   BOOL m_note_wasclipped;
   BOOL m_extrapage_count;
   BOOL m_more_note;
   CFaxProp *m_last_note_box;
   CFaxProp *m_note_wrench;
   CFaxProp *m_extra_notepage;
   CDC      *m_pdc;     // easier to put it here instead of passing
                                        // it all over the place.

   void read_note( void );
   int  clip_note( CDC *pdc,
                   LPTSTR *drawtext, LONG *numbytes,
                   BOOL   delete_usedtext,
                   LPRECT drawrect );

   BOOL IsRTLUI() { return m_bRTLUI;}
   BOOL IsInConvertMode() {return m_bConvertCpeToCov;}

   void reset_note( void );

   WORD GetLocaleDefaultPaperSize( void ) const;

   LPTSTR GetHtmlHelpFile() { return FAX_COVERPAGE_HELP_FILE; }
   BOOL more_note( void ) {return( m_more_note );}
private:

   TCHAR *pos_to_strptr( TCHAR *src, long pos,
                                                 TCHAR break_char,
                                                 TCHAR **last_break, long *last_break_pos );
   BOOL m_bUseDefaultDirectory ;

protected:
   HMODULE m_hMod;
   int m_iErrorCode;
   HANDLE m_hSem;
   CString m_szDefaultDir;
   CString m_szFileName;

   BOOL m_bRTLUI;
   BOOL m_bConvertCpeToCov;

   void InitRegistry();
   BOOL DoFilePageSetup(CMyPageSetupDialog& dlg);
   void RegistryEntries();
   virtual BOOL InitInstance();
   virtual int ExitInstance();
   void InitFaxProperties();
   BOOL IsSecondInstance();
   void CmdLinePrint();
   void CmdLineRender();
   BOOL Render();
   BOOL Print();
   void ParseCmdLine();
   void OnFileOpen();
   void OnFileNew();
   afx_msg void OnFilePageSetup();
   CDocument* OpenDocumentFile(LPCTSTR lpszFileName);

        //{{AFX_MSG(CDrawApp)
        afx_msg void OnAppAbout();
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};


class CSEHexception
{
   private:
     UINT m_nCode;
   public:
     CSEHexception() {};
     CSEHexception(UINT uCode) : m_nCode(uCode) {};
     ~CSEHexception() {};
     unsigned int GetNumber() {return m_nCode;};
};






extern CDrawApp NEAR theApp;


#endif //#ifndef __AWCPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpedoc.h ===
//--------------------------------------------------------------------------
// CPEDOC.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEDOC_H__
#define __CPEDOC_H__

#define MILIMETERS_TO_HIMETRIC 100        // Conversion factor
#define LE_TO_HM_NUMERATOR   2540         // LOENGLISH to HIMETRIC conversion
#define LE_TO_HM_DENOMINATOR 100
class CDrawView;
class CDrawObj;

class CDrawDoc : public COleDocument
{
public:
    enum {VERSION1,VERSION2,VERSION3,VERSION4, VERSION5};
    int m_iDocVer;
    WORD m_wOrientation;
    WORD m_wPaperSize;
    WORD m_wScale;
    BOOL m_bSerializeFailed ;
    BOOL m_bDataFileUsesAnsi ;

    CObList m_objects;
    CObList  m_previousStateForUndo ;

    virtual ~CDrawDoc();
    static CDrawDoc* GetDoc();
    CObList* GetObjects() { return &m_objects; }
    BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    const CSize& GetSize() const { return m_size; }
    void ComputePageSize();
    int GetMapMode() const { return m_nMapMode; }
    COLORREF GetPaperColor() const { return m_paperColor; }
    CDrawObj* ObjectAt(const CPoint& point);
    void Draw(CDC* pDC, CDrawView* pView, CRect rcClip);
    void Add(CDrawObj* pObj,BOOL bUndo=TRUE);
    void Remove(CDrawObj* pObj=NULL);
    virtual void Serialize(CArchive& ar);   // overridden for document i/o
    BOOL IsOkToClose();
    void schoot_faxprop_toend( WORD res_id );

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
        CSize m_size;
        int m_nMapMode;
        COLORREF m_paperColor;

        virtual BOOL OnNewDocument();
        void DeleteContents();
        CDrawDoc();
        virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
        void OnUpdateFileSave(CCmdUI* pCmdUI);
public:
        void OnFileSave();
        void OnFileSaveAs();
        void CloneObjectsForUndo();
        void SwapListsForUndo();
        virtual BOOL SaveModified(); // return TRUE if ok to continue // override to enforce ".COV" extension
protected:
        void StoreInformationForPrinting( CArchive& ar );
        void SeekPastInformationForPrinting( CArchive& ar );
        DECLARE_DYNCREATE(CDrawDoc)

        //{{AFX_MSG(CDrawDoc)
        afx_msg void OnViewPaperColor();
        afx_msg void OnUpdateMapiMsgNote(CCmdUI* pCmdUI);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//
// Structure of the composite file header.
// These will be used in the Windows API function  PrtCoverPage
//
typedef struct tagCOMPOSITEFILEHEADER {
  BYTE      Signature[20];
  DWORD     EmfSize;
  DWORD     NbrOfTextRecords;
  SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;
//
// Structure of the text box entries in the composite file.  For printing purposes only.
//

typedef struct tagTextBoxW{
  RECT           PositionOfTextBox;
  COLORREF       TextColor;
  UINT           TextAlignment;
  LOGFONTW       FontDefinition;
  WORD           ResourceID ;        // Identifies a FAX PROPERTY.
  DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOXW;

#endif //#ifndef __CPEDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpedoc.cpp ===
//--------------------------------------------------------------------------
// CPEDOC.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      document module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "faxreg.h"
#include "resource.h"
#include "faxutil.h"
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CDrawDoc, COleDocument)


//--------------------------------------------------------------------------
CDrawDoc::CDrawDoc():m_bSerializeFailed(FALSE)
{

    m_wScale = 100;                                 //default to full size
    m_wPaperSize = ((CDrawApp*)(AfxGetApp()))->GetLocaleDefaultPaperSize();    //default to papersize of letter
    m_wOrientation=DMORIENT_PORTRAIT;               //default to portrait mode
    m_nMapMode = MM_ANISOTROPIC;
    m_paperColor = COLOR_WHITE;
    ComputePageSize();

}

//--------------------------------------------------------------------------
CDrawDoc::~CDrawDoc()
{
}

//--------------------------------------------------------------------------
BOOL CDrawDoc::OnNewDocument()
{
    if (!COleDocument::OnNewDocument())
        return FALSE;

    UpdateAllViews(NULL);

    return TRUE;
}


//-----------------------------------------------------------------------------
CDrawDoc* CDrawDoc::GetDoc()
{
    CFrameWnd* pFrame = (CFrameWnd*) (AfxGetApp()->m_pMainWnd);
    return (CDrawDoc*) pFrame->GetActiveDocument();
}


//--------------------------------------------------------------------------
void CDrawDoc::Serialize(CArchive& ar)
{
    m_bSerializeFailed = FALSE ;
    if (ar.IsStoring()) 
    {

     //
     // Windows XP Fax Cover Page Editor puts all information
     // needed for rendering up front.
     //

     try 
     {
         StoreInformationForPrinting( ar ); // Includes the signature, _gheaderVer5
     }

     catch(CException* e )
     {
        SetModifiedFlag( FALSE ) ;
        m_bSerializeFailed = TRUE ;
        e->Delete();
     }
     catch(...)
     {
     }
     //
     // Now serialize as in Windows 95 Cover Page Editor.
     //

     ///////////////   ar.Write( _gheaderVer4, 20 );

        ar << m_wScale;
        ar << m_wPaperSize;
        ar << m_wOrientation;
        ar << m_paperColor;
        m_objects.Serialize(ar);
    }
    else 
    {
        try 
        {
                // set defaults for any unread params
            m_wScale = 100;
            m_wPaperSize = ((CDrawApp*)(AfxGetApp()))->GetLocaleDefaultPaperSize();
            m_wOrientation=DMORIENT_PORTRAIT;

            if (m_iDocVer==VERSION2) {
                ar.GetFile()->Seek(sizeof(_gheaderVer2),CFile::begin);
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION3) {
                ar.GetFile()->Seek(sizeof(_gheaderVer3),CFile::begin);
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
                else if (m_iDocVer==VERSION4) {
                ar.GetFile()->Seek(sizeof(_gheaderVer4),CFile::begin);
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION5) {
                SeekPastInformationForPrinting( ar ) ;
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else {
                ar.GetFile()->SeekToBegin();
            }

/** DISABLE SCALEING - SEE 2868's BUG LOG **/
            m_wScale = 100;
/*******************************************/

            ComputePageSize();

            ar >> m_paperColor;
            m_objects.Serialize(ar);
        }
        catch(CException* e )
        {
            SetModifiedFlag( FALSE ) ;
            m_bSerializeFailed = TRUE ;
            ////THROW_LAST() ;       //// No!  I don't like the framework's message box!
            e->Delete();
        }
        catch(...)
        {
        }

/**********************NOTE- BUG FIX FOR 3133**********************/
// can't call COleDocument::Serialize because COleDrawObj has
// already saved its client item. Also, items associated with
// undo objects will get saved if COleDocument::Serialize is called
// and will cause the file to mysteriously grow 'n grow...
//    COleDocument::Serialize(ar);
/******************************************************************/
        if( m_bDataFileUsesAnsi )
        {
            SetModifiedFlag();            // Conversion to UNICODE is a modification worth prompting to save!
            m_bDataFileUsesAnsi = FALSE ; // When using CLIPBOARD, assume LOGFONTW structures.
        }
    }
}

DWORD
CopyTLogFontToWLogFont(
        IN  const LOGFONT & lfSource,
        OUT LOGFONTW & lfDestW
        )
{
/*++

Routine Description:

    This fuction copies a LogFont structure from T format
    to UNICODE format.

Arguments:
    
      lfSource - reference to input LongFont structure
      lfDestW - reference to output UNICODE LongFont structure

Return Value:

    WINAPI last error
--*/
    lfDestW.lfHeight = lfSource.lfHeight ;
    lfDestW.lfWidth = lfSource.lfWidth ;
    lfDestW.lfEscapement = lfSource.lfEscapement ;
    lfDestW.lfOrientation = lfSource.lfOrientation ;
    lfDestW.lfWeight = lfSource.lfWeight ;
    lfDestW.lfItalic = lfSource.lfItalic ;
    lfDestW.lfUnderline = lfSource.lfUnderline ;
    lfDestW.lfStrikeOut = lfSource.lfStrikeOut ;
    lfDestW.lfCharSet = lfSource.lfCharSet ;
    lfDestW.lfOutPrecision = lfSource.lfOutPrecision ;
    lfDestW.lfClipPrecision = lfSource.lfClipPrecision ;
    lfDestW.lfQuality = lfSource.lfQuality ;
    lfDestW.lfPitchAndFamily = lfSource.lfPitchAndFamily ;

    SetLastError(0);
#ifdef UNICODE
    wcscpy( lfDestW.lfFaceName,lfSource.lfFaceName);
#else
    int iCount;
    iCount = MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                lfSource.lfFaceName,
                LF_FACESIZE,
                lfDestW.lfFaceName,
                LF_FACESIZE
            );

    if (!iCount)
    {
        TRACE( TEXT("Failed to covert string to UNICODE"));
        return GetLastError();
    }
#endif
    return ERROR_SUCCESS;
}


void CDrawDoc::StoreInformationForPrinting( CArchive& ar )
{
//
// Create an Enhanced MetaFile followed by text box information,
// to store, for rendering by a WINAPI function PrtCoverPage.
//
// Author  Julia J. Robinson
//
// March 29, 1996
//
   COMPOSITEFILEHEADER CompositeFileHeader ;
   memcpy( &CompositeFileHeader.Signature, _gheaderVer5w, 20 );

   CompositeFileHeader.CoverPageSize = m_size ;
   CompositeFileHeader.EmfSize = 0 ;
   CompositeFileHeader.NbrOfTextRecords = 0 ;
   //
   // Get the default printer to use as a reference device for the metafile.
   //
   LPTSTR  pDriver ;
   LPTSTR  pDevice ;
   LPTSTR  pOutput ;
   TCHAR  PrinterName[MAX_PATH];
   CDC ReferenceDC ;
   CDC *pScreenDC ;
   POSITION vpos = GetFirstViewPosition();
   CDrawView* pView = (CDrawView*)GetNextView(vpos);
   pScreenDC = pView->GetWindowDC();
   BOOL PrinterFound = FALSE;

   GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), PrinterName, MAX_PATH ) ;

   if(( pDevice = _tcstok( PrinterName, TEXT(","))) &&
      ( pDriver = _tcstok( NULL, TEXT(", "))) &&
      ( pOutput = _tcstok( NULL, TEXT(", ")))) 
   {
      PrinterFound = ReferenceDC.CreateDC( pDriver, pDevice, pOutput, NULL ) ;
   }

   //
   //  Make sure m_size agrees with current default printer settings.
   //

   ComputePageSize() ;

   //
   // Create an enhanced metafile in a buffer in memory, containing all of the graphics.
   //

   CRect Rect( 0,
               0,
               MulDiv( m_size.cx, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ),
               MulDiv( m_size.cy, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ));
   CMetaFileDC mDC ;

   //
   //  If no default printer exists, use the screen as reference device.
   //

   INT hdc = mDC.CreateEnhanced( !PrinterFound ? pScreenDC : &ReferenceDC,
                                 NULL,
                                 LPCRECT(Rect),
                                 NULL ) ;
   if( !hdc ){
       TRACE( TEXT("Failed to create the enhanced metafile"));
   }
#if 0
   //
   // The MM_ANISOTROPIC matches well as long as the laser printer or fax printer is the
   // reference device, but mismatches miserably when the screen is the reference device.
   //
   mDC.SetMapMode( MM_ANISOTROPIC );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   mDC.SetViewportExt( !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSX)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSX ),
                       !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSY)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSY ));
   mDC.SetWindowExt(100,-100);
   mDC.SetViewportOrg( 0, 0 );
#endif
   mDC.SetMapMode( MM_LOENGLISH );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   pView->ReleaseDC( pScreenDC );
   //
   //  Iterate the list of objects, drawing everything but text objects to the metafile.
   //  Count text boxes as we go.
   //  Consider each serializeable class separately, just to be safe!!!
   //
   if( ! m_objects.IsEmpty())
   {
      vpos = GetFirstViewPosition();
      pView = (CDrawView*) GetNextView( vpos ) ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ) 
      {
         CObject* pCurrentObject = m_objects.GetNext(pos) ;
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pCurrentObject )
         {
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pCurrentObject->GetRuntimeClass()))
         {
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){

             ++CompositeFileHeader.NbrOfTextRecords ; // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){

             ++CompositeFileHeader.NbrOfTextRecords ;  // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else {
             CDrawObj* pThisObj = (CDrawObj*) pCurrentObject ;
             pThisObj->Draw( &mDC, pView );
         }
      }
   }
   /////////CDrawView::m_IsRecording = FALSE;                // re-enable the scroll bar
   LPBYTE MBuffer ;
   HENHMETAFILE hEMF = mDC.CloseEnhanced();
   if( !hEMF )
   {
   }
   CompositeFileHeader.EmfSize = GetEnhMetaFileBits( hEMF, NULL, NULL ) ;
   if(!CompositeFileHeader.EmfSize)
   {
   }
   ar.Write( &CompositeFileHeader, sizeof(CompositeFileHeader));
   HGLOBAL hglobal ;
   if(( CompositeFileHeader.EmfSize ) &&
      ( hglobal = GlobalAlloc( GMEM_MOVEABLE, CompositeFileHeader.EmfSize )) &&
      ( MBuffer = (LPBYTE)GlobalLock(hglobal)) &&
      ( GetEnhMetaFileBits( hEMF, CompositeFileHeader.EmfSize, MBuffer ))) 
   {
      ar.Write( MBuffer, CompositeFileHeader.EmfSize ) ;
      GlobalUnlock( hglobal ) ;
      GlobalFree( hglobal );
   }
   //
   // Reiterate the m_objects list and write the text boxes to the file
   //
   if( !m_objects.IsEmpty()){
      TEXTBOXW TextBoxW ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ){
         CObject* pObj = m_objects.GetNext(pos) ;
         //
         //  For each CDrawText and CFaxProp object,
         //  put a TEXTBOXW and string in the file.
         //
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pObj ){
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pObj->GetRuntimeClass())){
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){
              DWORD Length = 0;
              LPCTSTR lptstrText = NULL;
              LPWSTR lpwstrUnicodeText = NULL;
              CDrawText* pThisObj = (CDrawText*) pObj ;
            
              if (CopyTLogFontToWLogFont(pThisObj->m_logfont,TextBoxW.FontDefinition) != ERROR_SUCCESS)
              {
                  AfxThrowMemoryException() ;
              }

              TextBoxW.ResourceID = 0 ;
              TextBoxW.TextColor = pThisObj->m_crTextColor ;
              TextBoxW.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBoxW.PositionOfTextBox = (RECT) pThisObj->m_position ;
              CString textString =  pThisObj->GetEditTextString();
              lptstrText = (LPCTSTR)textString;
#ifndef _UNICODE
              lpwstrUnicodeText = AnsiStringToUnicodeString(lptstrText);
              if (!lpwstrUnicodeText)
              {
                    AfxThrowMemoryException();
              }
#else
              lpwstrUnicodeText = (LPWSTR) lptstrText;
#endif          
              Length = wcslen(lpwstrUnicodeText) * sizeof(WCHAR);
              TextBoxW.NumStringBytes = Length;
              ar.Write( &TextBoxW, sizeof(TEXTBOXW));
              ar.Write( lpwstrUnicodeText, Length);
#ifndef _UNICODE
              MemFree(lpwstrUnicodeText);
#endif
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){
              CFaxProp* pThisObj = (CFaxProp*) pObj ;

              if (CopyTLogFontToWLogFont(pThisObj->m_logfont,TextBoxW.FontDefinition) != ERROR_SUCCESS)
              {
                  AfxThrowMemoryException() ;
              }

              TextBoxW.TextColor = pThisObj->m_crTextColor ;
              TextBoxW.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBoxW.PositionOfTextBox = (RECT) pThisObj->m_position ;
              TextBoxW.ResourceID = pThisObj->GetResourceId();
              TextBoxW.NumStringBytes = 0 ;
              ar.Write( &TextBoxW, sizeof(TEXTBOXW));
         }
         else { // This won't happen.
         }
       }
   }
}

void CDrawDoc::SeekPastInformationForPrinting( CArchive& ar )
{
  //
  // Start over from beginning of file and read in the file header.
  //
  ar.GetFile()->SeekToBegin();
  COMPOSITEFILEHEADER CompositeFileHeader;
  UINT BytesRead = ar.Read( &CompositeFileHeader, sizeof(COMPOSITEFILEHEADER));
  if(BytesRead != sizeof(COMPOSITEFILEHEADER)){
      //
      // Any exception will do.  The CATCH_ALL in CDrawDoc::Serialize() is the target.
      //
      AfxThrowMemoryException() ;
  }
  void * pBuffer ;
  HLOCAL hMem;

  //
  // Seek past the metafile.  It is only for printing with
  // the WINAPI function PrtCoverPage.
  //

  if( CompositeFileHeader.EmfSize ){
          hMem = LocalAlloc( LMEM_MOVEABLE, CompositeFileHeader.EmfSize );
          if( NULL == hMem ){
              LocalFree( hMem );
              AfxThrowMemoryException() ; // See above.  Any exception will do.
          }
          pBuffer = LocalLock( hMem );
          if( NULL == pBuffer ){
              AfxThrowMemoryException();
          }
          if( CompositeFileHeader.EmfSize != ar.Read( pBuffer, CompositeFileHeader.EmfSize )){
              LocalUnlock( pBuffer );
              LocalFree( hMem );
              AfxThrowMemoryException() ;
          }
          LocalUnlock( pBuffer );
          LocalFree( hMem );
  }

  //
  // Skip over the text boxes.  These are used only by PrtCoverPage.
  // Each text box is followed by a variable length string.
  //

  UINT SizeOfTextBox = sizeof(TEXTBOXW) ;
  for( DWORD Index = 0 ; Index < CompositeFileHeader.NbrOfTextRecords ; ++Index ){
       TEXTBOXW TextBoxW ;
       if( sizeof(TEXTBOXW) != ( BytesRead = ar.Read( &TextBoxW, sizeof(TEXTBOXW)))){
           AfxThrowMemoryException();
       }
       if( TextBoxW.NumStringBytes ){
           hMem = LocalAlloc( LMEM_MOVEABLE, TextBoxW.NumStringBytes );
           if( NULL == hMem ){
               AfxThrowMemoryException() ;
           }
           pBuffer = LocalLock( hMem );
           if( NULL == pBuffer ){
               LocalFree( hMem ) ;
               AfxThrowMemoryException() ;
           }
           if( TextBoxW.NumStringBytes != ar.Read( pBuffer, TextBoxW.NumStringBytes )){
               LocalUnlock( pBuffer );
               LocalFree( hMem );
               AfxThrowMemoryException();
           }
           LocalUnlock( pBuffer );
           LocalFree( hMem );
       }
  }
}


//--------------------------------------------------------------------------
void CDrawDoc::Draw(CDC* pDC, CDrawView* pView, CRect rcClip)
{
    POSITION pos = m_objects.GetHeadPosition();
    if( !pDC->IsPrinting() )
    { 
        // NOT PRINTING
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            if( pObj->Intersects( rcClip, TRUE ))
            {
                pObj->Draw(pDC, pView);
                if ( pView->IsSelected(pObj))
                {
                    pObj->DrawTracker(pDC, CDrawObj::selected);
                }
            }
        }
    }
    else 
    { 
        // PRINTING
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            pObj->Draw(pDC, pView);
        }
    }
}


//--------------------------------------------------------------------------
void CDrawDoc::Add(CDrawObj* pObj,BOOL bUndo /*=TRUE*/)
{
    CDrawView *pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

#if 0
    if (bUndo)
        pView->AddToUndo(new CAddUndo(pObj));
#endif

    if (bUndo){
        pView->SaveStateForUndo();
    }
        m_objects.AddTail(pObj);
        pObj->m_pDocument = this;
        SetModifiedFlag();
}


//--------------------------------------------------------------------------
void CDrawDoc::DeleteContents()
{
    Remove();

    CDrawView* pView = CDrawView::GetView();
    if (pView){
        pView->DisableUndo();
    }
    CDrawView::FreeObjectsMemory( & m_previousStateForUndo );
    m_previousStateForUndo.RemoveAll();
}


//--------------------------------------------------------------------------
void CDrawDoc::Remove(CDrawObj* pObj /*=NULL*/)
{
    CDrawView* pView = CDrawView::GetView();

    if (pObj==NULL) 
    {                    //remove all document objects
        if (pView) 
        {
            if (pView->m_pObjInEdit) 
            {                //first destroy edit window
                pView->m_pObjInEdit->m_pEdit->DestroyWindow();
                pView->m_pObjInEdit=NULL;
            }
        }
        POSITION pos = m_objects.GetHeadPosition();
        while (pos != NULL) 
        {
            CDrawObj* pobj = (CDrawObj*)m_objects.GetNext(pos);
            if (!pobj)
            {
                break;
            }
            if (pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) 
            {
                COleClientItem* pItem=((CDrawOleObj*)pobj)->m_pClientItem;
                if (pItem)  
                { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    RemoveItem(pItem);
                    pItem->InternalRelease();
                }
            }
            delete pobj;         //delete object
        }
        m_objects.RemoveAll();
        if (pView)
        {
            pView->m_selection.RemoveAll();     //remove pointers from selection list
        }
    }
    else 
    {
        if (pView) 
        {
            if (pObj==pView->m_pObjInEdit) 
            {
                pView->m_pObjInEdit->m_pEdit->DestroyWindow();
                pView->m_pObjInEdit=NULL;
            }
        }
        POSITION pos = m_objects.Find(pObj);
        if (pos != NULL) 
        {
            m_objects.RemoveAt(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) 
            {
                COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                if (pItem)  
                { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem);
                    pItem->InternalRelease();
                }
            }
            if (pView)
            {
                pView->Remove(pObj);
            }
            delete pObj;
        }
    }
}   // CDrawDoc::Remove

//--------------------------------------------------------------------------
CDrawObj* CDrawDoc::ObjectAt(const CPoint& point)
{
        CRect rc;
    rc.top=point.y+2;
        rc.bottom=point.y-2;
        rc.left=point.x-2;
        rc.right=point.x+2;

        POSITION pos = m_objects.GetTailPosition();
        while (pos != NULL) {
                CDrawObj* pObj = (CDrawObj*)m_objects.GetPrev(pos);
        if (pObj->Intersects(rc))
                            return pObj;
        }

        return NULL;
}


//--------------------------------------------------------------------------
void CDrawDoc::ComputePageSize()
{
    CSize new_size;
        BOOL do_default = FALSE;

    CPrintDialog dlg(FALSE);
    if (AfxGetApp()->GetPrinterDeviceDefaults(&dlg.m_pd)) 
    {
        LPDEVMODE  lpDevMode = (dlg.m_pd.hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(dlg.m_pd.hDevMode) : NULL;

#ifdef _DEBUG
        if (m_wOrientation==DMORIENT_PORTRAIT)
        {
            TRACE( TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to portrait \n"));
        }
        else
        {
            TRACE(TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to landscape \n"));
        }
#endif
        if (lpDevMode)
        {
            lpDevMode->dmPaperSize=m_wPaperSize;     // version 3 param
            lpDevMode->dmOrientation=m_wOrientation; // version 2 param

            // use doc scale only if printer supports scaleing
            if( lpDevMode->dmFields & DM_SCALE )
            {
                lpDevMode->dmScale   = m_wScale;
            }
            else
            {
                lpDevMode->dmScale   = 100;
            }

        }
        if (dlg.m_pd.hDevMode != NULL)
        {
            ::GlobalUnlock(dlg.m_pd.hDevMode);
        }

        CDC dc;
        HDC hDC= dlg.CreatePrinterDC();

        // don't fail if no printer, just use defaults
        if( hDC != NULL )
        {
            dc.Attach(hDC);

            // Get the size of the page in loenglish
            new_size.cx=MulDiv(dc.GetDeviceCaps(HORZSIZE),1000,254);
            new_size.cy=MulDiv(dc.GetDeviceCaps(VERTSIZE),1000,254);
        }
        else
        {
            do_default = TRUE;
        }
    }
    else
    {
        do_default = TRUE;
    }


    if( do_default )
    {
        // couldn't get at printer goo, just make a guess
        if (m_wOrientation==DMORIENT_PORTRAIT)
        {
            new_size.cx=850;   // 8.5 inches
            new_size.cy=1100;  // 11 inches
        }
        else
        {
            new_size.cx=1100;  // 11 inches
            new_size.cy=850;   // 8.5 inches
        }
    }


    if (new_size != m_size)  
    {
        m_size = new_size;
        POSITION pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            ((CDrawView*)GetNextView(pos))->SetPageSize(m_size);
        }
    }
}   // CDrawDoc::ComputePageSize




//--------------------------------------------------------------------------
void CDrawDoc::OnViewPaperColor()
{
        CColorDialog dlg;
        if (dlg.DoModal() != IDOK)
                return;

        m_paperColor = dlg.GetColor();
        SetModifiedFlag();
        UpdateAllViews(NULL);
}

UINT_PTR 
CALLBACK 
OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
/*++

Routine name : OFNHookProc

Routine description:

    Callback function that is used with the 
    Explorer-style Open and Save As dialog boxes.
    Refer MSDN for more info.

--*/
{
    UINT_PTR nRes = 0;

    if(WM_NOTIFY == uiMsg)
    {
        LPOFNOTIFY pOfNotify = (LPOFNOTIFY)lParam;
        if(CDN_FILEOK == pOfNotify->hdr.code)
        {
            if(_tcslen(pOfNotify->lpOFN->lpstrFile) > (MAX_PATH-10))
            {
                AlignedAfxMessageBox(IDS_SAVE_AS_TOO_LONG, MB_OK | MB_ICONEXCLAMATION);
                SetWindowLong(hdlg, DWLP_MSGRESULT, 1);
                nRes = 1;
            }
        }
    }
    return nRes;
}


//--------------------------------------------------------------------------
BOOL CDrawDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
    if (!IsOkToClose())                  //added to check for existence of fax properties
    {
        return FALSE;
    }

    CString newName = lpszPathName;
    if (newName.IsEmpty())  /// SAVE AS rather than SAVE
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);
        newName = m_strPathName;
        if (bReplace && newName.IsEmpty()) 
        {
             newName = m_strTitle;

             // append the default suffix if there is one
             CString strExt;
             if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) && !strExt.IsEmpty())
             {
                 ASSERT(strExt[0] == TEXT('.'));
                 newName += strExt;
             }
         }
         CString UpperNewName = newName ;
         UpperNewName.MakeUpper();
         if( UpperNewName.Right(4) == TEXT(".CPE"))
         {
             int Length = newName.GetLength() - 4 ;   /// Get rid of the ".CPE"
             newName = newName.Left( Length );
             newName += FAX_COVER_PAGE_FILENAME_EXT;   ////// Suggest the ".COV" extension.
         }
         if ( !((CDrawApp*)AfxGetApp())->IsInConvertMode() )
         {
             if (!((CDrawApp*)AfxGetApp())->DoPromptFileName(
                 newName,
                 bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
                 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                 FALSE,
                 pTemplate,
                 OFNHookProc))
             {
                 return FALSE;       // don't even attempt to save
             }
         }
         else
         {  
            //
            // The cover page application is in mode to convert CPE's to COV's.
            //
            TCHAR tszClientDir[2*MAX_PATH] = {0};
            //
            // save the coverted CPE file into CSIDL_PERSONAL\Fax\Personal Coverpages
            //
            if (GetClientCpDir (tszClientDir, ARR_SIZE(tszClientDir)))
            {
                CFile _newFile;
                _newFile.SetFilePath(newName);
                newName=_newFile.GetFileName();
                CString newPath = tszClientDir;
                newName = newPath + newName;
            }
         }
    }

    //
    // If called by SaveModified () on exiting, and the NewName happens to be the name of a
    // read only file, we would get a popup "Access to %1 denied" and exit without further
    // chance to save.  We avoid that scenario by checking the attributes and doing the popup
    // ourselves.  a-juliar, 9-26-96
    //

    DWORD newFileAttributes = GetFileAttributes( (LPCTSTR)newName );

    if ( (0xFFFFFFFF != newFileAttributes) &&
        ((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // the file exists in the personal cover page folder. don't transfer it.
        // this is a speced limitation of this feature.
        //
        return TRUE;
    }


    if ( 0xFFFFFFFF != newFileAttributes &&
        ((FILE_ATTRIBUTE_READONLY & newFileAttributes ) ||
        (FILE_ATTRIBUTE_DIRECTORY & newFileAttributes )))
    {
        CString ThisMess ;
        AfxFormatString1( ThisMess, AFX_IDP_FILE_ACCESS_DENIED, newName );
        AlignedAfxMessageBox( ThisMess );
        return FALSE ;    // Don't exit without saving.
    }
    

    BeginWaitCursor();
    if (!OnSaveDocument(newName))
    {
        if (lpszPathName == NULL)
        {
        // be sure to delete the file
            try
            {
                CFile::Remove(newName);
            }
            catch(CException* e )
            {
                TRACE0("Warning: failed to delete file after failed SaveAs.\n");
                e->Delete();
            }
            catch(...)
            {
            }
        }
        EndWaitCursor();
        return FALSE;
    }

    // reset the title and change the document name
    if (bReplace)
    {
        SetPathName(newName);
    }
    EndWaitCursor();
    return TRUE;        // success
}
//--------------------------------------------------------------------------
void CDrawDoc::CloneObjectsForUndo()
{
    POSITION pos = m_objects.GetHeadPosition();
    while( pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
        CDrawObj* pClone = pObj->Clone( NULL );
        m_previousStateForUndo.AddTail( pClone );
    }
}
//--------------------------------------------------------------------------
void CDrawDoc::SwapListsForUndo()
{
    INT_PTR iPreviousCount = m_previousStateForUndo.GetCount();
    m_previousStateForUndo.AddTail( & m_objects );
    m_objects.RemoveAll();
    for( int index = 0 ; index < iPreviousCount ; ++ index ){
         CObject * pObj = m_previousStateForUndo.RemoveHead();
         m_objects.AddTail( pObj );
    }
}
//---------------------------------------------------------------------------
BOOL CDrawDoc::IsOkToClose()
{
    CDrawApp* pApp = (CDrawApp*)AfxGetApp();
    BOOL bFaxObj=FALSE;

    if ( !(pApp->m_bCmdLinePrint || pApp->m_dwSesID!=0) ) {
       POSITION pos = m_objects.GetHeadPosition();
       while (pos != NULL) {
          CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
          if (pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ) {
                 bFaxObj=TRUE;
             break;
                  }
           }
       if (!bFaxObj)
           if (CPEMessageBox(MSG_INFO_NOFAXPROP, NULL, MB_YESNO, IDS_INFO_NOFAXPROP)==IDNO)
             return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------
void CDrawDoc::SetPathName( LPCTSTR lpszPathName, BOOL bAddToMRU )
{
        COleDocument::SetPathName( lpszPathName, bAddToMRU );

#if !defined( _NT ) && !defined( WIN32S )
        SHFILEINFO sfi;

        if( GetFileAttributes( lpszPathName ) != 0xffffffff ) {
                if( SHGetFileInfo( lpszPathName, 0, &sfi, sizeof( sfi ), SHGFI_DISPLAYNAME ) )  {
                        SetTitle( sfi.szDisplayName );
                }
        }
#endif
}

//---------------------------------------------------------------------------

void CDrawDoc::OnFileSave()
{
  // This override was added to "enforce" the .COV file extension when saving.  a-juliar, 9-19-96
    CString FileName = m_strPathName ;
    FileName.MakeUpper();
    if( FileName.Right(4) == TEXT( ".CPE" )){
        OnFileSaveAs();
    }
    else {
        CDocument::OnFileSave();
    }
}
//---------------------------------------------------------------------------
void CDrawDoc::OnFileSaveAs()
{
    CDocument::OnFileSaveAs() ;
}
//---------------------------------------------------------------------------
void CDrawDoc::OnUpdateFileSave(CCmdUI* pCmdUI)
{
   pCmdUI->Enable(TRUE);
}



#ifdef _DEBUG
void CDrawDoc::AssertValid() const
{
        COleDocument::AssertValid();
}

void CDrawDoc::Dump(CDumpContext& dc) const
{
        COleDocument::Dump(dc);
}
#endif //_DEBUG


BOOL CDrawDoc::SaveModified()
{
    //
    // Overridden to enforce the ".COV" file extension. 9-26-96, a-juliar
    //
    // Copied from COleDocument::SaveModified
    // determine if necessary to discard changes
    if (::InSendMessage())
    {
        POSITION pos = GetStartPosition();
        COleClientItem* pItem;
        while ((pItem = GetNextClientItem(pos)) != NULL)
        {
            ASSERT(pItem->m_lpObject != NULL);
            SCODE sc = pItem->m_lpObject->IsUpToDate();
            if (sc != OLE_E_NOTRUNNING && FAILED(sc))
            {
                //
                // inside inter-app SendMessage limits the user's choices
                //
                CString name = m_strPathName;
                if (name.IsEmpty())
                {
                    VERIFY(name.LoadString(AFX_IDS_UNTITLED));
                }

                CString prompt;
                AfxFormatString1(prompt, AFX_IDP_ASK_TO_DISCARD, name);
                return AlignedAfxMessageBox(prompt, MB_OKCANCEL|MB_DEFBUTTON2, AFX_IDP_ASK_TO_DISCARD) == IDOK;
            }
        }
    }
    //
    // sometimes items change without a notification, so we have to
    // update the document's modified flag before calling CDocument::SaveModified.
    //
    UpdateModifiedFlag();

    if (!IsModified())
    {
        return TRUE;        // ok to continue
    }
    //
    // Get name/title of document
    //
    CString name;
    if (m_strPathName.IsEmpty())
    {
        // Get name based on caption
        name = m_strTitle;
        if (name.IsEmpty())
        {
            VERIFY(name.LoadString(AFX_IDS_UNTITLED));
        }
    }
    else
    {
        // Get name based on file title of path name
        name = m_strPathName;
    }

    int iMessageBoxRes = IDYES;
    if (!((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        CString prompt;
        AfxFormatString1(prompt, AFX_IDP_ASK_TO_SAVE, name);
        iMessageBoxRes = AlignedAfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE);
    }
    switch (iMessageBoxRes)
    {
        case IDCANCEL:
            return FALSE;       // don't continue

        case IDYES:
            {
                //
                // Enforce the ".COV" extension.
                //
                CString FileName = m_strPathName ;
                FileName.MakeUpper();
                if ( FileName.Right(4) != FAX_COVER_PAGE_FILENAME_EXT)
                {
                    return DoSave(NULL) ;
                }
                else 
                {
                    return DoFileSave();
                }
                break;
            }
        case IDNO:
            // If not saving changes, revert the document
            break;

        default:
            ASSERT(FALSE);
            break;
        }
    return TRUE;    // keep going
}   // CDrawDoc::SaveModified


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawDoc, COleDocument)
   //{{AFX_MSG_MAP(CDrawDoc)
        ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_NOTE, OnUpdateMapiMsgNote)
        //}}AFX_MSG_MAP
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
   ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
   ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleDocument::OnUpdateObjectVerbMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
   ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
   ON_COMMAND(ID_FILE_SAVE, OnFileSave)
   ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
END_MESSAGE_MAP()




void CDrawDoc::OnUpdateMapiMsgNote(CCmdUI* pCmdUI)
        {
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
                                {
                                // only allow one note, don't let user make any more
                                pCmdUI->Enable( FALSE );
                                return;
                                }
                        }
        }

        // No notes, let user make one
        pCmdUI->Enable( TRUE );

        }



void CDrawDoc::
        schoot_faxprop_toend( WORD res_id )
        /*
                Moves all CFaxProps objects in m_objects that are of
                type res_id to the end of the list.

                Can throw a CMemoryException
         */
        {
        CObList temp_obs;
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos, cur_pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
                cur_pos = pos;
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == res_id )
                                {
                                // move prop to temporary list
                                temp_obs.AddTail( pObj );

                                // remove from original list
                                m_objects.RemoveAt( cur_pos );
                                }
                        }
        }

        // put all found objects at end of original list
        m_objects.AddTail( &temp_obs );

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpeedt.h ===
//--------------------------------------------------------------------------
// cpeedt.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEEDT_H__
#define __CPEEDT_H__

class CDrawObj;
class CDrawView;
class CDrawText;


class CTextEdit : public CEdit
{

public:
    CTextEdit();
    CTextEdit(CDrawObj*);

protected:
    CDrawObj* m_pDrawObj;
    DECLARE_SERIAL(CTextEdit);
    CDrawText* m_pTextBoxForUndo ;

#ifdef _DEBUG
    void AssertValid();
#endif
    virtual void Serialize(CArchive& ar);

    //{{AFX_MSG(CTextEdit)
    //}}AFX_MSG
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnChar(UINT, UINT, UINT);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);

    DECLARE_MESSAGE_MAP()
};



#endif   //#ifndef __CPEEDT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cntritem.cpp ===
//============================================================================
// cntritem.h : interface of the CDrawItem class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      OLE draw item for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//============================================================================

#include "stdafx.h"
#include "awcpe.h"
#include "cpedoc.h"
#include "cpeobj.h"
#include "cpevw.h"
#include "cntritem.h"
#include "dialogs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDrawItem implementation

IMPLEMENT_SERIAL(CDrawItem, COleClientItem, 0)

CDrawItem::CDrawItem(CDrawDoc* pContainer, CDrawOleObj* pDrawObj)
	: COleClientItem(pContainer)
{
	m_pDrawObj = pDrawObj;
}


CDrawItem::~CDrawItem()
{
	// TODO: add cleanup code here
}

void CDrawItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	switch(nCode)
	{
	case OLE_CHANGED_STATE:
	case OLE_CHANGED_ASPECT:
		m_pDrawObj->Invalidate();
		break;
	case OLE_CHANGED:
		UpdateExtent(); // extent may have changed
		m_pDrawObj->Invalidate();
		break;
	}
}


BOOL CDrawItem::DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg)
{
	ASSERT_VALID(this);
	if (pView != NULL)
		ASSERT_VALID(pView);
	if (lpMsg != NULL)
		ASSERT(AfxIsValidAddress(lpMsg, sizeof(MSG), FALSE));

    try
    {
		Activate(nVerb, pView, lpMsg);
	}
    catch(COleException* e)
    {
	    if (e->m_sc==OLE_E_STATIC) 
        {
            CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_OLE_STATIC_OBJECT);
        }
		else if (!ReportError(e->m_sc))
        {
		    AlignedAfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
        }

        e->Delete();
		return FALSE;
	}
    catch(CException* e)
    {
		// otherwise, show generic error
		AlignedAfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
        e->Delete();
		return FALSE;
	}
    catch(...)
    {
        return FALSE;
    }

	return TRUE;
}



BOOL CDrawItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	CRect rect = rectPos;
	pView->ClientToDoc(rect);

	if (rect != m_pDrawObj->m_position)
	{
		// invalidate old rectangle
		m_pDrawObj->Invalidate();

		// update to new rectangle
		m_pDrawObj->m_position = rect;
		GetExtent(&m_pDrawObj->m_extent);

		// and invalidate new rectangle
		m_pDrawObj->Invalidate();

		// mark document as dirty
		GetDocument()->SetModifiedFlag();
	}
	return COleClientItem::OnChangeItemPosition(rectPos);
}

void CDrawItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// update to extent of item if m_position is not initialized
	if (m_pDrawObj->m_position.IsRectEmpty())
		UpdateExtent();

	// copy m_position, which is in document coordinates
	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	rPosition = m_pDrawObj->m_position;
	pView->DocToClient(rPosition);
}

void CDrawItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Note: this sets up the m_pDocument pointer returned from
	//  CDrawItem::GetDocument, therefore it is a good idea
	//  to call the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CDrawItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

BOOL CDrawItem::UpdateExtent()
{
	CDC	  dc;
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	if( dc.CreateCompatibleDC( NULL ) )
		{
		dc.SetMapMode( MM_TEXT );
		dc.HIMETRICtoLP( &size ); // convert to screen space
		dc.DeleteDC();
		}

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - size.cy;
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top - size.cy;
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}

#ifdef FUBAR
BOOL CDrawItem::UpdateExtent()
{
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + MulDiv(size.cx, 10, 254);
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - MulDiv(size.cy, 10, 254);
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left +
			MulDiv(m_pDrawObj->m_position.Width(), size.cx, m_pDrawObj->m_extent.cx);
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top +
			MulDiv(m_pDrawObj->m_position.Height(), size.cy, m_pDrawObj->m_extent.cy);
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDrawItem diagnostics

#ifdef _DEBUG
void CDrawItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CDrawItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\awcpesup.h ===
/*
 *  AWCPESUP . H
 *
 *      Microsoft AtWork Fax for Windows
 *      Copyright (C) 1993-1994, Microsoft Corporation
 *
 *      Information in this document is subject to change without notice and does
 *      not represent a commitment on the part of Microsoft Corporation.
 */

/*
 * Constants
 */


// Recipient properties
#define CPE_RECIPIENT_NAME              (0x80000001)
#define CPE_RECIPIENT_TITLE             (0x80000002)
#define CPE_RECIPIENT_DEPARTMENT        (0x80000003)
#define CPE_RECIPIENT_OFFICE_LOCATION   (0x80000004)
#define CPE_RECIPIENT_COMPANY           (0x80000005)
#define CPE_RECIPIENT_STREET_ADDRESS    (0x80000006)
#define CPE_RECIPIENT_POST_OFFICE_BOX   (0x80000007)
#define CPE_RECIPIENT_LOCALITY          (0x80000008)
#define CPE_RECIPIENT_STATE_OR_PROVINCE (0x80000009)
#define CPE_RECIPIENT_POSTAL_CODE       (0x80000010)
#define CPE_RECIPIENT_COUNTRY           (0x80000011)
#define CPE_RECIPIENT_HOME_PHONE        (0x80000012)
#define CPE_RECIPIENT_WORK_PHONE        (0x80000013)
#define CPE_RECIPIENT_FAX_PHONE         (0x80000014)

// Sender properties
#define CPE_SENDER_NAME                 (0x08000001)
#define CPE_SENDER_TITLE                (0x08000002)
#define CPE_SENDER_DEPARTMENT           (0x08000003)
#define CPE_SENDER_OFFICE_LOCATION      (0x08000004)
#define CPE_SENDER_COMPANY              (0x08000005)
#define CPE_SENDER_ADDRESS              (0x08000006)
#define CPE_SENDER_HOME_PHONE           (0x08000007)
#define CPE_SENDER_WORK_PHONE           (0x08000008)
#define CPE_SENDER_FAX_PHONE            (0x08000009)
#define CPE_RECIPIENT_TO_LIST           (0x0800000A)
#define CPE_RECIPIENT_CC_LIST           (0x0800000B)
#define CPE_SENDER_EMAIL				(0x0800000C)

// Message related properties
#define CPE_MESSAGE_SUBJECT             (0x00800001)
#define CPE_MESSAGE_SUBMISSION_TIME     (0x00800002)
#define CPE_MESSAGE_BILLING_CODE        (0x00800003)

// Miscellanous message properties
#define CPE_MISC_ATTACHMENT_NAME_LIST   (0x00800004)// ; delimeted list of attachment names
#define CPE_MISC_USER_DEFINED           (0x00800005)// lpvBuf contains LPSPropValue

// Count type properties
#define CPE_COUNT_RECIPIENTS            (0x00800006)// Total count of recipients
#define CPE_COUNT_ATTACHMENTS           (0x00800007)// Total number of attachments
#define CPE_COUNT_PAGES                 (0x00800008)// total number of pages

// Derived property so CPE can get at PR_BODY data
// using the tempfile copy of PR_BODY
#define CPE_MESSAGE_BODY_FILENAME               (0x00800009)// Temp filename for PR_BODY text

// Configuration properties
#define CPE_CONFIG_CPE_TEMPLATE         (0x00080004)
#define CPE_CONFIG_PRINT_DEVICE         (0x00080005)// The device to print to

// Finish modes
#define CPE_FINISH_PAGE                 (0x00008001) //This is used when the
                                                                                                  //CPE finishes a page with out an error
#define CPE_FINISH_ERROR                (0x00008002) // This is used when the
                                                                                                          //CPE encounters an error.
                                                                                                          //This causes the process to end and
                                                                                                          //no further processing should take place

// Finish return values
#define CPE_NEXT_PAGE                   (0x00000001)
#define CPE_DONE                        (0x80000001)
#define CPE_ERROR                       (0x80000002)


//Version info
#define AWCPESUPPORT_VERSION            (0x00010000)

/*
 * CPESupport Interface
 */
typedef ULONG FAR *LPULONG;

#undef INTERFACE
#define INTERFACE IAWCPESupport

DECLARE_INTERFACE_(IAWCPESupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

        // *** ICPESupport methods ***
        STDMETHOD(GetVersion) (THIS_ LPULONG lpulVer) PURE;
        /* This function is used for version checking,
           it is currently not implemented */

        STDMETHOD(GetProp) (THIS_ ULONG ulProp, LPULONG lpulBufSize, LPVOID lpvBuf) PURE;
        /* This function is used to retrieve properties for the Cover Page.
                ulProp is one of the property constants above.
                lpulBufSize is a pointer to the size of the buffer pointed to by lpvBuf.
                lpvBuf is a buffer where the property value is returned.  If this value is NULL,
                the size needed to hold the property is returned in lpulBufSize.
        */

        STDMETHOD(SetProp) (THIS_ ULONG ulProp, LPVOID lpvBuf) PURE;
        /* This function is used to set properties On the message.
                ulProp is one of the property constants above.
                lpvBuf is the buffer where the property value is.
        */

        STDMETHOD(GetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to retrieve the count of certain attributes, such
           as thee number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is where the count value is returned.
        */

        STDMETHOD(SetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to set the count of certain attributes, such
           as the number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is the count value.
        */

        STDMETHOD(Finish) (THIS_ ULONG ulMode) PURE;
        /* This function get called when the CPE finishes a page or encounters an error.
           The CPE passes one of the finish codes from above to the function to signal
           which case is finishing, either the page or the CPE encountered an error.
           ulMode is one of the pre defined modes.

           The function can return three modes other than normal errors:
                        CPE_NEXT_PAGE   Finish returns this to signal the CPE to start printing
                                                        the next page.

                        CPE_DONE                Finish returns this to signal the CPE that all of the
                                                        Cover pages ahve been printed.

                        CPE_ERROR               Finish returns this to signal that an error ocurred in
                                                        the transport subsystem.  The CPE should exit with out UI
                                                        and without calling finish again.

        */
};
typedef IAWCPESupport FAR * LPAWCPESUPPORT;

// Service Entry definition
extern "C" {
typedef LONG (WINAPI *AWCPESUPPORTPROC)(DWORD dwSesID, LPAWCPESUPPORT FAR* lppCPESup);
}
typedef AWCPESUPPORTPROC FAR* LPAWCPESUPPORTPROC;



/*
 * GUIDs
 */
DEFINE_GUID(IID_IAWCPESupport, 0xd1ac6c20,0x91d4,0x101b,0xae,0xcc,0x00,0x00,0x0b,0x69,0x1f,0x18);

/*
 * Registry key locations
 */


//
// ISSUE: Please see EdgeBug #12681

// This is the root level key where the CPE specific sub keys are stored
#define CPE_SUPPORT_ROOT_KEY    (TEXT("Software\\Microsoft\\At Work Fax\\Transport Service Provider"))

// This is the location where the CPE puts the command line to used when calling it to print
// cover pages at send time.  The format is total at the CPE's discretion.  The transport will
// look for the string "SESS_ID" and replace it with the current session id.  The session ID is
// a DWORD.
#define CPE_COMMAND_LINE_KEY (TEXT("Cover Page Editor"))

// This key contains the DLL name that the CPE loads to get the Support Object
#define CPE_SUPPORT_DLL_KEY (TEXT("CPE Support DLL"))

//This is the key that holds the name of the function in the Support DLL that is the actual "Service Entry"
#define CPE_SUPPORT_FUNCTION_NAME_KEY (TEXT("CPE Support Function Name"))

// END IDENTICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cntritem.h ===
//--------------------------------------------------------------------------
// CNTRITEM.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CNTRITEM_H__
#define __CNTRITEM_H__


class CDrawDoc;
class CDrawView;

class CDrawItem : public COleClientItem
{
	DECLARE_SERIAL(CDrawItem)

// Constructors
public:
	CDrawItem(CDrawDoc* pContainer = NULL, CDrawOleObj* pDrawObj = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CDrawDoc* GetDocument()
		{ return (CDrawDoc*)COleClientItem::GetDocument(); }
	CDrawView* GetActiveView()
		{ return (CDrawView*)COleClientItem::GetActiveView(); }

	CDrawOleObj* m_pDrawObj;    // back pointer to OLE draw object

// Operations
	BOOL UpdateExtent();

// Implementation
public:
	~CDrawItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

protected:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};



#endif   //#ifndef __CNTRITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpeedt.cpp ===
//---------------------------------------------------------------------------
// cpeedt.cpp - implementation for edit object
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains edit class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

IMPLEMENT_SERIAL(CTextEdit, CEdit, 0)



//---------------------------------------------------------------------------
CTextEdit::CTextEdit()
{
    m_pDrawObj=NULL;

}


//---------------------------------------------------------------------------
void CTextEdit::Serialize(CArchive& ar)
{
    CString szEditText;
    CEdit::Serialize(ar);
    if (ar.IsStoring()) {
       GetWindowText(szEditText);
       ar << szEditText;
    }
    else {
       ar >> szEditText;
       SetWindowText(szEditText);
    }
}



//---------------------------------------------------------------------------
CTextEdit::CTextEdit(CDrawObj* pDrawObj) : m_pDrawObj(pDrawObj)
{
    CDrawView * pView = CDrawView::GetView();
    m_pTextBoxForUndo = pView ? pView->m_pObjInEdit : NULL ;
}


//---------------------------------------------------------------------------
void CTextEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    CDrawView *pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

    if (nChar == VK_TAB)
    {
        pView->OnChar(nChar,nRepCnt,nFlags);
    }
    else{
        CEdit::OnChar(nChar,nRepCnt,nFlags);
    }
#if 0
    if ( m_pTextBoxForUndo )
    {
         m_pTextBoxForUndo->m_bUndoAlignment = FALSE ;
         m_pTextBoxForUndo->m_bUndoFont = FALSE ;
         m_pTextBoxForUndo->m_bUndoTextChange = TRUE ;
    }
#endif
    if ( pView && pView->m_pObjInEdit )
    {
        pView->m_pObjInEdit->m_bUndoAlignment = FALSE ;
        pView->m_pObjInEdit->m_bUndoFont = FALSE ;
        pView->m_pObjInEdit->m_bUndoTextChange = TRUE ;
    }
}


//---------------------------------------------------------------------------
BOOL CTextEdit::PreTranslateMessage(MSG* pMsg)
{
   return CEdit::PreTranslateMessage(pMsg);
}


//---------------------------------------------------------------------------
BOOL CTextEdit::OnEraseBkgnd(CDC* pDC)
{
   return CEdit::OnEraseBkgnd(pDC);
}


//---------------------------------------------------------------------------
void CTextEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
    CDrawView* pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

    if (pView->m_bFontChg) 
    {
        pView->OnSelchangeFontSize();
        pView->OnSelchangeFontName();
        pView->m_bFontChg=FALSE;
    }

    CEdit::OnLButtonDown(nFlags, point);
}

//---------------------------------------------------------------------------
void CTextEdit::OnSetFocus(CWnd* pOldWnd)
{
   CEdit::OnSetFocus(pOldWnd);
}



//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CTextEdit, CEdit)
    //{{AFX_MSG_MAP(CTextEdit)
    //}}AFX_MSG_MAP
    ON_WM_CHAR()
    ON_WM_LBUTTONDOWN()
    ON_WM_ERASEBKGND()
    ON_WM_SETFOCUS()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpeobj.cpp ===
///============================================================================
// cpeobj.cpp - implementation for drawing objects
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains drawing objects for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/14/95      Added check for too thin rects in CDrawLine::MoveHandleTo
// 3/8          Added stuff for handling notes on cpe
// 3/10         commented out rect.bottom+=2 in CDrawText::SnapToFont
// 3/22         Fixed char set bug for editboxes
//
//============================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "richedit.h"
#include <windows.h>
#include <windowsx.h>
#include <math.h>

IMPLEMENT_SERIAL(CDrawObj, CObject, 0)
IMPLEMENT_SERIAL(CDrawRect, CDrawObj, 0)
IMPLEMENT_SERIAL(CFaxText, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawText, CDrawRect, 0)
IMPLEMENT_SERIAL(CFaxProp, CDrawText, 0)
IMPLEMENT_SERIAL(CDrawLine, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawRoundRect, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawEllipse, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawPoly, CDrawObj, 0)
IMPLEMENT_SERIAL(CDrawOleObj, CDrawObj, 0)


// prototype
DWORD CopyTLogFontToWLogFont(IN const LOGFONT & lfSource,OUT LOGFONTW & lfDestW);

//
// Window style translation
//
DWORD DTStyleToESStyle(DWORD dwDTStyle);
DWORD DTStyleToEXStyle(DWORD dwDTStyle);

DWORD
CopyWLogFontToTLogFont(
			IN const LOGFONTW & lfSourceW,
			OUT      LOGFONT & lfDest)
{
/*++
Routine Description:

    This fuction copies a LogFont structure from UNICODE format
	to T format.

Arguments:
	
	  lfSourceW - reference to input UNICODE LongFont structure
	  lfDest - reference to output LongFont structure

Return Value:

	WINAPI last error

--*/

    lfDest.lfHeight = lfSourceW.lfHeight ;
    lfDest.lfWidth = lfSourceW.lfWidth ;
    lfDest.lfEscapement = lfSourceW.lfEscapement ;
    lfDest.lfOrientation = lfSourceW.lfOrientation ;
    lfDest.lfWeight = lfSourceW.lfWeight ;
    lfDest.lfItalic = lfSourceW.lfItalic ;
    lfDest.lfUnderline = lfSourceW.lfUnderline ;
    lfDest.lfStrikeOut = lfSourceW.lfStrikeOut ;
    lfDest.lfCharSet = lfSourceW.lfCharSet ;
    lfDest.lfOutPrecision = lfSourceW.lfOutPrecision ;
    lfDest.lfClipPrecision = lfSourceW.lfClipPrecision ;
    lfDest.lfQuality = lfSourceW.lfQuality ;
    lfDest.lfPitchAndFamily = lfSourceW.lfPitchAndFamily ;

	SetLastError(0);
#ifdef UNICODE
	wcscpy( lfDest.lfFaceName,lfSourceW.lfFaceName);
#else
	int iCount;
    iCount = WideCharToMultiByte(
				CP_ACP,
				0,
				lfSourceW.lfFaceName,
				-1,
				lfDest.lfFaceName,
				LF_FACESIZE,
				NULL,
				NULL
				);

	if (!iCount)
	{
		TRACE( TEXT("Failed to covert string to ANSI"));
		return GetLastError();
	}
#endif
	return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------
BOOL CALLBACK 
get_fontdata( 
    ENUMLOGFONT* lpnlf,
    NEWTEXTMETRIC* lpntm,
    int iFontType,
    LPARAM lpData 
)
/*
        Gets charset and other data for font lpnlf
 */
{
    CDrawText *pdt = (CDrawText *)lpData;

    pdt->m_logfont.lfCharSet = lpnlf->elfLogFont.lfCharSet;

    return( FALSE );
}


//---------------------------------------------------------------------------
CDrawObj::CDrawObj()
{
	Initilaize();
}

//---------------------------------------------------------------------------
CDrawObj::~CDrawObj()
{
}

//---------------------------------------------------------------------------
CDrawObj::CDrawObj(const CRect& position)
{
	Initilaize(position);    
}


//---------------------------------------------------------------------------
void CDrawObj::Initilaize(const CRect& position)
{
	m_position = position;
    m_pDocument = NULL;

    m_bPen = TRUE;
    m_logpen.lopnStyle = PS_INSIDEFRAME;

    m_lLinePointSize=1;  //default to 1

    CClientDC dc(NULL);

    m_logpen.lopnWidth.x = (long) m_lLinePointSize*100/72;  //convert to LU
    m_logpen.lopnWidth.y = (long) m_lLinePointSize*100/72;  //convert to LU

    m_logpen.lopnColor = COLOR_BLACK; 

    m_bBrush = FALSE;
    m_logbrush.lbStyle = BS_SOLID;
    m_logbrush.lbColor = COLOR_WHITE; 
    m_logbrush.lbHatch = HS_HORIZONTAL;
}


//---------------------------------------------------------------------------
void CDrawObj::Serialize(CArchive& ar)
{
    CObject::Serialize(ar);
    if (ar.IsStoring()) 
    {
        ar << m_position;
        ar << (WORD)m_bPen;
        ar.Write(&m_logpen, sizeof(LOGPEN));
        ar << (WORD)m_bBrush;
        ar.Write(&m_logbrush, sizeof(LOGBRUSH));
        ar << m_lLinePointSize;
    }
    else   
    {
        // get the document back pointer from the archive
        m_pDocument = (CDrawDoc*)ar.m_pDocument;
        ASSERT_VALID(m_pDocument);
        ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDrawDoc)));

        WORD wTemp;
        ar >> m_position;
        ar >> wTemp; 
        m_bPen = (BOOL)wTemp;
        if( sizeof(LOGPEN) != ar.Read(&m_logpen,sizeof(LOGPEN)))
        {
             AfxThrowMemoryException() ; // Any exception will do.
        }
        ar >> wTemp; 
        m_bBrush = (BOOL)wTemp;
        if( sizeof(LOGBRUSH) != ar.Read(&m_logbrush, sizeof(LOGBRUSH)))
        {
             AfxThrowMemoryException(); // Aiming for the CATCH_ALL block in CDrawDoc::Serialize
        }
        ar >> m_lLinePointSize;
    }
}


//---------------------------------------------------------------------------
void CDrawObj::Draw(CDC*, CDrawView* )
{
}


//---------------------------------------------------------------------------
CDrawObj& CDrawObj::operator=(const CDrawObj& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

//   (CObject&)*this=rdo;  //assign cobject part

   m_bPen = rdo.m_bPen;
   m_logpen = rdo.m_logpen;
   m_bBrush = rdo.m_bBrush;
   m_logbrush = rdo.m_logbrush;
   m_lLinePointSize=rdo.m_lLinePointSize;
   m_pDocument=rdo.m_pDocument;

   return *this;
}


//---------------------------------------------------------------------------
void CDrawObj::DrawTracker(CDC* pDC, TrackerState state)
{
    ASSERT_VALID(this);

    switch (state) 
    {
      case normal:
        break;

      case selected:
      case active: 
      {
         int nHandleCount = GetHandleCount();
         for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) 
         {
            CPoint handle = GetHandle(nHandle);
            pDC->PatBlt(handle.x - 3, handle.y - 3, 7, 7, DSTINVERT);
         }
      }
      break;
    }
}

//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);

    if (position == m_position)
        return;

    Invalidate();
    m_position = position;
    Invalidate();
	
    m_pDocument->SetModifiedFlag();

    pView->UpdateStatusBar();
}


//---------------------------------------------------------------------------
// Note: if bSelected, hit-codes start at one for the top-left
// and increment clockwise, 0 means no hit.
// If !bSelected, 0 = no hit, 1 = hit (anywhere)
// point is in logical coordinates
//---------------------------------------------------------------------------
int CDrawObj::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    if (bSelected) {
        int nHandleCount = GetHandleCount();
        for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) 
        {
            // GetHandleRect returns in logical coords
            CRect rc = GetHandleRect(nHandle,pView);
            if (point.x >= rc.left && point.x < rc.right &&
                point.y <= rc.top && point.y > rc.bottom)
            {                
                return nHandle;
            }
        }
    }
    else  
    {
       if (point.x >= m_position.left && point.x < m_position.right &&
             point.y <= m_position.top && point.y > m_position.bottom)
       {             
          return 1;
       }
    }
    return 0;
}


//---------------------------------------------------------------------------
BOOL CDrawObj::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect fixed = m_position;
    fixed.NormalizeRect();
    CRect rectT = rect;
    rectT.NormalizeRect();
    return !(rectT & fixed).IsRectEmpty();
}


//---------------------------------------------------------------------------
BOOL CDrawObj::ContainedIn(const CRect& rect)
{
    ASSERT_VALID(this);

    CRect fixed = m_position;
    fixed.NormalizeRect();
    CRect rectT = rect;
    rectT.NormalizeRect();

    // prevent rects that are too skinny or short
    if( fixed.left == fixed.right )
            fixed.right = fixed.left+1;

    if( fixed.top == fixed.bottom )
            fixed.bottom = fixed.top+1;

    return ((rectT | fixed)==rectT);
}


//---------------------------------------------------------------------------
int CDrawObj::GetHandleCount()
{
    ASSERT_VALID(this);
    return 8;
}


//---------------------------------------------------------------------------
// returns logical coords of center of handle
//---------------------------------------------------------------------------
CPoint CDrawObj::GetHandle(int nHandle)
{
    ASSERT_VALID(this);
    int x, y, xCenter, yCenter;

    // this gets the center regardless of left/right and top/bottom ordering
    xCenter = m_position.left + m_position.Width() / 2;
    yCenter = m_position.top + m_position.Height() / 2;

    switch (nHandle)
    {
    default:
        ASSERT(FALSE);

    case 1:
        x = m_position.left;
        y = m_position.top;
        break;

    case 2:
        x = xCenter;
        y = m_position.top;
        break;

    case 3:
        x = m_position.right;
        y = m_position.top;
        break;

    case 4:
        x = m_position.right;
        y = yCenter;
        break;

    case 5:
        x = m_position.right;
        y = m_position.bottom;
        break;

    case 6:
        x = xCenter;
        y = m_position.bottom;
        break;

    case 7:
        x = m_position.left;
        y = m_position.bottom;
        break;

    case 8:
        x = m_position.left;
        y = yCenter;
        break;
    }

    return CPoint(x, y);
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawObj::GetHandleRect(int nHandleID, CDrawView* pView)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    CRect rect;
    // get the center of the handle in logical coords
    CPoint point = GetHandle(nHandleID);
    // convert to client/device coords
    pView->DocToClient(point);
    // return CRect of handle in device coords
    rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
    pView->ClientToDoc(rect);

    return rect;
}


//---------------------------------------------------------------------------
HCURSOR CDrawObj::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    LPCTSTR id;
    switch (nHandle) 
    {
    default:
        ASSERT(FALSE);

    case 1:
    case 5:
        id = IDC_SIZENWSE;
        break;

    case 2:
    case 6:
        id = IDC_SIZENS;
        break;

    case 3:
    case 7:
        id = IDC_SIZENESW;
        break;

    case 4:
    case 8:
        id = IDC_SIZEWE;
        break;
    }

    return AfxGetApp()->LoadStandardCursor(id);
}


//---------------------------------------------------------------------------
// point must be in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CRect position = m_position;
    switch (nHandle)
    {
    default:
        ASSERT(FALSE);

    case 1:
        position.left = point.x;
        position.top = point.y;
        break;

    case 2:
        position.top = point.y;
        break;

    case 3:
        position.right = point.x;
        position.top = point.y;
        break;

    case 4:
        position.right = point.x;
        break;

    case 5:
        position.right = point.x;
        position.bottom = point.y;
        break;

    case 6:
        position.bottom = point.y;
        break;

    case 7:
        position.left = point.x;
        position.bottom = point.y;
        break;

    case 8:
        position.left = point.x;
        break;
    }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) 
   {
      TRACE(TEXT("AWCPE: CDrawObj::Invalidate, missing View pointer\n"));
      return;
   }

   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) 
   {
	   LONG width = m_logpen.lopnWidth.x + 4; // this width is big enough so no traces are left.
       rect.left -= width;
       rect.top -= width;
       rect.right += width;
       rect.bottom += width;
   }

   pView->InvalidateRect(rect, FALSE);
}// Invalidate()


//---------------------------------------------------------------------------
CDrawObj* CDrawObj::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawObj* pClone = new CDrawObj(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    return pClone;
}


//---------------------------------------------------------------------------
void CDrawObj::OnDblClk(CDrawView* )
{
}


#ifdef _DEBUG
void CDrawObj::AssertValid()
{
   ASSERT(m_position.left <= m_position.right);
   ASSERT(m_position.bottom <= m_position.top);
}
#endif


//*********************************************************************
// CDrawRect
//*********************************************************************

//---------------------------------------------------------------------------
CDrawRect::CDrawRect()
{
}


//---------------------------------------------------------------------------
CDrawRect::~CDrawRect()
{
}

//---------------------------------------------------------------------------
CDrawRect::CDrawRect(const CRect& position)
        : CDrawObj(position)
{
}


//----------------------------------------------------------------------
void CDrawRect::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawObj::Serialize(ar);
    if (ar.IsStoring()) 
    {
    }
    else 
    {
    }
}

#define XinBOUNDS          \
   ((position.right > position.left) \
                 ? point.x > position.left && point.x < position.right \
         : point.x > position.right && point.x < position.left)

#define YinBOUNDS          \
   ((position.top > position.bottom) \
                 ? point.y > position.bottom && point.y < position.top \
         : point.y > position.top && point.y < position.bottom)



//---------------------------------------------------------------------------
void CDrawRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    CRect position = m_position;

    switch (nHandle) 
    {
    case 1:
        if (uiShiftDraw & SHIFT_DRAW) 
        {   //DRAW PERFECT RECT
            if (uiShiftDraw & SHIFT_TOOL) 
            {   //DRAW SQUARE
                if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) 
                {
                }
                else 
                {
                    position.left = point.x;
                    position.top =  (position.top > position.bottom) ? position.bottom + abs(position.right - position.left)
                            : position.bottom - abs(position.right - position.left);
                    if (!YinBOUNDS) 
                    {
                        position.top =  point.y;
                        position.left = (position.left < position.right) ? position.right - abs(position.top - position.bottom)
                                  : position.right + abs(position.top - position.bottom) ;
                    }
                }
            }
            else 
            {     //KEEP ASPECT RATIO SIMILAR
                if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) 
                {
                }
                else 
                {
                    UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                    UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                    UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                    position.left = point.x;
                    iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                    position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
                                 : position.bottom - (iW*iAspect)/100;
                    if (!YinBOUNDS) 
                    {
                        position.top =  point.y;
                        iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                        position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
                                   : position.right + ((iAspect>0)?(iH*100)/iAspect:0);
                    }
                }
            }
        }
        else 
        {    //NORMAL DRAWING
            position.left = point.x;
            position.top = point.y;
        }
        break;

    case 2:
        position.top = point.y;
        break;

    case 3:
        if (uiShiftDraw & SHIFT_DRAW) 
        {   //DRAW PERFECT RECT
            if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) 
            {
            }
            else 
            {
                UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                if (XinBOUNDS) 
                {
                    position.top =  point.y;
                    iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                    position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.left - ((iAspect>0)?(iH*100)/iAspect:0);
                }
                else 
                {
                    position.right = point.x;
                    iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                    position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
                            : position.bottom - (iW*iAspect)/100;
                }
            }
        }
        else 
        {    //NORMAL DRAWING
            position.right = point.x;
            position.top = point.y;
        }
        break;

    case 4:
        position.right = point.x;
        break;

    case 5:
        if (uiShiftDraw & SHIFT_DRAW) 
        {   //DRAW PERFECT RECT
            if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) 
            {
            }
            else 
            {
                UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                position.right = point.x;
                iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
                          : position.top + (iW*iAspect)/100;
                if (!YinBOUNDS) 
                {
                    position.bottom =  point.y;
                    iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                    position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.left - ((iAspect>0)?(iH*100)/iAspect:0);
                }
            }
        }
        else 
        {    //NORMAL DRAWING
            position.right = point.x;
            position.bottom = point.y;
        }
        break;

    case 6:
        position.bottom = point.y;
        break;

    case 7:
        if (uiShiftDraw & SHIFT_DRAW) 
        {   //DRAW PERFECT RECT
            if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) 
            {
            }
            else 
            {
                UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
                position.left = point.x;
                iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
                position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
                         : position.top + (iW*iAspect)/100;
                if (!YinBOUNDS) 
                {
                    position.bottom =  point.y;
                    iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
                    position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
                            : position.right + ((iAspect>0)?(iH*100)/iAspect:0);
                }
            }
        }
        else 
        {    //NORMAL DRAWING
            position.left = point.x;
            position.bottom = point.y;
        }
        break;

    case 8:
        position.left = point.x;
        break;

    default:
        ASSERT(FALSE);
    }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawRect::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen*   pOldPen;
    CBrush  brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&logBrush))
    {
        return;
    }

    CPen pen;
    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
       pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    CRect rect = m_position;

    pDC->Rectangle(rect);

    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();
    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRect::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawRect* pClone = new CDrawRect(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CFaxText
//*********************************************************************

//---------------------------------------------------------------------------
CFaxText::CFaxText()
{
   Initialize();
}

//---------------------------------------------------------------------------
CFaxText::CFaxText(const CRect& position)
        : CDrawRect(position)
{
   Initialize();
}


//----------------------------------------------------------------------
void CFaxText::Initialize()
{
   m_bPrintRTF=TRUE;
   m_hRTFWnd=NULL;
   m_hLib=NULL;
   m_wResourceid=IDS_PROP_MS_TEXT;
}

//---------------------------------------------------------------------------
CFaxText::~CFaxText()
{
   EndRTF();
}

//----------------------------------------------------------------------
void CFaxText::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
    if (ar.IsStoring()) {
    }
    else {
        if (GetApp()->m_dwSesID!=0) 
        {    //rendering
            InitRTF();
            StreamInRTF();
            CheckForFit();
        }
    }
}


//---------------------------------------------------------------------------
void CFaxText::InitRTF()
{
    LPVOID lpMsgBuf;

    m_hLib = LoadLibrary(TEXT("RICHED32.DLL"));

    if (!m_hLib) 
    {
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                        NULL,
                        ::GetLastError(), 
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &lpMsgBuf, 
                        0, 
                        NULL );
        TRACE1("AWCPE error: %s (error loading RICHED32.DLL)\n",lpMsgBuf);
        return;
    }

    CDrawView *pView = CDrawView::GetView();
    if (!pView)
    {
        TRACE(_T("AWCPE error: CDrawView::GetView() returns NULL\n"));
        return;
    }

    m_hRTFWnd = CreateWindow(TEXT("RICHEDIT"),TEXT(""),WS_CHILD | ES_MULTILINE, 0, 0, 0, 0, pView->m_hWnd,
        (HMENU)0, AfxGetInstanceHandle(),NULL);

    if (!m_hRTFWnd) 
    {
        ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
                        NULL,
                        ::GetLastError(), 
                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &lpMsgBuf, 
                        0, 
                        NULL );
        TRACE1("AWCPE error: %s (error in CreateWindow for RICHEDIT)\n",lpMsgBuf);
        return;
    }
}


//---------------------------------------------------------------------------
void CFaxText::EndRTF()
{
    if (m_hRTFWnd) {
            ::DestroyWindow(m_hRTFWnd);
                m_hRTFWnd=NULL;
        }

    if (m_hLib) {
        ::FreeLibrary(m_hLib);
                m_hLib=NULL;
        }
}


//-------------------------------------------------------------------------------------------------------
DWORD CALLBACK CFaxText::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    dwCookie=0;
        pbBuff=0;
        cb=0;
    pcb=0;

//  get a iStream from transport
//  read from storage.

        return 0;
}


//---------------------------------------------------------------------------
void CFaxText::StreamInRTF()
{
   if (m_hRTFWnd==NULL)
      return;

    EDITSTREAM es;
        es.dwCookie=0;   //pIStream pointer here
    es.dwError=0;
    es.pfnCallback= EditStreamCallBack;
    ::SendMessage(m_hRTFWnd, EM_STREAMIN, SF_RTF, (LPARAM)&es);
}

//---------------------------------------------------------------------------
void CFaxText::RectToTwip(CRect& rc,CDC& dc)
{
   int iX=dc.GetDeviceCaps(LOGPIXELSX);
   int iY=dc.GetDeviceCaps(LOGPIXELSY);
   rc.left=(rc.left*1440)/iX;
   rc.right=(rc.right*1440)/iX;
   rc.top=(rc.top*1440)/iY;
   rc.bottom=(rc.bottom*1440)/iX;
}

//---------------------------------------------------------------------------
void CFaxText::CheckForFit()
{
   if (m_hRTFWnd==NULL)
      return;

   CDrawView* pView=CDrawView::GetView();

   FORMATRANGE fr;
   CClientDC dc(pView);
   fr.hdc=fr.hdcTarget=dc.GetSafeHdc();
   CRect rc=m_position;
   pView->DocToClient(rc,&dc);
   RectToTwip(rc,dc);
   fr.rc=fr.rcPage=rc;
   fr.chrg.cpMin=0;
   fr.chrg.cpMax=-1;

   LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);
   LRESULT lTextLength = ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);

   if (m_bPrintRTF = (lTextToPrint <= lTextLength)) {
       //notify transport going to print RTF
   }
   else {
       //notify transport not going to print RTF
   }

   ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);       //clean up.
}



//---------------------------------------------------------------------------
void CFaxText::Draw(CDC* pDC,CDrawView* pView)
{
    if ( (GetApp()->m_dwSesID!=0) && (!(m_hRTFWnd!=NULL && m_bPrintRTF)) )
    {
        return;
    }

    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen*   pOldPen;
    CBrush  brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&logBrush))
    {
        return;
    }

    CPen pen;
    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
       pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    CRect rect = m_position;

    pDC->Rectangle(rect);

    int wx = MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
    int wy = MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
    int x = -wx-1;
    int y = -wy-1;

    pView->DocToClient(rect,pDC);
    rect.InflateRect(x,y);
    pView->ClientToDoc(rect,pDC);

    if (GetApp()->m_dwSesID != 0) 
    {
       //rendering
       FORMATRANGE fr;
       CRect rc=m_position;
       pView->DocToClient(rc,pDC);
       RectToTwip(rc,*pDC);
       fr.rc=fr.rcPage=rc;
       fr.chrg.cpMin=0;
       fr.chrg.cpMax=-1;

       LRESULT lTextLength  = ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);
       LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, TRUE, (LPARAM)&fr);
       if (lTextLength != lTextToPrint)
       {
            TRACE(TEXT("AWCPE: error, printed text range != total text length\n"));
       }

       ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);   //clean up.
    }
    else 
    {
       pDC->SetBkMode(TRANSPARENT);
       pDC->DrawText(_T("{Fax Text}"), 
                     10, 
                     rect, 
                     theApp.IsRTLUI() ? DT_RIGHT | DT_RTLREADING : DT_LEFT);
    }

    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }
}


//---------------------------------------------------------------------------
CDrawObj* CFaxText::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CFaxText* pClone = new CFaxText(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CDrawText
//*********************************************************************

//---------------------------------------------------------------------------
CDrawText::CDrawText()
{
    Initialize();
}


//---------------------------------------------------------------------------
CDrawText::CDrawText(const CRect& position)
        : CDrawRect(position)
{
    Initialize();
}


//---------------------------------------------------------------------------
void CDrawText::Initialize()
{
    m_pEdit = NULL;
    m_lStyle = theApp.IsRTLUI() ? DT_RIGHT | DT_RTLREADING : DT_LEFT;
    InitEditWnd();
    m_brush=NULL;
    m_crTextColor= COLOR_BLACK; 
    m_bUndoAlignment = FALSE ;
    m_bUndoTextChange = FALSE ;
    m_bUndoFont = FALSE ;
    m_bPen=FALSE;
    m_logbrush.lbColor = COLOR_WHITE; 
    NewBrush();  //brush is created, for WM_CTLCOLOR processing

    m_logfont = theApp.m_last_logfont;

    m_pFont = new CFont;
    m_pFont->CreateFontIndirect(&m_logfont);

    if (m_pEdit)
    {
        m_pEdit->SetFont(m_pFont);
    }
}

//-----------------------------------------------------------------------------
void CDrawText::OnEditUndo()
{
    if( !m_pEdit )
    {
        return;
    }
    if( m_bUndoAlignment )
    {
        ToggleAlignmentForUndo();
        return;
    }
    if( m_bUndoFont )
    {
        ToggleFontForUndo();
        return;
    }
    //
    // Let the edit control handle Undo
    //
    m_pEdit->SendMessage(WM_UNDO,0,0L);
}

//------------------------------------------------------------------------------
BOOL CDrawText::CanUndo()
{
    return m_bUndoFont || m_bUndoAlignment || m_pEdit && m_pEdit->CanUndo() ;
}

//------------------------------------------------------------------------------
void CDrawText::ToggleFontForUndo()
{
    LOGFONT temp ;
    memcpy( &temp, &m_logfont, sizeof(LOGFONT)) ;
    memcpy( &m_logfont, &m_previousLogfontForUndo, sizeof(LOGFONT)) ;
    memcpy( &m_previousLogfontForUndo, &temp, sizeof(LOGFONT)) ;
    ChgLogfont( m_logfont );
}
//------------------------------------------------------------------------------
void CDrawText::ToggleAlignmentForUndo()
{
    CDrawView * pView = CDrawView::GetView();

    if (!pView || !m_pEdit)
    {
        return;
    }

    //
    // We can't call ChgAlignment because it sets the state for the UNDO.
    //

    LONG lStyle = m_previousAlignmentForUndo;
    m_previousAlignmentForUndo = m_lStyle;
    m_lStyle = lStyle;


    m_pEdit->ModifyStyle(ES_CENTER | ES_RIGHT, 
                         DTStyleToESStyle(lStyle),
                         SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

    m_pEdit->ModifyStyleEx(WS_EX_RIGHT | WS_EX_RTLREADING, 
                           DTStyleToEXStyle(lStyle), 
                           SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);


    pView->UpdateStyleBar();
}

//---------------------------------------------------------------------------
CDrawText::~CDrawText()
{
    if (m_pEdit) 
    {
       m_pEdit->DestroyWindow();
       delete m_pEdit;
    }
    if (m_brush)
       VERIFY(::DeleteObject(m_brush));

    if (m_pFont)
       delete m_pFont;
}


//---------------------------------------------------------------------------
CDrawText& CDrawText::operator=(const CDrawText& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawRect::operator = (rdo);  //assign cdrawrect part

   m_crTextColor = rdo.m_crTextColor;
   m_szEditText  = rdo.m_szEditText;
   m_lStyle      = rdo.m_lStyle;

   memcpy(&m_logfont, &rdo.m_logfont, sizeof(m_logfont));
   LOGFONT lf;
   ChgLogfont(lf,FALSE);

   if (m_pEdit) 
   {
      CString szEditText;
      if (rdo.m_pEdit) 
      {
         rdo.m_pEdit->GetWindowText(szEditText);
         m_pEdit->SetWindowText(szEditText);
      }
   }
   return *this;
}


//---------------------------------------------------------------------
void CDrawText::ChgAlignment(
    CDrawView* pView, 
    LONG lStyle // DrawText alignment format
)
{
    if (!m_pEdit) 
    {
       TRACE(TEXT("AWCPE.CPEOBJ.CHGALIGNMENT: invalid CEdit pointer\n"));
       return;
    }
//
// Save the state for Undoing.
//
    m_bUndoTextChange = FALSE;
    m_bUndoAlignment = TRUE;
    m_bUndoFont = FALSE;
    m_previousAlignmentForUndo = m_lStyle ;

    m_lStyle = lStyle;
    if(m_pEdit->GetExStyle() & WS_EX_RTLREADING)
    {
        m_lStyle |= DT_RTLREADING;
    }

    m_pEdit->ModifyStyle(ES_CENTER | ES_RIGHT, 
                         DTStyleToESStyle(lStyle),
                         SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

    m_pEdit->ModifyStyleEx(WS_EX_RIGHT, 
                           DTStyleToEXStyle(lStyle), 
                           SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

    pView->UpdateStyleBar();
}


//---------------------------------------------------------------------
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
      TRACE(TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
      return;
   }

   CClientDC dc(pView);
   pView->OnPrepareDC(&dc,NULL);
   dc.SelectObject(m_pEdit->GetFont());

   Invalidate(); // clear size rect droppings
   SnapToFont_onthefly( pView, &dc, m_position );

   FitEditWnd(NULL);
   Invalidate(); // draw new stuff

   pView->UpdateStatusBar();
}



#ifdef FUBAR // keep this around awhile for reference
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
      TRACE( TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
      return;
   }

   TEXTMETRIC tm;
   CClientDC dc(pView);

   pView->OnPrepareDC(&dc,NULL);
   int x = MulDiv(m_logpen.lopnWidth.x, dc.GetDeviceCaps(LOGPIXELSX), 100)+1;
   int y = MulDiv(m_logpen.lopnWidth.y, dc.GetDeviceCaps(LOGPIXELSY), 100)+1;


   CRect rect = m_position;
   pView->DocToClient(rect,&dc);
   rect.InflateRect(-x,-y);
   pView->ClientToDoc(rect,&dc);

   dc.SelectObject(m_pEdit->GetFont());
//   CString sz;
//   GetLongestString(sz);
//   CSize cs = dc.GetTextExtent(sz,sz.GetLength());
   CSize cs;

   dc.GetTextMetrics(&tm);
   cs.cy=tm.tmHeight + tm.tmExternalLeading;

   int iOHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;

   int iLines= (cs.cy>0)?(int)((iOHeight/(float)cs.cy)*100):0;
//   int iLines= (cs.cy>0)?iOHeight/cs.cy:0;

   iLines=(iLines+50)/100;
   if (iLines<1)
      iLines=1;

   int iH=iLines*cs.cy+1;
//   int iH=iLines*cs.cy;

   if (rect.bottom < rect.top)
      rect.bottom = rect.top-iH;
   else
      rect.top = rect.bottom-iH;

   int iNHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;
   if (iOHeight > iNHeight)
      Invalidate();

//  TRACE??("before border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   pView->DocToClient(rect,&dc);
   rect.InflateRect(x,y);
   rect.bottom+=2;
   pView->ClientToDoc(rect,&dc);

//  TRACE("after border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   m_position=rect;
   Invalidate();

   FitEditWnd(NULL);

   pView->UpdateStatusBar();
}
#endif


//---------------------------------------------------------------------
void CDrawText::
        SnapToFont_onthefly( CDrawView *pView, CDC *fly_dc,
                                                 CRect &fly_rect, CFont *dpFont )
   /*
                If dpFont is not NULL it is selected into fly_dc after
                switching to MM_TEXT mode.
        */
   {
   TEXTMETRIC tm;
   LONG temp;

   if( pView == NULL )
                return;

   int x =
                MulDiv( m_logpen.lopnWidth.x,
                                fly_dc->GetDeviceCaps(LOGPIXELSX),
                                100)+1;
   int y =
                MulDiv( m_logpen.lopnWidth.y,
                                fly_dc->GetDeviceCaps(LOGPIXELSY),
                                100)+1;

   // normalize rect first
   if( fly_rect.top < fly_rect.bottom )
                {
                temp = fly_rect.top;
                fly_rect.top = fly_rect.bottom;
                fly_rect.bottom = temp;
                }

   if( fly_rect.right < fly_rect.left )
                {
                temp = fly_rect.right;
                fly_rect.right = fly_rect.left;
                fly_rect.left = temp;
                }

   // save original spot so we can avoid rect jiggle due
   // to unavoidable integer roundoff error below
   RECT save_rect = fly_rect;

   pView->DocToClient(fly_rect,fly_dc);
   fly_rect.InflateRect(-x,-y);

   CPoint pW1=fly_dc->GetWindowOrg();
   CPoint pW2=pW1;
   pView->DocToClient(pW2,fly_dc);
   CPoint pV=fly_dc->GetViewportOrg();

   // do snapping in MM_TEXT to get rect exactly right
   fly_dc->SetMapMode(MM_TEXT);
   fly_dc->SetWindowOrg(pW2);
   fly_dc->SetViewportOrg(pV);

   CSize cs;

   if( dpFont != NULL )
                fly_dc->SelectObject( dpFont );

   fly_dc->GetTextMetrics(&tm);
   cs.cy=tm.tmHeight;// + tm.tmExternalLeading;

   int iLines= (cs.cy>0)
                                        ?(fly_rect.bottom - fly_rect.top - 1 + cs.cy/2)/cs.cy
                                        :0;
   if (iLines<1)
      iLines=1;

   // snap height to a whole text line
   fly_rect.bottom = fly_rect.top + iLines*cs.cy + 1;

   // back to MM_ANISOTROPHIC
   fly_dc->SetMapMode(MM_ANISOTROPIC);
   fly_dc->SetWindowOrg(pW1);
   fly_dc->SetViewportOrg(pV);
   fly_dc->SetViewportExt(fly_dc->GetDeviceCaps(LOGPIXELSX),
                                                  fly_dc->GetDeviceCaps(LOGPIXELSY));
   fly_dc->SetWindowExt(100, -100);

   fly_rect.InflateRect(x,y);
   pView->ClientToDoc(fly_rect,fly_dc); // back to the future

   // integer round off error from above may cause rect to
   // jiggle a bit, so slap it back where it is supposed to be.
   int new_height = fly_rect.top - fly_rect.bottom;
   fly_rect = save_rect;
   fly_rect.bottom = fly_rect.top - new_height;

   }


//---------------------------------------------------------------------
void CDrawText::ChgLogfont(LOGFONT& lf, BOOL bResize /*=TRUE*/)
{
    CDrawView* pView = CDrawView::GetView();
    if (m_pEdit==NULL || pView==NULL) {
        TRACE(TEXT("CDrawText::ChgLogfont--missing m_pEdit or view pointer\n"));
        return;
    }


    CClientDC dc(pView);
    CRect rect;
    CString sz;
    CSize oldcs,newcs;

    if (m_pFont){
       delete m_pFont;
    }
    m_pFont = new CFont;

    // get charset for font (-> m_pEdit->m_logfont)

    ::EnumFontFamilies(
        dc.GetSafeHdc(),
        m_logfont.lfFaceName,
        (FONTENUMPROC)get_fontdata,
        LPARAM(this)
        );

    if (!m_pFont->CreateFontIndirect(&m_logfont)){
         TRACE(TEXT("CPEOBJ.ChgLogFont(): Unable to create font\n"));
    }
    theApp.m_last_logfont = m_logfont;

    if (m_pEdit){
        m_pEdit->SetFont(m_pFont);
    }

    SnapToFont(); // changing box size irratates Justin. Just snap for now

    Invalidate();
    pView->UpdateStatusBar();

    pView->UpdateStyleBar();
    CDrawDoc::GetDoc()->SetModifiedFlag();
}


//----------------------------------------------------------------------
void CDrawText::GetLongestString(CString& szLong)
{
   int linecount = (int)m_pEdit->SendMessage(EM_GETLINECOUNT,0,0L);

   if (linecount <= 0)
      return;

   TCHAR* sz;
   CString szHold;
   CString szTemp;
   int iSaveLen=0;
   WORD num;
   for (int i=0;i<linecount;i++) 
   {
       int linelength = (int)m_pEdit->SendMessage(EM_LINELENGTH,(WPARAM)m_pEdit->SendMessage(EM_LINEINDEX,(WPARAM)i,0L),0L);
       if (linelength>0) 
       {
          sz=new TCHAR[linelength+sizeof(TCHAR)];
          *(LPWORD)sz=linelength+(int)sizeof(TCHAR);
          num = (WORD)m_pEdit->SendMessage(EM_GETLINE,(WPARAM)i,(LPARAM)(LPCSTR) sz);
          sz[num]=(TCHAR)'\0';
          szTemp=sz;
          int j = szTemp.GetLength();
          if ( j > iSaveLen) 
          {
             szHold=sz;
             iSaveLen=j;
          }
          delete [] sz;
       }
   }
   szLong=szHold;
}

//----------------------------------------------------------------------
void CDrawText::InitEditWnd()
{
    if (m_pEdit)
    {
       return;
    }

    m_pEdit = new CTextEdit;

    RECT rect = {0};
    m_pEdit->CreateEx(DTStyleToEXStyle(m_lStyle), 
                      TEXT("EDIT"), 
                      NULL, 
                      WS_CHILD | ES_NOHIDESEL | ES_MULTILINE | DTStyleToESStyle(m_lStyle), 
                      rect, 
                      CDrawView::GetView(), 
                      ID_TEXT);
}

//----------------------------------------------------------------------
void CDrawText::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
    LOGFONT lf;
    if (ar.IsStoring()) 
    {
        LOGFONTW    lfTmpFont;

        if (CopyTLogFontToWLogFont(m_logfont,lfTmpFont) != ERROR_SUCCESS)
        {
              AfxThrowMemoryException() ; // Any exception will do.
                                          //CATCH_ALL in CDrawDoc::Serialize is the target.
        }
        ar.Write(&lfTmpFont, sizeof(LOGFONTW));
        if (m_pEdit) 
        {    //make sure that m_szEditText has window text
           FitEditWnd(NULL);
        }
        ar << m_lStyle;
        ar << m_szEditText;
        ar << m_crTextColor;
    }
    else 
    {  
        LOGFONTW LogFontW;
        LOGFONTA LogFontA;

        //
        //  Reading in from a file
        //
        if( CDrawDoc::GetDoc()->m_bDataFileUsesAnsi )
        {
            //
            // Read in a LOGFONTA and convert it to a LOGFONT.
            //
            if( sizeof(LOGFONTA) != ar.Read( &LogFontA, sizeof(LOGFONTA)))
            {
                AfxThrowMemoryException() ; // Any exception will do.
                                            //CATCH_ALL in CDrawDoc::Serialize is the target.
            }
            memcpy( &m_logfont, &LogFontA, sizeof(LOGFONTA)) ;
#ifdef UNICODE
            if( 0 == MultiByteToWideChar( CP_ACP,
                                          MB_PRECOMPOSED,
                                          LogFontA.lfFaceName,
                                          LF_FACESIZE,
                                          m_logfont.lfFaceName,
                                          LF_FACESIZE))
            {
                AfxThrowMemoryException() ;
            }
#endif
        }
        else
        {
            if(sizeof(LOGFONTW) != ar.Read(&LogFontW,sizeof(LOGFONTW)))
            {
                AfxThrowMemoryException() ; // Any exception will do.
            }
            else
            {
                if (CopyWLogFontToTLogFont(LogFontW, m_logfont) != ERROR_SUCCESS)
                {
                      AfxThrowMemoryException() ; // Any exception will do.
                                                  //CATCH_ALL in CDrawDoc::Serialize is the target.
                }
            }
        }    
        ar >> m_lStyle;
        ar >> m_szEditText;
        ar >> m_crTextColor;

        // Fix for 3405. Overide saved charset (codepage) with current
        //                               system charset. theApp.m_last_logfont is set
        //                               initially in CMainFrame::CreateStyleBar when
        //                               the CPE initializes so it is gaurenteed to be
        //                               valid by the time it gets here.
        m_logfont.lfCharSet = theApp.m_last_logfont.lfCharSet;

        ChgLogfont(lf,FALSE);
    }

    if (m_pEdit)
    {
       m_pEdit->Serialize(ar);
    }
    if (!ar.IsStoring())
    {
        SnapToFont();
        NewBrush();         /// Bug fix! unraided.  a-juliar 8-27-76
                            /// The text boxes were not being drawn with proper
                            /// background color when they had the input focus.
                            /// This bug was present in Windows 95 version.
    }
}



//---------------------------------------------------------------------------
int CDrawText::GetText( int numlines, BOOL delete_text )
        /*
                Returns number of ACTUAL remaining lines in editbox
         */
        {
        int linecount;
        int linelength;
        TCHAR* sz;
        WORD num;
        int i;
        int buflen;
        int zapline_char;
        int getline_char;


        m_szEditText=_T("");


        // see if there is any text
        linecount = m_pEdit->GetLineCount();
        if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
                return( 0 );


        if( numlines > 0 )
        {
            if( numlines < linecount )
            {
                 linecount = numlines;
            }
        }


        for( i=0;i<linecount;i++ )
        {
            getline_char = m_pEdit->LineIndex( i );
            linelength = m_pEdit->LineLength( getline_char );
            if (linelength>0)
            {
                buflen = 2*linelength;
                sz=new TCHAR[buflen+sizeof(TCHAR)];
                num = (WORD)m_pEdit->GetLine( i, sz, buflen );
                sz[num]=(TCHAR)'\0';
                m_szEditText+=sz;

                delete [] sz;
            }

            if( i<linecount )
                m_szEditText+=(TCHAR) '\n';
        }


        if( delete_text )
        {
                zapline_char = m_pEdit->LineIndex( linecount-1 );
                m_pEdit->SetSel( 0,
                                 zapline_char +
                                 m_pEdit->LineLength( zapline_char ),
                                 TRUE );

                m_pEdit->Clear();
        }

        // see if there is still any text
        linecount = m_pEdit->GetLineCount();
        if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
                return( 0 );
        else
                return( linecount );

}




//---------------------------------------------------------------------------
void CDrawText::SetText(CString& szText, CDrawView* pView)
{
   if (!m_pEdit)
      return;

   m_pEdit->SetWindowText(szText);

   FitEditWnd(pView);
}


//---------------------------------------------------------------------------
void CDrawText::OnDblClk(CDrawView* pView)
{
   ShowEditWnd(pView, TRUE);
}

//--------------------------------------------------------------------------------------------------
void CDrawText::NewBrush()
{
    if (m_brush)
    {
       ::DeleteObject(m_brush);
    }

    LOGBRUSH logBrush = m_logbrush;

    logBrush.lbColor = GetDisplayColor(logBrush.lbColor);

    m_brush = ::CreateBrushIndirect(&logBrush);
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::HitTestEdit(CDrawView* pView,CPoint& lpoint)
{
    if (pView->m_selection.GetCount()!=1)
      return FALSE;

    CRect cr = m_position;
    cr.NormalizeRect();

    CRect pointrc(lpoint, CSize(1, 1));
    CRect objrc = m_position;
    objrc.NormalizeRect();
    objrc.InflateRect(-5,-5);
    return !(pointrc & objrc).IsRectEmpty();
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::ShowEditWnd(CDrawView* pView, BOOL Initialize)
{
    FitEditWnd(pView);
    pView->m_pObjInEdit = this;
    if( Initialize )
    {
        m_bUndoFont = FALSE ;
        m_bUndoAlignment = FALSE ;
        m_bUndoTextChange = FALSE ;
    }
    m_pEdit->ShowWindow(SW_NORMAL);
    m_pEdit->SetFocus();

    pView->Select(NULL, FALSE, FALSE);
    return TRUE;
}


//---------------------------------------------------------------------------
void CDrawText::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
    if (!pView->m_pObjInEdit)
    {
       return;
    }

    if( CanUndo() && SaveUndoState )
    {
       OnEditUndo();                // Revert to Text Box's previous state.
       pView->SaveStateForUndo();   // Gives the View a record of the Text Box's last change.
       OnEditUndo();                // Return to "present state".
       m_bUndoFont = FALSE ;
       m_bUndoTextChange = FALSE ;
       m_bUndoAlignment = FALSE ;   // Now the View should handle Undo.
    }

    pView->m_pObjInEdit=NULL;

    GetText();

    //
    // save reading direction
    //
    if(m_pEdit->GetExStyle() & WS_EX_RTLREADING)
    {
        m_lStyle |= DT_RTLREADING;
    }
    else
    {
        m_lStyle &= ~DT_RTLREADING;
    }


    m_pEdit->ShowWindow(SW_HIDE);
}


//---------------------------------------------------------------------------
CFont* CDrawText::GetFont()
{
    return m_pFont;
}


//---------------------------------------------------------------------------
void CDrawText::Draw(CDC* pDC,CDrawView* pView)
{
    CPoint p;

    CFont*  pNewFont = NULL;
    CFont*  pOldFont=NULL;
    CBrush* pOldBrush=NULL;
    CPen*   pOldPen=NULL;

    CBrush brush;
    CPen pen;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    //ALLOCATE GDI OBJECTS
    if (m_bBrush) 
    {
       if (!brush.CreateBrushIndirect(&logBrush))
       {
           return;
       }
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen) 
    {
       if (!pen.CreatePenIndirect(&logPen))
       {
          return;
       }
       pOldPen = pDC->SelectObject(&pen);
    }
    else 
    {  
        //if no bPen & printing, use NULL pen
       if (pDC->IsPrinting()) 
       {
          pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
       }
       else 
       {   
          //default pen -- dashdot, gray border
          m_savepenstyle = m_logpen.lopnStyle;

          m_logpen.lopnStyle = PS_DOT;

          m_savepencolor = m_logpen.lopnColor;
          m_logpen.lopnColor = COLOR_LTGRAY;
          m_logpen.lopnWidth.x = 1;
          m_logpen.lopnWidth.y = 1;
          pen.CreatePenIndirect(&m_logpen);
          pOldPen = pDC->SelectObject(&pen);
       }
    }


    CRect rect = m_position;

    CFont* pFont = NULL;
    if (pDC->IsPrinting()) 
    {   
       //scale font to printer size
       LOGFONT logFont;
       memcpy(&logFont, &m_logfont, sizeof(m_logfont));
       pFont = new CFont;
       logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       pFont->CreateFontIndirect(&logFont);
       pOldFont= pDC->SelectObject(pFont);

       SnapToFont_onthefly( pView, pDC, rect );
    }
    else 
    {
       pOldFont= pDC->SelectObject(m_pEdit->GetFont());
    }

    pDC->Rectangle(rect);

    if (pView->m_pObjInEdit != this && m_szEditText.GetLength()>0) 
    {

       int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
       int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       int x = -wx-1;
       int y = -wy-1;

       pView->DocToClient(rect,pDC);
       CPoint pW1=pDC->GetWindowOrg();
       CPoint pW2=pW1;
       pView->DocToClient(pW2,pDC);
       CPoint pV=pDC->GetViewportOrg();
       rect.InflateRect(x,y);
       pDC->SetMapMode(MM_TEXT); //switch to MM_TEXT
       pDC->SetWindowOrg(pW2);
       pDC->SetViewportOrg(pV);
       pDC->SetTextColor(GetDisplayColor(m_crTextColor));
       pDC->SetBkMode(TRANSPARENT);

       pDC->DrawText(m_szEditText,
                     m_szEditText.GetLength(),
                     rect,
                     m_lStyle | DT_NOPREFIX );

       pDC->SetMapMode(MM_ANISOTROPIC);   //switch back to MM_ANISOTROPHIC
       pDC->SetWindowOrg(pW1);
       pDC->SetViewportOrg(pV);
       pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
       pDC->SetWindowExt(100, -100);
    }

       //CLEANUP GDI OBJECTS
    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }

    if (!m_bPen) 
    {
       m_logpen.lopnColor=m_savepencolor;
       m_logpen.lopnStyle=m_savepenstyle;
    }

    if (pOldFont)
    {
       pDC->SelectObject(pOldFont);
    }

    if (pFont)
    {
       delete pFont;
    }

    if (pNewFont)
    {
       delete pNewFont;
    }
}


//---------------------------------------------------------------------------
void CDrawText::FitEditWnd(CDrawView* pView, BOOL call_gettext, CDC *pdc )
{
   CClientDC dc(NULL);
   CRect rect = m_position;

   if( pdc == NULL )
   {
       if (pView==NULL)
       {
            pView=CDrawView::GetView();
       }

       pView->DocToClient(rect);

       if( pdc == NULL )
       {
            pdc = &dc;
       }


       int iX = pdc->GetDeviceCaps(LOGPIXELSX);
       int iY = pdc->GetDeviceCaps(LOGPIXELSY);
       int wx=MulDiv(m_logpen.lopnWidth.x, iX, 100);
       int wy=MulDiv(m_logpen.lopnWidth.y, iY, 100);
       int x = -wx-1;
       int y = -wy-1;
       rect.InflateRect(x,y);
   }

   m_pEdit->MoveWindow(&rect);

   m_pEdit->GetClientRect(&rect);         //set formatting rectangle to client area
   m_pEdit->SetRect(&rect);

   if( call_gettext )
   {
        GetText();
   }
}


//---------------------------------------------------------------------------
void CDrawText::MoveTo(const CRect& position, CDrawView* pView)
{
   CDrawRect::MoveTo(position, pView);
}

//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawText::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);

    FitEditWnd(pView);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawText::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);
    CString copy_text;

    CDrawText* pClone = new CDrawText(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this; // copy geometry, style, etc., in one swoop

    // have to stuff in a few other things
    pClone->m_pEdit = NULL; // don't point to old one
    pClone->InitEditWnd();

    // make a new one
    pClone->m_brush = ::CreateBrushIndirect( &pClone->m_logbrush );

    // ditto
    if( (pClone->m_pFont = new CFont) != NULL )
    {
        pClone->m_pFont->CreateFontIndirect( &pClone->m_logfont );
        pClone->m_pEdit->SetFont( pClone->m_pFont, FALSE );
    }

        // copy text
        m_pEdit->GetWindowText( copy_text );
        pClone->m_pEdit->SetWindowText( copy_text );

        // and position
        pClone->m_position = m_position;


        // shoe it in
        pClone->FitEditWnd( NULL );

    if (pDoc != NULL)
        pDoc->Add(pClone);

    return pClone;
}





//*********************************************************************
// CFaxProp
//*********************************************************************

//---------------------------------------------------------------------------
CFaxProp::CFaxProp()
{
}


//---------------------------------------------------------------------------
CFaxProp::CFaxProp(const CRect& position,WORD wResourceid)
        : CDrawText(position)
{
    m_wResourceid=wResourceid;
}


//---------------------------------------------------------------------------
CFaxProp::~CFaxProp()
{
// F I X  for 3647 /////////////
//
// Zap m_last_note_box at note destroy time so we don't have
// a dangling pointer.
//
                if( m_wResourceid == IDS_PROP_MS_NOTE )
                        theApp.m_last_note_box = NULL;
////////////////////////////////
}


//----------------------------------------------------------------------
void CFaxProp::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawText::Serialize(ar);

    if (ar.IsStoring()) 
    {
        ar << (WORD)m_wResourceid;
    }
    else 
    {
        ar >> m_wResourceid;
        if (GetApp()->m_dwSesID != 0) 
        {    //rendering
           GetApp()->m_pFaxMap->GetPropString(m_wResourceid,m_szEditText);
           m_pEdit->SetWindowText(m_szEditText);
           FitEditWnd(CDrawView::GetView());

// F I X  for 3647 /////////////
//
// set m_last_note_box at note creation time instead of at
// draw time.
//
            if( m_wResourceid == IDS_PROP_MS_NOTE )
            {
                theApp.m_last_note_box = this;
            }
////////////////////////////////
        }
    }
}


//---------------------------------------------------------------------------------------------------
BOOL CFaxProp::ShowEditWnd(CDrawView* pView, BOOL Initialize )
{
    return FALSE;    //fax property object doesnt support editing
}


//---------------------------------------------------------------------------
void CFaxProp::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
    return;    //never shown, never hidden
}



//---------------------------------------------------------------------------
CFaxProp& CFaxProp::operator=(const CFaxProp& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawText::operator=(rdo);  //assign cdrawrect part

   m_wResourceid = rdo.m_wResourceid;

   return *this;
}


//---------------------------------------------------------------------------
void CFaxProp::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    LPTSTR draw_str;
    UINT   draw_style;
    CFont* pOldFont=NULL;
    CBrush* pOldBrush=NULL;
    CPen* pOldPen=NULL;
    CBrush brush;
    CPen pen;
    long draw_strlen;
    CRect note_rect;
    int num_pages;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    //ALLOCATE GDI OBJECTS
    if (m_bBrush) 
    {
       if (!brush.CreateBrushIndirect(&logBrush))
       {
           return;
       }
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen) 
    {
       if (!pen.CreatePenIndirect(&logPen))
       {
          return;
       }
       pOldPen = pDC->SelectObject(&pen);
    }
    else 
    {  
        //if no bPen & printing, use NULL pen
       if (pDC->IsPrinting()) 
       {
          pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
       }
       else 
       {   
           //default pen -- dashdot, gray border
          m_savepenstyle = m_logpen.lopnStyle;

          m_logpen.lopnStyle = PS_DOT;

          m_savepencolor = m_logpen.lopnColor;
          m_logpen.lopnColor = COLOR_LTGRAY;
          m_logpen.lopnWidth.x = 1;
          m_logpen.lopnWidth.y = 1;
          pen.CreatePenIndirect(&m_logpen);
          pOldPen = pDC->SelectObject(&pen);
       }
    }

    CRect rect = m_position;

    CFont* pFont = NULL;
    if (pDC->IsPrinting()) 
    {   
       //scale font to printer size
       LOGFONT logFont;
       memcpy(&logFont, &m_logfont, sizeof(m_logfont));
       pFont = new CFont;
       logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       pFont->CreateFontIndirect(&logFont);
       pOldFont= pDC->SelectObject(pFont);

       SnapToFont_onthefly( pView, pDC, rect );
    }
    else 
    {
       pOldFont= pDC->SelectObject(m_pEdit->GetFont());
    }

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it below for why)
//
    if( !((theApp.m_extra_notepage == this)&&
         (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
    {
        pDC->Rectangle( rect );
    }
////////////////////////////////

    if((m_szEditText.GetLength() > 0) || (m_wResourceid == IDS_PROP_MS_NOTE)) 
    {
       int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
       int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
       int x = -wx-1;
       int y = -wy-1;
       pView->DocToClient(rect,pDC);
       CPoint pW1=pDC->GetWindowOrg();
       CPoint pW2=pW1;
       pView->DocToClient(pW2,pDC);
       CPoint pV=pDC->GetViewportOrg();
       rect.InflateRect(x,y);

        if( (m_wResourceid == IDS_PROP_MS_NOPG)&&
              theApp.m_note_wasread &&
             (theApp.m_extrapage_count < 0)&&
             (theApp.m_extra_notepage != NULL) )
        {
            note_rect = theApp.m_extra_notepage->m_position;
            pView->DocToClient( note_rect,pDC );
            note_rect.InflateRect(x,y);
        }

        pDC->SetMapMode(MM_TEXT);  //switch to MM_TEXT
        pDC->SetWindowOrg(pW2);
        pDC->SetViewportOrg(pV);
        pDC->SetTextColor(GetDisplayColor(m_crTextColor));
        pDC->SetBkMode(TRANSPARENT);

        draw_style = m_lStyle | DT_NOPREFIX;

                // stuff for notes
        if((m_wResourceid == IDS_PROP_MS_NOTE) && theApp.m_note_wasread)
        {
            theApp.clip_note( pDC, &draw_str, &draw_strlen, TRUE, rect );

// F I X  for 3647 /////////////
//
// Don't set m_last_note_box here! Set it in CFaxProp::Serialize
//
//                      theApp.m_last_note_box = this;
        }
        else if((m_wResourceid == IDS_PROP_MS_NOPG) && theApp.m_note_wasread)
        {
            if((theApp.m_extrapage_count < 0) && (theApp.m_extra_notepage != NULL))
            {

// F I X  for 3647 /////////////
//
// PROBLEM: Wrong dc attributes are in place at this point to
//                      properly calculate pages left. Must temporarialy switch
//                      to extra note's attributes by recursively calling
//                      Draw for the extra note with its id temporarialy set to
//                      a page-no object so that it will calculate the correct
//                      pages left and NOT draw anything in the process.
//
                if( theApp.m_extra_notepage == this )
                {
                    // We are in the second level of recursion
                    // here. This is extra notepage disguised as a
                    // page-no object. Calculate pages left.
                    theApp.m_extrapage_count = theApp.clip_note( pDC, &draw_str, &draw_strlen,
                                                                 FALSE, note_rect );
                }
                else
                {
                    // We are in the first level of recursion here.
                    // Make extra note look like a page-no object.
                    theApp.m_extra_notepage->m_wResourceid = IDS_PROP_MS_NOPG;
                    theApp.m_extra_notepage->m_szEditText  = m_szEditText;

                    // switch back to MM_ANISOTROPHIC so mapping will be
                    // correct for Draw call
                    pDC->SetMapMode(MM_ANISOTROPIC);
                    pDC->SetWindowOrg(pW1);
                    pDC->SetViewportOrg(pV);
                    pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
                    pDC->SetWindowExt(100, -100);

                    // recursively call Draw to force calc of re,aomomgpages
                    // left using correct font, etc.
                    theApp.m_extra_notepage->Draw( pDC, pView );

                    // restore mapping mode so page-no will draw correctly
                    pDC->SetMapMode(MM_TEXT);
                    pDC->SetWindowOrg(pW2);
                    pDC->SetViewportOrg(pV);
                    pDC->SetTextColor(GetDisplayColor(m_crTextColor));
                    pDC->SetBkMode(TRANSPARENT);

                    // restore extra note's true identity
                    theApp.m_extra_notepage->m_wResourceid = IDS_PROP_MS_NOTE;
                }
            }

            // If this isn't extra notepage in disguise then
            // do normal page-no thing
            if( theApp.m_extra_notepage != this )
            {
                num_pages = _ttoi( (LPCTSTR)m_szEditText );
                num_pages += theApp.m_extrapage_count;
                m_szEditText.Format( TEXT("%i"), num_pages );
                draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
                draw_strlen = lstrlen( draw_str );
            }
////////////////////////////////
        }                
        else //end of stuff for notes
        {
            draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
            draw_strlen = lstrlen( draw_str );
        }

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it above for why)
//
        if( !((theApp.m_extra_notepage == this)&&
              (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
        {
            pDC->DrawText( draw_str, draw_strlen, rect, draw_style);
        }
////////////////////////////////

       pDC->SetMapMode(MM_ANISOTROPIC);                  //switch back to MM_ANISOTROPHIC
       pDC->SetWindowOrg(pW1);
       pDC->SetViewportOrg(pV);
       pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
       pDC->SetWindowExt(100, -100);
    }

    //CLEANUP GDI OBJECTS
    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }
    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }

    if (!m_bPen) 
    {
       m_logpen.lopnColor=m_savepencolor;
       m_logpen.lopnStyle=m_savepenstyle;
    }

    if (pOldFont)
    {
       pDC->SelectObject(pOldFont);
    }

    if (pFont)
    {
       delete pFont;
    }
}



//---------------------------------------------------------------------------
CDrawObj* CFaxProp::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CFaxProp* pClone = new CFaxProp(m_position,m_wResourceid);

    ASSERT_VALID(pClone);

    *pClone=*this;
    CString szCaption;
    szCaption.LoadString( m_wResourceid );
    pClone->SetText( szCaption, CDrawView::GetView() );
    if (pDoc != NULL){
        pDoc->Add(pClone);
    }
    ASSERT_VALID(pClone);
    return pClone;
}





//*********************************************************************
// CDrawLine
//*********************************************************************


//---------------------------------------------------------------------------
CDrawLine::CDrawLine()
{
}


//---------------------------------------------------------------------------
CDrawLine::~CDrawLine()
{
}

//---------------------------------------------------------------------------
CDrawLine::CDrawLine(const CRect& position)
        : CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawLine::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
}


//----------------------------------------------------------------------
void CDrawLine::NegAdjustLineForPen(CRect& rect)
{
    if (rect.top > rect.bottom) {
       rect.top += m_logpen.lopnWidth.y / 2;
       rect.bottom -= (m_logpen.lopnWidth.y + 1) / 2;
    }
    else {
       rect.top -= (m_logpen.lopnWidth.y + 1) / 2;
       rect.bottom += m_logpen.lopnWidth.y / 2;
    }

    if (rect.left > rect.right) {
       rect.left += m_logpen.lopnWidth.x / 2;
       rect.right -= (m_logpen.lopnWidth.x + 1) / 2;
    }
    else {
       rect.left -= (m_logpen.lopnWidth.x + 1) / 2;
       rect.right += m_logpen.lopnWidth.x / 2;
    }
}


//----------------------------------------------------------------------
void CDrawLine::AdjustLineForPen(CRect& rect)
{

        // added by v-randr 2/15/95
        if( (rect.left == rect.right)&&(rect.top == rect.bottom) )
                return;

    if (rect.top > rect.bottom) {
       rect.top -= m_logpen.lopnWidth.y / 2;
       rect.bottom += (m_logpen.lopnWidth.y + 1) / 2;
    }
    else {
       rect.top += (m_logpen.lopnWidth.y + 1) / 2;
       rect.bottom -= m_logpen.lopnWidth.y / 2;
    }

    if (rect.left > rect.right) {
       rect.left -= m_logpen.lopnWidth.x / 2;
       rect.right += (m_logpen.lopnWidth.x + 1) / 2;
    }
    else {
       rect.left += (m_logpen.lopnWidth.x + 1) / 2;
       rect.right -= m_logpen.lopnWidth.x / 2;
    }
}


//---------------------------------------------------------------------------
void CDrawLine::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
      TRACE(TEXT("AWCPE: CDrawLine::Invalidate, missing View pointer\n"));
      return;
   }

   CRect rect = m_position;

   if (rect.top > rect.bottom) {
      rect.top += m_logpen.lopnWidth.y;
      rect.bottom -= m_logpen.lopnWidth.y;
   }
   else {
      rect.top -= m_logpen.lopnWidth.y;
      rect.bottom += m_logpen.lopnWidth.y;
   }

   if (rect.left > rect.right) {
      rect.left += m_logpen.lopnWidth.x;
      rect.right -= m_logpen.lopnWidth.x;
   }
   else {
      rect.left -= m_logpen.lopnWidth.x;
      rect.right += m_logpen.lopnWidth.x;
   }

   pView->DocToClient(rect);

   if (pView->IsSelected(this)) {
        rect.left -= 4;
        rect.top -= 5;
        rect.right += 5;
        rect.bottom += 4;
   }

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
void CDrawLine::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen*   pOldPen;
    CBrush  brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&logBrush))
    {
        return;
    }

    CPen pen;
    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
       pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    CRect rect = m_position;

    AdjustLineForPen(rect);

    pDC->MoveTo( rect.TopLeft() );
    pDC->LineTo( rect.BottomRight() );

    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }
}



//---------------------------------------------------------------------------
int CDrawLine::GetHandleCount()
{
    ASSERT_VALID(this);

    return 2;
}


//---------------------------------------------------------------------------
// returns center of handle in logical coordinates
//---------------------------------------------------------------------------
CPoint CDrawLine::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 2)
       nHandle = 5;

    return CDrawRect::GetHandle(nHandle);
}


//---------------------------------------------------------------------------
HCURSOR CDrawLine::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 2)
        nHandle = 5;

    return CDrawRect::GetHandleCursor(nHandle);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawLine::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawLine* pClone = new CDrawLine(m_position);

    *pClone=*this;

    ASSERT_VALID(pClone);

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}

// rearranged by v-randr 2/15/95
#define PI (3.14159)
#define ONESIXTH_PI   (PI/6)
#define ONETHIRD_PI   (PI/3)
#define ONEHALF_PI    (PI/2)
#define ONEFORTH_PI   (PI/4)
#define THREEFORTH_PI (PI*3/4)
#define TWOTHIRD_PI   (PI*2/3)
#define FIVESIXTH_PI  (PI*5/6)


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawLine::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    CRect position = m_position;

    if (nHandle == 2)
        nHandle = 5;

    switch (nHandle) {
    case 1:
        if (uiShiftDraw & SHIFT_DRAW) 
        {
            if (uiShiftDraw & SHIFT_TOOL) 
            {
                BOOL bNegR=FALSE;
                double radian = atan2((double)(point.y-position.bottom),(double)(point.x-position.right));
                if (radian < 0) 
                {
                    radian *= -1;
                    bNegR=TRUE;
                }
                if (radian >= 0 && radian < ONESIXTH_PI) 
                {
                    position.left = point.x;
                    position.top = (long) (tan(0.0f) * (point.x - position.right) + position.bottom ) - 1;
                }
                else if (radian >= ONESIXTH_PI && radian < ONETHIRD_PI) 
                {
                    if (radian >= ONESIXTH_PI && radian < ONEFORTH_PI) 
                    {
                        position.left = point.x;
                        position.top = (long) (tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI)) * (point.x - position.right) + 
                                        position.bottom );
                    }
                    else 
                    {
                        position.top = point.y;
                        position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI))  + 
                                        position.right );
                    }
                }
                else if (radian >= ONETHIRD_PI && radian < TWOTHIRD_PI) 
                {
                    position.top = point.y;
                    position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEHALF_PI:ONEHALF_PI))  + position.right);
                }
                else if (radian >= TWOTHIRD_PI && radian < FIVESIXTH_PI) 
                {
                    if (radian >= TWOTHIRD_PI && radian < THREEFORTH_PI) 
                    {
                        position.top = point.y;
                        position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI))  + position.right );
                    }
                    else 
                    {
                        position.left = point.x;
                        position.top = (long) (tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI)) * (point.x - position.right) + position.bottom );
                    }
                }
                else if (radian >= FIVESIXTH_PI && radian < PI) 
                {
                    position.left = point.x;
                    position.top = (long) (tan(PI) * (point.x - position.right) + position.bottom -1);
                }
                // make sure rect isn't too skinny, added 2/14/95 by v-randr
                if( CDrawTool::c_down != point )
                {
                    if( (position.left == position.right)&&
                        (position.top != position.bottom) )
                        position.left = position.right-1;
                }
            }
            else 
            {
                BOOL bNegR=FALSE;
                double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
                if (radianTL < 0) 
                {
                    radianTL *= -1;
                    bNegR=TRUE;
                }
                if (pView->m_bShiftSignal ) 
                {
                    TRACE(TEXT("shift signaled--slope is being calculated\n"));
                    if (position.left - position.right != 0) 
                    {
                        float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
                        if (temp>0)
                            temp += (float)0.005;
                        else
                            temp -= (float)0.005;
                        temp *= 100;
                        m_iSlope = (int)temp;
                    }
                    m_iB = (position.bottom*100 - m_iSlope*position.right);
                    pView->m_bShiftSignal=FALSE;
                }

                if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) 
                {
                    position.left = point.x;
                    int temp = position.left* m_iSlope + m_iB;
                    if (temp>0)
                        temp += 50;
                    else
                        temp -= 50;
                    position.top = temp/100;
                }
                else 
                {
                    position.top = point.y;
                    if (m_iSlope != 0) 
                    {
                        float temp = (position.top*100 - m_iB) / (float)m_iSlope;
                        if (temp>0)
                            temp += (float).5;
                        else
                            temp -= (float).5;
                        position.left = (long) temp;
                    }
                }
//             TRACE("slope(%i), yint(%i)\n",m_iSlope, m_iB);
            }
        }
        else 
        {
            CDrawRect::MoveHandleTo(nHandle, point, pView);
            return;
        }
        break;
    case 5:
        if (uiShiftDraw & SHIFT_DRAW) 
        {
            BOOL bNegR=FALSE;
            double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
            if (radianTL < 0) 
            {
                radianTL *= -1;
                bNegR=TRUE;
            }
            if (pView->m_bShiftSignal ) 
            {
                TRACE(TEXT("shift signaled--slope is being calculated\n"));
                if (position.left - position.right != 0) 
                {
                    float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
                    if (temp>0)
                        temp += (float)0.005;
                    else
                        temp -= (float)0.005;
                    temp *= 100;
                    m_iSlope = (int)temp;
                }
                m_iB = (position.bottom*100 - m_iSlope*position.right);
                pView->m_bShiftSignal=FALSE;
            }
            if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) 
            {
                position.right = point.x;
                int temp = position.right* m_iSlope + m_iB;
                if (temp>0)
                    temp += 50;
                else
                    temp -= 50;
                position.bottom = temp/100;
            }
            else 
            {
                position.bottom = point.y;
                if (m_iSlope != 0) 
                {
                    float temp = (position.bottom*100 - m_iB) / (float)m_iSlope;
                    if (temp>0)
                    {
                        temp += (float).5;
                    }
                    else
                    {
                        temp -= (float).5;
                    }
                    position.right = (long) temp;
                }
            }
        }
        else 
        {
            CDrawRect::MoveHandleTo(nHandle, point, pView);
            return;
        }
        break;

    default:
        CDrawRect::MoveHandleTo(nHandle, point, pView);
        return;
        }

    MoveTo(position, pView);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawLine::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

        CRect rectT = rect;
        rectT.NormalizeRect();

    if (bShortCut) {
        CRect fixed = m_position;
        fixed.NormalizeRect();
        return (!(rectT & fixed).IsRectEmpty() );
    }

        CDrawView* pView=CDrawView::GetView();
    CClientDC dc(pView);

    dc.BeginPath();
        Draw(&dc,pView);   //draw into GDI path
        dc.EndPath();

    CPen pen;
        LOGPEN lp=m_logpen;
    pen.CreatePenIndirect(&lp);
    CPen* oldpen= dc.SelectObject(&pen);
    dc.WidenPath();
    dc.SelectObject(oldpen);

    HRGN hRegion = NULL;
    BOOL bRes = FALSE;

    hRegion = ::PathToRegion(dc.GetSafeHdc());
    if (hRegion)
    {
        bRes = ::RectInRegion(hRegion,rectT);
        ::DeleteObject(hRegion);
    }
    return bRes;
}



//*********************************************************************
// CDrawRoundRect
//*********************************************************************


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::~CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect(const CRect& position)
        : CDrawRect(position)
{
    m_roundness.x = 16;
    m_roundness.y = 16;
}


//----------------------------------------------------------------------
void CDrawRoundRect::Serialize(CArchive& ar)
{
    ASSERT_VALID(this);

    CDrawRect::Serialize(ar);
    if (ar.IsStoring())
    {
        ar << m_roundness;
    }
    else
    {
        ar >> m_roundness;
    }
}



//----------------------------------------------------------------------
void CDrawRoundRect::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);

    CBrush* pOldBrush;
    CPen*   pOldPen;
    CBrush  brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&logBrush))
    {
        return;
    }

    CPen pen;

    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
       pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    pDC->RoundRect(m_position, m_roundness);

    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }
}



//----------------------------------------------------------------------
// returns center of handle in logical coordinates
CPoint CDrawRoundRect::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 9) {
        CRect rect = m_position;
        rect.NormalizeRect();
        CPoint point = rect.BottomRight();
        point.x -= m_roundness.x / 2;
        point.y -= m_roundness.y / 2;
        return point;
    }

    return CDrawRect::GetHandle(nHandle);
}

//----------------------------------------------------------------------
HCURSOR CDrawRoundRect::GetHandleCursor(int nHandle)
{
    ASSERT_VALID(this);

    if (nHandle == 9)
        return AfxGetApp()->LoadStandardCursor(IDC_SIZE);

    return CDrawRect::GetHandleCursor(nHandle);
}


//----------------------------------------------------------------------
void CDrawRoundRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);

    if (nHandle == 9) {
        CRect rect = m_position;
        rect.NormalizeRect();
        if (point.x > rect.right - 1)
                point.x = rect.right - 1;
        else if (point.x < rect.left + rect.Width() / 2)
                point.x = rect.left + rect.Width() / 2;
        if (point.y > rect.bottom - 1)
                point.y = rect.bottom - 1;
        else if (point.y < rect.top + rect.Height() / 2)
                point.y = rect.top + rect.Height() / 2;
        m_roundness.x = 2 * (rect.right - point.x);
        m_roundness.y = 2 * (rect.bottom - point.y);
        m_pDocument->SetModifiedFlag();
        Invalidate();
        return;
    }

    CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRoundRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();

    if( bShortCut ){
        return !(fixed & rectT).IsRectEmpty();
    }

    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    CRgn rgn;
    rgn.CreateRoundRectRgn(fixed.left, fixed.top, fixed.right, fixed.bottom,
        m_roundness.x, m_roundness.y);

    return rgn.RectInRegion(fixed);
}


//---------------------------------------------------------------------------
CDrawRoundRect& CDrawRoundRect::operator=(const CDrawRoundRect& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawRect::operator=(rdo);  //assign cdrawrect part

   m_roundness = rdo.m_roundness;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRoundRect::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawRoundRect* pClone = new CDrawRoundRect(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//*********************************************************************
// CDrawEllipse
//*********************************************************************

//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse()
{
}

//----------------------------------------------------------------------
CDrawEllipse::~CDrawEllipse()
{
}


//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse(const CRect& position)
        : CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawEllipse::Serialize(CArchive& ar)
{
    CDrawRect::Serialize(ar);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawEllipse::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawEllipse* pClone = new CDrawEllipse(m_position);

    ASSERT_VALID(pClone);

    *pClone=*this;

    if (pDoc != NULL)
        pDoc->Add(pClone);

    ASSERT_VALID(pClone);
    return pClone;
}


//----------------------------------------------------------------------
void CDrawEllipse::Draw(CDC* pDC,CDrawView* pView)
{
    ASSERT_VALID(this);
    CBrush* pOldBrush;
    CPen* pOldPen;
    CBrush brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&logBrush))
    {
        return;
    }

    CPen pen;
    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
       pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
       pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    pDC->Ellipse(m_position);

    if (pOldBrush)
    {
       pDC->SelectObject(pOldBrush);
    }

    if (pOldPen)
    {
       pDC->SelectObject(pOldPen);
    }
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawEllipse::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);

    CRect rectT = rect;
    rectT.NormalizeRect();

    CRect fixed = m_position;
    fixed.NormalizeRect();
        CRgn rgn;
    if( bShortCut ){
        return !(fixed & rectT).IsRectEmpty();
    }
    if ((rectT & fixed).IsRectEmpty())
        return FALSE;

    rgn.CreateEllipticRgnIndirect(fixed);

    return rgn.RectInRegion(fixed);
}




//--------------------------------------------------------------------------
// CDrawPoly
//--------------------------------------------------------------------------

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly()
{
    m_points = NULL;
    m_nPoints = 0;
    m_nAllocPoints = 0;
}

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly(const CRect& position)
        : CDrawObj(position)
{
    m_points = NULL;
    m_nPoints = 0;
    m_nAllocPoints = 0;
    m_bPen = TRUE;
    m_bBrush = FALSE;
}

//---------------------------------------------------------------------------
CDrawPoly::~CDrawPoly()
{
    if (m_points != NULL)
       delete [] m_points;
}


//---------------------------------------------------------------------------
void CDrawPoly::Serialize( CArchive& ar )
{
    int i;
    CDrawObj::Serialize( ar );
    if( ar.IsStoring() ) {
        ar << (WORD) m_nPoints;
        ar << (WORD) m_nAllocPoints;
        for (i = 0;i< m_nPoints; i++)
                ar << m_points[i];
    }
    else  {
        WORD wTemp;
        ar >> wTemp; m_nPoints = wTemp;
        ar >> wTemp; m_nAllocPoints = wTemp;
        m_points = NewPoints(m_nAllocPoints);
        for (i = 0;i < m_nPoints; i++)
                ar >> m_points[i];
    }
}

//---------------------------------------------------------------------------
void CDrawPoly::Draw(CDC* pDC,CDrawView*)
{
    ASSERT_VALID(this);

    CBrush brush;

    LOGBRUSH logBrush = m_logbrush;
    LOGPEN   logPen   = m_logpen;

    if( !pDC->IsPrinting() )
    {
        logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
        logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
    }

    if (!brush.CreateBrushIndirect(&m_logbrush))
    {
        return;
    }

    CPen pen;
    if (!pen.CreatePenIndirect(&logPen))
    {
        return;
    }

    CBrush* pOldBrush;
    CPen* pOldPen;

    if (m_bBrush)
    {
       pOldBrush = pDC->SelectObject(&brush);
    }
    else
    {
       pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
    }

    if (m_bPen)
    {
        pOldPen = pDC->SelectObject(&pen);
    }
    else
    {
        pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
    }

    pDC->Polygon(m_points, m_nPoints);

    pDC->SelectObject(pOldBrush);
    pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
// position must be in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);
    if (position == m_position)
        return;

    Invalidate();

    for (int i = 0; i < m_nPoints; i += 1)  {
        m_points[i].x += position.left - m_position.left;
        m_points[i].y += position.top - m_position.top;
    }

    m_position = position;

        Invalidate();

    m_pDocument->SetModifiedFlag();
}


//---------------------------------------------------------------------------
int CDrawPoly::GetHandleCount()
{
    return m_nPoints;
}


//---------------------------------------------------------------------------
CPoint CDrawPoly::GetHandle(int nHandle)
{
    ASSERT_VALID(this);

    ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
    return m_points[nHandle - 1];
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawPoly::GetHandleRect(int nHandleID, CDrawView* pView)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    CRect rect;
    // get the center of the handle in logical coords
    CPoint point = GetHandle(nHandleID);
    // convert to client/device coords
    pView->DocToClient(point);
    // return CRect of handle in device coords
    rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
    pView->ClientToDoc(rect);

    return rect;
}



//---------------------------------------------------------------------------
int CDrawPoly::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
    ASSERT_VALID(this);
    ASSERT(pView != NULL);

    if (bSelected) {
        int nHandleCount = GetHandleCount();
        for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
            // GetHandleRect returns in logical coords
            CRect rc = GetHandleRect(nHandle,pView);
            if (point.x >= rc.left && point.x < rc.right &&
                point.y <= rc.top && point.y > rc.bottom)
                return nHandle;
        }
    }
    else  {
       if (point.x >= m_position.left && point.x < m_position.right &&
             point.y <= m_position.top && point.y > m_position.bottom)
          return 1;
    }
    return 0;
}




//---------------------------------------------------------------------------
HCURSOR CDrawPoly::GetHandleCursor(int nHandle )
{
    CPoint p1;
    LPCTSTR id;
    CPoint p2;

    if (nHandle==1)
      p1 = m_points[m_nPoints - 1];
        else
      p1 = m_points[nHandle - 2];

    if (nHandle==m_nPoints)
      p2 = m_points[0];
        else
      p2 = m_points[nHandle];

    float m =  ((p2.x-p1.x)!=0) ? (p2.y-p1.y) / ((float)(p2.x-p1.x)) : 9999;

    if (m>=3 || m<=-3)
       id = IDC_SIZEWE;
        else
       if (m>.3)
          id = IDC_SIZENWSE;
       else
              if (m<-.3)
             id = IDC_SIZENESW;
              else
             id = IDC_SIZENS;

//    TRACE("CDrawPoly::GetHandleCursor, handle: %i, P1(%i,%i), P2(%i,%i), slope: %3.2f\n",nHandle,p1.x,p1.y,p2.x,p2.y,m);

    return AfxGetApp()->LoadStandardCursor(id);
//    return AfxGetApp()->LoadStandardCursor(IDC_ARROW);
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView, UINT uiShiftDraw /*=0*/)
{
    ASSERT_VALID(this);
    ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
    if (m_points[nHandle - 1] == point)
        return;

    m_points[nHandle - 1] = point;
    RecalcBounds(pView);

    Invalidate();
    m_pDocument->SetModifiedFlag();
}

//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawPoly::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
    ASSERT_VALID(this);
    CRgn rgn;
    if( bShortCut ){
        return TRUE ; // Called by CDrawDoc::Draw().  Skip the test and just Draw().
    }
    rgn.CreatePolygonRgn(m_points, m_nPoints, ALTERNATE);
    return rgn.RectInRegion(rect);
}


//---------------------------------------------------------------------------
CDrawPoly& CDrawPoly::operator=(const CDrawPoly& rdo)
{
   if (this==&rdo)
      return *this;   //return if assigning to self

   CDrawObj::operator=(rdo);  //assign cobject part

   m_points = NewPoints(rdo.m_nAllocPoints);
   memcpy(m_points, rdo.m_points, sizeof(CPoint) * rdo.m_nPoints);
   m_nAllocPoints = rdo.m_nAllocPoints;
   m_nPoints = rdo.m_nPoints;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawPoly::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    CDrawPoly* pClone = new CDrawPoly(m_position);

    ASSERT_VALID(pClone);

    TRY
    {
        *pClone=*this;
        if (pDoc != NULL)
        {
            pDoc->Add(pClone);
        }
        ASSERT_VALID(pClone);
    }
    CATCH_ALL(e)
    {
        //
        // Catch memory faults on operator=
        // Free memory and continue with throwing the exception
        //
        delete (pClone);
        pClone = NULL;
        THROW_LAST();
    }
    END_CATCH_ALL
    return pClone;
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::AddPoint(const CPoint& point, CDrawView* pView)
{
    ASSERT_VALID(this);
    if (m_nPoints == m_nAllocPoints) {
        CPoint* newPoints = NewPoints(m_nAllocPoints + 10);
        if (m_points != NULL) {
             memcpy(newPoints, m_points, sizeof(CPoint) * m_nAllocPoints);
             delete [] m_points;
        }
        m_points = newPoints;
        m_nAllocPoints += 10;
    }

    if (m_nPoints == 0 || m_points[m_nPoints - 1] != point) {
        m_points[m_nPoints++] = point;
        if (!RecalcBounds(pView)) {
            Invalidate();
        }
        m_pDocument->SetModifiedFlag();
    }
}


//---------------------------------------------------------------------------
CPoint* CDrawPoly::NewPoints(int nPoints)
{
    return (CPoint*)new BYTE[nPoints * sizeof(CPoint)];
}


//---------------------------------------------------------------------------
BOOL CDrawPoly::RecalcBounds(CDrawView* pView)
{
    ASSERT_VALID(this);

    if (m_nPoints == 0)
        return FALSE;

    CRect bounds(m_points[0], CSize(0, 0));
    for (int i = 1; i < m_nPoints; ++i) {
        if (m_points[i].x < bounds.left)
                bounds.left = m_points[i].x;
        if (m_points[i].x > bounds.right)
                bounds.right = m_points[i].x;
        if (m_points[i].y < bounds.top)
                bounds.top = m_points[i].y;
        if (m_points[i].y > bounds.bottom)
                bounds.bottom = m_points[i].y;
    }

    if (bounds == m_position)
        return FALSE;

    Invalidate();

    m_position = bounds;

    Invalidate();

    return TRUE;
}


BOOL CDrawOleObj::c_bShowItems = FALSE;


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj() : m_extent(0,0)
{
    m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj(const CRect& position)
        : CDrawObj(position), m_extent(0,0)
{
    m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Serialize( CArchive& ar )
{
    ASSERT_VALID(this);

    CDrawObj::Serialize(ar);

    if (ar.IsStoring()) {
        ar << m_extent;
        ar << m_pClientItem;
    }
    else  {
        ar >> m_extent;
        ar >> m_pClientItem;
        m_pClientItem->m_pDrawObj = this;
    }
}


//---------------------------------------------------------------------------
CDrawOleObj& CDrawOleObj::operator=(const CDrawOleObj& rdo)
{
    CDrawItem* pItem = NULL;

    if (this==&rdo)
    {
        return *this;   //return if assigning to self
    }

    CDrawObj::operator=(rdo);  //assign cdrawobj part

    pItem = new CDrawItem(m_pDocument, this);
    ASSERT_VALID(pItem);
    TRY  
    {
        if (!pItem->CreateCloneFrom(rdo.m_pClientItem))
        {
            AfxThrowMemoryException();
        }
        m_pClientItem = pItem;
    }
    CATCH_ALL(e) 
    {
        pItem->Delete();
        delete pItem;
        m_pClientItem = NULL;
        THROW_LAST();
    }
    END_CATCH_ALL
    return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawOleObj::Clone(CDrawDoc* pDoc)
{
    ASSERT_VALID(this);

    AfxGetApp()->BeginWaitCursor();

    CDrawOleObj* pClone=NULL;

    TRY 
    {
        pClone = new CDrawOleObj(m_position);
        ASSERT_VALID(pClone);
        *pClone=*this;
        if (pDoc != NULL)
        {
           pDoc->Add(pClone);
        }
    }
    CATCH_ALL(e) 
    {
        delete pClone;
        AfxGetApp()->EndWaitCursor();
        THROW_LAST();
    }
    END_CATCH_ALL

    AfxGetApp()->EndWaitCursor();

    return pClone;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Draw(CDC* pDC,CDrawView*)
{
    ASSERT_VALID(this);

    CDrawItem* pItem = m_pClientItem;
    if (pItem != NULL) 
    {
        pItem->Draw(pDC, m_position, DVASPECT_CONTENT);

        if (!pDC->IsPrinting()) 
        {
            // use a CRectTracker to draw the standard effects
            CRectTracker tracker;
            tracker.m_rect = m_position;
            pDC->LPtoDP(tracker.m_rect);

            if (c_bShowItems) 
            {
                // put correct border depending on item type
                if (pItem->GetType() == OT_LINK)
                {
                    tracker.m_nStyle |= CRectTracker::dottedLine;
                }
                else
                {
                    tracker.m_nStyle |= CRectTracker::solidLine;
                }
          }

          // put hatching over the item if it is currently open
          if (pItem->GetItemState() == COleClientItem::openState ||
              pItem->GetItemState() == COleClientItem::activeUIState) 
          {
             tracker.m_nStyle |= CRectTracker::hatchInside;
          }
          tracker.Draw(pDC);
        }
    }
}


//---------------------------------------------------------------------------
void CDrawOleObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
      TRACE(TEXT("AWCPE: CDrawOleObj::Invalidate, missing View pointer\n"));
      return;
   }
   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) {
        rect.left -= 4;
        rect.top -= 5;
        rect.right += 5;
        rect.bottom += 4;
   }
   rect.InflateRect(1, 1); // handles CDrawOleObj objects

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
void CDrawOleObj::OnDblClk(CDrawView* pView)
{
    AfxGetApp()->BeginWaitCursor();
    m_pClientItem->DoVerb(
        GetKeyState(VK_CONTROL) < 0 ? OLEIVERB_OPEN : OLEIVERB_PRIMARY,
        pView);
    AfxGetApp()->EndWaitCursor();

}


//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawOleObj::MoveTo(const CRect& position, CDrawView* pView)
{
    ASSERT_VALID(this);

    if (position == m_position)
        return;

    // call base class to update position
    CDrawObj::MoveTo(position, pView);

    // update position of in-place editing session on position change
    if (m_pClientItem->IsInPlaceActive())
        m_pClientItem->SetItemRects();
}

//----------------------------------------------------------------------------------------------

CMoveContext::CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg) : m_rc(rc), m_pObj(pObj)
{
    m_points=NULL;

    if ( pObj->IsKindOf(RUNTIME_CLASS(CDrawPoly)) && bPointChg) 
    {
        CDrawPoly* pPoly = (CDrawPoly*)pObj;
        m_points = pPoly->NewPoints(pPoly->m_nAllocPoints);
        memcpy(m_points, pPoly->m_points, sizeof(CPoint) * pPoly->m_nPoints);
    }
}

DWORD
DTStyleToESStyle(DWORD dwDTStyle)
/*
    Translate DrawText() alignment style to Edit Styles
*/
{
    DWORD dwESStyle = 0;

    ASSERT(((dwDTStyle & DT_RIGHT) && (dwDTStyle & DT_CENTER)) == FALSE);

    if(dwDTStyle & DT_RIGHT)
    {
        dwESStyle = ES_RIGHT;
    }
    else if(dwDTStyle & DT_CENTER)
    {
        dwESStyle = ES_CENTER;
    }
    else
    {
        dwESStyle = ES_LEFT;
    }

    return dwESStyle;
}

DWORD
DTStyleToEXStyle(DWORD dwDTStyle)
/*
    Translate DrawText() alignment and direction style to Extended Window Styles
*/
{
    DWORD dwEXStyle = 0;

    //
    // Translate the alignment
    //
    if(dwDTStyle & DT_RIGHT)
    {
        dwEXStyle = WS_EX_RIGHT;
    }
    else
    {
        dwEXStyle = WS_EX_LEFT;
    }

    //
    // Translate the reading direction
    //
    if(dwDTStyle & DT_RTLREADING)
    {
        dwEXStyle |= WS_EX_RTLREADING;
    }
    else
    {
        dwEXStyle |= WS_EX_LTRREADING;
    }

    return dwEXStyle;
}

COLORREF 
GetDisplayColor(
    COLORREF color
)
/*
    Translate the actual color to the display color.

    Black and White are auto colors and translated to the COLOR_WINDOWTEXT and COLOR_WINDOW.
    The rest of the colors are user defined and does not changed.
*/
{
    if(COLOR_WHITE == color)
    {
        return GetSysColor(COLOR_WINDOW);
    }
    else if(COLOR_BLACK == color)
    {
        return GetSysColor(COLOR_WINDOWTEXT);
    }
    else
    {
        return color;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpetool.cpp ===
//============================================================================
// cpetool.cpp - implementation for drawing tools
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains tool classes for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/7/95       Added check for empty list in CSelectTool::OnLButtonUp to
//                              avoid GPF (bug 2422).
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <math.h>

#define TOOL  0x8000

CPtrList CDrawTool::c_tools;

static CSelectTool selectTool;
static CRectTool lineTool(line);
static CRectTool textTool(text);
static CRectTool faxpropTool(faxprop);
static CRectTool rectTool(rect);
static CRectTool roundRectTool(roundRect);
static CRectTool ellipseTool(ellipse);
static CPolyTool polyTool;

CPoint CDrawTool::c_down;
UINT CDrawTool::c_nDownFlags;
CPoint CDrawTool::c_last;
DrawShape CDrawTool::c_drawShape = select;

CDrawTool::CDrawTool(DrawShape drawShape)
{
   m_drawShape = drawShape;
   c_tools.AddTail(this);
   m_bMoveCurSet=FALSE;
}

CDrawTool* CDrawTool::FindTool(DrawShape drawShape)
{
   POSITION pos = c_tools.GetHeadPosition();
   while (pos != NULL) {
        CDrawTool* pTool = (CDrawTool*)c_tools.GetNext(pos);
        if (pTool->m_drawShape == drawShape)
                return pTool;
   }

   return NULL;
}

void CDrawTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = pView->GetDocument()->GetInPlaceActiveItem(pView);
   if (pActiveItem != NULL) {
        pActiveItem->Close();
        ASSERT(pView->GetDocument()->GetInPlaceActiveItem(pView) == NULL);
   }

   pView->SetCapture();
   TRACE(TEXT("AWCPE: mouse capture set\n"));
   c_nDownFlags = nFlags;

   //TRACE( "c_down =%d,%d\n", c_down.x, c_down.y );
   c_down = point;

   c_last = point;
}

void CDrawTool::OnLButtonDblClk(CDrawView* , UINT , const CPoint& )
{
}

void CDrawTool::OnLButtonUp(CDrawView* pView, UINT , const CPoint& point)
{
   ReleaseCapture();
   TRACE(TEXT("AWCPE: mouse capture released\n"));

   if (point == c_down) {
      c_drawShape = select;
   }
}

void CDrawTool::OnMouseMove(CDrawView* , UINT , const CPoint& point)
{
   c_last = point;
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));
   m_bMoveCurSet=FALSE;
}

void CDrawTool::OnCancel()
{
   c_drawShape = select;
}

////////////////////////////////////////////////////////////////////////////
// CResizeTool

enum SelectMode
{
   none,
   netSelect,
   move,
   size
};

SelectMode selectMode = none;
int nDragHandle;

CPoint lastPoint;

CSelectTool::CSelectTool()
        : CDrawTool(select)
{
    m_bClicktoMove=FALSE;
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnArrowKey(CDrawView* pView, UINT nChar, UINT nRepCnt, UINT nFlags)
{
   TRACE(TEXT("CSelectTool::OnArrowKey\n"));

   CPoint delta;
   if (nRepCnt>1)
      nRepCnt*=5;

   if (nChar == VK_LEFT) {
      delta.x=-1*((int)nRepCnt);
      delta.y=0;
   }
   if (nChar == VK_RIGHT) {
      delta.x=nRepCnt;
      delta.y=0;
   }
   if (nChar == VK_UP) {
      delta.x=0;
      delta.y=nRepCnt;
   }
   if (nChar == VK_DOWN) {
      delta.x=0;
      delta.y=-1*((int)nRepCnt);
   }

   POSITION pos = pView->m_selection.GetHeadPosition();
   CDrawDoc* pDoc = CDrawDoc::GetDoc();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   CRect position;
   CDrawObj* pObj=NULL;
   while (pos != NULL)
   {
      pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
      position = pObj->m_position + delta;
      int r = (position.right > position.left) ? position.right : position.left;
      int l = (position.right > position.left) ? position.left : position.right;
      int t = (position.top > position.bottom) ? position.top : position.bottom;
      int b = (position.top > position.bottom) ? position.bottom : position.top;

      if (l > rect.left && r < rect.right && t < rect.top && b > rect.bottom )
         pObj->MoveTo(position, pView);
   }

   if(pObj)
   {
        CRect rc = pObj->m_position;
        pView->DocToClient(rc);
        pView->SetCaretPos(rc.CenterPoint());
   }
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    CPoint local = point;
    pView->ClientToDoc(local);


    CDrawObj* pObj;
    selectMode = none;

    // Check for resizing (only allowed on single selections)
    if (pView->m_selection.GetCount() == 1)
    {
        pObj = (CDrawObj*)pView->m_selection.GetHead();
        nDragHandle = pObj->HitTest(local, pView, TRUE);
        if (nDragHandle != 0)
        {
            selectMode = size;
        }
    }

    // See if the click was on an object, select and start move if so
    if (selectMode == none)
    {

       pObj = pView->GetDocument()->ObjectAt(local);

       if (pObj != NULL)
       {
            selectMode = move;

            if (pView->IsSelected(pObj))        //check to activate edit window for edit object
            {
                if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
                   if (((CDrawText*)pObj)->HitTestEdit(pView,local))
                      if (((CDrawText*)pObj)->ShowEditWnd(pView))
                         return;
            }

            if( (nFlags & MK_SHIFT)&&(nFlags & MK_CONTROL) )
            {
                // Shft+Ctrl+Click clones the selection...
                pView->CloneSelection();
            }
            else
            {
                if (!pView->IsSelected(pObj) || ((nFlags & MK_CONTROL) != 0) )
                {
                    if ( (nFlags & MK_CONTROL) == 0)
                    {
                          pView->Select(NULL);
                    }
                    pView->Select(pObj, (nFlags & MK_CONTROL) != 0);
                    pView->UpdateStatusBar();
                    pView->UpdateStyleBar();
                }
                if (!pView->IsSelected(pObj))
                {
                    selectMode=none;
                }
           }
        }
    }

    if (selectMode==move || selectMode==size)
    {
        m_bClicktoMove=TRUE;
    }

        // Click on background, start a net-selection
    if (selectMode == none)
    {

        if ((nFlags & MK_CONTROL) == 0)
             pView->Select(NULL);

        selectMode = netSelect;

        CClientDC dc(pView);
        CRect rect(point.x, point.y, point.x, point.y);
        rect.NormalizeRect();
        dc.DrawFocusRect(rect);
    }

    lastPoint = local;

    CDrawTool::OnLButtonDown(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if ((nFlags & MK_SHIFT) != 0) {
        // Shift+DblClk deselects object...
        CPoint local = point;
        pView->ClientToDoc(local);
        CDrawObj* pObj = pView->GetDocument()->ObjectAt(local);
        if (pObj != NULL)
                pView->Deselect(pObj);
   }
   else {
        // "Normal" DblClk, or OLE server...
        if (pView->m_selection.GetCount() == 1)
                ((CDrawObj*)pView->m_selection.GetHead())->OnDblClk(pView);
   }

   CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   m_bClicktoMove=FALSE;

   if (pView->GetCapture() == pView) {
        if (selectMode == netSelect) {
            CClientDC dc(pView);
            CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
            rect.NormalizeRect();
            dc.DrawFocusRect(rect);

            pView->SelectWithinRect(rect, TRUE);
        }
        else if (selectMode != none) {
                 pView->GetDocument()->UpdateAllViews(pView);
        }
   }

#ifdef GRID
   if (pView->m_bSnapToGrid && (selectMode==move || selectMode==size))
      CheckSnapSelObj(pView);
#endif


   if( (selectMode==size) &&                // if we're sizing AND
       (!pView->m_selection.IsEmpty()) )    // something got picked
   {                                        // then do pObj
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetHead();
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
        {
            ((CDrawText*)pObj)->SnapToFont();
        }
   }


   CDrawTool::OnLButtonUp(pView, nFlags, point);
}


#ifdef GRID
//---------------------------------------------------------------------------------
void CSelectTool::CheckSnapSelObj(CDrawView* pView)
{
   CRect r(0,0,0,0);
   CRect temp;
   int iOffsetX=0;
   int iOffsetY=0;

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
     CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
     temp = pObj->m_position;
     temp.NormalizeRect();
     r |= temp;
   }
   if (r.TopLeft().y < r.BottomRight().y) {
       int temp = r.TopLeft().y;
       r.TopLeft().y=r.BottomRight().y;
           r.BottomRight().y=temp;
   }

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

     //first check Top and left
   for (int y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.TopLeft().y > (y-8) && r.TopLeft().y < (y+8)) {
         iOffsetY=y-r.TopLeft().y;
         break;
      }

   for (int x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.TopLeft().x < (x+8) && r.TopLeft().x > (x-8)) {
         iOffsetX=x-r.TopLeft().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0) {
      AdjustSelObj(pView,iOffsetX,iOffsetY);
      return;
   }

   iOffsetX=iOffsetY=0;

     //if top and left dont need snapping, check right and bottom
   for (y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.BottomRight().y > (y-8) && r.BottomRight().y < (y+8)) {
         iOffsetY=y-r.BottomRight().y;
         break;
      }

   for (x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.BottomRight().x < (x+8) && r.BottomRight().x > (x-8)) {
         iOffsetX=x-r.BottomRight().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0)
      AdjustSelObj(pView,iOffsetX,iOffsetY);
}
#endif


//---------------------------------------------------------------------------------
void CSelectTool::AdjustSelObj(CDrawView* pView, int iOffsetX, int iOffsetY)
{
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
        CRect position = pObj->m_position;
        position.OffsetRect(iOffsetX,iOffsetY);
        pObj->MoveTo(position, pView);
   }
}


#ifdef GRID
//---------------------------------------------------------------------------------
int CSelectTool::NearestGridPoint(CDrawView* pView, CPoint& local,CPoint& ngp)
{
   CSize delta;
   CPoint upL,upR,loL,loR;
   int iDistance;
   int iHold;

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   for (int y = rect.top-20; y > rect.bottom; y -= 20)   //find y bound
      if (local.y > y) {
         upL.y=y+20;
         upR.y=y+20;
         loL.y=y;
         loR.y=y;
         break;
      }
   for (int x = rect.left + 20; x < rect.right; x += 20)  //find x bound
      if (local.x < x) {
         upL.x=x-20;
         loL.x=x-20;
         upR.x=x;
         loR.x=x;
         break;
      }

   delta=(CSize)(local - upR);   //get distance to upR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   iHold=iDistance;
   ngp=upR;

   delta=(CSize)(local - loR);   //get distance to loR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loR;
   }
   delta=(CSize)(local - upL);   //get distance to upL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=upL;
   }
   delta=(CSize)(local - loL);   //get distance to loL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loL;
   }

   return iHold;
}
#endif



//---------------------------------------------------------------------------------
void CSelectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if (pView->GetCapture() != pView) {   //if not in capture, set cursor
      CDrawObj* pObj;
      CPoint local=point;
      pView->ClientToDoc(local);

      if (c_drawShape == select && pView->m_selection.GetCount() == 1) 
      {
          //check for handle cursor change
          pObj = (CDrawObj*)pView->m_selection.GetHead();
          int nHandle = pObj->HitTest(local, pView, TRUE);
          if (nHandle != 0) 
          {
             SetCursor(pObj->GetHandleCursor(nHandle));
             return; // bypass CDrawTool
          }
      }
               //check for move cursor change
      if (c_drawShape == select) 
      {
          pObj=pView->GetDocument()->ObjectAt(local);
          if (pObj != NULL) 
          {
             if (pView->m_selection.GetCount() == 1 && pView->IsSelected(pObj) &&
                 pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) ) 
             {
                if ( !((CDrawText*)pObj)->HitTestEdit(pView,local) ) 
                {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
             else {
                if ( pView->IsSelected(pObj)) {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
          }
      }

      if (c_drawShape == select)
         CDrawTool::OnMouseMove(pView, nFlags, point);

      return;
   }

   // move or resize, add to undo collection

    if (m_bClicktoMove && pView->m_selection.GetCount() > 0) {

        pView->SaveStateForUndo();
        m_bClicktoMove=FALSE;
   }


   if (selectMode == netSelect) {     //do net selection drawing
      CClientDC dc(pView);
      CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);
      rect.SetRect(c_down.x, c_down.y, point.x, point.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);

      CDrawTool::OnMouseMove(pView, nFlags, point);
      return;
   }

   CPoint local = point;
   pView->ClientToDoc(local);
   CPoint delta;
   delta = (CPoint)(local - lastPoint);

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
      CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

      CRect position = pObj->m_position;

      if (selectMode == move) 
      {
        position += delta;
        pObj->MoveTo(position, pView);
      }
      else if (nDragHandle != 0) 
      {
            UINT iShift=0;

            if (nFlags & MK_SHIFT)
                   iShift |= SHIFT_DRAW;

            if (nFlags & TOOL)
                   iShift |= SHIFT_TOOL;

            pObj->MoveHandleTo(nDragHandle, local, pView, iShift);
      }
   }

   lastPoint = local;

   c_last = point;
   if (selectMode == size && c_drawShape == select) 
   {
        if(!pView->m_selection.IsEmpty())
        {
            SetCursor(((CDrawObj*)pView->m_selection.GetHead())->GetHandleCursor(nDragHandle));
        }
        return; // bypass CDrawTool
   }
    else if (selectMode == move && c_drawShape == select) //set cursor if in move mode
    {
        if (!m_bMoveCurSet) 
        {
            SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
            m_bMoveCurSet=TRUE;
        }
        return; // bypass CDrawTool
    }

   if (c_drawShape == select)
        CDrawTool::OnMouseMove(pView, nFlags, point);
}

////////////////////////////////////////////////////////////////////////////
CRectTool::CRectTool(DrawShape drawShape)
        : CDrawTool(drawShape)
{
}

void CRectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDown(pView, nFlags, point);

     CPoint local = point;
     pView->ClientToDoc(local);

     CDrawObj* pObj;

     switch (m_drawShape) {
     default:
        ASSERT(FALSE); // unsuported shape!

     case rect:
        pObj = new CDrawRect(CRect(local, CSize(0, 0)));
        break;

     case text:
        pObj = new CDrawText(CRect(local, CSize(0, 0)));
        break;

//     case faxprop:
//        pObj = new CFaxProp(CRect(local, CSize(0, 0)));
//      break;

     case roundRect:
        pObj = new CDrawRoundRect(CRect(local, CSize(0, 0)));
        break;

     case ellipse:
        pObj = new CDrawEllipse(CRect(local, CSize(0, 0)));
        break;

     case line:
        pObj = new CDrawLine(CRect(local, CSize(0, 0)));
        break;
     }

     pView->GetDocument()->Add(pObj);

     pView->Select(NULL);
     pView->Select(pObj);
         pView->UpdateStatusBar();
         pView->UpdateStyleBar();

     selectMode = size;
     nDragHandle = 1;
     lastPoint = local;
}

void CRectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}

void CRectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   BOOL bObj=TRUE;
   CDrawObj* pObj;

   if (point == c_down && !pView->m_selection.IsEmpty()) 
   {
        // Don't create empty objects...
        pObj = (CDrawObj*)pView->m_selection.GetTail();
        pView->GetDocument()->Remove(pObj);
//      delete pObj;
        selectTool.OnLButtonDown(pView, nFlags, point); // try a select!
        bObj=FALSE;
   }

   selectTool.OnLButtonUp(pView, nFlags, point);

   if (bObj) 
   {
      if (m_drawShape == text && !pView->m_selection.IsEmpty()) 
      {
         pObj = (CDrawObj*) pView->m_selection.GetTail();
         if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
         {
            ((CDrawText*)pObj)->ShowEditWnd(pView);
            pView->Select(NULL, FALSE, FALSE);
         }
      }
   }
}

void CRectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   //TRACE( "point =%d,%d\n", point.x, point.y );
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
   selectTool.OnMouseMove(pView, nFlags | TOOL, point);
}


////////////////////////////////////////////////////////////////////////////
// CPolyTool

CPolyTool::CPolyTool()
        : CDrawTool(poly)
{
   m_pDrawObj = NULL;
}

void CPolyTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   CDrawTool::OnLButtonDown(pView, nFlags, point);

   CPoint local = point;
   pView->ClientToDoc(local);

   if (m_pDrawObj == NULL) {
          pView->SetCapture();

          m_pDrawObj = new CDrawPoly(CRect(local, CSize(0, 0)));
          pView->GetDocument()->Add(m_pDrawObj);
          pView->Select(NULL);
          pView->Select(m_pDrawObj);
      m_pDrawObj->AddPoint(local, pView);
   }
   else if (local == m_pDrawObj->m_points[0]) {
        // Stop when the first point is repeated...
        ReleaseCapture();
        m_pDrawObj->m_nPoints -= 1;
        if (m_pDrawObj->m_nPoints < 2) {
                delete m_pDrawObj;
        }
        else {
                m_pDrawObj->Invalidate();
        }
        m_pDrawObj = NULL;
        c_drawShape = select;
        return;
   }

   local.x += 1; // adjacent points can't be the same!
   m_pDrawObj->AddPoint(local, pView);

   selectMode = size;
   nDragHandle = m_pDrawObj->GetHandleCount();
   lastPoint = local;
}

void CPolyTool::OnLButtonUp(CDrawView* , UINT , const CPoint& )
{
   // Don't release capture yet!
}

void CPolyTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    if (m_pDrawObj != NULL && (nFlags & MK_LBUTTON) != 0) {
       CPoint local = point;
       pView->ClientToDoc(local);
       m_pDrawObj->AddPoint(local);
       nDragHandle = m_pDrawObj->GetHandleCount();
       lastPoint = local;
       c_last = point;
       SetCursor(AfxGetApp()->LoadCursor(IDC_PENCIL));
    }
    else {
       SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
       selectTool.OnMouseMove(pView, nFlags, point);
    }
}

void CPolyTool::OnLButtonDblClk(CDrawView* pView, UINT , const CPoint& )
{
    ReleaseCapture();

    int nPoints = m_pDrawObj->m_nPoints;
    if (nPoints > 2 &&
        (m_pDrawObj->m_points[nPoints - 1] == m_pDrawObj->m_points[nPoints - 2] ||
        m_pDrawObj->m_points[nPoints - 1].x - 1 == m_pDrawObj->m_points[nPoints - 2].x &&
        m_pDrawObj->m_points[nPoints - 1].y == m_pDrawObj->m_points[nPoints - 2].y)) {
        // Nuke the last point if it's the same as the next to last...
        m_pDrawObj->m_nPoints -= 1;
        m_pDrawObj->Invalidate();
    }

    m_pDrawObj = NULL;
    c_drawShape = select;

    //
    // As part of the re-design for fixing bug # 39665,
    // put the "Ready" message back on the status bar.
    // Fix by a-juliar, 05-24-96
    //

    CString sz ;
    sz.LoadString( AFX_IDS_IDLEMESSAGE );
    CMainFrame* pFrame = (CMainFrame*) AfxGetApp()->m_pMainWnd;
    CStatusBar* pStatus = &pFrame->m_wndStatusBar;
    pStatus->SetPaneText( 0, sz );
}

void CPolyTool::OnCancel()
{
    CDrawTool::OnCancel();

    m_pDrawObj = NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpeobj.h ===
//--------------------------------------------------------------------------
// CPEOBJ.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEOBJ_H__
#define __CPEOBJ_H__

#define SHIFT_DRAW      0x0001
#define SHIFT_TOOL      0x0002

class CTextEdit;
class CMainFrame;
class CDrawView;
class CDrawDoc;

  //Colors used in CPE drawing program
#define COLOR_WHITE   RGB(255, 255, 255)
#define COLOR_LTBLUE  RGB(166, 202, 240)
#define COLOR_LTGRAY  RGB(192, 192, 192)
#define COLOR_MDGRAY  RGB(160, 160, 154)
#define COLOR_DKGRAY  RGB(128, 128, 128)
#define COLOR_BLACK   RGB(0, 0, 0)
//-------------------------------------------------------------------------
// CDrawObj - base class for all 'drawable objects'
//-------------------------------------------------------------------------
class CDrawObj : public CObject
{
private:
		void Initilaize(const CRect& rect=CRect(0, 0, 0, 0));
protected:
        DECLARE_SERIAL(CDrawObj);
        CDrawObj();

public:
        BOOL m_bPen;
        BOOL m_bBrush;

        CDrawObj(const CRect& position);

        CRect m_position;
        CDrawDoc* m_pDocument;

        CDrawObj& operator=(const CDrawObj& rdo);

        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        CRect GetHandleRect(int nHandleID, CDrawView* pView);

        virtual HCURSOR GetHandleCursor(int nHandle);

        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        enum TrackerState { normal, selected, active };
        virtual void DrawTracker(CDC* pDC, TrackerState state);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual BOOL ContainedIn(const CRect& rect);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual void OnDblClk(CDrawView* pView);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Invalidate();

// Implementation
public:
        virtual ~CDrawObj();
        virtual void Serialize(CArchive& ar);
        LOGBRUSH m_logbrush;
        LOGPEN   m_logpen;
        LONG     m_lLinePointSize;

#ifdef _DEBUG
        void AssertValid();
#endif

        // implementation data
protected:
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
};




//---------------------------------------------------------------------
class CDrawRect : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawRect);
        CDrawRect();
        ~CDrawRect();

public:
        CDrawRect(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);

protected:

        friend class CRectTool;
};


//---------------------------------------------------------------------
class CFaxText : public CDrawRect
{
protected:
    DECLARE_SERIAL(CFaxText);
    BOOL m_bPrintRTF;
    HINSTANCE m_hLib;
    HWND m_hRTFWnd;
    CFaxText();
    ~CFaxText();
    static DWORD CALLBACK AFX_EXPORT EditStreamCallBack(DWORD_PTR dwCookie,LPBYTE pbBuff, LONG cb, LONG *pcb);
    void RectToTwip(CRect& rc,CDC& dc);
    void CheckForFit();

public:
    WORD m_wResourceid;
    CFaxText(const CRect& position);
    void EndRTF();
    void InitRTF();
    void Initialize();
    void StreamInRTF();

    virtual void Serialize(CArchive& ar);
    virtual void Draw(CDC* pDC,CDrawView*);
    virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:

    friend class CRectTool;
};


//---------------------------------------------------------------------
class CDrawText : public CDrawRect
{
public:
   CTextEdit* m_pEdit;
   HBRUSH   m_brush;
   LOGFONT  m_logfont;
   COLORREF m_crTextColor;

   CDrawText(const CRect& position);
   CDrawText& operator=(const CDrawText& rdo);

   virtual void Serialize(CArchive& ar);
   virtual void Draw(CDC* pDC,CDrawView*);
   virtual BOOL HitTestEdit(CDrawView* pView,CPoint& point);
   virtual void ChgAlignment(CDrawView*, LONG);
   virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
   virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
   virtual CDrawObj* Clone(CDrawDoc* pDoc);
   CFont* GetFont();
   void ChgLogfont(LOGFONT& lf, BOOL bResize=TRUE);

   void ToggleFontForUndo();
   void ToggleAlignmentForUndo();
   LOGFONT m_previousLogfontForUndo;
   LONG m_previousAlignmentForUndo ;
   BOOL CanUndo();
   void OnEditUndo();
   BOOL m_bUndoFont ;          // LOGFONT was last change, and edit control is active.
   BOOL m_bUndoAlignment ;     // ALIGNMENT was last change, and edit control is active.
   BOOL m_bUndoTextChange ;

   void SnapToFont();
   virtual BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize=TRUE);
   virtual void HideEditWnd(CDrawView* pView, BOOL SaveUndoState=TRUE);
   void SetText(CString& szText, CDrawView* pView);
   void NewBrush();
   virtual void OnDblClk(CDrawView* pView);
   HBRUSH GetBrush() {return m_brush;};
   void SnapToFont_onthefly(
       CDrawView *pView,
       CDC *fly_dc,
       CRect &fly_rect,
       CFont *dpFont=NULL
       );
   int GetText( int numlines = -1, BOOL delete_text = FALSE );

   LPTSTR GetRawText( void ) {return (LPTSTR)(LPCTSTR)m_szEditText; }
   CString GetEditTextString(){ return m_szEditText; }
   LONG GetTextAlignment(){ return m_lStyle; }
protected:
   CFont* m_pOldFont;  // font used to save font in DC
   CFont* m_pFont;     // font used for edit control
   LONG   m_lStyle;    // DrawText() format 
   COLORREF m_savepencolor;
   UINT m_savepenstyle;
   CString m_szEditText;
   DECLARE_SERIAL(CDrawText);
   CDrawText();
   ~CDrawText();
   void FitEditWnd( CDrawView*, BOOL call_gettext=TRUE, CDC *pdc=NULL );
   void InitEditWnd();
   void Initialize();
   void GetLongestString(CString& szLong);

   friend class CRectTool;
};



//---------------------------------------------------------------------
class CFaxProp : public CDrawText
{
protected:
        DECLARE_SERIAL(CFaxProp);
        CFaxProp();
        ~CFaxProp();

public:
        CFaxProp(const CRect& position,WORD wResourceid);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void Draw(CDC* pDC,CDrawView*);
   CFaxProp& operator=(const CFaxProp& rdo);
   BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize = TRUE );
   void HideEditWnd(CDrawView* pView, BOOL SaveUndoState = TRUE );

   WORD GetResourceId( void )
                {return( m_wResourceid );}

protected:
   WORD m_wResourceid;
        friend class CRectTool;
};






//---------------------------------------------------------------------
class CDrawLine : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawLine);
        CDrawLine();
        ~CDrawLine();

public:
        CDrawLine(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual int GetHandleCount();
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual void Invalidate();
        void AdjustLineForPen(CRect& rc);
        void NegAdjustLineForPen(CRect& rc);

protected:
    int m_iSlope;
    int m_iB;

        friend class CRectTool;
};




//---------------------------------------------------------------------
class CDrawEllipse : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawEllipse);
        CDrawEllipse();
        ~CDrawEllipse();

public:
        CDrawEllipse(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);

protected:

        friend class CRectTool;
};



//---------------------------------------------------------------------
class CDrawRoundRect : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawRoundRect);
        CDrawRoundRect();
        ~CDrawRoundRect();

public:
        CDrawRoundRect(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
  ////////      virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
   CDrawRoundRect& operator=(const CDrawRoundRect& rdo);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:
        CPoint m_roundness; // for roundRect corners

        friend class CRectTool;
};





//---------------------------------------------------------------------
class CDrawPoly;

class CDrawPoly : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawPoly);
        CDrawPoly();

public:
        CDrawPoly(const CRect& position);

   CDrawPoly& operator=(const CDrawPoly& rdo);
        void AddPoint(const CPoint& point, CDrawView* pView = NULL);
        BOOL RecalcBounds(CDrawView* pView = NULL);

// Implementation
public:
        CRect GetHandleRect(int nHandleID, CDrawView* pView);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual ~CDrawPoly();
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ///////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual void MoveTo(const CRect& position, CDrawView* pView = NULL);
        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

        // static helper for creating arrays of points
        static CPoint* NewPoints(int nPoints);

//protected:
        int m_nPoints;
        int m_nAllocPoints;
        CPoint* m_points;
        CDrawPoly* m_pDrawObj;

//      friend class CPolyTool;
};


//---------------------------------------------------------------------
class CDrawItem;    // COleClientItem derived class

class CDrawOleObj : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawOleObj);
        CDrawOleObj();

public:
        CDrawOleObj(const CRect& position);

// Implementation
public:
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
   CDrawOleObj& operator=(const CDrawOleObj& rdo);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void OnDblClk(CDrawView* pView);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual void Invalidate();

        static BOOL c_bShowItems;

        CDrawItem* m_pClientItem;
        CSize m_extent; // current extent is tracked separate from scaled position
};

//---------------------------------------------------------------------
class CMoveContext: public CObject {
   CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg);
   RECT m_rc;
   CDrawObj* m_pObj;
   CPoint* m_points;
};

COLORREF GetDisplayColor(COLORREF color);

#endif // __CPEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpetool.h ===
//--------------------------------------------------------------------------
// CPETOOL.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPETOOL_H__
#define __CPETOOL_H__


#include "cpeobj.h"


class CDrawView;

enum DrawShape
{
	select,
	line,
	rect,
	text,
	faxprop,
	roundRect,
	ellipse,
	poly
};

class CDrawTool
{
// Constructors
public:
	CDrawTool(DrawShape nDrawShape);

// Overridables
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT) {};
	virtual void OnCancel();

// Attributes
	DrawShape m_drawShape;

	static CDrawTool* FindTool(DrawShape drawShape);
	static CPtrList c_tools;
	static CPoint c_down;
	static UINT c_nDownFlags;
	static CPoint c_last;
	static DrawShape c_drawShape;
    BOOL m_bMoveCurSet;
};

class CSelectTool : public CDrawTool
{
public:
   BOOL m_bClicktoMove;
   BOOL m_bSnapped;
   CPoint m_snappoint;

	CSelectTool();

	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
protected:
#ifdef GRID
   void CheckSnapSelObj(CDrawView*);
   int NearestGridPoint(CDrawView*, CPoint&,CPoint&);
#endif
   void AdjustSelObj(CDrawView*, int, int);
};

class CRectTool : public CDrawTool
{
// Constructors
public:
	CRectTool(DrawShape drawShape);

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
};

class CPolyTool : public CDrawTool
{
// Constructors
public:
	CPolyTool();

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnCancel();

	CDrawPoly* m_pDrawObj;
};

////////////////////////////////////////////////////////////////////////////

#endif // __CPETOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpevw.cpp ===
//===========================================================================
// CPEVW.cpp : implementation of the CDrawView class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main view class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/15/95      Disabled removing offpage objects in CDrawView::SetPageSize
// 2/21         Changed OnSpaceAcross,Down to use floating point
// 3/2          Added throw to EndDoc in render
// 3/9          Added msg-on-cpe stuff
//
//===========================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <dos.h>
#include <direct.h>
#include <afxpriv.h>
#include <math.h>
#include <winspool.h>
#include <faxreg.h>
#include <dlgprnt2.cpp>
#include <faxutil.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CENTER_WHITE_AREA  1 // tonyle wants the white area centered with half the gray on each side.
#define CENTERING_FUDGE_FACTOR 22 // Number of logical units we are consistently off-center by.
#define USING_PAPER_COLOR 0

const int G_ISPACING = 10;     //in LU (MM_LOENGLISH)

//
// private clipboard format (list of Draw objects).
// These could contain LOGFONTA or LOGFONTW structures a-juliar 9-6-96.
//

#ifdef UNICODE
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object W"));
#else
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object A"));
#endif

IMPLEMENT_DYNCREATE(CDrawView, CScrollView)

//--------------------------------------------------------------------------
CDrawView::CDrawView()
{
    m_bHighContrast = IsHighContrast();
//
//  Set m_dwEfcFields to the DWORD value of a registry key if it exists.
//
    HKEY hKey ;
    DWORD dwType ;
    m_dwEfcFields = 0 ;
    DWORD dwRegKeyVal ;
    DWORD dwsz = sizeof(DWORD)/sizeof(BYTE);
    hKey=0;

    if ( ERROR_SUCCESS == ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                          REGKEY_FAX_SETUP,
                                          0,
                                          KEY_READ,
                                          &hKey)) 
    {
        if ( ERROR_SUCCESS == ::RegQueryValueEx(hKey,
                                                TEXT("EFC_CoverPageFields"),
                                                0,
                                                &dwType,
                                                (LPBYTE)&dwRegKeyVal,
                                                &dwsz)) 
        {
            if ( REG_DWORD == dwType )
            {
                        m_dwEfcFields = dwRegKeyVal ;
            }         
        }
   }


   m_bGridLines= FALSE;
#ifdef GRID
   m_bSnapToGrid=FALSE;
#endif

#ifdef GRID
   m_iGridSize=GRID_LARGE;
   m_hbitmap.LoadBitmap(ID_GRIDDOT);
   m_hbitmap.GetObject(sizeof(BITMAP),(LPSTR)&m_bm);
#endif
   m_penSolid.CreatePen(PS_SOLID, 1, COLOR_LTBLUE);
   m_penDot.CreatePen(PS_DOT, 1, COLOR_LTBLUE);

   m_pObjInEdit=NULL;
   m_bFontChg=FALSE;
   m_bKU=TRUE;
   m_bCanUndo = FALSE ;
   if (hKey) {
       RegCloseKey(hKey);
   }
}


//--------------------------------------------------------------------------
CDrawView::~CDrawView()
{
}

//--------------------------------------------------------------------------
BOOL CDrawView::PreCreateWindow(CREATESTRUCT& cs)
{
    ASSERT(cs.style & WS_CHILD);
    if (cs.lpszClass == NULL)
    {
        cs.lpszClass = AfxRegisterWndClass(CS_DBLCLKS);
    }

    CScrollView::PreCreateWindow(cs);

    return TRUE;
}


//--------------------------------------------------------------------------
CDrawView* CDrawView::GetView()
{
    try {
    
    CFrameWnd* pFrame = (CFrameWnd*) AfxGetMainWnd();

    if (!pFrame)
       return NULL;

    CView* pView = pFrame->GetActiveView();
    if (!pView)
       return NULL;

    if (!pView->IsKindOf(RUNTIME_CLASS(CDrawView)))
       return NULL;

    return (CDrawView*) pView;

    } catch(...) {
        ;
    }

    return NULL;

}


//------------------------------------------------------------
void CDrawView::OnUpdate(CView* , LPARAM lHint, CObject* pHint)
{
   switch (lHint)
   {
   case HINT_UPDATE_WINDOW:    // redraw entire window
        Invalidate(FALSE);
        break;

   case HINT_UPDATE_DRAWOBJ:   // a single object has changed
        ((CDrawObj*)pHint)->Invalidate();
        break;

   case HINT_UPDATE_SELECTION: // an entire selection has changed
        {
            CObList* pList = pHint != NULL ? (CObList*)pHint : &m_selection;
            POSITION pos = pList->GetHeadPosition();
            while (pos != NULL)
            {
                ((CDrawObj*)pList->GetNext(pos))->Invalidate();
            }
        }
        break;

   case HINT_DELETE_SELECTION: // an entire selection has been removed
        if (pHint != &m_selection)
        {
            CObList* pList = (CObList*)pHint;
            POSITION pos = pList->GetHeadPosition();
            while (pos != NULL)     
            {
                CDrawObj* pObj = (CDrawObj*)pList->GetNext(pos);
                pObj->Invalidate();
                Remove(pObj);   // remove it from this view's selection
            }
        }
        break;

   case HINT_UPDATE_OLE_ITEMS:
        {
            CDrawDoc* pDoc = GetDocument();
            POSITION pos = pDoc->GetObjects()->GetHeadPosition();
            while (pos != NULL)
            {
                CDrawObj* pObj = (CDrawObj*)pDoc->GetObjects()->GetNext(pos);
                if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
                {
                    pObj->Invalidate();
                }
            }
        }
        break;

   default:
        ASSERT(FALSE);
        break;
   }

}


//--------------------------------------------------------------------------
void CDrawView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
   pDC->SetWindowOrg(0,0);
   CScrollView::OnPrepareDC(pDC, pInfo);
   DoPrepareDC(pDC);
}

//--------------------------------------------------------------------------
// This method created to resolve bug w/ MFC caused by /SUBSYSTEM:Windows,4.0
//--------------------------------------------------------------------------
void CDrawView::DoPrepareDC(CDC* pDC)
{
   CSize extents;

   if (pDC==NULL)
      return;



   // mapping mode is MM_ANISOTROPIC
   // these extents setup a mode similar to MM_LOENGLISH
   // MM_LOENGLISH is in .01 physical inches
   // these extents provide .01 logical inches

   extents.cx = pDC->GetDeviceCaps(LOGPIXELSX);
   extents.cy = pDC->GetDeviceCaps(LOGPIXELSY);

   pDC->SetMapMode(MM_ANISOTROPIC);
   pDC->SetViewportExt( extents );

   pDC->SetWindowExt(100, -100);


   // set the origin of the coordinate system to the center of the page
   CPoint ptOrg;
#if CENTER_WHITE_AREA
   ptOrg.x = GetTotalSize().cx / 2 + CENTERING_FUDGE_FACTOR ;
#else
   ptOrg.x = GetDocument()->GetSize().cx / 2 ;
#endif
   ptOrg.y = GetDocument()->GetSize().cy / 2;

   // ptOrg is in logical coordinates

   pDC->OffsetWindowOrg(-ptOrg.x,ptOrg.y);

}



//--------------------------------------------------------------------------
BOOL CDrawView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
   // do the scroll
   if (!CScrollView::OnScrollBy(sizeScroll, bDoScroll))
        return FALSE;

   // update the position of any in-place active item
   if (bDoScroll)
   {
        UpdateActiveItem();
        UpdateWindow();
   }
   return TRUE;
}


//--------------------------------------------------------------------------
HBRUSH CDrawView::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
    HBRUSH b = CScrollView::OnCtlColor(pDC, pWnd, nCtlColor);

    if (nCtlColor == CTLCOLOR_EDIT) 
    {
        if (m_pObjInEdit) 
        {
            m_pObjInEdit->NewBrush();

            pDC->SetTextColor(GetDisplayColor(m_pObjInEdit->m_crTextColor));
            pDC->SetBkColor(GetDisplayColor(m_pObjInEdit->m_logbrush.lbColor));
            return m_pObjInEdit->GetBrush();            
        }
    }

    return b;
}


//--------------------------------------------------------------------------
void CDrawView::OnDraw(CDC* pDC)
{
    //
    // Revised 8-22-96 by a-juliar to fix NT Bug 43431.
    //
    CDC dc;

    CDC* pDrawDC = pDC;

    CBitmap bitmap;
    CBitmap* pOldBitmap;

    CRect clipbox;

    pDC->GetClipBox(clipbox);

#define GIVE_MFC_NORMALIZE_RECT_A_TRY   0
#if GIVE_MFC_NORMALIZE_RECT_A_TRY
    clipbox.NormalizeRect();
#else
    if( clipbox.bottom > clipbox.top )
    {
        int temp = clipbox.bottom ;
        clipbox.bottom = clipbox.top ;
        clipbox.top = temp ;
    }
    if( clipbox.left > clipbox.right )
    {
        int temp = clipbox.left ;
        clipbox.left = clipbox.right ;
        clipbox.right = temp ;
    }
#endif
    clipbox.top    += 1;
    clipbox.left   -= 1;
    clipbox.right  += 1;
    clipbox.bottom -= 1;
    CRect rect = clipbox ;
    DocToClient(rect);        // Now "rect" is in device coordinates and "clipbox" is in logical coordinates.

    CDrawDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    if(!pDC->IsPrinting()) 
    {
        // draw to offscreen bitmap for fast looking repaints
        if( dc.CreateCompatibleDC(pDC) )
        {
            if (bitmap.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height())) 
            {
                OnPrepareDC(&dc,NULL);
                pDrawDC = &dc;

                // offset origin more because bitmap is just piece of the whole drawing

                dc.OffsetViewportOrg(-rect.left, -rect.top);
                pOldBitmap = dc.SelectObject(&bitmap);
                dc.SetBrushOrg(rect.left % 8, rect.top % 8);

                // might as well clip to the same rectangle

                dc.IntersectClipRect(clipbox);
            }
        }
    }
    else
    {
        //
        // Printing. Must undo the correction for centering done in DoPrepareDC();
        //
        pDrawDC->OffsetWindowOrg( ( GetTotalSize().cx - pDoc->GetSize().cx )/ 2 + CENTERING_FUDGE_FACTOR, 0 ) ;
    }
    if (!pDC->IsPrinting())
    {
        //
        // Paint the whole thing Light Gray first.  The white part will be done in DrawGrid().
        //
        HBRUSH oldbrush = (HBRUSH)::SelectObject(pDrawDC->m_hDC,(HBRUSH)::GetStockObject(LTGRAY_BRUSH) );
        
        pDrawDC->PatBlt( clipbox.left, clipbox.top, clipbox.Width(), clipbox.Height(), PATCOPY);

        ::SelectObject(pDrawDC->m_hDC,oldbrush);

        DrawGrid( pDrawDC );
    }
    else
    {
        // Printing.
        // Paint the whole thing white.  Paper color feature isn't supported.
        //
        pDrawDC->FillSolidRect(clipbox, COLOR_WHITE);

    }


    if (!pDoc->m_bSerializeFailed)
    {
        //
        // Serializaion succeeded - draw the document
        //
        pDoc->Draw(pDrawDC, this, clipbox);
    }
    if (pDrawDC != pDC) 
    {
        pDC->SetViewportOrg(0, 0);
        pDC->SetWindowOrg(0,0);
        pDC->SetMapMode(MM_TEXT);
        dc.SetViewportOrg(0, 0);
        dc.SetWindowOrg(0,0);
        dc.SetMapMode(MM_TEXT);
        pDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(),
                        &dc, 0, 0, SRCCOPY);
        dc.SelectObject(pOldBitmap);
    }
}


//--------------------------------------------------------------------------
void CDrawView::Remove(CDrawObj* pObj)
{
   POSITION pos = m_selection.Find(pObj);
   if (pos != NULL)
          m_selection.RemoveAt(pos);

}


//--------------------------------------------------------------------------
void CDrawView::PasteNative(COleDataObject& dataObject)
{
   // get file refering to clipboard data
   CFile* pFile = dataObject.GetFileData(m_cfDraw);
   if (pFile == NULL)
        return;

   // connect the file to the archive
   CArchive ar(pFile, CArchive::load);
   TRY
   {
        ar.m_pDocument = GetDocument(); // set back-pointer in archive

        // read the selection
        m_selection.Serialize(ar);
   }
   CATCH_ALL(e)
   {
        ar.Close();
        delete pFile;
        THROW_LAST();
   }
   END_CATCH_ALL

   ar.Close();
   delete pFile;
}


//--------------------------------------------------------------------------
void CDrawView::PasteEmbedded(COleDataObject& dataObject)
{
   BeginWaitCursor();

   // paste embedded
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);
   CDrawItem* pItem;
   TRY 
   {
        pItem = new CDrawItem(GetDocument(), pObj);
   }
   CATCH_ALL(e)
   {
        delete pObj;
        THROW_LAST();
   }
   END_CATCH_ALL

   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   TRY {
        if (!pItem->CreateFromData(&dataObject) &&
                !pItem->CreateStaticFromData(&dataObject)) {
                AfxThrowMemoryException();      // any exception will do
        }

        // add the object to the document
        GetDocument()->Add(pObj);
        m_selection.AddTail(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();
   }
   CATCH_ALL(e) {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::DrawGrid(CDC* pDC )
{
    //
    // Revised by a-juliar 8-22-96 to fix NT bug 43431.
    // Called by CDrawView::OnDraw(), which will draw the gray background.
    // Thus we do not need the client rect or clip box here at all.
    // The white background for the printable portion of the document will be drawn here.
    //
   CDrawDoc* pDoc = GetDocument();

   CRect rect;    // White area containing the printable portion of our document.

   int RectWidth  = pDoc->GetSize().cx ;
   int RectHeight = pDoc->GetSize().cy ;
   rect.left = - RectWidth / 2;
   rect.top = RectHeight / 2;
   rect.right = rect.left + RectWidth ;
   rect.bottom = rect.top - RectHeight ;

    //
    //  Draw background.
    //
    HBRUSH oldbrush = (HBRUSH)::SelectObject(pDC->m_hDC, ::GetSysColorBrush(COLOR_WINDOW));
    pDC->PatBlt(rect.left, rect.top, RectWidth, -RectHeight, PATCOPY);

    //
    // draw shadow
    //
    ::SelectObject(pDC->m_hDC, ::GetSysColorBrush(COLOR_3DDKSHADOW));
    pDC->PatBlt(rect.right,rect.top-5, 5, -RectHeight, PATCOPY );
    pDC->PatBlt(rect.left+5,rect.bottom, RectWidth, -5, PATCOPY );

    ::SelectObject(pDC->m_hDC,oldbrush);

    // Outlines

    pDC->MoveTo(rect.right, rect.top);
    pDC->LineTo(rect.right, rect.bottom);
    pDC->LineTo(rect.left, rect.bottom);
    pDC->LineTo(rect.left, rect.top);

    //
    // If "Grid lines" is checked on the view menu, draw the grid lines.
    //

    if (m_bGridLines) 
    {
        CPen* pOldPen = pDC->SelectObject(&m_penDot);
        for (int x = 100; x < rect.right; x += 100) {      // +x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (x = -100; x > rect.left; x -= 100) {      // -x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (int y = 100; y < rect.top; y += 100) {        // +y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }
        for (y = -100; y > rect.bottom; y -= 100) {        // -y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }

        pDC->SelectObject(&m_penSolid);
        //Center lines
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.right, 0);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(0, rect.bottom);

        pDC->SelectObject(pOldPen);
    }
}
// -------------------------------------------------------------------------
CSize CDrawView::ComputeScrollSize( CSize size )
{
    //
    //  Compute the scroll sizes.  The width needs to accommodate a grayed area on the margins of
    //  the document, at least 1.25 times the width of the document, and at least as wide as the
    //  client area of the window when it is maximized.  a-juliar 6-24-96
    //

    CClientDC dc(NULL);
    size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
   // size.cx = MulDiv((int)(size.cx * 1.10), dc.GetDeviceCaps(LOGPIXELSX), 100 ); // deliberate gray area
    size.cx = MulDiv( size.cx+16, dc.GetDeviceCaps(LOGPIXELSX), 100 ) ; // No unnecessary gray area.
#if CENTER_WHITE_AREA

    //
    //  Find out how wide the view is when maximized. Make scroll width at least this wide.
    //
#if 0
    long lScreenWidth = dc.GetDeviceCaps( HORZRES ) ;
    NONCLIENTMETRICS ncm ;
    BOOL rval = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    int iScrollBarAndBorderWidth = ncm.iBorderWidth + ncm.iScrollWidth ;
    long lMaxWidth = lScreenWidth - iScrollBarAndBorderWidth ;
    size.cx = rval ? max( lMaxWidth, size.cx ) : max( lScreenWidth, size.cx ) ;
#endif

    size.cx = max( size.cx,
                   GetSystemMetrics( SM_CXMAXIMIZED )
                      - GetSystemMetrics( SM_CXVSCROLL )
                           - 2 * GetSystemMetrics( SM_CXBORDER ));

#endif

    return size ;
}

//--------------------------------------------------------------------------
void CDrawView::OnInitialUpdate()
{
#if 0
   CSize size = GetDocument()->GetSize();
   CClientDC dc(NULL);
   size.cx = MulDiv(size.cx+(int)(size.cx*.25), dc.GetDeviceCaps(LOGPIXELSX), 100);
   size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
#endif
   CSize size = ComputeScrollSize( GetDocument()->GetSize() );
   SetScrollSizes(MM_TEXT, size);

   m_selection.RemoveAll();
#if CENTER_WHITE_AREA
   POINT ptStartingPosition ;
   ptStartingPosition.y = 0 ;
   CRect rect ;
   GetClientRect( &rect );
   ptStartingPosition.x = ( size.cx - rect.right ) / 2 ;
   ScrollToPosition( ptStartingPosition );
#endif

    //
    // The view should have LTR layout
    //
    if(theApp.IsRTLUI())
    {
        ModifyStyleEx(WS_EX_LAYOUTRTL | WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_RIGHTSCROLLBAR,
                      WS_EX_LEFT | WS_EX_LTRREADING | WS_EX_LEFTSCROLLBAR,
                      SWP_NOSIZE | SWP_NOMOVE  | SWP_NOZORDER);
    }
}


//--------------------------------------------------------------------------
void CDrawView::SetPageSize(CSize size)
{
   size = ComputeScrollSize(size);
   SetScrollSizes(MM_TEXT, size);
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_WINDOW, NULL);
}


//--------------------------------------------------------------------------
BOOL CDrawView::OnPreparePrinting(CPrintInfo* pInfo)
{
    if (pInfo->m_pPD)
    {
        delete pInfo->m_pPD;
    }

    if (IsWinXPOS())
    {   
        //
        // Use new look of printer selection dialog
        //
        pInfo->m_pPD = new C_PrintDialogEx (FALSE,
                                            PD_ALLPAGES                  | 
                                            PD_USEDEVMODECOPIES          |
                                            PD_NOPAGENUMS                |
                                            PD_NOSELECTION               |
                                            PD_RETURNDC);         
    }
    else
    {
        //
        // Use legacy printer selection dialog
        //
        pInfo->m_pPD = new CMyPrintDlg(FALSE, PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOSELECTION);
    }
    if (m_pObjInEdit)     //if there's an object in edit, remove it
    {
        m_pObjInEdit->HideEditWnd(this);
    }

    if (pInfo && GetApp()->m_bCmdLinePrint)
    {
        pInfo->m_bPreview=TRUE;
    }
    if (pInfo->m_bPreview) 
    {
        pInfo->SetMinPage(1);
        pInfo->SetMaxPage(1);
    }
    return DoPreparePrinting(pInfo);
}   // CDrawView::OnPreparePrinting


//--------------------------------------------------------------------------
void CDrawView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
   CScrollView::OnBeginPrinting(pDC,pInfo);

//   GetDocument()->ComputePageSize();
}

//--------------------------------------------------------------------------
void CDrawView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}


//--------------------------------------------------------------------------
BOOL CDrawView::IsSelected(const CObject* pDocItem) const
{
   CDrawObj* pDrawObj = (CDrawObj*)pDocItem;
   if (pDocItem->IsKindOf(RUNTIME_CLASS(CDrawItem)))
        pDrawObj = ((CDrawItem*)pDocItem)->m_pDrawObj;
   return m_selection.Find(pDrawObj) != NULL;
}


//--------------------------------------------------------------------------
void CDrawView::OnInsertObject()
{
   // Invoke the standard Insert Object dialog box to obtain information
   //  for new CDrawItem object.
   CMyOleInsertDialog dlg;       //// To get Context Sensitive Help, we define our own class. a-juliar
   if (dlg.DoModal() != IDOK)
        return;

   BeginWaitCursor();

   // First create the C++ object
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);

   CDrawItem* pItem;
   TRY 
   {
       pItem = new CDrawItem(GetDocument(), pObj);
   }
   CATCH_ALL(e)
   {
        delete pObj;
        THROW_LAST();
   }
   END_CATCH_ALL
  
   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   // Now create the OLE object/item
   TRY
   {
        if (!dlg.CreateItem(pObj->m_pClientItem)) {
                AfxThrowMemoryException();
        }

        // add the object to the document
        GetDocument()->Add(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
                pItem->DoVerb(OLEIVERB_SHOW, this);

        GetDocument()->UpdateAllViews( NULL );
   }
   CATCH_ALL(e)
   {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}

//--------------------------------------------------------------------------
// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.
//--------------------------------------------------------------------------
void CDrawView::OnCancelEdit()
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL) {
        // if we found one, deactivate it
        pActiveItem->Close();
   }
   ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);

   // escape also brings us back into select mode
   ReleaseCapture();

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
        pTool->OnCancel();

   CDrawTool::c_drawShape = select;
}


//--------------------------------------------------------------------------
void CDrawView::OnSetFocus(CWnd* pOldWnd)
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // need to set focus to this item if it is in the same view
        CWnd* pWnd = pActiveItem->GetInPlaceWindow();
        if (pWnd != NULL) {
                pWnd->SetFocus();
                return;
        }
    }

    CreateSolidCaret(10,10);

    CScrollView::OnSetFocus(pOldWnd);
}

void 
CDrawView::OnKillFocus(CWnd* pNewWnd)
{
    ::DestroyCaret();
    CScrollView::OnSetFocus(pNewWnd); 

    if(CDrawTool::c_drawShape != select)
    {
        CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
        if (pTool != NULL)
        {
            pTool->OnCancel();
        }

        CDrawTool::c_drawShape = select;
    }
}

//--------------------------------------------------------------------------
CRect CDrawView::GetInitialPosition()
{
    CRect rect(10, 10, 10, 10);
    ClientToDoc(rect);
    return rect;
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CPoint& point, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(&point);
      return;
   }

   pDC->DPtoLP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(rect);
      ASSERT(rect.left <= rect.right);
      ASSERT(rect.bottom <= rect.top);
      return;
   }

   pDC->DPtoLP(rect);
   ASSERT(rect.left <= rect.right);
   ASSERT(rect.bottom <= rect.top);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CPoint& point, CDC* pDC)
{
    if (pDC==NULL) 
    {
        CClientDC dc(this);
        OnPrepareDC(&dc,NULL);
        dc.LPtoDP(&point);
        return;
    }
    pDC->LPtoDP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.LPtoDP(rect);
      rect.NormalizeRect();
          return;
   }

   pDC->LPtoDP(rect);
   rect.NormalizeRect();
}


//--------------------------------------------------------------------------
void CDrawView::CheckStyleBar(BOOL bUnderline, BOOL bBold, BOOL bItalic,
   BOOL bLeft, BOOL bCenter, BOOL bRight)
{
    UINT id, style;
    int i;
    int image;

    CMainFrame* pFrame = GetFrame();  
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bUnderline)
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bBold)
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bItalic)
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bLeft)
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bCenter)
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bRight) {
       pFrame->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    }
    else
       pFrame->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

}


//--------------------------------------------------------------------------
// * Updates style bar based on font characterics of selected object(s)
// * Called whenever a drawing object is selected or deselected
//--------------------------------------------------------------------------
void CDrawView::UpdateStyleBar(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
   CString sz;
   CString cFace;
   LONG    style;
   TCHAR   cSize[5];

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   CComboBox& cboxSize = pFrame->m_StyleBar.m_cboxFontSize;
   CComboBox& cboxName = pFrame->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob = pObList;
   else
      pob = &m_selection;

   CDrawText* pText;
   if (p)
      pText = p;
   else
      pText = m_pObjInEdit;

   if (pText) 
   {
      if (!pText->m_pEdit)
      {
         return;
      }

      cFace = pText->m_logfont.lfFaceName;
      cboxName.GetWindowText(sz);
      if (sz != cFace)
      {
            cboxName.SetWindowText(cFace);
      }

      _itot(GetPointSize(*pText),cSize,10); //POINT SIZE
      cboxSize.GetWindowText(sz);
      if (sz!=cSize)
      {
            cboxSize.SetWindowText(cSize);
      }

      style = pText->m_pEdit->GetStyle();
      CheckStyleBar(pText->m_logfont.lfUnderline,                    //underline
                    pText->m_logfont.lfWeight==FW_BOLD,              //bold
                    pText->m_logfont.lfItalic,                       //italic
                    (!((style & ES_CENTER) || (style & ES_RIGHT))),  //left
                    style & ES_CENTER,                               //center
                    style & ES_RIGHT);                               //right
      return;
   }

   BOOL bText=FALSE;
   BOOL bFontFace=TRUE;
   BOOL bPointSize=TRUE;
   BOOL bUnderline=TRUE;
   BOOL bBold=TRUE;
   BOOL bItalic=TRUE;
   BOOL bLeft=TRUE;
   BOOL bCenter=TRUE;
   BOOL bRight=TRUE;
   CString szSaveFace;
   WORD wSaveSize=0;
   CDrawText* pTxt;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) 
   {
     CDrawObj* pObj = (CDrawObj*)pob->GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
         pTxt=(CDrawText*)pObj;
         if (pTxt->m_pEdit)
         {
            bText=TRUE;
         }
         else
         {
             continue;
         }

        if ( (wSaveSize != 0) && (GetPointSize(*pTxt) != wSaveSize) ) //font size
           bPointSize=FALSE;

        cFace=pTxt->m_logfont.lfFaceName;

        if ( (szSaveFace.GetLength() > 0) && (cFace != szSaveFace) )
           bFontFace=FALSE;

        if (!pTxt->m_logfont.lfUnderline)     //underline
           bUnderline=FALSE;

        if (pTxt->m_logfont.lfWeight!=FW_BOLD) //bold
           bBold=FALSE;

        if (!pTxt->m_logfont.lfItalic)         //italic
           bItalic=FALSE;

        style=::GetWindowLong(((CDrawText*)pObj)->m_pEdit->m_hWnd, GWL_STYLE);
        if ( ((style & ES_CENTER) || (style & ES_RIGHT)) )  //left style
           bLeft=FALSE;

        if (!(style & ES_CENTER))  //center style
           bCenter=FALSE;

        if ( !(style & ES_RIGHT) )  //right style
           bRight=FALSE;

        szSaveFace=cFace;
        wSaveSize=(WORD)GetPointSize(*pTxt);
     }
   }

   if (!bText) //no object in edit, nor any text object
      return;

   cboxName.GetWindowText(sz);
   if (bFontFace) {
      if (sz!=szSaveFace)
         cboxName.SetWindowText(cFace);
   }
   else
      cboxName.SetWindowText(TEXT(""));

   cboxSize.GetWindowText(sz);
   if (bPointSize) {
      _itot(wSaveSize,cSize,10);
      if (cSize!=sz)
         cboxSize.SetWindowText(cSize);
   }
   else
      cboxSize.SetWindowText(TEXT(""));

   CheckStyleBar(bUnderline, bBold, bItalic, bLeft, bCenter, bRight);
}


//--------------------------------------------------------------------------
void CDrawView::Select(CDrawObj* pObj, BOOL bShift /*=FALSE*/, BOOL bCheckEdit /*=TRUE*/)
{
    if (bCheckEdit && m_pObjInEdit)     //if there's an object in edit, remove it
       m_pObjInEdit->HideEditWnd(this);

    if (pObj==NULL) 
    {
        OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
        m_selection.RemoveAll();
        return;
    }

    if (bShift) 
    {
        if (IsSelected(pObj)) 
        {
            Deselect(pObj);
            return;
        }
    }

    if (!IsSelected(pObj)) 
    {
        m_selection.AddTail(pObj);
        pObj->Invalidate();

        CRect rc = pObj->m_position;
        DocToClient(rc);
        SetCaretPos(rc.CenterPoint());
    }
}


//--------------------------------------------------------------------------
// rect is in device coordinates
//--------------------------------------------------------------------------
void CDrawView::SelectWithinRect(CRect rect, BOOL bAdd)
{
    if (!bAdd)
            Select(NULL);

    ClientToDoc(rect);

    CObList* pObList = GetDocument()->GetObjects();
    POSITION posObj = pObList->GetHeadPosition();
    CDrawObj* pObj;
    while (posObj != NULL) 
    {
        pObj = (CDrawObj*)pObList->GetNext(posObj);
        if (pObj->ContainedIn(rect))
                Select(pObj);
    }

    UpdateStatusBar();
    UpdateStyleBar();
}


//--------------------------------------------------------------------------
void CDrawView::Deselect(CDrawObj* pObj)
{
    POSITION pos = m_selection.Find(pObj);
    if (pos != NULL) 
    {
        pObj->Invalidate();
        m_selection.RemoveAt(pos);
    }
    UpdateStatusBar();
    UpdateStyleBar();
}

//--------------------------------------------------------------------------
void CDrawView::CloneSelection()
{
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);

        BOOL bThisIsANote = FALSE ;
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ){
            CFaxProp * pfaxprop = (CFaxProp *)pObj;
            if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){
                 bThisIsANote = TRUE ;
            }
        }
        if (!bThisIsANote){
           pObj->Clone(pObj->m_pDocument);
        }
                // copies object and adds it to the document
    }
}


//--------------------------------------------------------------------------
void CDrawView::UpdateActiveItem()
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // this will update the item rectangles by calling
        //  OnGetPosRect & OnGetClipRect.
        pActiveItem->SetItemRects();
    }
}

//--------------------------------------------------------------------------
// CDrawView message handlers
//--------------------------------------------------------------------------
void CDrawView::OnLButtonDown(UINT nFlags, CPoint point)
{
   CObList oblist;
   if (m_bFontChg) {
      POSITION pos = m_selection.GetHeadPosition();
      while (pos != NULL)
          oblist.AddHead(m_selection.GetNext(pos));
   }

   CDrawText* p = m_pObjInEdit;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
       pTool->OnLButtonDown(this, nFlags, point);

   if (m_bFontChg) {
      OnSelChangeFontSize(&oblist,p);
      OnSelChangeFontName(&oblist,p);
      m_bFontChg=FALSE;
   }
}



//--------------------------------------------------------------------------
void CDrawView::OnContextMenu(CWnd *pWnd, CPoint pt)
{
    if (GetCapture() == this) 
    {
        TRACE(TEXT("AWCPE:  CDrawView::OnContextMenu, cannot invoke properties when in LButtondown capture\n"));
        return;
    }


    if (pt.x == -1 && pt.y == -1)
    {
        //
        // Keyboard (VK_APP or Shift + F10)
        // Pop the context menu near the mouse cursor
        //
        pt = (CPoint) GetMessagePos();
    }

    CDrawObj* pObj;

    ScreenToClient(&pt);
    CPoint local = pt;
    ClientToDoc(local);

    pObj = GetDocument()->ObjectAt(local);

    if (pObj == NULL) 
    {
        TrackViewMenu(pt);
        return;
    }
    if(!IsSelected(pObj))
    {
        while(!m_selection.IsEmpty())
        {
            CDrawObj* AnObj = (CDrawObj*) m_selection.GetHead() ;
            AnObj->Invalidate();
            m_selection.RemoveHead();
        }
        m_selection.AddHead( pObj );
        pObj->Invalidate();
    }
    TrackObjectMenu(pt);
}

//---------------------------------------------------------------------------------
void CDrawView::TrackObjectMenu(CPoint& pt)
{
   BOOL bTextObj=FALSE;
   BOOL bOLEObj=FALSE;

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL && !(bTextObj && bOLEObj) ) {
     CDrawObj* pobj = (CDrawObj*) m_selection.GetNext(pos);
     if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawText)) )
        bTextObj=TRUE;
     else
        if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
           bOLEObj=TRUE;
   }

   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_CUT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_CUT, temp);
   temp.LoadString(IDS_MENU_COPY);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_COPY, temp);
   temp.LoadString(IDS_MENU_PASTE);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PASTE, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);
   if (bOLEObj) {
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OLE_VERB_FIRST, _TEXT("<<OLE VERBS GO HERE>>"));
      mainmenu.AppendMenu(MF_SEPARATOR);
   }
   CMenu textmenu;
   if (bTextObj) {
      temp.LoadString(IDS_MENU_FONT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_FONT, temp);

      textmenu.CreatePopupMenu();
      temp.LoadString(IDS_MENU_ALIGNLEFT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_LEFT, temp);
      temp.LoadString(IDS_MENU_ALIGNCENTER);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_CENTERED, temp);
      temp.LoadString(IDS_MENU_ALIGNRIGHT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_RIGHT, temp);

      temp.LoadString(IDS_MENU_ALIGNTEXT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED | MF_POPUP,
                          (UINT_PTR)textmenu.GetSafeHmenu(),
              temp);

      mainmenu.AppendMenu(MF_SEPARATOR);
   }

   temp.LoadString(IDS_MENU_PROPERTIES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PROPERTIES, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);

   temp.LoadString(IDS_MENU_MOVETOFRONT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOFRONT, temp);
   temp.LoadString(IDS_MENU_SENDTOBACK);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOBACK, temp);

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
   if (bTextObj)
      textmenu.Detach();
}


//--------------------------------------------------------------------------
void CDrawView::TrackViewMenu(CPoint& pt)
{
   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_VIEWSTYLEBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STYLEBAR, temp);
   temp.LoadString(IDS_MENU_VIEWDRAWINGBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_DRAWBAR, temp);
   temp.LoadString(IDS_MENU_VIEWSTATUSBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STATUS_BAR, temp);
   temp.LoadString(IDS_MENU_VIEWGRIDLINES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRIDLINES, temp);

#ifdef GRID
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRID, _TEXT("Grid Lines"));
   mainmenu.AppendMenu(MF_SEPARATOR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_GRID_SETTINGS, _TEXT("Grid Settings..."));
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_SNAP_TO_GRID, _TEXT("Snap to &Grid"));
#endif

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
}



//--------------------------------------------------------------------------
void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonUp(this, nFlags, point);

    if (CDrawTool::c_drawShape != poly) {
       CDrawTool::c_drawShape = select;
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnMouseMove(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnMouseMove(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonDblClk(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnDestroy()
{
    CScrollView::OnDestroy();

    // deactivate the inplace active item on this view
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
    {
        pActiveItem->Deactivate();
        ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
    }
}


//--------------------------------------------------------------------------
// *_*_*_   RECIPIENT WM_COMMAND METHODS
//--------------------------------------------------------------------------
void CDrawView::CreateFaxProp(WORD wResID)
{
   CDrawText* pTextObj;
   CFaxProp*  pFaxPropObj;

   CString szCaption;
   CString szPropName;

   BeginWaitCursor();

   if (GetApp() && GetApp()->m_pFaxMap) 
   {
      GetApp()->m_pFaxMap->GetCaption(wResID,    szCaption);
      GetApp()->m_pFaxMap->GetPropString(wResID, szPropName);
   }

//FETCH CLIENT AREA MEASUREMENTS
   CRect rcClient;   //client area
   GetClientRect(&rcClient);
   ClientToDoc(rcClient);
   NormalizeRect(rcClient);

   CPoint pt = rcClient.TopLeft();
   int iHalfWidth  = (rcClient.right - rcClient.left)/2;
   int iHalfHeight = (rcClient.top   - rcClient.bottom)/2;

//SET FAX PROPERTY
   pFaxPropObj = new CFaxProp(CRect(0,0,0,0), wResID);
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX), dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectObject(pFaxPropObj->GetFont());

   TEXTMETRIC tm;
   dc.GetTextMetrics(&tm);

   int iPropWidth  = GetApp()->m_pFaxMap->GetPropDefLength(wResID) * tm.tmAveCharWidth;
   int iPropHeight = GetApp()->m_pFaxMap->GetPropDefLines (wResID) * (tm.tmHeight + 3*tm.tmInternalLeading);

//SET CAPTION SIZE
   TRY 
   {
       pTextObj = new CDrawText(CRect(0,0,0,0));
   }
   CATCH_ALL(e)
   {
        delete pFaxPropObj;
        THROW_LAST();
   }
   END_CATCH_ALL

   dc.SelectObject(pTextObj->GetFont());

   CSize sizeCaption = dc.GetTextExtent(szCaption, szCaption.GetLength()+1);
   sizeCaption.cx += 10;
   sizeCaption.cy += 3 * tm.tmInternalLeading;

//SET SIZES AND LOCATION OF BINDING RECT
   int iRcWidth  = iPropWidth + sizeCaption.cx + G_ISPACING;
   int iRcHeight = max(iPropHeight, sizeCaption.cy);

   pt.x = (pt.x + iHalfWidth)  - (long)(0.5 * iRcWidth);
   pt.y = (pt.y - iHalfHeight) + (long)(0.5 * iRcHeight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect rcObj(pt.x, pt.y, pt.x + iRcWidth, pt.y - iRcHeight);
   FindLocation(rcObj);

//SET CAPTION AND FAX PROPERTY
   if(theApp.IsRTLUI())
   {
        //
        // For RTL UI the caption should be on the right side of the property
        //
        pFaxPropObj->m_position.SetRect( rcObj.left, rcObj.top, rcObj.left + iPropWidth, rcObj.top - iPropHeight);      

        rcObj.left += iPropWidth + G_ISPACING;
        pTextObj->m_position.SetRect(rcObj.left, rcObj.top, rcObj.left + sizeCaption.cx, rcObj.top - sizeCaption.cy);
   }
   else
   {
        pTextObj->m_position.SetRect(rcObj.left, rcObj.top, rcObj.left + sizeCaption.cx, rcObj.top - sizeCaption.cy);
        rcObj.left += sizeCaption.cx + G_ISPACING;

        //set property object text
        pFaxPropObj->m_position.SetRect( rcObj.left, rcObj.top, rcObj.left + iPropWidth, rcObj.top - iPropHeight);      
   }

//Snap to current font for fine tuning
   pTextObj->SnapToFont();
   pFaxPropObj->SnapToFont();

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   pTextObj->SetText(szCaption, this);
   pFaxPropObj->SetText(szPropName, this);
   GetDocument()->Add(pTextObj);
   GetDocument()->Add(pFaxPropObj);
   Select(NULL);
   Select(pTextObj);
   Select(pFaxPropObj);

   UpdateStatusBar();
   UpdateStyleBar();

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::CreateFaxText()
{
   CFaxText* pFaxText;

   BeginWaitCursor();

//FETCH CLIENT AREA MEASUREMENTS
   CRect clientrect;   //client area
   TEXTMETRIC tm;
   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;
   CPoint cp = clientrect.TopLeft();

//SET FAX PROPERTY
   pFaxText = new CFaxText(CRect(0,0,0,0));
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX),dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectStockObject(SYSTEM_FONT);
   dc.GetTextMetrics(&tm);
   int faxpropWidth = GetApp()->m_pFaxMap->GetPropDefLength(IDS_PROP_MS_TEXT)
           * tm.tmAveCharWidth;
   int faxpropHeight = GetApp()->m_pFaxMap->GetPropDefLines(IDS_PROP_MS_TEXT)
           * (tm.tmHeight+3*tm.tmInternalLeading);

//SET SIZES AND LOCATION OF BINDING RECT
   cp.x = (cp.x+ihalfwidth)-(long)(.5*faxpropWidth);
   cp.y = (cp.y-ihalfheight)+(long)(.5*faxpropHeight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect objrect(cp.x,cp.y,cp.x+faxpropWidth,cp.y-faxpropHeight);
   FindLocation(objrect);

//SET CAPTION AND FAX PROPERTY
   pFaxText->m_position.SetRect( objrect.left,objrect.top, objrect.bottom, objrect.right);

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   GetDocument()->Add(pFaxText);
   Select(NULL);
   Select(pFaxText);

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::FindLocation(CRect& objrect)
{
   CObList* pObList = GetDocument()->GetObjects();
   POSITION posObj;
   CRect rcMove=objrect;
   double angle=0;
   CPoint p;
   int r=5;
   BOOL bFoundPlace;
   CRect clientrect;
   CPoint ptCR;

   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;

   ptCR.x=clientrect.left+ihalfwidth;
   ptCR.y=clientrect.top-ihalfheight;
   int iobjwidth = objrect.right-objrect.left;
   int iobjheight = objrect.top-objrect.bottom;
   int iLongestR=max(ihalfheight,ihalfwidth);

   BOOL bCont=TRUE;
//   CClientDC dc(this);                 //testing
//   OnPrepareDC(&dc,NULL);              //testing

   if (iobjwidth>ihalfwidth*2 || iobjheight>ihalfheight*2 ) {      //object is larger than client area

//       rcMove.top=ptCR.y;
//       rcMove.left=ptCR.x;

       rcMove.top=ptCR.y + iobjheight/2;
       rcMove.left=ptCR.x - iobjwidth/2;

       if( rcMove.top > clientrect.top )
                rcMove.top=clientrect.top;

       if( rcMove.left < clientrect.left )
                rcMove.left=clientrect.left;

           rcMove.right=rcMove.left+iobjwidth;
           rcMove.bottom=rcMove.top-iobjheight;
   }
   else {
      while (bCont) {
        bFoundPlace=TRUE;
            posObj = pObList->GetHeadPosition();
            while (posObj != NULL) {
                CDrawObj* pObj = (CDrawObj*)pObList->GetNext(posObj);
                if (pObj->Intersects(rcMove,TRUE)) {
                   bFoundPlace=FALSE;
                       break;
                    }
        }

            if (bFoundPlace)
              break;

        while(1) {
                p.x= (int)(r * cos(angle));
                p.y= (int)(r * sin(angle));
                if (angle<355)
                       angle += 10;
                else {
                       if (r<iLongestR) {
                          r+= 15;
                          angle=0;
                            }
                        else {
                                p.x=p.y=0;
                                bCont=FALSE;
                                break;
                            }
             }

                 if ( ((ptCR.x+p.x-.5*iobjwidth) > clientrect.left) &&
                    ((ptCR.x+p.x+.5*iobjwidth) < clientrect.right) &&
                        ((ptCR.y+p.y-.5*iobjheight) > clientrect.bottom) &&
                        ((ptCR.y+p.y+.5*iobjheight) < clientrect.top) )
                      break;
            }

        rcMove = objrect + p;

//      dc.Rectangle(rcMove);   //testing
      }
   }
   objrect=rcMove;
}



//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipName()
{
   CreateFaxProp(IDS_PROP_RP_NAME);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipFaxNum()
{
   CreateFaxProp(IDS_PROP_RP_FXNO);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCompany()
{
   CreateFaxProp(IDS_PROP_RP_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipAddress()
{
   CreateFaxProp(IDS_PROP_RP_ADDR);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCity()
{
   CreateFaxProp(IDS_PROP_RP_CITY);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipState()
{
   CreateFaxProp(IDS_PROP_RP_STAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipPOBox()
{
   CreateFaxProp(IDS_PROP_RP_POBX);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipZipCode()
{
   CreateFaxProp(IDS_PROP_RP_ZIPC);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCountry()
{
   CreateFaxProp(IDS_PROP_RP_CTRY);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipTitle()
{
   CreateFaxProp(IDS_PROP_RP_TITL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipDept()
{
   CreateFaxProp(IDS_PROP_RP_DEPT);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOfficeLoc()
{
   CreateFaxProp(IDS_PROP_RP_OFFI);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipHMTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_HTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOFTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_OTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipToList()
{
   CreateFaxProp(IDS_PROP_RP_TOLS);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCCList()
{
   CreateFaxProp(IDS_PROP_RP_CCLS);
}

//--------------------------------------------------------------------------
// *_*_*_   SENDER WM_COMMAND METHODS
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderName()
{
    CreateFaxProp(IDS_PROP_SN_NAME);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderFaxNum()
{
   CreateFaxProp(IDS_PROP_SN_FXNO);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderCompany()
{
   CreateFaxProp(IDS_PROP_SN_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderAddress()
{
   CreateFaxProp(IDS_PROP_SN_ADDR);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderTitle()
{
   CreateFaxProp(IDS_PROP_SN_TITL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderDept()
{
   CreateFaxProp(IDS_PROP_SN_DEPT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOfficeLoc()
{
   CreateFaxProp(IDS_PROP_SN_OFFI);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderHMTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_HTEL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOFTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_OTEL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderEmail()
{
   CreateFaxProp(IDS_PROP_SN_EMAL);
}

// *_*_*_   MESSAGE WM_COMMAND METHODS

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgSubject()
{
   CreateFaxProp(IDS_PROP_MS_SUBJ);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgTimeSent()
{
   CreateFaxProp(IDS_PROP_MS_TSNT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgNumPages()
{
   CreateFaxProp(IDS_PROP_MS_NOPG);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgAttach()
{
   CreateFaxProp(IDS_PROP_MS_NOAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgBillCode()
{
   CreateFaxProp(IDS_PROP_MS_BCOD);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgFaxText()
{
   CreateFaxText();
}

//--------------------------------------------------------------------------
void CDrawView::OnMapiMsgNote()
{
   CreateFaxProp(IDS_PROP_MS_NOTE);
}

//--------------------------------------------------------------------------
void CDrawView::OnDrawSelect()
{
    CDrawTool::c_drawShape = select;
}

void CDrawView::OnDrawRoundRect()
{
    CDrawTool::c_drawShape = roundRect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawRect()
{
    CDrawTool::c_drawShape = rect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawText()
{
    CDrawTool::c_drawShape = text;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawLine()
{
    CDrawTool::c_drawShape = line;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawEllipse()
{
    CDrawTool::c_drawShape = ellipse;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawPolygon()
{
    //The Window's 95 way: Bring up a dialog box with directions the FIRST TIME ONLY!!! How unconventional!
    //
    // Fix for BUG 39665 by a-juliar, 05-24-96.  We have modified the resource string
    // for IDS_INFO_DRAWPOLY to give the same directions that Word 6.0 gives.  But I
    // really dislike the dialog box that appeared only the first time you ran the app.
    // PUT THE DIRECTIONS ON THE STATUS BAR where they belong!
    //

    CString sz ;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

    sz.LoadString( IDS_INFO_DRAWPOLY );
    pFrame->m_wndStatusBar.SetPaneText(0,sz);
    CDrawTool::c_drawShape = poly;
}


//----------------------------------------------------------------------------
void CDrawView::OnSelEndOKFontSize()
{
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontName(CObList* pObList/*=NULL*/, CDrawText* p /*=NULL*/)
{
    CString szName;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   CComboBox& cbox = pFrame->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,szName);
   else
       cbox.GetWindowText(szName);

   LOGFONT lf;
   if (pText) {   //change object in edit
       lstrcpyn(pText->m_logfont.lfFaceName,szName,LF_FACESIZE);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
         CDrawText* pTextObj=(CDrawText*)pObj;
         lstrcpyn(pTextObj->m_logfont.lfFaceName,szName,LF_FACESIZE);
         lf.lfWeight=pTextObj->m_logfont.lfWeight;
         lf.lfItalic=pTextObj->m_logfont.lfItalic;
             pTextObj->ChgLogfont(lf);
      }
   }
   ::SetFocus(m_hWnd);
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontName()
{
   OnSelChangeFontName();
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontSize()
{
   OnSelChangeFontSize();
}


//----------------------------------------------------------------------------
void CDrawView::OnEditChangeFont()
{
   m_bFontChg=TRUE;
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontSize(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
    CString sz;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   CComboBox& cbox = pFrame->m_StyleBar.m_cboxFontSize;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,sz);
   else
       cbox.GetWindowText(sz);
   WORD wPointSize = (WORD)_ttoi(sz);

   if (wPointSize <= 0 || wPointSize > 5000) {
      UpdateStyleBar(pob,pText);
      return;
   }

   CClientDC dc(NULL);

   LOGFONT lf;
   if (pText) {   //change object in edit
       if (GetPointSize(*pText)==wPointSize)
              return;
       pText->m_logfont.lfHeight=  -MulDiv(wPointSize,100,72);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->m_logfont.lfWidth=0;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
             CDrawText* pTextObj=(CDrawText*)pObj;
             if (GetPointSize(*pTextObj)!=wPointSize) {
            lf.lfWeight=pTextObj->m_logfont.lfWeight;
            lf.lfItalic=pTextObj->m_logfont.lfItalic;
            pTextObj->m_logfont.lfHeight= -MulDiv(wPointSize,100,72);
                pTextObj->m_logfont.lfWidth=0;
                pTextObj->ChgLogfont(lf);
                pTextObj->FitEditWnd(this);
             }
      }
   }
   ::SetFocus(m_hWnd);
}


//----------------------------------------------------------------------------
void CDrawView::OnFont()
{
    LOGFONT lf ;
    UINT id, style;
    int i;
    int image;
    CString sz;
    CClientDC dc(NULL);

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

    memset(&lf,0,sizeof(LOGFONT)) ;

    pFrame->m_StyleBar.m_cboxFontName.GetWindowText(sz);
    if (sz.GetLength()>0){
        lstrcpyn( lf.lfFaceName, sz, LF_FACESIZE);
    }
    pFrame->m_StyleBar.m_cboxFontSize.GetWindowText(sz);
    if (sz.GetLength()>0) {
        WORD wPointSize = (WORD)_ttoi(sz);
        lf.lfHeight = -( (wPointSize * dc.GetDeviceCaps(LOGPIXELSY))/72 );
    }
    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfWeight = FW_BOLD;
    }
    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfItalic = TRUE ;
    }
    i = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    pFrame->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfUnderline = TRUE ;
    }

    CMyFontDialog dlgFont(
        (LPLOGFONT)&lf,
        CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS | CF_NOVERTFONTS,
        NULL,
        this
        ) ;
    LOGFONT dlf;

    if (dlgFont.DoModal()==IDOK) {

        //
        // steveke wants the font change Undoable.
        // We are going to assume that THE FONT HAS CHANGED.
        // If it hasn't, UNDO will do nothing.
        //

        if (m_pObjInEdit) {   //change object in edit

            m_pObjInEdit->m_bUndoFont = TRUE ;
            m_pObjInEdit->m_bUndoAlignment = FALSE ;
            m_pObjInEdit->m_bUndoTextChange = FALSE ;
            memcpy (
                & m_pObjInEdit->m_previousLogfontForUndo,
                & m_pObjInEdit->m_logfont,
                sizeof(LOGFONT)
                );
            memset(&m_pObjInEdit->m_logfont,0,sizeof(LOGFONT)) ;

            lstrcpyn(m_pObjInEdit->m_logfont.lfFaceName,dlgFont.GetFaceName(),LF_FACESIZE) ;

            m_pObjInEdit->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);

            dlf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
            dlf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;

            m_pObjInEdit->m_logfont.lfWeight=dlgFont.GetWeight();
            m_pObjInEdit->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
            m_pObjInEdit->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;

            m_pObjInEdit->ChgLogfont(dlf);

            m_pObjInEdit->m_pEdit->SetFocus();
            return;
        }

        SaveStateForUndo();

        CDrawObj* pObj;
        CDrawText* pTextObj;
        POSITION pos = m_selection.GetHeadPosition();
        while (pos != NULL) 
        {
            pObj=(CDrawObj*)m_selection.GetNext(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
            {
                pTextObj=(CDrawText*)pObj;
                memset(&pTextObj->m_logfont,0,sizeof(LOGFONT)) ;
                lstrcpyn(pTextObj->m_logfont.lfFaceName,dlgFont.GetFaceName(),LF_FACESIZE) ;
                pTextObj->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);
                dlf.lfWeight=pTextObj->m_logfont.lfWeight;
                dlf.lfItalic=pTextObj->m_logfont.lfItalic;
                pTextObj->m_logfont.lfWeight=dlgFont.GetWeight();
                pTextObj->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
                pTextObj->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;
                pTextObj->ChgLogfont(dlf);
            }
        }
    }

}



//----------------------------------------------------------------------------
void CDrawView::OnStyleBold()
{
   LOGFONT lf;
   UINT nID, nStyle;
   int iImage;
   LONG lWeight;
   int index;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   index = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   pFrame->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   if (nStyle&TBBS_CHECKED)   /////// BUG FIX!  by a-juliar
      lWeight=FW_BOLD;
   else
      lWeight=FW_REGULAR;


   if (m_pObjInEdit) {   //change object in edit
       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;


       lf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
       lf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;
       m_pObjInEdit->m_logfont.lfWeight=lWeight;
       m_pObjInEdit->ChgLogfont(lf, FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) 
   {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
        lf.lfWeight=((CDrawText*)pObj)->m_logfont.lfWeight;
        lf.lfItalic=((CDrawText*)pObj)->m_logfont.lfItalic;
        ((CDrawText*)pObj)->m_logfont.lfWeight=lWeight;
        ((CDrawText*)pObj)->ChgLogfont(lf, FALSE);

     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::OnStyleItalic()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bItalic;
   int index;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   index = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   pFrame->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   ///////bItalic = !(nStyle & TBBS_CHECKED);   /// BUG FIX! This is backwards!!!  a-juliar
   bItalic = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfItalic=bItalic != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfItalic=bItalic != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}


//----------------------------------------------------------------------------
void CDrawView::OnStyleUnderline()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bUnderline;
   int index;

    CMainFrame* pFrame = GetFrame();
    if(!pFrame)
    {
        ASSERT(FALSE);
        return;
    }

   index = pFrame->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   pFrame->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   bUnderline = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfUnderline=bUnderline != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfUnderline=bUnderline != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::ChgTextAlignment(LONG lstyle)
{
    if (m_pObjInEdit) 
    {
        m_pObjInEdit->ChgAlignment(this, lstyle);
        m_pObjInEdit->m_pEdit->ShowWindow(SW_NORMAL);
        m_pObjInEdit->Invalidate();
        GetDocument()->SetModifiedFlag();          //set document dirty
        return;
    }
    SaveStateForUndo();
    CDrawObj* pObj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) 
    {
        pObj=(CDrawObj*)m_selection.GetNext(pos);
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
        {
            ((CDrawText*)pObj)->ChgAlignment(this, lstyle);
            GetDocument()->SetModifiedFlag();         //set document dirty
            pObj->Invalidate();
        }
   }
}


void CDrawView::OnStyleLeft()
{
   ChgTextAlignment(DT_LEFT);
}


void CDrawView::OnStyleCentered()
{
   ChgTextAlignment(DT_CENTER);
}


void CDrawView::OnStyleRight()
{
   ChgTextAlignment(DT_RIGHT);
}

#ifdef GRID
void CDrawView::OnSnapToGrid()
{
    m_bSnapToGrid=!m_bSnapToGrid;
}
#endif

#ifdef GRID
void CDrawView::OnGridSettings()
{
   CGridSettingsDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   if (dlg.m_bRBSmall)
      m_iGridSize=GRID_SMALL;
   else
      if (dlg.m_bRBMedium)
         m_iGridSize=GRID_MEDIUM;
      else
         m_iGridSize=GRID_LARGE;

   m_bGrid=dlg.m_bCBViewGrid;
   m_bSnapToGrid=dlg.m_bCBSnapToGrid;

   Invalidate(FALSE);

   m_pDocument->SetModifiedFlag();
}
#endif


//--------------------------------------------------------------------------
void CDrawView::NormalizeObjs()
{
    CDrawObj* pobj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       NormalizeRect(pobj->m_position);
    }
}


//--------------------------------------------------------------------------
void CDrawView::NormalizeRect(CRect& rc)
{
        int nTemp;
        if (rc.left > rc.right) {
                nTemp = rc.left;
                rc.left = rc.right;
                rc.right = nTemp;
        }
        if (rc.top < rc.bottom) {
                nTemp = rc.top;
                rc.top = rc.bottom;
                rc.bottom = nTemp;
        }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignLeft()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ileftmost = GetDocument()->GetSize().cx / 2;

        NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left < ileftmost)
           ileftmost=pobj->m_position.left;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left != ileftmost) {
          rc = pobj->m_position;
          rc.right = ileftmost + (pobj->m_position.right - pobj->m_position.left);
          rc.left = ileftmost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignRight()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int irightmost = GetDocument()->GetSize().cx / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) 
    {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right > irightmost)
           irightmost=pobj->m_position.right;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) 
    {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right != irightmost) 
       {
          rc = pobj->m_position;
          rc.left = irightmost - (pobj->m_position.right - pobj->m_position.left);
          rc.right = irightmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignTop()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int itopmost = GetDocument()->GetSize().cy / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top > itopmost)
           itopmost=pobj->m_position.top;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top != itopmost) {
          rc = pobj->m_position;
          rc.bottom = itopmost - (pobj->m_position.top - pobj->m_position.bottom);
          rc.top = itopmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignBottom()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ibottommost = GetDocument()->GetSize().cy / 2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom < ibottommost)
           ibottommost=pobj->m_position.bottom;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom != ibottommost) {
          rc = pobj->m_position;
          rc.top = ibottommost + (pobj->m_position.top - pobj->m_position.bottom);
          rc.bottom = ibottommost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignHorzCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveY;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveY = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.bottom += iMoveY;
          rc.top += iMoveY;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignVertCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveX;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveX = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.left += iMoveX;
          rc.right += iMoveX;
          pobj->MoveTo(rc, this);
       }
    }
}

//-------------------------------------------------------------------------------
CSortedObList& CSortedObList::operator=(CObList& list)
{
    POSITION pos = list.GetHeadPosition();
    while (pos != NULL)
       AddHead(list.GetNext(pos));
    return *this;
}


//-------------------------------------------------------------------------------
inline void CSortedObList::swap(INT_PTR i, INT_PTR j)
{
    CObject* temp;
    temp = GetAt(FindIndex(i));
    SetAt(FindIndex(i),GetAt(FindIndex(j)));
    SetAt(FindIndex(j),temp);
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToLeft()
{
   CDrawObj* pi,*pi1;

   for (INT_PTR top=GetCount()-1;top>0;top--) {   //simple bubble sort
      for (INT_PTR i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.left < pi->m_position.left )
            swap(i+1,i);
                 else
            if (pi1->m_position.left == pi->m_position.left &&
                  pi1->m_position.right < pi->m_position.right )
               swap(i+1,i);
     }
   }
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToBottom()
{
   CDrawObj* pi,*pi1;

   for (INT_PTR top=GetCount()-1;top>0;top--) {   //simple bubble sort
      for (INT_PTR i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.bottom < pi->m_position.bottom )
            swap(i+1,i);
                 else
            if (pi1->m_position.bottom == pi->m_position.bottom &&
                  pi1->m_position.top < pi->m_position.top )
               swap(i+1,i);
     }
   }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;
    CDrawObj *pi1;
    CRect rc;
    int iObjLength=0;
    double iSpace=0;
        double drop_loc;
        long ob_width;
    CSortedObList sol;


    NormalizeObjs();

    SaveStateForUndo();

    INT_PTR iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjLength)) / (iCount-1);
                drop_loc = ((double)rcL.right) + iSpace;
                }
    else
        {           //evenly space middles
                drop_loc = ((double)(rcL.left + rcL.right))/2;
        iSpace = (((double)(rcR.left + rcR.right))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_width = rc.right-rc.left;
                if (iObjLength < iSpan)
                        {
                        rc.left = (long)(drop_loc + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += (ob_width + iSpace);
                        }
       else
                {
                        rc.left = (long)(drop_loc - ob_width/2 + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;
    int iObjHeight=0;
    double iSpace=0;
        double drop_loc;
        long ob_height;
    CSortedObList sol;
    CRect rc;
    CDrawObj *pi1;


    NormalizeObjs();

    SaveStateForUndo();

    INT_PTR iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjHeight)) / (iCount-1);
                drop_loc = ((double)rcB.top) + iSpace;
                }
    else
        {                      //evenly space middles
                drop_loc = ((double)(rcB.bottom + rcB.top))/2;
        iSpace = (((double)(rcT.bottom + rcT.top))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_height = rc.top - rc.bottom;

                if (iObjHeight < iSpan)
                        {
                        rc.bottom = (long)(drop_loc + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += (ob_height + iSpace);
                        }
                else
                        {
                        rc.bottom = (long)(drop_loc - ob_height/2 + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
        }
}


#ifdef FUBAR
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjLength=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjLength) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcR.left + (rcR.right-rcR.left)/2)
                  - (rcL.left + (rcL.right-rcL.left)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjLength < iSpan) {
          rc.left = pi->m_position.right + iSpace;
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       else {
          int middleL = pi->m_position.left + ((pi->m_position.right-pi->m_position.left)/2);
          rc.left = (middleL+iSpace)-((pi1->m_position.right-pi1->m_position.left)/2);
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjHeight=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjHeight) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcT.bottom + (rcT.top-rcT.bottom)/2)
                  - (rcB.bottom + (rcB.top-rcB.bottom)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjHeight < iSpan) {
          rc.bottom = pi->m_position.top + iSpace;
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       else {
          int middleL = pi->m_position.bottom + ((pi->m_position.top-pi->m_position.bottom)/2);
          rc.bottom = (middleL+iSpace)-((pi1->m_position.top-pi1->m_position.bottom)/2);
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       pi1->MoveTo(rc, this);
    }
}
#endif


//--------------------------------------------------------------------------
void CDrawView::OnCenterWidth()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;
    }

    int iSpace = rc.left + ((rc.right - rc.left) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.left += -iSpace;
       rc.right += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnCenterHeight()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;   //requires Y increase downward
    }

    NormalizeRect(rc);
    NormalizeObjs();

    int iSpace = rc.bottom + ((rc.top - rc.bottom) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.bottom += -iSpace;
       rc.top += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


void CDrawView::OnUpdateDrawEllipse(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == ellipse);
}


void CDrawView::OnUpdateDrawLine(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == line);
}

void CDrawView::OnUpdateDrawRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == rect);
}

void CDrawView::OnUpdateDrawText(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == text);
}

void CDrawView::OnUpdateDrawRoundRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == roundRect);
}

void CDrawView::OnUpdateDrawSelect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == select);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdatePosStatusBar(CCmdUI* pCmdUI)
{
    pCmdUI->Enable();
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateFaxText(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateSingleSelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() == 1);
}

void CDrawView::OnUpdateMoreThanOne(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 1);
}


void CDrawView::OnUpdateMove(CCmdUI* pCmdUI)
{
#if 0
   pCmdUI->Enable(m_selection.GetCount() == 1
         && GetDocument()->GetObjects()->GetCount()>1);
#endif

   //
   // BUG FIX for 33738, by a-juliar, 5-20-96
   //

      INT_PTR Count = m_selection.GetCount() ;
      pCmdUI->Enable( Count > 0
             && GetDocument()->GetObjects()->GetCount() > Count ) ;
}


#ifdef GRID
void CDrawView::OnUpdateSnapToGrid(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(m_bSnapToGrid);
}
#endif

void CDrawView::OnUpdateAlign(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() > 1);
}

void CDrawView::OnUpdateAlign3(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 3);
}


#ifdef GRID
void CDrawView::OnUpdateGridSettings(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(1);
}
#endif


//-------------------------------------------------------------------------------
void CDrawView::OnEditSelectAll()
{
    CObList* pObList = GetDocument()->GetObjects();
    POSITION pos = pObList->GetHeadPosition();
    while (pos != NULL)
        Select((CDrawObj*)pObList->GetNext(pos));

    UpdateStatusBar();
    UpdateStyleBar();
}

//-------------------------------------------------------------------------------
void CDrawView::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->GetObjects()->GetCount() != 0);
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditUndo()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit && m_pObjInEdit->CanUndo()){
        m_pObjInEdit->OnEditUndo() ;
        return ;
    }
    if(m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        m_pObjInEdit->HideEditWnd( this, FALSE );
    }
    m_selection.RemoveAll();
    GetDocument()->SwapListsForUndo();
    InvalidateRect( NULL );
  ///  GetDocument()->UpdateAllViews();
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditClear()
{
    if (m_selection.GetCount() > 0){
       SaveStateForUndo();
    }
    // update all the views before the selection goes away
    GetDocument()->UpdateAllViews(NULL, HINT_DELETE_SELECTION, &m_selection);
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);

    // now remove the selection from the document
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
           GetDocument()->Remove(pObj);
       GetDocument()->SetModifiedFlag();          //set document dirty
    }
    m_selection.RemoveAll();

    SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));

    UpdateStatusBar();
}


//----------------------------------------------------------------------------------
void CDrawView::UpdateStatusBar()
{
    CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();
    if (!pFrame)
       return;

    if (CDrawView::GetView()->m_selection.GetCount()!=1) {
       pFrame->m_wndStatusBar.SetPaneText(1,_T(""));
       pFrame->m_wndStatusBar.SetPaneText(2,_T(""));
       return;
        }

    POSITION pos = m_selection.GetHeadPosition();
    if (pos==NULL)
           return;

    CDrawObj* pObj=(CDrawObj*)m_selection.GetNext(pos);

    CRect rc = pObj->m_position;
        CSize cs=CDrawDoc::GetDoc()->GetSize();

    CDrawView::GetView()->NormalizeRect(rc);
    rc.left+= cs.cx/2;
    rc.right+= cs.cx/2;
    rc.top = cs.cy/2-rc.top;
    rc.bottom = cs.cy/2 - rc.bottom;

    TCHAR szT1[] = _T(" %i,%i");
    TCHAR szT2[] = _T(" %ix%i");
    TCHAR sz[50];
    wsprintf(sz,szT1,rc.left,rc.top);
    pFrame->m_wndStatusBar.SetPaneText(1,sz);
    wsprintf(sz,szT2,rc.right-rc.left,rc.bottom-rc.top);
    pFrame->m_wndStatusBar.SetPaneText(2,sz);
}

void CDrawView::SaveStateForUndo()
{
    m_bCanUndo = TRUE ;
    CDrawDoc * pDoc = GetDocument() ;
    CObList * pPrevious = &pDoc->m_previousStateForUndo ;
    FreeObjectsMemory( pPrevious );
    pPrevious->RemoveAll();
    pDoc->CloneObjectsForUndo();
}

void CDrawView::FreeObjectsMemory( CObList * pObList )
{
    POSITION pos = pObList->GetHeadPosition();
    while( pos != NULL ){
        CObject * pObj = pObList->GetNext( pos ) ;
        CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
        if( pWhatClass == RUNTIME_CLASS( CDrawOleObj )){
            COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
            if (pItem)  { //remove client item from document
                pItem->Release(OLECLOSE_NOSAVE);
                pItem->InternalRelease();
            }
            delete pObj ;
        }
        else {
            delete pObj ;
        }
    }
}

void CDrawView::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( m_bCanUndo );
}

void CDrawView::OnUpdateAnySelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!m_selection.IsEmpty());
}

void CDrawView::OnUpdateDrawPolygon(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == poly);
}

void CDrawView::OnSize(UINT nType, int cx, int cy)
{
    CScrollView::OnSize(nType, cx, cy);
    UpdateActiveItem();
}

void CDrawView::OnViewGridLines()
{
    m_bGridLines = !m_bGridLines;
    Invalidate(FALSE);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewGridLines(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bGridLines);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateFont(CCmdUI* pCmdUI)
{
   if (m_pObjInEdit) 
   {
      pCmdUI->Enable(TRUE);
      return;
   }

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL)
   {
     if (((CDrawObj*)m_selection.GetNext(pos))->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
        pCmdUI->Enable(TRUE);
        return;
     }
   }

   pCmdUI->Enable(FALSE);
}


//--------------------------------------------------------------------------
int CDrawView::GetPointSize(CDrawText& TextObj)
{
   return abs(MulDiv(TextObj.m_logfont.lfHeight,72,100));

/*
   TEXTMETRIC tm;
   CClientDC dc(TextObj.m_pEdit);
   dc.SelectObject(TextObj.m_pEdit->GetFont());
   dc.GetTextMetrics(&tm);
   int pointsize = MulDiv( (tm.tmHeight-tm.tmInternalLeading),72,dc.GetDeviceCaps(LOGPIXELSY) );
   return pointsize;
*/
}


BOOL CDrawView::OnEraseBkgnd(CDC* pDC)
{
    return TRUE;
}


void CDrawView::OnObjectMoveBack()
{
   if(m_selection.IsEmpty())
   {
       return;
   }
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList*  pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetHeadPosition()) 
   {
        POSITION posPrev = pos;
        pObjects->GetPrev(posPrev);
        pObjects->RemoveAt(pos);
        pObjects->InsertBefore(posPrev, pObj);
        pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveForward()
{
   if(m_selection.IsEmpty())
   {
       return;
   }
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList* pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetTailPosition()) {
          POSITION posNext = pos;
          pObjects->GetNext(posNext);
          pObjects->RemoveAt(pos);
          pObjects->InsertAfter(posNext, pObj);
          pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToBack()
{
   SaveStateForUndo();
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   POSITION s_pos = m_selection.GetTailPosition();
   while( s_pos != NULL ){
       CDrawObj* pObj = (CDrawObj*)m_selection.GetPrev( s_pos ) ;
       POSITION o_pos = pObjects->Find(pObj);
       ASSERT(o_pos != NULL);
       pObjects->RemoveAt(o_pos);
       pObjects->AddHead(pObj);
       pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToFront()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        return;
    }

    SaveStateForUndo();

    CDrawDoc* pDoc = GetDocument();
    CObList* pObjects = pDoc->GetObjects();
    POSITION s_pos = m_selection.GetHeadPosition();
    while( s_pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext( s_pos ) ;
        POSITION o_pos = pObjects->Find(pObj);
        ASSERT(o_pos != NULL);
        pObjects->RemoveAt(o_pos);
        pObjects->AddTail(pObj);
        pObj->Invalidate();
    }
    pDoc->SetModifiedFlag();
}


void CDrawView::OnEditCopy()
{
   ASSERT_VALID(this);
   ASSERT(m_cfDraw != NULL);

   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) 
   {   
       //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_COPY,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   if(m_selection.IsEmpty())
   {
       return;
   }

   // Create a shared file and associate a CArchive with it
   CSharedFile file;
   CArchive ar(&file, CArchive::store);

   // Serialize selected objects to the archive
   m_selection.Serialize(ar);
   ar.Close();

   COleDataSource* pDataSource = NULL;

   CDrawOleObj* pDrawOle = (CDrawOleObj*)m_selection.GetHead();
   TRY 
   {
        pDataSource = new COleDataSource;
        // put on local format instead of or in addation to
        pDataSource->CacheGlobalData(m_cfDraw, file.Detach());

        // if only one item and it is a COleClientItem then also
        // paste in that format
        if (m_selection.GetCount() == 1 && pDrawOle->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
        {
            pDrawOle->m_pClientItem->GetClipboardData(pDataSource, FALSE);
        }
        pDataSource->SetClipboard();
   }
   CATCH_ALL(e)
   {
        delete pDataSource;
        THROW_LAST();
   }
   END_CATCH_ALL
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    // WRONG! don't enable COPY just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit){
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        if( nStartChar < nEndChar ){
            pCmdUI->Enable( TRUE );
            return;
        }
    }
    pCmdUI->Enable(!m_selection.IsEmpty());

}


//--------------------------------------------------------------------------
void CDrawView::OnEditCut()
{
   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_CUT,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   OnEditCopy();
   OnEditClear();
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCut(CCmdUI* pCmdUI)
{
    // WRONG! don't enable CUT just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit)
    {
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        pCmdUI->Enable( nStartChar < nEndChar );
        return;
    }
    pCmdUI->Enable(!m_selection.IsEmpty());
}


//--------------------------------------------------------------------------

void CDrawView::OnEditPaste()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        m_pObjInEdit->m_pEdit->SendMessage(WM_PASTE,0,0L);
        m_pObjInEdit->m_bUndoAlignment = FALSE ;
        m_pObjInEdit->m_bUndoFont = FALSE ;
        m_pObjInEdit->m_bUndoTextChange = TRUE ;
        return;
    }

    COleDataObject dataObject;
    dataObject.AttachClipboard();

    // invalidate current selection since it will be deselected
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
    m_selection.RemoveAll();
    if (dataObject.IsDataAvailable(m_cfDraw)) {
        PasteNative(dataObject);
        //
        // Adjust position of all items in m_selection and add them to the document
        //
        POSITION pos = m_selection.GetHeadPosition();

        while (pos != NULL) {
            CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos) ;
            CRect rect = pObj->m_position;
            rect.top-=10;
            rect.bottom-=10;
            rect.left+=10;
            rect.right+=10;
            pObj->MoveTo( rect, this );
            GetDocument()->Add(pObj);
        }
        OnEditCopy();   /// Fix for bug 44896. Position adjustments above now are in clipboard.
                        /// so that next paste will be offset just a little bit more. 6-19-96
    }
    else {
        PasteEmbedded(dataObject);
    }

    GetDocument()->SetModifiedFlag();

    // invalidate new pasted stuff
    GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_SELECTION, &m_selection);
}

//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
    // Revised by a-juliar, 9-18-96.  Don't allow pastiing a second note rect into the document.

    if (m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        pCmdUI->Enable( ::IsClipboardFormatAvailable(CF_TEXT)); // a-juliar, 9-5-96
        return ;
    }

    //
    // determine if private or standard OLE formats are on the clipboard
    //

    COleDataObject dataObject;
    BOOL bAvailable ;
    BOOL bEnable = dataObject.AttachClipboard() &&
        ((bAvailable = dataObject.IsDataAvailable(m_cfDraw)) ||
        COleClientItem::CanCreateFromData(&dataObject));

    // enable command based on availability
    if( !bEnable ) 
    {
        pCmdUI->Enable(FALSE);
        return ;
    }
    if( !bAvailable ) 
    { 
        // Clipboard has a standard OLE format on it.
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // Enable PASTE unless both of the following hold:
    // 1. Document already has a NOTE field
    // 2. Clipboard has a note field.
    //
    BOOL bDocAlreadyHasNoteRect = FALSE ;
    POSITION pos;
    CFaxProp* pfaxprop ;
    pos = GetDocument()->m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CDrawObj* pObj = (CDrawObj*) GetDocument()->m_objects.GetNext(pos);
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
        {
            pfaxprop = (CFaxProp *)pObj;
            if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
            {
                 bDocAlreadyHasNoteRect = TRUE ;
            }
        }
    }
    if( !bDocAlreadyHasNoteRect )
    {
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // See if there is a NOTE on the clipboard
    //

    CObList ClipboardList ;
    TRY
    {
        CFile* pFile = dataObject.GetFileData(m_cfDraw);
        if (pFile == NULL)
        {
            pCmdUI->Enable(FALSE);
            return;
        }
        CArchive ar(pFile, CArchive::load);
        ar.m_pDocument = GetDocument(); // set back-pointer in archive
        ClipboardList.Serialize(ar);
        ar.Close();
        delete pFile;
        //
        // Traverse the list ClipboardList to look for NOTE and free memory.
        //
        pos = ClipboardList.GetHeadPosition();
        while( pos != NULL )
        {
            CObject * pObj = ClipboardList.GetNext( pos ) ;
            CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
            if( pWhatClass == RUNTIME_CLASS( CFaxProp ))
            {
                pfaxprop = (CFaxProp *)pObj;
                if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
                {
                    bEnable = FALSE;
                }
                delete pObj ;
            }
            else if( pWhatClass == RUNTIME_CLASS( CDrawOleObj ))
            {
                COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                if (pItem)  
                { 
                    //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    ////GetDocument->RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem); ///
                    pItem->InternalRelease();
                }
                delete pObj ;
            }
            else 
            {
                delete pObj ;
            }
        }
        ClipboardList.RemoveAll();
    }
    CATCH_ALL(e)
    {
        pCmdUI->Enable( FALSE );
        return ;
    }
    END_CATCH_ALL
    pCmdUI->Enable(bEnable);
}


//--------------------------------------------------------------------------
void CDrawView::OnFilePrint()
{
   m_selection.RemoveAll();
   if ( ((CDrawApp*)AfxGetApp())->m_dwSesID!=0) {
   ///////   Render();
          return;
   }


   CScrollView::OnFilePrint();

   //GetDocument()->ComputePageSize();
}


//--------------------------------------------------------------------------
#if 0
void CDrawView::Render()
{
   CString strTemp;
   CDrawDoc *pdoc = GetDocument();
   HANDLE hprt;
   LONG   dev_size;
   DEVMODE *dev_buf = NULL;

   // setup the printing DC
   TRACE(TEXT("AWCPE:  CPEVW.CPP.Render() called\n"));

   if( !OpenPrinter( (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice, &hprt, NULL ) )
          {
      TRACE(TEXT("CPEVW.Render: unable to open printer\n"));
      throw "render failed";
          }


   dev_size =
                DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                NULL,
                                                    NULL,
                                                    0 );

        dev_buf = (DEVMODE *)new BYTE[ dev_size ];

        if( (dev_size == 0)||(dev_buf == NULL) )
          {
          ClosePrinter( hprt );
      TRACE(TEXT("CPEVW.Render: unable to make dev_buf\n"));
      throw "render failed";
          }


        DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                dev_buf,
                                            NULL,
                                            DM_OUT_BUFFER );

        ClosePrinter( hprt );


    dev_buf->dmPaperSize   = pdoc->m_wPaperSize;
    dev_buf->dmOrientation = pdoc->m_wOrientation;

        // use doc scale only if printer supports scaling
        if( dev_buf->dmFields & DM_SCALE        )
        dev_buf->dmScale   = pdoc->m_wScale;
        else
        dev_buf->dmScale   = 100;


   CDC dcPrint;
   if( dcPrint.CreateDC(_T("winspool"),GetApp()->m_szRenderDevice,NULL,
                (void *)dev_buf )==0)
        {
                delete [] dev_buf;

      TRACE(TEXT("CPEVW.Render: unable to create a printer DC\n"));
      throw "render failed";
        }



        delete [] dev_buf;

        // reset note position
        theApp.reset_note();


   dcPrint.m_bPrinting=TRUE;

   DOCINFO docInfo;
   memset(&docInfo, 0, sizeof(DOCINFO));
   docInfo.cbSize = sizeof(DOCINFO);
   docInfo.lpszDocName = GetDocument()->GetTitle();
   docInfo.lpszOutput = NULL;

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartDoc() called\n"));
   if (dcPrint.StartDoc(&docInfo) == SP_ERROR) {
      TRACE(TEXT("CPEVW.Render: unable to StartDoc\n"));
      throw "render failed";
   }

   OnPrepareDC(&dcPrint,NULL);

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartPage() called\n"));
   if (dcPrint.StartPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
      throw "render failed";
   }


   // set up for note pages
   //
   // NOTE TO RAND:
   //   The extra note must be created BEFORE OnPrint so that
   //   any page-no objects can properly guess how many pages
   //   are left after the note object has consumed some of the
   //   note text. page-no objects are sorted to be after note
   //   objects in the objects list so they will be drawn after
   //   the note object has drawn. Setting of theApp.m_last_note_box
   //   has been done before this point so that the extranote
   //   will be created with the proper font, etc (bug fix for
   //   3647).
   //
   if( theApp.m_note_wasread )
                make_extranote( &dcPrint );

   OnPrint(&dcPrint, NULL);



   // get rid of surprise dialogs
   pdoc->SetModifiedFlag( FALSE );

   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndPage() called\n"));
   if (dcPrint.EndPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
      throw "render failed";
   }


        // see if we need extra note pages
        if( theApp.m_note_wasread )
                {
                if( theApp.m_extra_notepage != NULL )
                        {
                        // print page sized chunks untill note is consumed
                        while( theApp.more_note() )
                                {
                                if( dcPrint.StartPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
                                        throw "render failed";
                                        }

                                theApp.m_extra_notepage->Draw( &dcPrint, this );

                                if( dcPrint.EndPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
                                        throw "render failed";
                                        }
                                }

                        delete theApp.m_extra_notepage;
                        theApp.m_extra_notepage = NULL;
                        }

                // get rid of surprise dialogs
                pdoc->SetModifiedFlag( FALSE );
                }


   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndDoc() called\n"));
   if( dcPrint.EndDoc() < 0 )
          {
      TRACE(TEXT("CPEVW.Render: unable to EndDoc\n"));
      throw "render failed";
      }
/*
   if (pDMOut)
      delete [] (BYTE*) pDMOut;
 */
}
#endif





void CDrawView::make_extranote( CDC *pdc )
        {
        CRect note_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect physical_margins;
        CRect note_margins;

        physical_margins.left = pdc->GetDeviceCaps( PHYSICALOFFSETX );
        physical_margins.top = pdc->GetDeviceCaps( PHYSICALOFFSETY );
        physical_margins.right =
                pdc->GetDeviceCaps( PHYSICALWIDTH ) -
                        (physical_margins.left + pdc->GetDeviceCaps( HORZRES ));
        physical_margins.bottom =
                pdc->GetDeviceCaps( PHYSICALHEIGHT ) -
                        (physical_margins.top + pdc->GetDeviceCaps( VERTRES ));


        note_margins.left   = -physical_margins.left;
        note_margins.top    = -physical_margins.top;
        note_margins.right  =
                pdc->GetDeviceCaps( HORZRES ) + physical_margins.right;
        note_margins.bottom =
                pdc->GetDeviceCaps( VERTRES ) + physical_margins.bottom;

        ClientToDoc( note_margins, pdc );


        note_rect.left =
                note_rect.top = 0;
        note_rect.right  = pdc->GetDeviceCaps( HORZRES );
        note_rect.bottom = pdc->GetDeviceCaps( VERTRES );

        ClientToDoc( note_rect, pdc );


        note_margins.left   += 125;     // 1.25"
        note_margins.top    -= 100;     // 1.00"
        note_margins.right  -= 125; // 1.25"
        note_margins.bottom += 100; // 1.00"

        if( note_margins.left > note_rect.left )
                note_rect.left = note_margins.left;

        if( note_margins.top < note_rect.top )
                note_rect.top = note_margins.top;

        if( note_margins.right < note_rect.right )
                note_rect.right = note_margins.right;

        if( note_margins.bottom > note_rect.bottom )
                note_rect.bottom = note_margins.bottom;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;


// F I X  for 3647 /////////////
//
//FIX FOR 3647 reenables the following 'if' (by commenting out the FALSE)
        if( /*FALSE*/ theApp.m_last_note_box != NULL )
////////////////////////////////
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = note_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( note_rect, IDS_PROP_MS_NOTE );

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
        theApp.m_extra_notepage->m_logfont = theApp.m_default_logfont;
        theApp.m_extra_notepage->
                ChgLogfont( theApp.m_extra_notepage->m_logfont );
////////////////////////////////
                }
        }





#ifdef FUBAR
void CDrawView::make_extranote( CDC *pdc )
        {
        CSize doc_size;
        CRect doc_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect note_size;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;

        doc_size = pdoc->GetSize();

        // shrink by 6% to allow for transform round off
        // and printer edge
        //
        // This is probably a bug. I'll look at it later. The
        // vieworigin seems to be off a little and the printed
        // page is clipped without this kludge
        //
        doc_size.cx     = (doc_size.cx * 94)/100;
        doc_size.cy     = (doc_size.cy * 94)/100;

        // make page sized rect
        doc_rect.left   = -doc_size.cx/2;
        doc_rect.top    =  doc_size.cy/2;
        doc_rect.right  =  doc_rect.left + doc_size.cx;
        doc_rect.bottom =  doc_rect.top - doc_size.cy;


        if( theApp.m_last_note_box != NULL )
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = doc_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( doc_rect, IDS_PROP_MS_NOTE );
                }
        }
#endif





//--------------------------------------------------------------------------
void CDrawView::OnViewShowObjects()
{
   CDrawOleObj::c_bShowItems = !CDrawOleObj::c_bShowItems;
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_OLE_ITEMS, NULL);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewShowObjects(CCmdUI* pCmdUI)
{
   pCmdUI->SetCheck(CDrawOleObj::c_bShowItems);
}


//-------------------------------------------------------------------------
void CDrawView::OnEditProperties()
{
   if (m_selection.GetCount() < 1 || CDrawTool::c_drawShape != select)
      return;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   ASSERT(pTool != NULL);

   CObjPropDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   SaveStateForUndo();  // Assume a change has been made, and make it undoable.

   CString szColorBlack;
   szColorBlack.LoadString(ID_COLOR_BLACK);
   CString szColorWhite;
   szColorWhite.LoadString(ID_COLOR_WHITE);
   CString szColorLTGRAY;
   szColorLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szColorMDGRAY;
   szColorMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szColorDKGRAY;
   szColorDKGRAY.LoadString(ID_COLOR_DKGRAY);

   COLORREF crFillColor;
   if (dlg.m_szFillColor==szColorBlack)
        crFillColor=COLOR_BLACK;
   else if (dlg.m_szFillColor==szColorWhite)
        crFillColor=COLOR_WHITE;
   else if (dlg.m_szFillColor==szColorLTGRAY)
        crFillColor=COLOR_LTGRAY;
   else if (dlg.m_szFillColor==szColorMDGRAY)
        crFillColor=COLOR_MDGRAY;
   else if (dlg.m_szFillColor==szColorDKGRAY)
         crFillColor=COLOR_DKGRAY;
   else
         crFillColor=COLOR_WHITE;

   if(!dlg.m_bRBFillColor)
   {
       //
       // Use white auto color for transparent background
       //
       crFillColor = COLOR_WHITE;
   }

   COLORREF crLineColor;
   if (dlg.m_szLineColor==szColorBlack)
      crLineColor=COLOR_BLACK;
   else if (dlg.m_szLineColor==szColorWhite)
         crLineColor=COLOR_WHITE;
   else if (dlg.m_szLineColor==szColorLTGRAY)
         crLineColor=COLOR_LTGRAY;
   else if (dlg.m_szLineColor==szColorMDGRAY)
         crLineColor=COLOR_MDGRAY;
   else if (dlg.m_szLineColor==szColorDKGRAY)
         crLineColor=COLOR_DKGRAY;
   else
         crLineColor=COLOR_BLACK;

   COLORREF crTextColor;
   if (dlg.m_szTextColor==szColorBlack)
      crTextColor=COLOR_BLACK;
   else if (dlg.m_szTextColor==szColorWhite)
        crTextColor=COLOR_WHITE;
   else if (dlg.m_szTextColor==szColorLTGRAY)
        crTextColor=COLOR_LTGRAY;
   else if (dlg.m_szTextColor==szColorMDGRAY)
        crTextColor=COLOR_MDGRAY;
   else if (dlg.m_szTextColor==szColorDKGRAY)
        crTextColor=COLOR_DKGRAY;
   else
        crTextColor=COLOR_BLACK;

   long lPointSize = _ttol(dlg.m_szThickness);   //integrity check for line thickness

   if (lPointSize < 0)
   {
      lPointSize=1;
   }
   else if (lPointSize==0) 
   {
        dlg.m_bCBDrawBorder=FALSE;
        lPointSize=1;
   }
   else if (lPointSize>72)
   {
        lPointSize=72;
   }

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) 
   {
      CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
      pObj->Invalidate();
      pObj->m_bPen=dlg.m_bCBDrawBorder;
      pObj->m_bBrush=dlg.m_bRBFillColor;
      
      long nPS=lPointSize*100/72;
      pObj->m_lLinePointSize=lPointSize;

      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawLine)))      
      {
         //this correct line m_position for chgs in thickness
         CDrawLine* pLineObj = (CDrawLine*)pObj;
         CRect rc = pLineObj->m_position;
         pLineObj->AdjustLineForPen(rc);
         pLineObj->m_logpen.lopnWidth.y=pLineObj->m_logpen.lopnWidth.x=nPS;
         pLineObj->NegAdjustLineForPen(rc);
         pLineObj->m_position=rc;
      }
      else
      {
         pObj->m_logpen.lopnWidth.y=pObj->m_logpen.lopnWidth.x=nPS;
      }
      
      pObj->m_logpen.lopnColor = crLineColor;
      pObj->m_logbrush.lbColor = crFillColor;

      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
      {
          CDrawText* pText = (CDrawText*)pObj;
          pText->m_crTextColor = crTextColor;
          pText->FitEditWnd(this);
          pText->NewBrush();
      }

      pObj->Invalidate();
   }

   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   if (!pObjects) 
   {
      CScrollView::OnChar(nChar,nRepCnt,nFlags);
      return;
   }

   POSITION pos = NULL;
   CDrawObj* pObj = NULL;

   if (nChar == VK_TAB && 
      (m_selection.GetCount()==1 || m_pObjInEdit) &&
       pObjects->GetCount() > 1 ) 
   {
        if (m_pObjInEdit)
        {
            pos = pObjects->Find(m_pObjInEdit);
        }
        else if(!m_selection.IsEmpty())
        {
            pObj = (CDrawObj*)m_selection.GetHead();
            pos = pObjects->Find(pObj);
        }

        BOOL bShift = ::GetKeyState(VK_SHIFT) & 0x8000;

        if (bShift)
        {
            pObjects->GetPrev(pos);
        }
        else
        {
            pObjects->GetNext(pos);
        }

        if (pos == NULL && !pObjects->IsEmpty())
        {
            if (bShift)
            {
                pObj=(CDrawObj*)pObjects->GetTail();
            }
            else
            {
                pObj=(CDrawObj*)pObjects->GetHead();
            }
        }
        else
        {
            pObj=(CDrawObj*)pObjects->GetAt(pos);
        }

        Select(NULL);
        Select(pObj);
        UpdateStatusBar();
        UpdateStyleBar();
        pDoc->SetModifiedFlag();
   }
   else if (m_pObjInEdit && pObjects->GetCount()==1) 
   {
         CDrawObj* p = m_pObjInEdit;
         Select(NULL);
         Select(m_pObjInEdit);
         UpdateStatusBar();
         UpdateStyleBar();
   }
   else
   {
        CScrollView::OnChar(nChar,nRepCnt,nFlags);
   }
}


void CDrawView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar) 
    {
    case VK_LEFT:
    case VK_RIGHT:
    case VK_UP:
    case VK_DOWN:
       if (m_selection.GetCount() >=1 &&  m_pObjInEdit==NULL) 
       {
          CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
          if (pTool != NULL)
             pTool->OnArrowKey(this, nChar, nRepCnt, nFlags);
       }
       break;

    case VK_SHIFT:
        if (m_bKU) 
        {
            m_bShiftSignal=TRUE;
            m_bKU=FALSE;
        }
        break;
    }

    CScrollView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CDrawView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
        switch (nChar) {
                case VK_SHIFT:
                    m_bKU=TRUE;
                        break;
        }

    CScrollView::OnKeyUp(nChar, nRepCnt, nFlags);
}

BOOL
CDrawView::IsHighContrast()
{
    HIGHCONTRAST highContrast = {0};
    highContrast.cbSize = sizeof(highContrast);

    if(!SystemParametersInfo(SPI_GETHIGHCONTRAST, 0, (PVOID)&highContrast, 0))
    {
        TRACE(TEXT("SystemParametersInfo failed: %d"), ::GetLastError());
        return FALSE;
    }

    return ((highContrast.dwFlags & HCF_HIGHCONTRASTON) == HCF_HIGHCONTRASTON);
}

void 
CDrawView::OnSysColorChange()
{
    return CScrollView::OnSysColorChange();    
}

//-------------------------------------------------------------------------
void CDrawView::OnEditChange()
{
   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
   BOOL bEnable = m_selection.GetCount() >= 1 && CDrawTool::c_drawShape == select;
   if (bEnable) 
   {
        bEnable=FALSE;
        POSITION pos = m_selection.GetHeadPosition();
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
            if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj))) 
            {
                bEnable=TRUE;
                break;
            }
        }
   }

   pCmdUI->Enable(bEnable);
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateToList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_TO_LIST ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateCcList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_CC_LIST ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCompany(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COMPANY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecAddress(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STREET_ADDRESS ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCity(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_CITY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecState(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STATE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecZipCode(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_ZIP_CODE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCountry(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COUNTRY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecTitle(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_TITLE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecDept(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_DEPARTMENT ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficeLoc(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_LOCATION ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecHomePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_HOME_PHONE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_PHONE ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnFilePrintPreview()
{
   CScrollView::OnFilePrintPreview();
}


/////////////////////////////////////////////////////////////////////////////
// CDrawView diagnostics

#ifdef _DEBUG
void CDrawView::AssertValid() const
{
        CScrollView::AssertValid();
}

void CDrawView::Dump(CDumpContext& dc) const
{
        CScrollView::Dump(dc);
}
#endif //_DEBUG





//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawView, CScrollView)
   //{{AFX_MSG_MAP(CDrawView)
   ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
   ON_COMMAND(ID_CANCEL_EDIT, OnCancelEdit)
   ON_WM_SYSCOLORCHANGE()
   ON_WM_CONTEXTMENU()
   ON_WM_LBUTTONDOWN()
   ON_WM_KEYDOWN()
   ON_WM_KEYUP()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_LBUTTONDBLCLK()
   ON_WM_SETFOCUS()
   ON_WM_KILLFOCUS()
   ON_EN_CHANGE(ID_TEXT, OnEditChange)
   ON_COMMAND(ID_MAPI_RECIP_NAME,       OnMAPIRecipName)
   ON_COMMAND(ID_MAPI_RECIP_FAXNUM,     OnMAPIRecipFaxNum)
   ON_COMMAND(ID_MAPI_RECIP_COMPANY,    OnMAPIRecipCompany)
   ON_COMMAND(ID_MAPI_RECIP_ADDRESS,    OnMAPIRecipAddress)
   ON_COMMAND(ID_MAPI_RECIP_CITY,       OnMAPIRecipCity)
   ON_COMMAND(ID_MAPI_RECIP_STATE,      OnMAPIRecipState)
   ON_COMMAND(ID_MAPI_RECIP_POBOX,      OnMAPIRecipPOBox)
   ON_COMMAND(ID_MAPI_RECIP_ZIPCODE,    OnMAPIRecipZipCode)
   ON_COMMAND(ID_MAPI_RECIP_COUNTRY,    OnMAPIRecipCountry)
   ON_COMMAND(ID_MAPI_RECIP_TITLE,      OnMAPIRecipTitle)
   ON_COMMAND(ID_MAPI_RECIP_DEPT,       OnMAPIRecipDept)
   ON_COMMAND(ID_MAPI_RECIP_OFFICELOC,  OnMAPIRecipOfficeLoc)
   ON_COMMAND(ID_MAPI_RECIP_HMTELENUM,  OnMAPIRecipHMTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_OFTELENUM,  OnMAPIRecipOFTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_TOLIST,     OnMAPIRecipToList)
   ON_COMMAND(ID_MAPI_RECIP_CCLIST,     OnMAPIRecipCCList)
   ON_COMMAND(ID_MAPI_SENDER_NAME,      OnMAPISenderName)
   ON_COMMAND(ID_MAPI_SENDER_FAXNUM,    OnMAPISenderFaxNum)
   ON_COMMAND(ID_MAPI_SENDER_COMPANY,   OnMAPISenderCompany)
   ON_COMMAND(ID_MAPI_SENDER_ADDRESS,   OnMAPISenderAddress)
   ON_COMMAND(ID_MAPI_SENDER_TITLE,     OnMAPISenderTitle)
   ON_COMMAND(ID_MAPI_SENDER_DEPT,      OnMAPISenderDept)
   ON_COMMAND(ID_MAPI_SENDER_OFFICELOC, OnMAPISenderOfficeLoc)
   ON_COMMAND(ID_MAPI_SENDER_HMTELENUM, OnMAPISenderHMTeleNum)
   ON_COMMAND(ID_MAPI_SENDER_OFTELENUM, OnMAPISenderOFTeleNum)
   ON_COMMAND(ID_MAPI_SENDER_EMAIL,		OnMAPISenderEmail)
   ON_COMMAND(ID_MAPI_MSG_SUBJECT,      OnMAPIMsgSubject)
   ON_COMMAND(ID_MAPI_MSG_TIMESENT,     OnMAPIMsgTimeSent)
   ON_COMMAND(ID_MAPI_MSG_NUMPAGES,     OnMAPIMsgNumPages)
   ON_COMMAND(ID_MAPI_MSG_ATTACH,       OnMAPIMsgAttach)
   ON_COMMAND(ID_MAPI_MSG_BILLCODE,     OnMAPIMsgBillCode)
   ON_COMMAND(ID_MAPI_MSG_FAXTEXT,      OnMAPIMsgFaxText)
   ON_COMMAND(ID_FONT,              OnFont)
   ON_COMMAND(ID_DRAW_SELECT,       OnDrawSelect)
   ON_COMMAND(ID_DRAW_ROUNDRECT,    OnDrawRoundRect)
   ON_COMMAND(ID_DRAW_RECT,         OnDrawRect)
   ON_COMMAND(ID_DRAW_TEXT,         OnDrawText)
   ON_COMMAND(ID_DRAW_LINE,         OnDrawLine)
   ON_COMMAND(ID_DRAW_ELLIPSE,      OnDrawEllipse)
   ON_CBN_EDITCHANGE(ID_FONT_NAME,  OnEditChangeFont)
   ON_CBN_SELENDOK(ID_FONT_SIZE,    OnSelEndOKFontSize)
   ON_COMMAND(ID_STYLE_BOLD,        OnStyleBold)
   ON_COMMAND(ID_STYLE_ITALIC,      OnStyleItalic)
   ON_COMMAND(ID_STYLE_UNDERLINE,   OnStyleUnderline)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS1,  OnUpdatePosStatusBar)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ELLIPSE,    OnUpdateDrawEllipse)
   ON_UPDATE_COMMAND_UI(ID_DRAW_LINE,       OnUpdateDrawLine)
   ON_UPDATE_COMMAND_UI(ID_DRAW_RECT,       OnUpdateDrawRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_TEXT,       OnUpdateDrawText)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ROUNDRECT,  OnUpdateDrawRoundRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_SELECT,     OnUpdateDrawSelect)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERWIDTH,  OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEBACK,     OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_FAXTEXT,    OnUpdateFaxText)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNLEFT,    OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEACROSS,  OnUpdateAlign3)
   ON_COMMAND(ID_EDIT_SELECT_ALL,               OnEditSelectAll)
   ON_COMMAND(ID_EDIT_CLEAR,    OnEditClear)
   ON_COMMAND(ID_EDIT_UNDO,     OnEditUndo)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR,      OnUpdateAnySelect)
   ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO,       OnUpdateEditUndo)
   ON_COMMAND(ID_DRAW_POLYGON,              OnDrawPolygon)
   ON_UPDATE_COMMAND_UI(ID_DRAW_POLYGON,    OnUpdateDrawPolygon)
   ON_WM_SIZE()
   ON_COMMAND(ID_LAYOUT_ALIGNLEFT,      OnAlignLeft)
   ON_COMMAND(ID_LAYOUT_ALIGNRIGHT,     OnAlignRight)
   ON_COMMAND(ID_LAYOUT_ALIGNTOP,       OnAlignTop)
   ON_COMMAND(ID_LAYOUT_ALIGNBOTTOM,    OnAlignBottom)
   ON_COMMAND(ID_LAYOUT_ALIGNHORZCENTER, OnAlignHorzCenter)
   ON_COMMAND(ID_LAYOUT_ALIGNVERTCENTER, OnAlignVertCenter)
   ON_COMMAND(ID_LAYOUT_SPACEACROSS,    OnSpaceAcross)
   ON_COMMAND(ID_LAYOUT_SPACEDOWN,      OnSpaceDown)
   ON_COMMAND(ID_LAYOUT_CENTERWIDTH,    OnCenterWidth)
   ON_COMMAND(ID_LAYOUT_CENTERHEIGHT,   OnCenterHeight)
   ON_COMMAND(ID_VIEW_GRIDLINES,        OnViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_VIEW_GRIDLINES,  OnUpdateViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME,       OnUpdateFont)
   ON_WM_ERASEBKGND()
   ON_COMMAND(ID_OBJECT_MOVEBACK,       OnObjectMoveBack)
   ON_COMMAND(ID_OBJECT_MOVEFORWARD,    OnObjectMoveForward)
   ON_COMMAND(ID_OBJECT_MOVETOBACK,     OnObjectMoveToBack)
   ON_COMMAND(ID_OBJECT_MOVETOFRONT,    OnObjectMoveToFront)
   ON_COMMAND(ID_EDIT_COPY,             OnEditCopy)
   ON_UPDATE_COMMAND_UI(ID_EDIT_COPY,   OnUpdateEditCopy)
   ON_COMMAND(ID_EDIT_CUT,              OnEditCut)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CUT,    OnUpdateEditCut)
   ON_COMMAND(ID_EDIT_PASTE,            OnEditPaste)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE,  OnUpdateEditPaste)
   ON_COMMAND(ID_VIEW_SHOWOBJECTS,      OnViewShowObjects)
   ON_UPDATE_COMMAND_UI(ID_VIEW_SHOWOBJECTS, OnUpdateViewShowObjects)
   ON_COMMAND(ID_EDIT_PROPERTIES,       OnEditProperties)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PROPERTIES, OnUpdateEditProperties)
   ON_WM_DESTROY()
   ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
   ON_CBN_EDITCHANGE(ID_FONT_SIZE,          OnEditChangeFont)
   ON_CBN_SELCHANGE(ID_FONT_NAME,           OnSelchangeFontName)
   ON_CBN_SELCHANGE(ID_FONT_SIZE,           OnSelchangeFontSize)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE,           OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEFORWARD,  OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOBACK,   OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOFRONT,  OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME,       OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE,       OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_BOLD,      OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_ITALIC,    OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_UNDERLINE, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_LEFT,      OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_CENTERED,  OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_RIGHT,     OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT,            OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNRIGHT,       OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNTOP,         OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNBOTTOM,      OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNHORZCENTER,  OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNVERTCENTER,  OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEDOWN,        OnUpdateAlign3)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERHEIGHT,     OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS2,          OnUpdatePosStatusBar)
//
// Enable or disable menu for fax property fields depending on a registry key.   a-juliar
//
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TOLIST,     OnUpdateToList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CCLIST,     OnUpdateCcList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COMPANY ,   OnUpdateRecCompany )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ADDRESS ,   OnUpdateRecAddress )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CITY ,      OnUpdateRecCity )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_STATE ,     OnUpdateRecState )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ZIPCODE ,   OnUpdateRecZipCode )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COUNTRY ,   OnUpdateRecCountry )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TITLE ,     OnUpdateRecTitle )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_DEPT ,      OnUpdateRecDept )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFFICELOC , OnUpdateRecOfficeLoc )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_HMTELENUM , OnUpdateRecHomePhone )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFTELENUM , OnUpdateRecOfficePhone )
   ON_WM_CHAR()
   ON_COMMAND(ID_STYLE_LEFT,        OnStyleLeft)
   ON_COMMAND(ID_STYLE_CENTERED,    OnStyleCentered)  
   ON_COMMAND(ID_STYLE_RIGHT,       OnStyleRight)
   ON_COMMAND(ID_MAPI_MSG_NOTE,     OnMapiMsgNote)
   //}}AFX_MSG_MAP
   // Standard printing commands
#ifdef GRID
   ON_UPDATE_COMMAND_UI(ID_SNAP_TO_GRID, OnUpdateSnapToGrid)
   ON_UPDATE_COMMAND_UI(ID_GRID_SETTINGS, OnUpdateGridSettings)
   ON_COMMAND(ID_SNAP_TO_GRID, OnSnapToGrid)
   ON_COMMAND(ID_GRID_SETTINGS, OnGridSettings)
   ON_COMMAND(ID_VIEW_GRID, OnViewGrid)
#endif
   ON_WM_CTLCOLOR()
   ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
   ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\cpevw.h ===
//--------------------------------------------------------------------------
// cpevw.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEVW_H__
#define __CPEVW_H__


// Hints for UpdateAllViews/OnUpdate
#define HINT_UPDATE_WINDOW      0
#define HINT_UPDATE_DRAWOBJ     1
#define HINT_UPDATE_SELECTION   2
#define HINT_DELETE_SELECTION   3
#define HINT_UPDATE_OLE_ITEMS   4


class CDrawObj;
class CDrawText;
class CDrawApp;
class CDrawDoc;
class CMainFrame;

typedef enum {GRID_SMALL=10,GRID_MEDIUM=20,GRID_LARGE=50} eGridSize;     //grid sizes, in LU

class CSortedObList : public CObList
{
public:
   CSortedObList() {};
   CSortedObList& operator=(CObList&);
   void SortToLeft();
   void SortToBottom();
private:
   void swap(INT_PTR i, INT_PTR j);
};


class CDrawView : public CScrollView
{
public:
    BOOL m_bShiftSignal;
    BOOL m_bKU;
    CPen m_penDot;
    CPen m_penSolid;
    BOOL m_bFontChg;
    BOOL m_bHighContrast;
    CDrawText* m_pObjInEdit;

protected:
    BOOL m_bCanUndo ;
public:
    BOOL CanUndo() { return m_bCanUndo ; }
    void DisableUndo(){ m_bCanUndo = FALSE ; }
    void SaveStateForUndo();
    static void FreeObjectsMemory( CObList * pObList );

    CMainFrame* GetFrame() {return ((CMainFrame*)AfxGetMainWnd());}
    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
    static CDrawView* GetView();
    CDrawDoc* GetDocument() { return (CDrawDoc*)m_pDocument; }
    void SetPageSize(CSize size);
    CRect GetInitialPosition();
    void DoPrepareDC(CDC* pDC);
    void TrackObjectMenu(CPoint&);
    void TrackViewMenu(CPoint&);
    void NormalizeObjs();

    void DocToClient(CRect& rect, CDC* pDC=NULL);
    void DocToClient(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CRect& rect, CDC* pDC=NULL);

    void Select(CDrawObj* pObj, BOOL bShift = FALSE, BOOL bCheckEdit=TRUE);
    void SelectWithinRect(CRect rect, BOOL bAdd = FALSE);
    void Deselect(CDrawObj* pObj);
    void CloneSelection();
    void CreateFaxProp(WORD wResourceid);
    void CreateFaxText();
    void FindLocation(CRect& objrect);
    void UpdateActiveItem();
    void Remove(CDrawObj* pObj);
    void PasteNative(COleDataObject& dataObject);
    void PasteEmbedded(COleDataObject& dataObject);

    BOOL IsHighContrast();

    virtual ~CDrawView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    void UpdateStatusBar();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    void DrawGrid(CDC* pDC);

    static CLIPFORMAT m_cfDraw; // custom clipboard format

    CObList m_selection;
    BOOL m_bGridLines;
    BOOL m_bActive; // is the view active?

protected:
    CDrawView();
    BOOL m_bBold;
    BOOL m_bItalic;
    BOOL m_bUnderline;
    DWORD m_dwEfcFields ;

    DECLARE_DYNCREATE(CDrawView)
    virtual void OnInitialUpdate(); // called first time after construct
    int GetPointSize(CDrawText&);
    CSize ComputeScrollSize(CSize size) ;
    void CheckStyleBar(BOOL, BOOL, BOOL, BOOL, BOOL, BOOL);
    void NormalizeRect(CRect& rc);
    void UpdateStyleBar(CObList* pObList=NULL,CDrawText* p=NULL);

        // Printing support

    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

        // OLE Container support
public:
    afx_msg void OnChar(UINT, UINT, UINT);
    virtual BOOL IsSelected(const CObject* pDocItem) const;
    afx_msg void OnSelchangeFontName();
    afx_msg void OnSelchangeFontSize();

    void OnSelChangeFontName(CObList* pObList=NULL,CDrawText* p=NULL);
    void OnSelChangeFontSize(CObList* pObList=NULL,CDrawText* p=NULL);

    void make_extranote( CDC *pdc );
    //void make_extranote_and_count_pages( BOOL do_transform );

// Generated message map functions
protected:
    void ChgTextAlignment(LONG lstyle);

    //{{AFX_MSG(CDrawView)

    afx_msg void OnSysColorChange();
    afx_msg void OnInsertObject();
    afx_msg void OnCancelEdit();
    afx_msg void OnContextMenu(CWnd *, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnFilePrintPreview();
    afx_msg void OnEditChange();
    afx_msg void OnMAPIRecipName();
    afx_msg void OnMAPIRecipFaxNum();
    afx_msg void OnMAPIRecipCompany();
    afx_msg void OnMAPIRecipAddress();
    afx_msg void OnMAPIRecipCity();
    afx_msg void OnMAPIRecipState();
    afx_msg void OnMAPIRecipPOBox();
    afx_msg void OnMAPIRecipZipCode();
    afx_msg void OnMAPIRecipCountry();
    afx_msg void OnMAPIRecipTitle();
    afx_msg void OnMAPIRecipDept();
    afx_msg void OnMAPIRecipOfficeLoc();
    afx_msg void OnMAPIRecipHMTeleNum();
    afx_msg void OnMAPIRecipOFTeleNum();
    afx_msg void OnMAPIRecipToList();
    afx_msg void OnMAPIRecipCCList();
    afx_msg void OnMAPISenderName();
    afx_msg void OnMAPISenderFaxNum();
    afx_msg void OnMAPISenderCompany();
    afx_msg void OnMAPISenderAddress();
    afx_msg void OnMAPISenderTitle();
    afx_msg void OnMAPISenderDept();
    afx_msg void OnMAPISenderOfficeLoc();
    afx_msg void OnMAPISenderHMTeleNum();
    afx_msg void OnMAPISenderOFTeleNum();
	afx_msg void OnMAPISenderEmail();
    afx_msg void OnMAPIMsgSubject();
    afx_msg void OnMAPIMsgTimeSent();
    afx_msg void OnMAPIMsgNumPages();
    afx_msg void OnMAPIMsgAttach();
    afx_msg void OnMAPIMsgBillCode();
    afx_msg void OnMAPIMsgFaxText();
    afx_msg void OnFont();
    afx_msg void OnDrawSelect();
    afx_msg void OnDrawRoundRect();
    afx_msg void OnDrawRect();
    afx_msg void OnDrawText();
    afx_msg void OnDrawLine();
    afx_msg void OnDrawEllipse();
    afx_msg void OnEditChangeFont();
    afx_msg void OnSelEndOKFontSize();
    afx_msg void OnStyleBold();
    afx_msg void OnStyleItalic();
    afx_msg void OnStyleUnderline();
    afx_msg void OnStyleLeft();
    afx_msg void OnStyleCentered();
    afx_msg void OnStyleRight();
    afx_msg void OnUpdatePosStatusBar(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawEllipse(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawLine(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRoundRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSingleSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoreThanOne(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMove(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFaxText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign3(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditClear();
    afx_msg void OnEditUndo();
    afx_msg void OnUpdateAnySelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnDrawPolygon();
    afx_msg void OnUpdateDrawPolygon(CCmdUI* pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnAlignLeft();
    afx_msg void OnAlignRight();
    afx_msg void OnAlignTop();
    afx_msg void OnAlignBottom();
    afx_msg void OnAlignHorzCenter();
    afx_msg void OnAlignVertCenter();
    afx_msg void OnSpaceAcross();
    afx_msg void OnSpaceDown();
    afx_msg void OnCenterWidth();
    afx_msg void OnCenterHeight();
    afx_msg void OnViewGridLines();
    afx_msg void OnUpdateViewGridLines(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFont(CCmdUI* pCmdUI);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnObjectMoveBack();
    afx_msg void OnObjectMoveForward();
    afx_msg void OnObjectMoveToBack();
    afx_msg void OnObjectMoveToFront();
    afx_msg void OnViewPaperColor();
    afx_msg void OnDrawBitmap();
    afx_msg void OnUpdateDrawBitmap(CCmdUI* pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnEditCut();
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnFilePrint();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnViewShowObjects();
    afx_msg void OnUpdateViewShowObjects(CCmdUI* pCmdUI);
    afx_msg void OnEditProperties();
    afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
    afx_msg void OnDestroy();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnMapiMsgNote();
    afx_msg void OnUpdateToList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateCcList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCompany(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecAddress(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCity(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecState(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecZipCode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCountry(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecTitle(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecDept(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficeLoc(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecHomePhone(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficePhone(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


#endif //#ifndef __CPEVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\dialogs.h ===
//=========================================================================
// DIALOGS.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=========================================================================
//
// Modified by a-juliar to fix NT bug 49528.
//
#ifndef __DIALOGS_H__
#define __DIALOGS_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

//------------------------------------------------------------------------
// CPE error message codes
//
// 001 - 299 information
// 300 - 499 error
// >= 500    critical
//------------------------------------------------------------------------
#define MSG_INFO_DRAWPOLY              001
#define MSG_INFO_NOFAXPROP             002
#define MSG_ERROR_INVFORMAT            300
#define MSG_ERROR_OLEINIT_FAILED       301
#define MSG_ERROR_OLE_FAILED_TO_CREATE 302
#define MSG_ERROR_MISSINGFILE          303
#define MSG_ERROR_NOPAGESETUPDLL       304
#define MSG_ERROR_NOPAGESETUP          305

int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType=MB_OK, int msgid=-1);
int AlignedAfxMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 );
int AlignedAfxMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT) -1 );


class CDrawView;

//---------------------------------------------------------------------------
// CObjPropDlg dialog
//---------------------------------------------------------------------------
class CObjPropDlg : public CDialog
{
public:
   BOOL m_bCBDrawBorder;
   BOOL m_bRBFillColor;
   BOOL m_bRBFillTrans;
   CString m_szThickness;
   CString m_szLineColor;
   CString m_szFillColor;
   CString m_szTextColor;
   CObjPropDlg(CWnd* pParent = NULL); // standard constructor

    //{{AFX_DATA(CObjPropDlg)
    enum { IDD = IDD_OBJ_PROP};
    //}}AFX_DATA

protected:
   CDrawView* m_pView;

    afx_msg void OnSelChangeFillColor();
    BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    CButton& GetRBFillColor() { return *(CButton*)GetDlgItem(IDC_RB_FILLCOLOR); }
    CButton& GetRBFillTrans() { return *(CButton*)GetDlgItem(IDC_RB_FILLTRANS); }
    CComboBox& GetLBThickness() { return *(CComboBox*)GetDlgItem(IDC_LB_THICKNESS); }
    CComboBox& GetLBLineColor() { return *(CComboBox*)GetDlgItem(IDC_LB_LINECOLOR); }
    CComboBox& GetLBFillColor() { return *(CComboBox*)GetDlgItem(IDC_LB_FILLCOLOR); }
    CWnd& GetGRPFillColor() { return *(CWnd*)GetDlgItem(IDC_GRP_FILLCOLOR); }
    CComboBox& GetLBTextColor() { return *(CComboBox*)GetDlgItem(IDC_LB_TEXTCOLOR); }
    CWnd& GetSTTextColor() { return *(CWnd*)GetDlgItem(IDC_ST_TEXTCOLOR); }

    //{{AFX_MSG(CObjPropDlg)
            // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG

    virtual void OnOK();

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

    afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
 
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

   DECLARE_MESSAGE_MAP()
};





//---------------------------------------------------------------------------
// CGridSettingsDlg dialog
//---------------------------------------------------------------------------
class CGridSettingsDlg : public CDialog
{
public:
        CGridSettingsDlg(CWnd* pParent = NULL); // standard constructor
   BOOL m_bRBSmall, m_bRBMedium, m_bRBLarge;
   BOOL m_bCBViewGrid, m_bCBSnapToGrid;

        //{{AFX_DATA(CGridSettingsDlg)
        enum { IDD = IDD_GRID_SETTINGS};
        //}}AFX_DATA

protected:
   CDrawView* m_pView;

   BOOL OnInitDialog();

        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

        //{{AFX_MSG(CGridSettingsDlg)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG

        afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
///#ifdef ENABLE_HELP
        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CBigIcon : public CButton
{
public:
        void SizeToContent();

protected:
        virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

        //{{AFX_MSG(CBigIcon)
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CSplashTipsDlg : public CDialog
{
public:
    CFont m_tips_font;
    CFont m_tipstitle_font;
    int m_iCurrentTip;
    CSplashTipsDlg(BOOL bRandomTip = FALSE, CWnd* pParent = NULL);
    BOOL OnInitDialog();

    //{{AFX_DATA(CSplashTipsDlg)
    enum { IDD = IDD_SPLASHTIPS };
    //}}AFX_DATA

protected:

    BOOL m_bRandomTip;

    CButton* GetNextTip() {return (CButton*) GetDlgItem(IDC_B_NEXTTIP);};
    CButton* GetPrevTip() {return (CButton*) GetDlgItem(IDC_B_PREVTIP);};
    CButton* GetShowTips() {return (CButton*) GetDlgItem(IDC_CK_SHOWTIPS);};
    CEdit* GetTitle() {return (CEdit*) GetDlgItem(IDC_STA_TITLE);};
    CEdit* GetTips() {return (CEdit*) GetDlgItem(IDC_STA_TIP);};

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnNextTip();
    afx_msg void OnPrevTip();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnOK();

    //{{AFX_MSG(CSplashTipsDlg)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

//--------------------------------------------------------------------------------------
class CMyCommonDialog : public CCommonDialog
{
public:
        CMyCommonDialog( CWnd* pParentWnd );

protected:
        //{{AFX_MSG(CMyCommonDialog)        //////// I typed this, not the app wizard! a-juliar
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG

        DECLARE_MESSAGE_MAP()
};

class CMyOleInsertDialog : public COleInsertDialog
{
public:
    CMyOleInsertDialog( DWORD dwFlags = IOF_SELECTCREATENEW, CWnd* pParentWnd = NULL );

protected:
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

    DECLARE_MESSAGE_MAP()
};


typedef BOOL (APIENTRY *PPSD)(PAGESETUPDLG*);

class CMyPageSetupDialog : public CMyCommonDialog
{
public:
        CMyPageSetupDialog(CWnd* pParentWnd = NULL);
        ~CMyPageSetupDialog();
        PAGESETUPDLG m_psd;
        PPSD m_pPageSetupDlg;
        HINSTANCE m_hLib;

        virtual INT_PTR DoModal();
};

//--------------------------------------------------------------------------------------

class CMyPrintDlg : public CPrintDialog
{
        DECLARE_DYNAMIC(CMyPrintDlg)

public:
        CMyPrintDlg(BOOL bPrintSetupOnly,
                // TRUE for Print Setup, FALSE for Print Dialog
                DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
                        | PD_HIDEPRINTTOFILE | PD_NOSELECTION,
                CWnd* pParentWnd = NULL);

protected:
        //{{AFX_MSG(CMyPrintDlg)
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//---------------------------------------------------------------------------------------
class CMyFontDialog : public CFontDialog
{
public:
    CMyFontDialog(LPLOGFONT lplfInitial = NULL,
                  DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
                  CDC* pdcPrinter = NULL,
                  CWnd* pParentWnd = NULL);
protected:
    afx_msg BOOL OnHelpInfo( HELPINFO* pHelpInfo);
    DECLARE_MESSAGE_MAP()
};

extern const DWORD aHelpIDs[] ;       /// Defined in dialogs.cpp
extern const DWORD aOleDlgHelpIDs[] ; /// Defined in dialogs.cpp
#endif // #ifndef __DIALOGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\dialogs.cpp ===
//----------------------------------------------------------------------
// dialogs.cpp : implementation file
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains misc. dialogs for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modification:     a-juliar modified it to fix NT bug 49528  8/2/96
//----------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include <htmlhelp.h>
#include <time.h>
#include <faxutil.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

WORD wStandardLineSizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};

#define TOTAL_TIPS 10

//
// Help IDs for IDD_INSERTOBJECT (1000)
//
#define HIDC_IO_CREATENEW                       0x3E80834
#define HIDC_IO_CREATEFROMFILE                  0x3E80835
#define HIDC_IO_LINKFILE                        0x3E80836
#define HIDC_IO_OBJECTTYPELIST                  0x3E80837
#define HIDC_IO_DISPLAYASICON                   0x3E80838
#define HIDC_IO_CHANGEICON                      0x3E80839
#define HIDC_IO_FILE                            0x3E8083A
#define HIDC_IO_FILEDISPLAY                     0x3E8083B
#define HIDC_IO_RESULTIMAGE                     0x3E8083C
#define HIDC_IO_RESULTTEXT                      0x3E8083D
#define HIDC_IO_ICONDISPLAY                     0x3E8083E
#define HIDC_IO_FILETYPE                        0x3E80841
#define HIDC_IO_INSERTCONTROL                   0x3E80842
#define HIDC_IO_ADDCONTROL                      0x3E80843
#define HIDC_IO_CONTROLTYPELIST                 0x3E80844

const DWORD aOleDlgHelpIDs[]={
        IDC_IO_CREATENEW,       HIDC_IO_CREATENEW,
        IDC_IO_CREATEFROMFILE,  HIDC_IO_CREATEFROMFILE,
        IDC_IO_LINKFILE,        HIDC_IO_LINKFILE,
        IDC_IO_OBJECTTYPELIST,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_DISPLAYASICON,   HIDC_IO_DISPLAYASICON,
        IDC_IO_CHANGEICON,      HIDC_IO_CHANGEICON,
        IDC_IO_FILE,            HIDC_IO_FILE,
        IDC_IO_FILEDISPLAY,     HIDC_IO_FILEDISPLAY,
        IDC_IO_RESULTIMAGE,     HIDC_IO_RESULTIMAGE,
        IDC_IO_RESULTTEXT,      HIDC_IO_RESULTTEXT,
        IDC_IO_ICONDISPLAY,     HIDC_IO_ICONDISPLAY,
        IDC_IO_FILETYPE,        HIDC_IO_FILETYPE,
        IDC_IO_INSERTCONTROL,   HIDC_IO_INSERTCONTROL,
        IDC_IO_ADDCONTROL,      HIDC_IO_ADDCONTROL,
        IDC_IO_CONTROLTYPELIST, HIDC_IO_CONTROLTYPELIST,
        IDC_IO_OBJECTTYPETEXT,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_FILETEXT,        HIDC_IO_FILE,
        0,                      0
};

//------------------------------------------------------------------------
// CObjPropDlg dialog
//------------------------------------------------------------------------
CObjPropDlg::CObjPropDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CObjPropDlg::IDD, pParent)
{
}

//----------------------------------------------------------------------------
void CObjPropDlg::OnSelChangeFillColor()
{
    GetRBFillColor().SetCheck(1);
    GetRBFillTrans().SetCheck(0);
}

void CObjPropDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CObjPropDlg)
    DDX_Check(pDX, IDC_CB_DRAWBORDER, m_bCBDrawBorder);
    DDX_Check(pDX, IDC_RB_FILLCOLOR, m_bRBFillColor);
    DDX_Check(pDX, IDC_RB_FILLTRANS, m_bRBFillTrans);
    DDX_CBString(pDX, IDC_LB_THICKNESS, m_szThickness);
    DDX_CBString(pDX, IDC_LB_LINECOLOR, m_szLineColor);
    DDX_CBString(pDX, IDC_LB_FILLCOLOR, m_szFillColor);
    DDX_CBString(pDX, IDC_LB_TEXTCOLOR, m_szTextColor);
    // DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
        //}}AFX_DATA_MAP
}



LRESULT 
CObjPropDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{
    DWORD dwRes = ERROR_SUCCESS;

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        TRACE1("CPE: WinHelpContextPopup failed with %d\n", dwRes);
    }

    return 0;
}

void
CObjPropDlg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        TRACE1("CPE: WinHelpContextPopup failed with %d\n", dwRes);
    }
}


//------------------------------------------------------------------------
BOOL CObjPropDlg::OnInitDialog()
{
   TCHAR szPointSize[4] = {0};
   CComboBox& lbThickness = GetLBThickness();
   for ( int i = 0; i < ARR_SIZE(wStandardLineSizes) ; ++i) 
   {
       _sntprintf(szPointSize, ARR_SIZE(szPointSize)-1, TEXT("%d"), wStandardLineSizes[i]);
      lbThickness.AddString(szPointSize);
   }
   lbThickness.LimitText(2);

   CString szBLACK;
   szBLACK.LoadString(ID_COLOR_BLACK);
   CString szWHITE;
   szWHITE.LoadString(ID_COLOR_WHITE);
   CString szLTGRAY;
   szLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szMDGRAY;
   szMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szDKGRAY;
   szDKGRAY.LoadString(ID_COLOR_DKGRAY);

   GetLBLineColor().AddString(szBLACK);
   GetLBLineColor().AddString(szWHITE);
   GetLBLineColor().AddString(szLTGRAY);
   GetLBLineColor().AddString(szMDGRAY);
   GetLBLineColor().AddString(szDKGRAY);

   GetLBFillColor().AddString(szBLACK);
   GetLBFillColor().AddString(szWHITE);
   GetLBFillColor().AddString(szLTGRAY);
   GetLBFillColor().AddString(szMDGRAY);
   GetLBFillColor().AddString(szDKGRAY);

   GetLBTextColor().AddString(szBLACK);
   GetLBTextColor().AddString(szWHITE);
   GetLBTextColor().AddString(szLTGRAY);
   GetLBTextColor().AddString(szMDGRAY);
   GetLBTextColor().AddString(szDKGRAY);

   BOOL bFillObj=FALSE;
   BOOL bTextColor=TRUE;
   BOOL bFillColor=TRUE;
   BOOL bFillTrans=TRUE;
   BOOL bFillRGB=TRUE;
   BOOL bLineRGB=TRUE;
   BOOL bTextRGB=TRUE;
   BOOL bPen=TRUE;
   BOOL bPenThickness=TRUE;
   BOOL bBorder=TRUE;
   BOOL bTextObj=FALSE;
   BOOL bAllOleObjs=TRUE;
   int iSaveLinePointSize=0;
   COLORREF crSaveFillRGB=0;
   COLORREF crSaveLineRGB=0;
   COLORREF crSaveTextRGB=0;

   CDrawView* pView = CDrawView::GetView();
   if (!pView) {
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
      return FALSE;
   }

      //iterate thru selected objects for object properties
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          bTextObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawLine)))
          bFillObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
          bAllOleObjs=FALSE;

       if (iSaveLinePointSize !=0 && iSaveLinePointSize != pObj->m_lLinePointSize)
         bPenThickness=FALSE;
       if (crSaveFillRGB !=0 && crSaveFillRGB != pObj->m_logbrush.lbColor)
         bFillRGB=FALSE;
       if (crSaveLineRGB !=0 && crSaveLineRGB != pObj->m_logpen.lopnColor)
         bLineRGB=FALSE;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) &&
           crSaveTextRGB !=0 && crSaveTextRGB != ((CDrawText*)pObj)->m_crTextColor)
         bTextRGB=FALSE;

       if (!pObj->m_bBrush)
          bFillColor=FALSE;
       if (pObj->m_bBrush)
          bFillTrans=FALSE;
       if (!pObj->m_bPen)
          bPen=FALSE;

       iSaveLinePointSize=pObj->m_lLinePointSize;
       crSaveFillRGB=pObj->m_logbrush.lbColor;
       crSaveLineRGB=pObj->m_logpen.lopnColor;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          crSaveTextRGB=((CDrawText*)pObj)->m_crTextColor;
   }


    //load default point size
   if (bPenThickness) {
      _itot (iSaveLinePointSize, szPointSize, 10);
      m_szThickness=szPointSize;
   }
   else
      m_szThickness="";    //indeterminate state

   CString sz;
   if (bFillRGB) {  //Fill color listbox
      if (crSaveFillRGB==COLOR_BLACK)
         m_szFillColor=szBLACK;
      else
      if (crSaveFillRGB==COLOR_WHITE)
         m_szFillColor=szWHITE;
      else
      if (crSaveFillRGB==COLOR_LTGRAY)
         m_szFillColor=szLTGRAY;
      else
      if (crSaveFillRGB==COLOR_MDGRAY)
         m_szFillColor=szMDGRAY;
      else
      if (crSaveFillRGB==COLOR_DKGRAY)
         m_szFillColor=szDKGRAY;
      else
         m_szFillColor=szWHITE;
   }
   else
      m_szFillColor="";

   if (bLineRGB) { //Line color listbox
      if (crSaveLineRGB==COLOR_BLACK)
         m_szLineColor=szBLACK;
      else
      if (crSaveLineRGB==COLOR_WHITE)
         m_szLineColor=szWHITE;
      else
      if (crSaveLineRGB==COLOR_LTGRAY)
         m_szLineColor=szLTGRAY;
      else
      if (crSaveLineRGB==COLOR_MDGRAY)
         m_szLineColor=szMDGRAY;
      else
      if (crSaveLineRGB==COLOR_DKGRAY)
         m_szLineColor=szDKGRAY;
      else
         m_szLineColor=szBLACK;
   }
   else
      m_szLineColor="";

   if (bTextRGB) {
      if (crSaveTextRGB==COLOR_BLACK)
         m_szTextColor=szBLACK;
      else
      if (crSaveTextRGB==COLOR_WHITE)
         m_szTextColor=szWHITE;
      else
      if (crSaveTextRGB==COLOR_LTGRAY)
         m_szTextColor=szLTGRAY;
      else
      if (crSaveTextRGB==COLOR_MDGRAY)
         m_szTextColor=szMDGRAY;
      else
      if (crSaveTextRGB==COLOR_DKGRAY)
         m_szTextColor=szDKGRAY;
      else
         m_szTextColor=szBLACK;
   }
   else
      m_szTextColor="";

   m_bCBDrawBorder=bPen;
   m_bRBFillColor=bFillColor;
   m_bRBFillTrans=bFillTrans;

   if (!bFillObj) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   if (!bTextObj) {
     GetLBTextColor().EnableWindow(FALSE);
     GetSTTextColor().EnableWindow(FALSE);
   }

   if (bAllOleObjs) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   CDialog::OnInitDialog();

   ModifyStyleEx(0, WS_EX_CONTEXTHELP);  /////// puts "?" button in the dialog box.

   return TRUE;
}


//------------------------------------------------------------------------
void CObjPropDlg::OnOK()
{
    BOOL bTrans;
    int  nThickness = (int)GetDlgItemInt(IDC_LB_THICKNESS, &bTrans);

    if (!bTrans || nThickness < 0 || nThickness > wStandardLineSizes[ARR_SIZE(wStandardLineSizes)-1]) 
    {
        CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_INVALID_THICKNESS);
        GetLBThickness().SetFocus();
        return;
    }

    CDialog::OnOK();
}




#ifdef GRID
//------------------------------------------------------------------------
// CGridSettingsDlg dialog
//------------------------------------------------------------------------
CGridSettingsDlg::CGridSettingsDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CGridSettingsDlg::IDD, pParent)
{
   CDrawView* pView = CDrawView::GetView();
   if (pView) {
      m_bRBSmall=(pView->m_iGridSize==GRID_SMALL);
      m_bRBMedium=(pView->m_iGridSize==GRID_MEDIUM);
      m_bRBLarge=(pView->m_iGridSize==GRID_LARGE);
      m_bCBViewGrid=pView->m_bGrid;
      m_bCBSnapToGrid=pView->m_bSnapToGrid;
   }
   else
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
}


void CGridSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGridSettingsDlg)
    DDX_Check(pDX, IDC_RB_SMALL, m_bRBSmall);
    DDX_Check(pDX, IDC_RB_MEDIUM, m_bRBMedium);
    DDX_Check(pDX, IDC_RB_LARGE, m_bRBLarge);
    DDX_Check(pDX, IDC_CB_VIEWGRID, m_bCBViewGrid);
    DDX_Check(pDX, IDC_CB_SNAPTOGRID, m_bCBSnapToGrid);
        //}}AFX_DATA_MAP
}

//------------------------------------------------------------------------
BOOL CGridSettingsDlg::OnInitDialog()
{
   return CDialog::OnInitDialog();
}
#endif

LRESULT CGridSettingsDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{
    SetLastError(0);
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return 0;
}


///////#ifdef ENABLE_HELP
LRESULT CGridSettingsDlg::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
{
    SetLastError(0);

    ::HtmlHelp( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return( 0 );
}
//////////#endif




//-----------------------------------------------------------------------
int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType, int msgid)
{
   if (sz==NULL && msgid==-1)
      return 0;

   CString lpszCaption;
   CString lpszText;
   CString temp;

   lpszCaption.LoadString(IDS_MESSAGE);

   if (sz==NULL)
       lpszText.LoadString(msgid);
   else
       lpszText = sz;
   
   if (((CDrawApp*)AfxGetApp())->IsInConvertMode() )
   {
       //
       // we don't want to show pop up's in case of coversion of CPE's to COV's
       //
       return IDOK;
   }
   return ::AlignedMessageBox(CWnd::GetFocus()->GetSafeHwnd(), lpszText, lpszCaption, nType);
}

int 
AlignedAfxMessageBox( 
    LPCTSTR lpszText, 
    UINT    nType, 
    UINT    nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    if (((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // we don't want to show pop up's in case of coversion of CPE's to COV's
        //
        return IDOK;
    }
    return AfxMessageBox(lpszText, nType, nIDHelp);
}

int 
AlignedAfxMessageBox( 
    UINT nIDPrompt, 
    UINT nType, 
    UINT nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }
    
    if ( ((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // we don't want to show pop up's in case of coversion of CPE's to COV's
        //
        return IDOK;
    }

    return AfxMessageBox(nIDPrompt, nType, nIDHelp);
}




//--------------------------------------------------------------------------
//  SPLASH TIPS DIALOG
//--------------------------------------------------------------------------
CSplashTipsDlg::CSplashTipsDlg(BOOL bRandomTip, CWnd* pWnd /*=NULL*/)
   : CDialog(CSplashTipsDlg::IDD),
   m_bRandomTip(bRandomTip)
{
        //{{AFX_DATA_INIT(CSplashTipsDlg)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}



//--------------------------------------------------------------------------
void CSplashTipsDlg::OnPrevTip()
{
    if (m_iCurrentTip>1)
       m_iCurrentTip--;
    else
       m_iCurrentTip=TOTAL_TIPS;

    CString sz;
    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
void CSplashTipsDlg::OnNextTip()
{
    if (m_iCurrentTip<TOTAL_TIPS)
       m_iCurrentTip++;
    else
       m_iCurrentTip=1;

    CString sz;
    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
HBRUSH CSplashTipsDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
        int dlg_id;

        dlg_id = pWnd->GetDlgCtrlID();

#ifndef WIN32S
        if( dlg_id != IDC_CK_SHOWTIPS )
                {
                if( (nCtlColor == CTLCOLOR_STATIC)||(dlg_id == IDC_TIPWINDOW) )
                        {
                        pDC->SetTextColor( GetSysColor( COLOR_INFOTEXT ) );
                        pDC->SetBkMode( TRANSPARENT );
                return( (HBRUSH)::GetSysColorBrush( COLOR_INFOBK ) );
                        }
                }
#endif

        return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

//--------------------------------------------------------------------------
void CSplashTipsDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSplashTipsDlg)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}

void CSplashTipsDlg::OnOK()
{
	AfxGetApp()->WriteProfileString(TIPSECTION,TIPENTRY,(GetShowTips()->GetCheck()==1 ? _T("YES"):_T("NO") ));
		
	HKEY hKey;
	//
	// saving next tip number in registry
	//
	hKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_WRITE);
	if (hKey)
	{
		SetRegistryDword(hKey, REGVAL_NEXT_COVERPAGE_TIP, m_iCurrentTip);
		RegCloseKey(hKey);
	}

    CDialog::OnOK();
}

//--------------------------------------------------------------------------
BOOL 
CSplashTipsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    CenterWindow();
    CString sz;

    sz.LoadString(IDS_DIDYOUKNOW);
    GetTitle()->SetWindowText(sz);


	HKEY hKey;
	//
	// loading next tip number from registry
	//
	hKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_READ);
	if (hKey)
	{
		m_iCurrentTip = (GetRegistryDword(hKey, REGVAL_NEXT_COVERPAGE_TIP) % TOTAL_TIPS) + 1;
		RegCloseKey(hKey);
	}
	else
	{
		m_iCurrentTip = 1;
	}
 
    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);

    sz = AfxGetApp()->GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
    GetShowTips()->SetCheck(sz==_T("YES"));

    // set fonts for tips window
    LOGFONT lf;
    (GetTitle()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_BOLD;
    m_tipstitle_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TITLE)->SetFont(&m_tipstitle_font);

    (GetTips()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_NORMAL;
    m_tips_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TIP)->SetFont(&m_tips_font);

    return TRUE;
}


#define CY_SHADOW   4
#define CX_SHADOW   4

//--------------------------------------------------------------------------
void CBigIcon::SizeToContent()
{
   // get system icon size
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   // a big icon should be twice the size of an icon + shadows
        SetWindowPos(NULL, 0, 0, cxIcon*2 + CX_SHADOW + 4, cyIcon*2 + CY_SHADOW + 4,
                SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
}


//--------------------------------------------------------------------------
void CBigIcon::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
   CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
   ASSERT(pDC != NULL);

   CRect rect;
   GetClientRect(rect);
   int cxClient = rect.Width();
   int cyClient = rect.Height();

   // load icon
   HICON hicon = AfxGetApp()->LoadIcon(IDR_AWCPETYPE);
   if (hicon == NULL)
        return;

   // draw icon into off-screen bitmap
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   CBitmap bitmap;
   if (!bitmap.CreateCompatibleBitmap(pDC, cxIcon, cyIcon))
        return;
   CDC dcMem;
   if (!dcMem.CreateCompatibleDC(pDC))
        return;
   CBitmap* pBitmapOld = dcMem.SelectObject(&bitmap);
   if (pBitmapOld == NULL)
        return;

   // blt the bits already on the window onto the off-screen bitmap
   dcMem.StretchBlt(0, 0, cxIcon, cyIcon, pDC,
        2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4, SRCCOPY);

   // draw the icon on the background
   dcMem.DrawIcon(0, 0, hicon);

   // draw border around icon
   CPen pen;
   pen.CreateStockObject(BLACK_PEN);
   CPen* pPenOld = pDC->SelectObject(&pen);
   pDC->Rectangle(0, 0, cxClient-CX_SHADOW, cyClient-CY_SHADOW);
   if (pPenOld)
        pDC->SelectObject(pPenOld);

   // draw shadows around icon
   CBrush br;
   br.CreateStockObject(DKGRAY_BRUSH);
   rect.SetRect(cxClient-CX_SHADOW, CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);
   rect.SetRect(CX_SHADOW, cyClient-CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);

   // draw the icon contents
   pDC->StretchBlt(2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4,
        &dcMem, 0, 0, cxIcon, cyIcon, SRCCOPY);
}


//--------------------------------------------------------------------------
BOOL CBigIcon::OnEraseBkgnd(CDC*)
{
   return TRUE;
}



//--------------------------------------------------------------------------
CMyPageSetupDialog::CMyPageSetupDialog(CWnd* pParentWnd) : CMyCommonDialog(pParentWnd)
{

    m_hLib=NULL;
    m_pPageSetupDlg=NULL;
        memset(&m_psd, 0, sizeof(m_psd));
        m_psd.lStructSize = sizeof(PAGESETUPDLG);
        m_psd.Flags |= PSD_DISABLEMARGINS;
        m_psd.hInstance = AfxGetInstanceHandle();


    UINT OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
        m_hLib = ::LoadLibrary(TEXT("comdlg32.dll"));
    if (m_hLib!=NULL) {
#ifdef UNICODE
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgW");
#else
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgA");
#endif
        if (m_pPageSetupDlg==NULL)
           CPEMessageBox(MSG_ERROR_NOPAGESETUP, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUP);
        }
        else
        CPEMessageBox(MSG_ERROR_NOPAGESETUPDLL, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUPDLL);
    ::SetErrorMode (OldErrMode);
}







//--------------------------------------------------------------------------
CMyPageSetupDialog::~CMyPageSetupDialog()
{
    if (m_hLib)
       ::FreeLibrary(m_hLib);
}

//--------------------------------------------------------------------------
INT_PTR CMyPageSetupDialog::DoModal()
{
        ASSERT_VALID(this);
        ASSERT(m_pPageSetupDlg != NULL);

        m_psd.hwndOwner = PreModal();
        INT_PTR nResult = m_pPageSetupDlg(&m_psd);
        PostModal();


        return nResult;
}


//---------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CMyPrintDlg, CPrintDialog)

//---------------------------------------------------------------------------
CMyPrintDlg::CMyPrintDlg(BOOL bPrintSetupOnly, DWORD dwFlags, CWnd* pParentWnd) :
        CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
}

//---------------------------------------------------------------------------

BOOL CMyPrintDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
        return (Default() != 0);
}

//---------------------------------------------------------------------------

CMyCommonDialog::CMyCommonDialog( CWnd* pParentWnd ) :
       CCommonDialog( pParentWnd )
{
}

BOOL CMyCommonDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (Default() != 0);
}

//----------------------------------------------------------------------------
CMyFontDialog::CMyFontDialog( LPLOGFONT lplfInitial,
                              DWORD dwFlags,
                              CDC* pdcPrinter,
                              CWnd * pParentWnd) :
                 CFontDialog( lplfInitial, dwFlags, pdcPrinter, pParentWnd )
{
}
//----------------------------------------------------------------------------
CMyFontDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (Default() != 0);
}
//----------------------------------------------------------------------------
CMyOleInsertDialog::CMyOleInsertDialog(DWORD dwFlags, CWnd* pParentWnd ) :
        COleInsertDialog( dwFlags, pParentWnd )
{
}

//---------------------------------------------------------------------------
CMyOleInsertDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    //// return Default();   /// Worked in the other dialog boxes, but here it just
                             /// flashed the item we want temporarily and then threw
                             /// the faxcover help contents up.  BAD!!

    ::WinHelp( (HWND)(pHelpInfo->hItemHandle),
                        TEXT("mfcuix.hlp"),
                        HELP_WM_HELP,
                        (ULONG_PTR)(LPSTR)aOleDlgHelpIDs ) ;

    return 0;


}
//---------------------------------------------------------------------------

//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CObjPropDlg, CDialog)
   //{{AFX_MSG_MAP(CObjPropDlg)
   ON_LBN_SELCHANGE(IDC_LB_FILLCOLOR, OnSelChangeFillColor)
   ON_MESSAGE( WM_HELP, OnWM_HELP )
   ON_WM_CONTEXTMENU()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef GRID
BEGIN_MESSAGE_MAP(CGridSettingsDlg, CDialog)
    //{{AFX_MSG_MAP(CGridSettingsDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
   ON_MESSAGE( WM_HELP, OnWM_HELP )
/////#ifdef ENABLE_HELP
   ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////#endif
END_MESSAGE_MAP()
#endif

BEGIN_MESSAGE_MAP(CSplashTipsDlg, CDialog)
   //{{AFX_MSG_MAP(CSplashTipsDlg)
   ON_WM_CTLCOLOR()
   ON_BN_CLICKED(IDC_B_NEXTTIP, OnNextTip)
   ON_BN_CLICKED(IDC_B_PREVTIP, OnPrevTip)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CBigIcon, CButton)
        //{{AFX_MSG_MAP(CBigIcon)
        ON_WM_DRAWITEM()
        ON_WM_ERASEBKGND()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_MESSAGE_MAP(CMyPrintDlg, CPrintDialog)
        //{{AFX_MSG_MAP(CMyPrintDlg)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyCommonDialog, CCommonDialog)
        //{{AFX_MSG_MAP(CMyCommonDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyOleInsertDialog, COleInsertDialog)
        //{{AFX_MSG_MAP(CMyOleInsertDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyFontDialog, CFontDialog)
        //{{AFX_MSG_MAP(CMyFontDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\mainfrm.h ===
//---------------------------------------------------------------------------
// MAINFRM.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __MAINFRM_H__
#define __MAINFRM_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

class CSizeComboBox : public CComboBox
{
        int m_nLogVert;
public:
        void EnumFontSizes(CString& szFontName);
        static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf,
                LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
        void InsertSize(int nSize);
};



class CStyleBar : public CToolBar
{
public:
        CComboBox       m_cboxFontName;
        CSizeComboBox   m_cboxFontSize;
        CFont       m_font;
protected:
        virtual BOOL PreTranslateMessage(MSG* pMsg);
};

class CDrawApp;

class CMainFrame : public CFrameWnd
{
        DECLARE_DYNCREATE(CMainFrame)
public:
    CStyleBar   m_StyleBar;
        CToolBar    m_DrawBar;
        CStatusBar  m_wndStatusBar;

        CMainFrame();
        virtual ~CMainFrame();
        virtual void ActivateFrame( int nCmdShow = - 1 );

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
   HMENU m_mainmenu;
   int m_iTop;
   int m_iSecond;
   HICON m_toolbar_icon;

   BOOL CreateDrawToolBar();
   BOOL CreateStyleBar();

   afx_msg void OnMenuSelect(UINT, UINT, HMENU);
   afx_msg void OnInitMenu(CMenu* pPopupMenu);
   afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
   afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
   afx_msg void OnShowTips();
   afx_msg void OnDropDownFontName();
   afx_msg void OnDropDownFontSize();
   afx_msg void OnUpdateHelp(CCmdUI* pCmdUI);
   virtual BOOL PreTranslateMessage(MSG* pMsg);

   void PopupText();
   void EnumFontSizes(CString& szFontName);

        //{{AFX_MSG(CMainFrame)
   afx_msg LRESULT OnAWCPEActivate(WPARAM wParam, LPARAM lParam);
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        //}}AFX_MSG
///#ifdef ENABLE_HELP ////
///        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        afx_msg void OnHelp();
        afx_msg LRESULT OnWM_HELP(WPARAM wParam, LPARAM lParam);
        afx_msg BOOL OnQueryOpen( void );

   DECLARE_MESSAGE_MAP()
};



#endif // #ifndef __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\faxprop.h ===
//=============================================================================
// FAXPROP.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=============================================================================
#ifndef __FAXPROP_H__
#define __FAXPROP_H__


//--------------------------------------------------------------------------
class CProp
{
public:
   WORD m_wR_CAPT;
   WORD m_wR_PROP;
   CString m_szPropName;
   CString m_szCaption;
   WORD m_wPropDefLen;
   WORD m_wPropDefLines;
   ULONG m_lPropIndex;
   CProp(WORD wR_PROP, WORD wPropDefLen, WORD wPropDefLines,WORD wR_CAPT,
     ULONG lPropIndex);
};

/*
class CFaxPropMap;

class CFaxPropMapIterator
{
   CFaxPropMapIterator(CFaxPropMap& faxmap);
private:
   CFaxPropMap* currentlink;
   CFaxPropMap* prevlink
   CFaxPropMap& theMap;
}
*/


//--------------------------------------------------------------------------
class CFaxPropMap
{
public:
   static CMapWordToPtr m_PropMap;

//   CFaxProp();
//   void GetPropValue(WORD propid, CString& szPropValue);
   void GetCaption(WORD propid, CString& szCaption);
//   void GetPropName(WORD propid, CString& szPropName);
   void GetPropString(WORD propid, CString& szPropName);
   WORD GetPropDefLines(WORD propid);
   WORD GetPropDefLength(WORD propid);

protected:
//   friend class CFaxPropMapIterator;
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
	void get_message_note( void );
};



#endif   //#ifndef __FAXPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\faxprop.cpp ===
//---------------------------------------------------------------------------
// faxprop.cpp -
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains dictionary for fax properties for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 3/8/95       Added stuff for handling notes on cpe
// 3/21/95      Added stuff for updating pages-sent property with notes
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#define PROP_LENGTH_ADJUSTMENT 7  // 4 wasn't enough.  Needed because some characters are wider than average.

CMapWordToPtr CFaxPropMap::m_PropMap;


CProp::CProp(
    WORD wR_PROP,
    WORD wPropDefLen,
    WORD wPropDefLines,
    WORD wR_CAPT,
    ULONG lPropIndex
    ) : m_lPropIndex(lPropIndex)
{
    m_wR_PROP=wR_PROP;
    m_szPropName.LoadString(wR_PROP);
    m_wR_CAPT=wR_CAPT;
    m_szCaption.LoadString(wR_CAPT);
    //
    // m_wPropDefLen must exceed # of chars in m_szPropName in ALL LANGUAGES. a-juliar, 9-10-96
    //
    int StringLength = max( 0, m_szPropName.GetLength() + PROP_LENGTH_ADJUSTMENT ) ;
    m_wPropDefLen = max( (WORD)StringLength, wPropDefLen ) ;
    m_wPropDefLines=wPropDefLines;

    CFaxPropMap::m_PropMap[m_wR_PROP]=this;
}


//----------------------------------------------------------------------------
void CFaxPropMap::GetCaption(WORD propid, CString& szCaption)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetCaption:  property not found\n"));
      return;
   }

   szCaption = ((CProp*)pProp)->m_szCaption;
}


//----------------------------------------------------------------------------
//used to retrieve either a value or the property name
//----------------------------------------------------------------------------
void CFaxPropMap::GetPropString(WORD propid, CString& szPropValue)
{
   SCODE sc;
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      szPropValue = _T("");
      TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property id not found in table\n"));
      return;
   }

   CProp* pCProp=(CProp*)pProp;
   if (pCProp==NULL) {
       TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property key not found in dictionary\n"));
       szPropValue=_T("");
       return;
   }

   if ( (theApp.m_dwSesID!=0) && theApp.m_pIawcpe ) {
       ULONG temp= pCProp->m_wPropDefLines*pCProp->m_wPropDefLen + 1;
           ULONG lLen=0;
           WORD wtemp;

        if( propid == IDS_PROP_MS_NOTE )
                        {
                        szPropValue = _T("");
                        get_message_note();
                        return;
                        }

       if (propid!=IDS_PROP_MS_NOPG) {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, NULL);    //get length of property
          if (sc != S_OK) {
             TRACE(TEXT("AWCPE: GetPropString--unable to fetch length; GetProp != S_OK(%lx); prop:'%#8x'"),sc,pCProp->m_lPropIndex);
             TRACE1("; caption: '%s'",pCProp->m_szCaption);
                 TRACE1("; defaulting to length: '%i'\n",temp);
                 lLen=temp;
              }
          else
             if (lLen<=0 || lLen>10*temp) {
                    TRACE1("AWCPE: GetPropString--unreasonable length from GetProp(), prop: '%#8x'",pCProp->m_lPropIndex);
                TRACE1("; caption: '%s'",pCProp->m_szCaption);
                TRACE1("; fetched: '%i'",lLen);
                    TRACE1("; defaulting to length: '%i'\n",temp);
                    lLen=temp;
                 }
           }
       else {
              lLen=10;
           }

       LPTSTR BASED_CODE szTemp = ::new TCHAR[lLen];

       if( propid == IDS_PROP_MS_NOPG )
                {
                // IDS_PROP_MS_NOPG does not count the coverpage
                sc = theApp.m_pIawcpe->
                                GetProp(pCProp->m_lPropIndex, &lLen, (void*)&wtemp);

                wtemp += 1; // count the cover page
                wsprintf(szTemp,TEXT("%i"), wtemp );
                }
           else
        {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, szTemp);
                }

       if (sc !=S_OK) {    //failed to get property from transport interface
          szPropValue = _T("");
              TRACE1("AWCPE: GetPropString--unable to fetch value (prop:'%#8x')",pCProp->m_lPropIndex);
          TRACE(TEXT("; GetProp != S_OK; defaulting to blank property\n"));
       }
           else {
           szPropValue = szTemp;
           TRACE1("AWCPE: (%i",propid);
           TRACE1(",%#8x)\t",pCProp->m_lPropIndex);
           TRACE1("caption: '%s'\t",pCProp->m_szCaption);
               TRACE1("value: '%s'\n",szPropValue);
           }

           if (szTemp!=NULL)
              ::delete [] szTemp;
   }
   else {
       szPropValue = pCProp->m_szPropName;
   }

}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLines(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetNumLines:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLines;
}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLength(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetPropLength:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLen;
}




//----------------------------------------------------------------------------
void  CFaxPropMap::get_message_note( void )
        {

        if( !theApp.m_note_wasread )
                theApp.read_note();


        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\ntonly.h ===
#include <string.h>

#define _mbsncmp(x,y,z)      strncmp((LPSTR)x,(LPSTR)y,z)
#define _mbsstr(x,y)         (unsigned char*)strstr((LPSTR)x,(LPSTR)y)
#define _mbstok(x,y)         strtok((LPSTR)x,(LPSTR)y)
#define _mbscmp(x,y)         strcmp((LPSTR)x,(LPSTR)y)
#define _mbslen(x)           strlen((LPSTR)x)
#define _mbscpy(x,y)         strcpy((LPSTR)x,(LPSTR)y)
#define _mbsupr(x)           strupr((LPSTR)x)
#define _mbscat(x,y)         strcat((LPSTR)x,(LPSTR)y)
#define _mbschr(x,y)         strchr((LPSTR)x,y)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\mainfrm.cpp ===
//--------------------------------------------------------------------------
// MAINFRM.CPP
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main frame class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#ifndef NT_BUILD
#include <mbstring.h>
#endif

#include <htmlhelp.h>
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"
#include "faxutil.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

   //constants for font name & size
const int INDEX_FONTNAME = 10 ;
const int INDEX_FONTSIZE = 12 ;
const int NAME_WIDTH  = 170 ;
const int NAME_HEIGHT = 140 ;
const int SIZE_WIDTH  = 60 ;
const int SIZE_HEIGHT = 140 ;

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

extern UINT NEAR WM_AWCPEACTIVATE;

WORD nFontSizes[] = { 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE stylebar[] =
{
    // same order as in the bitmap 'stylebar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
    ID_STYLE_BOLD,
    ID_STYLE_ITALIC,
    ID_STYLE_UNDERLINE,
        ID_SEPARATOR,
    ID_STYLE_LEFT,
    ID_STYLE_CENTERED,
    ID_STYLE_RIGHT,
};


static UINT BASED_CODE drawtools[] =
{
    // same order as in the bitmap 'drawtools.bmp'
    ID_DRAW_SELECT,
    ID_DRAW_TEXT,
    ID_DRAW_LINE,
    ID_DRAW_RECT,
    ID_DRAW_ROUNDRECT,
    ID_DRAW_POLYGON,
    ID_DRAW_ELLIPSE,
        ID_SEPARATOR,
    ID_OBJECT_MOVETOFRONT,
    ID_OBJECT_MOVETOBACK,
        ID_SEPARATOR,
    ID_LAYOUT_SPACEACROSS,
    ID_LAYOUT_SPACEDOWN,
        ID_SEPARATOR,
    ID_LAYOUT_ALIGNLEFT,
    ID_LAYOUT_ALIGNRIGHT,
    ID_LAYOUT_ALIGNTOP,
    ID_LAYOUT_ALIGNBOTTOM,
#ifdef GRID
    ID_SNAP_TO_GRID,
#endif

};


static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,
    ID_INDICATOR_POS1,                          //id for object coordinates
    ID_INDICATOR_POS2,                          //id for object coordinates
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


//--------------------------------------------------------------------------
CMainFrame::CMainFrame()
{
        m_toolbar_icon = theApp.LoadIcon( IDI_TBARICON );
}


//--------------------------------------------------------------------------
CMainFrame::~CMainFrame()
{
}



//--------------------------------------------------------------------------
BOOL CALLBACK
        EnumFamProc( ENUMLOGFONT* lpnlf,NEWTEXTMETRIC* lpntm,int iFontType,
                        LPARAM lpData)
        {
        if( lpnlf == NULL )
                return FALSE;

        CComboBox* pCBox = (CComboBox*)lpData;

        if( pCBox )
                {
                if( _tcsncmp((lpnlf->elfLogFont.lfFaceName),
                                           TEXT("@"), 1 )
                        == 0 )
                        {
                        /*
                                This is a "vertical" font. Nobody wants to show these,
                                so filter them out and keep going.
                         */
                        return( TRUE );
                        }

                if( pCBox->
                                FindStringExact(0,(LPCTSTR)(lpnlf->elfLogFont.lfFaceName))
                                ==CB_ERR )
/***CHANGES FOR M8 bug 2988***/
                        {
                        pCBox->AddString( (LPCTSTR)(lpnlf->elfLogFont.lfFaceName) );

                        // look for fonts that matches system charset and keep
                        // first one in sort order
                        if( theApp.m_last_logfont.lfCharSet
                                        == lpnlf->elfLogFont.lfCharSet )
                                {
                                if( _tcscmp((lpnlf->elfLogFont.lfFaceName),
                                                      (theApp.m_last_logfont.lfFaceName) )
                                        < 0 )
                                        {
                                        // found it, copy the whole thing
                                        theApp.m_last_logfont = lpnlf->elfLogFont;
                                        }
                                }
                        }
/*****************************/
                }

        return TRUE ;

        }



//--------------------------------------------------------------------------
BOOL CMainFrame::CreateStyleBar()
{
   if (!m_StyleBar.Create(this,WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE, ID_VIEW_STYLEBAR) ||
       !m_StyleBar.LoadBitmap(theApp.IsRTLUI() ? IDR_STYLEBAR_RTL : IDR_STYLEBAR) ||
       !m_StyleBar.SetButtons(stylebar, sizeof(stylebar)/sizeof(UINT))) 
   {
        TRACE(TEXT("AWCPE.MAINFRM.CREATESTYLEBAR: Failed to create stylebar\n"));
        return FALSE;
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_STYLE);
   m_StyleBar.SetWindowText(sz);

   CRect rect;
   int cyFit;
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME, ID_FONT_NAME, TBBS_SEPARATOR, NAME_WIDTH );
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTNAME, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + NAME_WIDTH;
   rect.bottom = rect.top + NAME_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontName.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN|CBS_SORT,
        rect, &m_StyleBar, ID_FONT_NAME))  {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;      // fail to create
   }

   // Create font size combo box on toolbar
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE, ID_FONT_SIZE, TBBS_SEPARATOR, SIZE_WIDTH);
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTSIZE, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + SIZE_WIDTH;
   rect.bottom = rect.top + SIZE_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontSize.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN,
        rect, &m_StyleBar, ID_FONT_SIZE)) {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;
   }

/***CHANGES FOR M8 bug 2988***/
   // Fill font name combobox
//   CClientDC dc(NULL);
//   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   CString strDefaultFont;
//   strDefaultFont.LoadString(IDS_DEFAULT_FONT);
   LOGFONT system_logfont;
   CFont   system_font;

   system_font.Attach( ::GetStockObject(SYSTEM_FONT) );
   system_font.GetObject( sizeof (LOGFONT), (LPVOID)&system_logfont );
   theApp.m_last_logfont = system_logfont;

   // Fill font name combobox and find default font
   CClientDC dc(NULL);
   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   // enum changed theApp.m_last_logfont to first font that had same
   // charset as system font. Use face name for default

   theApp.m_last_logfont = system_logfont ;

   strDefaultFont = theApp.m_last_logfont.lfFaceName;

   // Wouldn't it be better to use the font mentioned in the resource file?
   //    5-30-95 a-juliar

   strDefaultFont.LoadString( IDS_DEFAULT_FONT );

   memset(&(theApp.m_last_logfont),0,sizeof(LOGFONT)) ;
   theApp.m_last_logfont.lfHeight = -17;   //LU
   theApp.m_last_logfont.lfWeight = 200; // non-bold font weight
   theApp.m_last_logfont.lfCharSet = DEFAULT_CHARSET;
   theApp.m_last_logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfQuality = DEFAULT_QUALITY;
   theApp.m_last_logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
////   strDefaultFont.LockBuffer();
   _tcsncpy(theApp.m_last_logfont.lfFaceName,strDefaultFont.GetBuffer(0),LF_FACESIZE);
   strDefaultFont.ReleaseBuffer();


/*****************************/


   CString strDefaultBoxFont;
   strDefaultBoxFont.LoadString(IDS_DEFAULT_BOXFONT);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(strDefaultFont);   //load font sizes for default font.



   ////////////////////////////////////////////////////////
   // FIX FOR 3718
   //
   // DBCS funny buisness font code for name and size comboboxes
   // removed and replaced with the following four lines. These
   // comboboxes are set to use the same font as menus do. This
   // automatically takes care of all localization headaches (knock
   // on wood...).
   //
   m_StyleBar.m_font.Attach(::GetStockObject(DEFAULT_GUI_FONT));
   m_StyleBar.m_cboxFontName.SetFont(&m_StyleBar.m_font);
   m_StyleBar.m_cboxFontSize.SetFont(&m_StyleBar.m_font);
/***NEEDED FOR M8 bug 2988***/
   m_StyleBar.m_cboxFontName.SelectString(-1,strDefaultFont);
   ////////////////////////////////////////////////////////




/***CHANGES FOR M8 bug 2988***/
//   m_StyleBar.m_cboxFontSize.SetCurSel(2);
/********the blow is since M8*****/
        int initial_fontsize_index;
        CString size_str;
        int font_size;

        if( (initial_fontsize_index =
                        m_StyleBar.m_cboxFontSize.FindStringExact( -1, TEXT("10") ))
                == CB_ERR )
                initial_fontsize_index = 2;

        m_StyleBar.m_cboxFontSize.SetCurSel( initial_fontsize_index );

        m_StyleBar.m_cboxFontSize.GetWindowText( size_str );
    font_size = _ttoi( size_str );
        if( font_size <= 0 || font_size > 5000 )
                font_size = 10;

        theApp.m_last_logfont.lfHeight = -MulDiv(font_size,100,72);
        theApp.m_last_logfont.lfWidth = 0;
/*****************************/

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
    theApp.m_default_logfont = theApp.m_last_logfont;
////////////////////////////////


   #if _MFC_VER >= 0x0300
      m_StyleBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_StyleBar);
      m_StyleBar.SetBarStyle(m_StyleBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   UINT id, style;
   int image;
   int idx = m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);

   return TRUE ;
}


BOOL CMainFrame::CreateDrawToolBar()
{
   if (!m_DrawBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE, ID_VIEW_DRAWBAR) ||
       !m_DrawBar.LoadBitmap(theApp.IsRTLUI() ? IDR_DRAWTOOL_RTL : IDR_DRAWTOOL) ||
       !m_DrawBar.SetButtons(drawtools, sizeof(drawtools)/sizeof(UINT))) 
   {
        TRACE(TEXT("Failed to create toolbar\n"));
        return -1;      // fail to create
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_DRAWING);
   m_DrawBar.SetWindowText(sz);

   #if _MFC_VER >= 0x0300
      m_DrawBar.EnableDocking(CBRS_ALIGN_ANY);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_DrawBar);
      m_DrawBar.SetBarStyle(m_DrawBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   return TRUE;
}

//-----------------------------------------------------------------------------------
LRESULT CMainFrame::OnAWCPEActivate(WPARAM wParam, LPARAM lParam)
{
   SetForegroundWindow();
   if (IsIconic())
       ShowWindow(SW_NORMAL);
   return 1L;
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontName()
{
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontSize()  
{
   CString szFontName;

   CString sz;
   m_StyleBar.m_cboxFontSize.GetWindowText(sz);

   int iSel = m_StyleBar.m_cboxFontName.GetCurSel();
   if ( iSel != CB_ERR)
       m_StyleBar.m_cboxFontName.GetLBText(iSel,szFontName);
   else
       m_StyleBar.m_cboxFontName.GetWindowText(szFontName);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(szFontName);
   if (sz.GetLength()>0)
       m_StyleBar.m_cboxFontSize.SetWindowText(sz);
}


//-----------------------------------------------------------------------------------
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (((CDrawApp*)AfxGetApp())->IsInConvertMode())
    {
        WINDOWPLACEMENT pl;
        pl.length = sizeof(pl);
        GetWindowPlacement(&pl);
        pl.showCmd = SW_SHOWMINIMIZED | SW_HIDE;
        SetWindowPlacement(&pl);
    }
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }
    if (!CreateStyleBar())
    {    
        return -1;
    }
    if (!CreateDrawToolBar())
    {
        return -1;
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,sizeof(indicators)/sizeof(UINT)))  
    {
        TRACE(TEXT("Failed to create status bar\n"));
        return -1;      // fail to create
    }
    //
    // Set toolbar (small) icon
    //
    SendMessage( WM_SETICON, (WPARAM)TRUE, (LPARAM)m_toolbar_icon );
    return 0;
}   // CMainFrame::OnCreate

//----------------------------------------------------------------------------------------------
void CMainFrame::OnShowTips()
{
   CSplashTipsDlg m_SplashDlg;
    m_SplashDlg.DoModal();
}


//----------------------------------------------------------------------------------------------
BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
   BOOL bReturn;

   CDrawView *pView = CDrawView::GetView();
   if (!pView)
   {
       return FALSE;
   }

   if (pView && (pView->m_pObjInEdit))
   {
       bReturn = FALSE;
   }
   else
   {
       bReturn = CFrameWnd::PreTranslateMessage(pMsg);
   }

   return bReturn;
}


///////////#ifdef ENABLE_HELP  ///// Just Do It!
//----------------------------------------------------------------------------------------------
//LRESULT CMainFrame::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
//{
//    ::WinHelp( (HWND)wParam,  AfxGetApp()->m_pszHelpFilePath,  HELP_CONTEXTMENU,
//               (DWORD)(LPSTR)cshelp_map );
//
//        return( 0 );
//}
//////////////#endif


//----------------------------------------------------------------------------------------------
LRESULT CMainFrame::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{   
    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM))
    {
        return 0;
    }

    SetLastError(0);
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return 0;
}
 
//----------------------------------------------------------------------------------------------
void CMainFrame::OnHelp()
{
    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM))
    {
        return;
    }

    SetLastError(0);
    ::HtmlHelp( m_hWnd,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }
}

void 
CMainFrame::OnUpdateHelp(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM));
}

//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenu(CMenu* pPopupMenu)
{
   m_mainmenu = ::GetMenu(m_hWnd);
   CFrameWnd::OnInitMenu(pPopupMenu);
}

//----------------------------------------------------------------------------------------------
// This is mostly code lifted from MFC's WINFRM.CPP.  It's to enable the app to display text for
// POPUPs.
//----------------------------------------------------------------------------------------------
void CMainFrame::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hmenu)
{
    // set the tracking state (update on idle)
    if (nFlags == 0xFFFF) 
    {
        // cancel menu operation (go back to idle now)
        CFrameWnd* pFrameWnd = GetTopLevelFrame();
        ASSERT_VALID(pFrameWnd);

        if (pFrameWnd && !pFrameWnd->m_bHelpMode)
        {
            m_nIDTracking = AFX_IDS_IDLEMESSAGE;
        }
        else
        {
            m_nIDTracking = AFX_IDS_HELPMODEMESSAGE;
        }

        SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
        ASSERT(m_nIDTracking == m_nIDLastMessage);

        // update right away
        CWnd* pWnd = GetMessageBar();
        if (pWnd != NULL)
        {
            pWnd->UpdateWindow();
        }
    }
    else if ( nFlags & (MF_SEPARATOR|MF_MENUBREAK|MF_MENUBARBREAK))      
    {
        m_nIDTracking = 0;
    }
    else if (nFlags & (MF_POPUP)) 
    {    
        //added this to track POPUPs
        if (hmenu==m_mainmenu) 
        {
            m_iTop=nItemID;
            m_iSecond=-1;
        }
        else
        {
            m_iSecond=nItemID;
        }

        PopupText();
    }
    else if (nItemID >= 0xF000 && nItemID < 0xF1F0) 
    { 
        // max of 31 SC_s
        // special strings table entries for system commands
        m_nIDTracking = ID_COMMAND_FROM_SC(nItemID);
        ASSERT(m_nIDTracking >= AFX_IDS_SCFIRST &&
        m_nIDTracking < AFX_IDS_SCFIRST + 31);
    }
    else if (nItemID >= AFX_IDM_FIRST_MDICHILD)  
    {
        // all MDI Child windows map to the same help id
        m_nIDTracking = AFX_IDS_MDICHILD;
    }
    else 
    {
        // track on idle
        m_nIDTracking = nItemID;
    }

    // when running in-place, it is necessary to cause a message to
    //  be pumped through the queue.
    if (m_nIDTracking != m_nIDLastMessage && GetParent() != NULL) 
    {
        PostMessage(WM_KICKIDLE);
    }
}


//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
   CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
}


//----------------------------------------------------------------------------------------------
void CMainFrame::PopupText()
{
   if (m_iTop<0 || m_iTop > 10 || m_iSecond > 10 || m_iSecond < -1)
      return;

   CString sz;

   if (m_iTop==0) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FILE_MENU);
   }
   else
   if (m_iTop==1) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_EDIT_MENU);
   }
   else
   if (m_iTop==2) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_VIEW_MENU);
   }
   else
   if (m_iTop==3) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_INSERT_MENU);
      else
      if (m_iSecond==0)
         sz.LoadString(IDP_RECIPIENT);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_SENDER);
      else
      if (m_iSecond==2)
         sz.LoadString(IDP_MESSAGE);
   }
   else
   if (m_iTop==4) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FORMAT_MENU);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_ALIGN_TEXT);
   }
   else
   if (m_iTop==5) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_LAYOUT_MENU);
      else
      if (m_iSecond==3)
         sz.LoadString(IDP_ALIGN_OBJECTS);
      else
      if (m_iSecond==4)
         sz.LoadString(IDP_SPACE_EVEN);
      else
      if (m_iSecond==5)
         sz.LoadString(IDP_CENTER_PAGE);
   }
   else
   if (m_iTop==6) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_HELP_MENU);
   }

   m_wndStatusBar.SetPaneText(0,sz);
}

#ifdef _DEBUG
//----------------------------------------------------------------------------------------------
void CMainFrame::AssertValid() const
{
        CFrameWnd::AssertValid();
}



//----------------------------------------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
{
        CFrameWnd::Dump(dc);
}

#endif //_DEBUG




BOOL CMainFrame::OnQueryOpen( void )
        {

    return( !(theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0)) );

        }



void CMainFrame::ActivateFrame( int nCmdShow )
        {

    if( theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0) )
                {
                //::MessageBeep( 0xffffffff );
                ShowWindow( SW_HIDE );
                }
        else
                CFrameWnd::ActivateFrame( nCmdShow );

        }




//--------------------------------------------------------------------------------------------
BOOL CStyleBar::PreTranslateMessage(MSG* pMsg)
{
         if (!( (pMsg->message == WM_KEYDOWN) && ((pMsg->wParam == VK_RETURN)||(pMsg->wParam == VK_ESCAPE)) ))
                return CToolBar::PreTranslateMessage(pMsg);

     CDrawView* pView = CDrawView::GetView();
         if (pView==NULL)
                return CToolBar::PreTranslateMessage(pMsg);

     if (pMsg->wParam == VK_ESCAPE) {
        pView->m_bFontChg=FALSE;
        pView->UpdateStyleBar();
        if (pView->m_pObjInEdit)
           pView->m_pObjInEdit->m_pEdit->SetFocus();
                else
           pView->SetFocus();
                return CToolBar::PreTranslateMessage(pMsg);
         }

         HWND hwndFontNameEdit=::GetDlgItem(m_cboxFontName.m_hWnd,1001);
         if (pMsg->hwnd == hwndFontNameEdit) {
                  pView->OnSelchangeFontName();
         }
         else {
       HWND hwndFontSizeEdit=::GetDlgItem(m_cboxFontSize.m_hWnd,1001);
       if (pMsg->hwnd == hwndFontSizeEdit)
          pView->OnSelchangeFontSize();
         }

     return CToolBar::PreTranslateMessage(pMsg);
}


//--------------------------------------------------------------------------
void CSizeComboBox::EnumFontSizes(CString& szFontName)
{
   CClientDC dc(NULL);
   m_nLogVert=dc.GetDeviceCaps(LOGPIXELSY);

   ResetContent();

   ::EnumFontFamilies(dc.GetSafeHdc(), szFontName, (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}


//--------------------------------------------------------------------------
void CSizeComboBox::InsertSize(int nSize)
{
    ASSERT(nSize > 0);

    TCHAR buf[10];
    wsprintf(buf,TEXT("%d"),nSize);

    if (FindStringExact(-1,buf) == CB_ERR)  {
            AddString(buf);
    }
}

//-------------------------------------------------------------------
BOOL CALLBACK CSizeComboBox::EnumSizeCallBack(LOGFONT FAR*, LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
   CSizeComboBox* pThis = (CSizeComboBox*)lpv;
   TCHAR buf[10];                                //????????????????????????????????
   if ( (FontType & TRUETYPE_FONTTYPE) ||
        !( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) ) ) {

        if (pThis->GetCount() != 0)
           pThis->ResetContent();

        for (int i = 0; nFontSizes[i]!=0; i++) {
            wsprintf(buf,TEXT("%d"),nFontSizes[i]);      //????????????????????Not changed. J.R.
                pThis->AddString(buf);
        }
            return FALSE;
   }

   int pointsize = MulDiv( (lpntm->tmHeight - lpntm->tmInternalLeading),72,pThis->m_nLogVert);
   pThis->InsertSize(pointsize);
   return TRUE;
}


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
   ON_WM_CREATE()
   ON_UPDATE_COMMAND_UI(ID_VIEW_STYLEBAR, CFrameWnd::OnUpdateControlBarMenu)
   ON_UPDATE_COMMAND_UI(ID_VIEW_DRAWBAR,  CFrameWnd::OnUpdateControlBarMenu)
   ON_COMMAND_EX(ID_VIEW_STYLEBAR, CFrameWnd::OnBarCheck)
   ON_COMMAND_EX(ID_VIEW_DRAWBAR,  CFrameWnd::OnBarCheck)
   //}}AFX_MSG_MAP
   ON_COMMAND(ID_SHOW_TIPS, OnShowTips)
   ON_CBN_DROPDOWN(ID_FONT_NAME, OnDropDownFontName)
   ON_CBN_DROPDOWN(ID_FONT_SIZE, OnDropDownFontSize)
   ON_WM_INITMENUPOPUP()
   ON_WM_MENUSELECT()
   ON_WM_INITMENU()

   ON_COMMAND(ID_DEFAULT_HELP, OnHelp)    /// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)     /// added by a-juliar, 6-18-96
   ON_REGISTERED_MESSAGE(WM_AWCPEACTIVATE, OnAWCPEActivate)
   ON_WM_QUERYOPEN()
// These next three lines were commented out in the code I inherited.  Let's try them!
// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
   ON_COMMAND(ID_HELP, OnHelp)
   ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)

/////////#ifdef ENABLE_HELP  ///////
////        ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////////#endif

   ON_COMMAND(ID_HELP_INDEX, OnHelp)
   ON_MESSAGE( WM_HELP, OnWM_HELP )
   ON_UPDATE_COMMAND_UI(ID_HELP_INDEX, OnUpdateHelp)

END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Cover Page Editor resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [2100 - 2999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#include <CoverPgId.h>

#define IDR_AWCPETYPE                   2100 
#define IDR_AWCPEDOC                    2101 
#define IDR_AWCPETYPE_CNTR_IP           2102 
#define IDR_STYLEBAR                    2103 
#define IDR_DRAWTOOL                    2104 
#define ID_GRIDDOT                      2105 
#define IDR_STYLEBAR_RTL                2106 
#define IDR_DRAWTOOL_RTL                2107 
#define ID_VIEW_STYLEBAR                2109
#define ID_TEXT                         2110 
#define ID_VIEW_DRAWBAR                 2112 
#define ID_VIEW_GRIDLINES               2113 
#define IDC_B_PREVTIP                   2114 
#define IDC_B_NEXTTIP                   2115 
#define IDD_SPLASHTIPS                  2116 
#define IDD_CPE_ABOUTBOX                2117 
#define IDP_BUSY                        2118 
#define IDD_OBJ_PROP                    2119 
#define IDP_OLE_INIT_FAILED             2120 
#define IDD_GRID_SETTINGS               2121 
#define IDP_FAILED_TO_CREATE            2122 
#define IDC_WEIGHT                      2123 
#define IDC_PENCIL                      2124 
#define IDC_NOFILL                      2125 
#define ID_CANCEL_EDIT                  2126 
#define ID_SNAP_TO_GRID                 2127 
#define IDI_TBARICON                    2128 
#define IDC_MOVE                        2129 
#define IDC_CB_VIEWGRID                 2130 
#define IDC_CB_SNAPTOGRID               2131 
#define IDC_RB_SMALL                    2132 
#define IDC_RB_MEDIUM                   2133 
#define IDC_RB_LARGE                    2134 
#define IDC_ST_TEXTCOLOR                2135 
#define IDC_GRP_FILLCOLOR               2136 
#define IDC_STA_TIP                     2140 
#define IDC_CK_SHOWTIPS                 2141 
#define IDC_STA_TITLE                   2143 
#define IDC_ICO_TIPS                    2144 
#define IDC_ST_THICKNESS                2145 
#define IDC_TIPWINDOW                   2146 
#define IDC_ST_COLOR                    2147 
#define IDI_TIPS                        2149 
#define ID_VIEW_GRID                    2150 
#define ID_OBJECT_LINECOLOR             2151 
#define ID_OBJECT_FILLCOLOR             2152 
#define ID_OBJECT_MOVETOFRONT           2153 
#define ID_OBJECT_MOVETOBACK            2154 
#define ID_OBJECT_MOVEFORWARD           2155 
#define ID_OBJECT_MOVEBACK              2156 
#define ID_LAYOUT_ALIGNLEFT             2157 
#define ID_LAYOUT_ALIGNRIGHT            2158 
#define ID_LAYOUT_ALIGNTOP              2159 
#define ID_LAYOUT_ALIGNBOTTOM           2160 
#define ID_LAYOUT_ALIGNHORZCENTER       2161 
#define ID_LAYOUT_ALIGNVERTCENTER       2162 
#define ID_LAYOUT_SPACEACROSS           2163 
#define ID_LAYOUT_SPACEDOWN             2164 
#define ID_LAYOUT_CENTERWIDTH           2165 
#define ID_LAYOUT_CENTERHEIGHT          2166 
#define ID_VIEW_PAPERCOLOR              2167 
#define ID_VIEW_SHOWOBJECTS             2168 
#define ID_EDIT_PROPERTIES              2169 
#define ID_DRAW_SELECT                  2170 
#define ID_DRAW_TEXT                    2171 
#define ID_DRAW_LINE                    2172 
#define ID_DRAW_RECT                    2173 
#define ID_DRAW_ROUNDRECT               2174 
#define ID_DRAW_POLYGON                 2175 
#define ID_DRAW_ELLIPSE                 2176 
#define ID_STYLE_BOLD                   2177 
#define ID_STYLE_ITALIC                 2178 
#define ID_STYLE_UNDERLINE              2179 
#define ID_STYLE_LEFT                   2180 
#define ID_STYLE_CENTERED               2181 
#define ID_STYLE_RIGHT                  2182 
#define ID_FONT_NAME                    2183 
#define ID_FONT_SIZE                    2184 
#define ID_FONT                         2185 
#define ID_SHOW_TIPS                    2189 
#define IDC_COMM_STATIC                 2190 
#define IDC_COMM_GROUPBOX               2191 
#define ID_MAPI_RECIP_NAME              2192 
#define ID_MAPI_RECIP_FAXNUM            2193 
#define ID_MAPI_RECIP_COMPANY           2194 
#define ID_MAPI_RECIP_ADDRESS           2195 
#define ID_MAPI_RECIP_TITLE             2196 
#define ID_MAPI_RECIP_DEPT              2197 
#define ID_MAPI_RECIP_OFFICELOC         2198 
#define ID_MAPI_RECIP_HMTELENUM         2199 
#define ID_MAPI_RECIP_OFTELENUM         2200 
#define ID_MAPI_RECIP_TOLIST            2201 
#define ID_MAPI_RECIP_CCLIST            2202 
#define ID_MAPI_SENDER_NAME             2203 
#define ID_MAPI_SENDER_FAXNUM           2204 
#define ID_MAPI_SENDER_COMPANY          2205 
#define ID_MAPI_SENDER_ADDRESS          2206 
#define ID_MAPI_SENDER_TITLE            2207 
#define ID_MAPI_SENDER_DEPT             2208 
#define ID_MAPI_SENDER_OFFICELOC        2209 
#define ID_MAPI_SENDER_HMTELENUM        2210 
#define ID_MAPI_SENDER_OFTELENUM        2211 
#define ID_MAPI_MSG_SUBJECT             2212 
#define ID_MAPI_MSG_TIMESENT            2213 
#define ID_MAPI_MSG_NUMPAGES            2214 
#define ID_MAPI_MSG_ATTACH              2215 
#define ID_MAPI_MSG_BILLCODE            2216 
#define ID_MAPI_MSG_FAXTEXT             2217 
#define ID_MAPI_RECIP_CITY              2218 
#define ID_MAPI_RECIP_STATE             2219 
#define ID_MAPI_RECIP_ZIPCODE           2220 
#define ID_MAPI_RECIP_COUNTRY           2221 
#define ID_MAPI_RECIP_POBOX             2222 
#define ID_MAPI_MSG_NOTE                2223 
#define IDS_OLD_FILE_FILTER             2224 
#define ID_TOOLBAR_STYLE                2225 
#define ID_TOOLBAR_DRAWING              2226 
#define IDS_CAPT_RP_NAME                2227 
#define IDS_CAPT_RP_FXNO                2228 
#define IDS_CAPT_RP_COMP                2230 
#define IDS_CAPT_RP_ADDR                2231 
#define IDS_CAPT_RP_TITL                2232 
#define IDS_CAPT_RP_DEPT                2233 
#define IDS_CAPT_RP_OFFI                2234 
#define IDS_CAPT_RP_HTEL                2235 
#define IDS_CAPT_RP_OTEL                2236 
#define IDS_CAPT_RP_TOLS                2237 
#define IDS_CAPT_RP_CCLS                2238 
#define IDS_CAPT_SN_NAME                2239 
#define IDS_CAPT_SN_FXNO                2240 
#define IDS_CAPT_SN_COMP                2241 
#define IDS_CAPT_SN_ADDR                2242 
#define IDS_CAPT_SN_TITL                2243 
#define IDS_CAPT_SN_DEPT                2244 
#define IDS_CAPT_SN_OFFI                2245 
#define IDS_CAPT_SN_HTEL                2246 
#define IDS_CAPT_SN_OTEL                2247 
#define IDS_CAPT_MS_SUBJ                2248 
#define IDS_CAPT_MS_TSNT                2249 
#define IDS_CAPT_MS_NOPG                2250 
#define IDS_CAPT_MS_NOAT                2251 
#define IDS_CAPT_MS_BCOD                2252 
#define IDS_PROP_MS_TEXT                2253 
#define IDS_CAPT_MS_TEXT                2254 
#define IDS_CAPT_RP_CITY                2255 
#define IDS_CAPT_RP_STAT                2256 
#define IDS_CAPT_RP_ZIPC                2257 
#define IDS_CAPT_RP_CTRY                2258 
#define IDS_CAPT_RP_POBX                2259 
#define IDS_CAPT_MS_NOTE                2260 
#define IDP_FILE_MENU                   2261 
#define IDP_EDIT_MENU                   2262 
#define IDP_VIEW_MENU                   2263 
#define IDP_INSERT_MENU                 2264 
#define IDP_FORMAT_MENU                 2265 
#define IDP_LAYOUT_MENU                 2266 
#define IDP_HELP_MENU                   2267 
#define IDP_SPACE_EVEN                  2268 
#define IDP_CENTER_PAGE                 2269 
#define IDP_ALIGN_TEXT                  2270 
#define IDP_RECIPIENT                   2271 
#define IDP_SENDER                      2272 
#define IDP_MESSAGE                     2273 
#define IDP_ALIGN_OBJECTS               2274 
#define IDP_INVALID_THICKNESS           2275 
#define IDP_OLE_STATIC_OBJECT           2276 
#define IDS_DISK_SPACE_UNAVAIL          2277 
#define IDS_DISK_SPACE                  2278 
#define IDS_MATH_COPR_NOTPRESENT        2279 
#define IDS_MATH_COPR_PRESENT           2280 
#define IDS_PHYSICAL_MEM                2281 
#define IDS_INVALID_FILE                2282 
#define IDS_CORRUPT_FILE                2283 
#define IDS_MAWF_NAME                   2284 
#define IDS_AWF_NAME                    2285 
#define IDS_APP_NAME                    2286 
#define IDS_INFORMATION_MESSAGE         2287 
#define IDS_WARNING_MESSAGE             2288 
#define IDS_CRITICAL_MESSAGE            2289 
#define IDS_MODULE_NAME                 2290 
#define MAWF_E_GENERIC                  2291 
#define IDS_IDNUM                       2292 
#define IDS_MESSAGE                     2293 
#define IDS_MENU_CUT                    2294 
#define IDS_MENU_COPY                   2295 
#define IDS_MENU_PASTE                  2296 
#define IDS_MENU_FONT                   2297 
#define IDS_MENU_ALIGNTEXT              2298 
#define IDS_MENU_ALIGNLEFT              2299 
#define IDS_MENU_ALIGNCENTER            2300 
#define IDS_MENU_ALIGNRIGHT             2301 
#define IDS_MENU_PROPERTIES             2302 
#define IDS_MENU_MOVETOFRONT            2303 
#define IDS_MENU_SENDTOBACK             2304 
#define IDS_MENU_VIEWSTYLEBAR           2305 
#define IDS_MENU_VIEWDRAWINGBAR         2306 
#define IDS_MENU_VIEWSTATUSBAR          2307 
#define IDS_MENU_VIEWGRIDLINES          2308 
#define IDS_TIP_BASE                    2309 
#define IDS_TIP1                        2310 
#define IDS_TIP2                        2311 
#define IDS_TIP3                        2312 
#define IDS_TIP4                        2313 
#define IDS_TIP5                        2314 
#define IDS_TIP6                        2315 
#define IDS_TIP7                        2316 
#define IDS_TIP8                        2317 
#define IDS_TIP9                        2318 
#define IDS_TIP10                       2319 
#define IDS_TIP11                       2320 
#define IDS_TIP12                       2321 
#define IDS_TIP13                       2322 
#define IDS_TIP14                       2323 
#define IDS_TIP15                       2324 
#define IDS_TIP16                       2325 
#define IDS_TIP17                       2326 
#define IDS_TIP18                       2327 
#define IDS_TIP19                       2328 
#define IDS_MISSING_FILE                2329 
#define IDS_NOPAGESETUP                 2330 
#define IDS_NOPAGESETUPDLL              2331 
#define IDS_FRIENDLY_TYPE_NAME          2332 
#define IDS_DIDYOUKNOW                  2333 
#define IDS_INFO_NOFAXPROP              2334 
#define ID_COLOR_BLACK                  2335 
#define ID_COLOR_WHITE                  2336 
#define ID_COLOR_LTGRAY                 2337 
#define ID_COLOR_DKGRAY                 2338 
#define ID_COLOR_MDGRAY                 2339 
#define ID_INDICATOR_POS1               2340 
#define IDS_NOMOREUNDO                  2341 
#define IDS_INFO_DRAWPOLY               2342 
#define ID_INDICATOR_POS2               2343 
#define IDC_CB_DRAWBORDER               2344 
#define IDS_DEFAULT_FONT                2345 
#define IDC_LB_THICKNESS                2346 
#define IDS_DEFAULT_BOXFONT             2347 
#define IDC_LB_LINECOLOR                2348 
#define IDC_RB_FILLTRANS                2349 
#define IDC_RB_FILLCOLOR                2350 
#define IDC_TXTLB_FILLCOLOR             2351 
#define IDC_LB_FILLCOLOR                2352 
#define IDC_LB_TEXTCOLOR                2353 
#define ID_MAPI_MSG_BODY                2354 
#define IDS_SAVE_AS_TOO_LONG            2355 
#define IDS_CP_FILTER_FORMAT            2356 
#define IDS_ERR_NO_HTML_HELP            2357 
#define IDC_ABOUT_CPE_PRODUCT			2358
#define IDC_ABOUT_CPE_VERSION			2359
#define IDC_ABOUT_CPE_COPYRIGHT			2360
#define IDS_CPE_VERSION_FORMAT			2361
#define ID_MAPI_SENDER_EMAIL			2362
#define IDS_CAPT_SN_EMAL				2363

//////////////////////////////////////////////////////
//                                                  //
// Fax Cover Page Editor resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [2100 - 2999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF

!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXCOVER)
TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows
C_DEFINES=$(C_DEFINES) /D_NT_SUR_ /DNO_STRICT /DWIN4 /DNT4 /DNT_BUILD

NOMFCPDB=1
USE_NATIVE_EH=1

TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib    \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\oleaut32.lib    \
  $(BASEDIR)\public\sdk\lib\*\comctl32.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\htmlhelp.lib

SOURCES=\
  ..\awcpe.cpp      \
  ..\cntritem.cpp   \
  ..\cpedoc.cpp     \
  ..\cpeedt.cpp     \
  ..\cpeobj.cpp     \
  ..\cpetool.cpp    \
  ..\cpevw.cpp      \
  ..\dialogs.cpp    \
  ..\faxprop.cpp    \
  ..\mainfrm.cpp    \
  ..\version.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE 2.0 support
#include <afxodlgs.h>       // MFC OLE 2.0 dialog support
#include <oledlg.h>         // MFC OLE dialog support
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\faxcover\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\coverpgid.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Cover Page Editor resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [2000 - 2100]                                    //
//                                                  //
//////////////////////////////////////////////////////


#ifndef _COVER_PAGE_ID_H_
#define _COVER_PAGE_ID_H_

//
// Cover page text box IDs.
//
#define IDS_PROP_RP_NAME                2001 // Recipient Name
#define IDS_PROP_RP_FXNO                2003 // Recipient Fax Number
#define IDS_PROP_RP_COMP                2005 // Recipient's Company
#define IDS_PROP_RP_ADDR                2007 // Recipient's Street Address
#define IDS_PROP_RP_TITL                2009 // Recipient's Title
#define IDS_PROP_RP_DEPT                2011 // Recipient's Department
#define IDS_PROP_RP_OFFI                2013 // Recipient's Office Location
#define IDS_PROP_RP_HTEL                2015 // Recipient's Home Telephone #
#define IDS_PROP_RP_OTEL                2017 // Recipient's Office Telephone #
#define IDS_PROP_RP_TOLS                2019 // To: List
#define IDS_PROP_RP_CCLS                2021 // Cc: List
#define IDS_PROP_SN_NAME                2023 // Sender Name
#define IDS_PROP_SN_FXNO                2025 // Sender Fax #
#define IDS_PROP_SN_COMP                2027 // Sender's Company
#define IDS_PROP_SN_ADDR                2029 // Sender's Address
#define IDS_PROP_SN_TITL                2031 // Sender's Title
#define IDS_PROP_SN_DEPT                2033 // Sender's Department
#define IDS_PROP_SN_OFFI                2035 // Sender's Office Location
#define IDS_PROP_SN_HTEL                2037 // Sender's Home Telephone #
#define IDS_PROP_SN_OTEL                2039 // Sender's Office Telephone #
#define IDS_PROP_MS_SUBJ                2041 // Subject
#define IDS_PROP_MS_TSNT                2043 // Time Sent
#define IDS_PROP_MS_NOPG                2045 // # of Pages
#define IDS_PROP_MS_NOAT                2047 // # of Attachments
#define IDS_PROP_MS_BCOD                2049 // Billing Code
#define IDS_PROP_RP_CITY                2053 // Recipient's City
#define IDS_PROP_RP_STAT                2055 // Recipient's State
#define IDS_PROP_RP_ZIPC                2057 // Recipient's Zip Code
#define IDS_PROP_RP_CTRY                2059 // Recipient's Country
#define IDS_PROP_RP_POBX                2061 // Recipient's Post Office Box
#define IDS_PROP_MS_NOTE                2063 // Note
#define IDS_PROP_SN_EMAL				2065 // Sender's E-mail

//////////////////////////////////////////////////////
//                                                  //
// Fax Cover Page Editor resource ID file           //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [2000 - 2100]                                    //
//                                                  //
//////////////////////////////////////////////////////

#endif // _COVER_PAGE_ID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\critsec.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CritSec.h

Abstract:

    This file provides declaration of the service
    Critical Section wrapper class.

Author:

    Oded Sacher (OdedS)  Nov, 2000

Revision History:

--*/

#ifndef _FAX_CRIT_SEC_H
#define _FAX_CRIT_SEC_H

#include "faxutil.h"


/************************************
*                                   *
*         CFaxCriticalSection        *
*                                   *
************************************/
class CFaxCriticalSection
{
public:
    CFaxCriticalSection () : m_bInit(FALSE) {}
    ~CFaxCriticalSection ()
    {
        SafeDelete();
        return;
    }

    BOOL Initialize ();
#if (_WIN32_WINNT >= 0x0403)
    BOOL InitializeAndSpinCount (DWORD dwSpinCount = (DWORD)0x80000000);
#endif
    VOID SafeDelete ();


#if DBG
    LONG LockCount() const
    {
        return m_CritSec.LockCount;
    }


    HANDLE OwningThread() const
    {
        return m_CritSec.OwningThread;
    }
#endif //#if DBG


    LPCRITICAL_SECTION operator & ()
    {
        return &m_CritSec;
    }


private:
    CRITICAL_SECTION m_CritSec;
    BOOL             m_bInit;
};  // CFaxCriticalSection

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\efsputil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    efsputil.h

--*/

#ifndef _EFSPUTIL_H_
#define _EFSPUTIL_H_

typedef struct tag_FSPI_BRAND_INFO
{
    DWORD   dwSizeOfStruct;
    LPWSTR  lptstrSenderTsid;
    LPWSTR  lptstrRecipientPhoneNumber;
    LPWSTR  lptstrSenderCompany;
    SYSTEMTIME tmDateTime;
} FSPI_BRAND_INFO;

typedef const FSPI_BRAND_INFO * LPCFSPI_BRAND_INFO;
typedef FSPI_BRAND_INFO * LPFSPI_BRAND_INFO;


#ifdef __cplusplus
extern "C" {
#endif


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctstrFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo
);

HRESULT
WINAPI
FaxRenderCoverPage(
  LPCTSTR lpctstrTargetFile,
  LPCFSPI_COVERPAGE_INFO lpCoverPageInfo,
  LPCFSPI_PERSONAL_PROFILE lpRecipientProfile,
  LPCFSPI_PERSONAL_PROFILE lpSenderProfile,
  SYSTEMTIME tmSentTime,
  LPCTSTR lpctstrBodyTiff
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\dword2str.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Dword2Str.h

Abstract:

    This file provides declaration for converting dwords to strings.
    Used in event logs.

Author:

    Oded Sacher (OdedS)  Dec, 200q

Revision History:

--*/

#ifndef _FAX_DWORD_2_STR__H
#define _FAX_DWORD_2_STR__H

#include "faxutil.h"


/************************************
*                                   *
*         Dword2String				*
*                                   *
************************************/

class Dword2String
{
public:
	Dword2String(DWORD dw) : m_dw(dw)
	{
		m_tszConvert[0] = TEXT('\0');
	}

	LPCTSTR Dword2Decimal() 
	{
		_stprintf(m_tszConvert, TEXT("%ld"), m_dw);
		return m_tszConvert;
	}

	LPCTSTR Dword2Hex()
	{
		_stprintf(m_tszConvert, TEXT("0x%08X"),m_dw);
		return m_tszConvert;
	}	

private:
	DWORD m_dw;
	TCHAR m_tszConvert[12];
};

#define DWORD2DECIMAL(dwVal)	Dword2String(dwVal).Dword2Decimal()

            
#define DWORD2HEX(dwVal)		Dword2String(dwVal).Dword2Hex()		


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\debugex.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Debug.h

Abstract:

    Interface for the CDebug class.

Author:

    Eran Yariv (EranY)  Jul, 1999

Revision History:

--*/

#if !defined(AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_)
#define AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined(DEBUG)
    #if defined(_DEBUG)
        #define DEBUG
    #elif defined(DBG)
        #define DEBUG
    #endif
#endif

//
// Remove previous declarations:
//
#if defined(ASSERTION)
    #undef ASSERTION
#endif

#ifdef VERBOSE
    #undef VERBOSE
#endif

#ifdef ASSERTION_FAILURE
    #undef ASSERTION_FAILURE
#endif

#include <FaxDebug.h>
//
// Bit-mask of errors / messages :
//
typedef enum 
{
	DBG_MSG                 = 0x00000001,    // General messages (not warnings or errors)
    DBG_WARNING             = 0x00000002,    // Warnings
    GENERAL_ERR             = 0x00000004,
	TAPI_MSG				= 0x00000008,
	ASSERTION_FAILED        = 0x00000010,    // Debug messages are displayed when an assertion fails
    FUNC_TRACE              = 0x00000020,    // Function entry / exit traces
	MEM_ERR                 = 0x00000040,    // Errors start from here...
    COM_ERR                 = 0x00000080,
    RESOURCE_ERR            = 0x00000100,
    EXCEPTION_ERR           = 0x00000200,
    RPC_ERR                 = 0x00000400,
    WINDOW_ERR              = 0x00000800,
    FILE_ERR                = 0x00001000,
    SECURITY_ERR            = 0x00002000,
    REGISTRY_ERR            = 0x00004000,
    PRINT_ERR               = 0x00008000,
    SETUP_ERR               = 0x00010000,
    NET_ERR                 = 0x00020000,
    SCM_ERR                 = 0x00040000,
	STARTUP_ERR             = 0x00080000,
    
    DBG_ERRORS_ONLY         = 0xFFFFFFDC,   // everything but DBG_MSG,FUNC_TRACE,DBG_WARNING
    DBG_ERRORS_WARNINGS     = 0xFFFFFFDE,   // everything but DBG_MSG,FUNC_TRACE
    DBG_ALL                 = 0xFFFFFFFF
}   DbgMsgType;

#ifdef ENABLE_FRE_LOGGING
#define ENABLE_LOGGING
#endif

#ifdef DEBUG 
#define ENABLE_LOGGING
#endif

#ifdef ENABLE_LOGGING

#define DEFAULT_DEBUG_MASK          ASSERTION_FAILED
#define DEFAULT_FORMAT_MASK         DBG_PRNT_ALL_TO_STD

// use these in your debugging sessions
#define DBG_ENTER       CDebug debugObject
#define VERBOSE         debugObject.Trace

#ifndef DEBUG
#define DebugBreak() ;
#endif

#define ASSERTION_FAILURE   {                                               \
                                debugObject.DbgPrint  (ASSERTION_FAILED,    \
                                        TEXT(__FILE__),                     \
                                        __LINE__,                           \
                                        TEXT("ASSERTION FAILURE!!!"));      \
                                DebugBreak();                               \
							}

#define ASSERTION(x)        if (!(x)) ASSERTION_FAILURE

#define CALL_FAIL(t,szFunc,hr)                                  \
    debugObject.DbgPrint(t,                                     \
    TEXT(__FILE__),                                             \
    __LINE__,                                                   \
    TEXT("Call to function %s failed with 0x%08X"),             \
    szFunc,                                                     \
    hr);         
//////////////////////////////////////////

// use these to cofigure the debug output
#define SET_DEBUG_MASK(m)           CDebug::SetDebugMask(m)
#define SET_FORMAT_MASK(m)          CDebug::SetFormatMask(m)
#define SET_DEBUG_FLUSH(m)          CDebug::SetDebugFlush(m)

#define GET_DEBUG_MASK              CDebug::GetDebugMask()
#define GET_FORMAT_MASK             CDebug::GetFormatMask()

#define MODIFY_DEBUG_MASK(a,b)      CDebug::ModifyDebugMask(a,b)
#define MODIFY_FORMAT_MASK(a,b)     CDebug::ModifyFormatMask(a,b)

#define IS_DEBUG_SESSION_FROM_REG   CDebug::DebugFromRegistry()

#define OPEN_DEBUG_LOG_FILE(f)      CDebug::OpenLogFile(f)
#define CLOSE_DEBUG_LOG_FILE        CDebug::CloseLogFile()
#define SET_DEBUG_FILE_HANDLE(h)    CDebug::SetLogFile(h)
//////////////////////////////////////////

#ifndef _DEBUG_INDENT_SIZE
#define _DEBUG_INDENT_SIZE      3
#endif // #ifndef _DEBUG_INDENT_SIZE

class CDebug  
{
public:

    CDebug (LPCTSTR lpctstrModule) :
        m_ReturnType (DBG_FUNC_RET_UNKNOWN)
    {
        EnterModule (lpctstrModule);
    }

    CDebug (LPCTSTR lpctstrModule,
            LPCTSTR lpctstrFormat,
            ...) :
        m_ReturnType (DBG_FUNC_RET_UNKNOWN)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
    }

    CDebug (LPCTSTR lpctstrModule, HRESULT &hr)
    {
        EnterModule (lpctstrModule);
        SetHR (hr);
    }

    CDebug (LPCTSTR lpctstrModule,
            HRESULT &hr,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetHR (hr);
    }

    CDebug (LPCTSTR lpctstrModule, DWORD &dw)
    {
        EnterModule (lpctstrModule);
        SetDWRes (dw);
    }

    CDebug (LPCTSTR lpctstrModule, UINT &dw)
    {
        EnterModule (lpctstrModule);
        SetDWRes ((DWORD &)dw);
    }

    CDebug (LPCTSTR lpctstrModule,
            DWORD &dw,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetDWRes (dw);
    }

    CDebug (LPCTSTR lpctstrModule,
            UINT &dw,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetDWRes ((DWORD &)dw);
    }

    CDebug (LPCTSTR lpctstrModule, BOOL &b)
    {
        EnterModule (lpctstrModule);
        SetBOOL (b);
    }

    CDebug (LPCTSTR lpctstrModule,
            BOOL &b,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetBOOL (b);
    }

    virtual ~CDebug();

    static void DbgPrint ( 
        DbgMsgType type,
        LPCTSTR    lpctstrFileName, 
        DWORD      dwLine,
        LPCTSTR    lpctstrFormat,
        ...
    );

    void Trace (
        DbgMsgType type,
        LPCTSTR    lpctstrFormat,
        ...
    );

    static void     ResetIndent()          { InterlockedExchange(&m_sdwIndent,0); }
    static void     Indent()               { InterlockedIncrement(&m_sdwIndent); }
    static void     Unindent();

    // calling any of those functions overrides the registry entries
    // SetDebugMask - overrides the DebugLevelEx entry
    // SetFormatMask - overrides the DebugFormatEx entry
    static void     SetDebugMask(DWORD dwMask);
    static void     SetFormatMask(DWORD dwMask);

    static DWORD    GetDebugMask()  { return m_sDbgMask; }
    static DWORD    GetFormatMask() { return m_sFmtMask; }

    static DWORD    ModifyDebugMask(DWORD dwAdd,DWORD dwRemove);
    static DWORD    ModifyFormatMask(DWORD dwAdd,DWORD dwRemove);
    static void     SetDebugFlush(BOOL fFlush);

    static HANDLE   SetLogFile(HANDLE hFile);
    static BOOL     OpenLogFile(LPCTSTR lpctstrFilename);
    static void     CloseLogFile();

    // returns whether we find debug setting in the registry
    // call this before using SetDebugMask or SetFormatMask to verify 
    // if the registry is being used, so registry will decide on 
    // debug level
    static BOOL DebugFromRegistry();

private:

    static void Print (
        DbgMsgType type,
        LPCTSTR    lpctstrFileName, 
        DWORD      dwLine,
        LPCTSTR    lpctstrFormat,
        va_list    arg_ptr
    );

    void   EnterModuleWithParams (LPCTSTR lpctstrModule, 
                                  LPCTSTR lpctstrFormat, 
                                  va_list arg_ptr);

    void  EnterModule           (LPCTSTR lpctstrModule);

    void  SetHR (HRESULT &hr)           { m_ReturnType = DBG_FUNC_RET_HR; m_phr = &hr; }
    void  SetDWRes (DWORD &dw)          { m_ReturnType = DBG_FUNC_RET_DWORD; m_pDword = &dw; }
    void  SetBOOL (BOOL &b)             { m_ReturnType = DBG_FUNC_RET_BOOL; m_pBool = &b; }

    static LONG     m_sdwIndent;
    static DWORD    m_sDbgMask;                 // a combination of DbgMsgType values
    static DWORD    m_sFmtMask;                 // a combination of DbgMsgFormat values
    static HANDLE   m_shLogFile;
    static BOOL     m_sbMaskReadFromReg;        // Did we already read the debug & format mask from the registry?
    static BOOL     m_sbRegistryExist;          // Do we use debug mask of registry?
    static BOOL     m_sbFlush;                  // Do we run FlushFileBuffer after writing to log file
    static BOOL     ReadMaskFromReg();          // Attempt to read debug & format mask from registry.

    static LPCTSTR GetMsgTypeString(DWORD dwMask);
    static BOOL OutputFileString(LPCTSTR szMsg);

    TCHAR        m_tszModuleName[MAX_PATH];

    typedef enum 
    {   
        DBG_FUNC_RET_UNKNOWN,
        DBG_FUNC_RET_HR,
        DBG_FUNC_RET_DWORD,
        DBG_FUNC_RET_BOOL
    } DbgFuncRetType;

    DbgFuncRetType  m_ReturnType;
    HRESULT        *m_phr;
    DWORD          *m_pDword;
    BOOL           *m_pBool;

};

#define START_RPC_TIME(f)   DWORD dwRPCTimeCheck=GetTickCount();
#define END_RPC_TIME(f)     VERBOSE (DBG_MSG, TEXT("%s took %ld millisecs"), \
                                f, GetTickCount()-dwRPCTimeCheck);

#else   // ENABLE_LOGGING

#define DBG_ENTER                   void(0);
#define VERBOSE                     void(0);
#define ASSERTION_FAILURE           void(0);
#define ASSERTION(x)                void(0);
#define CALL_FAIL(t,szFunc,hr)      void(0);
#define START_RPC_TIME(f)           void(0);
#define END_RPC_TIME(f)             void(0);

#define SET_DEBUG_MASK(m)           void(0);
#define SET_FORMAT_MASK(m)          void(0);

#define GET_DEBUG_MASK              0;
#define GET_FORMAT_MASK             0;

#define MODIFY_DEBUG_MASK(a,b)      0;
#define MODIFY_FORMAT_MASK(a,b)     0;

#define IS_DEBUG_SESSION_FROM_REG   FALSE;

#define OPEN_DEBUG_LOG_FILE(f)      FALSE;
#define CLOSE_DEBUG_LOG_FILE        void(0);
#define SET_DEBUG_FILE_HANDLE(h)    void(0);

#endif  // ENABLE_LOGGING

#endif // !defined(AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\comenum.h ===
//
// common to COM object and Proxy code
//
// GENERAL COMMENT - do not change the order in any of these enum definitions!
//                   pls consult ZviB b4 making any change here

// This file is used in order to generate VB & JS constant files that
// reside on the retail CD. Therefore, there are some conventions regarding
// the comments inside it:
//
// 1. Only C-style comments (slash-asterisk) are included in the generated
//    files. In order to use comments that will not appear, use C++-style
//    ones.
//
// 2. The C-style comments included SHOULD END THE SAME LINE THEY STARTED!!!!
//                                  -----------------------------------------
//
// 3. The PERL scripts that do the conversion put the comments to appropriate
//    form of JS/VB comments.
//
// 4. IN ANY CASE, DO NOT USE BIT MASKS FOR ENUMS!!!
//    You can put the hex value of the bit mask and a C++ comment near it
//    stating why the value is indeed so.
//
// For any issues regarding these enforcements, contact t-nadavr.

// These are retail CD comments
/* To include this file in HTML documents use the following HTML statements: */
/*   using JavaScript: */
/*      <script Language="JScript" src="CometCfg.js"> */
/*      </script> */
/*   using VBScript: */
/*      <script Language="VBScript" src="CometCfg.vbs"> */
/*      </script> */
/* */

/* This file holds VBScript constants that are needed to compensate for the fact */
/* that scripting engines cannot use the enumerated type information stored */
/* in the COM objects' type library. */
/* This file should be included in any VBScript scripts that use the Comet COM */
/* objects. */
/* */

#ifndef __COMENUM_H_
#define __COMENUM_H_

//TEMP from \ui\rwsprop\clustobj.h
typedef enum _RouteTypeEnum
{
    prxRouteNone            = -1,
    prxRouteDirect          =  0,
    prxRouteServer          =  1,
    prxRouteCluster         =  2,
    prxRouteAutoDetect      =  3,
    prxRouteSimpleServer    =  4

}RouteType;

///////////////////////////////////////////////
// @enum PublishRouteType | type of action performed by a publishing rule.

typedef enum _PublishRouteType
{
    prxRouteDiscard = 0,   // @emem Discard the coming requet.
    prxRouteRedirect       // @emem Redirect the request to another computer.
} PublishRouteType;

////////////////////////////////////////////////
// @enum PublishProtocolRedirectionType | the protocol choosed when redirecting a web request.

typedef enum _PublishProtocolRedirectionType
{
    prxSameAsInbound = 0,   // @emem The routed request is done using the same
                            // protocol as that of the inbound request
    prxFTP,                 // @emem The routed request is done using the FTP protocol
    prxHTTP,                // @emem The routed request is done using the HTTP protocol
} PublishProtocolRedirectionType;

/* Type _RouteRuleActionType from IRoutingRule */

/////////////////////////////////////////////////
// @enum RouteRuleActionType | proxy routing behavior

typedef enum _RouteRuleActionType
{
    prxRouteActionNone = 0,    // @emem No action
    prxRouteActionDirect,      // @emem Direct request to Internet.
    prxRouteActionUpstream,    // @emem Send the request to an upstream Comet server or array.
    prxRouteActionAlternate    // @emem Route to any other server.
} RouteRuleActionType;

/* Type _AuthType from ICredentials */

///////////////////////////////////////////////////
// @enum AuthType | Authentication method used for inter server connections

typedef enum _AuthType
{
    prxUiAuthBasic = 0,         // @emem Basic authentication
    prxUiAuthNtlm               // @emem NT Challenge Response authentication
} AuthType;

// code from dfltdata.h
typedef enum _DomainFiltersListType {
    prxDomainFilterDisabled, //              0
    prxDomainFilterDeny,     //              1
    prxDomainFilterGrant     //              2
} DomainFiltersListType;

// from alertdef.h

typedef enum _AlertTypes
{
    prxAlertTypePacketRate = 0,
    prxAlertTypeProtocolViolation,
    prxAlertTypeDiskFull,
    prxNumAlertTypes
} AlertTypes;

// from socksinf.h
///////////////////////////////////////////////////////
// @enum SOCKS_PERMISSION_ACTION | Action taken in a socks rule

typedef enum _SOCKS_PERMISSION_ACTION {


    prxSPermisNoAction = 0,       // @emem No action
    prxSPermisAllow,              // @emem allow the requested connection
    prxSPermisDeny,               // @emem deny the requested connection


} SOCKS_PERMISSION_ACTION;

//////////////////////////////////////////////////////
// @enum SOCKS_PORT_OPERATION | socks rule port criteria

typedef enum _SOCKS_PORT_OPERATION {

    prxSocksOpNop   = 0,        // @emem No criteria
    prxSocksOpEq    = 1,        // @emem Actual port equal to specified port
    prxSocksOpNeq   = 2,        // @emem Actual port not equal to specified port.
    prxSocksOpGt    = 3,        // @emem Actual port greater than specified port
    prxSocksOpLt    = 4,        // @emem Actual port less than specified port
    prxSocksOpGe    = 5,        // @emem Actual port greater or equal to specified port
    prxSocksOpLe    = 6         // @emem Actual port less or equal to specified port

} SOCKS_PORT_OPERATION;

// from clacctyp.h

//////////////////////////////////////////////////////
// @enum WspAccessByType | Winsock Proxy client way of identifying a server
typedef enum _WspAccessByType
{
    prxClientAccessSetByIp,         // @emem Identify by IP
    prxClientAccessSetByName,       // @emem Identify by name
    prxClientAccessSetManual        // @emem Identification set manually in ini file
} WspAccessByType;


// used in client configuration

/////////////////////////////////////////////////////
// @enum DirectDestinationType | type of destination used in browser "bypass" configuration.
typedef enum _DirectDestinationType
{
    prxLocalServersDirectDestination, // @emem All local addresses
    prxIPAddressDirectDestination,    // @emem A destination specified by IP
    prxDomainDirectDestination        // A destination specified by a Domain name.
}   DirectDestinationType;

typedef enum _BackupRouteType
{
    prxBackupRouteDirectToInternet,
    prxBackupRouteViaProxy
} BackupRouteType;

// new def - will be used by logginp.cpp in ui code
typedef enum _MSP_LOG_FORMAT {

    prxLogFormatVerbose=0,
    prxLogFormatRegular=1

} MSP_LOG_FORMAT;


//
// Only in COM object code
//

/////////////////////////////////////////////////////
//@enum SocksAddressType | the way an address of a socks connection is defined
typedef enum _SocksAddressType {

    prxSocksAddressNone = 1,    // @emem No address is defined
    prxSocksAddressIp,          // @emem Address defined by IP
    prxSocksAddressDomain,      // @emem Address defined by domain name
    prxSocksAddressAll          // @emem All addresses are used.


} SocksAddressType;

// proxy code uses different ugly enum that encompasses the enable state
typedef enum MSP_LOG_TYPE {

   prxLogTypeSqlLog=1,
   prxLogTypeFileLog

} MSP_LOG_TYPE;

// in proxy code this is computed on the fly from other data
typedef enum _DomainFilterType {
    prxSingleComputer = 1,
    prxGroupOfComputers,
    prxDomain
} DomainFilterType;

///////////////////////////////////////////////////////////
// @enum CacheExpirationPolicy | defines how soon cached web pages expire.

/* Type _CacheExpirationPolicy from IPrxCache */
typedef enum _CacheExpirationPolicy
{
    prxCachePolicyNotPredefined,          // @emem Not defined
    prxCachePolicyEmphasizeMoreUpdates,   // @emem Cached object exire more quickly.
    prxCachePolicyNoEmphasize,            // @emem Avarege behavior
    prxCachePolicyEmphasizeMoreCacheHits  // @emem Cached objects live longer.

}  CacheExpirationPolicy;


/* Type _ActiveCachingPolicy from IPrxCache */

/////////////////////////////////////////////////////////////
// @enum ActiveCachingPolicy | behavior of the active caching mechanism

typedef enum _ActiveCachingPolicy {
    prxActiveCachingEmphasizeOnFewerNetworkAccesses = 1, // @emem Less active caching is initiated
    prxActiveCachingNoEmphasize,                         // @emem Avarege behavior
    prxActiveCachingEmphasizeOnFasterUserResponse        // @emem More content is activelly cached.

}  ActiveCachingPolicy;


// enums for set sort by
typedef enum _PublishSortCriteria {
   prxPublishSortCriteriaURL = 1,
   prxPublishSortCriteriaRequestPath
} PublishSortCriteria;

typedef enum  _CacheFilterType {
   prxAlwaysCache = 1,
   prxNeverCache
} CacheFilterType;

typedef enum  _CacheFilterSortCriteria {
   prxCacheFilterSortCriteriaURL = 1,
   prxCacheFilterSortCriteriaStatus
} CacheFilterSortCriteria;

/////////////////////////////////////////////////////////////
// @enum PF_FILTER_TYPE | predefined static packet filters

typedef enum _PF_FILTER_TYPE
{
    prxCustomFilterType                 = 1,   // @emem no predefined filter. See custom options
    prxDnsLookupPredefinedType,                // @emem DNS lookup predefined static filter
    prxIcmpAllOutboundPredefinedType,          // @emem ICMP outbound predefined static filter
    prxIcmpPingResponsePredefinedType,         // @emem ICMP ping response predefined static filter
    prxIcmpPingQueryPredefinedType,            // @emem ICMP ping query predefined static filter
    prxIcmpSrcQuenchPredefinedType,            // @emem ICMP source quench predefined static filter
    prxIcmpTimeoutPredefinedType,              // @emem ICMP timeout predefined static filter
    prxIcmpUnreachablePredefinedType,          // @emem ICMP unreachable predefined static filter
    prxPptpCallPredefinedType,                 // @emem PPTP call predefined static filter
    prxPptpReceivePredefinedType,              // @emem PPTP receive predefined static filter
    prxSmtpPredefinedType,                     // @emem SMTP receive predefined static filter
    prxPop3PredefinedType,                     // @emem POP3 predefined static filter
    prxIdentdPredefinedType,                   // @emem Identd predefined static filter
    prxHttpServerPredefinedType,               // @emem HTTP server predefined static filter
    prxHttpsServerPredefinedType,              // @emem HTTPS server predefined static filter
    prxNetbiosWinsClientPredefinedType,        // @emem Netbios WINS predefined static filter
    prxNetbiosAllPredefinedType                // @emem Netbios all predefined static filter
} PF_FILTER_TYPE;

#define MIN_FILTER_TYPE prxCustomFilterType
#define MAX_FILTER_TYPE prxNetbiosAllPredefinedType

//
// type of protocol of the filter
// Keep the following in sync with structure aProtocolIds in file pfbase.h
// Keep the following in sync with the above (should never have to change).
//
//

/////////////////////////////////////////////////////////////////////
// @enum PF_PROTOCOL_TYPE | predefined static packet filters IP ports

typedef enum _PF_PROTOCOL_TYPE
{
    prxPfAnyProtocolIpIndex     = 0,           // @emem Any  protocol
    prxPfIcmpProtocolIpIndex    = 1,           // @emem ICMP protocol
    prxPfTcpProtocolIpIndex     = 6,           // @emem TCP  protocol
    prxPfUdpProtocolIpIndex     = 17           // @emem UDP  protocol
}
    PF_PROTOCOL_TYPE;

#define prxPfCustomProtocol      255
#define MIN_PROTOCOL_TYPE        prxPfAnyProtocolIpIndex
#define MAX_PROTOCOL_TYPE        prxPfUdpProtocolIpIndex

///////////////////////////////////////////////////////
// @enum PF_DIRECTION_TYPE | protocol direction options

typedef enum _PF_DIRECTION_TYPE
{
    prxPfDirectionIndexBoth = 0xC0000000,  // @emem both directions (in and out)
    prxPfDirectionIndexIn   = 0x80000000,  // @emem in direction
    prxPfDirectionIndexOut  = 0x40000000,  // @emem out direction
    prxPfDirectionIndexNone = 0            // @emem none - no direction defined
}
    PF_DIRECTION_TYPE;

#define MIN_DIRECTION_TYPE     1
#define MAX_DIRECTION_TYPE     4

/////////////////////////////////////////
// @enum PF_PORT_TYPE | port type options

typedef enum _PF_PORT_TYPE
{
    prxPfAnyPort=1,              // @emem Any port
    prxPfFixedPort,            // @emem fixed port (followed by port number)
    prxPfDynamicPort           // @emem dynamic port (1024-5000)
}
    PF_PORT_TYPE;

#define MIN_PORT_TYPE      prxPfAnyPort
#define MAX_PORT_TYPE      prxPfDynamicPort

///////////////////////////////////////////////////////////////////
// @enum PF_LOCAL_HOST_TYPE | local host (of packet filter) options

typedef enum _PF_LOCAL_HOST_TYPE
{
    prxPfDefaultProxyExternalIp = 1,     // @emem no host specified (default external IP)
    prxPfSpecificProxyIp,                // @emem specific proxy IP specified
    prxPfInternalComputer                // @emem specific internal computer specified
}
    PF_LOCAL_HOST_TYPE;


///////////////////////////////////////////////////////////////////
// @enum PF_REMOTE_HOST_TYPE | remote host (of packet filter) options

typedef enum _PF_REMOTE_HOST_TYPE
{
    prxPfSingleHost = 1,                 // @emem specific single host specified
    prxPfAnyHost                         // @emem Any host possible
}
    PF_REMOTE_HOST_TYPE;


/////////////////////////////////////////////
// @enum PF_SORT_ORDER_TYPE | PF sort options

typedef enum _PF_SORT_ORDER_TYPE
{
    prxPfSortByDirection = 1,                 // @emem sort by direction
    prxPfSortByProtocol,                      // @emem sort by protocol
    prxPfSortByLocalPort,                     // @emem sort by local port
    prxPfSortByRemotePort,                    // @emem sort by remote port
    prxPfSortByLocalAddress,                  // @emem sort by local address
    prxPfSortByRemoteAddress                  // @emem sort by remote address
}
    PF_SORT_ORDER_TYPE;


/////////////////////////////////////////////
// @enum PF_FILTER_STATUS_TYPE | PF status options

typedef enum _PF_FILTER_STATUS_TYPE
{
    prxFilterNotChanged = 1,                 // @emem No changes happed in the filter
    prxFilterWasAdded,                       // @emem a Packet filter was added
    prxFilterWasRemoved,                     // @emem a Packet filter was removed
    prxFilterWasChanged                      // @emem a Packet filter was changed
}
    PF_FILTER_STATUS_TYPE;

///////////////////////////////////////////////////////////////
// @enum RuleActions | kinds of actions performed when a rule criteria is met.
typedef enum _RuleActions
{
    prxRuleActionPermit,        // @emem Permit access to the requested web page
    prxRuleActionDeny,          // @emem Deny access tothe requested web page
    prxRuleActionRedirect       // @emem Redirect to a specific web page

} RuleActions;

///////////////////////////////////////////////////////////////
// @enum DestinationAddressType | type of a destination definition

typedef enum _DestinationAddressType
{
   prxDestinationTypeDomain,    // @emem Destination defined by domain name
   prxDestinationTypeSingleIP,  // @emem Destination defined by single IP
   prxDestinationTypeIPRange    // @emem Destination defined by an IP range.
} DestinationAddressType;

////////////////////////////////////////////////////////////////
// @enum DestinationSelection | type of destinations reffered to in a rule.
typedef enum _DestinationSelection
{
   prxAllDestinations,           // @emem All destinations
   prxAllInternalDestinations,   // @emem All internal destinations
   prxAllExternalDestinations,   // @emem All external destinations
   prxDestinationSet             // @emem Destinations that are part of a specified set

} DestinationSelection;

//////////////////////////////////////////////////////////
// @enum Days| the days of the week. Used in Schedule Templates
typedef enum _Days
{
  ALL_WEEK = -1,                 // @emem All days in week
  SUN,                           // @emem Sunday
  MON,                           // @emem Monday
  TUE,                           // @emem Tuesday
  WED,                           // @emem Wednesday
  THU,                           // @emem Thursday
  FRI,                           // @emem Friday
  SAT                            // @emem Saturday
} ScheduleDays;

//////////////////////////////////////////////////////////
// @enum Hours | the hours of the day. Used in Schedule Templates

typedef enum _Hours
{
    ALL_DAY=-1,                  // @emem All hours of the day
    AM_0,                        // @emem Midnight
    AM_1,                        // @emem 1 AM
    AM_2,                        // @emem 2 AM
    AM_3,                        // @emem 3 AM
    AM_4,                        // @emem 4 AM
    AM_5,                        // @emem 5 AM
    AM_6,                        // @emem 6 AM
    AM_7,                        // @emem 7 AM
    AM_8,                        // @emem 8 AM
    AM_9,                        // @emem 9 AM
    AM_10,                       // @emem 10 AM
    AM_11,                       // @emem 11 AM
    AM_12,                       // @emem 12 AM
    PM_1,                        // @emem 1 PM
    PM_2,                        // @emem 2 PM
    PM_3,                        // @emem 3 PM
    PM_4,                        // @emem 4 PM
    PM_5,                        // @emem 5 PM
    PM_6,                        // @emem 6 PM
    PM_7,                        // @emem 7 PM
    PM_8,                        // @emem 8 PM
    PM_9,                        // @emem 9 PM
    PM_10,                       // @emem 10 PM
    PM_11                        // @emem 11 PM
} ScheduleHours;


#define ENUM_INCR(type, x) x = ( (type) (  ((int)(x)) + 1 ) )

//
// Alert Enumerations.
//

////////////////////////////////////////////////////////////
// @enum ActionTypes | types of action that can be triggered by events

typedef enum _Actions {
    alrtLogEvent = 0,       //@emem Log event to System Event Log
    alrtCommand,            //@emem Run command line
    alrtSendMail,           //@emem Send Mail message
    alrtStopServices,       //@emem Stop Comet services
    alrtRestartServices,    //@emem Restart Comet services
    alrtPage,               //@emem Notify Pager
    alrtMakeCall            //@emem Make phone call using Web-based IVR
} ActionTypes;

#define alrtActionInvalid (-1)
#define alrtMaxActionType (alrtMakeCall + 1)

/////////////////////////////////////////////////////////
// @enum Events | type of events handled by Comet.
typedef enum _Events {
    alrtLowDiskSpace,        // @emem Low disk space.
    alrtZeroDiskSpace,       // @emem Out of disk space.
    alrtEventLogFailure,     // @emem Failure to log an event.
    alrtConfigurationError,  // @emem Configuration Error
    alrtRrasFailure,         // @emem Failure of RRAS service.
    alrtDllLoadFailure,      // @emem Failure to load a DLL.
    alrtDroppedPackets,      // @emem Dropped Packets (PFD)
    alrtProtocolViolation,   // @emem Protocol violations
    alrtProxyChaining,       // @emem Proxy chaining failure
    alrtServiceShutdown,     // @emem Service keep alive failure
    alrtRrasLineQuality,     // @emem RRAS line quality threshold
    alrtCacheCleanupFrequency, // @emem Cache cleanup frequency
    alrtTapiReinit,          // @emem TAPI reinitialized
    alrtDialOnDemandFailure, // @emem Dial On Demand failure (busy, no line)
    alrtIntraArrayCredentials, // @emem Intra array credentials incorrect
    alrtUpstreamChainingCredentials, // @emem Upstream chaining credentials incorrect
    alrtDialOnDemandCredentials, // @emem Dial On Demand credentials incorrect
    alrtOdbcCredentials,         // @emem Log to ODBC credentials incorrect
} EventTypes;
#define     alrtMaxEventType (alrtOdbcCrenetials + 1)

/////////////////////////////////////////////////////////
// @enum OperationModes | Alerting operation modes.
typedef enum _OperationModes {
    alrtCountThreshold,      //@emem events count before reraising alert
    alrtRateThreshold,       //@emem minimal events per second rate for raising alert
    alrtIntervalThreshold,   //@emem minimal interval in minutes before reraise
} OperationModes;
#define     alrtMaxOperationModes (alrtIntervalThreshold + 1)

///////////////////////////////////////////////////////////
// @enum Accounttypes | types of NT accounts
typedef enum _AccountTypes
{
  prxAccountTypeUser,                // @emem A User.
  prxAccountTypeGroup,               // @emem A group of users
  prxAccountTypeDomain,              // @emem A domain of users.
  prxAccountTypeAlias,               // @emem An alias.
  prxAccountTypeWellKnownGroup       // @emem A predefined account such as "Everyone"
} AccountTypes;

///////////////////////////////////////////////////////////
// @enum IncludeStatus | defines whether an accouint is included or excluded
// in the list of accounts to which a rule applies.
typedef enum _IncludeStatus
{
    prxInclude,                      // @emem Account is included.
    prxExclude                       // @emem Account is excluded.
} IncludeStatusEnum;

///////////////////////////////////////////////////////////
// @enum ConnectionProtocoltype | Type of IP protocol that consists a part
// of a Winsock Proxy Protocol definition.
typedef enum _ConnectionProtocolType
{
    prxTCP,                          // @emem TCP-IP
    prxUDP                           // @emem UDP-IP
}  ConnectionProtocolType;

///////////////////////////////////////////////////////////
// @enum Connectiondirectiontype | Type of connection that consists a part
// of a Winsock Proxy Protocol definition.
typedef enum _ConnectionDirectionType
{
   prxInbound,                       // @emem Inbound connection.
   prxOutbound                       // @emem Outbound connection.
}  ConnectionDirectionType;

///////////////////////////////////////////////////////////
// @enum CrmApplication | Type of application that uses a CRM
// line.
typedef enum _CrmApplication
{
    CRM_APPLICATION_NONE        =0,  // @emem No application
    CRM_APPLICATION_RAS         =1,  // @emem RAS
    CRM_APPLICATION_FAX         =2,  // @emem Fax
    CRM_APPLICATION_WEBIVR      =4,  // @emem Web-based IVR
    CRM_APPLICATION_MP          =8,  // @emem Modem Share
    CRM_ALL_APPLICATIONS        =0xF // @emem All the above values ORed
} CrmApplication;

///////////////////////////////////////////////////////////////
// @enum LoggingComponents
typedef enum _LoggingComponents
{
    logProxyWEB,           // @emem The Web Proxy log.
    logProxyWSP,           // @emem The Winsock Proxy log
    logProxySocks,         // @emem The Socks Proxy log.
    logProxyPacketFilters, // @emem Packet filters log.
    logWEBIVR,             // @emem The Web IVR log.
    logModemSharing,       // @emem The Modem Sharing log.
    logCRMLines,           // @emem The Telephone lines log.
    logFax,                // @emem The Fax Server log.
} LoggingComponents;

///////////////////////////////////////////////////////////////
// @enum LogFileDirectoryType
typedef enum _LogFileDirectoryType
{
    logFullPath,            // @emem The directory of the log files is given in full path.
    logRelativePath         // @emem The directory of the log files is relative to Comet install directory.
} LogFileDirectoryType;

typedef enum _ProtocolSelectionTypeEnum
{

   prxAllProtocols,
   prxAllDefinedProtocols,
   prxSpecifiedProtocols

} ProtocolSelectionTypeEnum;
//////////////////////////////////////////////////////
// @enum AppliesToType | types of request origins for which a rule applies..
typedef enum _AppliesToType
{
   cometAppliesToAll,                    // @emem All requests regardless of origin
   cometAppliesToUsers,                  // @emem requests coming from specified users.
   cometAppliesToClientSets              // @emem requests coming from specified machines.
} AppliesToType;

///////////////////////////////////////////////////////
// @enum CometServices | assigns numerical values for various
// components of Comet.
typedef enum _CometServices
{
    cometWspSrvSvc                  = 1,//@emem The Winsock Proxy component
    cometW3Svc                      = 2,//@emem The web proxy component.
    cometAllServices                = 0xFFFFFFFF // All the above values ORed
} CometServices;

///////////////////////////////////////////////////////////
// @enum DeviceType | The Fax Devices Types which are
// Device, Provider [Fax Over IP], or other.
typedef enum _DeviceType
{
    DEVICE = 1,  // TAPI Device
    PROVIDER,    // Non TAPI Device FaxOver IP or Virtual.
    OTHER
} DeviceType;

///////////////////////////////////////////////////////////
// @enum RemoveOldType | This is an enumerator for Fax
// different policies to remove old faxes from archive
typedef enum _RemoveOldType
{
    MAX_TIME_TO_KEEP = 1,   // how long to keep
    MAX_FAX_SIZE,           // maximal fax size allow to keep
    MAX_TOTAL_SIZE,         // maximal total size of archive
} RemoveOldType;

///////////////////////////////////////////////////////////
// @enum LineStatus | Telephony line status.
typedef enum _LineStatus
{
    lsError = 0,       // @emem Device is in error (the server may be down).
    lsIdle = 1,        // @emem The device state is idle - there is no active call on it.
    lsInbound = 2,     // @emem The device handles an inbound call.
    lsOutbound = 4     // @emem The device handles an outbound call.
} LineStatus;

///////////////////////////////////////////////////////////
// @enum ProtocolSelectiontype | type of protocols that a protocols rule
// applies to
typedef enum _ProtocolSelectionType
{
    cometAllIpTraffic, // @emem All IP connections.
    cometAllProtocols, // @emem All the protocols defined by Comet.
    cometSpecifiedProtocols // @emem the protocols specified by the
} ProtocolSelectionType;    // SpecifiedProtocols property

///////////////////////////////////////////////////////////
// @enum ProtocolRuleAction | the types of actions performed
// by the default protocol rule,
typedef enum _ProtocolRuleAction
{
  cometActionAllow, // @emem allow all IP connection requests.
  cometActionDeny   // @emem Deny all IP connection requests.
} ProtocolRuleAction;

///////////////////////////////////////////////////////////
// @enum INETLOG_TYPE | the types of logging methods
typedef enum  _LOG_TYPE   {

    InetLogInvalidType = -1, //@emem Indicates invalid log type
    InetNoLog = 0,           //@emem Logging disabled
    InetLogToFile,           //@emem Logging to text log files
    InetLogToSql,            //@emem Logging to ODBC log
    InetDisabledLogToFile,   //@emem Logging disabled
    InetDisabledLogToSql     //@emem Logging disabled
}  INETLOG_TYPE;


///////////////////////////////////////////////////////////
// @enum INETLOG_PERIOD | these options identify logging periods for text files
typedef enum  _INETLOG_PERIOD {
    InetLogInvalidPeriod = -1,     //@emem Indicates invalid logging period
    InetLogNoPeriod = 0,           //@emem no logging period in use
    InetLogDaily,                  //@emem one file per day
    InetLogWeekly,                 //@emem one log file per week
    InetLogMonthly,                //@emem one log file per month
    InetLogYearly                  //@emem one log file per year.
} INETLOG_PERIOD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\expdef.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ExpDef.h                                               //
//                                                                         //
//  DESCRIPTION   : Definitions of 'dllexp'.                               //
//                                                                         //
//  AUTHOR        : BarakH                                                 //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 22 1998 BarakH  Init.                                          //
//      Oct 15 1998 BarakH  Move to Comet SLM.                             //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef EXPDEF_H_INCLUDED
#define EXPDEF_H_INCLUDED

#ifndef dllexp

/////////////////////////////////////////////////////////////////////////////
// EXPORT_COMET_LOG is defined only in the log DLL project settings.
// This causes dllexp to be defined as __declspec( dllexport ) only when
// building the DLL. Otherwise the definition is empty so the log functions
// are not exported by other code that uses the headers of the log DLL.
/////////////////////////////////////////////////////////////////////////////

#ifdef EXPORT_COMET_LOG
#define dllexp __declspec( dllexport )

#else // ! defined EXPORT_COMET_LOG
#define dllexp
#endif // EXPORT_COMET_LOG

#endif // ! defined dllexp

#endif // EXPDEF_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxcfg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcfg.h

Abstract:

    Public interface to the fax configuration DLL

Environment:

        Windows XP fax configuration applet

Revision History:

        05/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

Note:

    The fax configuration DLL is not thread-safe. Make sure you're not
    using it simultaneously from multiples of a single process.

--*/


#ifndef _FAXCFG_H_
#define _FAXCFG_H_


//
// Fax configuration types
//

#define FAXCONFIG_CLIENT        0
#define FAXCONFIG_SERVER        1
#define FAXCONFIG_WORKSTATION   2

//
// Initialize the fax configuration DLL
//
// Parameters:
//
//  pServerName - Specifies the name of the fax server machine.
//      Pass NULL for local machine.
//
// Return value:
//
//  -1 - An error has occurred
//  FAXCONFIG_CLIENT -
//  FAXCONFIG_SERVER -
//  FAXCONFIG_WORKSTATION - Indicates the type of configuration the user can run
//

INT
FaxConfigInit(
    LPTSTR  pServerName,
    BOOL    CplInit
    );

//
// De-initialize the fax configuration DLL
//
//  You should call this function after you're done using the
//  fax configuration DLL.
//

VOID
FaxConfigCleanup(
    VOID
    );

//
// Get an array of handles to client/server/workstation configuration pages
//
// Parameters:
//
//  phPropSheetPages - Specifies a buffer for storing property page handles
//  count - Specifies the maximum number of handles the input buffer can hold
//
// Return value:
//
//  -1 - An error has occurred
//  >0 - Total number of configuration pages available
//
// Note:
//
//  To figure out how large the input buffer should be, the caller can
//  first call these functions with phPropSheetPages set to NULL and
//  count set to 0.
//

INT
FaxConfigGetClientPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetServerPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetWorkstationPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

#endif  // !_FAXCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxdebug.h ===
/*************************************************

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDebug.h

Abstract:

    This file defines the debugging enum/masks
    available to the FAX compoments.

Author:

    Mooly Beery (MoolyB) 22-06-2000

Environment:

    User Mode

**************************************************/

#ifndef __FAX_EDBUG_HEADER_FILE__
#define __FAX_EDBUG_HEADER_FILE__

typedef enum
{
    DEBUG_CONTEXT_T30_MAIN          = 0x00000001,
    DEBUG_CONTEXT_T30_CLASS1        = 0x00000002,
    DEBUG_CONTEXT_T30_CLASS2        = 0x00000004,
    DEBUG_CONTEXT_T30_COMM          = 0x00000008,
    DEBUG_CONTEXT_ADMIN_FAXCLIENT   = 0x00000010,
    DEBUG_CONTEXT_ADMIN_MMC         = 0x00000020,
    DEBUG_CONTEXT_ADMIN_FAXRES      = 0x00000040,
    DEBUG_CONTEXT_ADMIN_T30EXT      = 0x00000080,
    DEBUG_CONTEXT_ADMIN_ROUTINGEXT  = 0x00000100,
    DEBUG_CONTEXT_CLIENT_CONSOLE    = 0x00000200,
    DEBUG_CONTEXT_EXCHANGE_EXT      = 0x00000400,
    DEBUG_CONTEXT_EXCHANGE_XPORT    = 0x00000800,
    DEBUG_CONTEXT_FAXCOVER_SRC      = 0x00001000,
    DEBUG_CONTEXT_FAXCOVER_RENDERER = 0x00002000,
    DEBUG_CONTEXT_SERVICE_RPC       = 0x00004000,
    DEBUG_CONTEXT_SERVICE_EFSPUTIL  = 0x00008000,
    DEBUG_CONTEXT_SERVICE_REGISTRY  = 0x00010000,
    DEBUG_CONTEXT_SERVICE_CLIENT    = 0x00020000,
    DEBUG_CONTEXT_SERVICE_FAXEVENT  = 0x00040000,
    DEBUG_CONTEXT_SERVICE_FAXROUTE  = 0x00080000,
    DEBUG_CONTEXT_SERVICE_SERVER    = 0x00100000,
    DEBUG_CONTEXT_SETUP_UTIL        = 0x00200000,
    DEBUG_CONTEXT_SETUP_CLIENT      = 0x00400000,
    DEBUG_CONTEXT_SETUP_SERVER      = 0x00800000,
    DEBUG_CONTEXT_TIFF_SRC          = 0x01000000,
    DEBUG_CONTEXT_UTIL              = 0x02000000,
    DEBUG_CONTEXT_DEBUGEX           = 0x04000000,

    DEBUG_CONTEXT_ALL               = 0xFFFFFFFF

} DEBUG_MESSAGE_CONTEXT;

typedef enum
{
    DBG_PRNT_THREAD_ID      = 0x80000000,   // Print thread ID in debug stream
    DBG_PRNT_TIME_STAMP     = 0x40000000,   // Print Date/Time in debug stream
    DBG_PRNT_MSG_TYPE       = 0x20000000,   // Print [MSG],[WRN],[ERR] in debug stream
    DBG_PRNT_FILE_LINE      = 0x10000000,   // Print Filename & line number in debug stream
    DBG_PRNT_TO_FILE        = 0x08000000,   // Output debug stream to a file (you have to call OpenLogFile with a filename
    DBG_PRNT_TO_STD         = 0x04000000,   // Use std debug output
    DBG_PRNT_TICK_COUNT     = 0x02000000,   // Print Tick count
    DBG_PRNT_MOD_NAME       = 0x01000000,   // Print the module name

    DBG_PRNT_ALL            = 0xFFFFFFFF,
    DBG_PRNT_ALL_TO_FILE    = DBG_PRNT_ALL & ~DBG_PRNT_TO_STD,
    DBG_PRNT_ALL_TO_STD     = DBG_PRNT_ALL & ~DBG_PRNT_TO_FILE,

} DbgMsgFormat;


#endif // __FAX_EDBUG_HEADER_FILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxevent.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxevent.h

Abstract:

    This is the main fax service header file.  All
    source modules should include this file ONLY.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#ifndef _FAXEVENT_
#define _FAXEVENT_

#ifdef __cplusplus
extern "C" {
#endif

void
GetEventsCounters(
    OUT LPDWORD lpdwWarningEvents,
    OUT LPDWORD lpdwErrorEvents,
    OUT LPDWORD lpdwInformationEvents
    );

BOOL
FXSEVENTInitialize(
    VOID
    );

VOID
FXSEVENTFree(
    VOID
    );


BOOL WINAPI
InitializeEventLog(
    OUT PREG_FAX_SERVICE* ppFaxReg
    );

DWORD WINAPI
RefreshEventLog(
    PREG_FAX_LOGGING FaxEvent
    );

BOOL WINAPI
FaxLog(
    DWORD Category,
    DWORD Level,
    DWORD StringCount,
    DWORD FormatId,
    ...
    );

DWORD
GetLoggingCategories(
    OUT PFAX_LOG_CATEGORY* lppFaxCategory,
    OUT LPDWORD lpdwFaxCategorySize,
    OUT LPDWORD lpdwNumberCategories
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxdevex.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxdevex.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider extended API.

--*/

#ifndef _FAX_DEV_EX_H_
#define _FAX_DEV_EX_H_

#include <faxdev.h>
#include <oleauto.h>
#include <CoverPgId.h>

//
// Extended Fax Service Provider Interface
//


//
// Job Queue Status codes
//
#define FSPI_JS_UNKNOWN             0x00000001
#define FSPI_JS_PENDING             0x00000002
#define FSPI_JS_INPROGRESS          0x00000003
#define FSPI_JS_SUSPENDING          0x00000004
#define FSPI_JS_SUSPENDED           0x00000005
#define FSPI_JS_RESUMING            0x00000006
#define FSPI_JS_ABORTING            0x00000007
#define FSPI_JS_ABORTED             0x00000008
#define FSPI_JS_COMPLETED           0x00000009
#define FSPI_JS_RETRY               0x0000000A
#define FSPI_JS_FAILED              0x0000000B
#define FSPI_JS_FAILED_NO_RETRY     0x0000000C
#define FSPI_JS_DELETED             0x0000000D

//
// Extended job status codes
//
#define FSPI_ES_DISCONNECTED        0x00000001
#define FSPI_ES_INITIALIZING        0x00000002
#define FSPI_ES_DIALING             0x00000003
#define FSPI_ES_TRANSMITTING        0x00000004
#define FSPI_ES_ANSWERED            0x00000005
#define FSPI_ES_RECEIVING           0x00000006
#define FSPI_ES_LINE_UNAVAILABLE    0x00000007
#define FSPI_ES_BUSY                0x00000008
#define FSPI_ES_NO_ANSWER           0x00000009
#define FSPI_ES_BAD_ADDRESS         0x0000000A
#define FSPI_ES_NO_DIAL_TONE        0x0000000B
#define FSPI_ES_FATAL_ERROR         0x0000000C
#define FSPI_ES_CALL_DELAYED        0x0000000D
#define FSPI_ES_CALL_BLACKLISTED    0x0000000E
#define FSPI_ES_NOT_FAX_CALL        0x0000000F
#define FSPI_ES_PARTIALLY_RECEIVED  0x00000010
#define FSPI_ES_HANDLED             0x00000011
#define FSPI_ES_CALL_COMPLETED      0x00000012
#define FSPI_ES_CALL_ABORTED        0x00000013
#define FSPI_ES_PROPRIETARY         0x30000000 // Must be greater than FPS_ANSWERED to preserve
                                               // backward compatibiity with W2K FSPs
//
// Status information fields availability flags
//
#define FSPI_JOB_STATUS_INFO_PAGECOUNT             0x00000001
#define FSPI_JOB_STATUS_INFO_TRANSMISSION_START    0x00000002
#define FSPI_JOB_STATUS_INFO_TRANSMISSION_END      0x00000004

//
// data structures
//

typedef struct _FSPI_PERSONAL_PROFILE {
    DWORD      dwSizeOfStruct;
    LPWSTR     lpwstrName;
    LPWSTR     lpwstrFaxNumber;
    LPWSTR     lpwstrCompany;
    LPWSTR     lpwstrStreetAddress;
    LPWSTR     lpwstrCity;
    LPWSTR     lpwstrState;
    LPWSTR     lpwstrZip;
    LPWSTR     lpwstrCountry;
    LPWSTR     lpwstrTitle;
    LPWSTR     lpwstrDepartment;
    LPWSTR     lpwstrOfficeLocation;
    LPWSTR     lpwstrHomePhone;
    LPWSTR     lpwstrOfficePhone;
    LPWSTR     lpwstrEmail;
    LPWSTR     lpwstrBillingCode;
    LPWSTR     lpwstrTSID;
} FSPI_PERSONAL_PROFILE;

typedef FSPI_PERSONAL_PROFILE * LPFSPI_PERSONAL_PROFILE;
typedef const FSPI_PERSONAL_PROFILE * LPCFSPI_PERSONAL_PROFILE;

typedef struct _FSPI_COVERPAGE_INFO {
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPWSTR  lpwstrCoverPageFileName;
    DWORD   dwNumberOfPages;
    LPWSTR  lpwstrNote;
    LPWSTR  lpwstrSubject;
} FSPI_COVERPAGE_INFO;


typedef FSPI_COVERPAGE_INFO * LPFSPI_COVERPAGE_INFO;
typedef const FSPI_COVERPAGE_INFO * LPCFSPI_COVERPAGE_INFO;

typedef struct _FSPI_MESSAGE_ID {
    DWORD   dwSizeOfStruct;
    DWORD   dwIdSize;
    LPBYTE  lpbId;
} FSPI_MESSAGE_ID;

typedef FSPI_MESSAGE_ID * LPFSPI_MESSAGE_ID;
typedef const FSPI_MESSAGE_ID * LPCFSPI_MESSAGE_ID;

typedef struct _FSPI_JOB_STATUS {
    DWORD dwSizeOfStruct;
    DWORD fAvailableStatusInfo;
    DWORD dwJobStatus;
    DWORD dwExtendedStatus;
    DWORD dwExtendedStatusStringId;
    LPWSTR lpwstrRemoteStationId;
    LPWSTR lpwstrCallerId;
    LPWSTR lpwstrRoutingInfo;
    DWORD dwPageCount;
    SYSTEMTIME tmTransmissionStart;
    SYSTEMTIME tmTransmissionEnd;
} FSPI_JOB_STATUS;

typedef FSPI_JOB_STATUS * LPFSPI_JOB_STATUS;
typedef const FSPI_JOB_STATUS * LPCFSPI_JOB_STATUS;


#endif // _FAX_DEV_EX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxext.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    faxext.h

Abstract:

    Declarations of fax extension configuration and notification functions.

--*/


#ifndef _FAX_EXT_H_
#define _FAX_EXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************
*                                   *
*   Extension configuration data    *
*                                   *
************************************/

typedef enum
{
    DEV_ID_SRC_FAX,         // Device id is generated by the fax server
    DEV_ID_SRC_TAPI         // Device id is generated by a TAPI TSP (of FSP).
}   FAX_ENUM_DEVICE_ID_SOURCE;

//
// Prototype of FaxExtGetData 
// 
DWORD
FaxExtGetData (
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                     *ppData,         // (Out) Pointer to allocated data
    LPDWORD                     lpdwDataSize    // (Out) Pointer to data size
);
typedef DWORD (CALLBACK *PFAX_EXT_GET_DATA) (DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE *, LPDWORD);

//
// Prototype of FaxExtSetData 
// 
DWORD
FaxExtSetData (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                      pData,          // Pointer to  data
    DWORD                       dwDataSize      // Data size
);
typedef DWORD (CALLBACK *PFAX_EXT_SET_DATA) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE, DWORD);

HRESULT
FaxExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrDataGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
);
typedef HRESULT (WINAPI *PFAX_EXT_CONFIG_CHANGE) (DWORD, LPCWSTR, LPBYTE, DWORD);

//
// Prototype of FaxExtRegisterForEvents 
//
HANDLE
FaxExtRegisterForEvents (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    PFAX_EXT_CONFIG_CHANGE      lpConfigChangeCallback
);
typedef HANDLE (CALLBACK *PFAX_EXT_REGISTER_FOR_EVENTS) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, PFAX_EXT_CONFIG_CHANGE);

//
// Prototype of FaxExtUnregisterForEvents 
//
DWORD
FaxExtUnregisterForEvents (
    HANDLE      hNotification
);
typedef DWORD (CALLBACK *PFAX_EXT_UNREGISTER_FOR_EVENTS) (HANDLE);

//
// Prototype of FaxExtFreeBuffer
//
VOID
FaxExtFreeBuffer (
    LPVOID lpvBuffer
);
typedef VOID (CALLBACK *PFAX_EXT_FREE_BUFFER) (LPVOID);

//
// The extension should implement and export the following function:
//
HRESULT 
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA,              // Pointer to FaxExtGetExtensionData in service
    PFAX_EXT_SET_DATA,              // Pointer to FaxExtSetExtensionData in service
    PFAX_EXT_REGISTER_FOR_EVENTS,   // Pointer to FaxExtRegisterForExtensionEvents in service
    PFAX_EXT_UNREGISTER_FOR_EVENTS, // Pointer to FaxExtUnregisterForExtensionEvents in service
    PFAX_EXT_FREE_BUFFER            // Pointer to FaxExtFreeBuffer in service
);
typedef HRESULT (WINAPI *PFAX_EXT_INITIALIZE_CONFIG) (PFAX_EXT_GET_DATA, PFAX_EXT_SET_DATA, PFAX_EXT_REGISTER_FOR_EVENTS, PFAX_EXT_UNREGISTER_FOR_EVENTS, PFAX_EXT_FREE_BUFFER);

#ifdef __cplusplus
}
#endif

#endif // _FAX_EXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxhelp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    Help related declarations

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#ifndef _FAXHELP_H_
#define _FAXHELP_H_

#include <htmlhelp.h>

//
// Name of the help file for the fax configuration applet
//

#define FAXCFG_HELP_FILENAME    TEXT("fax.hlp")
#define FAX_HTMLHELP_FILENAME   TEXT("fax.chm")
#define FAXQUEUE_HTMLHELP_FILENAME   TEXT("faxqueue.chm")
#define FAXMMC_HTMLHELP_FILENAME   TEXT("%SystemRoot%\\help\\faxmgmt.chm")
#define FAXMMC_HTMLHELP_TOPIC   TEXT("faxmgmt.chm::/fax_mgmt_welcome.htm")


#define FAXWINHELP( iMsg, wParam, lParam, HelpIDs )       \
                                                          \
    if ((iMsg) == WM_HELP) {                              \
                                                          \
        WinHelp((HWND)((LPHELPINFO) (lParam))->hItemHandle,     \
                FAXCFG_HELP_FILENAME,                     \
                HELP_WM_HELP,                             \
                (ULONG_PTR) (HelpIDs));                    \
                                                          \
    } else {                                              \
                                                          \
        WinHelp((HWND) (wParam),                          \
                FAXCFG_HELP_FILENAME,                     \
                HELP_CONTEXTMENU,                         \
                (ULONG_PTR) (HelpIDs));                    \
    }

//
// Help topic mappings
//

#define IDH_INACTIVE                ((ULONG_PTR)-1)

// Fax Service dialog, General tab  
#define IDH_Fax_Service_General_RetryCharacteristics_GRP            101
#define IDH_Fax_Service_General_NumberOfRetries                     102
#define IDH_Fax_Service_General_MinutesBetweenRetries               103
#define IDH_Fax_Service_General_DaysUnsentJobKept                   104
#define IDH_Fax_Service_General_SendSettings_GRP                    105
#define IDH_Fax_Service_General_PrintBannerOnTop                    106
#define IDH_Fax_Service_General_UseSendingDeviceTSID                107
#define IDH_Fax_Service_General_ForceServerCoverPages               108
#define IDH_Fax_Service_General_DiscountPeriod                      109
#define IDH_Fax_Service_General_ArchiveOutgoingFaxes                110
#define IDH_Fax_Service_General_ArchiveOutgoingFaxes_Browse         111
#define IDH_Fax_Service_General_MapiProfile                         112


// Fax Service dialog, Routing tab  
#define IDH_Fax_Service_Routing_PriorityList                        201
#define IDH_Fax_Service_Routing_Up                                  202
#define IDH_Fax_Service_Routing_Down                                203

// Fax Service Modem dialog 
#define IDH_Fax_Modem_General_SendTSID                              400
#define IDH_Fax_Modem_General_ReceiveTSID                           401
#define IDH_Fax_Modem_General_RingsBeforeAnswer                     402
#define IDH_Fax_Modem_Routing_InboundRouting_GRP                    403
#define IDH_Fax_Modem_Routing_PrintTo                               404
#define IDH_Fax_Modem_Routing_SaveInFolder                          405
#define IDH_Fax_Modem_Routing_SendToLocalInbox                      406
#define IDH_Fax_Modem_Routing_ProfileName                           407
#define IDH_Fax_Modem_General_Send_GRP                              408
#define IDH_Fax_Modem_General_Receive_GRP                           409
#define IDH_Fax_Modem_General_Send                                  410
#define IDH_Fax_Modem_General_Receive                               411

// User Info tab in printer dialog box properties   
#define IDH_USERINFO_FAX_NUMBER                                     1024
#define IDH_USERINFO_ADDRESS                                        1049
#define IDH_USERINFO_COMPANY                                        1050
#define IDH_USERINFO_DEPARTMENT                                     1052
#define IDH_USERINFO_HOME_PHONE                                     1053
#define IDH_USERINFO_EMAIL_ADDRESS                                  1054
#define IDH_USERINFO_FULL_NAME                                      1055
#define IDH_USERINFO_OFFICE_LOCATION                                1056
#define IDH_USERINFO_WORK_PHONE                                     1057
#define IDH_USERINFO_TITLE                                          1058
#define IDH_USERINFO_BILLING_CODE                                   1059
#define IDH_USERINFO_RETURN_FAX_GRP                                 1071
// Fax Default - Fax Options (formally faxui.hlp)   
#define IDH_FAXDEFAULT_IMAGE_QUALITY                                2025
#define IDH_FAXDEFAULT_LANDSCAPE                                    2026
#define IDH_FAXDEFAULT_PAPER_SIZE                                   2037
#define IDH_FAXDEFAULT_PORTRAIT                                     2038
#define IDH_FAXDEFAULT_ORIENTATION                                  2062
#define IDH_FAXDEFAULT_DEFAULT_PRINT_SETUP_GRP                      2070

// Fax properties - Cover Page tab  
#define IDH_COVERPAGE_PERSONAL_LIST                                 501
#define IDH_COVERPAGE_ADD                                           502
#define IDH_COVERPAGE_NEW                                           503
#define IDH_COVERPAGE_OPEN                                          504
#define IDH_COVERPAGE_REMOVE                                        505
#define IDH_COVERPAGE_SERVER_LIST                                   511

// Fax details dialog box   
#define IDH_FAXDETAILS_DETAILS_LIST                                 1110
#define IDH_FAXDETAILS_CLOSE                                        1111

// Fax monitor dialog box   
#define IDH_FAXMONITOR_END_CALL                                     1112
#define IDH_FAXMONITOR_DETAILS                                      1113
#define IDH_FAXMONITOR_STATUS                                       1114
#define IDH_FAXMONITOR_ANSWER_NEXT_CALL                             1115
#define IDH_FAXMONITOR_ICON                                         1116

// Fax mail transport property sheet
#define IDH_FAXMAILTRANSPORT_FAX_PRINTERS                           1120
#define IDH_FAXMAILTRANSPORT_INCLUDE_COVER_PAGE                     1121
#define IDH_FAXMAILTRANSPORT_COVER_PAGES                            1122
#define IDH_FAXMAILTRANSPORT_DEFAULT_MESSAGE_FONT_GRP               1123
#define IDH_FAXMAILTRANSPORT_FONT                                   1124
#define IDH_FAXMAILTRANSPORT_FONT_STYLE                             1125
#define IDH_FAXMAILTRANSPORT_SIZE                                   1126
#define IDH_FAXMAILTRANSPORT_SET_FONT                               1127

// Fax Message Attributes Dialog Box    
#define IDH_FMA_FAX_PRINTERS                                        1130
#define IDH_FMA_DIALING_LOCATION                                    1131
#define IDH_FMA_INCLUDE_COVER_PAGE                                  1132
#define IDH_FMA_COVER_PAGES                                         1133

#endif  // !_FAXHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    faxdev.h

Abstract:

    This file contains the prototypes for the
    FAX device provider API.

--*/

#include <commctrl.h>


#ifndef _FAXDEV_
#define _FAXDEV_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// FAX status constants
//

#define FS_INITIALIZING         0x20000000
#define FS_DIALING              0x20000001
#define FS_TRANSMITTING         0x20000002
#define FS_RECEIVING            0x20000004
#define FS_COMPLETED            0x20000008
#define FS_HANDLED              0x20000010
#define FS_LINE_UNAVAILABLE     0x20000020
#define FS_BUSY                 0x20000040
#define FS_NO_ANSWER            0x20000080
#define FS_BAD_ADDRESS          0x20000100
#define FS_NO_DIAL_TONE         0x20000200
#define FS_DISCONNECTED         0x20000400
#define FS_FATAL_ERROR          0x20000800  
#define FS_NOT_FAX_CALL         0x20001000
#define FS_CALL_DELAYED         0x20002000
#define FS_CALL_BLACKLISTED     0x20004000
#define FS_USER_ABORT           0x20200000
#define FS_ANSWERED             0x20800000


//
// data structures
//

typedef struct _FAX_SEND {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  CallerName;
    LPWSTR  CallerNumber;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    BOOL    Branding;
    HCALL   CallHandle;
    DWORD   Reserved[3];
} FAX_SEND, *PFAX_SEND;

typedef struct _FAX_RECEIVE {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE, *PFAX_RECEIVE;

typedef struct _FAX_DEV_STATUS {
    DWORD   SizeOfStruct;
    DWORD   StatusId;
    DWORD   StringId;
    DWORD   PageCount;
    LPWSTR  CSI;
    LPWSTR  CallerId;
    LPWSTR  RoutingInfo;
    DWORD   ErrorCode;
    DWORD   Reserved[3];
} FAX_DEV_STATUS, *PFAX_DEV_STATUS;

typedef BOOL
(CALLBACK *PFAX_SERVICE_CALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

typedef void
(CALLBACK *PFAX_LINECALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD_PTR dwInstance,
    IN DWORD_PTR dwParam1,
    IN DWORD_PTR dwParam2,
    IN DWORD_PTR dwParam3
    );

BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );

HRESULT WINAPI FaxDevShutdown(
    void
);

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    );

typedef BOOL
(CALLBACK *PFAX_SEND_CALLBACK)(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    );

#define FAXDEVRECEIVE_SIZE 4096

BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    );

#define FAXDEVREPORTSTATUS_SIZE 4096

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    );

BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    );


typedef BOOL (WINAPI *PFAXDEVINITIALIZE)                (HLINEAPP,HANDLE,PFAX_LINECALLBACK*,PFAX_SERVICE_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVVIRTUALDEVICECREATION)     (LPDWORD,LPWSTR,LPDWORD,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVSTARTJOB)                  (HLINE,DWORD,PHANDLE,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVENDJOB)                    (HANDLE);
typedef BOOL (WINAPI *PFAXDEVSEND)                      (HANDLE,PFAX_SEND,PFAX_SEND_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVRECEIVE)                   (HANDLE,HCALL,PFAX_RECEIVE);
typedef BOOL (WINAPI *PFAXDEVREPORTSTATUS)              (HANDLE,PFAX_DEV_STATUS,DWORD,LPDWORD);
typedef BOOL (WINAPI *PFAXDEVABORTOPERATION)            (HANDLE);
typedef BOOL (WINAPI *PFAXDEVCONFIGURE)                 (HPROPSHEETPAGE*);
typedef HRESULT (WINAPI * PFAXDEVSHUTDOWN)              (void);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxisapi.h ===
#include "winfax.h"

//
// command codes
//

#define ICMD_CONNECT                0x80000001
#define ICMD_DISCONNECT             0x80000002
#define ICMD_ENUM_PORTS             0x80000003
#define ICMD_OPEN_PORT              0x80000004
#define ICMD_GET_PORT               0x80000006
#define ICMD_SET_PORT               0x80000007
#define ICMD_CLOSE                  0x80000008
#define ICMD_GET_ROUTINGINFO        0x80000009
#define ICMD_GET_DEVICE_STATUS      0x8000000a
#define ICMD_ENUM_ROUTING_METHODS   0x8000000b
#define ICMD_ENABLE_ROUTING_METHOD  0x8000000c
#define ICMD_GET_VERSION            0x8000000d

//
// packets
//

typedef struct _IFAX_CONNECT {
    DWORD   Command;
    WCHAR   ServerName[64];
} IFAX_CONNECT, *PIFAX_CONNECT;

typedef struct _IFAX_GENERAL {
    DWORD   Command;
    HANDLE  FaxHandle;
} IFAX_GENERAL, *PIFAX_GENERAL;

typedef struct _IFAX_OPEN_PORT {
    DWORD   Command;
    HANDLE  FaxHandle;
    DWORD   DeviceId;
    DWORD   Flags;
} IFAX_OPEN_PORT, *PIFAX_OPEN_PORT;

typedef struct _IFAX_SET_PORT {
    DWORD           Command;
    HANDLE          FaxPortHandle;
    FAX_PORT_INFOW  PortInfo;
} IFAX_SET_PORT, *PIFAX_SET_PORT;

typedef struct _IFAX_GET_ROUTINGINFO {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
} IFAX_GET_ROUTINGINFO, *PIFAX_GET_ROUTINGINFO;

typedef struct _IFAX_ENABLE_ROUTING_METHOD {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
    BOOL    Enabled;
} IFAX_ENABLE_ROUTING_METHOD, *PIFAX_ENABLE_ROUTING_METHOD;

typedef struct _IFAX_RESPONSE_HEADER {
    DWORD   Size;
    DWORD   ErrorCode;
} IFAX_RESPONSE_HEADER, *PIFAX_RESPONSE_HEADER;





typedef BOOL (WINAPI *PUNLOADINIT)(VOID);
typedef BOOL (WINAPI *PUNLOADER)(HMODULE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxmapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    This file contains the prototypes, etc for the
    FAX mapi API.

Author:

    Wesley Witt (wesw) 7-Mar-1997

Environment:

    User Mode

--*/

#ifndef _FAXMAPI_
#define _FAXMAPI_

#ifdef __cplusplus
extern "C" {
#endif


typedef BOOL
(WINAPI *PFAXLOG)(
    IN DWORD Category,
    IN DWORD Level,
    IN DWORD StringCount,
    IN DWORD FormatId,
    IN ...
    );

typedef BOOL
(WINAPI *PSERVICEMESSAGEBOX)(
    IN LPCWSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    );


VOID
FXSMAPIFree(
    VOID
    );



BOOL WINAPI
FaxMapiInitialize(
    IN PSERVICEMESSAGEBOX pServiceMessageBox
    );

LPCWSTR WINAPI
GetProfileName(
    IN LPVOID ProfileInfo
    );

LPVOID WINAPI
AddNewMapiProfile(
    LPCWSTR ProfileName,
    BOOL UseMail,
    BOOL ShowPopUp
    );

BOOL WINAPI
StoreMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         MsgSenderNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    );

BOOL WINAPI
MailMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         RecipientNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    );

LONG WINAPI
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    );



typedef BOOL (WINAPI *PFAXMAPIINITIALIZE)         (VOID);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxmmc.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    faxmmc.h

Abstract:

    This header file contains public constants for extension of MMC components.

--*/

#ifndef H_FXS_MMCEXT_H
#define H_FXS_MMCEXT_H

#define FAXSRV_DEVICE_NODETYPE_GUID_STR OLESTR("{3115A19A-6251-46ac-9425-14782858B8C9}")
#define FAXSRV_DEVICE_NODETYPE_GUID { 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } }

#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR OLESTR("{BD38E2AC-B926-4161-8640-0F6956EE2BA3}")
#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID { 0xbd38e2ac, 0xb926, 0x4161, { 0x86, 0x40, 0x0f, 0x69, 0x56, 0xee, 0x2b, 0xa3 } }

#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR OLESTR("{220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}")
#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID { 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } }

#define FAXSRV_MAX_GUID_LEN              sizeof(FAXSRV_DEVICE_NODETYPE_GUID_STR)/sizeof(WCHAR)
#define FAXSRV_MAX_SERVER_NAME           MAX_PATH
#define FAXSRV_MAX_ROUTEEXT_NAME_LEN     MAX_PATH

#define CF_MSFAXSRV_DEVICE_ID           TEXT("FAXSRV_DeviceID")
#define CF_MSFAXSRV_FSP_GUID            TEXT("FAXSRV_FSPGuid")
#define CF_MSFAXSRV_SERVER_NAME         TEXT("FAXSRV_ServerName")
#define CF_MSFAXSRV_ROUTEEXT_NAME       TEXT("FAXSRV_RoutingExtName")
#define CF_MSFAXSRV_ROUTING_METHOD_GUID TEXT("FAXSRV_RoutingMethodGuid")

#endif  //H_FXS_MMCEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxperf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxperf.h

Abstract:

    This file defines the fax perfmon dll interface.

Author:

    Wesley Witt (wesw) 22-Aug-1996

Environment:

    User Mode

--*/


#ifndef _FAXPERF_
#define _FAXPERF_

#ifdef __cplusplus
extern "C" {
#endif


#define FAXPERF_SHARED_MEMORY       TEXT("Global\\FaxPerfCounters") // We use the global kernel object name space.
                                                                    // See Terminal Services and kernel objects name space


typedef struct _FAX_PERF_COUNTERS {
    DWORD InboundBytes;
    DWORD InboundFaxes;
    DWORD InboundPages;
    DWORD InboundMinutes;
    DWORD InboundFailedReceive;
    DWORD OutboundBytes;
    DWORD OutboundFaxes;
    DWORD OutboundPages;
    DWORD OutboundMinutes;
    DWORD OutboundFailedConnections;
    DWORD OutboundFailedXmit;
    DWORD TotalBytes;
    DWORD TotalFaxes;
    DWORD TotalPages;
    DWORD TotalMinutes;
} FAX_PERF_COUNTERS, *PFAX_PERF_COUNTERS;



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxres.h ===
#ifndef FXSRES_H
#define FXSRES_H
#include <windows.h>
#include <FXSAPIP.H>

#ifdef __cplusplus
extern "C"{
#endif

HINSTANCE WINAPI GetResInstance(HINSTANCE hModule);
HINSTANCE WINAPI GetResInst(LPCTSTR pResFile, HINSTANCE hModule);
void WINAPI FreeResInstance(void);
UINT WINAPI GetErrorStringId(DWORD ec);

#ifdef __cplusplus
}
#endif

#define FAXUI_ERROR_DEVICE_LIMIT        14000L
#define FAXUI_ERROR_INVALID_RING_COUNT  14001L
#define FAXUI_ERROR_SELECT_PRINTER      14002L
#define FAXUI_ERROR_NAME_IS_TOO_LONG    14003L
#define FAXUI_ERROR_INVALID_RETRIES     14004L
#define FAXUI_ERROR_INVALID_RETRY_DELAY 14005L
#define FAXUI_ERROR_INVALID_DIRTY_DAYS  14006L
#define FAXUI_ERROR_INVALID_CSID        14007L
#define FAXUI_ERROR_INVALID_TSID        14008L


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxname.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxName.h                                              //
//                                                                         //
//  DESCRIPTION   : The central place for FaxName strings                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      May  4 2000 yossg  created                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

//
// This file should be localized
//

#ifndef _FAX_NAME_H_
#define _FAX_NAME_H_

#define FAX_FULL_NAME_MICROSOFT       "Microsoft "
#define FAX_SPACE                     " "

#define FAX_NAME                      "Fax"
#define FAX_FULL_NAME                 FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_NAME
#define FAX_SERVER_NAME               FAX_NAME FAX_SPACE "Service"
#define FAX_SERVER_FULL_NAME          FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_SERVER_NAME
#define FAX_SERVER_NAME_SERVER        FAX_NAME FAX_SPACE "Server"
#define FAX_CLIENT_CONSOLE_NAME       FAX_NAME FAX_SPACE "Console"
#define FAX_CLIENT_CONSOLE_FULL_NAME  FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_CLIENT_CONSOLE_NAME

#define FAX_SERVER_MANAGMENT_NAME     FAX_NAME FAX_SPACE "Manager"
#define FAX_SERVER_MANAGMENT_FULL_NAME   FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_SERVER_MANAGMENT_NAME

#define FAX_PERSONAL_COVER_PAGE_SUFFIX  "\\Fax\\Personal Cover Pages\\"
#endif  // !_FAX_NAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This file contains all fax registry strings and general constants.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/


#ifndef _FAXREG_H_
#define _FAXREG_H_

#define FAX_PATH_SEPARATOR_STR  TEXT("\\")
#define FAX_PATH_SEPARATOR_CHR  TEXT('\\')
#define CP_SHORTCUT_EXT     _T(".lnk")

/*****************************************************************************
**                                                                          **
**               Global project definitions and constants                   **
**                                                                          **
*****************************************************************************/

#define FAX_API_MODULE_NAME_A               "FXSAPI.DLL"								// Used by the print monitor and setup
#define FAX_API_MODULE_NAME                 TEXT("FXSAPI.DLL")                          // Used by the print monitor and setup
#define FAX_SERVICE_EXE_NAME                TEXT("FXSSVC.EXE")                          // Used by utility functions
#define FAX_SERVICE_IMAGE_NAME              TEXT("%systemroot%\\system32\\")) FAX_SERVICE_EXE_NAME // Used by the service
#define FAX_WZRD_MODULE_NAME                TEXT("FXSWZRD.DLL")                         // Used by setup
#define FAX_TIFF_MODULE_NAME_A              "FXSTIFF.DLL"
#define FAX_TIFF_MODULE_NAME                TEXT("FXSTIFF.DLL")                         // Used by setup
#define FAX_DRV_MODULE_NAME                 TEXT("FXSDRV.DLL")                          // Used by setup
#define FAX_DRV_WIN9X_32_MODULE_NAME        TEXT("FXSDRV32.DLL")
#define FAX_DRV_WIN9X_16_MODULE_NAME        TEXT("FXSDRV16.DRV")
#define FAX_NT4_DRV_MODULE_NAME             TEXT("FXSDRV4.DLL")
#define FAX_DRV_UNIDRV_MODULE_NAME          TEXT("UNIDRV.DLL")
#define FAX_DRV_UNIDRV_HELP                 TEXT("UNIDRV.HLP")
#define FAX_DRV_DEPEND_FILE                 TEXT("FXSWZRD.DLL")
#define FAX_TIFF_FILE                       TEXT("FXSTIFF.DLL")
#define FAX_RES_FILE                        TEXT("FXSRES.DLL")
#define FAX_DRV_ICONLIB                     TEXT("ICONLIB.DLL")
#define FAX_UI_MODULE_NAME                  TEXT("FXSUI.DLL")                           // Used by setup
#define FAX_MONITOR_FILE                    TEXT("FXSMON.DLL")                          // Used by setup
#define FAX_EVENT_MSG_FILE                  TEXT("%systemroot%\\system32\\fxsevent.dll")// Used by service\regsitry\faxreg.c: CreateFaxEventSource()
#define FAX_MAIL_TRANSPORT_MODULE_NAME      TEXT("FXSXP32.DLL")                         // Used by exchange\xport\faxxp.h
#define FAX_SETUP_DLL                       TEXT("FXSOCM.DLL")                          // Used by setup
#define FAX_SETUP_DLL_PATH                  TEXT("\\setup\\") FAX_SETUP_DLL             // Used by setup                
#define FAX_SEND_IMAGE_NAME                 TEXT("fxssend.exe")                         // Used by the client console
#define FAX_COVER_IMAGE_NAME                TEXT("fxscover.exe")                        // Used by MMC and ClientConsole
#define FAX_COVER_PAGE_EXT_LETTERS          TEXT("cov")                                 // Used by MMC, CoverPage editor, and ClientConsole
#define FAX_COVER_PAGE_FILENAME_EXT         TEXT(".") FAX_COVER_PAGE_EXT_LETTERS        // Used by many
#define FAX_COVER_PAGE_MASK                 TEXT("*") FAX_COVER_PAGE_FILENAME_EXT       // Used by MMC, Outlook ext, and ClientConsole
#define FAX_TIF_FILE_EXT                    TEXT("tif")                                 // Used by the service
#define FAX_TIF_FILE_DOT_EXT                TEXT(".") FAX_TIF_FILE_EXT                  // Used by the service
#define FAX_TIF_FILE_MASK                   TEXT("*") FAX_TIF_FILE_DOT_EXT              // Used by the service
#define FAX_TIFF_FILE_EXT                   TEXT("tiff")                                // Used by print monitor
#define FAX_TIFF_FILE_DOT_EXT               TEXT(".") FAX_TIFF_FILE_EXT                 // Used by print monitor
#define FAX_TIFF_FILE_MASK                  TEXT("*") FAX_TIFF_FILE_DOT_EXT             // Used by print monitor
#define FAX_HTML_HELP_EXT                   TEXT("chm")                                 // Used by the client console
#define FAX_ADMIN_CONSOLE_IMAGE_NAME        TEXT("fxsadmin.msc")                        // Used by configuration wizard and ClientConsole
#define FAX_SERVICE_NAME                    TEXT("Fax")                                 // Used by the service
#define MESSENGER_SERVICE_NAME              TEXT("Messenger")                           // Name of the messenger service.
#define FAX_SERVICE_DISPLAY_NAME            TEXT("Microsoft Fax Server Service")        // Used by the service
#define FAX_SERVICE_DISPLAY_NAME_W          L"Microsoft Fax Server Service"             // Used by the service
#define FAX_PRINTER_NAME                    TEXT("Fax")                                 // Used everywhere
#define FAX_MONITOR_PORT_NAME               TEXT("SHRFAX:")                             // Used by print monitor and setup
#define FAX_PORT_NAME                       FAX_MONITOR_PORT_NAME                       // Used by print monitor and setup
#define FAX_DRIVER_NAME                     TEXT("Microsoft Shared Fax Driver")         // Used by print monitor and setup
#define FAX_DRIVER_NAME_A                   "Microsoft Shared Fax Driver"               // Used by print driver
#define FAX_WIN2K_DRIVER_NAME               TEXT("Windows NT Fax Driver")       // Legacy - for routing extension snap-in
#define FAX_MONITOR_NAME                    TEXT("Microsoft Shared Fax Monitor")        // Used by print monitor and setup
#define FAX_ADDRESS_TYPE_A                  "FAX"                                       // Used by MAPI transport
#define TRANSPORT_DISPLAY_NAME_STRING       "Microsoft Fax Mail Transport"              // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W2K        "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W9X        "AWFAX"                                     // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME            "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_T          TEXT(FAX_MESSAGE_SERVICE_NAME)
#define FAX_MESSAGE_PROVIDER_NAME           "MSFAX XPP"                                 // Used by MAPI transport
#define FAX_MESSAGE_PROVIDER_NAME_T         TEXT(FAX_MESSAGE_PROVIDER_NAME)
#define FAX_MESSAGE_SERVICE_NAME_SBS50      "SHAREDFAX XP"
#define FAX_MESSAGE_SERVICE_NAME_SBS50_T    TEXT(FAX_MESSAGE_SERVICE_NAME_SBS50)
#define FAX_MESSAGE_PROVIDER_NAME_SBS50     "SHAREDFAX XPP"
#define FAX_MESSAGE_PROVIDER_NAME_SBS50_T   TEXT(FAX_MESSAGE_PROVIDER_NAME_SBS50)


#define FAX_ROUTE_MODULE_NAME               TEXT("FXSROUTE")
#define FAX_T30_MODULE_NAME                 TEXT("FXST30")

#define FAX_MESSAGE_SERVICE_PROVIDER_NAME   "Microsoft Fax XPP"                         // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_PROVIDER_NAME_T TEXT(FAX_MESSAGE_SERVICE_PROVIDER_NAME)     // Used by MAPI transport
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME    "FXSXP.DLL"                                 // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T  TEXT(FAX_MESSAGE_TRANSPORT_IMAGE_NAME)      // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_RPC_ENDPOINTW                   L"SHAREDFAX"                                // Used by RPC - Same EndPoint as for BOS
#define FAX_RPC_ENDPOINT                    TEXT("SHAREDFAX")                           // Used by RPC - Same EndPoint as for BOS
#define FAX_CLIENT_CONSOLE_IMAGE_NAME       TEXT("FXSCLNT.exe")                         // Used by MMC
#define FAX_CONSOLE_RESOURCE_DLL            TEXT("FXSCLNTR.dll")                        // Fax Console resource DLL
#define FAX_CONTEXT_HELP_FILE               TEXT("FXSCLNT.hlp")                         // Used by ClientConsole
#define FAX_CLIENT_HELP_FILE                TEXT("FXSCLNT.chm")                         // Used by ClientConsole
#define FAX_COVERPAGE_HELP_FILE             TEXT("FXSCOVER.chm")                        // Used by the cover page editor
#define FAX_ADMIN_HELP_FILE                 TEXT("FXSADMIN.chm")                        // Used by MMC
#define FAX_CLIENTS_SHARE_NAME              TEXT("FxsClients$")                         // Used by FxsUI.dll
#define FAX_COVER_PAGES_SHARE_NAME          TEXT("FxsSrvCp$")                           // Used by send wizard
#define ADAPTIVE_ANSWER_SECTION             TEXT("Adaptive Answer Modems")              // Used by the service
#define REGKEY_CLIENT_EXT                   TEXT("Software\\Microsoft\\Exchange\\Client\\Extensions")   // Used by setup
#define EXCHANGE_CLIENT_EXT_FILE            "%windir%\\system32\\fxsext32.dll"          // Used by setup
#define FAX_FILENAME_FAXPERF_INI            TEXT("\\FXSPERF.INI")                       // Used by setup
#define USE_SERVER_DEVICE                   MAXDWORD                                    // Used by the service - this line id value is reserved for internal use.
#define SHARED_FAX_SERVICE_SETUP_LOG_FILE   TEXT("XPFaxServiceSetupLog.txt")
#define SERVICE_ALWAYS_RUNS                 TEXT("/AlwaysRun")                          // Command line parameter to service to disable idle-activity suicide
#define SERVICE_DELAY_SUICIDE               TEXT("/DelaySuicide")                       // Command line parameter to service to delay idle-activity suicide
                                                                                                                   // This event should be "Global" (see terminal services and named kernel objects)

#define FAX_MODEM_PROVIDER_NAME             TEXT("Windows Telephony Service Provider for Universal Modem Driver")

//
// Install types
//
#define FAX_INSTALL_NETWORK_CLIENT          0x00000001                                  // Used by the coverpage editor
#define FAX_INSTALL_SERVER                  0x00000002                                  // Used by the coverpage editor
#define FAX_INSTALL_WORKSTATION             0x00000004                                  // Used by the coverpage editor
#define FAX_INSTALL_REMOTE_ADMIN            0x00000008                                  // Used by the coverpage editor
//
// Product types
//
#define PRODUCT_TYPE_WINNT                  1                                           // Used by the utility library
#define PRODUCT_TYPE_SERVER                 2                                           // Used by the utility library
//
// Shared memory region name for faxui & faxxp32
//
#define FAX_ENVVAR_PRINT_FILE               TEXT("MS_FAX_PRINTFILE")
#define FAXXP_ATTACH_MUTEX_NAME             TEXT("MS_FAXXP_ATTACHMENT_MUTEX")
#define FAXXP_MEM_NAME                      TEXT("MS_FAXXP_ATTACHMENT_REGION")
#define FAXXP_MEM_MUTEX_NAME                TEXT("MS_FAXXP_ATTACHMENTREGION_MUTEX")
#define FAXXP_ATTACH_END_DOC_EVENT          TEXT("_END_DOC_EVENT")                      // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_ABORT_EVENT            TEXT("_ABORT_EVENT")                        // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_EVENT_NAME_LEN         (MAX_PATH+20)
//
// Fax dirs. These are hardcoded relative paths. We call into the shell to get the base path.
//
#define FAX_SHARE_DIR                       TEXT("Microsoft\\Windows NT\\MSFax")
#define FAX_QUEUE_DIR                       FAX_SHARE_DIR TEXT("\\Queue")               // Used by service

// The following are used by SecureFaxServiceDirectories()
#define FAX_INBOX_DIR                       FAX_SHARE_DIR TEXT("\\Inbox")
#define FAX_SENTITEMS_DIR                   FAX_SHARE_DIR TEXT("\\SentItems")
#define FAX_ACTIVITYLOG_DIR                 FAX_SHARE_DIR TEXT("\\ActivityLog")
#define FAX_COMMONCOVERPAGES_DIR            FAX_SHARE_DIR TEXT("\\Common Coverpages")


#define FAX_PREVIEW_TMP_DIR                 TEXT("\\FxsTmp")  // Created under %windir%\system32 with special permissions.
                                                              // Used for mapping of preview file in W2K and NT4 if
                                                              // Access to %windir%\system32 is denied for guest users.


/*****************************************************************************
**                                                                          **
**                     Registry keys, values, paths etc.                    **
**                                                                          **
*****************************************************************************/

//
// Fax Server Registry Root (relative to LOCAL_MACHINE or CURRENT_USER)
//
#define REGKEY_FAXSERVER_A              "Software\\Microsoft\\Fax"
#define REGKEY_FAXSERVER                TEXT(REGKEY_FAXSERVER_A)

#define REGKEY_CLIENT                   TEXT("Microsoft\\Fax")
#define CLIENT_ARCHIVE_KEY              TEXT("Archive")
#define CLIENT_ARCHIVE_MSGS_PER_CALL    TEXT("MessagesPerCall")
#define CLIENT_INBOX_VIEW               TEXT("InboxView")
#define CLIENT_SENT_ITEMS_VIEW          TEXT("SentItemsView")
#define CLIENT_INCOMING_VIEW            TEXT("IncomingView")
#define CLIENT_OUTBOX_VIEW              TEXT("OutboxView")
#define CLIENT_VIEW_COLUMNS             TEXT("Columns")
#define CLIENT_VIEW_COL_WIDTH           TEXT("Width")
#define CLIENT_VIEW_COL_SHOW            TEXT("Show")
#define CLIENT_VIEW_COL_ORDER           TEXT("Order")
#define CLIENT_VIEW_SORT_ASCENDING      TEXT("SortAscending")
#define CLIENT_VIEW_SORT_COLUMN         TEXT("SortColumn")
#define CLIENT_MAIN_FRAME               TEXT("MainFrame")
#define CLIENT_MAXIMIZED                TEXT("Maximized")
#define CLIENT_NORMAL_POS_TOP           TEXT("NormalPosTop")
#define CLIENT_NORMAL_POS_RIGHT         TEXT("NormalPosRight")
#define CLIENT_NORMAL_POS_BOTTOM        TEXT("NormalPosBottom")
#define CLIENT_NORMAL_POS_LEFT          TEXT("NormalPosLeft")
#define CLIENT_SPLITTER_POS             TEXT("SplitterPos")
#define CLIENT_CONFIRM_SEC              TEXT("Confirm")
#define CLIENT_CONFIRM_ITEM_DEL         TEXT("ItemDeletion")
//
// Registry values stored under HKEY_CURRENT_USER
//
//
// User information is stored under Fax\UserInfo subkey
//
#define   REGVAL_FULLNAME                       TEXT("FullName")
#define   REGVAL_FAX_NUMBER                     TEXT("FaxNumber")
#define   REGVAL_MAILBOX                        TEXT("Mailbox")
#define   REGVAL_COMPANY                        TEXT("Company")
#define   REGVAL_TITLE                          TEXT("Title")
#define   REGVAL_ADDRESS                        TEXT("Address")
#define   REGVAL_CITY                           TEXT("City")
#define   REGVAL_STATE                          TEXT("State")
#define   REGVAL_ZIP                            TEXT("ZIP")
#define   REGVAL_COUNTRY                        TEXT("Country")
#define   REGVAL_DEPT                           TEXT("Department")
#define   REGVAL_OFFICE                         TEXT("Office")
#define   REGVAL_HOME_PHONE                     TEXT("HomePhone")
#define   REGVAL_OFFICE_PHONE                   TEXT("OfficePhone")
#define   REGVAL_BILLING_CODE                   TEXT("BillingCode")

#define   REGVAL_COVERPG                        TEXT("CoverPageFile")
#define   REGVAL_LAST_COUNTRYID                 TEXT("LastCountryID")
#define   REGVAL_LAST_RECNAME                   TEXT("LastRecipientName")
#define   REGVAL_LAST_RECNUMBER                 TEXT("LastRecipientNumber")
#define   REGVAL_USE_DIALING_RULES              TEXT("LastUseDialingRules")
#define   REGVAL_USE_OUTBOUND_ROUTING           TEXT("LastUseOutboundRouting")
#define   REGVAL_STRESS_INDEX                   TEXT("LastStressPrinterIndex")
#define   REGVAL_NEXT_COVERPAGE_TIP             TEXT("NextCoverPageTip")

#define   REGVAL_RECEIPT_NO_RECEIPT             TEXT("ReceiptNoRecipt")
#define   REGVAL_RECEIPT_GRP_PARENT             TEXT("ReceiptGroupParent")
#define   REGVAL_RECEIPT_MSGBOX                 TEXT("ReceiptMessageBox")
#define   REGVAL_RECEIPT_EMAIL                  TEXT("ReceiptEMail")
#define   REGVAL_RECEIPT_ADDRESS                TEXT("ReceiptAddress")
#define   REGVAL_RECEIPT_ATTACH_FAX             TEXT("ReceiptAttachFax")
//
// Status UI configuration values
//
#define   REGVAL_DEVICE_TO_MONITOR              TEXT("DeviceToMonitor") // device ID for monitoring
#define   REGVAL_MONITOR_ON_SEND                TEXT("MonitorOnSend")
#define   REGVAL_MONITOR_ON_RECEIVE             TEXT("MonitorOnReceive")
#define   REGVAL_NOTIFY_PROGRESS                TEXT("NotifyProgress")
#define   REGVAL_NOTIFY_IN_COMPLETE             TEXT("NotifyIncomingCompletion")
#define   REGVAL_NOTIFY_OUT_COMPLETE            TEXT("NotifyOutgoingCompletion")

#define   REGVAL_SOUND_ON_RING                  TEXT("SoundOnRing")
#define   REGVAL_SOUND_ON_RECEIVE               TEXT("SoundOnReceive")
#define   REGVAL_SOUND_ON_SENT                  TEXT("SoundOnSent")
#define   REGVAL_SOUND_ON_ERROR                 TEXT("SoundOnError")

#define   REGVAL_ALWAYS_ON_TOP                  TEXT("AlwaysOnTop")

//
// Fax status monitor and fax notification bar icon contants:
//
#define FAXSTAT_WINCLASS                        TEXT("FaxMonWinClass{3FD224BA-8556-47fb-B260-3E451BAE2793}")    // Window class for fax notification bar messages
#define FAX_SYS_TRAY_DLL                        TEXT("fxsst.dll")   // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                         "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                             // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC               "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();                       // FaxMonitorShutdown type
#define WM_FAXSTAT_CONTROLPANEL                 (WM_USER + 201)     // Fax notification bar configuration has changed
#define WM_FAXSTAT_OPEN_MONITOR                 (WM_USER + 211)     // User explicitly asks for fax status monitor
#define WM_FAXSTAT_INBOX_VIEWED                 (WM_USER + 212)     // Message viewed or deleted in the fax client console's inbox folder
#define WM_FAXSTAT_OUTBOX_VIEWED                (WM_USER + 213)     // Message in error was restarted or deleted in the fax client console's outbox folder
#define WM_FAXSTAT_RECEIVE_NOW                  (WM_USER + 214)     // Start receiving now
#define WM_FAXSTAT_PRINTER_PROPERTY             (WM_USER + 215)     // Open Fax Printer Property Sheet. WPARAM is an initiall page number

//
// Setup information is stored under Fax\Setup subkey
//
#define REGKEY_FAX_SETUP                        REGKEY_FAXSERVER TEXT("\\Setup")
#define REGKEY_FAX_SETUP_SUBKEY                 TEXT("Setup")

#define   REGVAL_CP_LOCATION                    TEXT("CoverPageDir")
#define   REGVAL_FAXINSTALLED                   TEXT("Installed")
#define   REGVAL_PRODUCT_SKU                    TEXT("ProductSKU")
#define   REGVAL_PRODUCT_BUILD                  TEXT("ProductBuild")
#define   REGVAL_SETUP_IN_PROGRESS				TEXT("SetupInProgress")
#define   REGVAL_IS_SHARED_FAX_PRINTER          TEXT("IsFaxPrinterShared")
#define   REGVAL_DONT_UNATTEND_INSTALL          TEXT("DenyUnattendInstall")
#define   REGVAL_FAXINSTALL_TYPE                TEXT("InstallType")
#define   REGVAL_FAXINSTALLED_PLATFORMS         TEXT("InstalledPlatforms")
#define   REGVAL_CFGWZRD_USER_INFO              TEXT("CfgWzdrUserInfo")
#define   REGVAL_CPE_CONVERT                    TEXT("WereCpesConverted")
#define   REGVAL_CFGWZRD_DISABLE_ROUTING        TEXT("DisableRoutingExtensionConfiguration")
#define   REGVAL_IMPORT_INFO                    TEXT("ImportInfoDisplayed")
#define   REGVAL_INSTALLED_COMPONENTS           TEXT("InstalledComponents")
#define   REGVAL_W2K_SENT_ITEMS                 TEXT("W2K_SentItems")
#define   REGVAL_W2K_INBOX                      TEXT("W2K_Inbox")

//
// Client information is stored under Fax\Client subkey
//
#define REGKEY_FAX_CLIENT                        REGKEY_FAXSERVER TEXT("\\Client")
#define REGKEY_FAX_CLIENT_SUBKEY                 TEXT("Client")

#define 	REGVAL_DBGLEVEL                         TEXT("DebugLevel")
#define 	REGVAL_DBGLEVEL_EX                      TEXT("DebugLevelEx")
#define 	REGVAL_DBGFORMAT_EX                     TEXT("DebugFormatEx")
#define 	REGVAL_DBGCONTEXT_EX                    TEXT("DebugContextEx")
#define 	REGVAL_DBG_SKU                          TEXT("DebugSKU")

#define 	REGVAL_SERVER_CP_LOCATION              TEXT("ServerCoverPageDir")
#define 	REGVAL_CFGWZRD_DEVICE                  TEXT("CfgWzdrDevice")
//
// Service startup information is stored under Fax\Client\ServiceStartup subkey
//
#define 	REGKEY_FAX_SERVICESTARTUP               REGKEY_FAX_CLIENT TEXT("\\ServiceStartup")
#define 	REGKEY_FAX_SERVICESTARTUP_SUBKEY        TEXT("ServiceStartup")
#define   		REGVAL_FAX_RPC_READY                  TEXT("RPCReady")




#define DEFAULT_COVERPAGE_EDITOR                FAX_COVER_IMAGE_NAME    // Used by print\faxprint\lib\registry.c
#define DEFAULT_COVERPAGE_DIR                   TEXT("%systemroot%\\Fax\\CoverPg")

#define REGKEY_INSTALLLOCATION                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_DEFAULT_TSID                     TEXT("Fax")
#define REGVAL_DEFAULT_CSID                     TEXT("Fax")

//
// Per-user devmode information is stored under Fax\Devmode subkey
//
#define REGKEY_FAX_DEVMODE                      REGKEY_FAXSERVER TEXT("\\Devmode")
//
// Registry values stored under HKEY_LOCAL_MACHINE
//

//
// Server registry values
// stored under REGKEY_FAXSERVER
//

#define FAX_SVC_EVENT                           TEXT("Microsoft Fax")
#define REGKEY_EVENTLOG                         TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\") FAX_SVC_EVENT

#define   REGVAL_EVENTMSGFILE                   TEXT("EventMessageFile")
#define   REGVAL_CATEGORYMSGFILE                TEXT("CategoryMessageFile")
#define   REGVAL_CATEGORYCOUNT                  TEXT("CategoryCount")
#define   REGVAL_TYPESSUPPORTED                 TEXT("TypesSupported")

#define REGKEY_SOFTWARE                         REGKEY_FAXSERVER

#define   REGVAL_RETRIES                        TEXT("Retries")
#define   REGVAL_RETRYDELAY                     TEXT("Retry Delay")
#define   REGVAL_MANUAL_ANSWER_DEVICE           TEXT("ManualAnswerDevice")
#define   REGVAL_DIRTYDAYS                      TEXT("Dirty Days")
#define   REGVAL_BRANDING                       TEXT("Branding")
#define   REGVAL_USE_DEVICE_TSID                TEXT("UseDeviceTsid")
#define   REGVAL_SERVERCP                       TEXT("ServerCoverPageOnly")
#define   REGVAL_STARTCHEAP                     TEXT("StartCheapTime")
#define   REGVAL_STOPCHEAP                      TEXT("StopCheapTime")
#define   REGVAL_QUEUE_STATE                    TEXT("QueueState")
#define   REGVAL_QUEUE_DIRECTORY                TEXT("QueueDirectory")
#define   REGVAL_JOB_NUMBER                     TEXT("NextJobNumber")
#define   REGVAL_MAX_LINE_CLOSE_TIME            TEXT("MaxLineCloseTime")
#define	  REGVAL_RECIPIENTS_LIMIT		        TEXT("RecipientsLimit")
#define	  REGVAL_ALLOW_REMOTE			        TEXT("AllowRemote")  // Allow remote calls even if printer is not shared.
#define   REGVAL_USE_DEFAULT_FAULT_HANDLING_POLICY  TEXT("UseDefaultFaultHandlingPolicy")
//
// 31 days * 24 hours * 60 minutes * 60 seconds * 1000000 microseconds * 10 (100 ns is one unit)
//
#define   DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME 26784000000000

#define   DEFAULT_REGVAL_RETRIES                3
#define   DEFAULT_REGVAL_RETRYDELAY             10
#define   DEFAULT_REGVAL_DIRTYDAYS              30
#define   DEFAULT_REGVAL_BRANDING               1
#define   DEFAULT_REGVAL_USEDEVICETSID          1
#define   DEFAULT_REGVAL_SERVERCP               0
#define   DEFAULT_REGVAL_STARTCHEAP             MAKELONG(20,0)
#define   DEFAULT_REGVAL_STOPCHEAP              MAKELONG(7,0)
#define   DEFAULT_REGVAL_QUEUE_STATE            0
#define   DEFAULT_REGVAL_JOB_NUMBER             1

#define   REGKEY_DEVICE_PROVIDERS               TEXT("Device Providers")
#define     REGVAL_FRIENDLY_NAME                TEXT("FriendlyName")
#define     REGVAL_IMAGE_NAME                   TEXT("ImageName")
#define     REGVAL_PROVIDER_NAME                TEXT("ProviderName")
#define     REGVAL_PROVIDER_GUID                TEXT("GUID")
#define     REGVAL_PROVIDER_API_VERSION         TEXT("APIVersion")

//
// The following value is the base device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE   DWORD(0x20000)
//
// The following value is the base for our internal unique fax ids
//
#define     DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE        DWORD(0x10000)

//
// How device ids are allocated:
// -----------------------------
// Fax unique devices (allocated by the server), VFSP devices, and EVFSP devices all share
// the same device id space (32-bit = 4GB of ids).
//
// Notice: TAPI permanent line ids (used by FSPs / EFSPs) are not in this space.
//
// Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
//     Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
//     and leave segments allocation to a PM effort here.
//
// Range [DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE ... DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE-1] :
//     Used by the fax server for the unique device ids of TAPI devices discovered by the server.
//
// Range [DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE ... MAXDWORD] : 
// Reserved for future use.
//

// *****************************************************************************
// *****************************************************************************
//                  VFSPs Device ID prefix given so far....
// *****************************************************************************
// 1. DeviceIdPrefix = 0x1. ------> VisionLab    http://VisionLab.com
//
// *****************************************************************************
// *****************************************************************************


#define   REGKEY_RECEIPTS_CONFIG                TEXT("Receipts")    // Key of receipts configuration
#define     REGVAL_RECEIPTS_TYPE                TEXT("Type")        // Receipts supported
#define     REGVAL_RECEIPTS_SERVER              TEXT("Server")      // SMTP Server's name
#define     REGVAL_RECEIPTS_PORT                TEXT("Port")        // SMTP Server's port
#define     REGVAL_RECEIPTS_FROM                TEXT("From")        // SMTP sender address
#define     REGVAL_RECEIPTS_USER                TEXT("User")        // SMTP user name
#define     REGVAL_RECEIPTS_PASSWORD            TEXT("Password")    // SMTP password
#define     REGVAL_RECEIPTS_SMTP_AUTH_TYPE      TEXT("SMTPAuth")    // SMTP authentication type
#define     REGVAL_ISFOR_MSROUTE                TEXT("UseForMsRoute")  // TRUE if to use for MS route through e-mail method

#define     DEFAULT_REGVAL_SMTP_PORT            25                  // Default SMTP port number

#define   REGKEY_ARCHIVE_SENTITEMS_CONFIG       TEXT("SentItems")// Key of SentItems archive configuration
#define   REGKEY_ARCHIVE_INBOX_CONFIG           TEXT("Inbox")    // Key of Inbox archive configuration
#define     REGVAL_ARCHIVE_USE                  TEXT("Use")      // Archive?
#define     REGVAL_ARCHIVE_FOLDER               TEXT("Folder")   // Archive location
#define     REGVAL_ARCHIVE_SIZE_QUOTA_WARNING   TEXT("SizeQuotaWarn") // Warn on size excess?
#define     REGVAL_ARCHIVE_HIGH_WATERMARK       TEXT("HighWatermark") // Warning high watermark
#define     REGVAL_ARCHIVE_LOW_WATERMARK        TEXT("LowWatermark")  // Warning low watermark
#define     REGVAL_ARCHIVE_AGE_LIMIT            TEXT("AgeLimit") // Archive age limit

#define     DEFAULT_REGVAL_ARCHIVE_USE          0        // Don't use archive by default
#define     DEFAULT_REGVAL_ARCHIVE_FOLDER       TEXT("") // Default location of archive
#define     DEFAULT_REGVAL_SIZE_QUOTA_WARNING   1        // Warn on size by default
#define     DEFAULT_REGVAL_HIGH_WATERMARK       100      // High watermark default
#define     DEFAULT_REGVAL_LOW_WATERMARK        95       // Low watermark default
#define     DEFAULT_REGVAL_AGE_LIMIT            60       // Default archive age limit

#define   REGKEY_ACTIVITY_LOG_CONFIG                    TEXT("ActivityLogging")         // Key of Activity Logging configuration
#define     REGVAL_ACTIVITY_LOG_DB                      TEXT("DBFile")                  // Database file
#define     REGVAL_ACTIVITY_LOG_IN                      TEXT("LogIncoming")             // Log incoming faxes?
#define     REGVAL_ACTIVITY_LOG_OUT                     TEXT("LogOutgoing")             // Log outgoing faxes?
#define     REGVAL_ACTIVITY_LOG_LIMIT_CRITERIA          TEXT("LogLimitCriteria")        // The activity log file limitting criteria - Size or Age
#define     REGVAL_ACTIVITY_LOG_SIZE_LIMIT              TEXT("LogSizeLimit")            // The activity log files size limit in MBytes
#define     REGVAL_ACTIVITY_LOG_AGE_LIMIT               TEXT("LogAgeLimit")             // The activity log files age limit in Months
#define     REGVAL_ACTIVITY_LOG_LIMIT_REACHED_ACTION    TEXT("LogLimitReachedAction")   // Delete log file or rename it when file limit reached 

#define   REGKEY_OUTBOUND_ROUTING                   TEXT("Outbound Routing")   // Outbound routing key
#define     REGKEY_OUTBOUND_ROUTING_GROUPS          TEXT("Groups")             // Outbound routing groups key
#define         REGVAL_ROUTING_GROUP_DEVICES        TEXT("Devices")            // List of all group's devices
#define     REGKEY_OUTBOUND_ROUTING_RULES           TEXT("Rules")              // Outbound routing rules key
#define         REGVAL_ROUTING_RULE_COUNTRY_CODE    TEXT("CountryCode")        // Outbound routing rule country code
#define         REGVAL_ROUTING_RULE_AREA_CODE       TEXT("AreaCode")           // Outbound routing rule area code
#define         REGVAL_ROUTING_RULE_GROUP_NAME      TEXT("GroupName")          // Outbound routing rule dest group name
#define         REGVAL_ROUTING_RULE_DEVICE_ID       TEXT("DeviceID")           // Outbound routing rule dest device ID
#define         REGVAL_ROUTING_RULE_USE_GROUP       TEXT("UseGroup")           // Flag inidicating to use group destination

#define   REGKEY_ROUTING_EXTENSIONS             TEXT("Routing Extensions")
#define     REGKEY_ROUTING_METHODS              TEXT("Routing Methods")
#define         REGVAL_FUNCTION_NAME            TEXT("Function Name")
#define         REGVAL_GUID                     TEXT("Guid")
#define         REGVAL_ROUTING_PRIORITY         TEXT("Priority")

#define   REGKEY_UNASSOC_EXTENSION_DATA         TEXT("UnassociatedExtensionData")
#define   REGKEY_DEVICES                        TEXT("Devices")
#define     REGKEY_FAXSVC_DEVICE_GUID           TEXT("{F10A5326-0261-4715-B367-2970427BBD99}")
#define       REGVAL_DEVICE_NAME                TEXT("Device Name")
#define       REGVAL_PROVIDER                   TEXT("Provider Name")
#define       REGVAL_PERMANENT_LINEID           TEXT("Permanent Lineid")
#define       REGVAL_TAPI_PERMANENT_LINEID      TEXT("TAPI Permanent Lineid")

#define       REGVAL_FLAGS                      TEXT("Flags")
#define       REGVAL_RINGS                      TEXT("Rings")
#define       REGVAL_ROUTING_CSID               TEXT("CSID")
#define       REGVAL_ROUTING_TSID               TEXT("TSID")
#define       REGVAL_DEVICE_DESCRIPTION         TEXT("Description")
#define       REGVAL_LAST_DETECTED_TIME         TEXT("LastDetected")
#define       REGVAL_MANUAL_ANSWER              TEXT("ManualAnswer")

#define       REGVAL_LAST_UNIQUE_LINE_ID        TEXT("LastUniqueLineId")

#define   REGKEY_LOGGING                        TEXT("Logging")
#define     REGVAL_CATEGORY_NAME                TEXT("Name")
#define     REGVAL_CATEGORY_LEVEL               TEXT("Level")
#define     REGVAL_CATEGORY_NUMBER              TEXT("Number")

#define   REGKEY_DEVICES_CACHE                  TEXT("Devices Cache")
#define     REGKEY_TAPI_DATA                    TEXT("TAPI Data")

#define REGKEY_TAPIDEVICES_CONFIG               TEXT("TAPIDevices")

#define REGKEY_USERINFO                         TEXT("UserInfo")

#define REGKEY_FAX_LOGGING                      REGKEY_FAXSERVER TEXT("\\") REGKEY_LOGGING
#define REGKEY_FAX_RECEIPTS                     REGKEY_FAXSERVER TEXT("\\") REGKEY_RECEIPTS_CONFIG
#define REGKEY_FAX_INBOX                        REGKEY_FAXSERVER TEXT("\\") REGKEY_ARCHIVE_INBOX_CONFIG
#define REGKEY_FAX_SENTITEMS                    REGKEY_FAXSERVER TEXT("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG
#define REGKEY_FAX_DEVICES                      REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICES
#define REGKEY_FAX_UNASS_DATA					REGKEY_FAX_DEVICES TEXT("\\") REGKEY_UNASSOC_EXTENSION_DATA
#define REGKEY_FAX_DEVICES_CACHE                REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICES_CACHE
#define REGKEY_TAPIDEVICES                      REGKEY_FAXSERVER TEXT("\\") REGKEY_TAPIDEVICES_CONFIG
#define REGKEY_DEVICE_PROVIDER_KEY              REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICE_PROVIDERS
#define REGKEY_ROUTING_EXTENSION_KEY            REGKEY_FAXSERVER TEXT("\\") REGKEY_ROUTING_EXTENSIONS
#define REGKEY_FAX_USERINFO                     REGKEY_FAXSERVER TEXT("\\") REGKEY_USERINFO
#define REGKEY_FAX_OUTBOUND_ROUTING             REGKEY_FAXSERVER TEXT("\\") REGKEY_OUTBOUND_ROUTING
#define REGKEY_FAX_OUTBOUND_ROUTING_GROUPS      REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\") REGKEY_OUTBOUND_ROUTING_GROUPS
#define REGKEY_FAX_OUTBOUND_ROUTING_RULES       REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\") REGKEY_OUTBOUND_ROUTING_RULES

#define REGKEY_FAX_SETUP_ORIG                   REGKEY_FAX_SETUP TEXT("\\Original Setup Data")
//
// device provider reg values
//
#define REGKEY_MODEM_PROVIDER                   TEXT("Microsoft Modem Device Provider")
#define   REGVAL_T30_PROVIDER_GUID_STRING       TEXT("{2172FD8F-11F6-11d3-90BF-006094EB630B}")
//
// MSFT standard routing methods
//
#define REGKEY_ROUTING_METHOD_EMAIL             TEXT("Email")
#define   REGVAL_RM_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_FOLDER            TEXT("Folder")
#define   REGVAL_RM_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_PRINTING          TEXT("Printing")
#define   REGVAL_RM_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
//
// GUID of routing methods usage flags - used by the Microsoft Fax Routing Extension DLL:
//
#define   REGVAL_RM_FLAGS_GUID                  TEXT("{aacc65ec-0091-40d6-a6f3-a2ed6057e1fa}")
//
// Routing mask bits
//
#define LR_PRINT                                0x00000001
#define LR_STORE                                0x00000002
#define LR_INBOX                                0x00000004
#define LR_EMAIL                                0x00000008
//
// Routing extension reg values
//
#define REGKEY_ROUTING_EXTENSION                TEXT("Microsoft Routing Extension")
//
// Performance key/values
//
#define REGKEY_FAXPERF                          TEXT("SYSTEM\\CurrentControlSet\\Services\\") FAX_SERVICE_NAME TEXT("\\Performance")
#define   REGVAL_OPEN                           TEXT("Open")
#define     REGVAL_OPEN_DATA                    TEXT("OpenFaxPerformanceData")
#define   REGVAL_CLOSE                          TEXT("Close")
#define     REGVAL_CLOSE_DATA                   TEXT("CloseFaxPerformanceData")
#define   REGVAL_COLLECT                        TEXT("Collect")
#define     REGVAL_COLLECT_DATA                 TEXT("CollectFaxPerformanceData")
#define   REGVAL_LIBRARY                        TEXT("Library")
#define     REGVAL_LIBRARY_DATA                 TEXT("%systemroot%\\system32\\fxsperf.dll")
//
// Security descriptors
//
#define REGKEY_SECURITY_CONFIG                  TEXT("Security")
#define REGKEY_FAX_SECURITY                     REGKEY_FAXSERVER TEXT("\\") REGKEY_SECURITY_CONFIG
#define   REGVAL_DESCRIPTOR                     TEXT("Descriptor")

//
// default mail client
//
#define  REGKEY_MAIL_CLIENT     TEXT("SOFTWARE\\Clients\\Mail")
#define  REGVAL_MS_OUTLOOK      TEXT("Microsoft Outlook")

#define  REGKEY_OUTLOOK_CUR_VER TEXT("SOFTWARE\\Classes\\Outlook.Application\\CurVer")

//
// Windows Address Book (WAB) location
//
#define  REGVAL_WABPATH         TEXT("Software\\Microsoft\\WAB\\DLLPath")

//
// Combined translated strings from the wizard to the service
// Format is "{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED<dialable string>{11d0ecca-4072-4c7b-9af1-541d9778375f}<displayable string>"
//
#define COMBINED_PREFIX                         TEXT("{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED")
#define COMBINED_SUFFIX                         TEXT("{11d0ecca-4072-4c7b-9af1-541d9778375f}")
#define COMBINED_TRANSLATED_STRING_FORMAT       COMBINED_PREFIX TEXT("%s") COMBINED_SUFFIX TEXT("%s")
#define COMBINED_TRANSLATED_STRING_EXTRA_LEN    (_tcslen(COMBINED_TRANSLATED_STRING_FORMAT) - 4)

//
// These prefixes are used by all temp preview TIFF files (generated by the client console and the fax send wizard)
//
#define CONSOLE_PREVIEW_TIFF_PREFIX                     TEXT("MSFaxConsoleTempPreview-#")
#define WIZARD_PREVIEW_TIFF_PREFIX                      TEXT("MSFaxWizardTempPreview-#")

#define FAX_ADDERSS_VALID_CHARACTERS                    TEXT("0123456789 -|^!#$*,?@ABCbcdDPTWdptw")

//
// Client console command line parameters.
// All parameters are case insensitive.
//
#define CONSOLE_CMD_FLAG_STR_FOLDER                     TEXT("folder")          // Sets initial startup folder. Usage: "fxsclnt.exe /folder <folder>"
#define CONSOLE_CMD_PRM_STR_OUTBOX                      TEXT("outbox")          // Outbox startup folder. Usage: "fxsclnt.exe /folder outbox"
#define CONSOLE_CMD_PRM_STR_INCOMING                    TEXT("incoming")        // Incoming startup folder. Usage: "fxsclnt.exe /folder incoming"
#define CONSOLE_CMD_PRM_STR_INBOX                       TEXT("inbox")           // Inbox startup folder. Usage: "fxsclnt.exe /folder inbox". This is the default
#define CONSOLE_CMD_PRM_STR_SENT_ITEMS                  TEXT("sent_items")      // sent items startup folder. Usage: "fxsclnt.exe /folder sent_items"

#define CONSOLE_CMD_FLAG_STR_MESSAGE_ID                 TEXT("MessageId")       // Select a message in the startup folder. Usage: "fxsclnt.exe /MessageId 0x0201c0d62f36ec0b"
#define CONSOLE_CMD_FLAG_STR_NEW                        TEXT("New")             // Force a new instance. Usage: "fxsclnt.exe /new"


//
// This is the prefix of optionally non-secure settings.
// For example:
//     In WinXP RTM, extension configuration data was written unencrypted to the registry.
//     In Win .NET Server, the same data is now written encrypted.
//     Since the service code of Win .NET Server is the same as WinXP SP1, the same code
//     should be able to read encrypted AND non-encrypted data.
//
//     If the bOptionallyNonSecure flag is set in the SetRegistrySecureBinary and SetRegistrySecureString
//     functions, the data is encrypted but written to the registry prefixed with FAX_REG_SECURITY_PREFIX.
//
//     If the bOptionallyNonSecure flag is set in the GetRegistrySecureBinary and GetRegistrySecureString
//     functions, the data is read from the registry and checked for a prefix of FAX_REG_SECURITY_PREFIX.
//     If the prefix is not there, the data is considered to be non-encrypted (e.g. WinXP RTM data)
//     and it is returned as-is without decryption. Otherwise, it is properly decrypted.
//
#define FAX_REG_SECURITY_PREFIX TEXT("{5b04adaa-5e01-4160-a61e-02d27d44f9db}")


// This SD is used when setting the security on Fax folders under CSIDL_COMMON_APPDATA:
// 1. When changing locations from the UI
// 2. When upgrading from BOS/SBS2000, and migrating the old archives
// 3. After converting the system partition from FAT to NTFS
//
#define SD_FAX_FOLDERS  TEXT("D:PAI(A;OICI;FA;;;BA)(A;OICI;FA;;;NS)")   // Administrators have full access, Network service have full access

// This SD is used when setting the security on Common Coverpages folder under CSIDL_COMMON_APPDATA:
// 3. After converting the system partition from FAT to NTFS
//
#define SD_COMMON_COVERPAGES  TEXT("D:PAI(A;OICI;FA;;;BA)(A;OICI;0x1200a9;;;WD)")  // Everyone can read, Administrators have full control

#endif  // !_FAXREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxrpclimit.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    FaxRpcLimit.h

Abstract:

    This file provides declaration of RPC buffer limits.    

Author:

    Oded Sacher (OdedS)  Dec, 2001

Revision History:

--*/

#ifndef _FAX_RPC_LIMIT_H
#define _FAX_RPC_LIMIT_H

//
// RPC buffer limits
//
#define FAX_MAX_RPC_BUFFER			(1024 * 1024)	// Limits BYTE buffer to 1 MB.
#define FAX_MAX_DEVICES_IN_GROUP	1000			// Limits the number of devices in an outbound routing group passed to RPC.
#define FAX_MAX_RECIPIENTS			10000			// Limits the number of recipients in a broadcast job passed to RPC.
#define RPC_COPY_BUFFER_SIZE        16384			// Size of data chunk used in RPC file copy

#endif // _FAX_RPC_LIMIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxsendw.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsendw.h

Abstract:

    

Environment:

    

Revision History:

    10/05/99 -v-sashab-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef __FAXSENDW_H_
#define __FAXSENDW_H_

#include <fxsapip.h>

typedef struct {
    DWORD                   dwSizeOfStruct;
    PFAX_COVERPAGE_INFO_EX  lpCoverPageInfo;
    DWORD                   dwNumberOfRecipients;
    PFAX_PERSONAL_PROFILE   lpRecipientsInfo;	
    PFAX_PERSONAL_PROFILE   lpSenderInfo;	
    BOOL                    bSaveSenderInfo;
    BOOL                    bUseDialingRules;
    BOOL                    bUseOutboundRouting;
    DWORD                   dwScheduleAction;
    SYSTEMTIME              tmSchedule;
    DWORD                   dwReceiptDeliveryType;
    LPTSTR                  szReceiptDeliveryAddress; // Depending on the value of dwReceiptDeliveryType this holds:
                                                      // DRT_MSGBOX: The computer name to which the message will be delivered
                                                      // DRT_EMAIL: SMTP address to deliver the receipt to
    LPTSTR                  lptstrPreviewFile;        // The full path to the TIFF to be used as the based for the preview (no cover page included)
    BOOL                    bShowPreview;             // TRUE if the preview option should be enabled
    DWORD                   dwPageCount;              // The number of pages in the preview TIFF (not including cover page). 
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwLastRecipientCountryId;
} FAX_SEND_WIZARD_DATA,*LPFAX_SEND_WIZARD_DATA;

enum {	
	FSW_FORCE_COVERPAGE		= 1,
	FSW_FORCE_SUBJECT_OR_NOTE	= 2,
	FSW_USE_SCANNER			= 4,
	FSW_USE_SCHEDULE_ACTION		= 8,
	FSW_USE_RECEIPT			= 16,
	FSW_USE_SEND_WIZARD		= 32,
	FSW_RESEND_WIZARD		= 64,
	FSW_PROPERTY_SHEET		= 128,
        FSW_PRINT_PREVIEW_OPTION    	= 256
};

#endif //__FAXSENDW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxroute.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    faxroute.h

Abstract:

    This file contains the prototypes for the
    FAX routing extension API.


--*/

#include <commctrl.h>

#ifndef _FAXROUTE_
#define _FAXROUTE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// microsoft routing guids
//

#define MS_FAXROUTE_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

//
// callback routines
//

typedef LONG (WINAPI *PFAXROUTEADDFILE)(DWORD JobId, LPCWSTR FileName, GUID *Guid);
typedef LONG (WINAPI *PFAXROUTEDELETEFILE)(DWORD JobId, LPCWSTR FileName);
typedef BOOL (WINAPI *PFAXROUTEGETFILE)(DWORD JobId, DWORD Index, LPWSTR FileNameBuffer, LPDWORD RequiredSize);
typedef BOOL (WINAPI *PFAXROUTEENUMFILE)(DWORD JobId, GUID *GuidOwner, GUID *GuidCaller, LPCWSTR FileName, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEENUMFILES)(DWORD JobId, GUID *Guid,PFAXROUTEENUMFILE FileEnumerator, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEMODIFYROUTINGDATA)(DWORD JobId, LPCWSTR RoutingGuid, LPBYTE RoutingData, DWORD RoutingDataSize );


typedef struct _FAX_ROUTE_CALLBACKROUTINES {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
} FAX_ROUTE_CALLBACKROUTINES, *PFAX_ROUTE_CALLBACKROUTINES;


//
// routing data structure
//

typedef struct _FAX_ROUTE {
    DWORD           SizeOfStruct;       // size of the struct set by the fax service
    DWORD           JobId;              // Fax job identifier
    DWORDLONG       ElapsedTime;        // Elapsed time for whole fax job in Coordinated Universal Time (UTC)
    DWORDLONG       ReceiveTime;        // Starting time for fax job in Coordinated Universal Time (UTC)
    DWORD           PageCount;          // Number of pages received
    LPCWSTR         Csid;               // Called station identifier
    LPCWSTR         Tsid;               // Transmitting station identifier
    LPCWSTR         CallerId;           // Caller id
    LPCWSTR         RoutingInfo;        // Routing info such as DID, T.30-subaddress, etc.
    LPCWSTR         ReceiverName;       // Receiver's name
    LPCWSTR         ReceiverNumber;     // Receiver's fax number
    LPCWSTR         DeviceName;         // Device name for the line that received the fax
    DWORD           DeviceId;           // Permenant line identifier for the receiving device
    LPBYTE          RoutingInfoData;    // Routing infor data to override configured info
    DWORD           RoutingInfoDataSize;// Size of routing info data
} FAX_ROUTE, *PFAX_ROUTE;

enum FAXROUTE_ENABLE {
    QUERY_STATUS = -1,
    STATUS_DISABLE = 0,
    STATUS_ENABLE = 1
};


//
// prototypes
//

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    );

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    );

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    );

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    );

BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    );


typedef BOOL (WINAPI *PFAXROUTEINITIALIZE)               (HANDLE,PFAX_ROUTE_CALLBACKROUTINES);
typedef BOOL (WINAPI *PFAXROUTEMETHOD)                   (const FAX_ROUTE*,PVOID*,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTEDEVICEENABLE)             (LPCWSTR,DWORD,LONG);
typedef BOOL (WINAPI *PFAXROUTEDEVICECHANGENOTIFICATION) (DWORD,BOOL);
typedef BOOL (WINAPI *PFAXROUTEGETROUTINGINFO)           (LPCWSTR,DWORD,LPBYTE,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTESETROUTINGINFO)           (LPCWSTR,DWORD,const BYTE*,DWORD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxsuite.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxSuite.h

Abstract:

    This file provides declaration of the Fax SKU values.

Author:

    Oded Sacher (OdedS)  Dec, 2001

Revision History:

--*/

#ifndef _FAX_SUITE_H
#define _FAX_SUITE_H

typedef enum
{
    PRODUCT_SKU_UNKNOWN             = 0x0000,
    PRODUCT_SKU_PERSONAL            = 0x0001,
    PRODUCT_SKU_PROFESSIONAL        = 0x0002,
    PRODUCT_SKU_SERVER              = 0x0004,
    PRODUCT_SKU_ADVANCED_SERVER     = 0x0008,
    PRODUCT_SKU_DATA_CENTER         = 0x0010,
    PRODUCT_SKU_DESKTOP_EMBEDDED    = 0x0020,
    PRODUCT_SKU_SERVER_EMBEDDED     = 0x0040,
    PRODUCT_SKU_WEB_SERVER          = 0x0080,
    PRODUCT_SERVER_SKUS             = PRODUCT_SKU_SERVER | PRODUCT_SKU_ADVANCED_SERVER | PRODUCT_SKU_DATA_CENTER | PRODUCT_SKU_SERVER_EMBEDDED | PRODUCT_SKU_WEB_SERVER,
    PRODUCT_DESKTOP_SKUS            = PRODUCT_SKU_PERSONAL | PRODUCT_SKU_PROFESSIONAL | PRODUCT_SKU_DESKTOP_EMBEDDED,

    PRODUCT_ALL_SKUS                = 0xFFFF
} PRODUCT_SKU_TYPE;

#endif // _FAX_SUITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxuiconstants.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxUIConstants.h                                       //
//                                                                         //
//  DESCRIPTION   : Fax UI Constants.                                      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 28 1999 yossg   create                                         //  
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef _FXS_CONST_H_
#define _FXS_CONST_H_

#include <lmcons.h>

#define FXS_RETRIES_DEFAULT         2
#define FXS_RETRIES_LOWER           0   
#define FXS_RETRIES_UPPER          99    
#define FXS_RETRIES_LENGTH          2 //num of digits of FXS_RETRIES_UPPER

#define FXS_RETRYDELAY_DEFAULT     10
#define FXS_RETRYDELAY_LOWER        0   
#define FXS_RETRYDELAY_UPPER      999    
#define FXS_RETRYDELAY_LENGTH       3 //num of digits of FXS_RETRYDELAY_UPPER

// FXS_DIRTYDAYS_LOWER  
// is actually must have FXS_DIRTYDAYS_ZERO equls zero
// for UI implementation reasons
// Do not change FXS_DIRTYDAYS_LOWER current value!
#define FXS_DIRTYDAYS_ZERO          0   

#define FXS_DIRTYDAYS_DEFAULT      30
#define FXS_DIRTYDAYS_LOWER         1   
#define FXS_DIRTYDAYS_UPPER        99    
#define FXS_DIRTYDAYS_LENGTH        2 //num of digits of FXS_DIRTYDAYS_UPPER

#define FXS_QUOTA_HIGH_DEFAULT     50
#define FXS_QUOTA_HIGH_LOWER        1   
#define FXS_QUOTA_HIGH_UPPER      999    
#define FXS_QUOTA_LENGTH            3 //num of digits of FXS_RINGS_UPPER

#define FXS_QUOTA_LOW_DEFAULT      48
#define FXS_QUOTA_LOW_LOWER         0   
#define FXS_QUOTA_LOW_UPPER       998    

#define FXS_RINGS_DEFAULT           3 
#define FXS_RINGS_LOWER             0   
#define FXS_RINGS_UPPER            99    
#define FXS_RINGS_LENGTH            2 //num of digits of FXS_RINGS_UPPER

#define FXS_DWORD_LEN              10
//Do not change 
#define FXS_MAX_RINGS_LEN          FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_NUM_OF_DEVICES_LEN FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_CODE_LEN           FXS_DWORD_LEN   //to be safe           

#define FXS_MAX_AREACODE_LEN       FXS_DWORD_LEN
#define FXS_MAX_COUNTRYCODE_LEN    FXS_DWORD_LEN

#define FXS_MAX_COUNTRYNAME_LEN   256
#define FXS_MAX_LOG_REPORT_LEVEL    4

//for Node's Display Name
#define FXS_MAX_DISPLAY_NAME_LEN      MAX_FAX_STRING_LEN
//Used in browse dialog, page error msg etc.
#define FXS_MAX_TITLE_LEN             128

#define FXS_MAX_MESSAGE_LEN          1024

#define FXS_MAX_ERROR_MSG_LEN         512
#define FXS_MAX_GENERAL_BUF_LEN       200

#define FXS_THIN_COLUMN_WIDTH          30
#define FXS_NORMAL_COLUMN_WIDTH       120
#define FXS_WIDE_COLUMN_WIDTH         180
#define FXS_LARGE_COLUMN_WIDTH        200

#define FXS_IDS_STATUS_ERROR          999
#define FXS_FIRST_DEVICE_ORDER          1
#define FXS_FIRST_METHOD_PRIORITY       1

#define NUL                             0
#define EQUAL_STRING                    0

#define FXS_ITEMS_NEVER_COUNTED        -1

//constants from lmcons.h (without the final null)
#define FXS_MAX_PASSWORD_LENGTH     PWLEN  //256
#define FXS_MAX_USERNAME_LENGTH     UNLEN  //256
#define FXS_MAX_DOMAIN_LENGTH       DNLEN  //15
//#define FXS_MAX_SERVERNAME_LENGTH   CNLEN  //15  == MAX_COMPUTERNAME_LENGTH

#define FXS_MAX_EMAIL_ADDRESS         128  

#define FXS_MAX_PORT_NUM           0xffff  //MAX_LONG
#define FXS_MIN_PORT_NUM                0
#define FXS_MAX_PORT_NUM_LEN            5

#define FXS_TSID_CSID_MAX_LENGTH       20

#define FXS_GLOBAL_METHOD_DEVICE_ID     0

//temp
#define FXS_ADMIN_HLP_FILE              L"FxsAdmin.hlp"

#define MAX_USERINFO_FULLNAME            128
#define MAX_USERINFO_FAX_NUMBER          64
#define MAX_USERINFO_COMPANY             128
#define MAX_USERINFO_ADDRESS             256
#define MAX_USERINFO_TITLE               64
#define MAX_USERINFO_DEPT                64
#define MAX_USERINFO_OFFICE              64
#define MAX_USERINFO_HOME_PHONE          64
#define MAX_USERINFO_WORK_PHONE          64
#define MAX_USERINFO_BILLING_CODE        64
#define MAX_USERINFO_MAILBOX             64
#define MAX_USERINFO_STREET              256
#define MAX_USERINFO_CITY                256
#define MAX_USERINFO_STATE               64
#define MAX_USERINFO_ZIP_CODE            64
#define MAX_USERINFO_COUNTRY             256

#define MAX_FAX_STRING_LEN               MAX_PATH - 2

//
// FSPI versions
//
typedef enum
{
    FSPI_API_VERSION_1 = 0x00010000    // Used by FSPs    
} FSPI_API_VERSIONS;    // Used in FaxRegisterServiceProviderEx

#endif // _FXS_CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\hlpres.h ===
// Help ID include file.
// Used by ClientConsole.rc
//

#ifndef _FAX_CLIENT_UI_HELP_IDS_H_
#define _FAX_CLIENT_UI_HELP_IDS_H_

//
// Common
//
#define HIDOK                           1000000001  
#define HIDCANCEL                       1000000002   
#define HIDC_CLOSE                      1000000008

//
// IDD_COLUMN_SELECT
//
#define HIDC_BUT_DOWN                   1000000011  
#define HIDC_BUT_ADD                    1000000012  
#define HIDC_BUT_REMOVE                 1000000013  
#define HIDC_BUT_UP                     1000000014  
#define HIDC_LIST_AVAILABLE             1000000015  
#define HIDC_LIST_DISPLAYED             1000000016  

//
// IDD_OPTIONS_USER_INFO
//
#define HIDC_ADDRESS_TITLE              1000000031  
#define HIDC_BILLING_CODE_TITLE         1000000032  
#define HIDC_BUSINESS_PHONE_TITLE       1000000033  
#define HIDC_COMPANY_TITLE              1000000034  
#define HIDC_DEPARTMENT_TITLE           1000000035  
#define HIDC_EMAIL_TITLE                1000000036  
#define HIDC_FAX_NUMBER_TITLE           1000000037  
#define HIDC_HOME_PHONE_TITLE           1000000038  
#define HIDC_NAME_TITLE                 1000000039  
#define HIDC_OFFICE_TITLE               1000000040  
#define HIDC_TITLE_TITLE                1000000041  
#define HIDC_USER_INFO_JUST_THIS_TIME   1000000043   

//
// IDD_INBOX_GENERAL
//
#define HIDC_DURATION_TITLE             1000000051  
#define HIDC_END_TIME_TITLE             1000000052  
#define HIDC_INBOX_PAGES_VALUE          1000000053  
#define HIDC_SIZE_TITLE                 1000000054  
#define HIDC_START_TIME_TITLE           1000000055  
#define HIDC_INBOX_STATUS_VALUE         1000000056  

//
// IDD_INBOX_DETAILS
//
#define HIDC_CALLER_ID_TITLE            1000000061  
#define HIDC_CSID_TITLE                 1000000062  
#define HIDC_DEVICE_TITLE               1000000063  
#define HIDC_JOB_ID_TITLE               1000000064  
#define HIDC_ROUTING_INFO_TITLE         1000000065  
#define HIDC_TSID_TITLE                 1000000066
#define HIDC_SERVER_TITLE				1000000067  

//
// IDD_OUTBOX_GENERAL
//
#define HIDC_DOC_NAME_TITLE             1000000071  
#define HIDC_RECIPIENT_NAME_TITLE       1000000072  
#define HIDC_RECIPIENT_NUMBER_TITLE     1000000073  
#define HIDC_SUBJECT_TITLE              1000000074  
#define HIDC_TRANSMISSION_TIME_TITLE    1000000075  
#define HIDC_OUTBOX_STATUS_VALUE        1000000076   
#define HIDC_OUTBOX_PAGES_VALUE         1000000077   
#define HIDC_OUTBOX_CURRENT_PAGE_VALUE  1000000078   
#define HIDC_OUTBOX_EXTENDED_STATUS     1000000079   

//
// IDD_OUTBOX_DETAILS
//
#define HIDC_PRIORITY_TITLE             1000000081  
#define HIDC_SCHEDULED_TIME_TITLE       1000000082  
#define HIDC_SUBMISSION_TIME_TITLE      1000000083  
#define HIDC_USER_TITLE                 1000000084  
#define HIDC_BROADCAST_ID_TITLE         1000000085 

//
// IDD_INCOMING_GENERAL
//
#define HIDC_INCOMING_CURRENT_PAGE_VALUE 1000000091  
#define HIDC_INCOMING_EXTENDED_STATUS    1000000092  
#define HIDC_INCOMING_STATUS_VALUE       1000000093  
#define HIDC_INCOMING_PAGES_VALUE        1000000094  

//
// IDD_INCOMING_DETAILS
//
#define HIDC_RETRIES_TITLE              1000000101
#define HIDC_RCV_DEVICE_TITLE           1000000102
#define HIDC_ROUTE_TIME_TITLE           1000000103
#define HIDC_ROUTE_RETRIES_TITLE        1000000104

//
// IDD_SENT_ITEMS_GENERAL
//
#define HIDC_SENDER_NAME_TITLE          1000000111  
#define HIDC_SENDER_NUMBER_TITLE        1000000112  
#define HIDC_SENT_ITEMS_PAGES_VALUE     1000000113   

//
// IDD_COVER_PAGES
//
#define HIDC_LIST_CP                    1000000121
#define HIDC_CP_OPEN                    1000000122
#define HIDC_CP_NEW                     1000000123
#define HIDC_CP_RENAME                  1000000124
#define HIDC_CP_DELETE                  1000000125
#define HIDC_CP_ADD                     1000000126

//
// IDD_SERVER_STATUS
//
#define HIDC_LIST_SERVER                1000000131

//
// Outlook extention
//
#define HIDC_MAPI_PRINTER_LIST          1000000141 
#define HIDC_MAPI_INCLUDE_COVER_PAGES   1000000142 
#define HIDC_MAPI_COVERPAGE_LIST        1000000143 
#define HIDC_MAPI_SEND_SINGLE_RECEIPT   1000000144 
#define HIDC_MAPI_FONT_NAME             1000000145 
#define HIDC_MAPI_FONT_STYLE            1000000146 
#define HIDC_MAPI_FONT_SIZE             1000000147 
#define HIDC_MAPI_BUT_SET_FONT          1000000148 
#define HIDC_MAPI_ATTACH_FAX            1000000149 
#define HIDC_MAPI_IENABLE_SINGLECP      1000000150 // Should read for a specific fax
#define HIDC_MAPI_SINGLE_ATTACH_FAX     1000000151 
#define HIDC_MAPI_SINGLE_CP_LIST        1000000152 // For a specific fax


//
// IDD_PRINTER_SELECT
//
#define HIDC_PRINTER_SELECTOR           1000000161

//
// IDD_PERSONAL_INFO - Sender Information Page
//  
#define HIDC_READ_NAME_VALUE            1000000172
#define HIDC_READ_FAX_NUMBER_VALUE      1000000173
#define HIDC_READ_EMAIL_VALUE           1000000174
#define HIDC_READ_TITLE_VALUE           1000000175
#define HIDC_READ_COMPANY_VALUE         1000000176
#define HIDC_READ_DEPARTMENT_VALUE      1000000177
#define HIDC_READ_OFFICE_VALUE          1000000178
#define HIDC_READ_BUSINESS_PHONE_VALUE  1000000179
#define HIDC_READ_HOME_PHONE_VALUE      1000000180
#define HIDC_READ_ADDRESS_VALUE         1000000181
#define HIDC_READ_BILLING_CODE_VALUE    1000000182

//
// IDD_DOCPROP - Fax Preferences
//
#define HIDC_FP_PAPER                   1000000191
#define HIDC_FP_IMAGE                   1000000192
#define HIDC_FP_ORIENT                  1000000193
#define HIDC_FP_PORTRAIT                1000000194
#define HIDC_FP_LANDSCAPE               1000000195

//
// IDD_DEVICE_INFO - Devices
//
#define HIDC_PFDevice_Details           1000000201
#define HIDC_PFDevice_TSID              1000000202
#define HIDC_PFDevice_CSID              1000000203
#define HIDC_PFDevice_Rings             1000000204
#define HIDC_PFDevice_Prop              1000000205

//
// IDD_RECEIVE_PROP - Receive
//
#define HIDC_PFRecv_Enable              1000000211 // Enable receive checkbox
#define HIDC_PFRecv_CSID                1000000212 // CSID text box
#define HIDC_PFRecv_Manual              1000000213 // Manual option button: 
#define HIDC_PFRecv_Auto                1000000214 // Auto option button: 
#define HIDC_PFRecv_NumRings            1000000215 // Rings spin box 
#define HIDC_PFRecv_Print               1000000216 // Enable to Print 
#define HIDC_PFRecv_Save                1000000217 // Enable to Save 
#define HIDC_PFRecv_PrintLoc            1000000218 // Print location 
#define HICD_PFRecv_SaveLoc             1000000219 // Folder location 
#define HICD_PFRecv_Browse              1000000220 // Browse button

//
// IDD_SEND_PROP - Send
//
#define HIDC_PFSend_Enable              1000000231 // Enable send checkbox 
#define HIDC_PFSend_TSID                1000000232 // TSID text box
#define HIDC_PFSend_NumRetry            1000000233 // Number of retries
#define HIDC_PFSend_RetryAfter          1000000234 // Retry after
#define HIDC_PFSend_DiscStart           1000000235 // Discount rate start 
#define HIDC_PFSend_DiscEnd             1000000236 // Discount rate end 
#define HIDC_PFSend_Banner              1000000237 // Enable banner 
#define HIDC_PFSend_Days_chk            1000000238 // "Automatically delete failed incoming and outgoing faxes after..." checkbox
#define HIDC_PFSend_Days_edt            1000000239 // "Automatically delete failed incoming and outgoing faxes after..." days edit box
#define HIDC_PFSend_Days_days           1000000240 // "Automatically delete failed incoming and outgoing faxes after..." days static text

//
// IDD_ARCHIVE_FOLDER - Archives
//
#define HIDC_PFArch_Recv                1000000241 // Enable incoming archive 
#define HIDC_PFArch_Sent                1000000242 // Enable outgoing archive 
#define HIDC_PFArch_RecvLoc             1000000243 // Text box incoming location 
#define HIDC_PFArch_SentLoc             1000000244 // Text box sent items location 
#define HIDC_PFArch_Browse              1000000245 // Browse button 

//
// IDD_SOUNDS - Sound Settings
//
#define HIDC_PFTrack_Sounds			    1000000251

//
// IDD_STATUS_OPTIONS - Tracking
//
#define HIDC_PFTrack_Device             1000000261 // Select fax device label and dropdown 
#define HIDC_PFTrack_Progress           1000000262 // Checkbox show progress 
#define HIDC_PFTrack_In                 1000000263 // Checkbox success in 
#define HIDC_PFTrack_Out                1000000264 // Checkbox success out 
#define HIDC_PRTrack_MonOut             1000000265 // Checkbox open FM for outgoing
#define HIDC_PRTrack_MonIn              1000000266 // Checkbox open FM for incoming 
#define HIDC_PRTrack_ConfSound          1000000267 // Button sound 

//
// IDD_MONITOR - Fax Monitor
//
#define HIDC_FaxMon_Status              1000000271 // Status label 
#define HIDC_FaxMon_Elapsed             1000000272 // Elapsed time label 
#define HIDC_FaxMon_OnTop               1000000273 // Enable keep on top 
#define HIDC_FaxMon_Hide                1000000274 // Hide button 
#define HIDC_FaxMon_Disconnect          1000000275 // Disconnect button 
#define HIDC_FaxMon_More_Less           1000000276 // More/Less button
#define HIDC_FaxMon_MoreInfo            1000000277 // Time/Status list
#define HIDC_FaxMon_ClearList           1000000278 // Clear list button

//
// IDD_SELECT_FAXPRINTER - Select Fax Printer
//
#define HIDC_SelectFP                   1000000281 // Fax Printer List 

//
// IDD_OBJ_PROP - Line, Fill and Color
//
#define HIDC_CPE_DrawBorder             1000000291 // Draw border/line
#define HIDC_CPE_Thickness              1000000292 // Thickness
#define HIDC_CPE_LineColor              1000000293 // Line color
#define HIDC_CPE_FillTrans              1000000294 // Fill color transparent
#define HIDC_CPE_FillColor              1000000295 // Fill color
#define HIDC_CPE_TextColor              1000000296 // Text color

#endif // _FAX_CLIENT_UI_HELP_IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxwiz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxwiz.h

Abstract:

    This file defines the fax setup wizard api.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;

//
// install modes
//

#define INSTALL_NEW                 0x00000001
#define INSTALL_UPGRADE             0x00000002
#define INSTALL_DRIVERS             0x00000004
#define INSTALL_REMOVE              0x00000008
#define INSTALL_UNATTENDED          0x00000010


BOOL WINAPI
FaxWizInit(
    VOID
    );

DWORD
WINAPI
FaxWizGetError(
    VOID
    );

VOID
WINAPI
FaxWizSetInstallMode(
    DWORD RequestedInstallMode,
    DWORD RequestedInstallType,
    LPWSTR AnswerFile
    );

BOOL WINAPI
FaxWizPointPrint(
    LPTSTR DirectoryName,
    LPTSTR PrinterName
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetServerPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetWorkstationPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetClientPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetPointPrintPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizRemoteAdminPages(
    LPDWORD PageCount
    );

PFNPROPSHEETCALLBACK WINAPI
FaxWizGetPropertySheetCallback(
    VOID
    );

//
// Function pointer types used when the client doesn't
// statically link to faxwiz.dll.
//

typedef BOOL (WINAPI *LPFAXWIZINIT)(VOID);
typedef DWORD (WINAPI *LPFAXWIZGETERROR)(VOID);
typedef BOOL (WINAPI*LPFAXWIZPOINTPRINT)(LPTSTR, LPTSTR);
typedef LPHPROPSHEETPAGE (WINAPI *LPFAXWIZGETPOINTPRINTPAGES)(LPDWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\makefile.inc ===
all: FAXINC
clean: cleansrc

FAXINC: WINFAX.H FXSAPIP.H

WINFAX.X FXSAPIP.X: WINFAX.W
	hsplit -o WINFAX.X FXSAPIP.X WINFAX.W
WINFAX.H: WINFAX.X
	wcshdr < WINFAX.X > WINFAX.H

FXSAPIP.H: FXSAPIP.X
	wcshdr < FXSAPIP.X > FXSAPIP.H


cleansrc:
	-del winfax.h
	-del fxsapip.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\jobtag.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jobtag.h

Abstract:

    Tags used in JOB_INFO_2.pParameters field for passing information
    about fax jobs through the print system to the fax service.

Environment:

        Windows XP fax driver

Revision History:

        06/03/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _JOBTAG_H_
#define _JOBTAG_H_

//
// Tags used to pass in fax job parameters - JOB_INFO_2.pParameters
//
//  JOB_INFO_2.pParameters field contains a tagged string of the form
//      <tag>value<tag>value
//
//  The format of tags is defined as:
//      <$FAXTAG$ tag-name>
//
//  There is exactly one space between the tag keyword and the tag name.
//  Characters in a tag are case-sensitive.
//
//  Currently only two tag names are defined:
//      REC#    recipient's phone number
//      RECNAME recipient's name
//      TSID    sending station identifier
//      SDRNAME sender's name
//      SDRCO   sender's company
//      SDRDEPT sender's department
//      BILL    billing code
//
//  If no recipient number tag is present, the entire string is used
//  as the recipient's fax number.
//

//
// Number fo job parameter tags in the parameter strings.
// UPDATE THIS FIELD when adding fields.
//
#define FAXTAG_PREFIX					TEXT("<$FAXTAG$ ")
#define FAXTAG_NEW_RECORD				TEXT("<$FAXTAG$ NEWREC>")
#define FAXTAG_NEW_RECORD_VALUE			TEXT("1")



//
//Job parameters (11 tags)
//
#define FAXTAG_TSID             TEXT("<$FAXTAG$ TSID>")
#define FAXTAG_BILLING_CODE     TEXT("<$FAXTAG$ BILL>")
#define FAXTAG_SEND_RETRY       TEXT("<$FAXTAG$ SENDRETRY>")
#define FAXTAG_ROUTE_FILE       TEXT("<$FAXTAG$ ROUTEFILE>")
#define FAXTAG_PROFILE_NAME     TEXT("<$FAXTAG$ PROFILENAME>")
#define FAXTAG_RECEIPT_TYPE     TEXT("<$FAXTAG$ RECEIPT_TYPE>")
#define FAXTAG_RECEIPT_ADDR     TEXT("<$FAXTAG$ RECEIPT_ADDR>")
#define FAXTAG_PRIORITY         TEXT("<$FAXTAG$ PRIORITY>")
#define FAXTAG_WHEN_TO_SEND     TEXT("<$FAXTAG$ WHENTOSEND>")  // string == "cheap" | "at"
#define FAXTAG_SEND_AT_TIME     TEXT("<$FAXTAG$ SENDATTIME>")  // string == "hh:mm"
#define FAXTAG_COVERPAGE_NAME   TEXT("<$FAXTAG$ COVERPAGE>")
#define FAXTAG_SERVER_COVERPAGE TEXT("<$FAXTAG$ SRV_COVERPAGE>")
#define FAXTAG_PAGE_COUNT		TEXT("<$FAXTAG$ PAGECOUNT>")
#define FAXTAG_RECIPIENT_COUNT  TEXT("<$FAXTAG$ RECPCOUNT>")
//
//Recipient information (13 tags)
//
#define FAXTAG_RECIPIENT_NAME				TEXT("<$FAXTAG$ REC_NAME>")
#define FAXTAG_RECIPIENT_NUMBER				TEXT("<$FAXTAG$ REC_NUM>")
#define FAXTAG_RECIPIENT_COMPANY			TEXT("<$FAXTAG$ REC_COMPANY>")
#define FAXTAG_RECIPIENT_STREET				TEXT("<$FAXTAG$ REC_STREET>")
#define FAXTAG_RECIPIENT_CITY				TEXT("<$FAXTAG$ REC_CITY>")
#define FAXTAG_RECIPIENT_STATE				TEXT("<$FAXTAG$ REC_STATE>")
#define FAXTAG_RECIPIENT_ZIP				TEXT("<$FAXTAG$ REC_ZIP>")
#define FAXTAG_RECIPIENT_COUNTRY			TEXT("<$FAXTAG$ REC_COUNTRY>")
#define FAXTAG_RECIPIENT_TITLE				TEXT("<$FAXTAG$ REC_TITLE>")
#define FAXTAG_RECIPIENT_DEPT				TEXT("<$FAXTAG$ REC_DEPT>")
#define FAXTAG_RECIPIENT_OFFICE_LOCATION	TEXT("<$FAXTAG$ REC_OFFICE_LOC>")
#define FAXTAG_RECIPIENT_HOME_PHONE			TEXT("<$FAXTAG$ REC_HOME_PHONE>")
#define FAXTAG_RECIPIENT_OFFICE_PHONE		TEXT("<$FAXTAG$ REC_OFFICE_PHONE>")
//
//Sender information (9 tags)
//
#define FAXTAG_SENDER_NAME					TEXT("<$FAXTAG$ SDR_NAME>")
#define FAXTAG_SENDER_NUMBER				TEXT("<$FAXTAG$ SDR_NUM>")
#define FAXTAG_SENDER_COMPANY				TEXT("<$FAXTAG$ SDR_COMPANY>")
#define FAXTAG_SENDER_TITLE					TEXT("<$FAXTAG$ SDR_TITLE>")
#define FAXTAG_SENDER_DEPT					TEXT("<$FAXTAG$ SDR_DEPT>")
#define FAXTAG_SENDER_OFFICE_LOCATION		TEXT("<$FAXTAG$ SDR_OFFICE_LOC>")
#define FAXTAG_SENDER_HOME_PHONE			TEXT("<$FAXTAG$ SDR_HOME_PHONE>")
#define FAXTAG_SENDER_OFFICE_PHONE			TEXT("<$FAXTAG$ SDR_OFFICE_PHONE>")
#define FAXTAG_SENDER_STREET				TEXT("<$FAXTAG$ SDR_STREET>")
#define FAXTAG_SENDER_CITY					TEXT("<$FAXTAG$ SDR_CITY>")
#define FAXTAG_SENDER_STATE					TEXT("<$FAXTAG$ SDR_STATE>")
#define FAXTAG_SENDER_ZIP					TEXT("<$FAXTAG$ SDR_ZIP>")
#define FAXTAG_SENDER_COUNTRY				TEXT("<$FAXTAG$ SDR_COUNTRY>")
#define FAXTAG_SENDER_EMAIL				    TEXT("<$FAXTAG$ SDR_EMAIL>")

//
// Coverpage information (2 tags)
//
#define FAXTAG_NOTE			TEXT("<$FAXTAG$ NOTE>")
#define FAXTAG_SUBJECT		TEXT("<$FAXTAG$ SUBJECT>")

#endif  // !_JOBTAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\faxutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    faxutil.h

Abstract:

    This file defines the debugging interfaces
    available to the FAX compoments.

Author:

    Wesley Witt (wesw) 22-Dec-1995

Environment:

    User Mode

--*/


#ifndef _FAXUTIL_
#define _FAXUTIL_
#include <windows.h>
#include <crtdbg.h>
#include <malloc.h>
#include <WinSpool.h>
#include <rpc.h>
#ifndef _FAXAPI_
    //
    // WinFax.h is not already included
    //
    #include <fxsapip.h>
#else
    //
    // WinFax.h is already included
    // This happens by the W2K COM only.
    //
    
typedef LPVOID *PFAX_VERSION;
    
#endif // !defined _FAXAPI_

#include <FaxDebug.h>
#ifdef __cplusplus
extern "C" {
#endif

#define ARR_SIZE(x) (sizeof(x)/sizeof((x)[0]))

//
// Nul terminator for a character string
//

#define NUL             0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)


#define OffsetToString( Offset, Buffer ) ((Offset) ? (LPTSTR) ((Buffer) + ((ULONG_PTR) Offset)) : NULL)
#define StringSize(_s)              (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)
#define StringSizeW(_s)              (( _s ) ? (wcslen( _s ) + 1) * sizeof(WCHAR) : 0)
#define MultiStringSize(_s)         ( ( _s ) ?  MultiStringLength((_s)) * sizeof(TCHAR) : 0 )
#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null

#define FAXBITS     1728
#define FAXBYTES    (FAXBITS/BYTEBITS)

#define MAXHORZBITS FAXBITS
#define MAXVERTBITS 3000        // 14inches plus

#define MINUTES_PER_HOUR    60
#define MINUTES_PER_DAY     (24 * 60)

#define SECONDS_PER_MINUTE  60
#define SECONDS_PER_HOUR    (SECONDS_PER_MINUTE * MINUTES_PER_HOUR)
#define SECONDS_PER_DAY     (MINUTES_PER_DAY * SECONDS_PER_MINUTE)

#define FILETIMETICKS_PER_SECOND    10000000    // 100 nanoseconds / second
#define FILETIMETICKS_PER_DAY       ((LONGLONG) FILETIMETICKS_PER_SECOND * (LONGLONG) SECONDS_PER_DAY)
#define MILLISECONDS_PER_SECOND     1000

#ifndef MAKELONGLONG
#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))
#endif

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

#define DWord2FaxTime(pFaxTime, dwValue) (pFaxTime)->hour = LOWORD(dwValue), (pFaxTime)->minute = HIWORD(dwValue)
#define FaxTime2DWord(pFaxTime) MAKELONG((pFaxTime)->hour, (pFaxTime)->minute)

#define EMPTY_STRING    TEXT("")

typedef GUID *PGUID;

typedef enum {
    DEBUG_VER_MSG   =0x00000001,
    DEBUG_WRN_MSG   =0x00000002,
    DEBUG_ERR_MSG   =0x00000004,
    DEBUG_FAX_TAPI_MSG   =0x00000008
    } DEBUG_MESSAGE_TYPE;
#define DEBUG_ALL_MSG    DEBUG_VER_MSG | DEBUG_WRN_MSG | DEBUG_ERR_MSG | DEBUG_FAX_TAPI_MSG


//
// Tags used to pass information about fax jobs
//
typedef struct {
    LPTSTR lptstrTagName;
    LPTSTR lptstrValue;
} FAX_TAG_MAP_ENTRY;


void
ParamTagsToString(
     FAX_TAG_MAP_ENTRY * lpTagMap,
     DWORD dwTagCount,
     LPTSTR lpTargetBuf,
     LPDWORD dwSize);


//
// debugging information
//

#ifndef FAXUTIL_DEBUG

#ifdef ENABLE_FRE_LOGGING
#define ENABLE_LOGGING
#endif  // ENABLE_FRE_LOGGING

#ifdef DEBUG
#define ENABLE_LOGGING
#endif  // DEBUG

#ifdef DBG
#define ENABLE_LOGGING
#endif  // DBG

#ifdef ENABLE_LOGGING

#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     fax_dprintf _x_

#define DebugStop(_x_)      {\
                                fax_dprintf _x_;\
                                fax_dprintf(TEXT("Stopping at %s @ %d"),TEXT(__FILE__),__LINE__);\
                                __try {\
                                    DebugBreak();\
                                } __except (UnhandledExceptionFilter(GetExceptionInformation())) {\
                                }\
                            }
#define ASSERT_FALSE \
    {                                           \
        int bAssertCondition = TRUE;            \
        Assert(bAssertCondition == FALSE);      \
    }                                           \



#ifdef USE_DEBUG_CONTEXT

#define DEBUG_WRN USE_DEBUG_CONTEXT,DEBUG_WRN_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_ERR USE_DEBUG_CONTEXT,DEBUG_ERR_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_MSG USE_DEBUG_CONTEXT,DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_TAPI USE_DEBUG_CONTEXT,DEBUG_FAX_TAPI_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__


#else

#define DEBUG_WRN DEBUG_CONTEXT_ALL,DEBUG_WRN_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_ERR DEBUG_CONTEXT_ALL,DEBUG_ERR_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_MSG DEBUG_CONTEXT_ALL,DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_TAPI DEBUG_CONTEXT_ALL,DEBUG_FAX_TAPI_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__

#endif

#define DebugPrintEx dprintfex
#define DebugError
#define DebugPrintEx0(Format) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format);
#define DebugPrintEx1(Format,Param1) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1);
#define DebugPrintEx2(Format,Param1,Param2) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1,Param2);
#define DebugPrintEx3(Format,Param1,Param2,Param3) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1,Param2,Param3);

#define DEBUG_TRACE_ENTER DebugPrintEx(DEBUG_MSG,TEXT("Entering: %s"),faxDbgFunction);
#define DEBUG_TRACE_LEAVE DebugPrintEx(DEBUG_MSG,TEXT("Leaving: %s"),faxDbgFunction);


#define DEBUG_FUNCTION_NAME(_x_) LPCTSTR faxDbgFunction=_x_; \
                                 DEBUG_TRACE_ENTER;

#define OPEN_DEBUG_FILE(f)          debugOpenLogFile(f, -1)
#define OPEN_DEBUG_FILE_SIZE(f,s)   debugOpenLogFile(f, s)
#define CLOSE_DEBUG_FILE     debugCloseLogFile()

#define SET_DEBUG_PROPERTIES(level,format,context)  debugSetProperties(level,format,context)

#else   // ENABLE_LOGGING

#define ASSERT_FALSE
#define Assert(exp)
#define DebugPrint(_x_)
#define DebugStop(_x_)
#define DebugPrintEx 1 ? (void)0 : dprintfex
#define DebugPrintEx0(Format)
#define DebugPrintEx1(Format,Param1)
#define DebugPrintEx2(Format,Param1,Param2)
#define DebugPrintEx3(Format,Param1,Param2,Param3)
#define DEBUG_FUNCTION_NAME(_x_)
#define DEBUG_TRACE_ENTER
#define DEBUG_TRACE_LEAVE
#define DEBUG_WRN DEBUG_CONTEXT_ALL,DEBUG_WRN_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define DEBUG_ERR DEBUG_CONTEXT_ALL,DEBUG_ERR_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define DEBUG_MSG DEBUG_CONTEXT_ALL,DEBUG_VER_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define DEBUG_TAPI DEBUG_CONTEXT_ALL,DEBUG_FAX_TAPI_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define OPEN_DEBUG_FILE(f)
#define OPEN_DEBUG_FILE_SIZE(f,s)
#define CLOSE_DEBUG_FILE
#define SET_DEBUG_PROPERTIES(level,format,context)

#endif  // ENABLE_LOGGING

extern BOOL ConsoleDebugOutput;

void
dprintfex(
    DEBUG_MESSAGE_CONTEXT nMessageContext,
    DEBUG_MESSAGE_TYPE nMessageType,
    LPCTSTR lpctstrDbgFunction,
    LPCTSTR lpctstrFile,
    DWORD dwLine,
    LPCTSTR lpctstrFormat,
    ...
    );

void
fax_dprintf(
    LPCTSTR Format,
    ...
    );

VOID
AssertError(
    LPCTSTR Expression,
    LPCTSTR File,
    ULONG  LineNumber
    );

BOOL debugOpenLogFile(LPCTSTR lpctstrFilename, DWORD dwMaxSize);

void debugCloseLogFile();

void debugSetProperties(DWORD dwLevel,DWORD dwFormat,DWORD dwContext);

BOOL debugIsRegistrySession();
#endif

//
// list management
//

#ifndef NO_FAX_LIST

#define InitializeListHead(ListHead) {\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead);\
    Assert((ListHead)->Flink && (ListHead)->Blink);\
    }

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    Assert ( !((Entry)->Flink) && !((Entry)->Blink) );\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    Assert ( !((Entry)->Flink) && !((Entry)->Blink) );\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    Assert((Entry)->Blink  && (Entry)->Flink);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    (Entry)->Flink = NULL;\
    (Entry)->Blink = NULL;\
    }

#define RemoveHeadList(ListHead) \
    Assert((ListHead)->Flink);\
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#endif

//
// memory allocation
//

#ifndef FAXUTIL_MEM

#define HEAP_SIZE   (1024*1024)

#ifdef FAX_HEAP_DEBUG
#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    SIZE_T      Size;
    ULONG       Line;
#ifdef UNICODE
    WCHAR       File[MAX_PATH];
#else
    CHAR        File[MAX_PATH];
#endif
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)          pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(d,s)      pMemReAlloc(d,s,__LINE__,__FILE__)
#define MemFree(p)           pMemFree(p,__LINE__,__FILE__)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p,__LINE__,__FILE__)
#define CheckHeap(p)         pCheckHeap(p,__LINE__,__FILE__)
#else
#define MemAlloc(s)          pMemAlloc(s)
#define MemReAlloc(d,s)      pMemReAlloc(d,s)
#define MemFree(p)           pMemFree(p)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p)
#define CheckHeap(p)         (TRUE)
#endif

typedef LPVOID (WINAPI *PMEMALLOC)   (SIZE_T);
typedef LPVOID (WINAPI *PMEMREALLOC) (LPVOID,SIZE_T);
typedef VOID   (WINAPI *PMEMFREE)  (LPVOID);

int GetY2KCompliantDate (
    LCID                Locale,
    DWORD               dwFlags,
    CONST SYSTEMTIME   *lpDate,
    LPTSTR              lpDateStr,
    int                 cchDate
);

long
StatusNoMemoryExceptionFilter (DWORD dwExceptionCode);

HRESULT
SafeInitializeCriticalSection (LPCRITICAL_SECTION lpCriticalSection);

HANDLE
HeapInitialize(
    HANDLE hHeap,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    PMEMREALLOC pMemReAlloc    
    );

BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    );

BOOL
HeapCleanup(
    VOID
    );

#ifdef FAX_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );

VOID
PrintAllocations(
    VOID
    );

#else

#define PrintAllocations()

#endif

PVOID
pMemAlloc(
    SIZE_T AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID dest,
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

#endif

//
//  Server/Registry Activity logging structure
//

typedef struct _FAX_SERVER_ACTIVITY_LOGGING_CONFIG
{
    DWORD   dwSizeOfStruct;
    BOOL    bLogIncoming;
    BOOL    bLogOutgoing;
    LPTSTR  lptstrDBPath;
    DWORD   dwLogLimitCriteria;
    DWORD   dwLogSizeLimit;
    DWORD   dwLogAgeLimit;
    DWORD   dwLimitReachedAction;
} FAX_SERVER_ACTIVITY_LOGGING_CONFIG, *PFAX_SERVER_ACTIVITY_LOGGING_CONFIG;


//
// TAPI functions
//
BOOL
GetCallerIDFromCall(
    HCALL hCall,
    LPTSTR lptstrCallerID,
    DWORD dwCallerIDSize
    );

//
// file functions
//

#ifndef FAXUTIL_FILE

/*++

Routine name : SafeCreateFile

Routine description:

    This is a safe wrapper around the Win32 CreateFile API.
    It only supports creating real files (as opposed to COM ports, named pipes, etc.).
    
    It uses some widely-discussed mitigation techniques to guard agaist some well known security
    issues in CreateFile().
    
Author:

    Eran Yariv (EranY), Mar, 2002

Arguments:

    lpFileName              [in] - Refer to the CreateFile() documentation for parameter description.
    dwDesiredAccess         [in] - Refer to the CreateFile() documentation for parameter description.
    dwShareMode             [in] - Refer to the CreateFile() documentation for parameter description.
    lpSecurityAttributes    [in] - Refer to the CreateFile() documentation for parameter description.
    dwCreationDisposition   [in] - Refer to the CreateFile() documentation for parameter description.
    dwFlagsAndAttributes    [in] - Refer to the CreateFile() documentation for parameter description.
    hTemplateFile           [in] - Refer to the CreateFile() documentation for parameter description.
                                        
Return Value:

    If the function succeeds, the return value is an open handle to the specified file. 
    If the specified file exists before the function call and dwCreationDisposition is CREATE_ALWAYS or OPEN_ALWAYS, 
    a call to GetLastError returns ERROR_ALREADY_EXISTS (even though the function has succeeded). 
    If the file does not exist before the call, GetLastError returns zero. 

    If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError. 
    
    For more information see the "Return value" section in the CreateFile() documentation.
    
Remarks:

    Please refer to the CreateFile() documentation.    

--*/
HANDLE
__stdcall 
SafeCreateFile(
  LPCTSTR                   lpFileName,             // File name
  DWORD                     dwDesiredAccess,        // Access mode
  DWORD                     dwShareMode,            // Share mode
  LPSECURITY_ATTRIBUTES     lpSecurityAttributes,   // SD
  DWORD                     dwCreationDisposition,  // How to create
  DWORD                     dwFlagsAndAttributes,   // File attributes
  HANDLE                    hTemplateFile           // Handle to template file
);

/*++

Routine name : SafeCreateTempFile

Routine description:

    This is a safe wrapper around the Win32 CreateFile API.
    It only supports creating real files (as opposed to COM ports, named pipes, etc.).
    
    It uses some widely-discussed mitigation techniques to guard agaist some well known security
    issues in CreateFile().
    
    Use this function to create and open temporary files.
    The file will be created / opened using the FILE_FLAG_DELETE_ON_CLOSE flag.
    When the last file handle is closed, the file will be automatically deleted.
    
    In addition, the file is marked for deletion after reboot (Unicode-version only).
    This will only work if the calling thread's user is a member of the local admins group.
    If marking for deletion-post-reboot fails, the InternalSafeCreateFile function call still succeeds.
    
    NOTICE: This function cannot be used to create temporary files which should be used by other applications. 
            For example, it should not be used to create temporary preview files. 
            This is because other applications will not specify FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE 
            in the file share mode and will fail to open the temporary file.
        
Author:

    Eran Yariv (EranY), Mar, 2002

Arguments:

    lpFileName              [in] - Refer to the CreateFile() documentation for parameter description.
    dwDesiredAccess         [in] - Refer to the CreateFile() documentation for parameter description.
    dwShareMode             [in] - Refer to the CreateFile() documentation for parameter description.
    lpSecurityAttributes    [in] - Refer to the CreateFile() documentation for parameter description.
    dwCreationDisposition   [in] - Refer to the CreateFile() documentation for parameter description.
    dwFlagsAndAttributes    [in] - Refer to the CreateFile() documentation for parameter description.
    hTemplateFile           [in] - Refer to the CreateFile() documentation for parameter description.
                                        
Return Value:

    If the function succeeds, the return value is an open handle to the specified file. 
    If the specified file exists before the function call and dwCreationDisposition is CREATE_ALWAYS or OPEN_ALWAYS, 
    a call to GetLastError returns ERROR_ALREADY_EXISTS (even though the function has succeeded). 
    If the file does not exist before the call, GetLastError returns zero. 

    If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError. 
    
    For more information see the "Return value" section in the CreateFile() documentation.
    
Remarks:

    Please refer to the CreateFile() documentation.    

--*/
HANDLE
__stdcall 
SafeCreateTempFile(
  LPCTSTR                   lpFileName,             // File name
  DWORD                     dwDesiredAccess,        // Access mode
  DWORD                     dwShareMode,            // Share mode
  LPSECURITY_ATTRIBUTES     lpSecurityAttributes,   // SD
  DWORD                     dwCreationDisposition,  // How to create
  DWORD                     dwFlagsAndAttributes,   // File attributes
  HANDLE                    hTemplateFile           // Handle to template file
);

typedef struct _FILE_MAPPING {
    HANDLE  hFile;
    HANDLE  hMap;
    LPBYTE  fPtr;
    DWORD   fSize;
} FILE_MAPPING, *PFILE_MAPPING;

BOOL
MapFileOpen(
    LPCTSTR FileName,
    BOOL ReadOnly,
    DWORD ExtendBytes,
    PFILE_MAPPING FileMapping
    );

VOID
MapFileClose(
    PFILE_MAPPING FileMapping,
    DWORD TrimOffset
    );

DWORDLONG
GenerateUniqueFileName(
    LPTSTR Directory,
    LPTSTR Extension,
    OUT LPTSTR FileName,
    DWORD  FileNameSize
    );

DWORDLONG
GenerateUniqueFileNameWithPrefix(
    BOOL   bUseProcessId,
    LPTSTR lptstrDirectory,
    LPTSTR lptstrPrefix,
    LPTSTR lptstrExtension,
    LPTSTR lptstrFileName,
    DWORD  dwFileNameSize
    );

VOID
DeleteTempPreviewFiles (
    LPTSTR lptstrDirectory,
    BOOL   bConsole
);

DWORD
GetFileVersion (
    LPCTSTR      lpctstrFileName,
    PFAX_VERSION pVersion
);

DWORD 
GetVersionIE(
	BOOL* fInstalled, 
	INT* iMajorVersion, 
	INT* iMinorVersion
);

DWORD 
ViewFile (
    LPCTSTR lpctstrTiffFile
);

DWORD
IsValidFaxFolder(
    LPCTSTR szFolder
);

BOOL
ValidateCoverpage(
    IN  LPCTSTR  CoverPageName,
    IN  LPCTSTR  ServerName,
    IN  BOOL     ServerCoverpage,
    OUT LPTSTR   ResolvedName,
    IN  DWORD    dwResolvedNameSize
    );

HINSTANCE 
WINAPI 
LoadLibraryFromLocalFolder(
	IN LPCTSTR lpctstrModuleName,
	IN HINSTANCE hModule
	);

#endif  // FAXUTIL_FILE

//
// string functions
//

LPTSTR
AllocateAndLoadString(
                      HINSTANCE     hInstance,
                      UINT          uID
                      );

#ifndef FAXUTIL_STRING                                              
            

typedef struct _STRING_PAIR {
        LPTSTR lptstrSrc;
        LPTSTR * lpptstrDst;
} STRING_PAIR, * PSTRING_PAIR;

int MultiStringDup(PSTRING_PAIR lpPairs, int nPairCount);

VOID
StoreString(
    LPCTSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset,
	DWORD dwBufferSize
    );

VOID
StoreStringW(
    LPCWSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset,
	DWORD dwBufferSize
    );

DWORD
IsValidGUID (
    LPCWSTR lpcwstrGUID
);

LPCTSTR
GetCurrentUserName ();

LPCTSTR
GetRegisteredOrganization ();

BOOL
IsValidSubscriberIdA (
    LPCSTR lpcstrSubscriberId
);

BOOL
IsValidSubscriberIdW (
    LPCWSTR lpcwstrSubscriberId
);

#ifdef UNICODE
    #define IsValidSubscriberId IsValidSubscriberIdW
#else
    #define IsValidSubscriberId IsValidSubscriberIdA
#endif

BOOL
IsValidFaxAddress (
    LPCTSTR lpctstrFaxAddress,
    BOOL    bAllowCanonicalFormat
);

LPTSTR
StringDup(
    LPCTSTR String
    );

LPWSTR
StringDupW(
    LPCWSTR String
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

VOID
FreeString(
    LPVOID String
    );

BOOL
MakeDirectory(
    LPCTSTR Dir
    );

VOID
DeleteDirectory(
    LPTSTR Dir
    );

VOID
HideDirectory(
    LPTSTR Dir
    );

#ifdef UNICODE
DWORD
CheckToSeeIfSameDir(
    LPWSTR lpwstrDir1,
    LPWSTR lpwstrDir2,
    BOOL*  pIsSameDir
    );
    
#endif

VOID
ConsoleDebugPrint(
    LPCTSTR buf
    );

int
FormatElapsedTimeStr(
    FILETIME *ElapsedTime,
    LPTSTR TimeStr,
    DWORD StringSize
    );

LPTSTR
ExpandEnvironmentString(
    LPCTSTR EnvString
    );

LPTSTR
GetEnvVariable(
    LPCTSTR EnvString
    );


DWORD
IsCanonicalAddress(
    LPCTSTR lpctstrAddress,
    BOOL* lpbRslt,
    LPDWORD lpdwCountryCode,
    LPDWORD lpdwAreaCode,
    LPCTSTR* lppctstrSubNumber
    );

BOOL
IsLocalMachineNameA (
    LPCSTR lpcstrMachineName
    );

BOOL
IsLocalMachineNameW (
    LPCWSTR lpcwstrMachineName
    );

void
GetSecondsFreeTimeFormat(
    LPTSTR tszTimeFormat,
    ULONG  cchTimeFormat
);

size_t
MultiStringLength(
    LPCTSTR psz
    );




#ifdef UNICODE
    #define IsLocalMachineName IsLocalMachineNameW
#else
    #define IsLocalMachineName IsLocalMachineNameA
#endif

#endif

//
// product suite functions
//

#ifndef FAXUTIL_SUITE

#include "FaxSuite.h"

BOOL
IsWinXPOS();

PRODUCT_SKU_TYPE GetProductSKU();
DWORD GetProductBuild();
LPCTSTR StringFromSKU(PRODUCT_SKU_TYPE pst);
BOOL IsDesktopSKU();
BOOL IsDesktopSKUFromSKU(PRODUCT_SKU_TYPE);
BOOL IsFaxShared();
DWORD IsFaxInstalled (
    LPBOOL lpbInstalled
    );

DWORD
GetDeviceLimit();

typedef enum
{
    FAX_COMPONENT_SERVICE           = 0x0001, // FXSSVC.exe   - Fax service
    FAX_COMPONENT_CONSOLE           = 0x0002, // FXSCLNT.exe  - Fax console
    FAX_COMPONENT_ADMIN             = 0x0004, // FXSADMIN.dll - Fax admin console
    FAX_COMPONENT_SEND_WZRD         = 0x0008, // FXSSEND.exe  - Send wizard invocation
    FAX_COMPONENT_CONFIG_WZRD       = 0x0010, // FXSCFGWZ.dll - Configuration wizard
    FAX_COMPONENT_CPE               = 0x0020, // FXSCOVER.exe - Cover page editor
    FAX_COMPONENT_HELP_CLIENT_HLP   = 0x0040, // fxsclnt.hlp  - Client help
    FAX_COMPONENT_HELP_CLIENT_CHM   = 0x0080, // fxsclnt.chm  - Client context help
    FAX_COMPONENT_HELP_ADMIN_HLP    = 0x0100, // fxsadmin.hlp - Admin help
    FAX_COMPONENT_HELP_ADMIN_CHM    = 0x0200, // fxsadmin.chm - Admin context help
    FAX_COMPONENT_HELP_CPE_CHM      = 0x0400, // fxscover.chm - Cover page editor help
    FAX_COMPONENT_MONITOR           = 0x0800, // fxsst.dll    - Fax monitor
    FAX_COMPONENT_DRIVER_UI         = 0x1000  // fxsui.dll    - Fax printer driver

} FAX_COMPONENT_TYPE;

BOOL
IsFaxComponentInstalled(FAX_COMPONENT_TYPE component);

DWORD GetOpenFileNameStructSize();

#endif

#ifndef FAXUTIL_LANG

//
// Unicode control characters
//
#define UNICODE_RLM 0x200F  // RIGHT-TO-LEFT MARK      (RLM)
#define UNICODE_RLE 0x202B  // RIGHT-TO-LEFT EMBEDDING (RLE)
#define UNICODE_RLO 0x202E  // RIGHT-TO-LEFT OVERRIDE  (RLO)

#define UNICODE_LRM 0x200E  // LEFT-TO-RIGHT MARK      (LRM)
#define UNICODE_LRE 0x202A  // LEFT-TO-RIGHT EMBEDDING (LRE)
#define UNICODE_LRO 0x202D  // LEFT-TO-RIGHT OVERRIDE  (LRO)

#define UNICODE_PDF 0x202C  // POP DIRECTIONAL FORMATTING (PDF)

//
// language functions
//

BOOL
IsRTLUILanguage();

BOOL
IsWindowRTL(HWND hWnd);

DWORD
SetLTREditDirection(
    HWND    hDlg,
    DWORD   dwEditID
);

DWORD
SetLTRControlLayout(
    HWND    hDlg,
    DWORD   dwCtrlID
);

DWORD
SetLTRComboBox(
    HWND    hDlg,
    DWORD   dwCtrlID
);

BOOL
StrHasRTLChar(
    LCID    Locale,
    LPCTSTR pStr
);

BOOL
IsRTLLanguageInstalled();

int
FaxTimeFormat(
  LCID    Locale,             // locale
  DWORD   dwFlags,            // options
  CONST   SYSTEMTIME *lpTime, // time
  LPCTSTR lpFormat,           // time format string
  LPTSTR  lpTimeStr,          // formatted string buffer
  int     cchTime             // size of string buffer
);

int
AlignedMessageBox(
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType          // message box style
);

DWORD SetRTLProcessLayout();

DWORD
AskUserAndAdjustFaxFolder(
    HWND   hWnd,
    TCHAR* szServerName, 
    TCHAR* szPath,
    DWORD  dwError
);


#endif

#ifndef FAXUTIL_NET

BOOL
IsSimpleUI();

#endif

//
// registry functions
//

#ifndef FAXUTIL_REG

typedef BOOL (WINAPI *PREGENUMCALLBACK) (HKEY,LPTSTR,DWORD,LPVOID);

HKEY
OpenRegistryKey(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    );

//
// caution!!! this is a recursive delete function !!!
//
BOOL
DeleteRegistryKey(
    HKEY hKey,
    LPCTSTR SubKey
    );

DWORD
EnumerateRegistryKeys(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL ChangeValues,
    PREGENUMCALLBACK EnumCallback,
    LPVOID ContextData
    );

LPTSTR
GetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    );

BOOL 
GetRegistryDwordDefault(
    HKEY hKey, 
    LPCTSTR lpszValueName, 
    LPDWORD lpdwDest, 
    DWORD dwDefault);

DWORD
GetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName
    );

DWORD
GetRegistryDwordEx(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD lpdwValue
    );

LPBYTE
GetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD DataSize
    );

DWORD
GetSubKeyCount(
    HKEY hKey
    );

DWORD
GetMaxSubKeyLen(
    HKEY hKey
    );

BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName,
    DWORD Value
    );

BOOL
SetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    const LPBYTE Value,
    LONG Length
    );

BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value,
    DWORD Length
    );

DWORD
CopyRegistrySubkeysByHandle(
    HKEY    hkeyDest,
    HKEY    hkeySrc,
    BOOL fForceRestore
    );

DWORD
CopyRegistrySubkeys(
    LPCTSTR strDest,
    LPCTSTR strSrc,
    BOOL fForceRestore
    );

BOOL SetPrivilege(
    LPTSTR pszPrivilege,
    BOOL bEnable,
    PTOKEN_PRIVILEGES oldPrivilege
    );

BOOL RestorePrivilege(
    PTOKEN_PRIVILEGES oldPrivilege
    );

DWORD
DeleteDeviceEntry(
    DWORD dwServerPermanentID
    );

DWORD
DeleteTapiEntry(
    DWORD dwTapiPermanentLineID
    );

DWORD
DeleteCacheEntry(
    DWORD dwTapiPermanentLineID
    );

#endif

//
// shortcut routines
//

#ifndef FAXUTIL_SHORTCUT

LPTSTR
GetCometPath();

BOOL
IsValidCoverPage(
    LPCTSTR  pFileName
);

BOOL
GetServerCpDir(
    LPCTSTR ServerName OPTIONAL,
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
GetClientCpDir(
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
SetClientCpDir(
    LPTSTR CpDir
    );

BOOL
GetSpecialPath(
   IN   int      nFolder,
   OUT  LPTSTR   lptstrPath,
   IN   DWORD    dwPathSize
    );

#ifdef _FAXAPIP_


#endif // _FAXAPIP_

DWORD
WinHelpContextPopup(
    ULONG_PTR dwHelpId,
    HWND hWnd
);

BOOL
InvokeServiceManager(
	   HWND hDlg,
	   HINSTANCE hResource,
	   UINT uid
);

#endif

PPRINTER_INFO_2
GetFaxPrinterInfo(
    LPCTSTR lptstrPrinterName
    );

BOOL
GetFirstLocalFaxPrinterName(
    OUT LPTSTR lptstrPrinterName,
    IN DWORD dwMaxLenInChars
    );

BOOL
GetFirstRemoteFaxPrinterName(
    OUT LPTSTR lptstrPrinterName,
    IN DWORD dwMaxLenInChars
    );

DWORD
IsLocalFaxPrinterInstalled(
    LPBOOL lpbLocalFaxPrinterInstalled
    );

DWORD
SetLocalFaxPrinterSharing (
    BOOL bShared
    );

DWORD
AddOrVerifyLocalFaxPrinter ();

#ifdef UNICODE
typedef struct
{
    LPCWSTR lpcwstrDisplayName;     // The display name of the printer
    LPCWSTR lpcwstrPath;            // The (UNC or other) path to the printer - as used by the fax service
} PRINTER_NAMES, *PPRINTER_NAMES;

PPRINTER_NAMES
CollectPrinterNames (
    LPDWORD lpdwNumPrinters,
    BOOL    bFilterOutFaxPrinters
);

VOID
ReleasePrinterNames (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters
);

LPCWSTR
FindPrinterNameFromPath (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrPath
);

LPCWSTR
FindPrinterPathFromName (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrName
);

#endif // UNICODE

BOOL
VerifyPrinterIsOnline (
    LPCTSTR lpctstrPrinterName
);

VOID FaxPrinterProperty(DWORD dwPage);

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   dwLevel,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    );


PVOID
MyEnumDrivers3(
    LPTSTR pEnvironment,
    PDWORD pcDrivers
    );


DWORD
IsLocalFaxPrinterShared (
    LPBOOL lpbShared
    );

DWORD
AddLocalFaxPrinter (
    LPCTSTR lpctstrPrinterName,
    LPCTSTR lpctstrPrinterDescription
);

HRESULT
RefreshPrintersAndFaxesFolder ();

PVOID
MyEnumMonitors(
    PDWORD  pcMonitors
    );

BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    );

BOOL
FaxPointAndPrintSetup(
    LPCTSTR pPrinterName,
    BOOL    bSilentInstall,
    HINSTANCE hModule
    );

BOOL
MultiFileDelete(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrFilesDirectory
    );


//
// START - Functions exported from service.cpp
//

BOOL
EnsureFaxServiceIsStarted(
    LPCTSTR lpctstrMachineName
    );

BOOL
StopService (
    LPCTSTR lpctstrMachineName,
    LPCTSTR lpctstrServiceName,
    BOOL    bStopDependents,
#ifdef __cplusplus
    DWORD   dwMaxWait = INFINITE
#else    
    DWORD   dwMaxWait
#endif    
    );

BOOL
WaitForServiceRPCServer (DWORD dwTimeOut);

DWORD
IsFaxServiceRunningUnderLocalSystemAccount (
    LPCTSTR lpctstrMachineName,
    LPBOOL lbpResultFlag
    );

DWORD
GetServiceStartupType (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    LPDWORD lpdwStartupType
);

DWORD
SetServiceStartupType (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    DWORD   dwStartupType
);

DWORD 
StartServiceEx (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    DWORD   dwNumArgs,
    LPCTSTR*lppctstrCommandLineArgs,
    DWORD   dwMaxWait
);

#ifdef _WINSVC_
DWORD
SetServiceFailureActions (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    LPSERVICE_FAILURE_ACTIONS lpFailureActions
);
#endif // _WINSVC_

PSID
GetCurrentThreadSID ();

SECURITY_ATTRIBUTES *
CreateSecurityAttributesWithThreadAsOwner (
    DWORD dwCurrentThreadRights,
	DWORD dwAuthUsersAccessRights,
	DWORD dwNetworkServiceRights	
);

VOID
DestroySecurityAttributes (
    SECURITY_ATTRIBUTES *pSA
);

DWORD
CreateSvcStartEvent(
    HANDLE *lphEvent,
    HKEY   *lphKey
);

//
// END - Functions exported from service.cpp
//

//
// START - Functions exported from security.cpp
//

HANDLE
EnablePrivilege (
    LPCTSTR lpctstrPrivName
);

void
ReleasePrivilege(
    HANDLE hToken
);

DWORD
EnableProcessPrivilege(
    LPCTSTR lpPrivilegeName
);

DWORD
FaxGetAbsoluteSD(
    PSECURITY_DESCRIPTOR pSelfRelativeSD,
    PSECURITY_DESCRIPTOR* ppAbsoluteSD
);

void
FaxFreeAbsoluteSD (
    PSECURITY_DESCRIPTOR pAbsoluteSD,
    BOOL bFreeOwner,
    BOOL bFreeGroup,
    BOOL bFreeDacl,
    BOOL bFreeSacl,
    BOOL bFreeDescriptor
);

//
// END - Functions exported from security.cpp
//


BOOL
MultiFileCopy(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrSrcDirectory,
    LPCTSTR  lpctstrDestDirerctory
    );

typedef enum
{
    CDO_AUTH_ANONYMOUS, // No authentication in SMTP server
    CDO_AUTH_BASIC,     // Basic (plain-text) authentication in SMTP server
    CDO_AUTH_NTLM       // NTLM authentication in SMTP server
}   CDO_AUTH_TYPE;

HRESULT
SendMail (
    LPCTSTR         lpctstrFrom,
    LPCTSTR         lpctstrTo,
    LPCTSTR         lpctstrSubject,
    LPCTSTR         lpctstrBody,
    LPCTSTR         lpctstrHTMLBody,
    LPCTSTR         lpctstrAttachmentPath,
    LPCTSTR         lpctstrAttachmentMailFileName,
    LPCTSTR         lpctstrServer,
#ifdef __cplusplus  // Provide default parameters values for C++ clients
    DWORD           dwPort              = 25,
    CDO_AUTH_TYPE   AuthType            = CDO_AUTH_ANONYMOUS,
    LPCTSTR         lpctstrUser         = NULL,
    LPCTSTR         lpctstrPassword     = NULL,
    HANDLE          hLoggedOnUserToken  = NULL
#else
    DWORD           dwPort,
    CDO_AUTH_TYPE   AuthType,
    LPCTSTR         lpctstrUser,
    LPCTSTR         lpctstrPassword,
    HANDLE          hLoggedOnUserToken
#endif
);


//
// FAXAPI structures utils
//


#ifdef _FAXAPIP_

BOOL CopyPersonalProfile(
    PFAX_PERSONAL_PROFILE lpDstProfile,
    LPCFAX_PERSONAL_PROFILE lpcSrcProfile
    );

void FreePersonalProfile (
    PFAX_PERSONAL_PROFILE  lpProfile,
    BOOL bDestroy
    );

#endif // _FAXAPIP_

//
// Tapi helper routines
//

#ifndef FAXUTIL_ADAPTIVE

#include <setupapi.h>

BOOL
IsDeviceModem (
    LPLINEDEVCAPS lpLineCaps,
    LPCTSTR       lpctstrUnimodemTspName
    );

LPLINEDEVCAPS
SmartLineGetDevCaps(
    HLINEAPP hLineApp,
    DWORD    dwDeviceId,
    DWORD    dwAPIVersion
    );


DWORD
GetFaxCapableTapiLinesCount (
    LPDWORD lpdwCount,
    LPCTSTR lpctstrUnimodemTspName
    );

#endif

//
//  RPC util functions
//
#define LOCAL_HOST_ADDRESS  _T("127.0.0.1")

RPC_STATUS
GetRpcStringBindingInfo (
    IN          handle_t    hBinding,
    OUT         LPTSTR*     pptszNetworkAddress,
    OUT         LPTSTR*     pptszProtSeq
);

RPC_STATUS
IsLocalRPCConnectionIpTcp( 
	handle_t	hBinding,
	PBOOL		pbIsLocal
);

RPC_STATUS
IsLocalRPCConnectionNP( PBOOL pbIsLocal
);

//
//  RPC debug functions
//
VOID
DumpRPCExtendedStatus ();

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//
//  This was borrowed from fatprocs.h

#ifdef DBG
#define try_fail(S) { DebugPrint(( TEXT("Failure in FILE %s LINE %d"), TEXT(__FILE__), __LINE__ )); S; goto try_exit; }
#else
#define try_fail(S) { S; goto try_exit; }
#endif

#define try_return(S) { S; goto try_exit; }
#define NOTHING

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\smartptr.h ===
// -*- c++ -*-
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    auto.h

Abstract:

    Smart pointer and auto handle classes

Author:


Revision History:
--*/

#ifndef COMET_SMARTPTR__H
#define COMET_SMARTPTR__H

#ifndef RWSASSERT
#define RWSASSERT(x) ATLASSERT(x)
#endif


//
// Class for automatic handle close.
//
template<int _CHV>
class CAutoCloseHandle_ {
    HANDLE m_h;

    void _Close() { if (m_h != ((HANDLE)(_CHV))) CloseHandle(m_h); }
public:
    CAutoCloseHandle_(HANDLE h =((HANDLE)(_CHV))) { m_h = h; }
    ~CAutoCloseHandle_() { _Close(); }

    CAutoCloseHandle_ & operator =(HANDLE h) {
        _Close();
        m_h = h;
        return *this;
    }

    HANDLE * operator &()  {
        RWSASSERT(m_h == ((HANDLE)(_CHV)));
        return &m_h;
    }

    operator HANDLE() { return m_h; }
    // Set to INVALID_HANDLE_VALUE without closing
    HANDLE Detach()   { HANDLE h = m_h; m_h = ((HANDLE)(_CHV)); return h; }
    void Attach(HANDLE h) { _Close(); m_h = h;                            }
    void Close()      { _Close(); m_h = ((HANDLE)(_CHV));                 }
};

typedef CAutoCloseHandle_<0>  CAutoCloseHandle;
// -1 is INVALID_HANDLE_VALUE, can't use it as template parameter
typedef CAutoCloseHandle_<-1> CAutoCloseFileHandle;

//-----------------------------
//
//  Auto delete pointer
//
template<class T>
class P {
private:
    T* m_p;
    void _Del()             { delete m_p; }

public:
    P() : m_p(0)            {}
    P(T* p) : m_p(p)        {}
   ~P()                     { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    P<T>& operator =(T* p)  { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Auto delete pointer for struct/class
//
template<class T>
class PC {
private:
    T* m_p;
    void _Del()             { delete m_p; }

public:
    PC() : m_p(0)           {}
    PC(T* p) : m_p(p)       {}
   ~PC()                    { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    PC<T>& operator =(T* p) { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Auto delete[] pointer, used for arrays
//
template<class T>
class AP {
private:
    T* m_p;
    void _Del() { delete [] m_p; }
public:
    AP() : m_p(0)           {}
    AP(T* p) : m_p(p)       {}
   ~AP()                    { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    AP<T>& operator =(T* p) { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};

//-----------------------------
//
//  Auto delete[] pointer, used for arrays of class/struct
//
template<class T>
class APC {
private:
    T* m_p;
    void _Del() { delete [] m_p; }
public:
    APC() : m_p(0)          {}
    APC(T* p) : m_p(p)      {}
   ~APC()                   { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    APC<T>& operator =(T* p){ _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Smart pointer that does both addref and relese
//
//  Used when CComPtr cannot be used.
template<class T>
class AR {
private:
    void _Rel()             { if(m_p) m_p->Release(); }
public:
    T* m_p;
    AR() : m_p(0)           {}
    AR(T* p) : m_p(p)       { if (m_p) m_p->AddRef(); }
   ~AR()                    { _Rel(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    T* operator =(T* p) { _Rel();
                          if(p) p->AddRef();
                          m_p = p;
                          return p; }
    T* operator=(const AR<T>& p) {
        _Rel();
        if(p.m_p) p.m_p->AddRef();
        m_p = p.m_p;
        return p.m_p;
    }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Rel(); m_p = p;                      }
    HRESULT CopyTo(T** ppT) {
        RWSASSERT(ppT != NULL);
        DBGPRINT(("CopyTo: ppT=%X m_p=%X\n", ppT,m_p));
        if (ppT == NULL) return E_POINTER;
        *ppT = m_p;
        if (m_p) m_p->AddRef();
        return S_OK;
    }
};

#ifdef RWS
//
// Class that automatically closes sockets if not instructed otherwise.
//
class CAutoSocket {
private:
    SOCKET m_Socket;
    void Free()                 { if (m_Socket != INVALID_SOCKET)
                                     closesocket(m_Socket);       }

public:
    CAutoSocket()               { m_Socket = INVALID_SOCKET;      }
    CAutoSocket(SOCKET s)       { m_Socket = s;                   }
    ~CAutoSocket()              { Free();                         }

    operator SOCKET()           { return m_Socket;                }
    CAutoSocket& operator=(SOCKET s) { Free(); m_Socket = s; return *this;}
    SOCKET* operator &()        { return &m_Socket;               }
    SOCKET Detach()             { SOCKET s = m_Socket;
                                  m_Socket = INVALID_SOCKET;
                                  return s;                       }
    void Attach(SOCKET s)       { Free(); m_Socket = s;           }
};
#endif

//
// Class for automatic HKEY close.
//
class CAutoHKEY {
    HKEY m_h;

    void _Close() { if (m_h != NULL) RegCloseKey(m_h); }
public:
    CAutoHKEY(HKEY h = NULL) { m_h = h; }
    ~CAutoHKEY() { _Close(); }

    CAutoHKEY & operator =(HKEY h) {
        _Close();
        m_h = h;
        return *this;
    }

    HKEY * operator &()  {
        RWSASSERT(m_h == NULL);
        return &m_h;
    }

    operator HKEY()         { return m_h; }
    HKEY Detach()           { HKEY hk = m_h; m_h = NULL; return hk; }
    void Attach(HKEY h)     { _Close(); m_h = h;                    }
};

#endif // COMET_SMARTPTR__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\prtcovpg.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    prtcovpg.h

Abstract:

    This module contains the WIN32 Fax API header
    for the Windows XP FaxCover rendering routine.

Author:

    Julia Robinson (a-juliar) 5-20-96

Revision History:

    Julia Robinson (a-juliar) 6-7-76
    Julia Robinson (a-juliar) 9-20-96     Allow passing paper size and orientation.
--*/

#ifndef __PRTCOVPG_H__
#define __PRTCOVPG_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure of the composite file header
//

typedef struct {
    BYTE      Signature[20];
    DWORD     EmfSize;
    DWORD     NbrOfTextRecords;
    SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;

//
// Structure of the text box entries appended to
// the composite file
//

typedef struct {
    RECT           PositionOfTextBox;
    COLORREF       TextColor;
    LONG           TextAlignment;
    LOGFONTW       FontDefinition;
    WORD           ResourceID ;
    DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOX;


//
// Structure of user data for text insertions
//

typedef struct _COVERPAGEFIELDS {

  //
  // Recipient stuff...
  //

  DWORD   ThisStructSize;
  LPTSTR  RecName;
  LPTSTR  RecFaxNumber;
  LPTSTR  RecCompany;
  LPTSTR  RecStreetAddress;
  LPTSTR  RecCity;
  LPTSTR  RecState;
  LPTSTR  RecZip;
  LPTSTR  RecCountry;
  LPTSTR  RecTitle;
  LPTSTR  RecDepartment;
  LPTSTR  RecOfficeLocation;
  LPTSTR  RecHomePhone;
  LPTSTR  RecOfficePhone;

  //
  // Senders stuff...
  //

  LPTSTR  SdrName;
  LPTSTR  SdrFaxNumber;
  LPTSTR  SdrCompany;
  LPTSTR  SdrAddress;
  LPTSTR  SdrTitle;
  LPTSTR  SdrDepartment;
  LPTSTR  SdrOfficeLocation;
  LPTSTR  SdrHomePhone;
  LPTSTR  SdrOfficePhone;
  LPTSTR  SdrEmail;

  //
  // Misc Stuff...
  //
  LPTSTR  Note;
  LPTSTR  Subject;
  LPTSTR  TimeSent;
  LPTSTR  NumberOfPages;
  LPTSTR  ToList;
  LPTSTR  CCList ;
} COVERPAGEFIELDS, *PCOVERPAGEFIELDS;

#define  NUM_INSERTION_TAGS   ((sizeof(COVERPAGEFIELDS) - sizeof(DWORD)) / sizeof(LPTSTR))

//
// pFlags fields: bit 0 is Recipient Name, bit 1 is Recipient Fax Number, et cetera.
//

#define  COVFP_NOTE         0x00800000
#define  COVFP_SUBJECT      0x01000000
#define  COVFP_NUMPAGES     0x04000000

typedef struct _COVDOCINFO {
    DWORD       Flags ;
    RECT        NoteRect ;
    short       Orientation ;
    short       PaperSize ;
    LOGFONT     NoteFont ;
} COVDOCINFO, *PCOVDOCINFO ;


//
// Function prototypes
//

DWORD WINAPI
PrintCoverPage(
    HDC               hDC,
    PCOVERPAGEFIELDS  pUserData,
    LPCTSTR           lpctstrTemplateFileName,
    PCOVDOCINFO       pCovDocInfo
    );

DWORD
WINAPI
RenderCoverPage(
    HDC              hdc,
	LPCRECT			 lpcRect,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo,
    BOOL             bPreview
    );


DWORD
PrintCoverPageToFile(
    LPTSTR lptstrCoverPage,
    LPTSTR lptstrTargetFile,
    LPTSTR lptstrPrinterName,
    short sCPOrientation,
	short sCPYResolution,
    PCOVERPAGEFIELDS pCPFields);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\routemapi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    routemapi.h

Abstract:

    This module provides the implemantation of registry manipulations to 
    route MAPI calls to the Microsoft Outlook mail client

Author:

    Mooly Beery (moolyb) 5-Nov-2000


Revision History:

--*/

#ifndef __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__
#define __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__

// EXPORT_MAPI_ROUTE_CALLS is defined in the module only
// this way when the module is compiled the class exports its functions
// when others use this header file the functions won't be exported by them
#ifdef EXPORT_MAPI_ROUTE_CALLS
    #define dllexp __declspec( dllexport )
#else   // EXPORT_MAPI_ROUTE_CALLS
    #define dllexp 
#endif  // EXPORT_MAPI_ROUTE_CALLS

class dllexp CRouteMAPICalls
{
public:
    CRouteMAPICalls();    
    ~CRouteMAPICalls();                             // used to restore the changes the Init method performed

    DWORD Init(LPCTSTR lpctstrProcessName);         // this is the process for which the MAPI calls are routed
                                                    // used to set up the registry to route MAPI calls of the 
                                                    // proper process to the Microsoft Outlook mail client
                                                    // and to suppress any pop-ups which might occur
private:

    bool m_bMSOutlookInstalled;                     // is Microsoft Outlook mail client installed
    bool m_bMSOutlookIsDefault;                     // is Microsoft Outlook the default mail client
    bool m_bProcessIsRouted;                        // are calls from the requested process already routed
    bool m_bProcessIsRoutedToMsOutlook;             // are calls from the process routed to Ms Outlook

    TCHAR* m_ptProcessName;                         // process name to route calls for

};

#endif  // __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\warning.h ===
#pragma warning(3:4101)         // Unreferenced local variable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\winres.h ===
//
// this header file is necessay because
// vc is lame.  it insists on including
// a file named winres.h in it's generated
// rc file.  the problem is that winres.h
// is a non-standard header file that
// exists only in a vc install.
//

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\inc\tiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff.h

Abstract:

    This file the data structures and constant
    definitions for the TIFF file format.
    See the TIFF specification Revision 6.0,
    dated 6-3-92, from Adobe for specific details.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFF_
#define _TIFF_

#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

#pragma pack(1)

typedef struct _TIFF_HEADER 
{
    WORD        Identifier;
    WORD        Version;
    DWORD       IFDOffset;
} TIFF_HEADER, *PTIFF_HEADER;

//
// TIFF Image File Directories are comprised of
// a table of field descriptors of the form shown
// below.  The table is sorted in ascending order
// by tag.  The values associated with each entry
// are disjoint and may appear anywhere in the file
// (so long as they are placed on a word boundary).
//
// If the value is 4 bytes or less, then it is placed
// in the offset field to save space.  If the value
// is less than 4 bytes, it is left-justified in the
// offset field.
//
typedef struct _TIFF_TAG {
    WORD        TagId;
    WORD        DataType;
    DWORD       DataCount;
    DWORD       DataOffset;
} TIFF_TAG;

typedef TIFF_TAG UNALIGNED *PTIFF_TAG;

typedef struct TIFF_IFD {
    WORD        wEntries;
    TIFF_TAG    ifdEntries[1];
} TIFF_IFD;

typedef TIFF_IFD UNALIGNED *PTIFF_IFD;


#pragma pack()


//
// NB: In the comments below,
//  - items marked with a + are obsoleted by revision 5.0,
//  - items marked with a ! are introduced in revision 6.0.
//  - items marked with a % are introduced post revision 6.0.
//  - items marked with a $ are obsoleted by revision 6.0.
//

//
// Tag data type information.
//
#define TIFF_NOTYPE                     0       // placeholder
#define TIFF_BYTE                       1       // 8-bit unsigned integer
#define TIFF_ASCII                      2       // 8-bit bytes w/ last byte null
#define TIFF_SHORT                      3       // 16-bit unsigned integer
#define TIFF_LONG                       4       // 32-bit unsigned integer
#define TIFF_RATIONAL                   5       // 64-bit unsigned fraction
#define TIFF_SBYTE                      6       // !8-bit signed integer
#define TIFF_UNDEFINED                  7       // !8-bit untyped data
#define TIFF_SSHORT                     8       // !16-bit signed integer
#define TIFF_SLONG                      9       // !32-bit signed integer
#define TIFF_SRATIONAL                  10      // !64-bit signed fraction
#define TIFF_FLOAT                      11      // !32-bit IEEE floating point
#define TIFF_DOUBLE                     12      // !64-bit IEEE floating point

//
// TIFF Tag Definitions.
//
#define TIFFTAG_SUBFILETYPE             254     // subfile data descriptor
#define     FILETYPE_REDUCEDIMAGE       0x1     // reduced resolution version
#define     FILETYPE_PAGE               0x2     // one page of many
#define     FILETYPE_MASK               0x4     // transparency mask
#define TIFFTAG_OSUBFILETYPE            255     // +kind of data in subfile
#define     OFILETYPE_IMAGE             1       // full resolution image data
#define     OFILETYPE_REDUCEDIMAGE      2       // reduced size image data
#define     OFILETYPE_PAGE              3       // one page of many
#define TIFFTAG_IMAGEWIDTH              256     // image width in pixels
#define TIFFTAG_IMAGELENGTH             257     // image height in pixels
#define TIFFTAG_BITSPERSAMPLE           258     // bits per channel (sample)
#define TIFFTAG_COMPRESSION             259     // data compression technique
#define     COMPRESSION_NONE            1       // dump mode
#define     COMPRESSION_CCITTRLE        2       // CCITT modified Huffman RLE
#define     COMPRESSION_CCITTFAX3       3       // CCITT Group 3 fax encoding
#define     COMPRESSION_CCITTFAX4       4       // CCITT Group 4 fax encoding
#define     COMPRESSION_LZW             5       // Lempel-Ziv  & Welch
#define     COMPRESSION_OJPEG           6       // !6.0 JPEG
#define     COMPRESSION_JPEG            7       // %JPEG DCT compression
#define     COMPRESSION_NEXT            32766   // NeXT 2-bit RLE
#define     COMPRESSION_CCITTRLEW       32771   // #1 w/ word alignment
#define     COMPRESSION_PACKBITS        32773   // Macintosh RLE
#define     COMPRESSION_THUNDERSCAN     32809   // ThunderScan RLE
//
// compression codes 32908-32911 are reserved for Pixar
//
#define     COMPRESSION_PIXARFILM       32908   // Pixar companded 10bit LZW
#define     COMPRESSION_DEFLATE         32946   // Deflate compression
#define     COMPRESSION_JBIG            34661   // ISO JBIG
#define TIFFTAG_PHOTOMETRIC             262     // photometric interpretation
#define     PHOTOMETRIC_MINISWHITE      0       // min value is white
#define     PHOTOMETRIC_MINISBLACK      1       // min value is black
#define     PHOTOMETRIC_RGB             2       // RGB color model
#define     PHOTOMETRIC_PALETTE         3       // color map indexed
#define     PHOTOMETRIC_MASK            4       // $holdout mask
#define     PHOTOMETRIC_SEPARATED       5       // !color separations
#define     PHOTOMETRIC_YCBCR           6       // !CCIR 601
#define     PHOTOMETRIC_CIELAB          8       // !1976 CIE L*a*b*
#define TIFFTAG_THRESHHOLDING           263     // +thresholding used on data
#define     THRESHHOLD_BILEVEL          1       // b&w art scan
#define     THRESHHOLD_HALFTONE         2       // or dithered scan
#define     THRESHHOLD_ERRORDIFFUSE     3       // usually floyd-steinberg
#define TIFFTAG_CELLWIDTH               264     // +dithering matrix width
#define TIFFTAG_CELLLENGTH              265     // +dithering matrix height
#define TIFFTAG_FILLORDER               266     // data order within a byte
#define     FILLORDER_MSB2LSB           1       // most significant -> least
#define     FILLORDER_LSB2MSB           2       // least significant -> most
#define TIFFTAG_DOCUMENTNAME            269     // name of doc. image is from
#define TIFFTAG_IMAGEDESCRIPTION        270     // info about image
#define TIFFTAG_MAKE                    271     // scanner manufacturer name
#define TIFFTAG_MODEL                   272     // scanner model name/number
#define TIFFTAG_STRIPOFFSETS            273     // offsets to data strips
#define TIFFTAG_ORIENTATION             274     // +image orientation
#define     ORIENTATION_TOPLEFT         1       // row 0 top, col 0 lhs
#define     ORIENTATION_TOPRIGHT        2       // row 0 top, col 0 rhs
#define     ORIENTATION_BOTRIGHT        3       // row 0 bottom, col 0 rhs
#define     ORIENTATION_BOTLEFT         4       // row 0 bottom, col 0 lhs
#define     ORIENTATION_LEFTTOP         5       // row 0 lhs, col 0 top
#define     ORIENTATION_RIGHTTOP        6       // row 0 rhs, col 0 top
#define     ORIENTATION_RIGHTBOT        7       // row 0 rhs, col 0 bottom
#define     ORIENTATION_LEFTBOT         8       // row 0 lhs, col 0 bottom
#define TIFFTAG_SAMPLESPERPIXEL         277     // samples per pixel
#define TIFFTAG_ROWSPERSTRIP            278     // rows per strip of data
#define TIFFTAG_STRIPBYTECOUNTS         279     // bytes counts for strips
#define TIFFTAG_MINSAMPLEVALUE          280     // +minimum sample value
#define TIFFTAG_MAXSAMPLEVALUE          281     // +maximum sample value
#define TIFFTAG_XRESOLUTION             282     // pixels/resolution in x
#define TIFFTAG_YRESOLUTION             283     // pixels/resolution in y
#define TIFFTAG_PLANARCONFIG            284     // storage organization
#define     PLANARCONFIG_CONTIG         1       // single image plane
#define     PLANARCONFIG_SEPARATE       2       // separate planes of data
#define TIFFTAG_PAGENAME                285     // page name image is from
#define TIFFTAG_XPOSITION               286     // x page offset of image lhs
#define TIFFTAG_YPOSITION               287     // y page offset of image lhs
#define TIFFTAG_FREEOFFSETS             288     // +byte offset to free block
#define TIFFTAG_FREEBYTECOUNTS          289     // +sizes of free blocks
#define TIFFTAG_GRAYRESPONSEUNIT        290     // $gray scale curve accuracy
#define     GRAYRESPONSEUNIT_10S        1       // tenths of a unit
#define     GRAYRESPONSEUNIT_100S       2       // hundredths of a unit
#define     GRAYRESPONSEUNIT_1000S      3       // thousandths of a unit
#define     GRAYRESPONSEUNIT_10000S     4       // ten-thousandths of a unit
#define     GRAYRESPONSEUNIT_100000S    5       // hundred-thousandths
#define TIFFTAG_GRAYRESPONSECURVE       291     // $gray scale response curve
#define TIFFTAG_GROUP3OPTIONS           292     // 32 flag bits
#define     GROUP3OPT_2DENCODING        0x1     // 2-dimensional coding
#define     GROUP3OPT_UNCOMPRESSED      0x2     // data not compressed
#define     GROUP3OPT_FILLBITS          0x4     // fill to byte boundary
#define TIFFTAG_GROUP4OPTIONS           293     // 32 flag bits
#define     GROUP4OPT_UNCOMPRESSED      0x2     // data not compressed
#define TIFFTAG_RESOLUTIONUNIT          296     // units of resolutions
#define     RESUNIT_NONE                1       // no meaningful units
#define     RESUNIT_INCH                2       // english
#define     RESUNIT_CENTIMETER          3       // metric
#define TIFFTAG_PAGENUMBER              297     // page numbers of multi-page
#define TIFFTAG_COLORRESPONSEUNIT       300     // $color curve accuracy
#define     COLORRESPONSEUNIT_10S       1       // tenths of a unit
#define     COLORRESPONSEUNIT_100S      2       // hundredths of a unit
#define     COLORRESPONSEUNIT_1000S     3       // thousandths of a unit
#define     COLORRESPONSEUNIT_10000S    4       // ten-thousandths of a unit
#define     COLORRESPONSEUNIT_100000S   5       // hundred-thousandths
#define TIFFTAG_TRANSFERFUNCTION        301     // !colorimetry info
#define TIFFTAG_SOFTWARE                305     // name & release
#define TIFFTAG_DATETIME                306     // creation date and time
#define TIFFTAG_ARTIST                  315     // creator of image
#define TIFFTAG_HOSTCOMPUTER            316     // machine where created
#define TIFFTAG_PREDICTOR               317     // prediction scheme w/ LZW
#define TIFFTAG_WHITEPOINT              318     // image white point
#define TIFFTAG_PRIMARYCHROMATICITIES   319     // !primary chromaticities
#define TIFFTAG_COLORMAP                320     // RGB map for pallette image
#define TIFFTAG_HALFTONEHINTS           321     // !highlight+shadow info
#define TIFFTAG_TILEWIDTH               322     // !rows/data tile
#define TIFFTAG_TILELENGTH              323     // !cols/data tile
#define TIFFTAG_TILEOFFSETS             324     // !offsets to data tiles
#define TIFFTAG_TILEBYTECOUNTS          325     // !byte counts for tiles
#define TIFFTAG_BADFAXLINES             326     // lines w/ wrong pixel count
#define TIFFTAG_CLEANFAXDATA            327     // regenerated line info
#define     CLEANFAXDATA_CLEAN          0       // no errors detected
#define     CLEANFAXDATA_REGENERATED    1       // receiver regenerated lines
#define     CLEANFAXDATA_UNCLEAN        2       // uncorrected errors exist
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     // max consecutive bad lines
#define TIFFTAG_SUBIFD                  330     // subimage descriptors
#define TIFFTAG_INKSET                  332     // !inks in separated image
#define     INKSET_CMYK                 1       // !cyan-magenta-yellow-black
#define TIFFTAG_INKNAMES                333     // !ascii names of inks
#define TIFFTAG_DOTRANGE                336     // !0% and 100% dot codes
#define TIFFTAG_TARGETPRINTER           337     // !separation target
#define TIFFTAG_EXTRASAMPLES            338     // !info about extra samples
#define     EXTRASAMPLE_UNSPECIFIED     0       // !unspecified data
#define     EXTRASAMPLE_ASSOCALPHA      1       // !associated alpha data
#define     EXTRASAMPLE_UNASSALPHA      2       // !unassociated alpha data
#define TIFFTAG_SAMPLEFORMAT            339     // !data sample format
#define     SAMPLEFORMAT_UINT           1       // !unsigned integer data
#define     SAMPLEFORMAT_INT            2       // !signed integer data
#define     SAMPLEFORMAT_IEEEFP         3       // !IEEE floating point data
#define     SAMPLEFORMAT_VOID           4       // !untyped data
#define TIFFTAG_SMINSAMPLEVALUE         340     // !variable MinSampleValue
#define TIFFTAG_SMAXSAMPLEVALUE         341     // !variable MaxSampleValue
#define TIFFTAG_JPEGTABLES              347     // %JPEG table stream
//
// Tags 512-521 are obsoleted by Technical Note #2
// which specifies a revised JPEG-in-TIFF scheme.
//
#define TIFFTAG_JPEGPROC                512     // !JPEG processing algorithm
#define     JPEGPROC_BASELINE           1       // !baseline sequential
#define     JPEGPROC_LOSSLESS           14      // !Huffman coded lossless
#define TIFFTAG_JPEGIFOFFSET            513     // !pointer to SOI marker
#define TIFFTAG_JPEGIFBYTECOUNT         514     // !JFIF stream length
#define TIFFTAG_JPEGRESTARTINTERVAL     515     // !restart interval length
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     // !lossless proc predictor
#define TIFFTAG_JPEGPOINTTRANSFORM      518     // !lossless point transform
#define TIFFTAG_JPEGQTABLES             519     // !Q matrice offsets
#define TIFFTAG_JPEGDCTABLES            520     // !DCT table offsets
#define TIFFTAG_JPEGACTABLES            521     // !AC coefficient offsets
#define TIFFTAG_YCBCRCOEFFICIENTS       529     // !RGB -> YCbCr transform
#define TIFFTAG_YCBCRSUBSAMPLING        530     // !YCbCr subsampling factors
#define TIFFTAG_YCBCRPOSITIONING        531     // !subsample positioning
#define     YCBCRPOSITION_CENTERED      1       // !as in PostScript Level 2
#define     YCBCRPOSITION_COSITED       2       // !as in CCIR 601-1
#define TIFFTAG_REFERENCEBLACKWHITE     532     // !colorimetry info
//
// tags 32952-32956 are private tags registered to Island Graphics
//
#define TIFFTAG_REFPTS                  32953   // image reference points
#define TIFFTAG_REGIONTACKPOINT         32954   // region-xform tack point
#define TIFFTAG_REGIONWARPCORNERS       32955   // warp quadrilateral
#define TIFFTAG_REGIONAFFINE            32956   // affine transformation mat
//
// tags 32995-32999 are private tags registered to SGI
//
#define TIFFTAG_MATTEING                32995   // $use ExtraSamples
#define TIFFTAG_DATATYPE                32996   // $use SampleFormat
#define TIFFTAG_IMAGEDEPTH              32997   // z depth of image
#define TIFFTAG_TILEDEPTH               32998   // z depth/data tile
//
// tags 33300-33309 are private tags registered to Pixar
//
// TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
// are set when an image has been cropped out of a larger image.
// They reflect the size of the original uncropped image.
// The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
// to determine the position of the smaller image in the larger one.
//
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   // full image size in x
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   // full image size in y
//
// tag 33432 is listed in the 6.0 spec w/ unknown ownership
//
#define TIFFTAG_COPYRIGHT               33432   // copyright string
//
// tags 34232-34236 are private tags registered to Texas Instruments
//
#define TIFFTAG_FRAMECOUNT              34232   // Sequence Frame Count
//
// tag 34750 is a private tag registered to Pixel Magic
//
#define TIFFTAG_JBIGOPTIONS             34750   // JBIG options
//
// tags 34908-34914 are private tags registered to SGI
//
#define TIFFTAG_FAXRECVPARAMS           34908   // encoded Class 2 ses. parms
#define TIFFTAG_FAXSUBADDRESS           34909   // received SubAddr string
#define TIFFTAG_FAXRECVTIME             34910   // receive time (secs)
//
// tags 40001-40100 are private tags registered to ms
//
#define MS_TIFFTAG_START                40001

#define TIFFTAG_CSID                    40001
#define TIFFTAG_TSID                    40002
#define TIFFTAG_PORT                    40003

#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005

#define TIFFTAG_RECIP_NAME              40006
#define TIFFTAG_RECIP_NUMBER            40007
#define TIFFTAG_RECIP_COMPANY           40008
#define TIFFTAG_RECIP_STREET            40009
#define TIFFTAG_RECIP_CITY              40010
#define TIFFTAG_RECIP_STATE             40011
#define TIFFTAG_RECIP_ZIP               40012
#define TIFFTAG_RECIP_COUNTRY           40013
#define TIFFTAG_RECIP_TITLE             40014
#define TIFFTAG_RECIP_DEPARTMENT        40015
#define TIFFTAG_RECIP_OFFICE_LOCATION   40016
#define TIFFTAG_RECIP_HOME_PHONE        40017
#define TIFFTAG_RECIP_OFFICE_PHONE      40018
#define TIFFTAG_RECIP_EMAIL             40020
#define TIFFTAG_SENDER_NAME             40021
#define TIFFTAG_SENDER_NUMBER           40022
#define TIFFTAG_SENDER_COMPANY          40023
#define TIFFTAG_SENDER_STREET           40024
#define TIFFTAG_SENDER_CITY             40025
#define TIFFTAG_SENDER_STATE            40026
#define TIFFTAG_SENDER_ZIP              40027
#define TIFFTAG_SENDER_COUNTRY          40028
#define TIFFTAG_SENDER_TITLE            40029
#define TIFFTAG_SENDER_DEPARTMENT       40030
#define TIFFTAG_SENDER_OFFICE_LOCATION  40031
#define TIFFTAG_SENDER_HOME_PHONE       40032
#define TIFFTAG_SENDER_OFFICE_PHONE     40033
#define TIFFTAG_SENDER_EMAIL            40035
#define TIFFTAG_SENDER_BILLING          40036
#define TIFFTAG_SENDER_USER_NAME        40037
#define TIFFTAG_SENDER_TSID             40038
#define TIFFTAG_DOCUMENT                40039
#define TIFFTAG_SUBJECT                 40040
#define TIFFTAG_RETRIES                 40041
#define TIFFTAG_PRIORITY                40042
#define TIFFTAG_BROADCAST_ID            40043
#define TIFFTAG_FAX_SUBMISSION_TIME     40044
#define TIFFTAG_FAX_SCHEDULED_TIME      40045

#define TIFFTAG_PAGES                   40046
#define TIFFTAG_TYPE                    40047
#define TIFFTAG_STATUS                  40048
#define TIFFTAG_EXTENDED_STATUS         40049
#define TIFFTAG_EXTENDED_STATUS_TEXT    40050
#define TIFFTAG_FAX_START_TIME          40051
#define TIFFTAG_FAX_END_TIME            40052
#define TIFFTAG_FAX_VERSION             40053


#define MS_TIFFTAG_END                  40053

#define MAX_MS_TIFFTAGS                 MS_TIFFTAG_END - MS_TIFFTAG_START +1

//
// TIFF tags defined in W2K fax
//
#define TIFFTAG_W2K_RECIP_NAME          40001
#define TIFFTAG_W2K_RECIP_NUMBER        40002
#define TIFFTAG_W2K_SENDER_NAME         40003
#define TIFFTAG_W2K_ROUTING             40004
#define TIFFTAG_W2K_CALLERID            40005
#define TIFFTAG_W2K_TSID                40006
#define TIFFTAG_W2K_CSID                40007
#define TIFFTAG_W2K_FAX_TIME            40008

//
// The following TIFF tags are used by the Shell group (contact: DavidShi)
// They are added here so we don't collide with their tags in the future
//
#define PropertyTagUnicodeDescription   40091
#define PropertyTagUnicodeComment       40092
#define PropertyTagUnicodeArtist        40093
#define PropertyTagUnicodeKeywords      40094
#define PropertyTagUnicodeSubject       40095


//
// The following are ``pseudo tags'' that can be
// used to control codec-specific functionality.
// These tags are not written to file.  Note that
// these values start at 0xffff+1 so that they'll
// never collide with Aldus-assigned tags.
//
// If you want your private pseudo tags ``registered''
// (i.e. added to this file), send mail to sam@sgi.com
// with the appropriate C definitions to add.
//
#define TIFFTAG_FAXMODE                 65536   // Group 3/4 format control
#define     FAXMODE_CLASSIC     0x0000          // default, include RTC
#define     FAXMODE_NORTC       0x0001          // no RTC at end of data
#define     FAXMODE_NOEOL       0x0002          // no EOL code at end of row
#define     FAXMODE_BYTEALIGN   0x0004          // byte align row
#define     FAXMODE_WORDALIGN   0x0008          // word align row
#define     FAXMODE_CLASSF      FAXMODE_NORTC   // TIFF Class F
#define TIFFTAG_JPEGQUALITY             65537   // Compression quality level
//
// Note: quality level is on the IJG 0-100 scale.  Default value is 75
//
#define TIFFTAG_JPEGCOLORMODE           65538   // Auto RGB<=>YCbCr convert?
#define     JPEGCOLORMODE_RAW   0x0000          // no conversion (default)
#define     JPEGCOLORMODE_RGB   0x0001          // do auto conversion
#define TIFFTAG_JPEGTABLESMODE          65539   // What to put in JPEGTables
#define     JPEGTABLESMODE_QUANT 0x0001         // include quantization tbls
#define     JPEGTABLESMODE_HUFF 0x0002          // include Huffman tbls
//
// Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF
//
#define TIFFTAG_FAXFILLFUNC             65540   // G3/G4 fill function
#define TIFFTAG_PIXARLOGDATAFMT         65549   // PixarLogCodec I/O data sz
#define     PIXARLOGDATAFMT_8BIT        0       // regular u_char samples
#define     PIXARLOGDATAFMT_8BITABGR    1       // ABGR-order u_chars
#define     PIXARLOGDATAFMT_10BITLOG    2       // 10-bit log-encoded (raw)
#define     PIXARLOGDATAFMT_12BITPICIO  3       // as per PICIO (1.0==2048)
#define     PIXARLOGDATAFMT_16BIT       4       // signed short samples
#define     PIXARLOGDATAFMT_FLOAT       5       // IEEE float samples

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\perfmon\fxscount.h ===
//
//  fxscount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\perfmon\faxperf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxperf.cpp

Abstract:

    This module contains the fax perfom dll code.

Author:

    Wesley Witt (wesw) 22-Aug-1996

--*/

#include <windows.h>
#include <winperf.h>

#include "fxscount.h"
#include "faxperf.h"
#include "faxreg.h"
#include "faxutil.h"



#define FAX_NUM_PERF_OBJECT_TYPES           1
#define COUNTER_SIZE                        sizeof(DWORD)


#define INBOUND_BYTES_OFFSET                (COUNTER_SIZE                                     )  //   1
#define INBOUND_FAXES_OFFSET                (INBOUND_BYTES_OFFSET               + COUNTER_SIZE)  //   2
#define INBOUND_PAGES_OFFSET                (INBOUND_FAXES_OFFSET               + COUNTER_SIZE)  //   3
#define INBOUND_MINUTES_OFFSET              (INBOUND_PAGES_OFFSET               + COUNTER_SIZE)  //   4
#define INBOUND_FAILED_RECEIVE_OFFSET       (INBOUND_MINUTES_OFFSET             + COUNTER_SIZE)  //   5
#define OUTBOUND_BYTES_OFFSET               (INBOUND_FAILED_RECEIVE_OFFSET      + COUNTER_SIZE)  //   6
#define OUTBOUND_FAXES_OFFSET               (OUTBOUND_BYTES_OFFSET              + COUNTER_SIZE)  //   7
#define OUTBOUND_PAGES_OFFSET               (OUTBOUND_FAXES_OFFSET              + COUNTER_SIZE)  //   8
#define OUTBOUND_MINUTES_OFFSET             (OUTBOUND_PAGES_OFFSET              + COUNTER_SIZE)  //   9
#define OUTBOUND_FAILED_CONNECTIONS_OFFSET  (OUTBOUND_MINUTES_OFFSET            + COUNTER_SIZE)  //  10
#define OUTBOUND_FAILED_XMIT_OFFSET         (OUTBOUND_FAILED_CONNECTIONS_OFFSET + COUNTER_SIZE)  //  11
#define TOTAL_BYTES_OFFSET                  (OUTBOUND_FAILED_XMIT_OFFSET        + COUNTER_SIZE)  //  12
#define TOTAL_FAXES_OFFSET                  (TOTAL_BYTES_OFFSET                 + COUNTER_SIZE)  //  13
#define TOTAL_PAGES_OFFSET                  (TOTAL_FAXES_OFFSET                 + COUNTER_SIZE)  //  14
#define TOTAL_MINUTES_OFFSET                (TOTAL_PAGES_OFFSET                 + COUNTER_SIZE)  //  15
#define LAST_COUNTER_OFFSET                 (TOTAL_MINUTES_OFFSET               + COUNTER_SIZE)  //

#define SIZE_OF_FAX_PERFORMANCE_DATA        LAST_COUNTER_OFFSET

#define PERF_COUNTER_DEFINITION(nm,ty)   \
    {                                    \
        sizeof(PERF_COUNTER_DEFINITION), \
        nm,                              \
        0,                               \
        nm,                              \
        0,                               \
        0,                               \
        PERF_DETAIL_NOVICE,              \
        ty,                              \
        COUNTER_SIZE,                    \
        nm##_OFFSET                      \
    }

#define PERF_COUNTER_INC(nm) \
    gs_FaxDataDefinition.nm##.CounterNameTitleIndex += dwFirstCounter; \
    gs_FaxDataDefinition.nm##.CounterHelpTitleIndex += dwFirstHelp


#pragma pack (4)

typedef struct _FAX_DATA_DEFINITION {
    PERF_OBJECT_TYPE            FaxObjectType;
    PERF_COUNTER_DEFINITION     InboundBytes;
    PERF_COUNTER_DEFINITION     InboundFaxes;
    PERF_COUNTER_DEFINITION     InboundPages;
    PERF_COUNTER_DEFINITION     InboundMinutes;
    PERF_COUNTER_DEFINITION     InboundFailedReceive;
    PERF_COUNTER_DEFINITION     OutboundBytes;
    PERF_COUNTER_DEFINITION     OutboundFaxes;
    PERF_COUNTER_DEFINITION     OutboundPages;
    PERF_COUNTER_DEFINITION     OutboundMinutes;
    PERF_COUNTER_DEFINITION     OutboundFailedConnections;
    PERF_COUNTER_DEFINITION     OutboundFailedXmit;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     TotalFaxes;
    PERF_COUNTER_DEFINITION     TotalPages;
    PERF_COUNTER_DEFINITION     TotalMinutes;
} FAX_DATA_DEFINITION, *PFAX_DATA_DEFINITION;

#pragma pack ()


static FAX_DATA_DEFINITION gs_FaxDataDefinition = {
    {
        sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA,
        sizeof(FAX_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        FAXOBJ,
        0,
        FAXOBJ,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(FAX_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/sizeof(PERF_COUNTER_DEFINITION),
        0,
        PERF_NO_INSTANCES,
        0,
    },

    PERF_COUNTER_DEFINITION( INBOUND_BYTES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAXES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_PAGES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_MINUTES,                    PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAILED_RECEIVE,             PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_BYTES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAXES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_PAGES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_MINUTES,                   PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_CONNECTIONS,        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_XMIT,               PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_BYTES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_FAXES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_PAGES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_MINUTES,                      PERF_COUNTER_RAWCOUNT  )

};

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

WCHAR GLOBAL_STRING[]  = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[]  = L"Costly";
WCHAR NULL_STRING[]    = L"\0";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)




static DWORD gs_dwOpenCount = 0;
static BOOL gs_bInitOK = FALSE;
static HANDLE gs_hMap = NULL;
static PFAX_PERF_COUNTERS gs_pPerfCounters = NULL;


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0)
    {
        return QUERY_GLOBAL;
    }
    else if (*lpValue == 0)
    {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE)
    {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter))
        {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem)
                {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber)
                {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber)
                {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0)
                {
                    return FALSE;
                }
                else
                {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

DWORD APIENTRY
OpenFaxPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the Fax Service to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened


Return Value:

    None.

--*/

{
    LONG            status;
    HKEY            hKeyDriverPerf = NULL;
    DWORD           size;
    DWORD           type;
    DWORD           dwFirstCounter;
    DWORD           dwFirstHelp;
    DEBUG_FUNCTION_NAME(TEXT("OpenFaxPerformanceData"));

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!gs_dwOpenCount)
    {
        gs_hMap = OpenFileMapping(
            FILE_MAP_READ,
            FALSE,
            FAXPERF_SHARED_MEMORY
            );
        if (NULL == gs_hMap)
        {
            //
            // Maybe the service is down and the memeory mapped file does not exist.
            // Try to create it
            //
            SECURITY_ATTRIBUTES *pSA;
            DWORD Rval;

            pSA = CreateSecurityAttributesWithThreadAsOwner (FILE_MAP_READ, FILE_MAP_READ, FILE_MAP_WRITE);
            if (!pSA)
            {
                Rval = GetLastError ();
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateSecurityAttributesWithThreadAsOwner() failed. (ec: %ld)"),
                        Rval);
            }
            else
            {
                gs_hMap = CreateFileMapping(
                    INVALID_HANDLE_VALUE,
                    pSA,
                    PAGE_READWRITE | SEC_COMMIT,
                    0,
                    sizeof(FAX_PERF_COUNTERS),
                    FAXPERF_SHARED_MEMORY
                    );
                DestroySecurityAttributes (pSA);
            }

            if (NULL == gs_hMap)
            {
                goto OpenExitPoint;
            }
        }

        gs_pPerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
            gs_hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
        if (!gs_pPerfCounters)
        {
            goto OpenExitPoint;
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REGKEY_FAXPERF,
            0L,
            KEY_QUERY_VALUE,
            &hKeyDriverPerf
            );

        if (status != ERROR_SUCCESS)
        {
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Counter",
            0L,
            &type,
            (LPBYTE)&dwFirstCounter,
            &size
            );

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Help",
            0L,
            &type,
            (LPBYTE)&dwFirstHelp,
            &size
            );

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        gs_FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex += dwFirstCounter;
        gs_FaxDataDefinition.FaxObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        PERF_COUNTER_INC( InboundBytes              );
        PERF_COUNTER_INC( InboundFaxes              );
        PERF_COUNTER_INC( InboundPages              );
        PERF_COUNTER_INC( InboundMinutes            );
        PERF_COUNTER_INC( InboundFailedReceive      );
        PERF_COUNTER_INC( OutboundBytes             );
        PERF_COUNTER_INC( OutboundFaxes             );
        PERF_COUNTER_INC( OutboundPages             );
        PERF_COUNTER_INC( OutboundMinutes           );
        PERF_COUNTER_INC( OutboundFailedConnections );
        PERF_COUNTER_INC( OutboundFailedXmit        );
        PERF_COUNTER_INC( TotalBytes                );
        PERF_COUNTER_INC( TotalFaxes                );
        PERF_COUNTER_INC( TotalPages                );
        PERF_COUNTER_INC( TotalMinutes              );

        gs_bInitOK = TRUE; // ok to use this function
    }

    InterlockedIncrement( (PLONG)&gs_dwOpenCount); // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    if (hKeyDriverPerf)
    {
            RegCloseKey (hKeyDriverPerf);
    }

    if (!gs_bInitOK)
    {
        if (gs_pPerfCounters)
        {
            UnmapViewOfFile(gs_pPerfCounters);
        }

        if (gs_hMap)
        {
            CloseHandle( gs_hMap );
        }
    }

    //
    // the performance APIs log an error in eventvwr if you fail this call
    // so we always return ERROR_SUCCESS so we don't clutter the logs
    //
    //return status;
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectFaxPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Fax counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    LPDWORD             pData;
    ULONG               SpaceNeeded;
    DWORD               dwQueryType;

    //
    // before doing anything else, see if Open went OK
    //
    if (!gs_bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if (!(IsNumberInUnicodeList (gs_FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex, lpValueName)))
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS;
        }
    }

    SpaceNeeded = sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    pData = (LPDWORD) *lppData;

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    CopyMemory(
        pData,
        &gs_FaxDataDefinition,
        sizeof(FAX_DATA_DEFINITION)
        );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_DATA_DEFINITION));

    //
    //  Format and collect Fax data from the service
    //

    *pData = SIZE_OF_FAX_PERFORMANCE_DATA;
    pData += 1;

    CopyMemory( pData, gs_pPerfCounters, sizeof(FAX_PERF_COUNTERS) );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_PERF_COUNTERS));

    *lpNumObjectTypes = FAX_NUM_PERF_OBJECT_TYPES;
    *lpcbTotalBytes = (DWORD)((LPBYTE)pData - (LPBYTE)*lppData);
    *lppData = (PVOID) pData;

    return ERROR_SUCCESS;
}


DWORD APIENTRY
CloseFaxPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Fax performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    InterlockedDecrement( (PLONG)&gs_dwOpenCount );

    if ((gs_dwOpenCount == 0) && gs_bInitOK)
    {
        if (gs_pPerfCounters)
        {
            UnmapViewOfFile(gs_pPerfCounters);
            gs_pPerfCounters = NULL;
        }

        if (gs_hMap)
        {
            CloseHandle( gs_hMap );
            gs_hMap = NULL;
        }

        gs_bInitOK = FALSE;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxmon\faxmon.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.h

Abstract:

    Header file for fax print monitor

Environment:

        Windows XP fax print monitor

Revision History:

        02/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXMON_H_
#define _FAXMON_H_

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <tchar.h>
#include "faxutil.h"
#include <fxsapip.h>
#include "jobtag.h"
#include "resource.h"
#include "faxres.h"
#include "Dword2Str.h"

//
// Data structure for representing a fax monitor port
//

typedef struct _FAXPORT {

    PVOID                   startSig;               // signature
    LPTSTR                  pName;                  // port name
    HANDLE                  hFaxSvc;                // fax service handle
    DWORD                   jobId;                  // main job ID
    DWORD                   nextJobId;              // next job ID in the chain
    HANDLE                  hFile;                  // handle to currently open file
    LPTSTR                  pFilename;              // pointer to currently open file name
    LPTSTR                  pPrinterName;           // currently connected printer name
    HANDLE                  hPrinter;               // open handle to currently connected printer
    LPTSTR                  pParameters;            // pointer to job parameter string
    FAX_JOB_PARAM_EX        JobParamsEx;             // pointer to individual job parameters
	//
	FAX_COVERPAGE_INFO_EX   CoverPageEx;			// Cover page information
    FAX_PERSONAL_PROFILE    SenderProfile;          // Sender information
    PFAX_PERSONAL_PROFILE   pRecipients;            // Array of recipient information for this transmission
    UINT                    nRecipientCount;        // The number of recipients in this transmission
	HANDLE					hCoverPageFile;
	LPTSTR					pCoverPageFileName;		// The name of the cover page file generated on the server by the fax monitor.
													// This file contains the cover page template as transfered via the cover page 
    												// print job.
	BOOL					bCoverPageJob;          // TRUE if the current print job is the cover page job.
    PVOID                   endSig;                 // signature

} FAXPORT, *PFAXPORT;

#define ValidFaxPort(pFaxPort) \
        ((pFaxPort) && (pFaxPort) == (pFaxPort)->startSig && (pFaxPort) == (pFaxPort)->endSig)

//
// Different error code when sending fax document
//

#define FAXERR_NONE         0
#define FAXERR_IGNORE       1
#define FAXERR_RESTART      2
#define FAXERR_SPECIAL      3

#define FAXERR_FATAL        IDS_FAXERR_FATAL
#define FAXERR_RECOVERABLE  IDS_FAXERR_RECOVERABLE
#define FAXERR_BAD_TIFF     IDS_FAXERR_BAD_TIFF
#define FAXERR_BAD_DATA16   IDS_FAXERR_BAD_DATA16

//
// Memory allocation and deallocation macros
//

//
// undefine the memory allocation routines from FAXUTIL.H
//
#undef MemAlloc
#undef MemFree

#define MemAlloc(size)  ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size) ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(ptr)    { if (ptr) LocalFree((HLOCAL) (ptr)); }

//
// Number of tags used for passing fax job parameters
//

#define NUM_JOBPARAM_TAGS 12

//
// Nul terminator for a character string
//

#define NUL             0

//
// Result of string comparison
//

#define EQUAL_STRING    0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define IsNulChar(c)        ((c) == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif


//
// Declaration of print monitor entry points
//

BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    );

BOOL
FaxMonClosePort(
    HANDLE  hPort
    );

BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    );

BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    );

BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    );

BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    );

BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    );

//
// Get the list of fax devices from the service
//

PFAX_PORT_INFO
MyFaxEnumPorts(
    LPDWORD pcPorts,
    BOOL    useCache
    );

//
// Wrapper function for fax service's FaxGetPort API
//

PFAX_PORT_INFO
MyFaxGetPort(
    LPTSTR  pPortName,
    BOOL    useCache
    );

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );


//
// Wrapper function for spooler API GetJob
//

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    );

//
// Create a temporary file in the system spool directory for storing fax data
//

LPTSTR
CreateTempFaxFile(
    LPCTSTR lpctstrPrefix
    );

//
// Open a handle to the current fax job file associated with a port
//

BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    );


#endif // !_FAXMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxmon\faxmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.c

Abstract:

    Implementation of the following print monitor entry points:
        InitializePrintMonitor
        OpenPort
        ClosePort
        StartDocPort
        EndDocPort
        WritePort
        ReadPort

Environment:

    Windows XP fax print monitor

Revision History:

    05/09/96 -davidx-
        Remove caching of ports from the monitor.

    02/22/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxmon.h"
#include "tiff.h"
#include "faxreg.h"
#include "faxext.h"
#include "faxsvcrg.h"
#include "faxevent.h"
#include "faxevent_messages.h"
#include "FaxRpcLimit.h"

//
// tag mapping structure for getting job parameters out of parameter string.
// see GetTagsFromParam().
//
typedef struct 
{
    LPTSTR lptstrTagName;
    LPTSTR * lpptstrValue;
    int nLen;
} FAX_TAG_MAP_ENTRY2;

//
// Fax monitor name string
//
TCHAR   faxMonitorName[CCHDEVICENAME] = FAX_MONITOR_NAME;   // Name defined in faxreg.h

//
// DLL instance handle
//
HINSTANCE g_hInstance = NULL;
HINSTANCE g_hResource = NULL;

BOOL
WriteToLog(
    IN  DWORD       dwMsgId,
    IN  DWORD       dwError,
    IN  PFAXPORT    pFaxPort,
    IN  JOB_INFO_2  *pJobInfo
    );


BOOL
WINAPI
DllMain(
    HINSTANCE   hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hModule);
            g_hInstance = hModule;
            g_hResource = GetResInstance(hModule);
            if(!g_hResource)
            {
                return FALSE;
            }
            FXSEVENTInitialize();
            break;

        case DLL_PROCESS_DETACH:
            FXSEVENTFree();
            HeapCleanup();
            FreeResInstance();
            break;
    }
    return TRUE;
}


LPMONITOREX
InitializePrintMonitor(
    LPTSTR  pRegistryRoot
    )

/*++

Routine Description:

    Initialize the print monitor

Arguments:

    pRegistryRoot = Points to a string that specifies the registry root for the monitor

Return Value:

    Pointer to a MONITOREX structure which contains function pointers
    to other print monitor entry points. NULL if there is an error.

--*/

{
    static MONITOREX faxmonFuncs = 
    {
        sizeof(MONITOR),
        {
            FaxMonEnumPorts,        // EnumPorts    
            FaxMonOpenPort,         // OpenPort     
            NULL,                   // OpenPortEx    (Language monitors only.) 
            FaxMonStartDocPort,     // StartDocPort 
            FaxMonWritePort,        // WritePort    
            FaxMonReadPort,         // ReadPort      (Not in use)
            FaxMonEndDocPort,       // EndDocPort   
            FaxMonClosePort,        // ClosePort    
            FaxMonAddPort,          // AddPort       (Obsolete. Should be NULL.) 
            FaxMonAddPortEx,        // AddPortEx     (Obsolete. Should be NULL.)
            FaxMonConfigurePort,    // ConfigurePort (Obsolete. Should be NULL.)
            FaxMonDeletePort,       // DeletePort    (Obsolete. Should be NULL.)
            NULL,                   // GetPrinterDataFromPort
            NULL,                   // SetPortTimeOuts
            NULL,                   // XcvOpenPort
            NULL,                   // XcvDataPort
            NULL                    // XcvClosePort
        }
    };


    BOOL bRes = TRUE;
    PREG_FAX_SERVICE pFaxReg = NULL;

    DEBUG_FUNCTION_NAME(TEXT("InitializePrintMonitor"));

    //
    //  Initialize Fax Event Log
    //
    if (!InitializeEventLog(&pFaxReg))
    {
        bRes = FALSE;
        DebugPrintEx(DEBUG_ERR, _T("InitializeEventLog() failed: %ld"), GetLastError());
    }

    FreeFaxRegistry(pFaxReg);

    return bRes ? &faxmonFuncs : NULL;
}

BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    )
/*++

Routine Description:

    Provides a port for a newly connected printer

Arguments:

    pName - Points to a string that specifies the port name
    pHandle - Returns a handle to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PFAXPORT         pFaxPort     = NULL;
    LPTSTR           pPortNameDup = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxMonOpenPort"));

    Assert(pHandle != NULL && pPortName != NULL && !lstrcmp(pPortName, FAX_PORT_NAME));
    //
    // Only support one port - It's name must be FAX_PORT_NAME
    //
    if (lstrcmp(pPortName,FAX_PORT_NAME))
    {
        *pHandle = NULL;
        return FALSE;
    }
    //
    // Get information about the specified port
    //
    if ((pFaxPort     = (PFAXPORT)MemAllocZ(sizeof(FAXPORT))) &&
        (pPortNameDup = DuplicateString(FAX_PORT_NAME)) )
    {
        pFaxPort->startSig = pFaxPort->endSig = pFaxPort;
        pFaxPort->pName = pPortNameDup;
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
        pFaxPort->hCoverPageFile = INVALID_HANDLE_VALUE;
        pFaxPort->pCoverPageFileName=NULL;        
    } 
    else 
    {
        MemFree(pFaxPort);
        pFaxPort = NULL;
    }
    *pHandle = (HANDLE) pFaxPort;
    return (*pHandle != NULL);
}   // FaxMonOpenPort


VOID
FreeFaxJobInfo(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Free up memory used for maintaining information about the current job

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    NONE

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FreeFaxJobInfo"));
    //
    // Close and delete the temporary file if necessary
    //
    if (pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(pFaxPort->hCoverPageFile);
        pFaxPort->hCoverPageFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->pCoverPageFileName) 
    {
        //
        // If the cover page is a server based cover page it was not generated by the print monitor.
        // No need to delete it.
        // This however is a personal cover page temp file. It was generated by the print monitor and we
        // need to delete it.
        //        
        if (!DeleteFile(pFaxPort->pCoverPageFileName)) 
        {
            DebugPrintEx(DEBUG_WRN,
                            TEXT("Failed to delete cover page file: %s  (ec: %ld)"),
                            pFaxPort->pCoverPageFileName,
                            GetLastError());            
        }        
        MemFree(pFaxPort->pCoverPageFileName);
        pFaxPort->pCoverPageFileName = NULL;
    }

    if (pFaxPort->hFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->pFilename) 
    {
        if (!DeleteFile(pFaxPort->pFilename)) 
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Failed to delete body file: %s  (ec: %ld)"),
                         pFaxPort->pFilename,
                         GetLastError());            
        }
        MemFree(pFaxPort->pFilename);
        pFaxPort->pFilename = NULL;
    }

    if (pFaxPort->hPrinter) 
    {
        ClosePrinter(pFaxPort->hPrinter);
        pFaxPort->hPrinter = NULL;
    }

    MemFree(pFaxPort->pPrinterName);
    pFaxPort->pPrinterName = NULL;
    //
    // Note: freeing pFaxPort->pParameters effectively frees the memory pointed by the strings in
    // FAXPORT.JobParamsEx, FAXPORT.CoverPageEx, FAXPORT.SenderProfile and the recipients in
    // FAXPORT.pRecipients
    //
    MemFree(pFaxPort->pParameters);
    pFaxPort->pParameters = NULL;

    ZeroMemory(&pFaxPort->JobParamsEx, sizeof(pFaxPort->JobParamsEx));
    ZeroMemory(&pFaxPort->CoverPageEx, sizeof(pFaxPort->CoverPageEx));
    ZeroMemory(&pFaxPort->SenderProfile, sizeof(pFaxPort->SenderProfile));
    //
    // Free the recipients array
    //
    MemFree(pFaxPort->pRecipients);
    pFaxPort->pRecipients = NULL;
    //
    // Disconnect from the fax service if necessary
    //
    if (pFaxPort->hFaxSvc) 
    {
        if (!FaxClose(pFaxPort->hFaxSvc)) 
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxClose failed: %d\n"), 
                         GetLastError());
        }
        pFaxPort->hFaxSvc = NULL;
    }
}   // FreeFaxJobInfo


BOOL
FaxMonClosePort(
    HANDLE  hPort
    )
/*++

Routine Description:

    Closes the port specified by hPort when there are no printers connected to it

Arguments:

    hPort - Specifies the handle of the port to be close

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;

    DEBUG_FUNCTION_NAME(TEXT("FaxMonClosePort"));
    DEBUG_TRACE_ENTER;
    //
    // Make sure we have a valid handle
    //
    if (! ValidFaxPort(pFaxPort)) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Trying to close an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    //
    // Free up memory used for maintaining information about the current job
    //
    FreeFaxJobInfo(pFaxPort);
    MemFree(pFaxPort->pName);
    MemFree(pFaxPort);
    return TRUE;
}   // FaxMonClosePort

LPTSTR
CreateTempFaxFile(
    LPCTSTR lpctstrPrefix
    )
/*++

Routine Description:

    Create a temporary file in the system temp directory. The file name is prefixed
    With the specified prefix.

Arguments:

    lpctstrPrefix - [in] The temporary file prefix (3 characters).

Return Value:

    Pointer to the name of the newly created temporary file
    NULL if there is an error.

    Caller should free the return value.

--*/

{
    LPTSTR  pFilename;
    DWORD   dwRes;
    TCHAR   TempDir[MAX_PATH];

    DEBUG_FUNCTION_NAME(TEXT("CreateTempFaxFile"));
    //
    // Allocate a memory buffer for holding the temporary filename 
    //
    pFilename = (LPTSTR)MemAlloc(sizeof(TCHAR) * MAX_PATH);
    if (!pFilename)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate %ld bytes"),
                     sizeof(TCHAR) * MAX_PATH);
        return NULL;
    }
    dwRes = GetTempPath(sizeof(TempDir)/sizeof(TCHAR),TempDir);
    if (!dwRes || dwRes > sizeof(TempDir)/sizeof(TCHAR))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetTempPath failed with %ld"),
                     GetLastError ());
        MemFree(pFilename);
        return NULL;
    }

    if (!GetTempFileName(TempDir, lpctstrPrefix, 0, pFilename))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetTempFileName failed with %ld"),
                     GetLastError ());
        MemFree(pFilename);
        return NULL;
    }
    return pFilename;
}   // CreateTempFaxFile

BOOL OpenCoverPageFile(PFAXPORT pFaxPort)
{
    DEBUG_FUNCTION_NAME(TEXT("OpenCoverPageFile"));
    //
    //Generate a unique file name for the cover page temp file in the TEMP directory
    //
    pFaxPort->pCoverPageFileName = CreateTempFaxFile(FAX_COVER_PAGE_EXT_LETTERS);
    if (!pFaxPort->pCoverPageFileName) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate temporary file for cover page template (ec: %d).\n"),GetLastError());
        return FALSE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Cover page temporary file: %ws\n"), pFaxPort->pCoverPageFileName);
    //
    // Open the file for reading and writing
    //
    pFaxPort->hCoverPageFile = CreateFile(pFaxPort->pCoverPageFileName,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
    if (INVALID_HANDLE_VALUE == pFaxPort->hCoverPageFile) 
    {
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to open for WRITE temporary file for cover page template (ec: %d)"),GetLastError());			
    }
    return (pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE);
}   // OpenCoverPageFile

BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    )
/*++

Routine Description:

    Open a handle to the current fax job file associated with a port

Arguments:

    pFaxPort - Points to a fax port structure
    doAppend - Specifies whether to discard existing data in the file or
        append new data to it

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   creationFlags;

    DEBUG_FUNCTION_NAME(TEXT("OpenTempFaxFile"));

    Assert(pFaxPort->pFilename && pFaxPort->hFile == INVALID_HANDLE_VALUE);
    DebugPrintEx(DEBUG_MSG,TEXT("Temporary fax job file: %ws\n"), pFaxPort->pFilename);
    //
    // Open the file for reading and writing
    //
    creationFlags = doAppend ? OPEN_ALWAYS : (OPEN_ALWAYS | TRUNCATE_EXISTING);

    pFaxPort->hFile = CreateFile(pFaxPort->pFilename,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 NULL,
                                 creationFlags,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    //
    // If we're appending, then move the file pointer to end of file
    //
    if (doAppend && pFaxPort->hFile != INVALID_HANDLE_VALUE &&
        SetFilePointer(pFaxPort->hFile, 0, NULL, FILE_END) == 0xffffffff)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SetFilePointer failed: %d\n"), GetLastError());

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }
    return (pFaxPort->hFile != INVALID_HANDLE_VALUE);
}   // OpenTempFaxFile

LPCTSTR
ExtractFaxTag(
    LPCTSTR      pTagKeyword,
    LPCTSTR      pTaggedStr,
    INT        *pcch
    )

/*++

Routine Description:

    Find the value of for the specified tag in a tagged string.

Arguments:

    pTagKeyword - specifies the interested tag keyword
    pTaggedStr - points to the tagged string to be searched
    pcch - returns the length of the specified tag value (if found)

Return Value:

    Points to the value for the specified tag.
    NULL if the specified tag is not found

NOTE:

    Tagged strings have the following form:
        <tag>value<tag>value

    The format of tags is defined as:
        <$FAXTAG$ tag-name>

    There is exactly one space between the tag keyword and the tag name.
    Characters in a tag are case-sensitive.

--*/

{
    LPCTSTR  pValue;

    if (pValue = _tcsstr(pTaggedStr, pTagKeyword)) 
    {
        pValue += _tcslen(pTagKeyword);

        if (pTaggedStr = _tcsstr(pValue, FAXTAG_PREFIX))
        {
            *pcch = (INT)(pTaggedStr - pValue);
        }
        else
        {
            *pcch = _tcslen(pValue);
        }
    }
    return pValue;
}   // ExtractFaxTag


//*********************************************************************************
//* Name:   GetTagsFromParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Given a tagged parameter string this function populates a FAX_TAG_MAP_ENTRY2
//*     array with pointers to each of the tag values and the length of each tag
//*     value (for those tages specified in the tag map array).
//* PARAMETERS:
//*     lpctstrParams
//*         A pointer to the string containin the tagged parameters.
//*     lpcTags
//*         A pointer to a FAX_TAG_MAP_ENTRY2 array. For each element in the array
//*         FAX_TAG_MAP_ENTRY2.lptstrTagName must point to the name of the tag to
//*         look for.
//*         FAX_TAG_MAP_ENTRY2.lpptstrValue will be set to a pointer to the first
//*         char of the value string or NULL if the tag is not found.
//*         If the tage is found FAX_TAG_MAP_ENTRY2.nLen will be set to the its
//*         string value length. Otherwise its value is not defined.
//*
//*     int nTagCount
//*         The number of tages in the tag map array.
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     The function does not allocate any memory !!!
//*     It returns pointers to substrings in the provided tagged paramter string.
//*********************************************************************************
void
GetTagsFromParam(
    LPCTSTR lpctstrParams,
    FAX_TAG_MAP_ENTRY2 * lpcTags,
    int nTagCount)
{
    //
    // Note: GetTagsFromParam DOES NOT ALLOCATE any memory for the returned tag values.
    //       It returns pointers to location within the parameter string.
    //       Thus, freeing the parameter string (deallocated when the port is closed)
    //       is enough. DO NOT attempt to free the memory for each tag.
    //
    int nTag;
    //
    // Extract individual fields out of the tagged string
    //
    for (nTag=0; nTag < nTagCount; nTag++)
    {
        *(lpcTags[nTag].lpptstrValue) = (LPTSTR)ExtractFaxTag(lpcTags[nTag].lptstrTagName,
                                         lpctstrParams,
                                         &(lpcTags[nTag].nLen));
    }
    //
    // Null-terminate each field
    //
    for (nTag=0; nTag < nTagCount; nTag++)
    {
        if (*(lpcTags[nTag].lpptstrValue))
        {
            (*(lpcTags[nTag].lpptstrValue))[lpcTags[nTag].nLen] = NUL;
        }
    }
}   // GetTagsFromParam

//*********************************************************************************
//* Name:   SetRecipientFromTaggedParams()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Populates a recipient FAX_PERSONAL_PROFILE with pointers to relevant
//*     information in in the provided tagged parameter string.
//* PARAMETERS:
//*     pParamStr
//*
//*     PFAX_PERSONAL_PROFILE lpProfile
//*
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     This function does not allocate memory !!!
//*     The returned pointers are pointed to locations within the provided
//*     pParamStr string.
//*********************************************************************************
VOID SetRecipientFromTaggedParams(
    LPCTSTR pParamStr,
    PFAX_PERSONAL_PROFILE lpProfile)
{
    FAX_TAG_MAP_ENTRY2 tagMap[] =
    {
        { FAXTAG_RECIPIENT_NAME,            (LPTSTR *)&lpProfile->lptstrName},
        { FAXTAG_RECIPIENT_NUMBER,          (LPTSTR *)&lpProfile->lptstrFaxNumber },
        { FAXTAG_RECIPIENT_COMPANY,         (LPTSTR *)&lpProfile->lptstrCompany },
        { FAXTAG_RECIPIENT_STREET,          (LPTSTR *)&lpProfile->lptstrStreetAddress },
        { FAXTAG_RECIPIENT_CITY,            (LPTSTR *)&lpProfile->lptstrCity },
        { FAXTAG_RECIPIENT_STATE,           (LPTSTR *)&lpProfile->lptstrState },
        { FAXTAG_RECIPIENT_ZIP,             (LPTSTR *)&lpProfile->lptstrZip },
        { FAXTAG_RECIPIENT_COUNTRY,         (LPTSTR *)&lpProfile->lptstrCountry },
        { FAXTAG_RECIPIENT_TITLE,           (LPTSTR *)&lpProfile->lptstrTitle },
        { FAXTAG_RECIPIENT_DEPT,            (LPTSTR *)&lpProfile->lptstrDepartment },
        { FAXTAG_RECIPIENT_OFFICE_LOCATION, (LPTSTR *)&lpProfile->lptstrOfficeLocation },
        { FAXTAG_RECIPIENT_HOME_PHONE,      (LPTSTR *)&lpProfile->lptstrHomePhone },
        { FAXTAG_RECIPIENT_OFFICE_PHONE,    (LPTSTR *)&lpProfile->lptstrOfficePhone },
    };

    ZeroMemory(lpProfile, sizeof(FAX_PERSONAL_PROFILE));
    lpProfile->dwSizeOfStruct = sizeof( FAX_PERSONAL_PROFILE);
    GetTagsFromParam(pParamStr, tagMap, sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY2));
}   // SetRecipientFromTaggedParams


//*********************************************************************************
//* Name:   SetJobInfoFromTaggedParams()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Popultaes pFaxPort->JobParamsEx, CoverPageEx , SenderProfile and
//*     nRecipientCount using the provided tagged parameter string.
//*     The string must be NULL terminated.
//* PARAMETERS:
//*     LPCTSTR pParamStr [IN\OUT]
//*
//*     PFAXPORT pFaxPort [OUT]
//*
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     The string pointers put into the populated pFaxPort structures are pointers
//*     into the provided pParamStr string. No memory is allocated by this
//*     function !!!
//*********************************************************************************
void SetJobInfoFromTaggedParams(
    LPCTSTR pParamStr,
    PFAXPORT pFaxPort)
{
    LPTSTR lptstrServerCoverPage = NULL;
    LPTSTR WhenToSend = NULL;
    LPTSTR SendAtTime = NULL;
    LPTSTR lptstrPageCount=NULL; //temp for holding the page count string;
    LPTSTR lptstrRecipientCount=NULL;
    LPTSTR lptstrReceiptFlags = NULL;
    LPTSTR lptstrPriority = NULL;

    FAX_TAG_MAP_ENTRY2 tagMap[] =
    {
        { FAXTAG_SENDER_NAME,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrName},
        { FAXTAG_SENDER_NUMBER,             (LPTSTR *)&pFaxPort->SenderProfile.lptstrFaxNumber },
        { FAXTAG_SENDER_COMPANY,            (LPTSTR *)&pFaxPort->SenderProfile.lptstrCompany },
        { FAXTAG_SENDER_TITLE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrTitle },
        { FAXTAG_SENDER_DEPT,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrDepartment },
        { FAXTAG_SENDER_OFFICE_LOCATION,    (LPTSTR *)&pFaxPort->SenderProfile.lptstrOfficeLocation },
        { FAXTAG_SENDER_HOME_PHONE,         (LPTSTR *)&pFaxPort->SenderProfile.lptstrHomePhone },
        { FAXTAG_SENDER_OFFICE_PHONE,       (LPTSTR *)&pFaxPort->SenderProfile.lptstrOfficePhone },
        { FAXTAG_SENDER_STREET,             (LPTSTR *)&pFaxPort->SenderProfile.lptstrStreetAddress },
        { FAXTAG_SENDER_CITY,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrCity },
        { FAXTAG_SENDER_STATE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrState },
        { FAXTAG_SENDER_ZIP,                (LPTSTR *)&pFaxPort->SenderProfile.lptstrZip },
        { FAXTAG_SENDER_COUNTRY,            (LPTSTR *)&pFaxPort->SenderProfile.lptstrCountry },
        { FAXTAG_SENDER_EMAIL,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrEmail },
        { FAXTAG_TSID,                      (LPTSTR *)&pFaxPort->SenderProfile.lptstrTSID },
        { FAXTAG_BILLING_CODE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrBillingCode},
        { FAXTAG_COVERPAGE_NAME,            (LPTSTR *)&pFaxPort->CoverPageEx.lptstrCoverPageFileName },
        { FAXTAG_SERVER_COVERPAGE,          (LPTSTR *)&lptstrServerCoverPage },
        { FAXTAG_NOTE,                      (LPTSTR *)&pFaxPort->CoverPageEx.lptstrNote },
        { FAXTAG_SUBJECT,                   (LPTSTR *)&pFaxPort->CoverPageEx.lptstrSubject},
        { FAXTAG_WHEN_TO_SEND,              (LPTSTR *)&WhenToSend },
        { FAXTAG_SEND_AT_TIME,              (LPTSTR *)&SendAtTime },
        { FAXTAG_PAGE_COUNT,                (LPTSTR *)&lptstrPageCount },
        { FAXTAG_RECEIPT_TYPE,              (LPTSTR *)&lptstrReceiptFlags},
        { FAXTAG_RECEIPT_ADDR,              (LPTSTR *)&pFaxPort->JobParamsEx.lptstrReceiptDeliveryAddress},
        { FAXTAG_PRIORITY,                  (LPTSTR *)&lptstrPriority},
        { FAXTAG_RECIPIENT_COUNT,           (LPTSTR *)&lptstrRecipientCount}
    };

    ZeroMemory(&pFaxPort->SenderProfile, sizeof(FAX_PERSONAL_PROFILE));
    pFaxPort->SenderProfile.dwSizeOfStruct = sizeof( FAX_PERSONAL_PROFILE);

    ZeroMemory(&pFaxPort->CoverPageEx, sizeof(FAX_COVERPAGE_INFO_EXW));
    pFaxPort->CoverPageEx.dwSizeOfStruct = sizeof( FAX_COVERPAGE_INFO_EXW);

    ZeroMemory(&pFaxPort->JobParamsEx, sizeof(FAX_JOB_PARAM_EXW));
    pFaxPort->JobParamsEx.dwSizeOfStruct = sizeof( FAX_JOB_PARAM_EXW);
    //
    // Note: GetTagsFromParam DOES NOT ALLOCATE any memory for the returned tag values.
    //       It returns pointers to location within the parameter string.
    //       Thus, freeing the parameter string (deallocated when the port is closed)
    //       is enough. DO NOT attempt to free the memory for each tag.
    //

    GetTagsFromParam(pParamStr,tagMap,sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY2));
    if (lptstrServerCoverPage) 
    {
        pFaxPort->CoverPageEx.bServerBased=TRUE;
    }
    else 
    {
        pFaxPort->CoverPageEx.bServerBased=FALSE;
    }
    pFaxPort->CoverPageEx.dwCoverPageFormat=FAX_COVERPAGE_FMT_COV;

    if (WhenToSend) 
    {
        if (_tcsicmp( WhenToSend, TEXT("cheap") ) == 0) 
        {
            pFaxPort->JobParamsEx.dwScheduleAction = JSA_DISCOUNT_PERIOD;
        } 
        else if (_tcsicmp( WhenToSend, TEXT("at") ) == 0) 
        {
            pFaxPort->JobParamsEx.dwScheduleAction = JSA_SPECIFIC_TIME;
        }
    }

    if (SendAtTime) 
    {
        if (_tcslen(SendAtTime) == 5 && SendAtTime[2] == L':' &&
            _istdigit(SendAtTime[0]) && _istdigit(SendAtTime[1]) &&
            _istdigit(SendAtTime[3]) && _istdigit(SendAtTime[4]))
        {
            DWORDLONG FileTime;
            SYSTEMTIME LocalTime;
            INT Minutes;
            INT SendMinutes;

            SendAtTime[2] = 0;
            //
            // Calculate the number of minutes from now to send and add that to the current time.
            //
            GetLocalTime( &LocalTime );
            SystemTimeToFileTime( &LocalTime, (LPFILETIME) &FileTime );

            SendMinutes = min(23,_ttoi( &SendAtTime[0] )) * 60 + min(59,_ttoi( &SendAtTime[3] ));

            Minutes = LocalTime.wHour * 60 + LocalTime.wMinute;

            Minutes = SendMinutes - Minutes;
            //
            // Account for passing midnight
            //
            if (Minutes < 0) 
            {
                Minutes += 24 * 60;
            }
            FileTime += (DWORDLONG)(Minutes * 60I64 * 1000I64 * 1000I64 * 10I64);
            FileTimeToSystemTime((LPFILETIME) &FileTime, &pFaxPort->JobParamsEx.tmSchedule );
        }
    }
    //
    // Setting PageCount=0 means the server will count the number of pages in the job
    //
    pFaxPort->JobParamsEx.dwPageCount = 0;
    pFaxPort->nRecipientCount =_ttoi(lptstrRecipientCount);
    pFaxPort->JobParamsEx.Priority = (FAX_ENUM_PRIORITY_TYPE)_ttoi(lptstrPriority);
    pFaxPort->JobParamsEx.dwReceiptDeliveryType = _ttoi(lptstrReceiptFlags);
}   // SetJobInfoFromTaggedParams



//*********************************************************************************
//* Name:   GetJobInfo()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Popultes the sender information , cover page information ,job parameters
//*     information and recipients information in the pointed FAXPORT structure.
//*     The information is retrieved from pFaxPort->pParameters tagged parameter string.
//* PARAMETERS:
//*     pFaxPort [OUT]
//*
//*     jobId    [IN]
//*
//* RETURN VALUE:
//*
//* Notes:
//* the format of the tagged parameter string is:
//* The string is partitioned to "records" each record starts with the <$FAXTAG NEWREC>
//* tag with a dummy value of "1" (exactly one character).
//* The first record contains all the information which is not recipient related
//* (cover page, sender info, etc.) and also contains the number of recipients in
//* the transmission.
//* This record is followed by a number of records which is equal to the number
//* of specified recipients. Rach of these records contains recipient information
//* which is equivalent to the content of FAX_PERSONAL_PROFILE.
//*********************************************************************************
BOOL
GetJobInfo(
    PFAXPORT    pFaxPort,
    DWORD       jobId
    )
{
    JOB_INFO_2 *pJobInfo2 = NULL;
    LPTSTR      pParameters = NULL;
    LPTSTR       lptstrCurRecipient = NULL;
    LPTSTR       lptstrNextRecipient = NULL;
    UINT nRecp;

    DEBUG_FUNCTION_NAME(TEXT("GetJobInfo"));

    pJobInfo2 = (PJOB_INFO_2)MyGetJob(pFaxPort->hPrinter, 2, jobId);

    if (!pJobInfo2) 
    { // pJobInfo2 is allocated here
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to get job information for print job: %ld"),
                     jobId);
        goto Error;
    }

    if (!pJobInfo2->pParameters) 
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Print job %ld has NULL tagged parameter string. No op."),
                     jobId);
        goto Error;
    }

    if ((pFaxPort->pParameters = DuplicateString(pJobInfo2->pParameters)) == NULL)
    {
        DebugPrintEx(DEBUG_ERR, 
                     _T("DuplicateString(pJobInfo2->pParameters) failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    pParameters = pFaxPort->pParameters;

    //
    // Find the first recipient new record tag and place a NULL at its start.
    // This makes the first record into a NULL terminated string and
    // allows us to use _tcsstr (used by ExtractTag) to locate tags in the first record.
    //
    lptstrCurRecipient=_tcsstr(pParameters+1, FAXTAG_NEW_RECORD);
    if (lptstrCurRecipient) 
    {
        *lptstrCurRecipient=TEXT('\0');
        //
        // move past the <$FAXTAG NEWREC> dummy value so we point to the start of
        // the recipient info.
        //
        lptstrCurRecipient = lptstrCurRecipient + _tcslen(FAXTAG_NEW_RECORD)+1;
    } 
    else 
    {
        //
        // Bad job info  e.g. LPR/LPD job
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Bad job info, No recipients - pFaxPort->pParameters is %s"),
                     pFaxPort->pParameters);
        goto Error;
    }
    //
    // Populate all but the recipient information from the tagged parameter string (1st record)
    //
    SetJobInfoFromTaggedParams(pParameters,pFaxPort);
    //
    // Allocate the recipient list (Note that only after calling SetJobInfoFromTaggedParams()
    // we know how many recipients there are).
    //

	if (0 == pFaxPort->nRecipientCount ||
		pFaxPort->nRecipientCount > FAX_MAX_RECIPIENTS)
	{
		//
		// Recipients count is greater than the limit. This can be an attack that will cause the spooler to allocate alot of memory.
		//
		DebugPrintEx(DEBUG_ERR,
			TEXT("Recipient limit exceeded, or no recipients. #of recipients: %ld"),
			pFaxPort->nRecipientCount);
        goto Error;
	}
    pFaxPort->pRecipients = (PFAX_PERSONAL_PROFILE)MemAlloc(sizeof(FAX_PERSONAL_PROFILE)*pFaxPort->nRecipientCount);
    if (!pFaxPort->pRecipients) 
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("Failed to allocate %ld bytes for recipient array.(ec: 0x%0X)"),
                        sizeof(FAX_PERSONAL_PROFILE)*pFaxPort->nRecipientCount,
                        GetLastError());
        goto Error;
    }
    //
    // Go over the recipients array and populate each recipient from the parameter string.
    //
    for (nRecp=0; nRecp<pFaxPort->nRecipientCount; nRecp++) 
    {
        //
        // At each stage we must first turn the string into null terminated string
        // by locating the next new record tag and replacing its first char with NULL.
        // This allows us to use ExtractTag on the current recipient record alone (without
        // crossing over into the content of the next recipient record).
        // lptstrCurRecipient allways points to the first char past the new record tag and
        // dummy value.
        //
        lptstrNextRecipient=_tcsstr(lptstrCurRecipient,FAXTAG_NEW_RECORD);
        if (lptstrNextRecipient) 
        {
            *lptstrNextRecipient=TEXT('\0');
            //
            // Before being assigned into lptstrCurRecipient we make sure lptstrNextRecipient
            // points to the data following the next recipient new record tag and dummy value.
            //
            lptstrNextRecipient=lptstrNextRecipient+_tcslen(FAXTAG_NEW_RECORD);
        } 
        else 
        {
            if (nRecp != (pFaxPort->nRecipientCount-1))
			{
				//
				// only the last recipient does not have a following recipient
				// We have a mismach between the number of recipients in the recipients array
				// to the number of recipients reported.
				//
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("Number of recipients mismatch."));
				goto Error;
			}
        }

        SetRecipientFromTaggedParams( lptstrCurRecipient,&pFaxPort->pRecipients[nRecp]);
        //
        // Move to the next record in the parameter string
        //
        lptstrCurRecipient=lptstrNextRecipient;
    }
    MemFree(pJobInfo2);
    return TRUE;

Error:
    MemFree(pJobInfo2);
    return FALSE;
}   // GetJobInfo


BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    )
/*++

Routine Description:

    Spooler calls this function to start a new print job on the port

Arguments:

    hPort - Identifies the port
    pPrinterName - Specifies the name of the printer to which the job is being sent
    JobId - Identifies the job being sent by the spooler
    Level - Specifies the DOC_INFO_x level
    pDocInfo - Points to the document information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    JOB_INFO_3  *pJobInfo;
    PFAXPORT     pFaxPort = (PFAXPORT) hPort;
    DEBUG_FUNCTION_NAME(TEXT("FaxMonStartDocPort"));

    DebugPrintEx(DEBUG_MSG,TEXT("Entering StartDocPort: %d ...\n"), JobId);
    //
    // Make sure we have a valid handle
    //
    if (! ValidFaxPort(pFaxPort)) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("StartDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Check if we're at the beginning of a series of chained jobs
    //
    pFaxPort->bCoverPageJob = FALSE;
    if (INVALID_HANDLE_VALUE != pFaxPort->hCoverPageFile)
    {
        //
        // Cover page file exists.
        // We already written to it (since this startdoc event is for the body of the fax)
        // so lets close the file.
        //
        CloseHandle(pFaxPort->hCoverPageFile);
        pFaxPort->hCoverPageFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->hFaxSvc) 
    {
        //
        // If pFaxPort->hFaxSvc is not NULL then we are in the job following the cover page print job.
        // FaxMonEndDocPort() that was called after the cover page print job updated pFaxPort->NextJobId
        // to the next job id in the chain. Thus, the job id we got as a parameter must be
        // the same is pFaxPort->JobId.
        //
        Assert(pFaxPort->jobId == JobId);
        return TRUE;
    }

    //
    // If we are not connected to the fax server yet.
    // This means that this is the FIRST job we handle since the port was last opened.
    // (This means it is the cover page job).
    //

    Assert(pFaxPort->pPrinterName == NULL &&
           pFaxPort->hPrinter     == NULL &&
           pFaxPort->pParameters  == NULL &&
           pFaxPort->pFilename    == NULL &&
           pFaxPort->hFile        == INVALID_HANDLE_VALUE);

    if (!OpenPrinter(pPrinterName, &pFaxPort->hPrinter, NULL))
    {
        pFaxPort->hPrinter = NULL;
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to open printer %s (ec: %d)"), 
                     pPrinterName, 
                     GetLastError());
        goto Error;
    }

    //
    // Connect to the fax service and obtain a session handle
    //
    if (!FaxConnectFaxServer(NULL, &pFaxPort->hFaxSvc)) 
    {
        dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("FaxConnectFaxServer failed: %d\n"), dwErr);
        pFaxPort->hFaxSvc = NULL;
        goto Error;
    }
    
    //
    // Remember the printer name because we'll need it at EndDocPort time.
    //
    pFaxPort->pPrinterName = DuplicateString(pPrinterName);
    if (!pFaxPort->pPrinterName)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to duplicate printer name (ec: %d)"),GetLastError());
        goto Error;
    }

    //
    //  All Jobs are chained, with first job being Cover Page and
    //      second one being the Body.
    //
    //  The only case where only one Job is arrived, is when the Job
    //      is created by FaxStartPrintJob(). In this case, the Job
    //      contains both the Cover Page Info and the Body together.
    //
    //  To check whether the Job is chained or not, MyGetJob() is called.
    //
    //  If NextJob is NOT zero ==> there is chained job ==>
    //      ==> so the current job is the Cover Page job.
    //
    if (pJobInfo = (PJOB_INFO_3)MyGetJob(pFaxPort->hPrinter, 3, JobId))
    {
        pFaxPort->bCoverPageJob = (pJobInfo->NextJobId != 0);
        MemFree(pJobInfo);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,
                        _T("MyGetJob() for JobId = %ld failed, ec = %ld"),
                        JobId,
                        GetLastError());
        goto Error;
    }
    //
    // Get the job parameters from the string in JOB_INFO_2:pParameters.
    //
    if (!GetJobInfo(pFaxPort, JobId))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to get job info for job id : %d"),JobId);
        goto Error;
    }
    //
    // CreateTempFaxFile() creates a temporray files into which the fax body
    // data written by FaxMonWritePort() will be saved.
    //
    if (!(pFaxPort->pFilename = CreateTempFaxFile(TEXT("fax"))))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to Create temp file for fax body. (ec: %d)"),
                     GetLastError());
        goto Error;
    }
    //
    // Open the temporary file we just created for write operation.
    //
    if (!OpenTempFaxFile(pFaxPort, FALSE))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to Open temp file for fax body. (ec: %d)"),
                     GetLastError());
        goto Error;
    }
    if (pFaxPort->CoverPageEx.lptstrCoverPageFileName && !pFaxPort->CoverPageEx.bServerBased) 
    {
        //
        // A cover page is specified and it is a personal cover page.
        // The cover page (template) is in the chained print job.
        // We create a file to which the cover page will be written (by FaxMonWriteDocPort).
        //
        DebugPrintEx(DEBUG_MSG,TEXT("Personal cover page detected."));
        if (!OpenCoverPageFile(pFaxPort))
        {
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to open temp file for fax cover page. (ec: %d)"),
                         GetLastError());
            goto Error;
        }
    }
    else
    {
        //
        // The specified cover page is a server based cover page or no cover page is specified.
        // In both cases there is no cover page data in the print job body so we do not create
        // the file to hold it.
        //
        DebugPrintEx(DEBUG_MSG,TEXT("Server cover page detected or no cover page specified."));
        pFaxPort->hCoverPageFile=INVALID_HANDLE_VALUE;
    }
    //
    // If we got here there were no errors. Keep the job id.
    //
    pFaxPort->jobId = JobId;

    return TRUE;

Error:

    if (NULL == pFaxPort->hFaxSvc && pFaxPort->hPrinter)
    {
        //
        //  pFaxPort->hFaxSvc == NULL
        //      i.e. FaxConnectFaxServer failed
        //
        //  So, we need to Write to Fax Log
        //
        if (GetJobInfo(pFaxPort, JobId))
        {
            JOB_INFO_2  *pJobInfo2 = NULL;  
            pJobInfo2 = (PJOB_INFO_2)MyGetJob( pFaxPort->hPrinter, 2, JobId );
            if (pJobInfo2)
            {
                WriteToLog(MSG_FAX_MON_CONNECT_FAILED, dwErr, pFaxPort, pJobInfo2);
                MemFree(pJobInfo2);
            }
        }
    }
         
    if(pFaxPort->hPrinter)
    {
        //
        // Delete print job
        //
        if (!SetJob(pFaxPort->hPrinter, JobId, 0, NULL, JOB_CONTROL_DELETE))
        {
            DebugPrintEx(DEBUG_ERR, _T("Failed to delete job with id: %d"), JobId);
        }
    }

    FreeFaxJobInfo(pFaxPort);

    return FALSE;

}   // FaxMonStartDocPort


INT
CheckJobRestart(
    PFAXPORT    pFaxPort
    )
/*++

Routine Description:

    Check if the job has been restarted.
    If not, get the ID of the next job in the chain.

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    FAXERR_RESTART or FAXERR_NONE

--*/

{
    JOB_INFO_3 *pJobInfo3;
    JOB_INFO_2 *pJobInfo2;
    INT         status = FAXERR_NONE;
    //
    // If not, get the ID of the next job in the chain.
    //
    DEBUG_FUNCTION_NAME(TEXT("CheckJobRestart"));

    DebugPrintEx(DEBUG_MSG,TEXT("Job chain: id = %d\n"), pFaxPort->nextJobId);

    if (pJobInfo3 = (PJOB_INFO_3)MyGetJob(pFaxPort->hPrinter, 3, pFaxPort->jobId)) 
    {
        pFaxPort->nextJobId = pJobInfo3->NextJobId;
        MemFree(pJobInfo3);
    } 
    else
    {
        pFaxPort->nextJobId = 0;
    }
    //
    // Determine whether the job has been restarted or deleted
    //
    if (pJobInfo2 = (PJOB_INFO_2)MyGetJob(pFaxPort->hPrinter, 2, pFaxPort->jobId)) 
    {
        if (pJobInfo2->Status & (JOB_STATUS_RESTART | JOB_STATUS_DELETING))
        {
            status = FAXERR_RESTART;
        }
        MemFree(pJobInfo2);
    }
    return status;
}   // CheckJobRestart

BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    )
/*++

Routine Description:

    Spooler calls this function at the end of a print job

Arguments:

    hPort - Identifies the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;
    INT         status;
    BOOL        Rslt;
    JOB_INFO_2  *pJobInfo2 = NULL;
    FAX_COVERPAGE_INFO_EX * pCovInfo;
    BOOL bBodyFileIsEmpty=FALSE;
    DWORD       dwFileSize;
    DWORDLONG   dwlParentJobId; // Receives teh parent job id after job submittion
    DWORDLONG*  lpdwlRecipientJobIds = NULL; // Receives the recipient job ids after job submittion

    DEBUG_FUNCTION_NAME(TEXT("FaxMonEndDocPort"));
    //
    // Make sure we have a valid handle
    //
    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("EndDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    //
    // Check if the job has been restarted. If not, get the ID of
    // the next job in the chain.
    //
    //
    // set pFaxPort->nextJobId to the next job id reported by JOB_INFO_3
    // set to 0 if no more chained jobs.
    //
    if ((status = CheckJobRestart(pFaxPort)) != FAXERR_NONE)
    {
        goto ExitEndDocPort;
    }
    //
    // Check if we're at the end of a job chain
    //
    // The job chain starts with a cover page job and ends with a body job.
    // The cover page job has JOB_INFO_2:pParametes which is not NULL. This string
    // is copied to pFaxPort->pParameters when GetJobInfo() was called at FaxMonStartDocPort().
    // This is pParameters is not NULL it means that the current job is a cover page job.
    // In case the current job is a cover page job we report that we sent the job to the printer
    // and do nothing more. Since we do not close the temp file to which FaxMonWriteDoc() is writing
    // the next job (body) will continue to write to the same file. This effectively merges the cover
    // page with the body.
    //
    if (pFaxPort->nextJobId != 0 && pFaxPort->pParameters != NULL) 
    {
        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        return TRUE;
    }
    //
    // If we are here then we are at the end of writing the body (the last job in the chain).
    // In the temporaty file we have a TIFF file with the cover page followed by the body.
    //
    FlushFileBuffers(pFaxPort->hFile);

    if ((dwFileSize = GetFileSize(pFaxPort->hFile, NULL)) == 0)
    {
        DebugPrintEx(DEBUG_WRN, TEXT("Body TIFF file is empty."));
        bBodyFileIsEmpty = TRUE;
        status = FAXERR_IGNORE;
    }
    if (INVALID_FILE_SIZE == dwFileSize)
    {
        status = GetLastError ();
        DebugPrintEx(DEBUG_ERR, TEXT("Can't get file size (ec = %ld)"), status);
        goto ExitEndDocPort;
    }
    CloseHandle(pFaxPort->hFile);
    pFaxPort->hFile = INVALID_HANDLE_VALUE;
    //
    // Call the fax service to send the TIFF file
    //
    pJobInfo2 = (PJOB_INFO_2)MyGetJob( pFaxPort->hPrinter, 2, pFaxPort->jobId );
    if (pJobInfo2) 
    {
        pFaxPort->JobParamsEx.lptstrDocumentName = pJobInfo2->pDocument;
    } 
    else 
    {
        DebugPrintEx(DEBUG_WRN, TEXT("MyGetJob failed for JobId: %d. Setting document name to NULL."), pFaxPort->jobId);
        pFaxPort->JobParamsEx.lptstrDocumentName = NULL;
    }
    pFaxPort->JobParamsEx.dwReserved[0] = 0xffffffff;
    pFaxPort->JobParamsEx.dwReserved[1] = pFaxPort->jobId;

    if (pFaxPort->CoverPageEx.lptstrCoverPageFileName) 
    {
        //
        // If a cover page is specified at all.
        //
        if (pFaxPort->CoverPageEx.bServerBased) 
        {
            //
            // Server cover page. Use the user specified path.
            //
            pCovInfo=&(pFaxPort->CoverPageEx);
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Using server based cover page: %s"),
                         pFaxPort->CoverPageEx.lptstrCoverPageFileName);
        } 
        else 
        {
            //
            // Personal cover page. Use the cover page file created from the print job.
            // Note that there is no cleanup issue here. pCoverPageFileName is deallocated on cleanup.
            // and pFaxPort->CoverPageEx.lptstrCoverPageFileName is never deallocated directly. It points
            // to a location within pFaxPort->pParameters which is freed at cleanup.
            //
            pFaxPort->CoverPageEx.lptstrCoverPageFileName = pFaxPort->pCoverPageFileName;
            pCovInfo=&(pFaxPort->CoverPageEx);
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Using personal cover page copied to : %s"),
                         pFaxPort->CoverPageEx.lptstrCoverPageFileName);
        }
    } 
    else 
    {
        //
        // No cover page specified by the user. Nullify the cover page info sent to FaxSendDocument.
        //
        pCovInfo=NULL;
    }

    if (!pCovInfo && bBodyFileIsEmpty)
    {
        DebugPrintEx(DEBUG_WRN,TEXT("Body file is empty and cover page is not specified. Job is ignored."));
        status = FAXERR_IGNORE;
        goto ExitEndDocPort;
    }
    //
    // Allocate array of recipient job ids
    //
    lpdwlRecipientJobIds=(DWORDLONG*)MemAlloc(sizeof(DWORDLONG)*pFaxPort->nRecipientCount);
    if (!lpdwlRecipientJobIds) 
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate array of size %ld for recipient job ids (ec: 0x%0X)."),
                     sizeof(DWORD)*pFaxPort->nRecipientCount,
                     GetLastError());
        goto ExitEndDocPort;
    }
    if (bBodyFileIsEmpty)
    {
        DebugPrintEx(DEBUG_MSG, TEXT("Sending fax with EMPTY body (cover page is available)"));
        Rslt = FaxSendDocumentEx(
                    pFaxPort->hFaxSvc,
                    NULL, // NO BODY
                    pCovInfo,
                    &pFaxPort->SenderProfile,
                    pFaxPort->nRecipientCount,
                    pFaxPort->pRecipients,
                    &pFaxPort->JobParamsEx,
                    &dwlParentJobId,
                    lpdwlRecipientJobIds);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG, TEXT("Sending fax with body"));
        Rslt = FaxSendDocumentEx(
            pFaxPort->hFaxSvc,
            pFaxPort->pFilename,
            pCovInfo,
            &pFaxPort->SenderProfile,
            pFaxPort->nRecipientCount,
            pFaxPort->pRecipients,
            &pFaxPort->JobParamsEx,
            &dwlParentJobId,
            lpdwlRecipientJobIds);
    }

    if (Rslt) 
    {
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Successfuly submitted job. Parent Job Id = 0x%I64x"),
                     dwlParentJobId);       
        status = FAXERR_NONE;
        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        //
        // pFaxPort>pFileName will be deleted on exit by FreeFaxJobInfo()
        //
    } 
    else 
    {
        status = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            _T("FaxSendDocument failed: ec = %d, job id = %ld\n"),
            GetLastError(),
            pFaxPort->jobId);

        if (pJobInfo2)
        {
            WriteToLog(MSG_FAX_MON_SEND_FAILED, status, pFaxPort, pJobInfo2);
        }
        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_DELETE);
        status = FAXERR_NONE;
    }

ExitEndDocPort:
    //
    // If the job wasn't successfully sent to the fax service,
    // inform the spooler that there is an error on the job.
    //
    // Or if the print job has no data, simply ignore it.
    //
    switch (status) 
    {
        case FAXERR_NONE:
            break;

        case FAXERR_RESTART:
            DebugPrintEx(DEBUG_WRN,TEXT("Job restarted or deleted: id = %d\n"), pFaxPort->jobId);
            //
            // Deliberate fall through
            //
        case FAXERR_IGNORE:
            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
            break;

        default:
            DebugPrintEx(DEBUG_ERR,TEXT("Error sending fax job: id = %d\n"), pFaxPort->jobId);
            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_DELETE);
            break;
    }
    if (pJobInfo2) 
    {
        MemFree( pJobInfo2 );
        pFaxPort->JobParamsEx.lptstrDocumentName = NULL; // It was set to point into pJobInfo2
    }
    if (lpdwlRecipientJobIds) 
    {
        MemFree(lpdwlRecipientJobIds);
        lpdwlRecipientJobIds=NULL;
    }
    FreeFaxJobInfo(pFaxPort);
    return (status < FAXERR_SPECIAL);
}   // FaxMonEndDocPort


BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    )
/*++

Routine Description:

    Writes data to a port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer that contains data to be written to the port
    cbBuf - Specifies the size in bytes of the buffer
    pcbWritten - Returns the count of bytes successfully written to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT  pFaxPort = (PFAXPORT) hPort;
    BOOL      bRet = TRUE;
    //
    // Make sure we have a valid handle
    //
    DEBUG_FUNCTION_NAME(TEXT("FaxMonWritePort"));

    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("WritePort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pFaxPort->bCoverPageJob)
    {
        //
        // If pFaxPort->bCoverPageJob is on it means that the print job that writes is the cover page print job.
        // If the cover page is a personal cover page then it is embedded (the template itself) in this print job
        // and we write it to the temp cover page file we created earlier (pFaxPort->hCoverPageFile).
        // If the cover page is a server cover page then it is NOT embedded in the print job (since it can be found
        // directly on the server) and we do not create a temp cover page file and do not write the print job content
        // into it.
        //
        if (!pFaxPort->CoverPageEx.bServerBased)
        {
            //
            // Personal cover page
            //
            Assert(pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE);
            if(!WriteFile(pFaxPort->hCoverPageFile, pBuffer, cbBuf, pcbWritten, NULL))
            {
                bRet = FALSE;
                DebugPrintEx(DEBUG_ERR,TEXT("WriteFile failed (ec: %d)"), GetLastError());
            }
        } 
        else
        {
            //
            // Server cover page - the print job body is empty and the port shoult not be written to.
            // This should never execute.
            //
            Assert(FALSE);
            *pcbWritten = cbBuf;
        }
    }
    else
    {
        Assert(pFaxPort->hFile != INVALID_HANDLE_VALUE);
        if(!WriteFile(pFaxPort->hFile, pBuffer, cbBuf, pcbWritten, NULL))
        {
            bRet = FALSE;
            DebugPrintEx(DEBUG_ERR,TEXT("WriteFile failed (ec: %d)"), GetLastError());
        }
    }

    if(!bRet)
    {
        //
        // Operation failed
        // Delete print job
        //
        if (!SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_DELETE))
        {
            DebugPrintEx(DEBUG_ERR, _T("Failed to delete job with id: %d"), pFaxPort->jobId);
        }
    }

    return bRet;
}   // FaxMonWritePort


BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    )

/*++

Routine Description:

    Reads data from the port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer where data read from the printer can be written
    cbBuf - Specifies the size in bytes of the buffer pointed to by pBuffer
    pcbRead - Returns the number of bytes successfully read from the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonReadPort"));

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}   // FaxMonReadPort


BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    )
/*++

Routine Description:

    Enumerates the ports available on the specified server

Arguments:

    pServerName - Specifies the name of the server whose ports are to be enumerated
    dwLevel - Specifies the version of the structure to which pPorts points
    pPorts - Points to an array of PORT_INFO_1 structures where data describing
        the available ports will be writteno
    cbBuf - Specifies the size in bytes of the buffer to which pPorts points
    pcbNeeded - Returns the required buffer size identified by pPorts
    pReturned -  Returns the number of PORT_INFO_1 structures returned

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAX_DESC_LEN    64

{
    TCHAR            portDescStr[MAX_DESC_LEN];
    INT              descStrSize, faxmonNameSize;
    DWORD            cbNeeded;
    BOOL             status = TRUE;
    PORT_INFO_1      *pPortInfo1 = (PORT_INFO_1 *) pPorts;
    PORT_INFO_2      *pPortInfo2 = (PORT_INFO_2 *) pPorts;
    INT              strSize;

    DEBUG_FUNCTION_NAME(TEXT("FaxMonEnumPorts"));
    DEBUG_TRACE_ENTER;

    if (pcbNeeded == NULL || pReturned == NULL || (pPorts == NULL && cbBuf != 0)) 
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Invalid input parameters\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    //
    // Load the fax port description string
    //
    if (!LoadString(g_hResource, IDS_FAX_PORT_DESC, portDescStr, MAX_DESC_LEN))
    {
        portDescStr[0] = NUL;
    }
    descStrSize = SizeOfString(portDescStr);
    faxmonNameSize = SizeOfString(faxMonitorName);

    switch (Level) 
    {
        case 1:
            cbNeeded = sizeof(PORT_INFO_1) + SizeOfString(FAX_PORT_NAME);
            break;

        case 2:
            cbNeeded = sizeof(PORT_INFO_2) + descStrSize + faxmonNameSize + SizeOfString(FAX_PORT_NAME);
            break;

        default:
            ASSERT_FALSE;            
            cbNeeded = 0xffffffff;
            break;
    }
    *pReturned = 1;
    *pcbNeeded = cbNeeded;

    if (cbNeeded > cbBuf) 
    {
        //
        // Caller didn't provide a big enough buffer
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        status = FALSE;
    } 
    else 
    {
        //
        // Strings must be packed at the end of the caller provided buffer.
        // Otherwise, spooler will screw up royally.
        //
        pPorts += cbBuf;
        //
        // Copy the requested port information to the caller provided buffer
        //
        strSize = SizeOfString(FAX_PORT_NAME);
        pPorts -= strSize;
        CopyMemory(pPorts, FAX_PORT_NAME, strSize);

        switch (Level) 
        {
            case 1:
                pPortInfo1->pName = (LPTSTR) pPorts;
                DebugPrintEx(DEBUG_MSG, TEXT("Port info 1: %ws\n"), pPortInfo1->pName);
                pPortInfo1++;
                break;

            case 2:
                pPortInfo2->pPortName = (LPTSTR) pPorts;
                //
                // Copy the fax monitor name string
                //
                pPorts -= faxmonNameSize;
                pPortInfo2->pMonitorName = (LPTSTR) pPorts;
                CopyMemory(pPorts, faxMonitorName, faxmonNameSize);
                //
                // Copy the fax port description string
                //
                pPorts -= descStrSize;
                pPortInfo2->pDescription = (LPTSTR) pPorts;
                CopyMemory(pPorts, portDescStr, descStrSize);

                pPortInfo2->fPortType = PORT_TYPE_WRITE;
                pPortInfo2->Reserved = 0;

                DebugPrintEx(DEBUG_MSG,
                             TEXT("Port info 2: %ws, %ws, %ws\n"),
                             pPortInfo2->pPortName,
                             pPortInfo2->pMonitorName,
                             pPortInfo2->pDescription);

                pPortInfo2++;
                break;

            default:
                ASSERT_FALSE; 
                status = FALSE;           
                break;
        }
    }
    return status;
}   // FaxMonEnumPorts


BOOL
DisplayErrorNotImplemented(
    HWND    hwnd,
    INT     titleId
    )
/*++

Routine Description:

    Display an error dialog to tell the user that he cannot manage
    fax devices in the Printers folder.

Arguments:

    hwnd - Specifies the parent window for the message box
    titleId - Message box title string resource ID

Return Value:

    FALSE

--*/
{
    TCHAR   title[128] = {0};
    TCHAR   message[256] = {0};

    LoadString(g_hResource, titleId, title, 128);
    LoadString(g_hResource, IDS_CONFIG_ERROR, message, 256);
    AlignedMessageBox(hwnd, message, title, MB_OK|MB_ICONERROR);
    SetLastError(ERROR_SUCCESS);
    return FALSE;
}   // DisplayErrorNotImplemented

BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    )
/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonAddPort"));
    return DisplayErrorNotImplemented(hwnd, IDS_ADD_PORT);
}   // FaxMonAddPort

BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    )

/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonAddPortEx"));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}   // FaxMonAddPortEx

BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    )
/*++

Routine Description:

    Delete the specified port from the list of supported ports

Arguments:

    pServerName - Specifies the name of the server from which the port is to be removed
    hwnd - Identifies the parent window of the port-deletion dialog box
    pPortName - Specifies the name of the port to be deleted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonDeletePort"));
    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}   // FaxMonDeletePort

BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    )
/*++

Routine Description:

    Display a dialog box to allow user to configure the specified port

Arguments:

    pServerName - Specifies the name of the server on which the given port exists
    hwnd - Identifies the parent window of the port-configuration dialog
    pPortName - Specifies the name of the port to be configured

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonConfigurePort"));
    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}   // FaxMonConfigurePort



PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )
/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    DEBUG_FUNCTION_NAME(TEXT("MyGetJob"));

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = (PBYTE)MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    DebugPrintEx(DEBUG_ERR,TEXT("GetJob failed: %d\n"), GetLastError());
    MemFree(pJobInfo);
    return NULL;
}   // MyGetJob



BOOL
WriteToLog(
    IN DWORD        dwMsgId,
    IN DWORD        dwError,
    IN PFAXPORT     pFaxPort,
    IN JOB_INFO_2*  pJobInfo
    )
/*++

Routine name : WriteToLog

Routine description:

    Write to the Event Log of Fax Service

Author:

    Iv Garber (IvG),    Sep, 2000

Arguments:

    dwError           [in]    - error code
    pFaxPort          [in]    - data about the fax
    pJobInfo          [in]    - data about the fax job

Return Value:

    TRUE if succeded to write to the event log, FALSE otherwise.

--*/
{
    DWORD   dwBufferSize = MAX_PATH - 1;
    TCHAR   tszBuffer[MAX_PATH] = {0};
    BOOL    bRes = FALSE;   

    DEBUG_FUNCTION_NAME(_T("WriteToLog"));

    if (FAX_ERR_RECIPIENTS_LIMIT == dwError)
    {
        DWORD   dwRecipientsLimit = 0;

        if (!FaxGetRecipientsLimit( pFaxPort->hFaxSvc, &dwRecipientsLimit))
        {
            DebugPrintEx(DEBUG_ERR, _T("FaxGetRecipientsLimit() failed: %ld"), GetLastError());
        }   
        //
        //  Write to the Event Log
        //          
        bRes = FaxLog(FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            5,
            MSG_FAX_MON_SEND_RECIPIENT_LIMIT,
            pJobInfo->pMachineName,
            pJobInfo->pUserName,
            pFaxPort->SenderProfile.lptstrName,        
            DWORD2DECIMAL(pFaxPort->nRecipientCount),
            DWORD2DECIMAL(dwRecipientsLimit));
    }
    else
    {
        //
        //  Write to the Event Log
        //          
        bRes = FaxLog(FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            5,
            dwMsgId,
            DWORD2DECIMAL(dwError),
            pJobInfo->pMachineName,
            pJobInfo->pUserName,
            pFaxPort->SenderProfile.lptstrName,        
            DWORD2DECIMAL(pFaxPort->nRecipientCount));
    }

    if (!bRes)
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxLog() failed, ec = %ld"), GetLastError());
    }

    return bRes;
}   // WriteToLog

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )
/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error
    
NOTICE:
    We're not using the utility function StringDup on purpose.
    StringDup uses the utility MemAlloc / MemFree heap management routines.
    However, in this module, MemAlloc / MemFree are remapped (in faxmon.h) to LocalAlloc / LocalFree.

--*/
{
    LPTSTR  pDestStr;
    INT     strSize;

    DEBUG_FUNCTION_NAME(TEXT("DuplicateString"));

    if (pSrcStr != NULL) 
    {
        strSize = SizeOfString(pSrcStr);

        if (pDestStr = (LPTSTR)MemAlloc(strSize))
        {
            CopyMemory(pDestStr, pSrcStr, strSize);
        }
        else
        {
            DebugPrintEx(DEBUG_ERR,TEXT("Memory allocation failed\n"));
        }

    } 
    else
    {
        pDestStr = NULL;
    }
    return pDestStr;
}   // DuplicateString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\escape.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    escape.c

Abstract:

    Implementation of escape related DDI entry points:
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



ULONG
DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEscape.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface the call is directed to
    iEsc - Specifies a query
    cjIn - Specifies the size in bytes of the buffer pointed to by pvIn
    pvIn - Points to input data buffer
    cjOut - Specifies the size in bytes of the buffer pointed to by pvOut
    pvOut -  Points to the output buffer

Return Value:

    Depends on the query specified by iEsc parameter

--*/

{
    Verbose(("Entering DrvEscape...\n"));

    switch (iEsc) {

    case QUERYESCSUPPORT:

        //
        // Query which escapes are supported: The only escape we support
        // is QUERYESCSUPPORT itself.
        //

        if (cjIn != sizeof(ULONG) || !pvIn) {

            Error(("Invalid input paramaters\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return DDI_ERROR;
        }

        if (*((PULONG) pvIn) == QUERYESCSUPPORT)
            return TRUE;

        break;

    default:

        Verbose(("Unsupported iEsc: %d\n", iEsc));
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxmon\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Monitor resource ID file                     //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [12000 - 12499]                                  //
//                                                  //
//////////////////////////////////////////////////////

//
// String resource IDs
//

#define IDS_FAX_PORT_DESC       12000
#define IDS_PORT_ALREADY_EXISTS 12001
#define IDS_FAXERR_RECOVERABLE  12002
#define IDS_FAXERR_FATAL        12003
#define IDS_FAXERR_BAD_TIFF     12004
#define IDS_FAXERR_BAD_DATA16   12005
#define IDS_ADD_PORT            12006
#define IDS_DELETE_PORT         12007
#define IDS_CONFIGURE_PORT      12008
#define IDS_CONFIG_ERROR        12009
#define IDS_ADD_ERROR           12010
#define IDS_DELETE_ERROR        12011
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\enable.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of device and surface related DDI entry points:

        DrvEnableDriver
        DrvDisableDriver
        DrvEnablePDEV
        DrvResetPDEV
        DrvCompletePDEV
        DrvDisablePDEV
        DrvEnableSurface
        DrvDisableSurface
        DrvBitBlt
        DrvStretchBlt
        DrvDitherColor
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"
#include "forms.h"

#define CLOSE_HANDLE(h)     if (!CloseHandle(h)) Error(("CloseHandle failed: %d.\n", GetLastError()))

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

static DRVFN FaxDriverFuncs[] =
{
    { INDEX_DrvEnablePDEV,          (PFN) DrvEnablePDEV         },
    { INDEX_DrvResetPDEV,           (PFN) DrvResetPDEV          },
    { INDEX_DrvCompletePDEV,        (PFN) DrvCompletePDEV       },
    { INDEX_DrvDisablePDEV,         (PFN) DrvDisablePDEV        },
    { INDEX_DrvEnableSurface,       (PFN) DrvEnableSurface      },
    { INDEX_DrvDisableSurface,      (PFN) DrvDisableSurface     },

    { INDEX_DrvStartDoc,            (PFN) DrvStartDoc           },
    { INDEX_DrvEndDoc,              (PFN) DrvEndDoc             },
    { INDEX_DrvStartPage,           (PFN) DrvStartPage          },
    { INDEX_DrvSendPage,            (PFN) DrvSendPage           },

    { INDEX_DrvBitBlt,              (PFN) DrvBitBlt             },
    { INDEX_DrvStretchBlt,          (PFN) DrvStretchBlt         },
    { INDEX_DrvCopyBits,            (PFN) DrvCopyBits           },
    { INDEX_DrvDitherColor,         (PFN) DrvDitherColor        },
    { INDEX_DrvEscape,              (PFN) DrvEscape             },
};

//
// Forward declaration of local functions
//

VOID SelectPrinterForm(PDEVDATA);
BOOL FillDevInfo(PDEVDATA, ULONG, PVOID);
BOOL FillGdiInfo(PDEVDATA, ULONG, PVOID);
VOID FreeDevData(PDEVDATA);



HINSTANCE   ghInstance;


BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
    case DRVQUERY_USERMODE:

        Assert(pcbNeeded != NULL);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;

    default:

        Error(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}



BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pDrvEnableData
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    iEngineVersion - Specifies the DDI version number that GDI is written for
    cb - Size of the buffer pointed to by pDrvEnableData
    pDrvEnableData - Points to an DRVENABLEDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvEnableDriver...\n"));

    //
    // Make sure we have a valid engine version and
    // we're given enough room for the DRVENABLEDATA.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4 || cb < sizeof(DRVENABLEDATA)) {

        Error(("DrvEnableDriver failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }

    //
    // Fill in the DRVENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = DDI_DRIVER_VERSION_NT4;
    pDrvEnableData->c = sizeof(FaxDriverFuncs) / sizeof(DRVFN);
    pDrvEnableData->pdrvfn = FaxDriverFuncs;

    return TRUE;
}



DHPDEV
DrvEnablePDEV(
    PDEVMODE  pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pGdiInfo,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    pdm - Points to a DEVMODE structure that contains driver data
    pLogAddress - Points to the logical address string
    cPatterns - Specifies the number of standard patterns
    phsurfPatterns - Buffer to hold surface handles to standard patterns
    cjGdiInfo - Size of GDIINFO buffer
    pGdiInfo - Points to a GDIINFO structure
    cjDevInfo - Size of DEVINFO buffer
    pDevInfo - Points to a DEVINFO structure
    hdev - GDI device handle
    pDeviceName - Points to device name string
    hPrinter - Spooler printer handle

Return Value:

    Driver device handle, NULL if there is an error

--*/

{
    PDEVDATA    pdev;
#ifndef USERMODE_DRIVER
    ULONG       ul;
#endif

    Verbose(("Entering DrvEnablePDEV...\n"));

    //
    // Allocate memory for our DEVDATA structure and initialize it
    //
    if (! (pdev = MemAllocZ(sizeof(DEVDATA)))) {

        Error(("Memory allocation failed\n"));
        return NULL;
    }

    pdev->hPrinter = hPrinter;
    pdev->bPrintPreview = FALSE;
    pdev->hPreviewMapping = NULL;

#ifdef USERMODE_DRIVER
    pdev->hPreviewFile = INVALID_HANDLE_VALUE;
#endif

    pdev->pTiffPageHeader = NULL;
    pdev->pbTiffPageFP = NULL;
    pdev->startDevData = pdev;
    pdev->endDevData = pdev;

    //
    // Save and validate DEVMODE information
    //  start with the driver default
    //  then merge with the system default
    //  finally merge with the input devmode
    //

    if (CurrentVersionDevmode(pdm)) {

        memcpy(&pdev->dm, pdm, sizeof(DRVDEVMODE));

        //
        // NOTE: We now use dmPrintQuality and dmYResolution fields
        // to store the resolution measured in dots-per-inch. Add
        // the following check as a safety precaution in case older
        // DEVMODE is passed to us.
        //

        if (pdev->dm.dmPublic.dmPrintQuality <= 0 ||
            pdev->dm.dmPublic.dmYResolution <= 0)
        {
            pdev->dm.dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
            pdev->dm.dmPublic.dmYResolution = FAXRES_VERTICAL;
        }

        //
        // Check if we were given a mapping file
        //
        if (pdev->dm.dmPrivate.szMappingFile[0] != TEXT('\0'))
        {
            //
            // Load the preview file image:
            //
            // In user mode this is done by - CreateFile(), CreateFileMapping() and MapViewOfFile().
            // In kernel mode this is done by - EngLoadModuleForWrite() and EngMapModule().
            //

#ifdef USERMODE_DRIVER

            //
            // First, open the file
            //
            if ( INVALID_HANDLE_VALUE == (pdev->hPreviewFile = SafeCreateFile(
                        pdev->dm.dmPrivate.szMappingFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_TEMPORARY,
                        NULL)) )
            {
                Error(("Failed opening mapping file.\n"));
            }
            else
            {
                //
                // Then create a mapping object
                //
                pdev->hPreviewMapping = CreateFileMapping(
                    pdev->hPreviewFile,                     // handle to file
                    NULL,                                   // security
                    PAGE_READWRITE,                         // protection
                    0,                                      // high-order DWORD of size
                    MAX_TIFF_PAGE_SIZE,                     // low-order DWORD of size
                    NULL                                    // object name
                    );
#else
                //
                // First, load the file image
                //
                pdev->hPreviewMapping = EngLoadModuleForWrite(pdev->dm.dmPrivate.szMappingFile, 0);
#endif

                if (pdev->hPreviewMapping)
                {
                    //
                    // Now, open a view to the image in our address space
                    //

#ifdef USERMODE_DRIVER
                    pdev->pTiffPageHeader = (PMAP_TIFF_PAGE_HEADER) MapViewOfFile(
                        pdev->hPreviewMapping,              // handle to file-mapping object
                        FILE_MAP_WRITE,                     // access mode
                        0,                                  // high-order DWORD of offset
                        0,                                  // low-order DWORD of offset
                        0                                   // number of bytes to map
                        );
                    if ( (NULL != pdev->pTiffPageHeader) && 
                         (sizeof(MAP_TIFF_PAGE_HEADER) == pdev->pTiffPageHeader->cb) )
#else
                    pdev->pTiffPageHeader = 
                                (PMAP_TIFF_PAGE_HEADER) EngMapModule(pdev->hPreviewMapping, &ul);
                    if ( (NULL != pdev->pTiffPageHeader) && 
                         (MAX_TIFF_PAGE_SIZE == ul)      &&
                         (sizeof(MAP_TIFF_PAGE_HEADER) == pdev->pTiffPageHeader->cb) )
#endif
                    {
                        //
                        // Sucess
                        //
                        pdev->bPrintPreview = pdev->pTiffPageHeader->bPreview;
                        pdev->pbTiffPageFP = (LPBYTE) (pdev->pTiffPageHeader + 1);
                    }
                    else
                    {
                        Error(("Failed opening view.\n"));

#ifdef USERMODE_DRIVER
                        if (pdev->pTiffPageHeader)
                        {
                            UnmapViewOfFile(pdev->pTiffPageHeader);
                        }
                        CLOSE_HANDLE(pdev->hPreviewMapping);
                        CLOSE_HANDLE(pdev->hPreviewFile);
                        pdev->hPreviewFile = NULL;
#else
                        EngFreeModule(pdev->hPreviewMapping);
#endif
                        pdev->hPreviewMapping = NULL;
                        pdev->pTiffPageHeader = NULL;
                    }
                }
                else
                {
                    Error(("Failed mapping file: %s.\n", pdev->dm.dmPrivate.szMappingFile));

#ifdef USERMODE_DRIVER
                    // Close the file handle
                    CLOSE_HANDLE(pdev->hPreviewFile);
                    pdev->hPreviewFile = NULL;
#endif
                }

#ifdef USERMODE_DRIVER
            }
#endif

        }
        else
        {
            Warning(("No mapping file specified.\n"));
        }
    } else {

        Error(("Bad DEVMODE passed to DrvEnablePDEV\n"));
        DriverDefaultDevmode(&pdev->dm, NULL, hPrinter);
    }

    //
    // Calculate the paper size information
    //

    SelectPrinterForm(pdev);

    //
    // Fill out GDIINFO and DEVINFO structure
    //

    if (! FillGdiInfo(pdev, cjGdiInfo, pGdiInfo) ||
        ! FillDevInfo(pdev, cjDevInfo, pDevInfo))
    {
        FreeDevData(pdev);
        return NULL;
    }

    //
    // Zero out the array of HSURF's so that the engine will
    // automatically simulate the standard patterns for us
    //

    memset(phsurfPatterns, 0, sizeof(HSURF) * cPatterns);

    //
    // Return a pointer to our DEVDATA structure
    //

    return (DHPDEV) pdev;
}



BOOL
DrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvResetPDEV.
    Please refer to DDK documentation for more details.

Arguments:

    phpdevOld - Driver handle to the old device
    phpdevNew - Driver handle to the new device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdevOld, pdevNew;

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Validate both old and new device
    //

    pdevOld = (PDEVDATA) dhpdevOld;
    pdevNew = (PDEVDATA) dhpdevNew;

    if (! ValidDevData(pdevOld) || ! ValidDevData(pdevNew)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Transfer information from old device to new device
    //

    if (pdevOld->pageCount != 0) {

        pdevNew->pageCount = pdevOld->pageCount;
        pdevNew->flags |= PDEV_RESETPDEV;
        pdevNew->fileOffset = pdevOld->fileOffset;

        if (pdevOld->pFaxIFD) {

            pdevNew->pFaxIFD = pdevOld->pFaxIFD;
            pdevOld->pFaxIFD = NULL;
        }
    }

    //
    // Carry over relevant flag bits
    //
    pdevNew->flags |= pdevOld->flags & PDEV_CANCELLED;
    return TRUE;
}



VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCompletePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    hdev - GDI device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvCompletePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Remember the engine's handle to the physical device
    //

    pdev->hdev = hdev;
}



HSURF
DrvEnableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    Handle to newly created surface, NULL if there is an error

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;
    FLONG       flHooks;

    Verbose(("Entering DrvEnableSurface...\n"));

    //
    // Validate the pointer to our DEVDATA structure
    //

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Adjust the bitmap size so that we always end up with 1728 pixels per scanline
    //

    Assert(MAX_WIDTH_PIXELS % DWORDBITS == 0);

    if (IsLandscapeMode(pdev)) {

        Assert(pdev->imageSize.cy <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cy = MAX_WIDTH_PIXELS;
        pdev->imageSize.cx = ((pdev->imageSize.cx + (BYTEBITS - 1)) / BYTEBITS) * BYTEBITS;

    } else {

        Assert(pdev->imageSize.cx <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cx = MAX_WIDTH_PIXELS;
    }

    pdev->lineOffset = PadBitsToBytes(pdev->imageSize.cx, sizeof(DWORD));

    //
    // Call the engine to create a standard bitmap surface for us
    //

    pdev->hbitmap = (HSURF) EngCreateBitmap(pdev->imageSize,
                                            pdev->lineOffset,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT | BMF_USERMEM,
                                            NULL);

    if (pdev->hbitmap == NULL) {

        Error(("EngCreateBitmap failed\n"));
        return NULL;
    }

    //
    // Associate the surface with the device and inform the
    // engine which functions we have hooked out
    //

    if (pdev->dm.dmPrivate.flags & FAXDM_NO_HALFTONE)
        flHooks = 0;
    else
        flHooks = (HOOK_STRETCHBLT | HOOK_BITBLT | HOOK_COPYBITS);

    EngAssociateSurface(pdev->hbitmap, pdev->hdev, flHooks);

    //
    // Return the surface handle to the engine
    //

    return pdev->hbitmap;
}



VOID
DrvDisableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisableSurface...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Call the engine to delete the surface handle
    //

    if (pdev->hbitmap != NULL) {

        EngDeleteSurface(pdev->hbitmap);
        pdev->hbitmap = NULL;
    }
}



VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisablePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Free up memory allocated for the current PDEV
    //
    FreeDevData(pdev);
}



VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    Verbose(("Entering DrvDisableDriver...\n"));
}



BOOL
IsCompatibleSurface(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    XLATEOBJ   *pxlo
    )

/*++

Routine Description:

    Check if the source surface is compatible with the destination surface
    i.e. we can bitblt without halftonig

Arguments:

    psoDst - Specifies the destination surface
    psoSrc - Specifies the source surface
    pxlo - How to transform colors between the source surface and the destination surface

Return Value:

    TRUE if the source surface is compatible with the destination surface
    FALSE otherwise

--*/

{
    BOOL result;

    //
    // We know our destination surface is always 1bpp
    //

    Assert(psoDst->iBitmapFormat == BMF_1BPP);

    //
    // Check whether the transformation is trivial
    //

    if (!pxlo || (pxlo->flXlate & XO_TRIVIAL)) {

        result = (psoSrc->iBitmapFormat == psoDst->iBitmapFormat);

    } else if ((pxlo->flXlate & XO_TABLE) && pxlo->cEntries <= 2) {
        
        ULONG srcPalette[2];

        srcPalette[0] = srcPalette[1] = RGB_BLACK;
        XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, pxlo->cEntries, srcPalette);

        result = (srcPalette[0] == RGB_BLACK || srcPalette[0] == RGB_WHITE) &&
                 (srcPalette[1] == RGB_BLACK || srcPalette[1] == RGB_WHITE);

    } else
        result = FALSE;

    return result;
}



BOOL
DrvCopyBits(
    SURFOBJ    *psoTrg,   
    SURFOBJ    *psoSrc,    
    CLIPOBJ    *pco,   
    XLATEOBJ   *pxlo, 
    RECTL      *prclDst, 
    POINTL     *pptlSrc 
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    Verbose(("Entering DrvCopyBits ...\n"));
    
    //
    // Check if halftoning is necessary
    // If not, let the engine handle it
    //

    if ((psoSrc->iType != STYPE_BITMAP) ||
        (psoTrg->iType != STYPE_BITMAP) ||
        IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        return EngCopyBits(psoTrg, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {
        POINTL  ptlBrushOrg;
        RECTL   rclDst, rclSrc;

        ptlBrushOrg.x = ptlBrushOrg.y = 0;

        rclDst        = *prclDst;
        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy))
        {
            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;
            rclDst.right  = rclDst.left + (rclSrc.right - rclSrc.left);
            rclDst.bottom = rclDst.top  + (rclSrc.bottom - rclSrc.top);
        }

        return EngStretchBlt(psoTrg,
                             psoSrc,
                             NULL,
                             pco,
                             pxlo,
                             &DefHTClrAdj,
                             &ptlBrushOrg,
                             &rclDst,
                             &rclSrc,
                             NULL,
                             HALFTONE);
    }
}



BOOL
DrvBitBlt(
    SURFOBJ    *psoTrg,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclTrg,
    POINTL     *pptlSrc,
    POINTL     *pptlMask,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrush,
    ROP4        rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    COLORADJUSTMENT *pca;
    PDEVDATA        pdev;
    DWORD           rop3Foreground, rop3Background;
    SURFOBJ         *psoNewSrc;
    HBITMAP         hbmpNewSrc;
    POINTL          brushOrg;
    BOOL            result;

    Verbose(("Entering DrvBitBlt...\n"));
    
    //
    // Validate input parameters
    //

    Assert(psoTrg != NULL);
    pdev = (PDEVDATA) psoTrg->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Use the system default color adjustment information
    //

    pca = &DefHTClrAdj;

    //
    // Figure out the foreground and background ROP3
    //

    psoNewSrc = NULL;
    hbmpNewSrc = NULL;
    rop3Foreground = GetForegroundRop3(rop4);
    rop3Background = GetBackgroundRop3(rop4);

    if ((Rop3NeedPattern(rop3Foreground) || Rop3NeedPattern(rop3Background)) && pptlBrush) {

        brushOrg = *pptlBrush;

    } else {

        brushOrg.x = brushOrg.y = 0;
    }

    //
    // If a source bitmap is involved in the raster operation and
    // the source is not compatible with the destination surface,
    // then we'll halftone the source bitmap into a new bitmap and
    // bitblt the new bitmap onto the destination surface.
    //

    if ((Rop3NeedSource(rop3Foreground) || Rop3NeedSource(rop3Background)) &&
        !IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        RECTL   rclNewSrc, rclOldSrc;
        SIZEL   bmpSize;
        LONG    lDelta;

        rclNewSrc.left = rclNewSrc.top = 0;
        rclNewSrc.right = prclTrg->right - prclTrg->left;
        rclNewSrc.bottom = prclTrg->bottom - prclTrg->top;

        rclOldSrc.left = pptlSrc->x;
        rclOldSrc.top = pptlSrc->y;
        rclOldSrc.right = rclOldSrc.left + rclNewSrc.right;
        rclOldSrc.bottom = rclOldSrc.top + rclNewSrc.bottom;

        //
        // Express path for the most common case: SRCCOPY
        //

        if (rop4 == 0xcccc) {

            return EngStretchBlt(psoTrg,
                                 psoSrc,
                                 psoMask,
                                 pco,
                                 pxlo,
                                 pca,
                                 &brushOrg,
                                 prclTrg,
                                 &rclOldSrc,
                                 pptlMask,
                                 HALFTONE);
        }

        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's (0, 0) minus the original location
        //

        brushOrg.x -= prclTrg->left;
        brushOrg.y -= prclTrg->top;

        //
        // Create a temporary bitmap surface
        // Halftone the source bitmap into the temporary bitmap
        //

        Assert(psoTrg->iBitmapFormat == BMF_1BPP);

        bmpSize.cx = rclNewSrc.right;
        bmpSize.cy = rclNewSrc.bottom;
        lDelta = PadBitsToBytes(bmpSize.cx, sizeof(DWORD));

        if (! (hbmpNewSrc = EngCreateBitmap(bmpSize,
                                            lDelta,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT,
                                            NULL)) ||
            ! EngAssociateSurface((HSURF) hbmpNewSrc, pdev->hdev, 0) ||
            ! (psoNewSrc = EngLockSurface((HSURF) hbmpNewSrc)) ||
            ! EngStretchBlt(psoNewSrc,
                            psoSrc,
                            NULL,
                            NULL,
                            pxlo,
                            pca,
                            &brushOrg,
                            &rclNewSrc,
                            &rclOldSrc,
                            NULL,
                            HALFTONE))
        {
            if (psoNewSrc)
                EngUnlockSurface(psoNewSrc);
        
            if (hbmpNewSrc)
                EngDeleteSurface((HSURF) hbmpNewSrc);

            return FALSE;
        }

        //
        // Proceed to bitblt from the temporary bitmap to the destination
        //

        psoSrc = psoNewSrc;
        pptlSrc = (PPOINTL) &rclNewSrc.left;
        pxlo = NULL;
        brushOrg.x = brushOrg.y = 0;
    }

    //
    // Let engine do the work
    //

    result = EngBitBlt(psoTrg,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclTrg,
                       pptlSrc,
                       pptlMask,
                       pbo,
                       &brushOrg,
                       rop4);

    //
    // Clean up properly before returning
    //

    if (psoNewSrc)
        EngUnlockSurface(psoNewSrc);

    if (hbmpNewSrc)
        EngDeleteSurface((HSURF) hbmpNewSrc);

    return result;
}



BOOL
DrvStretchBlt(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    COLORADJUSTMENT  *pca,
    POINTL     *pptlBrushOrg,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    POINTL     *pptlMask,
    ULONG       iMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvStretchBlt...\n"));

    //
    // If no color adjustment information is provided, use the system default 
    //

    if (pca == NULL)
        pca = &DefHTClrAdj;

    //
    // Let engine do the work; make sure halftone is enabled
    //

    return EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         HALFTONE);
}



ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgb,
    ULONG  *pul
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iMode - Determines the palette to dither against
    rgb - Specifies the RGB color that is to be dithered
    pul - Points to a memory location in which the dithering information is to be recorded

Return Value:

    DCR_HALFTONE to indicate that the engine should create a halftone
    approximation for the driver.

--*/

{
    return DCR_HALFTONE;
}



BOOL
FillDevInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pdevinfo
    )

/*++

Routine Description:

    Fill in the DEVINFO structure pointed to by pdevinfo.

Arguments:

    pdev - Pointer to our DEVDATA structure
    cb - Size of structure pointed to by pdevinfo
    pdevinfo - Pointer to DEVINFO structure

[Notes:]

    Since we have to worry about not writing out more than cb bytes to
    pdevinfo, we will first fill in a local buffer, then copy cb bytes
    to pdevinfo.

Return Value:

    TRUE if successful. FALSE otherwise.

--*/

{
    static ULONG paletteColors[2] = {

        RGB_BLACK,
        RGB_WHITE,
    };

    DEVINFO devinfo;

    memset(&devinfo, 0, sizeof(devinfo));

    //
    // Fill in the graphics capabilities flags: we let the engine
    // do almost everything. Also, we have to tell the engine not
    // to do metafile spooling because we hook out DrvDocumentEvent.
    //

    devinfo.flGraphicsCaps = GCAPS_HALFTONE |
                             GCAPS_MONO_DITHER |
                             GCAPS_COLOR_DITHER |
                             GCAPS_DONTJOURNAL;

    //
    // No device fonts
    //

    devinfo.cFonts = 0;

    //
    // Black and white palette: entry 0 is black and entry 1 is white
    //

    if (! (pdev->hpal = EngCreatePalette(PAL_INDEXED, 2, paletteColors, 0, 0, 0))) {

        Error(("EngCreatePalette failed\n"));
        return FALSE;
    }

    devinfo.hpalDefault = pdev->hpal;
    devinfo.iDitherFormat = BMF_1BPP;
    devinfo.cxDither = devinfo.cyDither = 4;

    //
    // Copy cb bytes from devinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(devinfo))
    {
        memset(pdevinfo, 0, cb);
        memcpy(pdevinfo, &devinfo, sizeof(devinfo));
    }
    else
        memcpy(pdevinfo, &devinfo, cb);

    return TRUE;
}



BOOL
FillGdiInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pgdiinfo
    )

/*++

Routine Description:

    Fill in the device capabilities information for the engine.

Arguments:

    pdev - Pointer to DEVDATA structure
    cb - Size of buffer pointed to by pgdiinfo
    pgdiinfo - Pointer to a GDIINFO buffer

Return Value:

    NONE

--*/

{
    GDIINFO gdiinfo;
    LONG    maxRes;

    memset(&gdiinfo, 0, sizeof(gdiinfo));

    //
    // This field doesn't seem to have any effect for printer drivers.
    // Put our driver version number in there anyway.
    //

    gdiinfo.ulVersion = DRIVER_VERSION;

    //
    // We're raster printers
    //

    gdiinfo.ulTechnology = DT_RASPRINTER;

    //
    // Width and height of the imageable area measured in microns.
    // Remember to turn on the sign bit.
    //

    gdiinfo.ulHorzSize = - (pdev->imageArea.right - pdev->imageArea.left);
    gdiinfo.ulVertSize = - (pdev->imageArea.bottom - pdev->imageArea.top);

    //
    // Convert paper size and imageable area from microns to pixels
    //

    pdev->paperSize.cx = MicronToPixel(pdev->paperSize.cx, pdev->xres);
    pdev->paperSize.cy = MicronToPixel(pdev->paperSize.cy, pdev->yres);

    pdev->imageArea.left = MicronToPixel(pdev->imageArea.left, pdev->xres);
    pdev->imageArea.right = MicronToPixel(pdev->imageArea.right, pdev->xres);
    pdev->imageArea.top = MicronToPixel(pdev->imageArea.top, pdev->yres);
    pdev->imageArea.bottom = MicronToPixel(pdev->imageArea.bottom, pdev->yres);

    pdev->imageSize.cx = pdev->imageArea.right - pdev->imageArea.left;
    pdev->imageSize.cy = pdev->imageArea.bottom - pdev->imageArea.top;

    //
    // Width and height of the imageable area measured in device pixels
    //

    gdiinfo.ulHorzRes = pdev->imageSize.cx;
    gdiinfo.ulVertRes = pdev->imageSize.cy;

    //
    // Color depth information
    //

    gdiinfo.cBitsPixel = 1;
    gdiinfo.cPlanes = 1;
    gdiinfo.ulNumColors = 2;

    //
    // Resolution information
    //

    gdiinfo.ulLogPixelsX = pdev->xres;
    gdiinfo.ulLogPixelsY = pdev->yres;

    //
    // Win31 compatible text capability flags. Are they still used by anyone?
    //

    gdiinfo.flTextCaps = 0;

    //
    // Device pixel aspect ratio
    //

    gdiinfo.ulAspectX = pdev->yres;
    gdiinfo.ulAspectY = pdev->xres;
    gdiinfo.ulAspectXY = CalcHypot(pdev->xres, pdev->yres);

    //
    // Dotted line appears to be approximately 25dpi
    // We assume either xres is a multiple of yres or yres is a multiple of xres
    //

    maxRes = max(pdev->xres, pdev->yres);
    Assert((maxRes % pdev->xres) == 0 && (maxRes % pdev->yres == 0));

    gdiinfo.xStyleStep = maxRes / pdev->xres;
    gdiinfo.yStyleStep = maxRes / pdev->yres;
    gdiinfo.denStyleStep = maxRes / 25;

    //
    // Size and margins of physical surface measured in device pixels
    //

    gdiinfo.szlPhysSize.cx = pdev->paperSize.cx;
    gdiinfo.szlPhysSize.cy = pdev->paperSize.cy;

    gdiinfo.ptlPhysOffset.x = pdev->imageArea.left;
    gdiinfo.ptlPhysOffset.y = pdev->imageArea.top;

    //
    // Use default halftone information
    //

    gdiinfo.ciDevice = DefDevHTInfo.ColorInfo;
    gdiinfo.ulDevicePelsDPI = max(pdev->xres, pdev->yres);
    gdiinfo.ulPrimaryOrder = PRIMARY_ORDER_CBA;
    gdiinfo.ulHTOutputFormat = HT_FORMAT_1BPP;
    gdiinfo.flHTFlags = HT_FLAG_HAS_BLACK_DYE;
    gdiinfo.ulHTPatternSize = HT_PATSIZE_4x4_M;

    //
    // Copy cb byte from gdiinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(gdiinfo))
    {
        memset(pgdiinfo, 0, cb);
        memcpy(pgdiinfo, &gdiinfo, sizeof(gdiinfo));
    }
    else
        memcpy(pgdiinfo, &gdiinfo, cb);

    return TRUE;
}



VOID
FreeDevData(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free up all memory associated with the specified PDEV

Arguments:

    pdev    Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->hpal)
        EngDeletePalette(pdev->hpal);

    //
    // Close our preview file mapping if opened
    //

#ifdef USERMODE_DRIVER

    if (pdev->pTiffPageHeader)
    {
        UnmapViewOfFile(pdev->pTiffPageHeader);
        pdev->pTiffPageHeader = NULL;
    }
    if (pdev->hPreviewMapping)
    {
        CLOSE_HANDLE(pdev->hPreviewMapping);
        pdev->hPreviewMapping = NULL;
    }
    if (INVALID_HANDLE_VALUE != pdev->hPreviewFile)
    {
        CLOSE_HANDLE(pdev->hPreviewFile);
        pdev->hPreviewFile = INVALID_HANDLE_VALUE;
    }

#else

    if (pdev->hPreviewMapping)
    {
        EngFreeModule(pdev->hPreviewMapping);
    }

#endif // USERMODE_DRIVER

    MemFree(pdev->pFaxIFD);
    MemFree(pdev);
}



VOID
SelectPrinterForm(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Store printer paper size information in our DEVDATA structure

Arguments:

    pdev - Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    FORM_INFO_1 formInfo;

    //
    // Validate devmode form specification; use default form if it's invalid.
    //

    if (! ValidDevmodeForm(pdev->hPrinter, &pdev->dm.dmPublic, &formInfo)) {

        memset(&formInfo, 0, sizeof(formInfo));

        //
        // Default to A4 paper
        //

        formInfo.Size.cx = formInfo.ImageableArea.right = A4_WIDTH;
        formInfo.Size.cy = formInfo.ImageableArea.bottom = A4_HEIGHT;
    }

    Assert(formInfo.Size.cx > 0 && formInfo.Size.cy > 0);
    Assert(formInfo.ImageableArea.left >= 0 &&
           formInfo.ImageableArea.top >= 0 &&
           formInfo.ImageableArea.left < formInfo.ImageableArea.right &&
           formInfo.ImageableArea.top < formInfo.ImageableArea.bottom &&
           formInfo.ImageableArea.right <= formInfo.Size.cx &&
           formInfo.ImageableArea.bottom <= formInfo.Size.cy);

    //
    // Take landscape into consideration
    //

    if (IsLandscapeMode(pdev)) {

        LONG    width, height;

        //
        // Swap the width and height
        //

        pdev->paperSize.cy = width = formInfo.Size.cx;
        pdev->paperSize.cx = height = formInfo.Size.cy;

        //
        // Rotate the coordinate system 90 degrees counterclockwise
        //

        pdev->imageArea.left = height - formInfo.ImageableArea.bottom;
        pdev->imageArea.top = formInfo.ImageableArea.left;
        pdev->imageArea.right = height - formInfo.ImageableArea.top;
        pdev->imageArea.bottom = formInfo.ImageableArea.right;

        //
        // Swap x and y resolution
        //
    
        pdev->xres = pdev->dm.dmPublic.dmYResolution;
        pdev->yres = pdev->dm.dmPublic.dmPrintQuality;

    } else {

        pdev->paperSize = formInfo.Size;
        pdev->imageArea = formInfo.ImageableArea;

        pdev->xres = pdev->dm.dmPublic.dmPrintQuality;
        pdev->yres = pdev->dm.dmPublic.dmYResolution;
    }
}



LONG
CalcHypot(
    LONG    x,
    LONG    y
    )

/*++

Routine Description:

    Returns the length of the hypotenouse of a right triangle

Arguments:

    x, y - Edges of the right triangle

Return Value:

    Hypotenouse of the right triangle

--*/

{
    LONG    hypo, delta, target;

    //
    // Take care of negative inputs
    //
    
    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    //
    // use sq(x) + sq(y) = sq(hypo);
    // start with MAX(x, y),
    // use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the target hypotenouse.
    //

    hypo = max(x, y);
    target = min(x, y);
    target *= target;

    for(delta = 0; delta < target; hypo++)
        delta += (hypo << 1) + 1;

    return hypo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\faxtable.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtable.h

Abstract:

    Tables used for Group3 fax compression

Environment:

	Windows XP Fax driver, kernel mode

Revision History:

	01/23/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FAXTABLE_H_
#define _FAXTABLE_H_

//
// Data structure for representing code table entries
//

typedef struct {

    WORD    length;     // code length
    WORD    code;       // code word itself

} CODETABLE;

typedef const CODETABLE *PCODETABLE;

//
// Code word for end-of-line (EOL)
//  000000000001
//

#define EOL_CODE        1
#define EOL_LENGTH      12

//
// Code word for 2D encoding - pass mode
//  0001
//

#define PASSCODE        1
#define PASSCODE_LENGTH 4

//
// Code word for 2D encoding - horizontal mode prefix
//  001
//

#define HORZCODE        1
#define HORZCODE_LENGTH 3

//
// Code word for 2D encoding - vertical mode
//

static const CODETABLE VertCodes[] = {

    {  7, 0x02 },       // 0000010         VL3
    {  6, 0x02 },       // 000010          VL2
    {  3, 0x02 },       // 010             VL1
    {  1, 0x01 },       // 1                V0
    {  3, 0x03 },       // 011             VR1
    {  6, 0x03 },       // 000011          VR2
    {  7, 0x03 },       // 0000011         VR3
};

//
// Code table for white runs
//

static const CODETABLE WhiteRunCodes[] = {
    
    {  8, 0x35 },       // 00110101          0
    {  6, 0x07 },       // 000111            1
    {  4, 0x07 },       // 0111              2
    {  4, 0x08 },       // 1000              3
    {  4, 0x0b },       // 1011              4
    {  4, 0x0c },       // 1100              5
    {  4, 0x0e },       // 1110              6
    {  4, 0x0f },       // 1111              7
    {  5, 0x13 },       // 10011             8
    {  5, 0x14 },       // 10100             9
    {  5, 0x07 },       // 00111            10
    {  5, 0x08 },       // 01000            11
    {  6, 0x08 },       // 001000           12
    {  6, 0x03 },       // 000011           13
    {  6, 0x34 },       // 110100           14
    {  6, 0x35 },       // 110101           15
    {  6, 0x2a },       // 101010           16
    {  6, 0x2b },       // 101011           17
    {  7, 0x27 },       // 0100111          18
    {  7, 0x0c },       // 0001100          19
    {  7, 0x08 },       // 0001000          20
    {  7, 0x17 },       // 0010111          21
    {  7, 0x03 },       // 0000011          22
    {  7, 0x04 },       // 0000100          23
    {  7, 0x28 },       // 0101000          24
    {  7, 0x2b },       // 0101011          25
    {  7, 0x13 },       // 0010011          26
    {  7, 0x24 },       // 0100100          27
    {  7, 0x18 },       // 0011000          28
    {  8, 0x02 },       // 00000010         29
    {  8, 0x03 },       // 00000011         30
    {  8, 0x1a },       // 00011010         31
    {  8, 0x1b },       // 00011011         32
    {  8, 0x12 },       // 00010010         33
    {  8, 0x13 },       // 00010011         34
    {  8, 0x14 },       // 00010100         35
    {  8, 0x15 },       // 00010101         36
    {  8, 0x16 },       // 00010110         37
    {  8, 0x17 },       // 00010111         38
    {  8, 0x28 },       // 00101000         39
    {  8, 0x29 },       // 00101001         40
    {  8, 0x2a },       // 00101010         41
    {  8, 0x2b },       // 00101011         42
    {  8, 0x2c },       // 00101100         43
    {  8, 0x2d },       // 00101101         44
    {  8, 0x04 },       // 00000100         45
    {  8, 0x05 },       // 00000101         46
    {  8, 0x0a },       // 00001010         47
    {  8, 0x0b },       // 00001011         48
    {  8, 0x52 },       // 01010010         49
    {  8, 0x53 },       // 01010011         50
    {  8, 0x54 },       // 01010100         51
    {  8, 0x55 },       // 01010101         52
    {  8, 0x24 },       // 00100100         53
    {  8, 0x25 },       // 00100101         54
    {  8, 0x58 },       // 01011000         55
    {  8, 0x59 },       // 01011001         56
    {  8, 0x5a },       // 01011010         57
    {  8, 0x5b },       // 01011011         58
    {  8, 0x4a },       // 01001010         59
    {  8, 0x4b },       // 01001011         60
    {  8, 0x32 },       // 00110010         61
    {  8, 0x33 },       // 00110011         62
    {  8, 0x34 },       // 00110100         63
    {  5, 0x1b },       // 11011            64
    {  5, 0x12 },       // 10010           128
    {  6, 0x17 },       // 010111          192
    {  7, 0x37 },       // 0110111         256
    {  8, 0x36 },       // 00110110        320
    {  8, 0x37 },       // 00110111        384
    {  8, 0x64 },       // 01100100        448
    {  8, 0x65 },       // 01100101        512
    {  8, 0x68 },       // 01101000        576
    {  8, 0x67 },       // 01100111        640
    {  9, 0xcc },       // 011001100       704
    {  9, 0xcd },       // 011001101       768
    {  9, 0xd2 },       // 011010010       832
    {  9, 0xd3 },       // 011010011       896
    {  9, 0xd4 },       // 011010100       960
    {  9, 0xd5 },       // 011010101      1024
    {  9, 0xd6 },       // 011010110      1088
    {  9, 0xd7 },       // 011010111      1152
    {  9, 0xd8 },       // 011011000      1216
    {  9, 0xd9 },       // 011011001      1280
    {  9, 0xda },       // 011011010      1344
    {  9, 0xdb },       // 011011011      1408
    {  9, 0x98 },       // 010011000      1472
    {  9, 0x99 },       // 010011001      1536
    {  9, 0x9a },       // 010011010      1600
    {  6, 0x18 },       // 011000         1664
    {  9, 0x9b },       // 010011011      1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

//
// Code table for black runs
//

static const CODETABLE BlackRunCodes[] = {
    
    { 10, 0x37 },       // 0000110111        0
    {  3, 0x02 },       // 010               1
    {  2, 0x03 },       // 11                2
    {  2, 0x02 },       // 10                3
    {  3, 0x03 },       // 011               4
    {  4, 0x03 },       // 0011              5
    {  4, 0x02 },       // 0010              6
    {  5, 0x03 },       // 00011             7
    {  6, 0x05 },       // 000101            8
    {  6, 0x04 },       // 000100            9
    {  7, 0x04 },       // 0000100          10
    {  7, 0x05 },       // 0000101          11
    {  7, 0x07 },       // 0000111          12
    {  8, 0x04 },       // 00000100         13
    {  8, 0x07 },       // 00000111         14
    {  9, 0x18 },       // 000011000        15
    { 10, 0x17 },       // 0000010111       16
    { 10, 0x18 },       // 0000011000       17
    { 10, 0x08 },       // 0000001000       18
    { 11, 0x67 },       // 00001100111      19
    { 11, 0x68 },       // 00001101000      20
    { 11, 0x6c },       // 00001101100      21
    { 11, 0x37 },       // 00000110111      22
    { 11, 0x28 },       // 00000101000      23
    { 11, 0x17 },       // 00000010111      24
    { 11, 0x18 },       // 00000011000      25
    { 12, 0xca },       // 000011001010     26
    { 12, 0xcb },       // 000011001011     27
    { 12, 0xcc },       // 000011001100     28
    { 12, 0xcd },       // 000011001101     29
    { 12, 0x68 },       // 000001101000     30
    { 12, 0x69 },       // 000001101001     31
    { 12, 0x6a },       // 000001101010     32
    { 12, 0x6b },       // 000001101011     33
    { 12, 0xd2 },       // 000011010010     34
    { 12, 0xd3 },       // 000011010011     35
    { 12, 0xd4 },       // 000011010100     36
    { 12, 0xd5 },       // 000011010101     37
    { 12, 0xd6 },       // 000011010110     38
    { 12, 0xd7 },       // 000011010111     39
    { 12, 0x6c },       // 000001101100     40
    { 12, 0x6d },       // 000001101101     41
    { 12, 0xda },       // 000011011010     42
    { 12, 0xdb },       // 000011011011     43
    { 12, 0x54 },       // 000001010100     44
    { 12, 0x55 },       // 000001010101     45
    { 12, 0x56 },       // 000001010110     46
    { 12, 0x57 },       // 000001010111     47
    { 12, 0x64 },       // 000001100100     48
    { 12, 0x65 },       // 000001100101     49
    { 12, 0x52 },       // 000001010010     50
    { 12, 0x53 },       // 000001010011     51
    { 12, 0x24 },       // 000000100100     52
    { 12, 0x37 },       // 000000110111     53
    { 12, 0x38 },       // 000000111000     54
    { 12, 0x27 },       // 000000100111     55
    { 12, 0x28 },       // 000000101000     56
    { 12, 0x58 },       // 000001011000     57
    { 12, 0x59 },       // 000001011001     58
    { 12, 0x2b },       // 000000101011     59
    { 12, 0x2c },       // 000000101100     60
    { 12, 0x5a },       // 000001011010     61
    { 12, 0x66 },       // 000001100110     62
    { 12, 0x67 },       // 000001100111     63
    { 10, 0x0f },       // 0000001111       64
    { 12, 0xc8 },       // 000011001000    128
    { 12, 0xc9 },       // 000011001001    192
    { 12, 0x5b },       // 000001011011    256
    { 12, 0x33 },       // 000000110011    320
    { 12, 0x34 },       // 000000110100    384
    { 12, 0x35 },       // 000000110101    448
    { 13, 0x6c },       // 0000001101100   512
    { 13, 0x6d },       // 0000001101101   576
    { 13, 0x4a },       // 0000001001010   640
    { 13, 0x4b },       // 0000001001011   704
    { 13, 0x4c },       // 0000001001100   768
    { 13, 0x4d },       // 0000001001101   832
    { 13, 0x72 },       // 0000001110010   896
    { 13, 0x73 },       // 0000001110011   960
    { 13, 0x74 },       // 0000001110100  1024
    { 13, 0x75 },       // 0000001110101  1088
    { 13, 0x76 },       // 0000001110110  1152
    { 13, 0x77 },       // 0000001110111  1216
    { 13, 0x52 },       // 0000001010010  1280
    { 13, 0x53 },       // 0000001010011  1344
    { 13, 0x54 },       // 0000001010100  1408
    { 13, 0x55 },       // 0000001010101  1472
    { 13, 0x5a },       // 0000001011010  1536
    { 13, 0x5b },       // 0000001011011  1600
    { 13, 0x64 },       // 0000001100100  1664
    { 13, 0x65 },       // 0000001100101  1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

#ifdef USELSB

//
// Table used to reverse fill order from MSB to LSB
//

static const BYTE BitReverseTable[256] = {

    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

#endif

#endif	// !_FAXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxmon\tiffstub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiffstub.h

Abstract:

    Miminal set of declarations for dealing with TIFF files. We need this in the
    monitor because a fax print job may consist of several TIFF files concatenated
    together. We must patch it up into a single valid TIFF before passing it to
    the fax service.

Environment:

	Windows XP fax print monitor

Revision History:

	02/25/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _TIFFSTUB_H_
#define _TIFFSTUB_H_

//
// Constants for various TIFF data types
//

#define TIFFTYPE_BYTE       1
#define TIFFTYPE_ASCII      2
#define TIFFTYPE_SHORT      3
#define TIFFTYPE_LONG       4
#define TIFFTYPE_RATIONAL   5
#define TIFFTYPE_SBYTE      6
#define TIFFTYPE_UNDEFINED  7
#define TIFFTYPE_SSHORT     8
#define TIFFTYPE_SLONG      9
#define TIFFTYPE_SRATIONAL  10
#define TIFFTYPE_FLOAT      11
#define TIFFTYPE_DOUBLE     12

//
// Constants for TIFF tags which we're interested in
//

#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_STRIPBYTECOUNTS     279

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY;

typedef IFDENTRY UNALIGNED *PIFDENTRY_UNALIGNED;

//
// Data structure for representing an IFD
//

typedef struct {

    WORD        wEntries;
    IFDENTRY    ifdEntries[1];

} IFD;

typedef IFD UNALIGNED *PIFD_UNALIGNED;

//
// Determine whether we're at the beginning of a TIFF file
//

#define ValidTiffFileHeader(p) \
        (((LPSTR) (p))[0] == 'I' && ((LPSTR) (p))[1] == 'I' && \
         ((PBYTE) (p))[2] == 42  && ((PBYTE) (p))[3] == 0)

//
// Read a DWORD value from an unaligned address
//

#define ReadUnalignedDWord(p) *((DWORD UNALIGNED *) (p))

//
// Write a DWORD value to an unaligned address
//

#define WriteUnalignedDWord(p, value) (*((DWORD UNALIGNED *) (p)) = (value))

#endif	// !_TIFFSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\faxdrv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    faxdrv.h

Abstract:

    Fax driver graphics DLL header file

[Environment:]

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    20/10/99 -danl-
        Organize DEVDATA for 95 use.

    dd/mm/yy -author-
        description

--*/


#ifndef _FAXDRV_H_
#define _FAXDRV_H_

#include "faxlib.h"


//
// Data structure maintained by the fax driver graphics DLL
//

typedef struct {

    PVOID       startDevData;   // data structure signature

    HANDLE      hPrinter;       // handle to printer

#ifdef USERMODE_DRIVER
    HANDLE      hPreviewFile;   // handle to print preview mapping file
#endif

    HANDLE      hPreviewMapping;// handle to print preview mapping object
    PMAP_TIFF_PAGE_HEADER pTiffPageHeader;  // points to the header of the mapping file
    LPBYTE      pbTiffPageFP;   // The mapping virutal 'File Pointer'.
    BOOL        bPrintPreview;  // Indicates print preview is requested
    DRVDEVMODE  dm;             // devmode information
    INT         pageCount;      // number of pages printed
    LONG        lineOffset;     // bitmap scanline byte offset
    DWORD       flags;          // flag bits
    SIZEL       imageSize;      // image size measured in pixels

#ifndef WIN__95
    HDEV        hdev;           // handle to GDI device
    HANDLE      hpal;           // handle to default palette
    SIZEL       paperSize;      // paper size measured in pixels
    RECTL       imageArea;      // imageable area measured in pixels
    LONG        xres, yres;     // x- and y-resolution
    HSURF       hbitmap;        // handle to bitmap surface
    DWORD       jobId;          // job ID
#endif //WIN__95

    DWORD       fileOffset;     // output byte count for current document
    PBYTE       pCompBits;      // buffer to hold G4 compressed bitmap data
    PBYTE       pCompBufPtr;    // pointer to next free byte in the buffer
    PBYTE       pCompBufMark;   // high-water mark
    DWORD       compBufSize;    // size of compressed bitmap data buffer
    DWORD       compBufInc;     // increment to enlarge the buffer when necessary
    PBYTE       prefline;       // raster data for the reference line
    INT         bitcnt;         // these two fields are used for assembling variable-length
    DWORD       bitdata;        // compressed bits into byte stream
    PVOID       pFaxIFD;        // IFD entries for each page

    PVOID       endDevData;     // data structure signature

} DEVDATA, *PDEVDATA;

//
// Constants for DEVDATA.flags field
//

#define PDEV_CANCELLED  0x0001  // current job has been cancelled
#define PDEV_RESETPDEV  0x0002  // DrvResetPDEV has been called
#define PDEV_WITHINPAGE 0x0004  // drawing on a page

//
// Check if a DEVDATA structure is valid
//

#define ValidDevData(pdev)  \
        ((pdev) && (pdev)->startDevData == (pdev) && (pdev)->endDevData == (pdev))

//
// Color values and indices
//

#define RGB_BLACK   RGB(0, 0, 0)
#define RGB_WHITE   RGB(255, 255, 255)

#define BLACK_INDEX 0
#define WHITE_INDEX 1

//
// Number of bits consisting a BYTE and a DWORD
//

#define BYTEBITS    8
#define DWORDBITS   (sizeof(DWORD) * BYTEBITS)

//
// Pad bit scanline data to N-byte boundary
//

#define PadBitsToBytes(bits, N) \
        ((((bits) + ((N) * BYTEBITS - 1)) / ((N) * BYTEBITS)) * (N))

//
// Macros for manipulating ROP4s and ROP3s
//

#define GetForegroundRop3(rop4) ((rop4) & 0xFF)
#define GetBackgroundRop3(rop4) (((rop4) >> 8) & 0xFF)
#define Rop3NeedPattern(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define Rop3NeedSource(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define Rop3NeedDest(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))

//
// Determine whether the page is in landscape mode
//

#define IsLandscapeMode(pdev)   ((pdev)->dm.dmPublic.dmOrientation == DMORIENT_LANDSCAPE)

//
// Returns the length of the hypotenouse of a right triangle
//

LONG
CalcHypot(
    LONG    x,
    LONG    y
    );

//
// Output a completed page bitmap to the spooler
//

BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    );

//
// Output document trailer information to the spooler
//

BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    );

#endif // !_FAXDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\faxtiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.c

Abstract:

    Functions to compress the bitmap bits using CCITT Group3 2-dimensional coding
    and output the resulting data as TIFF-F file.

Environment:

        Windows XP fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

#include "faxdrv.h"
#include "faxtiff.h"
#include "faxtable.h"



BOOL
WriteData(
    PDEVDATA    pdev,
    PVOID       pbuf,
    DWORD       cbbuf
    )

/*++

Routine Description:

    Output a buffer of data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pbuf - Points to data buffer
    cbbuf - Number of bytes in the buffer

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    DWORD   cbwritten;

    //
    // Stop if the document has been cancelled.
    //
    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Send output to spooler directly
    //

    if (! WritePrinter(pdev->hPrinter, pbuf, cbbuf, &cbwritten) || cbbuf != cbwritten) {
        Error(("WritePrinter failed\n"));
        pdev->flags |= PDEV_CANCELLED;

        // Abort preview as well - just in case ...
        if (pdev->bPrintPreview)
        {
            Assert(pdev->pTiffPageHeader);
            pdev->pTiffPageHeader->bPreview = FALSE;
            pdev->bPrintPreview = FALSE;
        }
        return FALSE;
    }

    //
    // If print preview is enabled, send a copy to our preview page
    //
    if (pdev->bPrintPreview)
    {
        Assert(pdev->pTiffPageHeader);
        Assert(pdev->pbTiffPageFP == 
            ((LPBYTE) (pdev->pTiffPageHeader + 1)) + pdev->pTiffPageHeader->dwDataSize);

        //
        // Add the bits in if we don't overflow
        //
        if (pdev->pTiffPageHeader->dwDataSize + cbbuf >
                MAX_TIFF_PAGE_SIZE - sizeof(MAP_TIFF_PAGE_HEADER))
        {
            Error(("MAX_TIFF_PAGE_SIZE exeeded!\n"));

            //
            // Cancel print preview for this document
            //
            pdev->pTiffPageHeader->bPreview = FALSE;
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            CopyMemory(pdev->pbTiffPageFP, pbuf, cbbuf);
            pdev->pbTiffPageFP += cbbuf;
            pdev->pTiffPageHeader->dwDataSize += cbbuf;
        }
    }

    pdev->fileOffset += cbbuf;
    return TRUE;
}



PDWORD
CalcXposeMatrix(
    VOID
    )

/*++

Routine Description:

    Generate the transpose matrix for rotating landscape bitmaps

Arguments:

    NONE

Return Value:

    Pointer to the generated transpose matrix
    NULL if there is an error

--*/

{
    static DWORD templateData[16] = {

        /* 0000 */  0x00000000,
        /* 0001 */  0x00000001,
        /* 0010 */  0x00000100,
        /* 0011 */  0x00000101,
        /* 0100 */  0x00010000,
        /* 0101 */  0x00010001,
        /* 0110 */  0x00010100,
        /* 0111 */  0x00010101,
        /* 1000 */  0x01000000,
        /* 1001 */  0x01000001,
        /* 1010 */  0x01000100,
        /* 1011 */  0x01000101,
        /* 1100 */  0x01010000,
        /* 1101 */  0x01010001,
        /* 1110 */  0x01010100,
        /* 1111 */  0x01010101
    };

    PDWORD  pdwXpose, pTemp;
    INT     index;

    //
    // First check if the transpose matrix has been generated already
    //

    if (pdwXpose = MemAlloc(sizeof(DWORD) * 2 * (1 << BYTEBITS))) {

        for (index=0, pTemp=pdwXpose; index < (1 << BYTEBITS); index++, pTemp++) {

            pTemp[0] = templateData[index >> 4];
            pTemp[1 << BYTEBITS] = templateData[index & 0xf];
        }
    }

    return pdwXpose;
}



BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    )

/*++

Routine Description:

    Output a completed page bitmap to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pBitmapData - Points to bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LONG    bmpWidth, bmpHeight;
    BOOL    result;
    DWORD   compressedBytes;

    Verbose(("Sending page %d...\n", pdev->pageCount));
    Assert(pdev->pCompBits == NULL);

    //
    // For portrait output, encode the entire bitmap in one shot
    // For landscape output, we need to rotate the bitmap here:
    //  Generate the transpose matrix and allocate a
    //  temporary buffer large enough to hold 8 scanlines
    //

    if (IsLandscapeMode(pdev)) {

        bmpWidth = pdev->imageSize.cy;
        bmpHeight = pdev->imageSize.cx;

    } else {

        bmpWidth = pdev->imageSize.cx;
        bmpHeight = pdev->imageSize.cy;
    }

    //
    // Initialize fax encodier
    //

    if (! InitFaxEncoder(pdev, bmpWidth, bmpHeight))
        return FALSE;

    if (! IsLandscapeMode(pdev)) {

        LONG    dwordCount;
        PDWORD  pBits;

        //
        // Invert the entire page bitmap in memory
        //

        Assert(bmpWidth % DWORDBITS == 0);
        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        //
        // Compress the page bitmap
        //

        result = EncodeFaxData(pdev, pBitmapData, bmpWidth, bmpHeight);

        //
        // Restore the original page bitmap
        //

        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        if (! result) {

            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

    } else {

        register PDWORD pdwXposeHigh, pdwXposeLow;
        register DWORD  dwHigh, dwLow;
        PBYTE           pBuffer, pbCol;
        LONG            deltaNew;

        //
        // Calculate the transpose matrix for fast bitmap rotation
        //

        if (!(pdwXposeHigh = CalcXposeMatrix()) || !(pBuffer = MemAllocZ(bmpWidth))) {

            MemFree(pdwXposeHigh);
            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

        pdwXposeLow = pdwXposeHigh + (1 << BYTEBITS);

        //
        // During each iteration thru the following loop, we will process
        // one byte column and generate 8 rotated scanlines.
        //

        Assert(bmpHeight % BYTEBITS == 0);
        Assert(bmpWidth  % DWORDBITS == 0);

        deltaNew = bmpWidth / BYTEBITS;
        pbCol = pBitmapData + (bmpHeight / BYTEBITS - 1);

        do {

            PBYTE   pbWrite = pBuffer;
            PBYTE   pbTemp = pbCol;
            LONG    loopCount = deltaNew;

            while (loopCount--) {

                //
                // Rotate the next 8 bytes in the current column
                // Unroll the loop here in hopes of faster execution
                //

                dwHigh = pdwXposeHigh[*pbTemp];
                dwLow  = pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                //
                // Invert black and white pixel polarity
                //

                dwHigh ^= 0xffffffff;
                dwLow  ^= 0xffffffff;

                //
                // Distribute the resulting byte to 8 separate scanlines
                //

                *pbWrite = (BYTE) dwLow;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*3);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) dwHigh;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*3);
                pbWrite -= (deltaNew * BYTEBITS - deltaNew - 1);
            }

            //
            // Encode the next band of scanlines
            //

            if (! EncodeFaxData(pdev, pBuffer, bmpWidth, BYTEBITS)) {

                MemFree(pdwXposeHigh);
                MemFree(pBuffer);
                FreeCompBitsBuffer(pdev);
                return FALSE;
            }

        } while (pbCol-- != pBitmapData);

        MemFree(pdwXposeHigh);
        MemFree(pBuffer);
    }

    //
    // Output EOB (two EOLs) after the last scanline
    // and make sure the compressed data is WORD aligned
    //

    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    FlushBits(pdev);

    if ((compressedBytes = (DWORD)(pdev->pCompBufPtr - pdev->pCompBits)) & 1) {

        *pdev->pCompBufPtr++ = 0;
        compressedBytes++;
    }

    //
    // Output the IFD for the previous page and generate the IFD for the current page
    // Output the compressed bitmap data
    //

    result = WriteTiffIFD(pdev, bmpWidth, bmpHeight, compressedBytes) &&
             WriteTiffBits(pdev, pdev->pCompBits, compressedBytes);

    FreeCompBitsBuffer(pdev);

    return result;
}



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}



INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}



VOID
OutputRun(
    PDEVDATA    pdev,
    INT         run,
    PCODETABLE  pCodeTable
    )

/*++

Routine Description:

    Output a single run (black or white) using the specified code table

Arguments:

    pdev - Points to our DEVDATA structure
    run - Specifies the length of the run
    pCodeTable - Specifies the code table to use

Return Value:

    NONE

--*/

{
    PCODETABLE  pTableEntry;

    //
    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.
    //

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run -= 2560;
    }

    //
    // Use appropriate make-up code word if the run is longer than 63 pixels
    //

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run &= 0x3f;
    }

    //
    // Output terminating code word
    //

    OutputBits(pdev, pCodeTable[run].length, pCodeTable[run].code);
}



#ifdef USE1D

VOID
OutputEOL(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output EOL code at the beginning of each scanline

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    DWORD   length, code;

    //
    // EOL code word always ends on a byte boundary
    //

    code = EOL_CODE;
    length = EOL_LENGTH + ((pdev->bitcnt - EOL_LENGTH) & 7);
    OutputBits(pdev, length, code);
}


BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     bitIndex, run;

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Output byte-aligned EOL code
        //

        OutputEOL(pdev);

        //
        // Use 1-dimensional encoding scheme
        //

        bitIndex = 0;

        while (TRUE) {

            //
            // Code white run
            //

            run = FindWhiteRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, WhiteRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;

            //
            // Code black run
            //

            run = FindBlackRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, BlackRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;
        }

        //
        // Move on to the next scanline
        //

        plinebuf += delta;
    }

    return TRUE;
}



#else //!USE1D

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     a0, a1, a2, b1, b2, distance;
    PBYTE   prefline = pdev->prefline;

    Assert(lineWidth % BYTEBITS == 0);

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Use 2-dimensional encoding scheme
        //

        a0 = 0;
        a1 = GetBit(plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0);
        b1 = GetBit(prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0);

        while (TRUE) {

            b2 = (b1 >= lineWidth) ? lineWidth :
                    NextChangingElement(prefline, b1, lineWidth, GetBit(prefline, b1));

            if (b2 < a1) {

                //
                // Pass mode
                //

                OutputBits(pdev, PASSCODE_LENGTH, PASSCODE);
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                OutputBits(pdev, VertCodes[distance+3].length, VertCodes[distance+3].code);
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= lineWidth) ? lineWidth :
                        NextChangingElement(plinebuf, a1, lineWidth, GetBit(plinebuf, a1));

                OutputBits(pdev, HORZCODE_LENGTH, HORZCODE);

                if (a1 != 0 && GetBit(plinebuf, a0)) {

                    OutputRun(pdev, a1-a0, BlackRunCodes);
                    OutputRun(pdev, a2-a1, WhiteRunCodes);

                } else {

                    OutputRun(pdev, a1-a0, WhiteRunCodes);
                    OutputRun(pdev, a2-a1, BlackRunCodes);
                }

                a0 = a2;
            }

            if (a0 >= lineWidth)
                break;

            a1 = NextChangingElement(plinebuf, a0, lineWidth, GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, a0, lineWidth, !GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, b1, lineWidth, GetBit(plinebuf, a0));
        }

        //
        // Move on to the next scanline
        //

        prefline = plinebuf;
        plinebuf += delta;
    }

    //
    // Remember the last line as a reference
    //

    CopyMemory(pdev->prefline, prefline, delta);

    return TRUE;
}

#endif //!USE1D



//
// IFD entries we generate for each page
//

WORD FaxIFDTags[NUM_IFD_ENTRIES] = {

    TIFFTAG_NEWSUBFILETYPE,
    TIFFTAG_IMAGEWIDTH,
    TIFFTAG_IMAGEHEIGHT,
    TIFFTAG_BITSPERSAMPLE,
    TIFFTAG_COMPRESSION,
    TIFFTAG_PHOTOMETRIC,
    TIFFTAG_FILLORDER,
    TIFFTAG_STRIPOFFSETS,
    TIFFTAG_SAMPLESPERPIXEL,
    TIFFTAG_ROWSPERSTRIP,
    TIFFTAG_STRIPBYTECOUNTS,
    TIFFTAG_XRESOLUTION,
    TIFFTAG_YRESOLUTION,
#ifdef USE1D
    TIFFTAG_G3OPTIONS,
#else
    TIFFTAG_G4OPTIONS,
#endif
    TIFFTAG_RESUNIT,
    TIFFTAG_PAGENUMBER,
    TIFFTAG_SOFTWARE,
    TIFFTAG_CLEANFAXDATA,
};

static FAXIFD FaxIFDTemplate = {

    0,
    NUM_IFD_ENTRIES,

    {
        { TIFFTAG_NEWSUBFILETYPE, TIFFTYPE_LONG, 1, SUBFILETYPE_PAGE },
        { TIFFTAG_IMAGEWIDTH, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_IMAGEHEIGHT, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_BITSPERSAMPLE, TIFFTYPE_SHORT, 1, 1 },
#ifdef USE1D
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G3FAX },
#else
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G4FAX },
#endif
        { TIFFTAG_PHOTOMETRIC, TIFFTYPE_SHORT, 1, PHOTOMETRIC_WHITEIS0 },
#ifdef USELSB
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_LSB },
#else
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_MSB },
#endif
        { TIFFTAG_STRIPOFFSETS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_SAMPLESPERPIXEL, TIFFTYPE_SHORT, 1, 1 },
        { TIFFTAG_ROWSPERSTRIP, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_STRIPBYTECOUNTS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_XRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
        { TIFFTAG_YRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
#ifdef USE1D
        { TIFFTAG_G3OPTIONS, TIFFTYPE_LONG, 1, G3_ALIGNEOL },
#else
        { TIFFTAG_G4OPTIONS, TIFFTYPE_LONG, 1, 0 },
#endif
        { TIFFTAG_RESUNIT, TIFFTYPE_SHORT, 1, RESUNIT_INCH },
        { TIFFTAG_PAGENUMBER, TIFFTYPE_SHORT, 2, 0 },
        { TIFFTAG_SOFTWARE, TIFFTYPE_ASCII, sizeof(FAX_DRIVER_NAME_A)+1, 0 },
        { TIFFTAG_CLEANFAXDATA, TIFFTYPE_SHORT, 1, 0 },
    },

    0,
    DRIVER_SIGNATURE,
    TIFFF_RES_X,
    1,
    TIFFF_RES_Y,
    1,
    FAX_DRIVER_NAME_A
};



BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output document trailer information to the spooler

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;

    if (pFaxIFD == NULL || pdev->pageCount == 0)
        return TRUE;

    //
    // Output the IFD for the last page of the document
    //

    pFaxIFD->nextIFDOffset = pFaxIFD->filler = 0;

    return WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
}



BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the IFD for the previous page and generate the IFD for the current page

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap image
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;
    ULONG_PTR   offset;
    BOOL    result = TRUE;

    //
    // Create the IFD data structure if necessary
    //

    if (pFaxIFD == NULL) {

        if (! (pFaxIFD = MemAlloc(sizeof(FAXIFD))))
            return FALSE;

        pdev->pFaxIFD = pFaxIFD;
        memcpy(pFaxIFD, &FaxIFDTemplate, sizeof(FAXIFD));

        #if DBG

        for (offset=0; offset < NUM_IFD_ENTRIES; offset++) {

            Assert(pFaxIFD->ifd[offset].tag == FaxIFDTags[offset]);
        }

        #endif
    }

    if (pdev->pageCount <= 1) {

        //
        // If this is the very first page, there is no previous IFD.
        // Output the TIFF file header instead.
        //

        TIFFFILEHEADER *pTiffFileHeader;

        pdev->fileOffset = 0;

        if (pTiffFileHeader = MemAlloc(sizeof(TIFFFILEHEADER))) {

            pTiffFileHeader->magic1 = TIFF_MAGIC1;
            pTiffFileHeader->magic2 = TIFF_MAGIC2;
            pTiffFileHeader->signature = DRIVER_SIGNATURE;
            pTiffFileHeader->firstIFD = sizeof(TIFFFILEHEADER) +
                                        compressedBytes +
                                        offsetof(FAXIFD, wIFDEntries);

            result = WriteData(pdev, pTiffFileHeader, sizeof(TIFFFILEHEADER));
            MemFree(pTiffFileHeader);

        } else {

            Error(("Memory allocation failed\n"));
            result = FALSE;
        }

    } else {

        //
        // Not the first page of the document
        // Output the IFD for the previous page
        //

        pFaxIFD->nextIFDOffset = pdev->fileOffset + compressedBytes + sizeof(FAXIFD) +
                                 offsetof(FAXIFD, wIFDEntries);

        result = WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
    }

    //
    // Generate the IFD for the current page
    //

    offset = pdev->fileOffset;

    pFaxIFD->ifd[IFD_PAGENUMBER].value = MAKELONG(pdev->pageCount-1, 0);
    pFaxIFD->ifd[IFD_IMAGEWIDTH].value = bmpWidth;
    pFaxIFD->ifd[IFD_IMAGEHEIGHT].value = bmpHeight;
    pFaxIFD->ifd[IFD_ROWSPERSTRIP].value = bmpHeight;
    pFaxIFD->ifd[IFD_STRIPBYTECOUNTS].value = compressedBytes;
    pFaxIFD->ifd[IFD_STRIPOFFSETS].value = (ULONG)offset;
    offset += compressedBytes;

    pFaxIFD->ifd[IFD_XRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, xresNum);
    pFaxIFD->ifd[IFD_YRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, yresNum);
    pFaxIFD->ifd[IFD_SOFTWARE].value = (ULONG)offset + offsetof(FAXIFD, software);

    pFaxIFD->yresNum = (pdev->dm.dmPublic.dmYResolution == FAXRES_VERTDRAFT) ?
                            TIFFF_RES_Y_DRAFT :
                            TIFFF_RES_Y;

    return result;
}



BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the compressed bitmap data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pCompBits - Points to a buffer containing compressed bitmap data
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define OUTPUT_BUFFER_SIZE  4096

{
    PBYTE   pBuffer;
    DWORD   bytesToWrite;

#ifndef USERMODE_DRIVER
    //
    // Since we allocated the compressed bitmap data buffer from
    // the user mode memory space, we couldn't passed it directly
    // to EngWritePrinter.
    //
    // Here we allocate a temporary buffer from kernel mode memory
    // space and output the compressed data one buffer at a time.
    //

    if (! (pBuffer = MemAlloc(OUTPUT_BUFFER_SIZE))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    while (compressedBytes > 0) {

        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);
        CopyMemory(pBuffer, pCompBits, bytesToWrite);

        if (! WriteData(pdev, pBuffer, bytesToWrite)) {

            MemFree(pBuffer);
            return FALSE;
        }

        pCompBits += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    MemFree(pBuffer);
    return TRUE;
#else
    //
    // just dump the data in OUTPUT_BUFFER_SIZE increments
    //
    pBuffer = pCompBits;
    while (compressedBytes > 0) {
        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);

        if (! WriteData(pdev, pBuffer, bytesToWrite) ) {
            return FALSE;
        }

        pBuffer += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    return TRUE;    
#endif

}



BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    )

/*++

Routine Description:

    Enlarge the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure
    scanlineSize - Number of uncompressed bytes per scanline

Return Value:

    TRUE if successful, FALSE if memory allocation fails

--*/

{
    DWORD   oldBufferSize;
    PBYTE   pNewBuffer;

    //
    // Allocate a new buffer which is one increment larger than existing one
    //

    oldBufferSize = pdev->pCompBits ? pdev->compBufSize : 0;
    pdev->compBufSize = oldBufferSize + pdev->compBufInc;

    if (! (pNewBuffer = MemAlloc(pdev->compBufSize))) {

        Error(("MemAlloc failed\n"));
        FreeCompBitsBuffer(pdev);
        return FALSE;
    }

    if (pdev->pCompBits) {

        //
        // Growing an existing buffer
        //

        Warning(("Growing compressed bitmap buffer: %d -> %d\n", oldBufferSize, pdev->compBufSize));

        memcpy(pNewBuffer, pdev->pCompBits, oldBufferSize);
        pdev->pCompBufPtr = pNewBuffer + (pdev->pCompBufPtr - pdev->pCompBits);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pNewBuffer;

    } else {

        //
        // First time allocation
        //

        pdev->pCompBufPtr = pdev->pCompBits = pNewBuffer;
    }

    //
    // Set a high-water mark to about 4 scanlines before the end of the buffer
    //

    pdev->pCompBufMark = pdev->pCompBits + (pdev->compBufSize - 4*scanlineSize);

    return TRUE;
}



VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->pCompBits) {

        MemFree(pdev->prefline);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pdev->pCompBufPtr = NULL;
        pdev->compBufSize = 0;
    }
}



BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    )

/*++

Routine Description:

    Initialize the fax encoder

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Calculate the increment in which to enlarge the compressed bits buffer:
    //  about 1/4 of the uncompressed bitmap buffer
    //

    bmpWidth /= BYTEBITS;
    pdev->compBufInc = bmpWidth * bmpHeight / 4;

    //
    // Allocate the initial buffer
    //

    if (! (pdev->prefline = MemAllocZ(bmpWidth)) ||
        ! GrowCompBitsBuffer(pdev, bmpWidth))
    {
        MemFree(pdev->prefline);
        return FALSE;
    }

    //
    // Perform other initialization of fax encoder
    //

    pdev->bitdata = 0;
    pdev->bitcnt = DWORDBITS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\faxtiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    Declarations for Group3 2D compression and generating TIFF files

Environment:

        Windows XP Fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

NOTE:

    Structure of the TIFF output file from the driver:

    4949        II
    002a        42
    00000008    Offset to the first IFD

    IFD for the first page

    Number of directory entries
    NEWSUBFILETYPE  LONG     1  2 - Page in a multi-page document
    PAGENUMBER      SHORT    2  PageNumber 0000
    IMAGEWIDTH      LONG     1  ImageWidth
    IMAGEHEIGHT     LONG     1  ImageHeight
    BITSPERSAMPLE   SHORT    1  1
    SAMPLESPERPIXEL SHORT    1  1
    COMPRESSION     SHORT    1  4 - G4Fax
    GROUP4OPTIONS   SHORT    1  0
    CLEANFAXDATA    SHORT    1  0
    FILLORDER       SHORT    1  2
    PHOTOMETRIC     SHORT    1  0 - WhiteIsZero
    RESOLUTIONUNIT  SHORT    1  2 - Inch
    XRESOLUTION     RATIONAL 1  Xdpi
    YRESOLUTION     RATIONAL 1  Ydpi
    ROWSPERSTRIP    LONG     1  ImageHeight
    STRIPBYTECOUNTS LONG     1  Compressed data byte count
    STRIPOFFSETS    LONG     1  Offset to compressed data
    Next IFD offset
    Compressed data for the first page

    IFD for the second page
    Compressed data for the second page
    ...

    Last IFD

    0001
    SOFTWARE        ASCII    n  "Microsoft Shared Fax Driver"
    00000000
    00000000

--*/

#ifndef _FAXTIFF_H_
#define _FAXTIFF_H_

//
// TIFF field tag and type constants
//

#define TIFFTYPE_ASCII              2
#define TIFFTYPE_SHORT              3
#define TIFFTYPE_LONG               4
#define TIFFTYPE_RATIONAL           5

#define TIFFTAG_NEWSUBFILETYPE      254
#define     SUBFILETYPE_PAGE        2
#define TIFFTAG_IMAGEWIDTH          256
#define TIFFTAG_IMAGEHEIGHT         257
#define TIFFTAG_BITSPERSAMPLE       258
#define TIFFTAG_COMPRESSION         259
#define     COMPRESSION_G3FAX       3
#define     COMPRESSION_G4FAX       4
#define TIFFTAG_PHOTOMETRIC         262
#define     PHOTOMETRIC_WHITEIS0    0
#define     PHOTOMETRIC_BLACKIS0    1
#define TIFFTAG_FILLORDER           266
#define     FILLORDER_MSB           1
#define     FILLORDER_LSB           2
#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_SAMPLESPERPIXEL     277
#define TIFFTAG_ROWSPERSTRIP        278
#define TIFFTAG_STRIPBYTECOUNTS     279
#define TIFFTAG_XRESOLUTION         282
#define     TIFFF_RES_X             204
#define TIFFTAG_YRESOLUTION         283
#define     TIFFF_RES_Y             196
#define     TIFFF_RES_Y_DRAFT       98
#define TIFFTAG_G3OPTIONS           292
#define     G3_2D                   1
#define     G3_ALIGNEOL             4
#define TIFFTAG_G4OPTIONS           293
#define TIFFTAG_RESUNIT             296
#define     RESUNIT_INCH            2
#define TIFFTAG_PAGENUMBER          297
#define TIFFTAG_SOFTWARE            305
#define TIFFTAG_CLEANFAXDATA        327

//
// Data structure for representing our TIFF output file header information
//

typedef struct {

    WORD    magic1;     // II
    WORD    magic2;     // 42
    LONG    firstIFD;   // offset to first IFD
    DWORD   signature;  // driver private signature

} TIFFFILEHEADER;

#define TIFF_MAGIC1     'II'
#define TIFF_MAGIC2     42

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY, *PIFDENTRY;

//
// IFD entries we generate for each page
//

enum {

    IFD_NEWSUBFILETYPE,
    IFD_IMAGEWIDTH,
    IFD_IMAGEHEIGHT,
    IFD_BITSPERSAMPLE,
    IFD_COMPRESSION,
    IFD_PHOTOMETRIC,
    IFD_FILLORDER,
    IFD_STRIPOFFSETS,
    IFD_SAMPLESPERPIXEL,
    IFD_ROWSPERSTRIP,
    IFD_STRIPBYTECOUNTS,
    IFD_XRESOLUTION,
    IFD_YRESOLUTION,
    IFD_G3G4OPTIONS,
    IFD_RESUNIT,
    IFD_PAGENUMBER,
    IFD_SOFTWARE,
    IFD_CLEANFAXDATA,

    NUM_IFD_ENTRIES
};

typedef struct {

    WORD        reserved;
    WORD        wIFDEntries;
    IFDENTRY    ifd[NUM_IFD_ENTRIES];
    DWORD       nextIFDOffset;
    DWORD       filler;
    DWORD       xresNum;
    DWORD       xresDenom;
    DWORD       yresNum;
    DWORD       yresDenom;
    CHAR        software[32];

} FAXIFD, *PFAXIFD;

//
// Output compressed data bytes in correct fill order
//

#ifdef USELSB

#define OutputByte(n)   BitReverseTable[(BYTE) (n)]

#else

#define OutputByte(n)   ((BYTE) (n))

#endif

//
// Output a sequence of compressed bits
//

#define OutputBits(pdev, length, code) { \
            (pdev)->bitdata |= (code) << ((pdev)->bitcnt - (length)); \
            if (((pdev)->bitcnt -= (length)) <= 2*BYTEBITS) { \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 2*BYTEBITS)); \
                (pdev)->bitdata <<= 2*BYTEBITS; \
                (pdev)->bitcnt += 2*BYTEBITS; \
            } \
        }

//
// Flush any leftover bits into the compressed bitmap buffer
//

#define FlushBits(pdev) { \
            while ((pdev)->bitcnt < DWORDBITS) { \
                (pdev)->bitcnt += BYTEBITS; \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                (pdev)->bitdata <<= BYTEBITS; \
            } \
            (pdev)->bitdata = 0; \
            (pdev)->bitcnt = DWORDBITS; \
        }

//
// Find the next pixel on the scanline whose color is opposite of
// the specified color, starting from the specified starting point
//

#define NextChangingElement(pbuf, startBit, stopBit, isBlack) \
        ((startBit) + ((isBlack) ? FindBlackRun((pbuf), (startBit), (stopBit)) : \
                                   FindWhiteRun((pbuf), (startBit), (stopBit))))

//
// Check if the specified pixel on the scanline is black or white
//  1 - the specified pixel is black
//  0 - the specified pixel is white
//

#define GetBit(pbuf, bit)   (((pbuf)[(bit) >> 3] >> (((bit) ^ 7) & 7)) & 1)

//
// Compress the specified number of scanlines
//

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    );

//
// Output TIFF IFD for the current page
//

BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBits
    );

//
// Output the compressed bitmap data for the current page
//

BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBits
    );

//
// Enlarge the buffer for holding the compressed bitmap data
//

BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    );

//
// Free the buffer for holding the compressed bitmap data
//

VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    );

//
// Initialize the fax encoder
//

BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    );

#endif  // !_FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\page.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    page.c

Abstract:

    Implementation of document and page related DDI entry points:
        DrvStartDoc
        DrvEndDoc
        DrvStartPage
        DrvSendPage

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    pDocName - Specifies a Unicode document name
    jobId - Identifies the print job

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvStartDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Initialize page count and other information
    //

    if (! (pdev->flags & PDEV_RESETPDEV)) {

        pdev->pageCount = 0;
        pdev->jobId = jobId;
    }

    //
    // Check if print preview was requested
    //
    if (NULL == pdev->pTiffPageHeader)
    {
        Assert(FALSE == pdev->bPrintPreview);
    }
    else
    {
        //
        // Validate preview mapping
        //
        if (sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
        {
            Error(("Preview mapping corrupted\n"));
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            //
            // This is the place to check if print preview was requested: DrvStartDoc() is called
            // immediately after the UI dll sets pTiffPageHeader->bPreview value in DOCUMENTEVENT_STARTDOCPRE, or after ResetDC
            //
            pdev->bPrintPreview = pdev->pTiffPageHeader->bPreview;

            //
            // Reset page count in map file to 0. This causes the UI dll to ignore the first
            // DOCUMENTEVENT_STARTPAGE event when there is no real preview page ready.
            // The true page count will be updated every call to DrvStartPage().
            // If DrvStartDoc() called as a result of ResetDC(), we should restore the previous page count.		
			//
            pdev->pTiffPageHeader->iPageCount = pdev->pageCount;
							
			//
			// If DrvStartDoc() called as a result of ResetDC(), we should restore the previous page file pointer			
			//			
			pdev->pbTiffPageFP = (((LPBYTE)(pdev->pTiffPageHeader + 1)) + pdev->pTiffPageHeader->dwDataSize);			
        }
    }
    return TRUE;
}



BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;
    RECTL       pageRect;

    Verbose(("Entering DrvStartPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Ignore nested calls to DrvStartPage
    //

    if (pdev->flags & PDEV_WITHINPAGE) {

        Error(("Nested call to DrvStartPage\n"));
        return TRUE;
    }

    pdev->flags |= PDEV_WITHINPAGE;

    //
    // Erase the page to all white
    //

    pageRect.left = pageRect.top = 0;
    pageRect.right = pdev->imageSize.cx;
    pageRect.bottom = pdev->imageSize.cy;

    EngEraseSurface(pso, &pageRect, WHITE_INDEX);
    pdev->pageCount++;

    //
    // Reset our 'Mapping file pointer' if we have an open mapping and print preview is enabled
    //
    if (pdev->bPrintPreview)
    {
        Assert(pdev->pTiffPageHeader);

        //
        // Validate preview mapping
        //
        if (sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
        {
            Error(("Preview mapping corrupted\n"));
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            if (FALSE == pdev->pTiffPageHeader->bPreview)
            {
                //
                // Preview operation was cancled by the UI dll
                //
                pdev->bPrintPreview = FALSE;
            }
            else
            {
                pdev->pbTiffPageFP = (LPBYTE) (pdev->pTiffPageHeader + 1);
                pdev->pTiffPageHeader->dwDataSize = 0;
                pdev->pTiffPageHeader->iPageCount = pdev->pageCount;
            }
        }
    }
    return TRUE;
}



BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvSendPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvSendPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Assert(pdev->flags & PDEV_WITHINPAGE);
    pdev->flags &= ~PDEV_WITHINPAGE;

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Validate preview mapping
    //
    if (pdev->bPrintPreview && sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pdev->bPrintPreview = FALSE;
    }

    //
    // Output code to end a page
    //

    Assert(pso->lDelta == pdev->lineOffset);
    Assert(pso->fjBitmap & BMF_TOPDOWN);

    return OutputPageBitmap(pdev, pso->pvBits);
}



BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEndDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    flags - A set of flag bits

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvEndDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Validate preview mapping
    //
    if (pdev->bPrintPreview && sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pdev->bPrintPreview = FALSE;
    }

    if ((pdev->flags & PDEV_CANCELLED) || (flags & ED_ABORTDOC)) {

        Error(("Print job was cancelled\n"));

    } else if (pdev->pageCount) {

        //
        // Perform any necessary work at the end of a document
        //

        Verbose(("Number of pages printed: %d\n", pdev->pageCount));
        if (!OutputDocTrailer(pdev)) {
                Error(("OutputDocTrailer failed\n"));
                return FALSE;
        }
    }

    //
    // Clean up
    //
    pdev->pageCount = 0;
    pdev->flags = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\sources.inc ===
!IF 0

Copyright (c) 1989-1995 Microsoft Corporation

!ENDIF

NOUNICODE=1 

!if !$(FREEBUILD)
USE_PDB=1
!endif

O=Obj\i386

!include ..\..\..\..\..\faxsrc.inc

BINPLACE_PLACEFILE=$(FAXROOT)\placew9x.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\faxdrv16.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : faxdrv16.h                                             //
//                                                                         //
//  DESCRIPTION   :                                                        //
//                                                                         //       
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef __FAXDRV__FAXDRV16_H
#define __FAXDRV__FAXDRV16_H

#define MAX_LENGTH_CAPTION 30 //GetOpenFileName dialog caption
#define MAX_LENGTH_PRINT_TO_FILE_FILTERS 40 //GetOpenFileName dialog filtes 
#define MAX_LENGTH_STRING  MAX_PATH

#define BUF_CHUNK       32768
#define CB_LANDSCAPE	0x0001	

#define DW_WIDTHBYTES(bits) (((bits)+31)/32*4)

#define LPDV_DEFINED
//
// documented part of UNIDRV.DLL's PDEVICE
//
typedef struct
{
    short  iType;
    short  oBruteHdr;
    HANDLE hMd;
    LPSTR  lpMd;
} PDEVICE, FAR * LPDV;
//
// private data for DUMP callback.
//
typedef struct
{
    DWORD      dwScanBufSize;
    DWORD      dwTotalScanBytes;
    DWORD      dwTotalScans;
    WORD       wWidthBytes;
    HANDLE     hScanBuf;
    char _huge *lpScanBuf;
    WORD       wHdrSize;
    HDC        hAppDC;
    DWORD      dwPointer;
} EXTPDEV, FAR *LPEXTPDEV;

//
// Copy a scan line to the global scan buffer.
//
short FAR PASCAL BlockOut(LPDV, LPSTR, WORD);
//
// Gets band blocks from GDI and dump them.
//
short FAR PASCAL fnDump(LPDV, LPPOINT, WORD);
//
// Win Proc for the User Info property page.
//
UINT CALLBACK UserInfoProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
);
//
// Handle GDI control messages.
//
short WINAPI Control(LPDV lpdv,WORD function,LPSTR lpInData,LPSTR lpOutData);

/*
 -  StringReplace
 -
 *  Purpose:
 *      Replace occurances of one character by another in an input string.
 *      This function is destructive of the input string.
 *
 *  Arguments:
 *      [in][out] sz - Manipulated string.
 *      [in] src - Character to be replaced.
 *      [in] dst - Character to replace to.
 *
 *  Returns:
 *      LPSTR Address of resulted string. 
 *
 *  Remarks:
 *      Used primarily to replace occurances of \n by \0 in the string resource
 *      for the file filters of the Print To File dialog box.
 */
__inline LPSTR 
StringReplace(LPSTR sz,char src,char dst)
{    
    LPSTR szRet = sz;
    for (;*sz != 0; sz++)
    {
        if (*sz == src)
        {
            *sz = dst;
        }
    }
    return szRet;
}

#endif //__FAXDRV__FAXDRV16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\makeenv16.inc ===
##/////////////////////////////////////////////////////////////////////////##
##  FILE          : makeenv16.inc                                          ##
##                                                                         ##
##  DESCRIPTION   : Create a 16 bit build environment.                     ##
##                                                                         ##       
##  AUTHOR        : DanL.                                                  ##
##                                                                         ##
##  HISTORY       :                                                        ##
##      Oct 19 1999 DannyL  Creation.                                      ##
##                                                                         ##
##  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         ##
##/////////////////////////////////////////////////////////////////////////##

C16_ROOT=$(FAXROOT)\sdktools\msvc15

SDKROOT=..\sdk
DDKROOT=..\ddk
BUILD_TYPE=printer
BROWSER_INFO=

!if [set include=;]
!endif
!if [set path=;]
!endif
!if [set lib=;]
!endif

PATH		= $(DDKROOT)\$(BUILD_TYPE)\bin;\
			  $(DDKROOT)\bin;\
			  $(SDKROOT)\binw16;\
			  $(SDKROOT)\bin;\
			  $(C16_ROOT)\bin;\
			  $(PATH);

LIB 		= $(DDKROOT)\lib;\
			  $(SDKROOT)\lib16;\
			  $(C16_ROOT)\LIB;\
			  $(C16_ROOT)\MFC\LIB;\
			  $(LIB)

INCLUDE 	= $(DDKROOT)\$(BUILD_TYPE)\inc;\
			  $(DDKROOT)\inc16;\
			  $(SDKROOT)\inc16;\
			  $(C16_ROOT)\include;\
			  $(C16_ROOT)\MFC\include;\
			  ..\..\..\..\..\version;\
			  ..\..\..\..\..\inc;\
			  $(INCLUDE);\
			  $(DDKROOT)\inc32;\
			  $(SDKROOT)\include;\
              $(INCLUDES);

PATH		= $(PATH:;;=;)
PATH		= $(PATH: =)

LIB 		= $(LIB:;;=;)
LIB 		= $(LIB: =)

INCLUDE 	= $(INCLUDE:;;=;)
INCLUDE 	= $(INCLUDE: =)

!if !$(FREEBUILD)

CFLAGS  =   -u -c -ASu -PLM -G2s -W3 -WX -Od -Zipe -DDEBUG -D_DEBUG 
LFLAGS  =   /ALIGN:16/NOD/map/Co
RCFLAGS = -d DEBUG

!else

# MSVC 1.5 compiler will fail with "Out Of Memory" message on -Oasceob1
CFLAGS=  -nologo -u -c -ASu -PLM -G2s -W3 -Od -Zpe
LFLAGS =    /ALIGN:16/NOD/map
RCFLAGS =

!endif #!$(FREEBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\sources.inc ===
!IF 0

Copyright (c) 1989-1995 Microsoft Corporation

!ENDIF

!include ..\..\..\..\faxsrc.inc

TARGETPATH=obj
DLLDEF=..\faxdrv.def

INCLUDES=..;..\..\inc;$(INCLUDES)

TARGETLIBS=$(TARGETLIBS) \
    $(BASEDIR)\public\sdk\lib\*\libcntpr.lib

C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -DUSELSB

SOURCES=..\enable.c    \
        ..\escape.c    \
        ..\page.c      \
        ..\faxtiff.c   \
        ..\faxdrv.rc

PRECOMPILED_INCLUDE=..\faxdrv.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\faxdrv16.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : faxdrv16.c                                             //
//                                                                         //
//  DESCRIPTION   : Implementation for the unidriver dump callback.        //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdhdr.h"

BYTE szBuf[4] = {0xFF, 0xFF, 0xFF, 0xFF};

/*
 -  fnDump
 -
 *  Purpose: Gets filled in band block from GDI and sends to BlockOut
 *           one scan line at a time.
 *
 *  Arguments:
 *      [in] lpdv - Address of a PDEVICE structure for device data.
 *      [in] lpptCursor - Address of a pair of POINT structures that specify the
 *                   coordinates of the current and final position of the
 *                   print head.
 *      [in] fMode - Landscape flag. If this parameter is CD_LANDSCAPE, the
 *              printer is in landscape mode; otherwise, it is in portrait mode.
 *
 *  Returns:
 *      Return value conflicts with documentation. Doenst seem to have
 *      any specific meaning.
 *
 *  Remarks:
 *      For complete documentation refer to fnOEMDump in the Minidriver
 *      Developer's Guide.
 */
short FAR PASCAL
fnDump(LPDV lpdv, LPPOINT lpptCursor, WORD fMode)
{
    short     sRet = 1;
    WORD      iScan, i, WidthBytes, BandHeight;
    WORD      wScanlinesPerSeg, wWAlignBytes, wSegmentInc;
    LPBITMAP  lpbmHdr;
    BOOL      fHuge;
    LPBYTE    lpSrc;
    LPBYTE    lpScanLine;
    LPEXTPDEV lpXPDV;
    WORD      count = 0;
    BOOL      fAbort = FALSE;

    DBG_PROC_ENTRY("fnDump");
    //
    // get pointer to our private data stored in UNIDRV's PDEVICE
    //
    lpXPDV = ((LPEXTPDEV)lpdv->lpMd);
    //
    // get ptr to PBITMAP
    //
    lpbmHdr = (LPBITMAP)((LPSTR)lpdv + lpdv->oBruteHdr);
    //
    // initialize some things
    //
    fHuge = lpbmHdr->bmSegmentIndex > 0;
    lpSrc = lpbmHdr->bmBits;
    wWAlignBytes = (lpbmHdr->bmWidth+7)>>3;
    WidthBytes = lpbmHdr->bmWidthBytes;
    BandHeight =  lpbmHdr->bmHeight;
    DBG_TRACE2("Page dump:%d pxls X %d pxls",lpbmHdr->bmWidth,BandHeight);
    wScanlinesPerSeg = lpbmHdr->bmScanSegment;
    wSegmentInc = lpbmHdr->bmSegmentIndex;
    //
    // We take landscape orientation into cosideration on OutputPageBitmap.
    //
    for (iScan = 0; ((iScan < BandHeight) && (fAbort = QueryAbort(lpXPDV->hAppDC,0))
        && lpXPDV->hScanBuf);iScan += wScanlinesPerSeg)
    {
        DBG_TRACE("Inside main loop");
        //
        // get next 64K segment of scans
        //
        if (iScan)
        {
            WORD wRemainingScans = BandHeight - iScan;
            //
            // cross the segment boundary
            //
            lpSrc = (LPBYTE)MAKELONG(0,HIWORD(lpSrc)+wSegmentInc);

            if (wScanlinesPerSeg > wRemainingScans)
                 wScanlinesPerSeg = wRemainingScans;
        }
        //
        // loop through scan lines in 64K segment
        //
        for (i=iScan, lpScanLine=lpSrc;
            ((i < iScan + wScanlinesPerSeg) && QueryAbort(lpXPDV->hAppDC, 0)
            && lpXPDV->hScanBuf); i++)
        {
             BlockOut(lpdv, lpScanLine, wWAlignBytes);
             lpScanLine += WidthBytes;
             count++;
        }
    }   // end for iScan

    DBG_TRACE("Out of main loop");
    DBG_TRACE2("iScan: %d    BandHeight: %d", iScan, BandHeight);
    DBG_TRACE1("lpXPDV->hScanBuf: 0x%lx", lpXPDV->hScanBuf);
    DBG_TRACE1("fAbort: %d", fAbort);
    DBG_TRACE1("count is: %d",count);

    RETURN sRet;
}

/*
 -  BlockOut
 -
 *  Purpose:
 *      Copy a scan line to the global scan buffer.
 *
 *  Arguments:
 *      [in] lpdv - Address of a PDEVICE structure.
 *      [in] lpBuf - Address of buffer containing scanline.
 *      [in] len - width of scanline.
 *
 *  Returns:
 *      [N/A]
 *
 *  Remarks:
 *      [N/A]
 */
short FAR PASCAL
BlockOut(LPDV lpdv, LPSTR lpBuf, WORD len)
{
    WORD wBytes;
    LPEXTPDEV lpXPDV;

    SDBG_PROC_ENTRY("BlockOut");
    //
    // get pointer to our private data stored in UNIDRV's PDEVICE
    //
    lpXPDV = ((LPEXTPDEV)lpdv->lpMd);

    //
    // convert from BYTE aligned to DWORD aligned buffer
    // get DWORD amount of bytes
    //
    wBytes = (WORD)DW_WIDTHBYTES((DWORD)len*8);
    //
    // check to see if need to realloc scan buffer
    //
    if ((lpXPDV->dwTotalScanBytes + wBytes) > lpXPDV->dwScanBufSize)
    {
        HANDLE hTemp;

        lpXPDV->dwScanBufSize += BUF_CHUNK;
        hTemp = GlobalReAlloc(lpXPDV->hScanBuf, lpXPDV->dwScanBufSize, 0);
        //
        // if realloc fails, call ABORTDOC to clean up scan buf
        //
        if (!hTemp)
        {
            DBG_CALL_FAIL("GlobalReAlloc ... Aborting",0);
            DBG_TRACE3("lpXPDV->hScanBuf: 0x%lx, lpXPDV->dwScanBufSize: %d,  (ec: %d)",
                       lpXPDV->hScanBuf,
                       lpXPDV->dwScanBufSize,
                       GetLastError());
            Control(lpdv, ABORTDOC, NULL, NULL);
            RETURN 0;
        }
        else
        {
            lpXPDV->hScanBuf  = hTemp;
            lpXPDV->lpScanBuf = (char _huge *)GlobalLock(lpXPDV->hScanBuf);
            lpXPDV->lpScanBuf += lpXPDV->dwTotalScanBytes;
        }
    }
    ASSERT((lpXPDV->dwTotalScanBytes + wBytes) < lpXPDV->dwScanBufSize);
    //
    // copy scan line to scan buffer
    //
    _fmemcpy(lpXPDV->lpScanBuf, lpBuf, len);
    lpXPDV->lpScanBuf += len;
    _fmemcpy(lpXPDV->lpScanBuf, (LPSTR)szBuf, wBytes-len);
    lpXPDV->lpScanBuf += wBytes-len;
    //
    // update total scan bytes
    //
    lpXPDV->dwTotalScanBytes += wBytes;
    lpXPDV->dwTotalScans++;
    RETURN wBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\resource.h ===
// Used by faxdrv16.rc
//
#define IDS_MB_FAIL_GET_SENDER_INFO     600
#define IDS_MB_CAPTION_ERROR            601
#define IDS_MB_THUNK_CALL_FAIL          602
#define IDS_CAPTION_PRINT_TO_FILE       603
#define IDS_PRINT_TO_FILE_FILTER        604
#define IDS_MB_FAIL_PUT_SENDER_INFO     605
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\makefile.inc ===
##/////////////////////////////////////////////////////////////////////////##
##  FILE          : makefile.inc                                           ##
##                                                                         ##
##  DESCRIPTION   : make file for the 16 bit side of the driver.           ##
##                                                                         ##
##  AUTHOR        : DanL.                                                  ##
##                                                                         ##
##  HISTORY       :                                                        ##
##      Oct 19 1999 DannyL  Creation.                                      ##
##                                                                         ##
##  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         ##
##/////////////////////////////////////////////////////////////////////////##

!INCLUDE makeenv16.inc

DRVNAME = FXSDRV16
FONTS = STANDARD.PFM
RCV = FAXDRV16.RCV

CFLAGS=$(CFLAGS) -Yustdhdr.h -Fp$O\stdhdr.pch

####################################################################################
## fxsdrv

$O\$(DRVNAME).res:  faxdrv16.rc faxdrv16.GPC $(FONTS) $(RCV)
    rc $(RCFLAGS) -r -I. -Fo$O\$(DRVNAME).res faxdrv16.RC

$O\minidriv.obj: minidriv.c
    cl $(CFLAGS) -Fo$O\minidriv.obj minidriv.c

$O\faxdrv16.obj:  faxdrv16.c
    cl $(CFLAGS) -Fo$O\faxdrv16.obj faxdrv16.c

$O\stdhdr.pch: stdhdr.h
    cl -Ycstdhdr.h $(CFLAGS) stdhdr.c

$O\$(DRVNAME).EXE:  $O\minidriv.obj $O\faxdrv16.obj faxdrv16.def ..\faxdrv32\$O\thk16.obj
    link /NOE $(LFLAGS) @<<
$O\minidriv $O\faxdrv16 ..\faxdrv32\$O\thk16.obj 
$O\$(DRVNAME).EXE
$O\$(DRVNAME).map
sdllcew libw COMMCTRL.LIB COMMDLG.LIB
faxdrv16.def
<<
    mapsym -l $O\$(DRVNAME).map $O\$(DRVNAME)


$O\$(DRVNAME).DRV: $O\stdhdr.pch $O\$(DRVNAME).EXE $O\$(DRVNAME).res
    rc $(RCFLAGS) -40 -t -I. faxdrv16.rc $O\$(DRVNAME).EXE
    copy $O\$(DRVNAME).EXE $O\$(DRVNAME).DRV

$O\*.sbr: 

clean:
	-@del *.pdb
	-@del *.res
    -@del $O\*.pch
	-@del $O\*.res
	-@del $O\*.obj
	-@del $O\*.sym
	-@del $O\*.map
	-@del $O\*.dll
	-@del $O\*.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\minidriv.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : minidriv.c                                             //
//                                                                         //
//  DESCRIPTION   : Implementation for the driver Device Driver Interface. //
//                  For further details about driver interface functions - //
//                  refer to the Windows 95 DDK chapter under the DDK -    //
//                  Documentation.                                         //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdhdr.h"

#include "resource.h"
#include "..\faxdrv32\faxdrv32.h" // faxdrv32 api
#include "faxreg.h"

#define TEXT(quote) quote

//
// To enable the user info tab in the printer properties, define:
//
// #define ENABLE_USER_INFO_TAB

DBG_DECLARE_MODULE("fxsdrv");

HANDLE g_hModule;

//
// Decleration for the winproc of the user info tab on the device mode property
// sheet page.
//
BOOL FAR PASCAL
UserInfoDlgProc(
    HWND hDlg,
    WORD message,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Debugging mechanizm for device pointer debug prints (lpdev, lpdv->lpMd and the device context).
//

#if 0
//#ifdef DBG_DEBUG
#define DEBUG_OUTPUT_DEVICE_POINTERS(sz, lpDev)     OutputDevicePointers(sz, lpDev)
void OutputDevicePointers(char* szMessage, LPDV lpdv)
{
    DBG_PROC_ENTRY("OutputDevicePointers");

    DBG_TRACE3(
        "Device Event:%s lpdv:%#lx lpdv->lpMd:%#lx",
        szMessage,
        lpdv,
        lpdv->lpMd);

    if (lpdv->lpMd)
    {
        DBG_TRACE2("Device Event:%s dc:%#lx", szMessage, ((LPEXTPDEV)lpdv->lpMd)->hAppDC);
    }
    RETURN;
}
#else
#define DEBUG_OUTPUT_DEVICE_POINTERS(sz, lpDev)
#endif


////////////////////////////////////////////////////////////////////////////////////////
// Printer-Escape Functions
//
// The printer-escape functions support device-specific operations. The
// following briefly describes these escape functions.
//
// ABORTDOC          The ABORTDOC escape function signals the abnormal
//                   cancellation of a print job.
//
// BANDINFO          The BANDINFO escape function RETURNs information about a
//                   band of bitmap data.
//
// ENDDOC            The ENDDOC escape function signals the end of a print job.
//
// NEXTBAND          The NEXTBAND escape function prints a band of bitmap data.
//
// QUERYESCSUPPORT   The QUERYESCSUPPORT escape function specifies whether the
//                   driver supports a specified escape.
//
// SETABORTDOC       The SETABORTDOC escape function calls an application's
//                   cancellation procedure.
//
// STARTDOC          The STARTDOC escape function signals the beginning of a
//                   print job.
//
// The previous list of printer escapes is a list of escapes supported by the
// Microsoft Windows Universal Printer Driver (UNIDRV.DLL). It is not a
// comprehensive list of all Windows escape functions. Most of the escape
// functions now have equivalent Windows API functions with Windows 3.1. The
// escapes are supported for backward compatibility, but application
// developers are encouraged to start using the new API calls.
//
#ifndef NOCONTROL
short WINAPI Control(lpdv, function, lpInData, lpOutData)
LPDV    lpdv;
WORD    function;
LPSTR   lpInData;
LPSTR   lpOutData;
{
    LPEXTPDEV lpXPDV;
    LPEXTPDEV lpOldXPDV;
    short sRet, sRc;
    DBG_PROC_ENTRY("Control");
    if (lpdv)
    {
        DBG_TRACE1("lpdv: 0x%lx", lpdv);
    }

    DBG_TRACE1("function: %d", function);

    if (lpInData)
    {
        DBG_TRACE2("lpInData: 0x%lx,  *lpInData: %d", lpInData, *((LPWORD)lpInData));

    }

    if (lpOutData)
    {
        DBG_TRACE1("lpOutData: 0x%lx", lpOutData);
    }

    //
    // get pointer to our private data stored in UNIDRV's PDEVICE
    //
    lpXPDV = ((LPEXTPDEV)lpdv->lpMd);

    switch(function)
    {
        case SETPRINTERDC:
            //
            // save app's DC for QueryAbort() calls.
            //
            DBG_TRACE("SETPRINTERDC");

            if(lpXPDV)
                lpXPDV->hAppDC = *(HANDLE FAR *)lpInData;
            DEBUG_OUTPUT_DEVICE_POINTERS("SETPRINTERDC", lpdv);
            break;

        case NEXTBAND:
            DBG_TRACE("NEXTBAND");
            //
            // call UNIDRV.DLL's NEXTBAND to see if we're at end of page
            //
            sRet = UniControl(lpdv, function, lpInData, lpOutData);
            //
            // check for end of page (ie, empty rectangle) or failure
            //
            if((!IsRectEmpty((LPRECT)lpOutData)) || (sRet <= 0))
            {
                RETURN sRet;
            }
            //
            // Rewind buffer pointer.
            //
            lpXPDV->lpScanBuf -= lpXPDV->dwTotalScanBytes;
            ASSERT(lpXPDV->dwTotalScanBytes != 0);
            //
            // Add this page to our tiff.
            //
            DEBUG_OUTPUT_DEVICE_POINTERS("Before FaxEddPage", lpdv);
            sRc = FaxAddPage(
                        lpXPDV->dwPointer,
                        (LPBYTE)lpXPDV->lpScanBuf,
                        lpXPDV->dwTotalScanBytes * 8 / lpXPDV->dwTotalScans,
                        lpXPDV->dwTotalScans);
            if(sRc != TRUE)
            {
                if(sRc < 0)
                {
                    ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
                }
                DBG_CALL_FAIL("FaxAddPage",0);
                RETURN SP_ERROR;
            }
            //
            // clean up page stuff
            // initialize job variables
            //
            lpXPDV->dwTotalScans     =
            lpXPDV->dwTotalScanBytes = 0;

            RETURN sRet;

        case STARTDOC:
            {
                DOCINFO di;
                char  szTiffName[MAX_PATH] = "*.tif";

                DBG_TRACE("STARTDOC");
                if(IsBadReadPtr(lpOutData,1))
                {
                    RETURN SP_ERROR;
                }
                //
                // If the output file is named "file:" we must pop up a dialog
                // and request the output filename from the user.
                //
                if(((LPDOCINFO)lpOutData)->lpszOutput &&
                (_fstrncmp(((LPDOCINFO)lpOutData)->lpszOutput,"file:",5) == 0))
                {
                    OPENFILENAME ofn;
                    char         szTitle[MAX_LENGTH_CAPTION]="";
                    char         szFilters[MAX_LENGTH_PRINT_TO_FILE_FILTERS]="";

                    _fmemset(&ofn,0,sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = GetActiveWindow();
                    LoadString(g_hModule,
                               IDS_PRINT_TO_FILE_FILTER,
                               szFilters,
                               sizeof(szFilters) - 1);
                    ofn.lpstrDefExt = FAX_TIF_FILE_EXT;
                    ofn.lpstrFilter = StringReplace(szFilters,'\n','\0');
                    ofn.nMaxFile = sizeof(szTiffName) -1;
                    ofn.lpstrFile = szTiffName;
                    LoadString(g_hModule,
                               IDS_CAPTION_PRINT_TO_FILE,
                               szTitle,
                               sizeof(szTitle) - 1);
                    ofn.lpstrTitle = szTitle;
                    if(!GetOpenFileName(&ofn))
                    {
                        //
                        // User aborted.
                        //
                        RETURN SP_APPABORT;
                    }
                    ((LPDOCINFO)lpOutData)->lpszOutput = szTiffName;
                }
                //
                // Create the tiff/output file for pages.
                //
                DEBUG_OUTPUT_DEVICE_POINTERS("Before FaxStartDoc", lpdv);
                sRc = FaxStartDoc(lpXPDV->dwPointer, (LPDOCINFO)lpOutData);
                if(sRc != TRUE)
                {
                    if(sRc < 0)
                    {
                        ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
                    }
                    DBG_CALL_FAIL("FaxStartDoc",0);
                    RETURN SP_ERROR;
                }
                //
                // pass NUL file to OpenJob in order to redirect the print
                // job to dev nul sinc we take care of the print job ourselves.
                //
                di.cbSize = sizeof(DOCINFO);
                di.lpszDocName = NULL;
                di.lpszOutput = (LPSTR)"nul";
                //
                // call UNIDRV.DLL's Control()
                //
                sRet = UniControl(lpdv, function, lpInData, (LPSTR)&di);
                //
                // if failure clean up scan buffer
                //
                if(sRet <= 0)
                {
                    FaxEndDoc(lpXPDV->dwPointer, TRUE);
                }
                RETURN sRet;
            }
        case ABORTDOC:
            DBG_TRACE("ABORTDOC");
            //
            // The input parameter for FaxEndDoc reflects the difference.
            //
        case ENDDOC:
            DBG_TRACE("ENDDOC");
            //
            // Finalize tiff generation.
            //
            DEBUG_OUTPUT_DEVICE_POINTERS("Before FaxEndDoc", lpdv);
            sRc = FaxEndDoc(lpXPDV->dwPointer, function == ABORTDOC);
            if(sRc != TRUE)
            {
                if(sRc < 0)
                {
                    ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
                }
                DBG_CALL_FAIL("FaxEndDoc",0);
                RETURN SP_ERROR;
            }
            break;

        case RESETDEVICE:
            DBG_TRACE("RESETDEVICE");
            //
            // ResetDC was called - Copy the context to the new DC
            //
            lpOldXPDV = ((LPEXTPDEV)((LPDV)lpInData)->lpMd);
            sRc = FaxResetDC(&(lpOldXPDV->dwPointer), &(lpXPDV->dwPointer));
            if(sRc != TRUE)
            {
                if(sRc < 0)
                {
                    ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
                }
                DBG_CALL_FAIL("FaxResetDC",0);
                RETURN SP_ERROR;
            }
            break;

        default:
            DBG_TRACE1("UNSUPPORTED: %d",function);
            break;
    } // end case

    // call UNIDRV's Control
    RETURN (UniControl(lpdv, function, lpInData, lpOutData));
}
#endif

#ifndef NODEVBITBLT
BOOL WINAPI DevBitBlt(lpdv, DstxOrg, DstyOrg, lpSrcDev, SrcxOrg, SrcyOrg,
                    xExt, yExt, lRop, lpPBrush, lpDrawmode)
LPDV        lpdv;           // --> to destination bitmap descriptor
short       DstxOrg;        // Destination origin - x coordinate
short       DstyOrg;        // Destination origin - y coordinate
LPBITMAP    lpSrcDev;       // --> to source bitmap descriptor
short       SrcxOrg;        // Source origin - x coordinate
short       SrcyOrg;        // Source origin - y coordinate
WORD        xExt;           // x extent of the BLT
WORD        yExt;           // y extent of the BLT
long        lRop;           // Raster operation descriptor
LPPBRUSH    lpPBrush;       // --> to a physical brush (pattern)
LPDRAWMODE  lpDrawmode;
{
    DBG_PROC_ENTRY("DevBitBlt");
    RETURN UniBitBlt(lpdv, DstxOrg, DstyOrg, lpSrcDev, SrcxOrg, SrcyOrg,
                    xExt, yExt, lRop, lpPBrush, lpDrawmode);
}
#endif

#ifndef NOPIXEL
DWORD WINAPI Pixel(lpdv, x, y, Color, lpDrawMode)
LPDV        lpdv;
short       x;
short       y;
DWORD       Color;
LPDRAWMODE  lpDrawMode;
{
    DBG_PROC_ENTRY("Pixel");
    RETURN UniPixel(lpdv, x, y, Color, lpDrawMode);
}
#endif

#ifndef NOOUTPUT
short WINAPI Output(lpdv, style, count, lpPoints, lpPPen, lpPBrush, lpDrawMode, lpCR)
LPDV        lpdv;       // --> to the destination
WORD        style;      // Output operation
WORD        count;      // # of points
LPPOINT     lpPoints;   // --> to a set of points
LPVOID      lpPPen;     // --> to physical pen
LPPBRUSH    lpPBrush;   // --> to physical brush
LPDRAWMODE  lpDrawMode; // --> to a Drawing mode
LPRECT      lpCR;       // --> to a clipping rectange if <> 0
{
    DBG_PROC_ENTRY("Output");
    RETURN UniOutput(lpdv, style, count, lpPoints, lpPPen, lpPBrush, lpDrawMode, lpCR);
}
#endif

#ifndef NOSTRBLT
DWORD WINAPI StrBlt(lpdv, x, y, lpCR, lpStr, count, lpFont, lpDrawMode, lpXform)
LPDV        lpdv;
short       x;
short       y;
LPRECT      lpCR;
LPSTR       lpStr;
int         count;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;           // includes background mode and bkColor
LPTEXTXFORM lpXform;
{
    DBG_PROC_ENTRY("StrBlt");
    // StrBlt is never called by GDI.
    // Keep a stub function here so nobody complains.
    //
    RETURN 0;
}
#endif

#ifndef NOSCANLR
short WINAPI ScanLR(lpdv, x, y, Color, DirStyle)
LPDV    lpdv;
short   x;
short   y;
DWORD   Color;
WORD    DirStyle;
{
    DBG_PROC_ENTRY("ScanLR");
    // ScanLR is only called for RASDISPLAY devices.
    // Keep a stub function here so nobody complains.
    //
    RETURN 0;
}
#endif

#ifndef NOENUMOBJ
short WINAPI EnumObj(lpdv, style, lpCallbackFunc, lpClientData)
LPDV    lpdv;
WORD    style;
FARPROC lpCallbackFunc;
LPVOID  lpClientData;
{
    DBG_PROC_ENTRY("EnumObj");
    RETURN UniEnumObj(lpdv, style, lpCallbackFunc, lpClientData);
}
#endif

#ifndef NOCOLORINFO
DWORD WINAPI ColorInfo(lpdv, ColorIn, lpPhysBits)
LPDV    lpdv;
DWORD   ColorIn;
LPDWORD lpPhysBits;
{
    DBG_PROC_ENTRY("ColorInfo");
    RETURN UniColorInfo(lpdv, ColorIn, lpPhysBits);
}
#endif

#ifndef NOREALIZEOBJECT
DWORD WINAPI RealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm)
LPDV        lpdv;
short       sStyle;
LPSTR       lpInObj;
LPSTR       lpOutObj;
LPTEXTXFORM lpTextXForm;
{
    DBG_PROC_ENTRY("RealizeObject");
    RETURN UniRealizeObject(lpdv, sStyle, lpInObj, lpOutObj, lpTextXForm);
}
#endif

#ifndef NOENUMDFONTS
short WINAPI EnumDFonts(lpdv, lpFaceName, lpCallbackFunc, lpClientData)
LPDV    lpdv;
LPSTR   lpFaceName;
FARPROC lpCallbackFunc;
LPVOID  lpClientData;
{
    DBG_PROC_ENTRY("EnumDFonts");
    RETURN UniEnumDFonts(lpdv, lpFaceName, lpCallbackFunc, lpClientData);
}
#endif


// Enable will be called twice by the GDI
// First:  the unidriver fills the GDIINFO structure (so the GDI will know the
//         size of PDEVICE, and alloc memory for it.
// Second: To initialize the already allocated PDEIVCE.
#ifndef NOENABLE
WORD WINAPI Enable(
  LPVOID lpDevInfo,
  WORD wAction,
  LPSTR lpDestDevType,
  LPSTR lpOutputFile,
  LPVOID lpData
 )
{
    CUSTOMDATA  cd;
    short sRet;
    LPEXTPDEV lpXPDV = NULL;

    DBG_PROC_ENTRY("Enable");
    DBG_TRACE1("lpDevInfo: 0x%lx", lpDevInfo);
    DBG_TRACE1("wAction: %d", wAction);
    DBG_TRACE1("lpDestDevType: %s", lpDestDevType);
    DBG_TRACE1("lpOutputFile: %s", lpOutputFile);
    DBG_TRACE1("lpData: 0x%lx", lpData);


    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = g_hModule;
    // output raster graphics in portrait and landscape orientation.
    cd.fnOEMDump = fnDump;

    if (!(sRet = UniEnable((LPDV)lpDevInfo,
                           wAction,
                           lpDestDevType, // Printer model
                           lpOutputFile, // Port name
                           (LPDM)lpData,
                           &cd)))
    {
        RETURN (sRet);
    }

    switch(wAction)
    {
    case 0x0000:
        // Initializes the driver and associated hardware and then copies
        // device-specific information needed by the driver to the PDEVICE
        // structure pointed to by lpDevInfo.
    case 0x8000:
        // Initializes the PDEVICE structure pointed to by lpDevInfo,
        // but does not initialize the driver and peripheral hardware.
        {
            LPDV lpdv = (LPDV)lpDevInfo;
            DBG_TRACE("Init PDEVICE");
            //
            // allocate space for our private data
            //
            if (!(lpdv->hMd = GlobalAlloc(GHND, sizeof(EXTPDEV))))
            {
                RETURN 0;
            }
            if (!(lpdv->lpMd = GlobalLock(lpdv->hMd)))
            {
                GlobalFree (lpdv->hMd);
                RETURN 0;
            }

            lpXPDV = (LPEXTPDEV) lpdv->lpMd;
            //
            // alloc page scan buffer
            //
            if(!(lpXPDV->hScanBuf = GlobalAlloc(GHND, BUF_CHUNK)))
            {
                GlobalUnlock (lpdv->hMd);
                GlobalFree (lpdv->hMd);
                RETURN 0;
            }
            if (!(lpXPDV->lpScanBuf = (char _huge *)GlobalLock(lpXPDV->hScanBuf)))
            {
                GlobalUnlock (lpdv->hMd);
                GlobalFree (lpdv->hMd);
                GlobalFree (lpXPDV->hScanBuf);
                RETURN 0;
            }

            lpXPDV->dwScanBufSize = BUF_CHUNK;
            //
            // initialize job variables
            //
            lpXPDV->dwTotalScans     = 0;
            lpXPDV->dwTotalScanBytes = 0;

            //
            // Set the device context parameters in a newly allocated 32 bit driver context
            // and save the returned pointer
            //
            DBG_TRACE3("lpData:0x%lx, lpDestDevType:%s ,lpOutputFile:%s",lpData, lpDestDevType, lpOutputFile);
            sRet = FaxCreateDriverContext(
                            lpDestDevType,
                            lpOutputFile,
                            (LPDEVMODE)lpData,
                            &(lpXPDV->dwPointer));
            if(sRet != TRUE)
            {
                if(sRet < 0)
                {
                    ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
                }
                DBG_CALL_FAIL("FaxCreateDriverContext",0);

                GlobalUnlock (lpdv->hMd);
                GlobalFree (lpdv->hMd);
                GlobalUnlock (lpXPDV->hScanBuf);
                GlobalFree (lpXPDV->hScanBuf);
                RETURN 0;
            }
        }
        break;
    case 0x0001:
    case 0x8001:
        //
        // Copies the device driver information to the GDIINFO structure pointed
        // to by lpDevInfo. GDIINFO also contains information about the sizes of
        // DEVMODE and PDEVICE needed by the GDI to allocate them.
        //
        {
            // GDIINFO far* lpgdiinfo = (GDIINFO far*)lpDevInfo;
            DBG_TRACE("Init GDIINFO");
        }
        break;
    default:
        DBG_TRACE("UNSUPPORTED style");
    }

    RETURN sRet;
}
#endif


#ifndef NODISABLE
void WINAPI Disable(lpdv)
LPDV lpdv;
{
    DBG_PROC_ENTRY("Disable");
    //
    // if allocated private PDEVICE data
    //
    if (lpdv->hMd)
    {
        LPEXTPDEV lpXPDV;

        // get pointer to our private data stored in UNIDRV's PDEVICE
        lpXPDV = ((LPEXTPDEV)lpdv->lpMd);
        ASSERT(lpXPDV);

        DEBUG_OUTPUT_DEVICE_POINTERS("Before calling fax disable", lpdv);
        // check to see if scan buffer is still around
        if (lpXPDV->hScanBuf)
        {
            GlobalUnlock(lpXPDV->hScanBuf);
            GlobalFree(lpXPDV->hScanBuf);
        }

        //
        // Free 32 bit driver context
        //
        FaxDisable(lpXPDV->dwPointer);

        //
        // Release our pdev
        //
        GlobalUnlock(lpdv->hMd);
        GlobalFree(lpdv->hMd);
    }
    UniDisable(lpdv);
    RETURN;
}
#endif

#ifndef NODEVEXTTEXTOUT
DWORD WINAPI DevExtTextOut(lpdv, x, y, lpCR, lpStr, count, lpFont,
                        lpDrawMode, lpXform, lpWidths, lpOpaqRect, options)
LPDV        lpdv;
short       x;
short       y;
LPRECT      lpCR;
LPSTR       lpStr;
int         count;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;
LPTEXTXFORM lpXform;
LPSHORT     lpWidths;
LPRECT      lpOpaqRect;
WORD        options;
{
    DBG_PROC_ENTRY("DevExtTextOut");
    RETURN(UniExtTextOut(lpdv, x, y, lpCR, lpStr, count, lpFont,
                        lpDrawMode, lpXform, lpWidths, lpOpaqRect, options));
}
#endif

#ifndef NODEVGETCHARWIDTH
short WINAPI DevGetCharWidth(lpdv, lpBuf, chFirst, chLast, lpFont, lpDrawMode,
                        lpXForm)
LPDV        lpdv;
LPSHORT     lpBuf;
WORD        chFirst;
WORD        chLast;
LPFONTINFO  lpFont;
LPDRAWMODE  lpDrawMode;
LPTEXTXFORM lpXForm;
{
    DBG_PROC_ENTRY("DevGetCharWidth");
    RETURN(UniGetCharWidth(lpdv, lpBuf, chFirst, chLast, lpFont,lpDrawMode,
                          lpXForm));
}
#endif

#ifndef NODEVICEBITMAP
short WINAPI DeviceBitmap(lpdv, command, lpBitMap, lpBits)
LPDV     lpdv;
WORD     command;
LPBITMAP lpBitMap;
LPSTR    lpBits;
{
    DBG_PROC_ENTRY("DeviceBitmap");
    RETURN 0;
}
#endif

#ifndef NOFASTBORDER
short WINAPI FastBorder(lpRect, width, depth, lRop, lpdv, lpPBrush,
                                          lpDrawmode, lpCR)
LPRECT  lpRect;
short   width;
short   depth;
long    lRop;
LPDV    lpdv;
long    lpPBrush;
long    lpDrawmode;
LPRECT  lpCR;
{
    DBG_PROC_ENTRY("FastBorder");
    RETURN 0;
}
#endif

#ifndef NOSETATTRIBUTE
short WINAPI SetAttribute(lpdv, statenum, index, attribute)
LPDV    lpdv;
WORD    statenum;
WORD    index;
WORD    attribute;
{
    DBG_PROC_ENTRY("SetAttribute");
    RETURN 0;
}
#endif

//
// The ExtDeviceMode function also displays a dialog box that
// allows a user to select printer options such as paper size,
// paper orientation, output quality, and so on. Printer
// drivers written for Windows 3.x and later versions support
// this function. This DDI replaces obsolete DeviceMode.
//
int WINAPI ExtDeviceMode(hWnd, hDriver, lpDevModeOutput, lpDeviceName, lpPort,
lpDevModeInput, lpProfile, wMode)
HWND    hWnd;           // parent for DM_PROMPT dialog box
HANDLE  hDriver;        // handle from LoadLibrary()
LPDM    lpDevModeOutput;// output DEVMODE for DM_COPY
LPSTR   lpDeviceName;   // device name
LPSTR   lpPort;         // port name
LPDM    lpDevModeInput; // input DEVMODE for DM_MODIFY
LPSTR   lpProfile;      // alternate .INI file
WORD    wMode;          // operation(s) to carry out

#define FAILURE -1
{
    int     iRc;

    DBG_PROC_ENTRY("ExtDeviceMode");

    ASSERT(!(wMode & DM_COPY) || lpDevModeOutput);
    DBG_TRACE2("params: lpDevModeInput:0x%lx wMode:%d",lpDevModeInput,wMode);

    //
    // We don't do anything particular here. Let unidrive manage the default devmode...
    //
    iRc = UniExtDeviceMode(hWnd,
                           hDriver,
                           lpDevModeOutput,
                           lpDeviceName,
                           lpPort,
                           lpDevModeInput,
                           lpProfile,
                           wMode);
    if(iRc < 0)
    {
        DBG_CALL_FAIL("UniExtDeviceMode",iRc);
    }
    RETURN iRc;
}


#ifndef WANT_WIN30
#ifndef NODMPS
int WINAPI ExtDeviceModePropSheet(hWnd, hInst, lpDevName, lpPort,
                              dwReserved, lpfnAdd, lParam)
HWND                 hWnd;        // Parent window for dialog
HANDLE               hInst;       // handle from LoadLibrary()
LPSTR                lpDevName;   // friendly name
LPSTR                lpPort;      // port name
DWORD                dwReserved;  // for future use
LPFNADDPROPSHEETPAGE lpfnAdd;     // Callback to add dialog page
LPARAM               lParam;      // Pass to callback
{
    int iRc;

    DBG_PROC_ENTRY("ExtDeviceModePropSheet");
    DBG_TRACE1("lpDevName PTR [0x%08X]",lpDevName);

    DBG_TRACE3("hInst:[%ld] lpDevName:[%s] lpPort:[%s]",hInst,
                                                        (LPSTR)lpDevName,
                                                        (LPSTR)lpPort);
    DBG_TRACE1("lpfnAdd:[%ld]",lpfnAdd);
    iRc = UniExtDeviceModePropSheet(hWnd, hInst, lpDevName, lpPort,
                                    dwReserved, lpfnAdd, lParam);
    if (iRc < 0)
    {
        DBG_CALL_FAIL("UniExtDeviceModePropSheet",0);
    }

    RETURN iRc;
}
#endif
#endif

#ifndef NODEVICECAPABILITIES
DWORD WINAPI DeviceCapabilities(lpDevName, lpPort, wIndex, lpOutput, lpdm)
LPSTR   lpDevName;
LPSTR   lpPort;
WORD    wIndex;
LPSTR   lpOutput;
LPDM    lpdm;
{
    DWORD dwCap;

    DBG_PROC_ENTRY("DeviceCapabilities");
    DBG_TRACE1("Capability index: %d",wIndex);
    dwCap = UniDeviceCapabilities(lpDevName,
                                  lpPort,
                                  wIndex,
                                  lpOutput,
                                  lpdm,
                                  g_hModule);
    DBG_TRACE1("Reporeted Capability %d", dwCap);
    if (DC_VERSION == wIndex )
    {
        DBG_TRACE1("Reporting DC_VERSION [0x%08X]",dwCap);
    }
    RETURN dwCap;
}
#endif

#ifndef NOADVANCEDSETUPDIALOG
LONG WINAPI AdvancedSetUpDialog(hWnd, hInstMiniDrv, lpdmIn, lpdmOut)
HWND    hWnd;
HANDLE  hInstMiniDrv;   // handle of the driver module
LPDM    lpdmIn;         // initial device settings
LPDM    lpdmOut;        // final device settings
{
    DBG_PROC_ENTRY("AdvancedSetUpDialog");
    RETURN(UniAdvancedSetUpDialog(hWnd, hInstMiniDrv, lpdmIn, lpdmOut));
}
#endif

#ifndef NODIBBLT
short WINAPI DIBBLT(lpBmp, style, iStart, sScans, lpDIBits,
                        lpBMI, lpDrawMode, lpConvInfo)
LPBITMAP      lpBmp;
WORD          style;
WORD          iStart;
WORD          sScans;
LPSTR         lpDIBits;
LPBITMAPINFO  lpBMI;
LPDRAWMODE    lpDrawMode;
LPSTR         lpConvInfo;
{
    DBG_PROC_ENTRY("DIBBLT");
    RETURN(UniDIBBlt(lpBmp, style, iStart, sScans, lpDIBits,
                     lpBMI, lpDrawMode, lpConvInfo));
}
#endif

#ifndef NOCREATEDIBITMAP
short WINAPI CreateDIBitmap()
{
    DBG_PROC_ENTRY("CreateDIBitmap");
    // CreateDIBitmap is never called by GDI.
    // Keep a stub function here so nobody complains.
    //
    RETURN(0);
}
#endif

#ifndef NOSETDIBITSTODEVICE
short WINAPI SetDIBitsToDevice(lpdv, DstXOrg, DstYOrg, StartScan, NumScans,
                         lpCR, lpDrawMode, lpDIBits, lpDIBHdr, lpConvInfo)
LPDV                lpdv;
WORD                DstXOrg;
WORD                DstYOrg;
WORD                StartScan;
WORD                NumScans;
LPRECT              lpCR;
LPDRAWMODE          lpDrawMode;
LPSTR               lpDIBits;
LPBITMAPINFOHEADER  lpDIBHdr;
LPSTR               lpConvInfo;
{
    DBG_PROC_ENTRY("SetDIBitsToDevice");
    RETURN(UniSetDIBitsToDevice(lpdv, DstXOrg, DstYOrg, StartScan, NumScans,
                         lpCR, lpDrawMode, lpDIBits, lpDIBHdr, lpConvInfo));
}
#endif

#ifndef NOSTRETCHDIB
int WINAPI StretchDIB(lpdv, wMode, DstX, DstY, DstXE, DstYE,
                SrcX, SrcY, SrcXE, SrcYE, lpBits, lpDIBHdr,
                lpConvInfo, dwRop, lpbr, lpdm, lpClip)
LPDV                lpdv;
WORD                wMode;
short               DstX, DstY, DstXE, DstYE;
short               SrcX, SrcY, SrcXE, SrcYE;
LPSTR               lpBits;             /* pointer to DIBitmap Bits */
LPBITMAPINFOHEADER  lpDIBHdr;           /* pointer to DIBitmap info Block */
LPSTR               lpConvInfo;         /* not used */
DWORD               dwRop;
LPPBRUSH            lpbr;
LPDRAWMODE          lpdm;
LPRECT              lpClip;
{
    DBG_PROC_ENTRY("StretchDIB");
    RETURN(UniStretchDIB(lpdv, wMode, DstX, DstY, DstXE, DstYE,
            SrcX, SrcY, SrcXE, SrcYE, lpBits, lpDIBHdr,
            lpConvInfo, dwRop, lpbr, lpdm, lpClip));
}
#endif

#if 0   // nobody is calling this DDI. Deleted.
#ifndef NOQUERYDEVICENAMES
long WINAPI QueryDeviceNames(lprgDeviceNames)
LPSTR   lprgDeviceNames;
{
    DBG_PROC_ENTRY("QueryDeviceNames");
    RETURN UniQueryDeviceNames(g_hModule,lprgDeviceNames);
}
#endif
#endif

#ifndef NODEVINSTALL
int WINAPI DevInstall(hWnd, lpDevName, lpOldPort, lpNewPort)
HWND    hWnd;
LPSTR   lpDevName;
LPSTR   lpOldPort, lpNewPort;
{

    short sRc;

    int nRet;
    DBG_PROC_ENTRY("DevInstall");
    //
    // This call is made right after installation of the driver into the system
    // directory.
    //
    DBG_TRACE3("hWnd: %ld DevName: %s OldPort: %s", hWnd,lpDevName,lpOldPort);
    DBG_TRACE1("NewPort: %s",lpNewPort);

    sRc = FaxDevInstall(lpDevName,lpOldPort,lpNewPort);
    if(sRc < 0)
    {
        ERROR_PROMPT(NULL,THUNK_CALL_FAIL);
        RETURN 0;
    }

    if (!sRc)
    {
        DBG_CALL_FAIL("FaxDevInstall",0);
        RETURN 0;
    }
    nRet = UniDevInstall(hWnd, lpDevName, lpOldPort, lpNewPort);

    DBG_TRACE1("UniDevInstall() returned: %d",nRet);

    return nRet;

}
#endif

#ifndef NOBITMAPBITS
BOOL WINAPI BitmapBits(lpdv, fFlags, dwCount, lpBits)
LPDV  lpdv;
DWORD fFlags;
DWORD dwCount;
LPSTR lpBits;
{
    DBG_PROC_ENTRY("BitmapBits");
    RETURN UniBitmapBits(lpdv, fFlags, dwCount, lpBits);
}
#endif

#ifndef NOSELECTBITMAP
BOOL WINAPI DeviceSelectBitmap(lpdv, lpPrevBmp, lpBmp, fFlags)
LPDV     lpdv;
LPBITMAP lpPrevBmp;
LPBITMAP lpBmp;
DWORD    fFlags;
{
    DBG_PROC_ENTRY("DeviceSelectBitmap");
    RETURN UniDeviceSelectBitmap(lpdv, lpPrevBmp, lpBmp, fFlags);
}
#endif

BOOL WINAPI
thunk1632_ThunkConnect16(LPSTR, LPSTR, WORD, DWORD);

#ifndef NOLIBMAIN
int WINAPI LibMain(HANDLE hInstance, WORD wDataSeg, WORD cbHeapSize,
               LPSTR lpszCmdLine)
{
    DBG_PROC_ENTRY("LibMain");
    //
    // Save instance handle.
    //
    g_hModule = hInstance;
    if( !(thunk1632_ThunkConnect16( "fxsdrv.dll",  // name of 16-bit DLL
                                    "fxsdrv32.dll",// name of 32-bit DLL
                                     g_hModule,
                                     1)) )
    {
        DBG_CALL_FAIL("thunk1632_ThunkConnect16",0);
        RETURN FALSE;
    }
    RETURN TRUE;
}
#endif


VOID WINAPI WEP(short fExitWindows);

#pragma alloc_text(WEP_TEXT, WEP)

VOID WINAPI WEP(fExitWindows)
short fExitWindows;
{
    SDBG_PROC_ENTRY("WEP");
    if( !(thunk1632_ThunkConnect16( "fxsdrv.dll",  // name of 16-bit DLL
                                    "fxsdrv32.dll",// name of 32-bit DLL
                                     g_hModule,
                                     0)) )
    {
        DBG_MESSAGE_BOX("thunk1632_ThunkConnect16 failed");
        RETURN;
    }

    RETURN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\stdhdr.c ===
#include "stdhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\16\stdhdr.h ===
#ifndef __FAXDRV__STDHDR_H
#define __FAXDRV__STDHDR_H
                
#define WINVER 0x0400

#define PRINTDRIVER
#define BUILDDLL
#include <print.h>
#include "gdidefs.inc"
#include "faxdrv16.h"
#include "mdevice.h"
#include "unidrv.h"
#include "..\utils\dbgtrace.h"
#include "..\utils\utils.h"
#include "windowsx.h" //GET_WM_COMMAND_ID
#include <commdlg.h>  //GetOpenFileName

#endif //__FAXDRV__STDHDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc16\gdidefs.inc ===
;/*
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;	GDI Definitions for Device Drivers
;
;	Since most of the routines only need a portion of these definitions,
;	conditional assembly flags have been defined in the various files
;	to only include portions as needed (as opposed to having a lot of
;	include files to mess with).  The flags are as follows:
;
;	incFont 	include font definitions
;	incDevice	include device definitions
;	incLogical	include logical object definitions
;	incDrawmode	include DrawMode structure definition
;	incOutput	include Output definitions
;	incControl	include Control definitions
;       incPolyScanline include Scan definition

page
;	General definitions that almost everyone will use.



;	Physical Bitmap Structure
;
;	Bitmap data structure passed to OEM routines.  Defines the location and
;	size of a main memory bitmap.



BITMAP		struc							    ;*/ typedef struct {		 /*

  bmType	    dw	0	; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;		 /*
				; is number of physical display and format
				; of the rest of the structure known only
				; to device driver
  bmWidth	    dw	0	; Width of bitmap in pixels		    ;*/ unsigned short int bmWidth;	 /*
  bmHeight	    dw	0	; Height of bitmap in pixels		    ;*/ unsigned short int bmHeight;	 /*
  bmWidthBytes	    dw	0	; #bytes per scan line			    ;*/ unsigned short int bmWidthBytes; /*
  bmPlanes	    db	0	; # of planes in bitmap 		    ;*/ BYTE		   bmPlanes;	 /*
  bmBitsPixel	    db	0	; # of bits per pixel			    ;*/ BYTE		   bmBitsPixel;  /*
  bmBits	    dd	0	; Far pointer to bits of main memory bitmap ;*/ BYTE FAR	  *bmBits;	 /*
  bmWidthPlanes     dd	0	; Product of bmWidthBytes and bmHeight	    ;*/ unsigned long int  bmWidthPlanes;/*
  bmlpPDevice	    dd	0	; Pointer to associated PDevice 	    ;*/ BYTE FAR	  *bmlpPDevice;  /*
  bmSegmentIndex    dw	0	; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*
  bmScanSegment     dw	0	; Number of scans per segment		    ;*/ unsigned short int bmScanSegment; /*
  bmFillBytes	    dw	0	; Number of unused bytes per segment	    ;*/ unsigned short int bmFillBytes;   /*
		    dw	0						    ;*/ unsigned short int futureUse4;	  /*
		    dw	0						    ;*/ unsigned short int futureUse5;	  /*
BITMAP		    ends						    ;*/ } BITMAP;			  /*

; structures used for Device Independent Bitmap (DIB) processing.
; all taken out of Presentation Manager's documentation 
;  Tuesday 25-October-1988 15:04   -by-   Ron Gery [rong]

; C definitions are provided below (separately).

; triple used in PM1.1 (BitmapCoreInfo) format color table
RGBTriple	    struc	
  rgbtBlue 	    db	0
  rgbtGreen 	    db	0
  rgbtRed 	    db	0
RGBTriple	    ends

; RGB DWORD used in PM2.0 format color table
RGBQuad		    struc
  rgbBlue 	    db	0
  rgbGreen 	    db	0
  rgbRed 	    db	0
  rgbReserved 	    db	0
RGBQuad		    ends

BitmapCoreHeader    struc
  bcSize 	    dd	0
  bcWidth 	    dw	0
  bcHeight 	    dw	0
  bcPlanes 	    dw	0
  bcBitCount 	    dw	0
BitmapCoreHeader    ends

; new format bitmap structure based on PM2.0 format DCR.
;  Tuesday 23-May-1989 16:05   -by-   Ron Gery [rong]

BitmapInfoHeader    struc
  biSize 	    dd	0
  biWidth 	    dd	0
  biHeight 	    dd	0
  biPlanes 	    dw	0
  biBitCount 	    dw	0

  biCompression	    dd  0
  biSizeImage 	    dd	0
  biXPelsPerMeter   dd	0
  biYPelsPerMeter   dd	0
  biClrUsed	    dd	0
  biClrImportant    dd	0
BitmapInfoHeader    ends

BitmapInfo	    struc
  bmiHeader	db (size BitmapInfoHeader) DUP (?)
  bmiColors	db ?			; array of RGBQUADS
BitmapInfo	    ends

BitmapCoreInfo	    struc
  bmciHeader	db (size BitmapCoreHeader) DUP (?)
  bmciColors	db ?			; array of RGBTRIPLES
BitmapCoreInfo	    ends

BI_RGB          equ    0h
BI_RLE8         equ    1h
BI_RLE4         equ    2h
BI_BITFIELDS    equ    3h

BitmapV4Header	struc
  bV4Size	    dd	0
  bV4Width	    dd	0
  bV4Height	    dd	0
  bV4Planes	    dw	0
  bV4BitCount	    dw	0
  bV4Compression    dd	0
  bV4SizeImage	    dd	0
  bV4XPelsPerMeter  dd	0
  bV4YPelsPerMeter  dd	0
  bV4ClrUsed	    dd	0
  bV4ClrImportant   dd	0
  bV4RedMask	    dd	0
  bV4GreenMask	    dd	0
  bV4BlueMask	    dd	0
  bV4AlphaMask	    dd	0
  bV4CSType	    dd	0
  bV4Endpoints	    db	36 dup (0)
  bV4GammaRed	    dd	0
  bV4GammaGreen     dd	0
  bV4GammaBlue	    dd	0
BitmapV4Header	  ends


	if	0

*/
/* C definitions for DIBs, as defined in windows.h */

typedef struct {
	DWORD	bcSize;
	WORD	bcWidth;
	WORD	bcHeight;
	WORD	bcPlanes;
	WORD	bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;

typedef struct {
  	DWORD	   biSize;
  	DWORD	   biWidth;
  	DWORD	   biHeight;
  	WORD	   biPlanes;
  	WORD	   biBitCount;

	DWORD	   biCompression;
	DWORD	   biSizeImage;
	DWORD	   biXPelsPerMeter;
	DWORD	   biYPelsPerMeter;
	DWORD	   biClrUsed;
	DWORD	   biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

typedef struct {
	BYTE	rgbtBlue;
	BYTE	rgbtGreen;
	BYTE	rgbtRed;
} RGBTRIPLE;

typedef struct {
	BYTE	rgbBlue;
	BYTE	rgbGreen;
	BYTE	rgbRed;
	BYTE	rgbReserved;
} RGBQUAD;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

typedef long            FXPT16DOT16, FAR *LPFXPT16DOT16;
typedef long            FXPT2DOT30, FAR *LPFXPT2DOT30;

typedef struct tagCIEXYZ
{
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ  FAR *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
	CIEXYZ  ciexyzRed;
	CIEXYZ  ciexyzGreen;
	CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE    FAR *LPCIEXYZTRIPLE;

typedef struct { 
    BITMAPCOREHEADER	bmciHeader;
    RGBQUAD		bmciColors[1];
} BITMAPCOREINFO;

typedef BITMAPCOREINFO FAR *LPBITMAPCOREINFO;
typedef BITMAPCOREINFO *PBITMAPCOREINFO;

typedef struct { 
    BITMAPINFOHEADER	bmiHeader;
    RGBQUAD		bmiColors[1];
} BITMAPINFO;

typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;

typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER, FAR *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

typedef struct { 
    BITMAPV4HEADER	bmv4Header;
    RGBQUAD		bmv4Colors[1];
} BITMAPV4INFO;

typedef BITMAPV4INFO FAR *LPBITMAPV4INFO;
typedef BITMAPV4INFO *PBITMAPV4INFO;

/* currently, if the low byte of biCompression is non zero, 
 * it must be one of following */

#define BI_RGB              0x00
#define BI_RLE8             0x01
#define BI_RLE4             0x02
#define BI_BITFIELDS        0x03

#define BITMAP_SELECTED     0x01
#define BITMAP_64K	    0x01

#define DIBSIGNATURE	    0x4944
/*
	endif

    if	    0
*/
#ifndef NOPTRC
/*
    endif


PTTYPE		struc							    ;*/ typedef     struct {	    /*

  xcoord	dw	0		;x coordinate of point		    ;*/ short int xcoord;	    /*
  ycoord	dw	0		;y coordinate of point		    ;*/ short int ycoord;	    /*

PTTYPE		ends							    ;*/ } PTTYPE;		    /*
									    ;*/ typedef PTTYPE *PPOINT;     /*
									    ;*/ typedef PTTYPE FAR *LPPOINT; /*
    if	    0
*/
#define     POINT   PTTYPE
/*
    endif



RECT		struc							    ;*/ typedef struct {	    /*

  left		dw	0						    ;*/ short int left, 	    /*
  top		dw	0						    ;*/ 	  top,		    /*
  right 	dw	0						    ;*/ 	  right,	    /*
  bottom	dw	0						    ;*/ 	  bottom;	    /*

RECT		ends							    ;*/ } RECT; 		    /*
									    ;*/ typedef RECT  *PRECT;	    /*

    if	    0
*/
#endif
/*
    endif


BOXTYPE 	struc							    ;*/ typedef     struct {	    /*

  min		db	SIZE PTTYPE dup (?)   ;x,y starting coord	    ;*/ PTTYPE min;		    /*
  ext		db	SIZE PTTYPE dup (?)   ;x,y extents		    ;*/ PTTYPE ext;		    /*

BOXTYPE 	ends							    ;*/ } BOXTYPE;		    /*


									    ;*/ typedef RECT  FAR * LPRECT; /*

page
;	Logical Object Definitions  - incLogical
		ifdef	incLogical
		if	incLogical



OBJ_PEN 	equ	1
OBJ_BRUSH	equ	2
OBJ_FONT	equ	3

    if	0
*/
/* Object definitions used by GDI support routines written in C */

#define OBJ_PEN 	1
#define OBJ_BRUSH	2
#define OBJ_FONT	3
/*
    endif


LogBrush	struc							    ;*/ typedef struct {	    /*
  lbStyle	dw	0		;Style of logical BRUSH 	    ;*/ unsigned short int lbStyle; /*
  lbColor	dd	0		;RGB color			    ;*/ unsigned long int  lbColor; /*
  lbHatch	dw	0		;Hatching style 		    ;*/ unsigned short int lbHatch; /*
  lbBkColor	dd	0		;Background color for hatched brush ;*/ unsigned long int lbBkColor;/*
  lbhcmXform	dd	0		;transform for image color matching ;*/ unsigned long int lbhcmXform;/*
LogBrush	ends							    ;*/ } LOGBRUSH;		    /*

lbPattern      =       lbColor		; pointer to physical pattern

    if	0
*/
#define lbPattern	lbColor
/*
    endif



;	Brush styles defined by GDI

BS_SOLID	equ	0
BS_HOLLOW	equ	1
BS_HATCHED	equ	2
BS_PATTERN	equ	3

MaxBrushStyle	equ	3



;	Hatched Brush hatching styles defined by GDI

HS_HORIZONTAL	equ	0		; Horizontal		 -----
HS_VERTICAL	equ	1		; Vertical		 |||||
HS_FDIAGONAL	equ	2		; Foreward Diagonal	 /////
HS_BDIAGONAL	equ	3		; Backward Diagonal	 \\\\\
HS_CROSS	equ	4		; Cross 		 +++++
HS_DIAGCROSS	equ	5		; Diagonal Cross	 XXXXX

MaxHatchStyle	equ	5

    if	0
*/
/* Brush Style definitions used by GDI support routines written in C */

#define     BS_SOLID		0
#define     BS_HOLLOW		1
#define     BS_HATCHED		2
#define     BS_PATTERN		3

#define     MaxBrushStyle	3


/* Hatch Style definitions used by GDI support routines written in C */

#define     HS_HORIZONTAL	0	/* ----- */
#define     HS_VERTICAL 	1	/* ||||| */
#define     HS_FDIAGONAL	2	/* ///// */
#define     HS_BDIAGONAL	3	/* \\\\\ */
#define     HS_CROSS		4	/* +++++ */
#define     HS_DIAGCROSS	5	/* xxxxx */

#define     MaxHatchStyle	5
/*
    endif




;	Logical Pen Structure

LogPen		struc							    ;*/ typedef struct {	    /*
  lopnStyle	dw	0		;(solid, hollow, dashed..)	    ;*/ unsigned short int lopnStyle;/*
  lopnWidth	dw	0		;This is really a point type	    ;*/ PTTYPE		   lopnWidth;/*
		dw	0
  lopnColor	dd	0						    ;*/ unsigned long int  lopnColor;/*
  lopnStyle2    dw      0               ;end caps and joins                 ;*/ unsigned short int lopnStyle2;/*
  lopnhcmXform	dd	0		;transform for image color matching ;*/ unsigned long int  lopnhcmXform;/*
LogPen		ends							    ;*/ } LOGPEN;		    /*

		errnz	<(SIZE PTTYPE) -4>



;	Line Style definitions for lopnStyle

LS_SOLID	equ	  0
LS_DASHED	equ	  1
LS_DOTTED	equ	  2
LS_DOTDASHED	equ	  3
LS_DASHDOTDOT	equ	  4
LS_NOLINE	equ	  5
LS_INSIDEFRAME	equ	  6
MaxLineStyle	equ	LS_NOLINE

;	Line Style definitions for lopnStyle2

LS_ENDCAP_FLAT  equ     01h
LS_ENDCAP_ROUND equ     02h
LS_ENDCAP_SQUARE equ    04h
LS_JOIN_BEVEL   equ     08h
LS_JOIN_MITER   equ     10h
LS_JOIN_ROUND   equ     20h

    if	0
*/
/* Line Style definitions used by GDI support routines written in C */

#define     LS_SOLID		0
#define     LS_DASHED		1
#define     LS_DOTTED		2
#define     LS_DOTDASHED	3
#define     LS_DASHDOTDOT	4
#define     LS_NOLINE		5
#define     LS_INSIDEFRAME	6
#define     MaxLineStyle	LS_NOLINE

#define     LS_ENDCAP_FLAT      0x01
#define     LS_ENDCAP_ROUND     0x02
#define     LS_ENDCAP_SQUARE    0x04
#define     LS_JOIN_BEVEL       0x08
#define     LS_JOIN_MITER       0x10
#define     LS_JOIN_ROUND       0x20

/*
    endif



; Various constants for defining a logical font.
OUT_DEFAULT_PRECIS	equ	0
OUT_STRING_PRECIS	equ	1
OUT_CHARACTER_PRECIS	equ	2
OUT_STROKE_PRECIS	equ	3
OUT_TT_PRECIS		equ	4
OUT_DEVICE_PRECIS	equ	5
OUT_RASTER_PRECIS	equ	6
OUT_TT_ONLY_PRECIS	equ	7

CLIP_DEFAULT_PRECIS	equ	0
CLIP_CHARACTER_PRECIS	equ	1
CLIP_STROKE_PRECIS	equ	2
CLIP_MASK		equ	00Fh
CLIP_LH_ANGLES		equ	010h
CLIP_TT_ALWAYS		equ	020h
CLIP_EMBEDDED		equ	080h

DEFAULT_QUALITY 	equ	0
DRAFT_QUALITY		equ	1
PROOF_QUALITY		equ	2

DEFAULT_PITCH		equ	0
FIXED_PITCH		equ	1
VARIABLE_PITCH		equ	2

ANSI_CHARSET		equ	0
DEFAULT_CHARSET 	equ	1
SYMBOL_CHARSET		equ	2
MAC_CHARSET		equ	77
SHIFTJIS_CHARSET	equ	128
HANGEUL_CHARSET 	equ	129
CHINESEBIG5_CHARSET	equ	136
OEM_CHARSET		equ	255



;	GDI font families.
FF_DONTCARE		equ 00000000b	; Don't care or don't know.
FF_ROMAN		equ 00010000b	; Variable stroke width, serifed.
					; Times Roman, Century Schoolbook, etc.
FF_SWISS		equ 00100000b	; Variable stroke width, sans-serifed.
					; Helvetica, Swiss, etc.
FF_MODERN		equ 00110000b	; Constant stroke width, serifed or sans-serifed.
					; Pica, Elite, Courier, etc.
FF_SCRIPT		equ 01000000b	; Cursive, etc.
FF_DECORATIVE		equ 01010000b	; Old English, etc.


;	Font weights lightest to darkest.
FW_DONTCARE		equ	0d
FW_THIN 		equ	100d
FW_EXTRALIGHT		equ	200d
FW_LIGHT		equ	300d
FW_NORMAL		equ	400d
FW_MEDIUM		equ	500d
FW_SEMIBOLD		equ	600d
FW_BOLD 		equ	700d
FW_EXTRABOLD		equ	800d
FW_HEAVY		equ	900d

FW_ULTRALIGHT		equ	FW_EXTRALIGHT
FW_REGULAR		equ	FW_NORMAL
FW_DEMIBOLD		equ	FW_SEMIBOLD
FW_ULTRABOLD		equ	FW_EXTRABOLD
FW_BLACK		equ	FW_HEAVY


; Enumeration font types.
RASTER_FONTTYPE 	equ	1
DEVICE_FONTTYPE 	equ	2

    if	0
*/

/* The size to allocate for the lfFaceName field in the logical font. */
#ifndef     LF_FACESIZE
#define     LF_FACESIZE     32
#endif

/* Various constants for defining a logical font. */
#define     OUT_DEFAULT_PRECIS	    0
#define     OUT_STRING_PRECIS	    1
#define     OUT_CHARACTER_PRECIS    2
#define     OUT_STROKE_PRECIS	    3
#define     OUT_TT_PRECIS	    4
#define     OUT_DEVICE_PRECIS	    5
#define     OUT_RASTER_PRECIS	    6
#define     OUT_TT_ONLY_PRECIS	    7

#define     CLIP_DEFAULT_PRECIS     0
#define     CLIP_CHARACTER_PRECIS   1
#define     CLIP_STROKE_PRECIS	    2
#define     CLIP_MASK		    0x0F
#define     CLIP_LH_ANGLES	    0x10
#define     CLIP_TT_ALWAYS	    0x20
#define     CLIP_EMBEDDED	    0x80

#define     DEFAULT_QUALITY	    0
#define     DRAFT_QUALITY	    1
#define     PROOF_QUALITY	    2

#define     DEFAULT_PITCH	    0
#define     FIXED_PITCH 	    1
#define     VARIABLE_PITCH	    2

#define     ANSI_CHARSET	    0
#define     DEFAULT_CHARSET	    1
#define     SYMBOL_CHARSET	    2
#define     MAC_CHARSET		    77
#define     SHIFTJIS_CHARSET	    128
#define     HANGEUL_CHARSET	    129
#define     CHINESEBIG5_CHARSET     136
#define     OEM_CHARSET 	    255


/*	GDI font families.						*/
#define FF_DONTCARE	(0<<4)	/* Don't care or don't know.		*/
#define FF_ROMAN	(1<<4)	/* Variable stroke width, serifed.	*/
				/* Times Roman, Century Schoolbook, etc.*/
#define FF_SWISS	(2<<4)	/* Variable stroke width, sans-serifed. */
				/* Helvetica, Swiss, etc.		*/
#define FF_MODERN	(3<<4)	/* Constant stroke width, serifed or sans-serifed. */
				/* Pica, Elite, Courier, etc.		*/
#define FF_SCRIPT	(4<<4)	/* Cursive, etc.			*/
#define FF_DECORATIVE	(5<<4)	/* Old English, etc.			*/


/*	Font weights lightest to darkest.				*/
#define FW_DONTCARE		0
#define FW_THIN 		100
#define FW_EXTRALIGHT		200
#define FW_LIGHT		300
#define FW_NORMAL		400
#define FW_MEDIUM		500
#define FW_SEMIBOLD		600
#define FW_BOLD 		700
#define FW_EXTRABOLD		800
#define FW_HEAVY		900

#define FW_ULTRALIGHT		FW_EXTRALIGHT
#define FW_REGULAR		FW_NORMAL
#define FW_DEMIBOLD		FW_SEMIBOLD
#define FW_ULTRABOLD		FW_EXTRABOLD
#define FW_BLACK		FW_HEAVY

/* Enumeration font types. */
#define     RASTER_FONTTYPE	    1
#define     DEVICE_FONTTYPE	    2

/*
    endif


LogFont 	struc							    ;*/ typedef     struct  {	       /*

  lfHeight	      dw      0 					    ;*/ short int lfHeight;	       /*
  lfWidth	      dw      0 					    ;*/ short int lfWidth;	       /*
  lfEscapement	      dw      0 					    ;*/ short int lfEscapement;        /*
  lfOrientation       dw      0 					    ;*/ short int lfOrientation;       /*
  lfWeight	      dw      0 					    ;*/ short int lfWeight;	       /*
  lfItalic	      db      0 					    ;*/ BYTE lfItalic;		       /*
  lfUnderline	      db      0 					    ;*/ BYTE lfUnderline;	       /*
  lfStrikeOut	      db      0 					    ;*/ BYTE lfStrikeOut;	       /*
  lfCharSet	      db      0 					    ;*/ BYTE lfCharSet; 	       /*
  lfOutPrecision      db      0 					    ;*/ BYTE lfOutPrecision;	       /*
  lfClipPrecision     db      0 					    ;*/ BYTE lfClipPrecision;	       /*
  lfQuality	      db      0 					    ;*/ BYTE lfQuality; 	       /*
  lfPitchAndFamily    db      0 					    ;*/ BYTE lfPitchAndFamily;	       /*
  lfFaceName	      db      0 ; A variable length field for the face name.;*/ BYTE lfFaceName[LF_FACESIZE];  /*

LogFont 	ends							    ;*/ } LOGFONT;		       /*


		endif
		endif
page
;		Device Definitions - incDevice


		ifdef	incDevice
		if	incDevice


InquireInfo	=	00000001b	;Inquire Device GDI Info
EnableDevice	=	00000000b	;Enable Device
InfoContext	=	    8000h	;Inquire/Enable for information context


;		Device Technologies

DT_PLOTTER	equ	0		; Vector plotter
DT_RASDISPLAY	equ	1		; Raster display
DT_RASPRINTER	equ	2		; Raster printer
DT_RASCAMERA	equ	3		; Raster camera
DT_CHARSTREAM	equ	4		; Character-stream, PLP
DT_METAFILE	equ	5		; Metafile, VDM
DT_DISPFILE	equ	6		; Display-file
DT_JUMBO	equ	11		; SPAG LJ cool thing

;		Curve Capabilities

CC_NONE 	equ 0000000000000000B	; Curves not supported
CC_CIRCLES	equ 0000000000000001B	; Can do circles
CC_PIE		equ 0000000000000010B	; Can do pie wedges
CC_CHORD	equ 0000000000000100B	; Can do chord arcs
CC_ELLIPSES	equ 0000000000001000B	; Can do ellipses (full arcs)
CC_WIDE 	equ 0000000000010000B	; Can do wide lines
CC_STYLED	equ 0000000000100000B	; Can do styled lines
CC_WIDESTYLED	equ 0000000001000000B	; Can do wide styled lines
CC_INTERIORS	equ 0000000010000000B	; Can do interiors
CC_ROUNDRECT	equ 0000000100000000B	; Can do round rectangles
CC_POLYBEZIER	equ 0000001000000000B	; Can do beziers


;		Line Capabilities

LC_NONE 	equ	00000000B	; Lines not supported
LC_POLYSCANLINE equ	00000001B	; Poly Scanlines supported
LC_POLYLINE	equ	00000010B	; Can do polylines
LC_MARKER	equ	00000100B	; Can do markers
LC_POLYMARKER	equ	00001000B	; Can do polymarkers
LC_WIDE 	equ	00010000B	; Can do wide lines
LC_STYLED	equ	00100000B	; Can do styled lines
LC_WIDESTYLED	equ	01000000B	; Can do wide styled lines
LC_INTERIORS	equ	10000000B	; Can do interiors


;		Polygonal Capabilities

PC_NONE 	equ 0000000000000000B	; Polygonals not supported
PC_ALTPOLYGON	equ 0000000000000001B	; Can do alternate polygons
PC_POLYGON      equ 0000000000000001B   ; an old name for ALTPOLYGON
PC_RECTANGLE	equ 0000000000000010B	; Can do rectangles
PC_WINDPOLYGON	equ 0000000000000100B	; Can do winding polygons
PC_TRAPEZOID    equ 0000000000000100B   ; an old name for WINDPOLYGON
PC_SCANLINE	equ 0000000000001000B	; Can do scanlines
PC_WIDE 	equ 0000000000010000B	; Can do wide borders
PC_STYLED	equ 0000000000100000B	; Can do styled borders
PC_WIDESTYLED	equ 0000000001000000B	; Can do wide styled borders
PC_INTERIORS	equ 0000000010000000B	; Can do interiors
PC_POLYPOLYGON  equ 0000000100000000B   ; Can do PolyPolygons
PC_PATHS        equ 0000001000000000B   ; Can do Paths

;		Clipping Capabilities

CP_NONE 	equ	00000000B	; No clipping at device level
CP_RECTANGLE	equ	00000001B	; Device Output clips to rectangles
CP_REGION       equ     00000010B       ; Not supported.
CP_REGION32     equ     00000100B       ; Device Output clips to regions

;		Text Capabilities

TC_OP_CHARACTER equ 0000000000000001B	; Can do OutputPrecision   CHARACTER
TC_OP_STROKE	equ 0000000000000010B	; Can do OutputPrecision   STROKE
TC_CP_STROKE	equ 0000000000000100B	; Can do ClipPrecision	   STROKE
TC_CR_90	equ 0000000000001000B	; Can do CharRotAbility    90
TC_CR_ANY	equ 0000000000010000B	; Can do CharRotAbility    ANY
TC_SF_X_YINDEP	equ 0000000000100000B	; Can do ScaleFreedom	   X_YINDEPENDENT
TC_SA_DOUBLE	equ 0000000001000000B	; Can do ScaleAbility	   DOUBLE
TC_SA_INTEGER	equ 0000000010000000B	; Can do ScaleAbility	   INTEGER
TC_SA_CONTIN	equ 0000000100000000B	; Can do ScaleAbility	   CONTINUOUS
TC_EA_DOUBLE	equ 0000001000000000B	; Can do EmboldenAbility   DOUBLE
TC_IA_ABLE	equ 0000010000000000B	; Can do ItalisizeAbility  ABLE
TC_UA_ABLE	equ 0000100000000000B	; Can do UnderlineAbility  ABLE
TC_SO_ABLE	equ 0001000000000000B	; Can do StrikeOutAbility  ABLE
TC_RA_ABLE	equ 0010000000000000B	; Can do RasterFontAble    ABLE
TC_VA_ABLE	equ 0100000000000000B	; Can do VectorFontAble    ABLE
TC_RESERVED	equ 1000000000000000B	; Reserved. Must be returned zero.

;		Raster Capabilities

RC_NONE 	equ 0000000000000000b	; No Raster Capabilities
RC_BITBLT	equ 0000000000000001b	; Can do bitblt
RC_BANDING	equ 0000000000000010b	; Requires banding support
RC_SCALING	equ 0000000000000100b	; does scaling while banding
RC_BITMAP64	equ 0000000000001000b	; supports >64k bitmaps
RC_GDI20_OUTPUT equ 0000000000010000b	; has 2.0 output calls
RC_GDI20_STATE	equ 0000000000100000b	; dc has a state block
RC_SAVEBITMAP	equ 0000000001000000b	; can save bitmaps locally
RC_DI_BITMAP	equ 0000000010000000b	; can do device independent bitmaps
RC_PALETTE	equ 0000000100000000b	; can do color palette management
RC_DIBTODEV	equ 0000001000000000b	; can do SetDIBitsToDevice
RC_BIGFONT	equ 0000010000000000b	; does BIGFONTs
RC_STRETCHBLT	equ 0000100000000000b	; can do StretchBlt
RC_FLOODFILL	equ 0001000000000000b	; can do FloodFill
RC_STRETCHDIB	equ 0010000000000000b	; can do StretchDIBits
RC_OP_DX_OUTPUT equ 0100000000000000b	;dev opaque and dx array capable
RC_DEVBITS	equ 1000000000000000b	; supports device bitmaps

;	DC Management Flags

DC_SPDevice   equ 00000001b	;Seperate PDevice required per device/filename
DC_1PDevice   equ 00000010b	;Only 1 PDevice allowed per device/filename
DC_IgnoreDFNP equ 00000100b	;Ignore device/filename pairs when matching

;		dpCaps1 capability bits

C1_TRANSPARENT	equ 0000000000000001b	; supports transparency
TC_TT_ABLE	equ 0000000000000010b	; can do TT fonts through DDI or brute
C1_TT_CR_ANY	equ 0000000000000100b	; can do rotated TT fonts
C1_EMF_COMPLIANT equ 0000000000001000b	; Win95 - supports metafile spooling
C1_DIBENGINE	equ 0000000000010000b	; DIB Engine compliant driver
C1_GAMMA_RAMP	equ 0000000000100000b	; supports gamma ramp setting
C1_ICM		equ 0000000001000000b	; does some form of ICM support
C1_REINIT_ABLE  equ 0000000010000000b   ; driver supports ReEnable call    
C1_GLYPH_INDEX  equ 0000000100000000b   ; Driver supports glyph index fonts
C1_BIT_PACKED	equ 0000001000000000b	; Supports bit-packed glyphs
C1_BYTE_PACKED	equ 0000010000000000b	; Supports byte-packed glyphs
C1_COLORCURSOR  equ 0000100000000000b   ; Supports color-cursors and async SetCursor
C1_CMYK_ABLE	equ 0001000000000000b	; Supports CMYK ColorRefs
C1_SLOW_CARD    equ 0010000000000000b   ; Little or no acceleration (VGA, etc.)


;               dpCapsFE capability bits

FEC_TT_DBCS     equ 0000000000100000b   ; can output DBCS TT fonts correctly
FEC_WIFE_ABLE   equ 0000000010000000b   ; can handle WIFE font as Engine font

	if	0
*/

#define     InquireInfo     0x01	/* Inquire Device GDI Info	   */
#define     EnableDevice    0x00	/* Enable Device		   */
#define     InfoContext     0x8000	/* Inquire/Enable for info context */

/*		Device Technologies				   */

#define     DT_PLOTTER		0	/* Vector plotter	   */
#define     DT_RASDISPLAY	1	/* Raster display	   */
#define     DT_RASPRINTER	2	/* Raster printer	   */
#define     DT_RASCAMERA	3	/* Raster camera	   */
#define     DT_CHARSTREAM	4	/* Character-stream, PLP   */
#define     DT_METAFILE 	5	/* Metafile, VDM	   */
#define     DT_DISPFILE 	6	/* Display-file 	   */
#define     DT_JUMBO            11	/* SPAG LJ cool thing	   */		

/*		Curve Capabilities				   */

#define     CC_NONE	    0x0000	/* Curves not supported    */
#define     CC_CIRCLES	    0x0001	/* Can do circles	   */
#define     CC_PIE	    0x0002	/* Can do pie wedges	   */
#define     CC_CHORD	    0x0004	/* Can do chord arcs	   */
#define     CC_ELLIPSES     0x0008	/* Can do ellipese	   */
#define     CC_WIDE	    0x0010	/* Can do wide lines	   */
#define     CC_STYLED	    0x0020	/* Can do styled lines	   */
#define     CC_WIDESTYLED   0x0040	/* Can do wide styled lines*/
#define     CC_INTERIORS    0x0080	/* Can do interiors	   */
#define     CC_ROUNDRECT    0x0100	/* Can do round rectangles */
#define     CC_POLYBEZIER   0x0200      /* Can do polybeziers      */

/*		 Line Capabilities				   */

#define     LC_NONE	    0x0000	/* Lines not supported	   */
#define     LC_POLYSCANLINE 0x0001	/* Poly Scanlines supported*/
#define     LC_POLYLINE     0x0002	/* Can do polylines	   */
#define     LC_MARKER	    0x0004	/* Can do markers	   */
#define     LC_POLYMARKER   0x0008	/* Can do polymarkers	   */
#define     LC_WIDE	    0x0010	/* Can do wide lines	   */
#define     LC_STYLED	    0x0020	/* Can do styled lines	   */
#define     LC_WIDESTYLED   0x0040	/* Can do wide styled lines*/
#define     LC_INTERIORS    0x0080	/* Can do interiors	   */

/*		 Polygonal Capabilities 			   */

#define     PC_NONE	    0x0000	/* Polygonals not supported*/
#define     PC_ALTPOLYGON   0x0001	/* Can do even odd polygons*/
#define     PC_POLYGON      0x0001      /* old name for ALTPOLYGON */
#define     PC_RECTANGLE    0x0002	/* Can do rectangles	   */
#define     PC_WINDPOLYGON  0x0004	/* Can do winding polygons */
#define     PC_TRAPEZOID    0x0004      /* old name for WINDPOLYGON*/
#define     PC_SCANLINE     0x0008	/* Can do scanlines	   */
#define     PC_WIDE	    0x0010	/* Can do wide borders	   */
#define     PC_STYLED	    0x0020	/* Can do styled borders   */
#define     PC_WIDESTYLED   0x0040	/* Can do wide styled borders*/
#define     PC_INTERIORS    0x0080	/* Can do interiors	   */
#define     PC_POLYPOLYGON  0x0100      /* Can do PolyPolygons     */

/*		 Clipping Capabilities				   */

#define     CP_NONE	    0x0000	/* no clipping of Output   */
#define     CP_RECTANGLE    0x0001	/* Output clipped to Rects */
#define     CP_REGION	    0x0002	/* not supported	   */
#define     CP_REGION32     0x0004      /* Output clipped to regions */

/*		 Text Capabilities					       */

#define TC_OP_CHARACTER 0x0001     /* Can do OutputPrecision	CHARACTER      */
#define TC_OP_STROKE	0x0002     /* Can do OutputPrecision	STROKE	       */
#define TC_CP_STROKE	0x0004     /* Can do ClipPrecision	STROKE	       */
#define TC_CR_90	0x0008     /* Can do CharRotAbility	90	       */
#define TC_CR_ANY	0x0010     /* Can do CharRotAbility	ANY	       */
#define TC_SF_X_YINDEP	0x0020     /* Can do ScaleFreedom	X_YINDEPENDENT */
#define TC_SA_DOUBLE	0x0040     /* Can do ScaleAbility	DOUBLE	       */
#define TC_SA_INTEGER	0x0080     /* Can do ScaleAbility	INTEGER        */
#define TC_SA_CONTIN	0x0100     /* Can do ScaleAbility	CONTINUOUS     */
#define TC_EA_DOUBLE	0x0200     /* Can do EmboldenAbility	DOUBLE	       */
#define TC_IA_ABLE	0x0400     /* Can do ItalisizeAbility	ABLE	       */
#define TC_UA_ABLE	0x0800     /* Can do UnderlineAbility	ABLE	       */
#define TC_SO_ABLE	0x1000     /* Can do StrikeOutAbility	ABLE	       */
#define TC_RA_ABLE	0x2000     /* Can do RasterFontAble	ABLE	       */
#define TC_VA_ABLE	0x4000     /* Can do VectorFontAble	ABLE	       */
#define TC_RESERVED	0x8000     /* Reserved. Must be returned zero.        */

/*		 Raster Capabilities				   */

#define RC_NONE 	0x0000		/* No Raster Capabilities	*/
#define RC_BITBLT	0x0001		/* Can do bitblt		*/
#define RC_BANDING	0x0002		/* Requires banding support	*/
#define RC_SCALING	0x0004		/* does scaling while banding	*/
#define RC_BITMAP64	0x0008		/* supports >64k bitmaps	*/
#define RC_GDI20_OUTPUT 0x0010		/* has 2.0 output calls		*/
#define RC_GDI20_STATE	0x0020		/* dc has a state block		*/
#define RC_SAVEBITMAP	0x0040		/* can save bitmaps locally	*/
#define RC_DI_BITMAP	0x0080		/* can do DIBs			*/
#define RC_PALETTE	0x0100		/* can do color pal management	*/
#define RC_DIBTODEV	0x0200		/* can do SetDIBitsToDevice	*/
#define	RC_BIGFONT	0x0400		/* can do BIGFONTs 		*/
#define	RC_STRETCHBLT	0x0800		/* can do StretchBlt		*/
#define	RC_FLOODFILL	0x1000		/* can do FloodFill		*/
#define RC_STRETCHDIB	0x2000		/* can do StretchDIBits 	*/
#define RC_OP_DX_OUTPUT 0x4000		/* can do smart ExtTextOut w/dx */
#define RC_DEVBITS	0x8000		/* supports device bitmaps	*/

/*	DC Management Flags					   */

#define DC_SPDevice	0000001     /* Seperate PDevice required per device/filename */
#define DC_1PDevice	0000002     /* Only 1 PDevice allowed per device/filename    */
#define DC_IgnoreDFNP	0000004     /* Ignore device/filename pairs when matching    */

/*	dpCaps1 capability bits 					    */

#define C1_TRANSPARENT 	0x0001	    /* supports transparency                */
#define TC_TT_ABLE	0x0002	    /* can do TT through DDI or brute       */
#define C1_TT_CR_ANY	0x0004	    /* can do rotated TT fonts              */
#define C1_EMF_COMPLIANT 0x0008	    /* Win95 - supports metafile spooling   */
#define C1_DIBENGINE	0x0010	    /* DIB Engine compliant driver          */
#define C1_GAMMA_RAMP	0x0020	    /* supports gamma ramp setting	    */
#define C1_ICM		0x0040	    /* does some form of ICM support	    */
#define C1_REINIT_ABLE	0x0080	    /* Driver supports ReEnable             */
#define C1_GLYPH_INDEX	0x0100	    /* Driver supports glyph index fonts    */
#define C1_BIT_PACKED	0x0200	    /* Supports bit-packed glyphs	    */
#define C1_BYTE_PACKED	0x0400	    /* Supports byte-packed glyphs	    */
#define C1_COLORCURSOR  0x0800      /* Driver supports color_cursors and async SetCursor */
#define C1_CMYK_ABLE	0x1000	    /* Driver supports CMYK ColorRefs	    */

/*	dpCapsFE capability bits 					    */

#define FEC_TT_DBCS 	0x0020	    /* can output DBCS TT fonts correctly   */
#define FEC_WIFE_ABLE 	0x0080	    /* can handle WIFE font as Engine font  */

/*
	endif

GDIINFO 	struc							    ;*/ typedef struct {	   /*

  dpVersion	dw	0	; Version = 0100h for now		    ;*/ short int dpVersion;	   /*
  dpTechnology	dw	0	; Device classification 		    ;*/ short int dpTechnology;    /*
  dpHorzSize	dw	0	; Horizontal size in millimeters	    ;*/ short int dpHorzSize;	   /*
  dpVertSize	dw	0	; Vertical   size in millimeters	    ;*/ short int dpVertSize;	   /*
  dpHorzRes	dw	0	; Horizontal width in pixels		    ;*/ short int dpHorzRes;	   /*
  dpVertRes	dw	0	; Vertical   width in pixels		    ;*/ short int dpVertRes;	   /*
  dpBitsPixel	dw	0	; Number of bits per pixel		    ;*/ short int dpBitsPixel;	   /*
  dpPlanes	dw	0	; Number of planes			    ;*/ short int dpPlanes;	   /*
  dpNumBrushes	dw	0	; Number of brushes the device has	    ;*/ short int dpNumBrushes;    /*
  dpNumPens	dw	0	; Number of pens the device has 	    ;*/ short int dpNumPens;	   /*
  dpCapsFE	dw	0	; capability bits for Far East		    ;*/ short int dpCapsFE;	   /*
  dpNumFonts	dw	0	; Number of fonts the device has	    ;*/ short int dpNumFonts;	   /*
  dpNumColors	dw	0	; Number of colors in color table	    ;*/ short int dpNumColors;	   /*
  dpDEVICEsize	dw	0	; Size required for the device descriptor   ;*/ short int dpDEVICEsize;    /*
  dpCurves	dw	0	; Curves    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpCurves;	   /*
  dpLines	dw	0	; Line	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpLines;	   /*
  dpPolygonals	dw	0	; Polygonal capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpPolygonals; /*
  dpText	dw	0	; Text	    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpText;	   /*
  dpClip	dw	0	; Clipping  capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpClip;	   /*
  dpRaster	dw	0	; Bitblt    capabilities		    ;*/ unsigned short int	   /*
									    ;*/ 	     dpRaster;	   /*
  dpAspectX	dw	0	; Length of X leg			    ;*/ short int dpAspectX;	   /*
  dpAspectY	dw	0	; Length of Y leg			    ;*/ short int dpAspectY;	   /*
  dpAspectXY	dw	0	; Length of hypotenuse			    ;*/ short int dpAspectXY;	   /*
  dpStyleLen	dw	0	; Length of segment for line styles	    ;*/ short int dpStyleLen;	   /*
  dpMLoWin	dw	0	; Metric  Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoWin;	   /*
		dw	0
  dpMLoVpt	dw	0	; Metric  Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMLoVpt;	   /*
		dw	0
  dpMHiWin	dw	0	; Metric  Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiWin;	   /*
		dw	0
  dpMHiVpt	dw	0	; Metric  Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpMHiVpt;	   /*
		dw	0
  dpELoWin	dw	0	; English Lo res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpELoWin;	   /*
		dw	0
  dpELoVpt	dw	0	; English Lo res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpELoVpt;	   /*
		dw	0
  dpEHiWin	dw	0	; English Hi res WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiWin;	   /*
		dw	0
  dpEHiVpt	dw	0	; English Hi res VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpEHiVpt;	   /*
		dw	0
  dpTwpWin	dw	0	; Twips 	 WinX,WinY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpWin;	   /*
		dw	0
  dpTwpVpt	dw	0	; Twips 	 VptX,VptY  (PTTYPE)	    ;*/ PTTYPE	  dpTwpVpt;	   /*
		dw	0
  dpLogPixelsX	dw	0	;Logical pixels/inch in X		    ;*/ short int dpLogPixelsX;    /*
  dpLogPixelsY	dw	0	;Logical pixels/inch in Y		    ;*/ short int dpLogPixelsY;    /*
  dpDCManage	dw	0	;DC Management flags			    ;*/ short int dpDCManage;	   /*
  dpCaps1	dw	0	; more capability bits			    ;*/ unsigned short int dpCaps1;	/*
  dpSpotSizeX	dw	0						    ;*/ short int futureuse4;		/*
		dw	0						    ;*/ short int futureuse5;		/*
  dpSpotSizeY	dw	0						    ;*/ short int futureuse6;		/*
		dw	0						    ;*/ short int futureuse7;		/*

; start of entries in version 3.0 of this structure

  dpNumPalReg	dw	0	; Number of entries in device's palette	    ;*/ WORD dpNumPalReg;	   /*
  dpPalReserved	dw	0	; Number of reserved entries palette	    ;*/ WORD dpPalReserved;	   /*
  dpColorRes	dw	0	; bits of color resolution (total)	    ;*/ WORD dpColorRes;	   /*
GDIINFO 	ends							    ;*/ } GDIINFO;		   /*

		endif
		endif


page
;	Font Definitions
		ifdef	incFont
		if	incFont

; flags for extended textout

ETO_GRAYED	equ	0001h
ETO_OPAQUE	equ	0002h
ETO_CLIPPED	equ	0004h
ETO_GLYPH_INDEX	equ	0010h
ETO_RTL		equ	0080h
ETO_BYTE_PACKED	equ	0100h
ETO_BIT_PACKED	equ	0200h
ETO_LEVEL_MODE	equ	1000h

PF_BITS_IS_ADDRESS  equ     4
PF_DEVICE_REALIZED  equ     10000000B
PF_RASTER_TYPE	    equ     0
PF_VECTOR_TYPE	    equ     1
PF_OTHER1_TYPE	    equ     2
PF_OTHER2_TYPE	    equ     3
PF_GLYPH_INDEX      equ    20h
PF_WIFE_TYPE        equ    08h


; Glyph types for EngineGetGlyphBmp
EGB_BITMAP          equ     1
EGB_OUTLINE         equ     2
EGB_GRAY2_BITMAP    equ     8
EGB_GRAY4_BITMAP    equ     9
EGB_GRAY8_BITMAP    equ    10


    if	0
*/

/* This bit in the dfType field signals that the dfBitsOffset field is an
   absolute memory address and should not be altered. */
#define PF_BITS_IS_ADDRESS  4

/* This bit in the dfType field signals that the font is device realized. */
#define PF_DEVICE_REALIZED  0x80

/* These bits in the dfType give the fonttype -
       raster, vector, other1, other2. */
#define PF_RASTER_TYPE	    0
#define PF_VECTOR_TYPE	    1
#define PF_OTHER1_TYPE	    2
#define PF_OTHER2_TYPE	    3
#define PF_GLYPH_INDEX   0x20
#define PF_WIFE_TYPE     0x08

/* Glyph types for EngineGetGlyphBmp */
#define EGB_BITMAP          1
#define EGB_OUTLINE         2
#define EGB_GRAY2_BITMAP    8
#define EGB_GRAY4_BITMAP    9
#define EGB_GRAY8_BITMAP   10


/* The size to allocate for the dfMaps field in the physical font. */
#ifndef     DF_MAPSIZE
#define     DF_MAPSIZE	    1
#endif

/*
    endif


;	Font data structure passed to OEM routines.  Refer to chapters 12 and
;	13 of the OEM adaptation guide for a complete description.


FONTINFO	struc							    ;*/ typedef     struct  {	       /*

  dfType	    dw	    0	; Type field for the font.		    ;*/ short int   dfType;	       /*
  dfPoints	    dw	    0	; Point size of font.			    ;*/ short int   dfPoints;	       /*
  dfVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   dfVertRes;	       /*
  dfHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   dfHorizRes;        /*
  dfAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   dfAscent;	       /*
  dfInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   dfInternalLeading; /*
  dfExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   dfExternalLeading; /*
  dfItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    dfItalic;	       /*
  dfUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    dfUnderline;       /*
  dfStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    dfStrikeOut;       /*
  dfWeight	    dw	    0	; Weight of font.			    ;*/ short int   dfWeight;	       /*
  dfCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    dfCharSet;	       /*
  dfPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   dfPixWidth;        /*
  dfPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   dfPixHeight;       /*
  dfPitchAndFamily  db	    0	; Flag specifying variable pitch, family.   ;*/ BYTE	    dfPitchAndFamily;  /*
  dfAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   dfAvgWidth;        /*
  dfMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   dfMaxWidth;        /*
  dfFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    dfFirstChar;       /*
  dfLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    dfLastChar;        /*
  dfDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    dfDefaultChar;     /*
  dfBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    dfBreakChar;       /*
  dfWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   dfWidthBytes;      /*
  dfDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   dfDevice;  /*
  dfFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   dfFace;    /*
  dfBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   dfBitsPointer;/*
  dfBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   dfBitsOffset;/*
				; On the disk, this is relative to the
				; begining of the file. In memory this is
				; relative to the begining of this structure.
  dfReservedByte    db	    0	; filler byte to WORD-align charoffset      ;*/ BYTE dfReservedByte;		/*
  dfCharOffset	    dw	    0	; Area for storing the character offsets,   ;*/ unsigned short dfMaps[DF_MAPSIZE];/*
				; facename, device name (opt), and bitmap.

FONTINFO	ends							    ;*/ } FONTINFO;		       /*

SCALABLEFONTINFO    struc						    ;*/ typedef     struct  {	       /*
  erType	    dw	    0	; Type field for the font.		    ;*/ short int   erType;	       /*
  erPoints	    dw	    0	; Point size of font.			    ;*/ short int   erPoints;	       /*
  erVertRes	    dw	    0	; Vertical digitization.		    ;*/ short int   erVertRes;	       /*
  erHorizRes	    dw	    0	; Horizontal digitization.		    ;*/ short int   erHorizRes;        /*
  erAscent	    dw	    0	; Baseline offset from char cell top.	    ;*/ short int   erAscent;	       /*
  erInternalLeading dw	    0	; Internal leading included in font	    ;*/ short int   erInternalLeading; /*
  erExternalLeading dw	    0	; Prefered extra space between lines	    ;*/ short int   erExternalLeading; /*
  erItalic	    db	    0	; Flag specifying if italic.		    ;*/ BYTE	    erItalic;	       /*
  erUnderline	    db	    0	; Flag specifying if underlined.	    ;*/ BYTE	    erUnderline;       /*
  erStrikeOut	    db	    0	; Flag specifying if struck out.	    ;*/ BYTE	    erStrikeOut;       /*
  erWeight	    dw	    0	; Weight of font.			    ;*/ short int   erWeight;	       /*
  erCharSet	    db	    0	; Character set of font.		    ;*/ BYTE	    erCharSet;	       /*
  erPixWidth	    dw	    0	; Width field for the font.		    ;*/ short int   erPixWidth;        /*
  erPixHeight	    dw	    0	; Height field for the font.		    ;*/ short int   erPixHeight;       /*
  erPitchAndFamily  db	    0	; Flag specifying pitch and family.	    ;*/ BYTE	    erPitchAndFamily;  /*
  erAvgWidth	    dw	    0	; Average character width.		    ;*/ short int   erAvgWidth;        /*
  erMaxWidth	    dw	    0	; Maximum character width.		    ;*/ short int   erMaxWidth;        /*
  erFirstChar	    db	    0	; First character in the font.		    ;*/ BYTE	    erFirstChar;       /*
  erLastChar	    db	    0	; Last character in the font.		    ;*/ BYTE	    erLastChar;        /*
  erDefaultChar     db	    0	; Default character for out of range.	    ;*/ BYTE	    erDefaultChar;     /*
  erBreakChar	    db	    0	; Character to define wordbreaks.	    ;*/ BYTE	    erBreakChar;       /*
  erWidthBytes	    dw	    0	; Number of bytes in each row.		    ;*/ short int   erWidthBytes;      /*
  erDevice	    dd	    0	; Offset to device name.		    ;*/ unsigned long int   erDevice;  /*
  erFace	    dd	    0	; Offset to face name.			    ;*/ unsigned long int   erFace;    /*
  erBitsPointer     dd	    0	; Bits pointer. 			    ;*/ unsigned long int   erBitsPointer;/*
  erBitsOffset	    dd	    0	; Offset to the begining of the bitmap.     ;*/ unsigned long int   erBitsOffset;/*
  erFlags	    db	    0	; flags, and word align the stuff to come   ;*/ BYTE erReservedByte;		/*
  erUnderlinePos    dw	    0	; underline position relative to cell origin	;*/ short int	erUnderlinePos;  /*
  erUnderlineThick  dw	    0	; underline thickness				;*/ short int	erUnderlineThick;/*
  erStrikeoutPos    dw	    0	; Strikeout position relative to cell origin	;*/ short int	erStrikeoutPos;  /*
  erStrikeoutThick  dw	    0	; strikeout thickness				;*/ short int	erStrikeoutThick;/*
SCALABLEFONTINFO    ends						    ;*/ } SCALABLEFONTINFO;	       /*


;------------------------------------------------------------------------------
;--------------------------  4.0 font structures  -----------------------------
;------------------------------------------------------------------------------
; This font format has a simple font header. It contains a version field 
; followed by a glyph format field, the total number of glyphs in the 
; entire font, and the dword offset to the array of glyph offsets.
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
; The NF_LARGE flag indicates that the glyph offset table is
;  array of DWORDs instead of WORD offsets AND that the glyphs
;  have LARGExxxGLYPH headers instead of SMALLxxxGLYPH headers.
;------------------------------------------------------------------------------
NF_BYTE_PACKED	equ	0001h		; Byte aligned row format
NF_BIT_PACKED	equ	0002h		; Bit packed row format
NF_FROM_BMP	equ	0040h		; Derived from bitmap font
NF_LARGE	equ	0080h		; Large offsets and glyph headers

NewFontSeg	struct
 nfVersion	dw	0		; Font version (0x0400)
 nfFormat	dw	0		; Font format flags
 nfNumGlyphs	dw	0		; Number of glyphs in font
 nfGlyphOffset	dd	0		; Offset to glyph offset table
 nfAWTable	dd	0		; Offset to advance width table

 nfHeight	dw	0		; Height of font in pixels
 nfAscent	dw	0		; Distance from baseline to top
 nfUniqueID	dd	0		; Unique identifier for this PFont
NewFontSeg	ends


;----------------------  Byte-packed glyph structures  ------------------------
;
; This structure is the header for a glyph stored in byte-packed 
; row-oriented format. The glyph bitmap is stored immediately after 
; the ROWGLYPH structure.
;------------------------------------------------------------------------------
SMALLROWGLYPH	struc
 srgOrgX	db	0		; Vector to glyph origin in bitmap
 srgOrgY	db	0		;  from upper left corner
 srgWidth	db	0		; Width and height of glyph bmp in
 srgHeight	db	0		;  pixels
SMALLROWGLYPH	ends

LARGEROWGLYPH	struc
 lrgOrgX	dw	0		; Vector to glyph origin in bitmap
 lrgOrgY	dw	0		;  from upper left corner
 lrgWidth	dw	0		; Width and height of glyph bmp in
 lrgHeight	dw	0		;  pixels
LARGEROWGLYPH	ends

;----------------------  Bit-packed glyph structures  -------------------------
;
; This structure is the header for a glyph stored in bit-packed row-oriented 
; format. The glyph bitmap is stored immediately after the BITGLYPH structure.
;
; Bit-packed format means that the glyph rows are packed together end-to-end. 
; There is no padding out to byte boundaries at the end of a row. This
; format results in the highest performance on some accelerated cards and 
; the smallest memory footprint.
;------------------------------------------------------------------------------
SMALLBITGLYPH	struc
 sbgOrgX	db	0		; Vector to glyph origin in bitmap
 sbgOrgY	db	0		;  from upper left corner
 sbgWidth	db	0		; Width and height of glyph bmp in
 sbgHeight	db	0		;  pixels
 sbgPixels	dw	0		; Total # of pixels in the glyph
SMALLBITGLYPH	ends

LARGEBITGLYPH	struc
 lbgOrgX	dw	0		; Vector to glyph origin in bitmap
 lbgOrgY	dw	0		;  from upper left corner
 lbgWidth	dw	0		; Width and height of glyph bmp in
 lbgHeight	dw	0		;  pixels
 lbgPixels	dd	0		; Total # of pixels in the glyph
LARGEBITGLYPH	ends


TEXTXFORM	struc							    ;*/ typedef     struct  {	       /*

  ftHeight	      dw  0						    ;*/ short int ftHeight;	       /*
  ftWidth	      dw  0						    ;*/ short int ftWidth;	       /*
  ftEscapement	      dw  0						    ;*/ short int ftEscapement;        /*
  ftOrientation       dw  0						    ;*/ short int ftOrientation;       /*
  ftWeight	      dw  0						    ;*/ short int ftWeight;	       /*
  ftItalic	      db  0						    ;*/ BYTE ftItalic;		       /*
  ftUnderline	      db  0						    ;*/ BYTE ftUnderline;	       /*
  ftStrikeOut	      db  0						    ;*/ BYTE ftStrikeOut;	       /*
  ftOutPrecision      db  0						    ;*/ BYTE ftOutPrecision;	       /*
  ftClipPrecision     db  0						    ;*/ BYTE ftClipPrecision;	       /*
  ftAccelerator       dw  0						    ;*/ unsigned short int	       /*
									    ;*/ 		ftAccelerator; /*
  ftOverhang	      dw  0						    ;*/ short int ftOverhang;	       /*

TEXTXFORM	ends							    ;*/ } TEXTXFORM;		       /*



TEXTMETRIC	struc							    ;*/ typedef struct {	       /*

  tmHeight		dw  0	  ; Ascent+Descent			    ;*/ short int tmHeight;	       /*
  tmAscent		dw  0	  ; Pixels above the baseline		    ;*/ short int tmAscent;	       /*
  tmDescent		dw  0	  ; Pixels below the baseline		    ;*/ short int tmDescent;	       /*
  tmInternalLeading	dw  0	  ; Internal leading included in font	    ;*/ short int tmInternalLeading;   /*
  tmExternalLeading	dw  0	  ; Prefered extra space between lines	    ;*/ short int tmExternalLeading;   /*
  tmAveCharWidth	dw  0	  ; Of the letter 'X'			    ;*/ short int tmAveCharWidth;      /*
  tmMaxCharWidth	dw  0						    ;*/ short int tmMaxCharWidth;      /*
  tmWeight		dw  0						    ;*/ short int tmWeight;	       /*
  tmItalic		db  0						    ;*/ BYTE	  tmItalic;	       /*
  tmUnderlined		db  0						    ;*/ BYTE	  tmUnderlined;        /*
  tmStruckOut		db  0						    ;*/ BYTE	  tmStruckOut;	       /*
  tmFirstChar		db  0						    ;*/ BYTE	  tmFirstChar;	       /*
  tmLastChar		db  0						    ;*/ BYTE	  tmLastChar;	       /*
  tmDefaultChar 	db  0	  ; dfDefaultChar+dfFirstChar		    ;*/ BYTE	  tmDefaultChar;       /*
  tmBreakChar		db  0	  ; dfBreakChar+dfFirstChar		    ;*/ BYTE	  tmBreakChar;	       /*
  tmPitchAndFamily	db  0	  ; Low bit zero if fixed pitch, one if     ;*/ BYTE	  tmPitchAndFamily;    /*
				  ; variable. Family in high nibble.
  tmCharSet		db  0						    ;*/ BYTE	  tmCharSet;	       /*
  tmOverhang		dw  0						    ;*/ short int tmOverhang;	       /*
  tmDigitizedAspectX	dw  0	  ; Digitization aspect ratio		    ;*/ short int tmDigitizedAspectX;  /*
  tmDigitizedAspectY	dw  0	  ; in X and Y. 			    ;*/ short int tmDigitizedAspectY;  /*

TEXTMETRIC     ends							    ;*/ } TEXTMETRIC;		       /*



		endif
		endif
page
;	Drawing mode definitions - incDrawMode


		ifdef	incDrawMode
		if	incDrawMode


DRAWMODE	struc							    ;*/ typedef     struct {	     /*

  Rop2		dw	0	;The 16-bit encoded Logical op		    ;*/ short int	  Rop2;       /*
  bkMode	dw	0	;Background Mode (for text only)	    ;*/ short int	  bkMode;     /*
  bkColor	dd	0	;Physical background Color		    ;*/ unsigned long int bkColor;    /*
  TextColor	dd	0	;Physical text (forground) color	    ;*/ unsigned long int TextColor;  /*
  TBreakExtra	dw	0	; total pixles to stuff into a line	    ;*/ short int	  TBreakExtra;/*
  BreakExtra	dw	0	; div(TBreakExtra, BreakCount)		    ;*/ short int	  BreakExtra; /*
  BreakErr	dw	0	; running error term			    ;*/ short int	  BreakErr;   /*
  BreakRem	dw	0	; mod(TBreakExtra, BreakCount)		    ;*/ short int	  BreakRem;   /*
  BreakCount	dw	0	; count of breaks in the line		    ;*/ short int	  BreakCount; /*
  CharExtra	dw	0	; extra pixles to stuff after each char     ;*/ short int	  CharExtra;  /*
				;   (used to space out a font)
  LbkColor	dd	0	;Logical background color		    ;*/ unsigned long int LbkColor;   /*
  LTextColor	dd	0	;Logical Text (forground) color 	    ;*/ unsigned long int LTextColor; /*
  ICMCXform	dd	0	;Transform for DIC image color matcher	    ;*/ DWORD		  ICMCXform;  /*
  StretchBltMode dw     0       ;Stretch Blt mode                           ;*/ short         StretchBltMode; /*
  eMiterLimit   dd      0       ;Miter Limit (single precision IEEE float)  ;*/ DWORD             eMiterLimit;/*      

DRAWMODE	ends							    ;*/ } DRAWMODE;		      /*



;	Background Mode definitions

TRANSPARENT	equ	1
OPAQUE		equ	2

BKMODE_TRANSPARENT	equ	1
BKMODE_OPAQUE		equ	2
BKMODE_LEVEL1		equ	3
BKMODE_LEVEL2		equ	4
BKMODE_LEVEL3		equ	5
BKMODE_TRANSLATE	equ	6


;       StretchBlt Mode definitions

STRETCH_ANDSCANS	equ	1
STRETCH_ORSCANS		equ	2
STRETCH_DELETESCANS	equ	3
STRETCH_HALFTONE	equ	4

SBM_BLACKONWHITE	equ	STRETCH_ANDSCANS
SBM_WHITEONBLACK	equ	STRETCH_ORSCANS
SBM_COLORONCOLOR	equ	STRETCH_DELETESCANS
SBM_HALFTONE            equ     STRETCH_HALFTONE

    if	0
*/
/* Background Mode definitions used by GDI support routines written in C */

#define     TRANSPARENT 	1
#define     OPAQUE		2

#define	BKMODE_TRANSPARENT	1
#define	BKMODE_OPAQUE		2
#define	BKMODE_LEVEL1		3
#define	BKMODE_LEVEL2		4
#define	BKMODE_LEVEL3		5
#define	BKMODE_TRANSLATE	6

/* StretchBlt Mode definitions used by GDI support routines written in C */

#define STRETCH_ANDSCANS	1
#define STRETCH_ORSCANS		2
#define STRETCH_DELETESCANS	3
#define STRETCH_HALFTONE	4

#define SBM_BLACKONWHITE	STRETCH_ANDSCANS
#define SBM_WHITEONBLACK	STRETCH_ORSCANS
#define SBM_COLORONCOLOR	STRETCH_DELETESCANS
#define SBM_HALFTONE            STRETCH_HALFTONE

/*
    endif



		endif
		endif
page

;       The SCAN structure used by OS_POLYSCANLINE and DRAWESCAPE.
;       The DRAWESCAPE structure is used by the DrawEcape DDI.

                ifdef   incPolyScanline
                if      incPolyScanline

SCAN		struc							;*/  typedef struct {           /*
  scnPntCnt	dw	?		;Count of X coords (not pairs)	;*/  short int scnPntCnt;       /*
  scnPntTop	dw	?		;Top of scan (inclusive)	;*/  short int scnPntTop;       /*
  scnPntBottom	dw	?		;Bottom of scan (exclusive)	;*/  short int scnPntBottom;    /*
  scnPntX	dw	2 dup (?)	;Var. length array of X pairs	;*/  short int scnPntX[2];      /*
  scnPntCntToo	dw	?		;=scnPntCnt                     ;*/  short int scnPntCntToo;    /*
SCAN		ends							;*/  } SCAN, FAR* LPSCAN;	/*

DRAWESCAPE      struc                                                   ;*/  typedef struct {           /*
  de_cbSize     dd      ?               ;sizeof(DRAWESCAPE)             ;*/  DWORD      cbSize;         /*
  de_lpDestDev  dd      ?               ;PDEVICE or PBITMAP             ;*/  LPVOID     lpDestDev;      /*
  de_nEscape    dd      ?               ;API parameter                  ;*/  DWORD      nEscape;        /*
  de_cbInput    dd      ?               ;API parameter                  ;*/  DWORD      cbInput;        /*
  de_lpszInput  dd      ?               ;API parameter                  ;*/  LPVOID     lpInput;        /*
  de_ptOrigin   dd      ?               ;origin of window               ;*/  POINT      ptOrigin;       /*
  de_dwUniq     dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  de_rcBBox     dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  de_cScans     dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  de_lpScan     dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
DRAWESCAPE      ends                                                    ;*/  } DRAWESCAPE, FAR* LPDRAWESCAPE; /*

REGION          struc                                                   ;*/  typedef struct {           /*
  rgn_id        dw      ?               ;if LPREGION 0x8000 else LPRECT ;*/  WORD       id;             /*
  rgn_cbSize    dw      ?               ;sizeof(REGION)                 ;*/  WORD       cbSize;         /*
  rgn_lprcClip  dd      ?               ;NULL or region walking opt.    ;*/  LPRECT     lprcClip;       /*
  rgn_dwUniq    dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  rgn_rcBBox    dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  rgn_cScans    dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  rgn_lpScan    dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
REGION          ends                                                    ;*/  } REGION, FAR* LPREGION;   /*

                endif   ;incPolyScanline
                endif   ;incPolyScanline

;	Output Definitions - incOutput

		ifdef	incOutput
		if	incOutput


;	Output Style definitions used by GDI


OS_POLYBEZIER   equ     1
OS_ARC		equ	3
OS_SCANLINES	equ	4
OS_POLYSCANLINE equ     5
OS_RECTANGLE	equ	6
OS_ELLIPSE	equ	7
OS_MARKER	equ	8
OS_POLYLINE	equ	18
OS_WINDPOLYGON  equ     20
OS_TRAPEZOID	equ	20      ; replaced with WINDPOLYGON
OS_ALTPOLYGON   equ     22
OS_POLYGON	equ	22      ; replaced with ALTPOLYGON
OS_PIE		equ	23
OS_POLYMARKER	equ	24
OS_CHORD	equ	39
OS_CIRCLE	equ	55

OS_POLYPOLYGON  equ     4000h   ; this bit is ORd with OS_WIND/ALTPOLYGON

OS_BEGINNSCAN	equ	80
OS_ENDNSCAN	equ	81
    if	0
*/

/* Output Style definitions used by GDI support routines written in C */

#define     OS_POLYBEZIER       1
#define     OS_ARC		3
#define     OS_SCANLINES	4
#define     OS_POLYSCANLINE 	5
#define     OS_RECTANGLE	6
#define     OS_ELLIPSE		7
#define     OS_MARKER		8
#define     OS_POLYLINE 	18
#define     OS_TRAPEZOID	20      /* should really be WINDPOLYGON */
#define     OS_WINDPOLYGON      OS_TRAPEZOID
#define     OS_POLYGON		22      /* should really be ALTPOLYGON */
#define     OS_ALTPOLYGON       OS_POLYGON
#define     OS_PIE		23
#define     OS_POLYMARKER	24
#define     OS_CHORD		39
#define     OS_CIRCLE		55

#define     OS_POLYPOLYGON      0x4000  /* this bit is ORd with OS_WIND/ALTPOLYGON */

#define	    OS_BEGINNSCAN	80
#define	    OS_ENDNSCAN		81
/*
    endif


		endif
		endif


		ifdef	incControl
		if	incControl

OEM_FAILED	equ	8000000

;	GDI escape constants

NEWFRAME          equ     1
ABORTDOC	  equ     2
NEXTBAND          equ     3
SETCOLORTABLE     equ     4
GETCOLORTABLE     equ     5
FLUSHOUTPUT       equ     6
DRAFTMODE         equ     7
QUERYESCSUPPORT   equ     8
SETPRINTERDC	  equ	  9
SETABORTPROC      equ     9
STARTDOC          equ     10
ENDDOC            equ     11
GETPHYSPAGESIZE   equ     12
GETPRINTINGOFFSET equ     13
GETSCALINGFACTOR  equ     14
MFCOMMENT         equ     15
GETPENWIDTH       equ     16
SETCOPYCOUNT      equ     17
SELECTPAPERSOURCE equ     18
DEVICEDATA	  equ     19
PASSTHROUGH       equ     19
GETTECHNOLGY	  equ     20
GETTECHNOLOGY	  equ     20
SETLINECAP	  equ	  21
SETLINEJOIN	   equ 	  22
SETMITERLIMIT	   equ 	  23
BANDINFO	   equ 	  24
DRAWPATTERNRECT    equ 	  25
GETVECTORPENSIZE   equ 	  26
GETVECTORBRUSHSIZE equ 	  27
ENABLEDUPLEX	   equ 	  28
GETSETPAPERBINS    equ 	  29
GETSETPRINTORIENT  equ 	  30
ENUMPAPERBINS	   equ 	  31
SETDIBSCALING	   equ 	  32
EPSPRINTING        equ 	  33
ENUMPAPERMETRICS   equ 	  34
GETSETPAPERMETRICS equ 	  35
GETVERSION	   equ	  36
POSTSCRIPT_DATA	   equ 	  37
POSTSCRIPT_IGNORE  equ 	  38
MOUSETRAILS	   equ 	  39
QUERYROPSUPPORT    equ    40
GETDEVICEUNITS	   equ	  42
RESETDEVICE	   equ	  128
GETEXTENDEDTEXTMETRICS equ 256
GETEXTENTTABLE         equ 257
GETPAIRKERNTABLE       equ 258
GETTRACKKERNTABLE      equ 259
EXTTEXTOUT             equ 512
GETFACENAME	       equ 513
DOWNLOADFACE	       equ 514
ENABLERELATIVEWIDTHS   equ 768
ENABLEPAIRKERNING      equ 769
SETKERNTRACK           equ 770
SETALLJUSTVALUES       equ 771
SETCHARSET	       equ 772

STRETCHBLT             equ 2048
QUERYDIBSUPPORT        equ 3073
QDI_SETDIBITS          equ 1h
QDI_GETDIBITS          equ 2h
QDI_DIBTOSCREEN        equ 4h
QDI_STRETCHDIB         equ 8h
DCICOMMAND             equ 3075
BEGIN_PATH	       equ 4096
CLIP_TO_PATH	       equ 4097
END_PATH	       equ 4098
EXT_DEVICE_CAPS	       equ 4099
RESTORE_CTM	       equ 4100
SAVE_CTM	       equ 4101
SET_ARC_DIRECTION      equ 4102
SET_BACKGROUND_COLOR   equ 4103
SET_POLY_MODE	       equ 4104
SET_SCREEN_ANGLE       equ 4105
SET_SPREAD	       equ 4106
TRANSFORM_CTM	       equ 4107
SET_CLIP_BOX	       equ 4108
SET_BOUNDS             equ 4109
OPENCHANNEL	       equ 4110 
DOWNLOADHEADER	       equ 4111 
CLOSECHANNEL	       equ 4112 
SETGDIXFORM	       equ 4113 
RESETPAGE	       equ 4114 
POSTSCRIPT_PASSTHROUGH equ 4115 
				
ENCAPSULATED_POSTSCRIPT equ 4116
				


    if 0
*/
#define OEM_FAILED	    0x80000000L

#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETPRINTERDC		     9		// DDK - between GDI and Driver
#define SETABORTPROC		     9		// SDK - between APP and GDI
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define GETVERSION		     36 	/* ADOBE_11_1_88 */
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define QUERYROPSUPPORT              40
#define GETDEVICEUNITS		     42 
#define RESETDEVICE		     128
#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define DOWNLOADFACE		     514       /* ADOBE_11_1_88 */
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772
#define STRETCHBLT		     2048
#define QUERYDIBSUPPORT              3073
#define QDI_SETDIBITS                0x0001
#define QDI_GETDIBITS                0x0002
#define QDI_DIBTOSCREEN              0x0004
#define QDI_STRETCHDIB               0x0008
#define DCICOMMAND                   3075
#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109
#define OPENCHANNEL		     4110   
#define DOWNLOADHEADER		     4111   
#define CLOSECHANNEL		     4112   
#define SETGDIXFORM		     4113   
#define RESETPAGE		     4114   
#define POSTSCRIPT_PASSTHROUGH	     4115   
#define ENCAPSULATED_POSTSCRIPT      4116   
					    

typedef FONTINFO    FAR *LPFONTINFO;
typedef DRAWMODE    FAR *LPDRAWMODE;
typedef TEXTXFORM   FAR *LPTEXTXFORM;
typedef TEXTMETRIC  FAR *LPTEXTMETRIC;
typedef LOGFONT     FAR *LPLOGFONT;
typedef LOGPEN	    FAR *LPLOGPEN;
typedef LOGBRUSH    FAR *LPLOGBRUSH;
typedef BITMAP	    FAR *LPBITMAP;
typedef FARPROC     FAR *LPFARPROC;
typedef GDIINFO     FAR *LPGDIINFO;
typedef SCALABLEFONTINFO FAR * LPSCALABLEFONTINFO;


/*
    endif



		endif
		endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc\mindrvrc.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// Filename:    mindrvrc.h
//
// This file contains definitions for types of resource tables contained
// in the resource file of the Mini Drivers. 
//-----------------------------------------------------------------------------

// these values have to be greater than 256

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259
#define RC_SUBTABLE    260
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\mindrvrc.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// Filename:    mindrvrc.h
//
// This file contains definitions for types of resource tables contained
// in the resource file of the Mini Drivers. 
//-----------------------------------------------------------------------------

// these values have to be greater than 256

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259
#define RC_SUBTABLE    260
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc16\windowsx.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
* Version 3.10								      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPPAINTSTRUCT)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPRECT)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(LPMDICREATESTRUCT)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam)
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(LPMSG)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), (LPARAM)(int)cyItem))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

/****** Alternate porting layer macros ***************************************/

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      ((BOOL)HIWORD(lp))
#define GET_WM_ACTIVATE_HWND(wp, lp)            ((HWND)LOWORD(lp))
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      \
        (WPARAM)(s), (LPARAM)MAKELONG(hwnd, fmin)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          ((CHAR)wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    \
        (WPARAM)ch, (LPARAM)MAKELONG(hwnd, pos)

#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(LOWORD(lp))
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)id, MAKELONG(hwnd, cmd)

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(LOWORD(lp))
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
#define GET_WM_CTLCOLOR_MSG(type)               WM_CTLCOLOR
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)MAKELONG(hwnd, type)

#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(HIWORD(lp))
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)cmd, (LPARAM)MAKELONG(f, hmenu)

// Note: the following are for interpreting MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (wp)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   \
    (WPARAM)FALSE, (LPARAM)MAKELONG(hmenuF, hmenuW)

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)HIWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)LOWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)ch, (LPARAM)MAKELONG(f, hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (int)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (int)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)msg, (LPARAM)MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)msg, (LPARAM)MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)code, (LPARAM)MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 (int)LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   (int)HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)TRUE, MAKELONG(iStart, iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)0, (LPARAM)MAKELONG(vert, horz)

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc16\prsht.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//----------------------------------------------------------------------------
//
// prsht.h  - PropSheet definitions
//
//----------------------------------------------------------------------------

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME	 u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME	
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif

#define MAXPROPPAGES 100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

typedef struct _PROPSHEETPAGE FAR *LPPROPSHEETPAGE;     // forward declaration

//
// Property sheet page helper function
//

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACK)(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001 // use pResource instead of pszTemplate
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE		0x0008
#define PSP_RTLREADING          0x0010 // MidEast versions only

#define PSP_HASHELP		0x0020
#define PSP_USEREFPARENT	0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

// this structure is passed to CreatePropertySheetPage() and is in the LPARAM on
// of the WM_INITDIALOG message when a property sheet page is created
typedef struct _PROPSHEETPAGE {
        DWORD           dwSize;             // size of this structure (including extra data)
        DWORD           dwFlags;            // PSP_ bits define the use and meaning of fields
        HINSTANCE       hInstance;	    // instance to load the template from
        union {
            LPCSTR          pszTemplate;    // template to use
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;      // PSP_DLGINDIRECT: pointer to resource in memory
#else
            const VOID FAR *pResource;	    // PSP_DLGINDIRECT: pointer to resource in memory
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;              // PSP_USEICON: hIcon to use
            LPCSTR      pszIcon;            // PSP_USEICONID: or icon name string or icon id
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;	    // name to override the template title or string id
        DLGPROC         pfnDlgProc;	    // dlg proc
        LPARAM          lParam;		    // user data
        LPFNPSPCALLBACK pfnCallback;        // if PSP_USECALLBACK this is called with PSPCB_* msgs
        UINT FAR * pcRefParent;		    // PSP_USERREFPARENT: pointer to ref count variable
} PROPSHEETPAGE;
typedef const PROPSHEETPAGE FAR *LPCPROPSHEETPAGE;

#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001 // use "Properties for <lpszCaption>" as the title
#define PSH_USEHICON            0x0002 // use specified hIcon for the caption
#define PSH_USEICONID           0x0004 // use lpszIcon to load the icon
#define PSH_PROPSHEETPAGE       0x0008 // use ppsp instead of phpage (points to array of PROPSHEETPAGE structures)
#define PSH_WIZARD		0x0020 // Wizard
#define PSH_USEPSTARTPAGE	0x0040 // use pStartPage for starting page
#define PSH_NOAPPLYNOW          0x0080 // Remove Apply Now button
#define PSH_USECALLBACK 	0x0100 // pfnCallback is valid
#define PSH_HASHELP		0x0200 // Display help button
#define PSH_MODELESS		0x0400 // modless property sheet, PropertySheet returns HWND
#define PSH_RTLREADING  0x0800 // MidEast versions only

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADER {
        DWORD           dwSize;         // size of this structure
        DWORD           dwFlags;        // PSH_
        HWND            hwndParent;
        HINSTANCE       hInstance;      // to load icon, caption or page string
        union {
            HICON       hIcon;          // PSH_USEHICON: hIcon to use
            LPCSTR      pszIcon;        // PSH_USEICONID: or icon name string or icon id
        } DUMMYUNIONNAME;
        LPCSTR          pszCaption;	// PSH_PROPTITLE: dlg caption or "Properties for <lpszCaption>"
					// may be MAKEINTRESOURCE()

        UINT            nPages;	        // # of HPROPSHEETPAGE (or PROPSHEETPAGE) elements in phpage
	union {
	    UINT        nStartPage;	// !PSH_USEPSTARTPAGE: page number (0-based)
	    LPCSTR      pStartPage;	// PSH_USEPSTARTPAGE: name of page or string id
	} DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGE ppsp;
            HPROPSHEETPAGE FAR *phpage;
        } DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADER, FAR *LPPROPSHEETHEADER;
typedef const PROPSHEETHEADER FAR *LPCPROPSHEETHEADER;

//
// pfnCallback message values
//

#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

//
// property sheet APIs
//

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPage(LPCPROPSHEETPAGE);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheet(LPCPROPSHEETHEADER);
//
// callback for property sheet extensions to call to add pages
//
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);

//
// generic routine for prop sheet extensions to export.  this is called
// to have the extension add pages.  specific versions of this will be
// implemented when necessary.
//

typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);

typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;

#define PSN_FIRST       (0U-200U)
#define PSN_LAST        (0U-299U)

// PropertySheet notification codes sent to the page.  NOTE: RESULTS
// MUST BE RETURNED BY USING SetWindowLong(hdlg, DWL_MSGRESULT, result)

// page is being activated. initialize the data on the page here if other pages can
// effect this page, otherwise init the page at WM_INITDIALOG time. return value is
// ignored.
#define PSN_SETACTIVE           (PSN_FIRST-0)

// indicates the current page is being switched away from.  validate input
// at this time and return TRUE to keep the page switch from happening.
// to commit changes on page switches commit data after validating on this message.
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)

// indicates that the OK or Apply Now buttons have been pressed (OK will
// destroy the dialog when done)
// pshnotify's lparam is true if this was from an IDOK, false if it's from applynow
// return TRUE or PSNRET_INVALID to abort the save
#define PSN_APPLY               (PSN_FIRST-2)

// indicates that the cancel button has been pressed, the page may want use this
// as an oportunity to confirm canceling the dialog.
// pshnotify's lparam is true if it was done by system close button, false if it's from idcancel button
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)

// sent to page indicating that the help button has been pressed
#define PSN_HELP                (PSN_FIRST-5)

// sent to wizard sheets only
#define PSN_WIZBACK		(PSN_FIRST-6)
#define PSN_WIZNEXT		(PSN_FIRST-7)
#define PSN_WIZFINISH		(PSN_FIRST-8)

// called sheet can reject a cancel by returning non-zero
#define PSN_QUERYCANCEL 	(PSN_FIRST-9)

// results that may be returned:
#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2

//// MESSAGES sent to the main property sheet dialog

// used to set the current selection
// supply either the hpage or the index to the tab
#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SendMessage(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)

// remove a page
// wParam = index of page to remove
// lParam = hwnd of page to remove
#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SendMessage(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)

// add a page
// lParam = hPage of page to remove
#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SendMessage(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)

// tell the PS manager that that the page has changed and "Apply Now" should be enabled
// (we may mark the visually tab so the user knows that a change has been made)
#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SendMessage(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)

// tell the PS manager that we need to restart windows due to a change made so
// the restart windows dialog will be presented when dismissing the dialog
#define PSM_RESTARTWINDOWS            (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SendMessage(hDlg, PSM_RESTARTWINDOWS, 0, 0L)

// tell the PS manager that we need to reboot due to a change made so
// the reboot windows dialog will be presented when dismissing the dialog
#define PSM_REBOOTSYSTEM              (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SendMessage(hDlg, PSM_REBOOTSYSTEM, 0, 0L)

// change the OK button to Close and disable cancel.  this indicates a non cancelable
// change has been made
#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SendMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)

// have the PS manager forward this query to each initialized tab's hwnd
// until a non-zero value is returned.  This value is returned to the caller.
#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SendMessage(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)

// tell the PS manager the opposite of PSM_CHANGED -- that the page has reverted
// to its previously saved state.  If no pages remain changed, "Apply Now"
// will be disabled.  (we may remove the visually marked tab so that the user
// knows no change has been made)
#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SendMessage(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)

// tell the PS manager to do an "Apply Now"
#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SendMessage(hDlg, PSM_APPLY, 0, 0L)

// iStyle can be PSH_PROPTITLE or PSH_DEFAULT
// lpszText can be a string or an rcid
#define PSM_SETTITLE            (WM_USER + 111)
#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SendMessage(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCSTR)lpszText)

// tell the PS manager which wizard buttons to enable.
#define PSM_SETWIZBUTTONS	(WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
	PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)

#define PSWIZB_BACK		0x00000001
#define PSWIZB_NEXT		0x00000002
#define PSWIZB_FINISH		0x00000004
#define PSWIZB_DISABLEDFINISH	0x00000008	// Show disabled finish button

// press a button automagically
#define PSM_PRESSBUTTON 	(WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
	SendMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)

#define PSBTN_BACK	0
#define PSBTN_NEXT	1
#define PSBTN_FINISH	2
#define PSBTN_OK	3
#define PSBTN_APPLYNOW	4
#define PSBTN_CANCEL	5
#define PSBTN_HELP	6

// used to set the current selection by supplying the resource ID
// supply either the hpage or the index to the tab
#define PSM_SETCURSELID 	(WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
	SendMessage(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)

//
//  Force the "Finish" button to be enabled and change
//  the text to the specified string.  The Back button will be hidden.
//
#define PSM_SETFINISHTEXT	(WM_USER + 115)
#define PropSheet_SetFinishText(hDlg, lpszText) \
	SendMessage(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)

// returns the tab control
#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SendMessage(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE	(WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SendMessage(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SendMessage(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS 0x2
#define ID_PSREBOOTSYSTEM   (ID_PSRESTARTWINDOWS | 0x1)

//
//  Standard sizes for wizard sheet dialog templates.  Use these sizes to create
//  wizards that conform to the Windows standard.
//
#define WIZ_CXDLG 276
#define WIZ_CYDLG 140

#define WIZ_CXBMP 80	    // Org at 0,0 -- Use WIZ_CYDLG for height

#define WIZ_BODYX 92	    // Y org is 0
#define WIZ_BODYCX 184

//
//  Standard sizes for property sheet dialog templates.  Use these
//  property sheets that conform to the Windows standard.
//
#define PROP_SM_CXDLG	212	// small
#define PROP_SM_CYDLG	188

#define PROP_MED_CXDLG	227	// medium
#define PROP_MED_CYDLG	215	// some are 200

#define PROP_LG_CXDLG	252	// large
#define PROP_LG_CYDLG	218

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc16\print.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER  	 - For inclusion with a printer driver
*  NOPQ         	 - Prevent inclusion of priority queue APIs
*  NOEXTDEVMODEPROPSHEET - Prevent inclusion of shlobj.h and defs for printer
*			   property sheet pages
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
//#pragma pack(1)         /* Assume byte packing throughout */ DANNY
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef PRINTDRIVER

#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI
#define NOENHMETAFILE

#include <windows.h>

#undef NOENHMETAFILE
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC  /* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

#endif /* !PRINTDRIVER */

/* spooler error code */
#define SP_ERROR            (-1)    /* general error - mostly used when spooler isn't loaded */
#define SP_APPABORT         (-2)    /* app aborted the job through the driver */
#define SP_USERABORT        (-3)    /* user aborted the job through spooler's front end */
#define SP_OUTOFDISK        (-4)    /* simply no disk to spool */
#define SP_OUTOFMEMORY      (-5)
#define SP_RETRY            (-6)    /* retry sending to the port again  */

/* Spool routines for use by printer drivers */

typedef HANDLE HPJOB;

HPJOB   WINAPI OpenJobEx(HDC, LPDOCINFO);
HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HDC);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

DWORD   WINAPI DrvSetPrinterData(LPSTR, LPSTR, DWORD, LPBYTE, DWORD);
DWORD   WINAPI DrvGetPrinterData(LPSTR, LPSTR, LPDWORD, LPBYTE, DWORD, LPDWORD);

#define PD_DEFAULT_DEVMODE  "Default DevMode"
#define PD_PRINTER_MODEL    "Printer Model"
#define PD_INSTALLED_MEMORY "Installed Memory"
#define PD_AVAILABLE_MEMORY "Available Memory"

#define INT_PD_DEFAULT_DEVMODE  MAKEINTRESOURCE(1)
#define INT_PD_PRINTER_MODEL    MAKEINTRESOURCE(2)

#define DATATYPE_RAW        "RAW"
#define DATATYPE_EMF        "EMF"
#define DATATYPE_EPS        "EPS"

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64
#define CCHFORMNAME   32

/* current version of specification */
#define DM_SPECVERSION 0x0400

/* field selection bits */
#define DM_ORIENTATION      0x00000001L
#define DM_PAPERSIZE        0x00000002L
#define DM_PAPERLENGTH      0x00000004L
#define DM_PAPERWIDTH       0x00000008L
#define DM_SCALE            0x00000010L
#define DM_COPIES           0x00000100L
#define DM_DEFAULTSOURCE    0x00000200L
#define DM_PRINTQUALITY     0x00000400L
#define DM_COLOR            0x00000800L
#define DM_DUPLEX           0x00001000L
#define DM_YRESOLUTION      0x00002000L
#define DM_TTOPTION         0x00004000L
#define DM_COLLATE          0x00008000L
#define DM_FORMNAME         0x00010000L
#define DM_LOGPIXELS        0x00020000L
#define DM_BITSPERPEL       0x00040000L
#define DM_PELSWIDTH        0x00080000L
#define DM_PELSHEIGHT       0x00100000L
#define DM_DISPLAYFLAGS     0x00200000L
#define DM_DISPLAYFREQUENCY 0x00400000L
#define DM_ICMMETHOD        0x00800000L
#define DM_ICMINTENT        0x01000000L
#define DM_MEDIATYPE        0x02000000L
#define DM_DITHERTYPE       0x04000000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
#define DMPAPER_FIRST               DMPAPER_LETTER
#define DMPAPER_LETTER              1   /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL         2   /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID             3   /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER              4   /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL               5   /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT           6   /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE           7   /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3                  8   /* A3 297 x 420 mm                    */
#define DMPAPER_A4                  9   /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5                  11  /* A5 148 x 210 mm                    */
#define DMPAPER_B4                  12  /* B4 (JIS) 257 x 364 mm              */
#define DMPAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
#define DMPAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14               16  /* 10 x 14 in                         */
#define DMPAPER_11X17               17  /* 11 x 17 in                         */
#define DMPAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8 in       */
#define DMPAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2 in      */
#define DMPAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8 in     */
#define DMPAPER_ENV_12              22  /* Envelope #12 4 3/4 x 11 in         */
#define DMPAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2 in         */
#define DMPAPER_CSHEET              24  /* C size sheet                       */
#define DMPAPER_DSHEET              25  /* D size sheet                       */
#define DMPAPER_ESHEET              26  /* E size sheet                       */
#define DMPAPER_ENV_DL              27  /* Envelope DL  110 x 220 mm          */
#define DMPAPER_ENV_C5              28  /* Envelope C5  162 x 229 mm          */
#define DMPAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH         37  /* Envelope Monarch 3 7/8 x 7 1/2 in  */
#define DMPAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US          39  /* US Standard Fanfold 14 7/8 x 11 in */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Standard Fanfold 8 1/2 x 12 in  */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
/*                                                                                
** the following sizes are new in Windows 95                                      
*/                                                                                
#define DMPAPER_ISO_B4              42  /* B4 (ISO) 250 x 353 mm              */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
#define DMPAPER_ENV_INVITE          47  /* Envelope Invite 220 x 220 mm       */
#define DMPAPER_RESERVED_48         48  /* RESERVED--DO NOT USE               */  
#define DMPAPER_RESERVED_49         49  /* RESERVED--DO NOT USE               */  
/*                                                                                
** the following sizes were used in Windows 3.1 WDL PostScript driver             
** and are retained here for compatibility with the old driver.                   
** Tranverse is used as in the PostScript language, and indicates that            
** the physical page is rotated, but that the logical page is not.
*/
#define DMPAPER_LETTER_EXTRA	      50  /* Letter Extra 9 1/2 x 12 in         */
#define DMPAPER_LEGAL_EXTRA 	      51  /* Legal Extra 9 1/2 x 15 in          */
#define DMPAPER_TABLOID_EXTRA	      52  /* Tabloid Extra 11.69 x 18 in        */
#define DMPAPER_A4_EXTRA     	      53  /* A4 Extra 9.27 x 12.69 in           */
#define DMPAPER_LETTER_TRANSVERSE	  54  /* Letter Transverse 8 1/2 x 11 in    */
#define DMPAPER_A4_TRANSVERSE       55  /* A4 Transverse 210 x 297 mm         */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56 /* Letter Extra Transverse 9 1/2 x 12 in  */
#define DMPAPER_A_PLUS              57  /* SuperA/SuperA/A4 227 x 356 mm      */
#define DMPAPER_B_PLUS              58  /* SuperB/SuperB/A3 305 x 487 mm      */
#define DMPAPER_LETTER_PLUS         59  /* Letter Plus 8.5 x 12.69 in         */
#define DMPAPER_A4_PLUS             60  /* A4 Plus 210 x 330 mm               */
#define DMPAPER_A5_TRANSVERSE       61  /* A5 Transverse 148 x 210 mm         */
#define DMPAPER_B5_TRANSVERSE       62  /* B5 (JIS) Transverse 182 x 257 mm   */
#define DMPAPER_A3_EXTRA            63  /* A3 Extra 322 x 445 mm              */
#define DMPAPER_A5_EXTRA            64  /* A5 Extra 174 x 235 mm              */
#define DMPAPER_B5_EXTRA            65  /* B5 (ISO) Extra 201 x 276 mm        */
#define DMPAPER_A2                  66  /* A2 420 x 594 mm                    */
#define DMPAPER_A3_TRANSVERSE       67  /* A3 Transverse 297 x 420 mm         */
#define DMPAPER_A3_EXTRA_TRANSVERSE 68  /* A3 Extra Transverse 322 x 445 mm   */

#ifdef DBCS

/*
** the following sizes are reserved for the Far East version of Win95.
** Rotated papers rotate the physical page but not the logical page.
*/
#define DMPAPER_DBL_JAPANESE_POSTCARD 69 /* Japanese Double Postcard 200 x 148 mm */
#define DMPAPER_A6                  70  /* A6 105 x 148 mm                 */
#define DMPAPER_JENV_KAKU2          71  /* Japanese Envelope Kaku #2       */
#define DMPAPER_JENV_KAKU3          72  /* Japanese Envelope Kaku #3       */
#define DMPAPER_JENV_CHOU3          73  /* Japanese Envelope Chou #3       */
#define DMPAPER_JENV_CHOU4          74  /* Japanese Envelope Chou #4       */
#define DMPAPER_LETTER_ROTATED      75  /* Letter Rotated 11 x 8 1/2 11 in */
#define DMPAPER_A3_ROTATED          76  /* A3 Rotated 420 x 297 mm         */
#define DMPAPER_A4_ROTATED          77  /* A4 Rotated 297 x 210 mm         */
#define DMPAPER_A5_ROTATED          78  /* A5 Rotated 210 x 148 mm         */
#define DMPAPER_B4_JIS_ROTATED      79  /* B4 (JIS) Rotated 364 x 257 mm   */
#define DMPAPER_B5_JIS_ROTATED      80  /* B5 (JIS) Rotated 257 x 182 mm   */
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81 /* Japanese Postcard Rotated 148 x 100 mm */
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82 /* Double Japanese Postcard Rotated 148 x 200 mm */
#define DMPAPER_A6_ROTATED          83  /* A6 Rotated 148 x 105 mm         */
#define DMPAPER_JENV_KAKU2_ROTATED  84  /* Japanese Envelope Kaku #2 Rotated*/
#define DMPAPER_JENV_KAKU3_ROTATED  85  /* Japanese Envelope Kaku #3 Rotated*/
#define DMPAPER_JENV_CHOU3_ROTATED  86  /* Japanese Envelope Chou #3 Rotated*/
#define DMPAPER_JENV_CHOU4_ROTATED  87  /* Japanese Envelope Chou #4 Rotated*/
#define DMPAPER_B6_JIS              88  /* B6 (JIS) 128 x 182 mm           */
#define DMPAPER_B6_JIS_ROTATED      89  /* B6 (JIS) Rotated 182 x 128 mm   */
#define DMPAPER_12X11               90  /* 12 x 11 in                      */
#define DMPAPER_JENV_YOU4           91  /* Japanese Envelope You #4        */
#define DMPAPER_JENV_YOU4_ROTATED   92  /* Japanese Envelope You #4 Rotated*/
#define DMPAPER_P16K                93  /* PRC 16K 146 x 215 mm            */
#define DMPAPER_P32K                94  /* PRC 32K 97 x 151 mm             */
#define DMPAPER_P32KBIG             95  /* PRC 32K(Big) 97 x 151 mm        */
#define DMPAPER_PENV_1              96  /* PRC Envelope #1 102 x 165 mm    */
#define DMPAPER_PENV_2              97  /* PRC Envelope #2 102 x 176 mm    */
#define DMPAPER_PENV_3              98  /* PRC Envelope #3 125 x 176 mm    */
#define DMPAPER_PENV_4              99  /* PRC Envelope #4 110 x 208 mm    */
#define DMPAPER_PENV_5              100 /* PRC Envelope #5 110 x 220 mm    */
#define DMPAPER_PENV_6              101 /* PRC Envelope #6 120 x 230 mm    */
#define DMPAPER_PENV_7              102 /* PRC Envelope #7 160 x 230 mm    */
#define DMPAPER_PENV_8              103 /* PRC Envelope #8 120 x 309 mm    */
#define DMPAPER_PENV_9              104 /* PRC Envelope #9 229 x 324 mm    */
#define DMPAPER_PENV_10             105 /* PRC Envelope #10 324 x 458 mm   */
#define DMPAPER_P16K_ROTATED        106 /* PRC 16K Rotated                 */
#define DMPAPER_P32K_ROTATED        107 /* PRC 32K Rotated                 */
#define DMPAPER_P32KBIG_ROTATED     108 /* PRC 32K(Big) Rotated            */
#define DMPAPER_PENV_1_ROTATED      109 /* PRC Envelope #1 Rotated 165 x 102 mm*/
#define DMPAPER_PENV_2_ROTATED      110 /* PRC Envelope #2 Rotated 176 x 102 mm*/
#define DMPAPER_PENV_3_ROTATED      111 /* PRC Envelope #3 Rotated 176 x 125 mm*/
#define DMPAPER_PENV_4_ROTATED      112 /* PRC Envelope #4 Rotated 208 x 110 mm*/
#define DMPAPER_PENV_5_ROTATED      113 /* PRC Envelope #5 Rotated 220 x 110 mm*/
#define DMPAPER_PENV_6_ROTATED      114 /* PRC Envelope #6 Rotated 230 x 120 mm*/
#define DMPAPER_PENV_7_ROTATED      115 /* PRC Envelope #7 Rotated 230 x 160 mm*/
#define DMPAPER_PENV_8_ROTATED      116 /* PRC Envelope #8 Rotated 309 x 120 mm*/
#define DMPAPER_PENV_9_ROTATED      117 /* PRC Envelope #9 Rotated 324 x 229 mm*/
#define DMPAPER_PENV_10_ROTATED     118 /* PRC Envelope #10 Rotated 458 x 324 mm */

#define DMPAPER_LAST                DMPAPER_PENV_10_ROTATED

#else

#define DMPAPER_LAST                DMPAPER_A3_EXTRA_TRANSVERSE

#endif

#define DMPAPER_USER        256

/* bin selections */
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_FORMSOURCE    15      /* not supported under windows 95  */
#define DMBIN_LAST          DMBIN_FORMSOURCE

#define DMBIN_USER          256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT         (-1)
#define DMRES_LOW           (-2)
#define DMRES_MEDIUM        (-3)
#define DMRES_HIGH          (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR       2

/* duplex enable */
#define DMDUP_SIMPLEX    1
#define DMDUP_VERTICAL   2
#define DMDUP_HORIZONTAL 3
#define DMDUP_LAST       DMDUP_HORIZONTAL

/* TrueType options */
#define DMTT_BITMAP           1   /* print TT fonts as graphics */
#define DMTT_DOWNLOAD         2   /* download TT fonts as soft fonts */
#define DMTT_SUBDEV           3   /* substitute device fonts for TT fonts */
#define DMTT_DOWNLOAD_OUTLINE 4   /* download TT fonts as outline soft fonts */
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE

/* Collation selections */
#define DMCOLLATE_TRUE      1   /* Collate multiple output pages */
#define DMCOLLATE_FALSE     0   /* Do not collate multiple output pages  */

/* DEVMODE dmDisplayFlags flags */

#define DM_GRAYSCALE        0x00000001L  /* Device is non-color */
#define DM_INTERLACED       0x00000002L  /* device is interlaced */

/* ICM methods */
#define DMICMMETHOD_NONE    1   /* ICM disabled */
#define DMICMMETHOD_SYSTEM  2   /* ICM handled by system */
#define DMICMMETHOD_DRIVER  3   /* ICM handled by driver */
#define DMICMMETHOD_DEVICE  4   /* ICM handled by device */
#define DMICMMETHOD_LAST    DMICMMETHOD_DEVICE

#define DMICMMETHOD_USER  256   /* Device-specific methods start here */

/* ICM Intents */
#define DMICM_SATURATE      1   /* Maximize color saturation */
#define DMICM_CONTRAST      2   /* Maximize color contrast */
#define DMICM_COLORMETRIC   3   /* Use specific color metric */
#define DMICM_LAST          DMICM_COLORMETRIC

#define DMICM_USER        256   /* Device-specific intents start here */

/* Media types */
#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_TRANSPARENCY  2   /* Transparency */
#define DMMEDIA_GLOSSY        3   /* Glossy paper */
#define DMMEDIA_LAST          DMMEDIA_GLOSSY

#define DMMEDIA_USER        256   /* Device-specific media start here */

/* Dither types */
#define DMDITHER_NONE       1       /* No dithering */
#define DMDITHER_COARSE     2       /* Dither with a coarse brush */
#define DMDITHER_FINE       3       /* Dither with a fine brush */
#define DMDITHER_LINEART    4       /* LineArt dithering */
#define DMDITHER_ERRORDIFFUSION 5   /* Error Diffusion */
                                    /* id 6-9 are reserved for future use */
#define DMDITHER_GRAYSCALE  10      /* Device does grayscaling */
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

#define DMDITHER_USER     256   /* Device-specific dithers start here */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
    int   dmCollate;
    char  dmFormName[CCHFORMNAME];
    WORD  dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE           1
#define DM_COPY             2
#define DM_PROMPT           4
#define DM_MODIFY           8

#define DM_IN_BUFFER        DM_MODIFY
#define DM_IN_PROMPT        DM_PROMPT
#define DM_OUT_BUFFER       DM_COPY
#define DM_OUT_DEFAULT      DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS           1
#define DC_PAPERS           2
#define DC_PAPERSIZE        3
#define DC_MINEXTENT        4
#define DC_MAXEXTENT        5
#define DC_BINS             6
#define DC_DUPLEX           7
#define DC_SIZE             8
#define DC_EXTRA            9
#define DC_VERSION          10
#define DC_DRIVER           11
#define DC_BINNAMES         12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE         15
#define DC_PAPERNAMES       16
#define DC_ORIENTATION      17
#define DC_COPIES           18
#define DC_BINADJUST        19
#define DC_EMF_COMPLIANT    20
#define DC_DATATYPE_PRODUCED 21
#define DC_ICC_MANUFACTURER  23
#define DC_ICC_MODEL	     24

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP             0x0000001L
#define DCTT_DOWNLOAD           0x0000002L
#define DCTT_SUBDEV             0x0000004L
#define DCTT_DOWNLOAD_OUTLINE   0x0000008L

/* return values for DC_BINADJUST */
#define DCBA_FACEUPNONE       0x0000
#define DCBA_FACEUPCENTER     0x0001
#define DCBA_FACEUPLEFT       0x0002
#define DCBA_FACEUPRIGHT      0x0003
#define DCBA_FACEDOWNNONE     0x0100
#define DCBA_FACEDOWNCENTER   0x0101
#define DCBA_FACEDOWNLEFT     0x0102
#define DCBA_FACEDOWNRIGHT    0x0103

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE      MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE      MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */


/* BUGBUG, many of these params are const  */

typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE,
                          LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#ifndef NOEXTDEVMODEPROPSHEET
#include <prsht.h>      /* for EXTDEVMODEPROPSHEET  */

/* these are the names of the exports from the printer drivers   */

#define PROCNAME_EXTDEVICEMODE		"EXTDEVICEMODE"
#define PROCNAME_EXTDEVMODEPROPSHEET	"EXTDEVICEMODEPROPSHEET"

/* this function is similar to ExtDeviceMode(), with the following
** changes:
**
** 1) No lpdmIn or lpdmOut. Changes are global
** 2) UI always displays, changes always saved (wMode is always
**    DM_PROMPT | DM_UPDATE)
** 3) Driver enumerates property pages back to the caller via
**    lpfnAddPage and lParam.
**    lpfnAddPage is called by the driver to enumerate each HPROPSHEETPAGE
**    lParam is passed back to lpfnAddPage.
*/

typedef int (WINAPI *LPFNEXTDEVICEMODEPROPSHEET)(
  HWND      hWnd,
	HINSTANCE hinstDriver,
	LPCSTR    lpszDevice, 
	LPCSTR    lpszPort,
  DWORD     dwReserved,
 LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

/* Ordinal for new entry point */
#define PROC_EXTDEVICEMODEPROPSHEET  MAKEINTRESOURCE(95)

#endif  /* NOEXTDEVMODEPROPSHEET  */



HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
// #pragma pack() //DANNY
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\mdevice.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*
** mdevice.h defines minidriver version of structures used in
** minidriv unidrv interface.
*/

// unidrv definitions of these structures are in device.h

#ifndef LPMDV_DEFINED
typedef LPVOID LPMDV;
#define LPMDV_DEFINED
#endif

#ifndef LPDV_DEFINED
typedef struct pdev
{
    short  iType;           // 0 iff memory bitmap, !0 iff our device
    short  oBitmapHdr;      // lpdv+oBitmapHdr points to shadow bitmapheader

    // unidrv never touches the following 3 words --
    // they are reserved for minidriver use only

    LPMDV  lpMdv;           // pointer to minidriver device data
    BOOL   fMdv;            // TRUE iff lpMdv defined
} PDEVICE, FAR * LPDV;
#define LPDV_DEFINED
#endif

#ifndef LPPBRUSH_DEFINED
typedef LPVOID LPPBRUSH;
#define LPPBRUSH_DEFINED
#endif

#ifndef LPPPEN_DEFINED
typedef LPVOID LPPPEN;
#define LPPPEN_DEFINED
#endif

typedef LPDEVMODE LPDM;
typedef short FAR *LPSHORT;

typedef short (FAR PASCAL *LPFNOEMDUMP)       (LPDV, LPPOINT, WORD);
typedef short (FAR PASCAL *LPFNOEMGRXFILTER)  (LPDV, LPSTR, WORD);
typedef void  (FAR PASCAL *LPFNOEMOUTPUTCHAR) (LPDV, LPSTR, WORD);
typedef void  (FAR PASCAL *LPFNOEMOUTPUTCMD)  (LPDV, WORD, LPDWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\inc16\windows.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 4.00                                                  *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x0400).  To exclude
*                   definitions introduced in version 4.0 (or above)
*                   #define WINVER 0x0300
*                   or 0x0310 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
* NOIMT             Installable messge thunk APIs and definitions
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 4.0 */
#ifndef WINVER
#define WINVER  0x0400
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID        void

#define FAR         _far
#define NEAR        _near
#define PASCAL      _pascal
#define CDECL       _cdecl
#define WINAPI      _far _pascal
#define CALLBACK    _far _pascal
#define WINCAPI     _far _cdecl

/****** Simple types & common helper macros *********************************/

typedef int             BOOL;
#define FALSE           0
#define TRUE            1

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef WORD            WCHAR;

typedef unsigned int    UINT;

#ifdef STRICT
typedef signed long     LONG;
#else
#define LONG            long
#endif

typedef short           SHORT;
typedef unsigned long   ULONG;

#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)       ((WORD)(DWORD)(l))
#define HIWORD(l)       ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high)     ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT            WPARAM;
typedef LONG            LPARAM;
typedef LONG            LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL            0
#endif

typedef char NEAR*      PSTR;
typedef char NEAR*      NPSTR;

typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;

typedef BYTE NEAR*      PBYTE;
typedef BYTE FAR*       LPBYTE;
typedef const BYTE FAR* LPCBYTE;

typedef int NEAR*       PINT;
typedef int FAR*        LPINT;

typedef WORD NEAR*      PWORD;
typedef WORD FAR*       LPWORD;

typedef long NEAR*      PLONG;
typedef long FAR*       LPLONG;

typedef DWORD NEAR*     PDWORD;
typedef DWORD FAR*      LPDWORD;

typedef void FAR*       LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*         PHANDLE;
typedef HANDLE NEAR*    SPHANDLE;
typedef HANDLE FAR*     LPHANDLE;

typedef HANDLE          HGLOBAL;
typedef HANDLE          HLOCAL;

typedef HANDLE          GLOBALHANDLE;
typedef HANDLE          LOCALHANDLE;

typedef UINT            ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */
typedef DWORD HKL;                                   

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

#if (WINVER >= 0x0400)
typedef struct tagOSVERSIONINFO {
     	DWORD dwOSVersionInfoSize;
     	DWORD dwMajorVersion;
     	DWORD dwMinorVersion;
     	DWORD dwBuildNumber;
     	DWORD dwPlatformId;
	char  szCSDVersion[128];
} OSVERSIONINFO, NEAR *POSVERSIONINFO, FAR *LPOSVERSIONINFO;

#define VER_PLATFORM_WIN32s    		0
#define VER_PLATFORM_WIN32_WINDOWS	1
#define VER_PLATFORM_WIN32_NT		2

BOOL WINAPI GetVersionEx(LPOSVERSIONINFO lpBuffer);

UINT    WINAPI GetProductName(LPSTR, UINT);
#endif  /* WINVER >= 0x0400 */

#if (WINVER >= 0x0400)
#define GFS_PHYSICALRAMSIZE   0x1793
#define GFS_NEARESTMEGRAMSIZE 0x1794
#endif  /* WINVER >= 0x0400 */
DWORD   WINAPI GetFreeSpace(UINT);

UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#if (WINVER < 0x030a)
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#endif
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_DOSPAGING    0x1000
#define WF_HASCPUID     0x2000
#define WF_WINNT        0x4000
#define WF_WLO          0x8000
#define WF_CPUMASK      0xFC000000
#define WF_CPU_X86	0
#define WF_CPU_R4000	1
#define WF_CPU_ALPHA	2
#define WF_CPU_CLIPPER	3

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

#define ERR_SIZE_MASK   0x3000
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
#if (WINVER >= 0x0400)
    WORD    chDefRIP;
#endif /* WINVER >= 0x0400 */
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42

#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM         0x43
BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOOPENFILEERRORBOX      0x8000

UINT    WINAPI SetErrorMode(UINT);

#if (WINVER >= 0x0400)
void    WINAPI SetLastError(DWORD);
DWORD   WINAPI GetLastError(void);
#endif /* WINVER >= 0x0400 */

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);

#if (WINVER >= 0x0400)
void    WINAPI ProfStart32(void);
void    WINAPI ProfStop32(void);
void    WINAPI ProfClear32(void);
void    WINAPI ProfFlush32(void);
void    WINAPI ProfFinish32(void);
#endif /* WINVER >= 0x0400) */
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE NEAR *, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT    offSegment;
    UINT    cbSegment;
    UINT    flags;
    UINT    cbAlloc;
    HGLOBAL h;
    UINT    alignShift;
    UINT    reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL 0

/****** Task Management *****************************************************/

#endif /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED     0x4000
#define GMEM_LOCKCOUNT     0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);
#if (WINVER >= 0x0400)                      
UINT    WINAPI GlobalSmartPageLock(HGLOBAL);
UINT    WINAPI GlobalSmartPageUnlock(HGLOBAL);
#endif /* WINVER >= 0x0400 */		      

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)

HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED     0x4000
#define LMEM_LOCKCOUNT     0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

#if (WINVER >= 0x0400)
/* OpenFileEx() Structure */
typedef struct tagOFSTRUCTEX
{
    WORD nBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[260];
} OFSTRUCTEX;
typedef OFSTRUCTEX*       POFSTRUCTEX;
typedef OFSTRUCTEX NEAR* NPOFSTRUCTEX;
typedef OFSTRUCTEX FAR*  LPOFSTRUCTEX;
#endif  /* WINVER >= 0x0400 */

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400  /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400  /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
#if (WINVER >= 0x0400)
HFILE   WINAPI OpenFileEx(LPCSTR, OFSTRUCTEX FAR*, UINT);
#endif  /* WINVER >= 0x0400 */

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ                0
#define WRITE               1
#define READ_WRITE          2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long WINAPI _hread(HFILE, void _huge*, long);
long WINAPI _hwrite(HFILE, const void _huge*, long);
#endif /* WINVER >= 0x030a */

#endif /* NOLFILEIO */

#if (WINVER >= 0x0400)
DWORD   WINAPI GetCurrentDirectory(DWORD, LPSTR);
BOOL    WINAPI SetCurrentDirectory(LPCSTR);

#define MAX_PATH 260

#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, NEAR *PFILETIME, FAR *LPFILETIME;

typedef struct _WIN32_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char   cFileName[ MAX_PATH ];
    char   cAlternateFileName[ 14 ];
} WIN32_FIND_DATA, NEAR *PWIN32_FIND_DATA, FAR *LPWIN32_FIND_DATA;

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100
#define FILE_ATTRIBUTE_ATOMIC_WRITE     0x00000200
#define FILE_ATTRIBUTE_XACTION_WRITE    0x00000400

DECLARE_HANDLE32(HFINDFILE);
#define INVALID_HFINDFILE       ((HFINDFILE)-1)

HFINDFILE WINAPI FindFirstFile(LPCSTR, LPWIN32_FIND_DATA);
BOOL      WINAPI FindNextFile(HFINDFILE, LPWIN32_FIND_DATA);
BOOL      WINAPI FindClose(HFINDFILE);

DWORD     WINAPI GetFileAttributes(LPCSTR);
BOOL      WINAPI SetFileAttributes(LPCSTR, DWORD);
BOOL      WINAPI GetDiskFreeSpace(LPCSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
BOOL      WINAPI CreateDirectory(LPCSTR, LPVOID);
BOOL      WINAPI RemoveDirectory(LPCSTR);
BOOL      WINAPI DeleteFile(LPCSTR);
#endif /* WINVER >= 0x0400 */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE     (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS          0x0000
#define WN_NOT_SUPPORTED    0x0001
#define WN_NET_ERROR        0x0002
#define WN_MORE_DATA        0x0003
#define WN_BAD_POINTER      0x0004
#define WN_BAD_VALUE        0x0005
#define WN_BAD_PASSWORD     0x0006
#define WN_ACCESS_DENIED    0x0007
#define WN_FUNCTION_BUSY    0x0008
#define WN_WINDOWS_ERROR    0x0009
#define WN_BAD_USER         0x000A
#define WN_OUT_OF_MEMORY    0x000B
#define WN_CANCEL           0x000C
#define WN_CONTINUE         0x000D

/* Connection errors */
#define WN_NOT_CONNECTED    0x0030
#define WN_OPEN_FILES       0x0031
#define WN_BAD_NETNAME      0x0032
#define WN_BAD_LOCALNAME    0x0033
#define WN_ALREADY_CONNECTED    0x0034
#define WN_DEVICE_ERROR         0x0035
#define WN_CONNECTION_CLOSED    0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)     GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR       MAKEINTRESOURCE(1)
#define RT_BITMAP       MAKEINTRESOURCE(2)
#define RT_ICON         MAKEINTRESOURCE(3)
#define RT_MENU         MAKEINTRESOURCE(4)
#define RT_DIALOG       MAKEINTRESOURCE(5)
#define RT_STRING       MAKEINTRESOURCE(6)
#define RT_FONTDIR      MAKEINTRESOURCE(7)
#define RT_FONT         MAKEINTRESOURCE(8)
#define RT_ACCELERATOR  MAKEINTRESOURCE(9)
#define RT_RCDATA       MAKEINTRESOURCE(10)
#define RT_GROUP_CURSOR MAKEINTRESOURCE(12)
#define RT_GROUP_ICON   MAKEINTRESOURCE(14)
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE; use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE; use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE; use OIC_WINLOGO */
#define OCR_NO              32648   
#if (WINVER >= 0x0400)
#endif  /* WINVER >= 0x400 */

#define OIC_SAMPLE              32512
#define OIC_ERROR               32513
#define OIC_QUES                32514
#define OIC_WARNING             32515
#define OIC_INFORMATION         32516

#define OIC_HAND                OIC_ERROR
#define OIC_BANG                OIC_WARNING
#define OIC_NOTE                OIC_INFORMATION

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#if (WINVER >= 0x0400)
BOOL    WINAPI GetPrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
BOOL    WINAPI WritePrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
UINT    WINAPI GetProfileSectionNames(LPSTR, UINT);
UINT    WINAPI GetPrivateProfileSectionNames(LPSTR, UINT, LPCSTR);
int     WINAPI GetPrivateProfileSection(LPCSTR, LPSTR, UINT, LPCSTR);
int     WINAPI GetProfileSection(LPCSTR, LPSTR, UINT);
BOOL    WINAPI WritePrivateProfileSection(LPCSTR, LPCSTR, LPCSTR);
BOOL    WINAPI WriteProfileSection(LPCSTR, LPCSTR);
#endif /* WINVER >= 0x0400 */

/****** Registration Database Support ***************************************/
/* return codes from Registration functions */
/* Retained for win 3.x compatibility  and not needed 4.0 onwards */
/* For 4.0 onwards you should be including winerror.h */

#if (WINVER < 0x0400)

#define ERROR_SUCCESS			0L
#define ERROR_BADDB                     1L
#define ERROR_BADKEY			2L
#define ERROR_CANTOPEN			3L
#define ERROR_CANTREAD			4L
#define ERROR_CANTWRITE			5L
#define ERROR_INSUFFICIENT_MEMORY	6L
#define ERROR_INVALID_PARAMETER         7L
#define	ERROR_ACCESS_DENIED		8L

#endif /* WINVER < 0x400 */

#define REG_SZ				0x0001

#if (WINVER >= 0x0400)
#define REG_BINARY			0x0003
#define REG_DWORD                       0x0004
#endif

typedef DWORD HKEY;
typedef HKEY FAR* LPHKEY;

#if (WINVER < 0x0400)		// Win 3.1 compatibility
#define HKEY_CLASSES_ROOT		(( HKEY) 0x1)
#else				// Win 4 upwards
#define HKEY_CLASSES_ROOT		(( HKEY) 0x80000000)
#define HKEY_CURRENT_USER		(( HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE		(( HKEY) 0x80000002)
#define HKEY_USERS			(( HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA		(( HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG		(( HKEY) 0x80000005)
#define HKEY_DYN_DATA			(( HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS		7
#endif

LONG    WINAPI RegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCloseKey(HKEY);
LONG    WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG    WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG    WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG    WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

#if (WINVER >= 0x0400)
LONG    WINAPI RegDeleteValue(HKEY, LPCSTR);
LONG    WINAPI RegEnumValue(HKEY, DWORD, LPCSTR,
                         LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                         LONG FAR *);
LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
			    LPBYTE, LONG FAR *);
LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG    WINAPI RegFlushKey(HKEY);
LONG	WINAPI RegSaveKey(HKEY, LPCSTR,LPVOID);
LONG	WINAPI RegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG	WINAPI RegUnLoadKey(HKEY, LPCSTR);

#endif		// WINVER >= 0x0400

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, DWORD);
#if (WINVER >= 0x0400)
LPSTR   WINAPI lstrcatn(LPSTR, LPCSTR, int);
#endif /* WINVER >= 0x0400 */
#endif /* WINVER >= 0x030a */
#endif /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
UINT    WINAPI VkKeyScanEx(UINT,HKL);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
UINT    WINAPI MapVirtualKeyEx(UINT,UINT,HKL);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);
int     WINAPI ToAsciiEx(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags,HKL hkl);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;
typedef const RECT FAR * LPCRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;
typedef const POINT FAR * LPCPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Common structures for 4.X/Win32 GDI APIs */

typedef struct tagPOINTS
{
   SHORT    x;
   SHORT    y;

} POINTS;
typedef POINTS*       PPOINTS;
typedef POINTS NEAR*  NPPOINTS;
typedef POINTS FAR*   LPPOINTS;
typedef const POINTS FAR* LPCPOINTS;

typedef struct tagPOINTL
{
   LONG     x;
   LONG     y;

} POINTL;
typedef POINTL*       PPOINTL;
typedef POINTL NEAR*  NPPOINTL;
typedef POINTL FAR*   LPPOINTL;
typedef const POINTL FAR* LPCPOINTL;

typedef struct tagSIZEL
{
   LONG     cx;
   LONG     cy;

} SIZEL;
typedef SIZEL*       PSIZEL;
typedef SIZEL NEAR*  NPSIZEL;
typedef SIZEL FAR*   LPSIZEL;
typedef const SIZEL FAR* LPCSIZEL;

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
                       
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;
#endif /* WINVER >= 0x0400 */

#define MAKEPOINT(l)     (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, LPCRECT lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, LPRECT lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080
#define PC_POLYPOLYGON      0x0100
#define PC_PATHS            0x0200

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT         1
#define MM_LOMETRIC     2
#define MM_HIMETRIC     3
#define MM_LOENGLISH    4
#define MM_HIENGLISH    5
#define MM_TWIPS        6
#define MM_ISOTROPIC    7
#define MM_ANISOTROPIC  8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)      ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)  ((BYTE)(rgb))
#define GetGValue(rgb)  ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)  ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

HBRUSH   WINAPI GetSysColorBrush(int);
COLORREF WINAPI GetSysColor(int);
void     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR             0
#define COLOR_DESKTOP               1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER          10
#define COLOR_INACTIVEBORDER        11
#define COLOR_APPWORKSPACE          12
#define COLOR_HIGHLIGHT             13
#define COLOR_HIGHLIGHTTEXT         14
#define