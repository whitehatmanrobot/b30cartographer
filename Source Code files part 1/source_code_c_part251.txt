om object with zero interfaces, 
        // use the global one.
        //

        InitInterfaceVTableMap();
        if (IsComObjectType())
            SetComObjectType();
    }
    else
    {
        // 
        // Assign an interface ID
        //

        pCl = GetClass();

        UINT32 id = pCl->AssignInterfaceId();

        //
        // Set up our entry in the global interface vtable
        // 

        if (pCl->IsSharedInterface())
        {
            // need to copy this to all the appdomains interface managers
            SystemDomain::PropogateSharedInterface(id, GetVtable());
        }
        else
        {
            GetModule()->GetDomain()->
              GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers()[id] 
              = (LPVOID)(GetVtable());
        }
    }

    // If we have any thread local statics, our class needs an index, allocate it now.
    pCl = GetClass();
    if (pCl->GetThreadStaticsSize() > 0)
    {
        if(IsShared())
            SetThreadStaticOffset ((WORD)BaseDomain::IncSharedTLSOffset());
        else 
            SetThreadStaticOffset ((WORD)GetDomain()->IncUnsharedTLSOffset());
    }

        // same for context local statics 
    if (pCl->GetContextStaticsSize() > 0)
    {
        if(IsShared())
            SetContextStaticOffset ((WORD)BaseDomain::IncSharedCLSOffset());
        else 
            SetContextStaticOffset ((WORD)GetDomain()->IncUnsharedCLSOffset());
    }


    //
    // Map our system interfaces into the current app domain for COM interop
    //

    pCl->MapSystemInterfaces();

    //
    // Store under IID map
    // 

    pCl->GetClassLoader()->InsertClassForCLSID(pCl);

#if CHECK_APP_DOMAIN_LEAKS

    // 
    // Figure out if we're domain agile.. Need to do this before we start
    // allocating objects of the type (which could happen in InstantiateStaticHandles)
    // because need to determine agility prior to setting the appdomain. 
    // 

    if (g_pConfig->AppDomainLeaks())
        _ASSERTE(pCl->IsAppDomainAgilityDone());

#endif

    //
    // Allocate handles for statics
    // 

    if (IsShared())
        FixupStaticMethodTables();
    else
        InstantiateStaticHandles((OBJECTREF**)(m_Vtable + (size_t)pCl->GetNumMethodSlots()), TRUE);

    //
    // Restore field marshaler vptrs
    // 

    if (pCl->HasLayout())
    {
        pCl = GetClass();
        EEClassLayoutInfo *pInfo = &((LayoutEEClass*)pCl)->m_LayoutInfo;
        
        FieldMarshaler *pFM = (FieldMarshaler *)pInfo->GetFieldMarshalers();
        FieldMarshaler *pFMEnd = (FieldMarshaler*) ((BYTE *)pFM + pInfo->GetNumCTMFields()*MAXFIELDMARSHALERSIZE);
        while (pFM < pFMEnd)
        {
            FieldMarshaler::RestoreConstruct((void*)pFM, GetModule());
            ((BYTE*&)pFM) += MAXFIELDMARSHALERSIZE;
        }
    }

    if (GetParentClass() != NULL)
        GetParentClass()->NoticeSubtype(pCl);


    SetClassRestored();

    if (pCl->IsInited())
    {
        //
        // Clear the method table's flag.
        //

        SetClassInited();
    }
}
*/

/*******************************************************************/
// See EEClass::DoRunClassInit() below.  Here we haven't brought the EEClass into our
// working set yet.  We only impact working set if there is a strong likelihood that
// the class needs <clinit> to be run.
BOOL MethodTable::CheckRunClassInit(OBJECTREF *pThrowable)
{
    _ASSERTE(IsRestored());
    
    // To find GC hole easier...
    TRIGGERSGC();

    if (IsClassInited())
        return TRUE;

    return GetClass()->DoRunClassInit(pThrowable);
}

BOOL MethodTable::CheckRunClassInit(OBJECTREF *pThrowable, 
                                    DomainLocalClass **ppLocalClass,
                                    AppDomain *pDomain)
{
    _ASSERTE(IsRestored());

    
    // To find GC hole easier...
    TRIGGERSGC();

    if (IsShared())
    {    
        if (pDomain==NULL)
            pDomain = SystemDomain::GetCurrentDomain();

        DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();

        if (pLocalBlock->IsClassInitialized(GetSharedClassIndex()))
        {
            if (ppLocalClass != NULL)
                *ppLocalClass = pLocalBlock->GetClass(GetSharedClassIndex());

            return TRUE;
        }
    }
    
    if (IsClassInited())
    {
        if (ppLocalClass != NULL)
            *ppLocalClass = NULL;

        return TRUE;
    }

    return GetClass()->DoRunClassInit(pThrowable, pDomain, ppLocalClass);
}

CorIfaceAttr MethodTable::GetComInterfaceType()
{
    // This should only be called on interfaces.
    _ASSERTE(IsInterface());

    // Check to see if we have already determined the COM interface type
    // of this interface.
    if (m_ComInterfaceType != (CorIfaceAttr)-1)
        return m_ComInterfaceType;

    // Retrieve the interface type from the metadata.
    CorIfaceAttr ItfType = ifDual;
    HRESULT hr = GetClass()->GetMDImport()->GetIfaceTypeOfTypeDef(GetClass()->GetCl(), (ULONG*)&ItfType);
    _ASSERTE(SUCCEEDED(hr));

    // Cache the interface type
    m_ComInterfaceType = ItfType;
    return ItfType;
}

OBJECTREF MethodTable::Allocate()
{
    THROWSCOMPLUSEXCEPTION();

    CheckRestore();

    if (!IsClassInited())
    {
        OBJECTREF throwable = NULL;
        if (!CheckRunClassInit(&throwable))
            COMPlusThrow(throwable);
    }

    return AllocateObject(this);
}

OBJECTREF MethodTable::Box(void *data, BOOL mayContainRefs)
{
    _ASSERTE(IsValueClass());

    OBJECTREF ref;

    GCPROTECT_BEGININTERIOR (data);
    ref = Allocate();

    if (mayContainRefs)
        CopyValueClass(ref->UnBox(), data, this, ref->GetAppDomain());
    else
        memcpyNoGCRefs(ref->UnBox(), data, GetClass()->GetAlignedNumInstanceFieldBytes());

    GCPROTECT_END ();
    return ref;
}

CorClassIfaceAttr EEClass::GetComClassInterfaceType()
{
    THROWSCOMPLUSEXCEPTION();

    // This should only be called on classes.
    _ASSERTE(!IsInterface());

    const BYTE *pVal;
    ULONG cbVal;

    // First look for the class interface attribute at the class level.
    HRESULT hr = GetMDImport()->GetCustomAttributeByName(GetCl(), INTEROP_CLASSINTERFACE_TYPE, (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        _ASSERTE("The ClassInterface custom attribute is invalid" && cbVal);
        _ASSERTE("ClassInterface custom attribute does not have the right format" && (*pVal == 0x01) && (*(pVal + 1) == 0x00));
        CorClassIfaceAttr ClassItfType = (CorClassIfaceAttr)*(pVal + 2);
        if (ClassItfType < clsIfLast)
            return ClassItfType;
    }

    // If we haven't found the class interface attribute at the class level then look at the 
    // assembly level.
    Assembly *pAssembly = GetAssembly();
    if (pAssembly->IsAssembly())
    {
        IfFailThrow(pAssembly->GetManifestImport()->GetCustomAttributeByName(pAssembly->GetManifestToken(), INTEROP_CLASSINTERFACE_TYPE, (const void**)&pVal, &cbVal));
        if (hr == S_OK)
        {
            _ASSERTE("The ClassInterface custom attribute is invalid" && cbVal);
            _ASSERTE("ClassInterface custom attribute does not have the right format" && (*pVal == 0x01) && (*(pVal + 1) == 0x00));
            CorClassIfaceAttr ClassItfType = (CorClassIfaceAttr)*(pVal + 2);
            if (ClassItfType < clsIfLast)
                return ClassItfType;
        }
    }

    return DEFAULT_CLASS_INTERFACE_TYPE;
}

Assembly* EEClass::GetAssembly()
{
    return GetClassLoader()->m_pAssembly;
}

BaseDomain* EEClass::GetDomain()
{
    return GetAssembly()->GetDomain();
}

BOOL EEClass::RunClassInit(DeadlockAwareLockedListElement *pEntry, OBJECTREF *pThrowable)
{
    Thread *pCurThread = GetThread();

    _ASSERTE(IsRestored());

    // This behavior is being removed from spec - I don't want to delete the code though
    // until I've run tests.
#if 0 

    // Init the parent first if it hasn't already been inited
    if (GetParentClass() != NULL)
    {
        if (GetParentClass()->GetMethodTable()->CheckRunClassInit(pThrowable) == FALSE)
        {
            // Failed to init parent - pThrowable would have been set by the parent
            return FALSE;
        }
    }
#endif

    if (s_cctorSig == NULL)
    {
        // Allocate a metasig to use for all class constructors.
        void *tempSpace = SystemDomain::Loader()->GetHighFrequencyHeap()->AllocMem(sizeof(MetaSig));
        s_cctorSig = new (tempSpace) MetaSig(gsig_SM_RetVoid.GetBinarySig(), 
                                             SystemDomain::SystemModule());
    }

    // Find init method
    MethodDesc *pCLInitMethod = GetMethodDescForSlot(GetMethodTable()->GetClassConstructorSlot());

    // If the static initialiser throws an exception that it doesn't catch, it has failed
    COMPLUS_TRY
    {
        // During the <clinit>, this thread must not be asynchronously
        // stopped or interrupted.  That would leave the class unavailable
        // and is therefore a security hole.  We don't have to worry about
        // multithreading, since we only manipulate the current thread's count.
        pCurThread->IncPreventAsync();

        STRESS_LOG1(LF_CLASSLOADER, LL_INFO1000, "RunClassInit: Calling class contructor for type %pT\n", GetMethodTable());
        
        // We want to give the debugger a chance to handle any unhandled exceptions
        // that occur during class initialization, so we need to have filter
        __try
        {
            (void) pCLInitMethod->Call((BYTE *) NULL, s_cctorSig);
        }
        __except(ThreadBaseExceptionFilter(GetExceptionInformation(),
                                           GetThread(),
                                           ClassInitUnhandledException)) 
        {
            _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPTION_EXECUTE_HANDLER");
        }

        STRESS_LOG1(LF_CLASSLOADER, LL_INFO1000, "RunClassInit: Returned Successfully from class contructor for type %pT\n", GetMethodTable());

        pCurThread->DecPreventAsync();
        // success
        return TRUE;
    }
    COMPLUS_CATCH
    {
        // Exception set by parent
        // @TODO: We should make this an ExceptionInInitializerError if the exception thrown is not
        // a subclass of Error
        pCurThread->DecPreventAsync();
        UpdateThrowable(pThrowable);
        return FALSE;
    }
    COMPLUS_END_CATCH

    _ASSERTE(0);        // Should not be reached, but COMPLUS_CATCH nastiness ...
    return FALSE;       // ... is more that VC can handle.
}

//
// Check whether the class initialiser has to be run for this class, and run it if necessary.
// Returns TRUE for success, FALSE for failure.
//
// If this returns FALSE, then pThrowable MUST be set to an exception.
//
BOOL EEClass::DoRunClassInit(OBJECTREF *pThrowable, AppDomain *pDomain, DomainLocalClass **ppLocalClass)
{
    HRESULT                             hrResult = E_FAIL;
    DeadlockAwareLockedListElement*     pEntry;
    BOOL                                bLeaveLock = FALSE;

    BEGIN_REQUIRES_16K_STACK;

    // by default are always operating off the current domain, but sometimes need to do this before
    // we've switched in
    if (IsShared() && pDomain == NULL)
        pDomain = SystemDomain::GetCurrentDomain();

    //
    // Check to see if we have already run the .cctor for this class.
    //

    // Have we run clinit already on this class?
    if (IsInited())
        return TRUE;
    
    STRESS_LOG2(LF_CLASSLOADER, LL_INFO1000, "DoRunClassInit: Request to init %pT in appdomain %p\n", GetMethodTable(), pDomain);
    //
    // If we're shared, see if our DLS is set up already.
    // (We will never set the Inited flag on a shared class.)
    //

    SIZE_T sharedIndex = 0;
    DomainLocalBlock *pLocalBlock = NULL;

    if (IsShared())
    {
        sharedIndex = GetMethodTable()->GetSharedClassIndex();
        pLocalBlock = pDomain->GetDomainLocalBlock();

        if (pLocalBlock->IsClassInitialized(sharedIndex))
        {
            if (ppLocalClass != NULL)
                *ppLocalClass = pLocalBlock->GetInitializedClass(sharedIndex);

            return TRUE;
        }
    }

    //
    // Take the global lock
    //

    ListLock *pLock;
    if (IsShared())
        pLock = pDomain->GetClassInitLock();
    else
        pLock = GetAssembly()->GetClassInitLock();

    _ASSERTE(GetClassLoader());
    pLock->Enter();

    // Check again
    if (IsInited())
    {
        pLock->Leave();

        return TRUE;
    }

    //
    // Check the shared case again
    //

    if (IsShared())
    {
        if (pLocalBlock->IsClassInitialized(sharedIndex))
        {
            pLock->Leave();

            if (ppLocalClass != NULL)
                *ppLocalClass = pLocalBlock->GetInitializedClass(sharedIndex);

            return TRUE;
        }
    }

    //
    // Handle cases where the .cctor has already tried to run but failed.
    //

    if (IsInitError() || (IsShared() && pLocalBlock->IsClassInitError(sharedIndex)))
    {
        // Some error occurred trying to init this class
        pEntry = (DeadlockAwareLockedListElement *) pLock->Find(this);
        _ASSERTE(pEntry!=NULL);        

        // Extract the saved exception.
        *pThrowable = ObjectFromHandle(pEntry->m_hInitException);
                
        pLock->Leave();
        return FALSE;
    }

    //
    // Check to see if the .cctor for this class is already being run.
    //

    pEntry = (DeadlockAwareLockedListElement *) pLock->Find(this);
    BOOL bEnterLockSucceeded = FALSE;
    __try 
    {
        if (pEntry == NULL)
        {
            //
            // We are the first one to try and run this classe's .cctor so create an entry for it
            //

            // No one else is running class init, so we need to allocate a new entry
            pEntry = new DeadlockAwareLockedListElement;
            if (pEntry == NULL)
            {
                // Out of memory
                SetClassInitError();
                pLock->Leave();
                CreateExceptionObject(kOutOfMemoryException, pThrowable);
                return FALSE;
            }

            // Fill in the entry information and add it to the correct list
            pEntry->AddEntryToList(pLock, this);

            // Take the entry's lock. This cannot cause a deadlock since nobody has started
            // running the .cctor for this class.
            bEnterLockSucceeded = pEntry->DeadlockAwareEnter();
            _ASSERTE(bEnterLockSucceeded);

            // Leave global lock
            pLock->Leave();

            //
            // If we are shared, allocate our handles
            //

            // @ToDo: I don't think that this TRY/CATCH is necessary
            //        as RunClassInit() contains a dominating TRY/CATCH 
            COMPLUS_TRY 
            {
                if (IsShared())
                    pLocalBlock->PopulateClass(GetMethodTable());

                //
                // We are now ready to run the .cctor itself (i.e RunClassInit() )
                //
                if (!GetMethodTable()->HasClassConstructor() || RunClassInit(pEntry, pThrowable))
                {
                    hrResult = S_OK;
                    
                    if (IsShared())
                        pLocalBlock->SetClassInitialized(sharedIndex);
                    else
                        SetInited();
                }
            }
            COMPLUS_CATCH 
            {
                hrResult = E_FAIL;
                UpdateThrowable(pThrowable);
            }
            COMPLUS_END_CATCH

            if (FAILED(hrResult))
            {
                // The .cctor failed and we want to store the exception that resulted
                // in the entry. Increment the ref count to keep the entry alive for
                // subsequent attempts to run the .cctor.
                pEntry->m_dwRefCount++;    

                DefineFullyQualifiedNameForClassWOnStack();
                LPWSTR wszName = GetFullyQualifiedNameForClassW(this);

                OBJECTREF pInitException = NULL;
                GCPROTECT_BEGIN(pInitException);        
                CreateTypeInitializationExceptionObject(wszName,pThrowable,&pInitException);        

                // Save the exception object, and return to caller as well.
                pEntry->m_hInitException = (pDomain ? pDomain : GetDomain())->CreateHandle(pInitException);     
                pEntry->m_hrResultCode = E_FAIL;
                *pThrowable = pInitException;

                GCPROTECT_END();
                
                if (IsShared())
                    pLocalBlock->SetClassInitError(sharedIndex);
                else
                    SetClassInitError();
            }

            // Set the flag indicating we need to leave the lock now that we have either 
            // finished running the .cctor or failed.
            bLeaveLock = TRUE;
        }
        else
        {
            //
            // Someone else is initing this class
            //
            
            // Refcount ourselves as waiting for this class to init
            pEntry->m_dwRefCount++;
            pLock->Leave();

            // Wait for class - note, we could be waiting on our own thread from running a class init further up the stack
            bEnterLockSucceeded = pEntry->DeadlockAwareEnter();            
            if(bEnterLockSucceeded)
            {
                //
                // We managed to take the lock this means that the other thread has finished running it or
                // that the current thread is the one that is already running it.
                //
                hrResult = pEntry->m_hrResultCode;
                if(FAILED(hrResult))
                { 
                    // An exception may have occurred in the cctor. DoRunClassInit() should return FALSE in that
                    // case. 
                    _ASSERTE(pEntry->m_hInitException);
                    _ASSERTE(IsInitError() || (IsShared() && pLocalBlock->IsClassInitError(sharedIndex)));                        

                    // Extract the saved exception.
                    *pThrowable = ObjectFromHandle(pEntry->m_hInitException);
                }                                

                bLeaveLock = TRUE;
            }
            else
            {
                //
                // Taking the lock would cause a deadlock.
                //

                COMPLUS_TRY 
                {
                    //
                    // If we are shared, go ahead and allocate our DLS entry & handles.  
                    // (It's OK to exposed uninitialized statics, but we do need to allocate them.)
                    // It's OK to race with the other thread to do this, since there is an 
                    // app domain level lock which protects the DLS block.
                    //

                    if (IsShared())
                        pLocalBlock->PopulateClass(GetMethodTable());

                    // The class init has not run yet so lets return S_FALSE to indicate this.
                    hrResult = S_FALSE;                    
                }
                COMPLUS_CATCH 
                {
                    hrResult = E_FAIL;
                    UpdateThrowable(pThrowable);
                }
                COMPLUS_END_CATCH
            }
        }

        //
        // Notify any entries waiting on the current entry and wait for the required entries.
        //

        // We need to take the global lock before we play with the list of entries.
        pLock->Enter();

    }
    // Leave the lock if the flag is set.
    __finally 
    {
        if (bEnterLockSucceeded)
            pEntry->DeadlockAwareLeave();
    }

    //
    // If we are the last waiter, delete the entry
    //

    if (--pEntry->m_dwRefCount == 0)
    {
        // Unlink item from list - in reality, anyone can do this, it doesn't have to be the last waiter.
        pLock->Unlink(pEntry);

        // Clean up the information contained in the entry and delete it.
        pEntry->Destroy();
        delete pEntry;
    }

    pLock->Leave();

    if (ppLocalClass != NULL)
        if (IsShared())
            *ppLocalClass = pLocalBlock->GetClass(sharedIndex);
        else
            *ppLocalClass = NULL;


    END_CHECK_STACK;
    
    STRESS_LOG2(LF_CLASSLOADER, LL_INFO1000, "DoRunClassInit: returning SUCCESS for init %pT in appdomain %p\n", GetMethodTable(), pDomain);
    // No need to set pThrowable in case of error it will already have been set.
    return SUCCEEDED(hrResult) ? TRUE : FALSE;
}

//
// This function is a shortcut to get the current DomainLocalClass without
// doing any locking.  Currently it should be used by the debugger only
// (since it doesn't do any locking.)
//
DomainLocalClass *EEClass::GetDomainLocalClassNoLock(AppDomain *pAppDomain)
{
    _ASSERTE(IsShared());

    DomainLocalBlock *pLocalBlock = pAppDomain->GetDomainLocalBlock();

    return pLocalBlock->GetClass(GetMethodTable()->GetSharedClassIndex());
}

//==========================================================================
// If the EEClass doesn't yet know the Exposed class that represents it via
// Reflection, acquire that class now.  Regardless, return it to the caller.
//==========================================================================
OBJECTREF EEClass::GetExposedClassObject()
{
    THROWSCOMPLUSEXCEPTION();
    TRIGGERSGC();

    // We shouldnt be here if the class is __TransparentProxy
    _ASSERTE(!CRemotingServices::IsRemotingInitialized()||this != CTPMethodTable::GetMethodTable()->GetClass());

    if (m_ExposedClassObject == NULL) {
        // Make sure that reflection has been initialized
        COMClass::EnsureReflectionInitialized();

        // Make sure that we have been restored
        CheckRestore();

        REFLECTCLASSBASEREF  refClass = NULL;
        GCPROTECT_BEGIN(refClass);
        COMClass::CreateClassObjFromEEClass(this, &refClass);

        // Let all threads fight over who wins using InterlockedCompareExchange.
        // Only the winner can set m_ExposedClassObject from NULL.      
        OBJECTREF *exposedClassObject; 
        GetDomain()->AllocateObjRefPtrsInLargeTable(1, &exposedClassObject);
        SetObjectReference(exposedClassObject, refClass, IsShared() ? NULL : (AppDomain*)GetDomain());
        
        if (VipInterlockedCompareExchange ((void**)&m_ExposedClassObject, *(void**)&exposedClassObject, NULL)) 
            SetObjectReference(exposedClassObject, NULL, NULL);

        GCPROTECT_END();
    }
    return *m_ExposedClassObject;
}


void EEClass::UnlinkChildrenInDomain(AppDomain *pDomain)
{
    EEClass  **ppRewrite;
    EEClass   *pCur, *pFirstRemove;

 restart:

    ppRewrite = &m_ChildrenChain;

        // We only remember parents of classes that are being unloaded.  Such parents
        // clearly have children.  But we never notice the subtypes of e.g. __ComObject
        // and it's not really worth it from a backpatching perspective.
        // _ASSERTE(m_ChildrenChain);

    do
    {
        // Skip all leading classes for domains that are NOT being unloaded.
        while (*ppRewrite && (*ppRewrite)->GetDomain() != pDomain)
            ppRewrite = &(*ppRewrite)->m_SiblingsChain;

        if (*ppRewrite)
        {
            // Now march pCur along until we find the end of a sublist of classes that
            // are being unloaded.
            //
            // By grabbing pFirstRemove before checking pCur->GetDomain(), we handle the
            // race between someone inserting a type that doesn't need unloading at the
            // head, in the case where ppRewrite points to the head.  This will simply
            // perform a NOP and then go back and pick up the next segment to remove.
            pFirstRemove = pCur = *ppRewrite;
            while (pCur && pCur->GetDomain() == pDomain)
                pCur = pCur->m_SiblingsChain;

                // Now extract that portion of the chain.  We can have contention with inserts
                // only if we are removing from the head.  And if we have contention, it is
                // guaranteed that we have moved from the head to further down.  So we don't
                // have to worry about contention in a loop.  Nevertheless, we need to find
                // the point at which to start removing because it has moved.  The best way to
                // ensure we are running well-tested code is to simply restart.  This is
                // inefficient, but it's the best way to guarantee robustness for an exceedingly
                // rare situation.
            if (ppRewrite == &m_ChildrenChain)
            {
                if (FastInterlockCompareExchange((void **) ppRewrite,
                                                 pCur,
                                                 pFirstRemove) != pFirstRemove)
                {
                    // contention.  Try again
                    goto restart;
                }
            }
            else
            {
                // We aren't operating at the head, so we don't need to worry about races.
                *ppRewrite = pCur;
            }

            _ASSERTE(!*ppRewrite ||
                     (*ppRewrite)->GetDomain() != pDomain);

        }
    
    } while (*ppRewrite);
}

BOOL s_DisableBackpatching = FALSE;

void EEClass::DisableBackpatching()
{
    s_DisableBackpatching = TRUE;
}

void EEClass::EnableBackpatching()
{
    s_DisableBackpatching = FALSE;
}


// Backpatch up and down the class hierarchy, as aggressively as possible.
BOOL EEClass::PatchAggressively(MethodDesc *pMD, SLOT codeaddr)
{
    // If we are in the middle of appdomain unloading, the sibling and children chains
    // are potentially corrupt.  They will be fixed by the time the appdomain is
    // fully unloaded but -- until the patch list is applied and deleted -- we bypass
    // any aggressive backpatching opportunities.
    if (s_DisableBackpatching)
        return FALSE;

    MethodTable     *pMT = pMD->GetMethodTable();
    MethodTable     *baseMT = pMT;
    DWORD            slot = pMD->GetSlot();
    SLOT             prestub = pMD->GetPreStubAddr();
    BOOL             IsDup = pMD->IsDuplicate();
    DWORD            numSlots;
    EEClass         *pClass;
    SLOT             curaddr;

    _ASSERTE(pMD->IsVirtual());

    // We are starting at the point in the hierarchy where the MD was introduced.  So
    // we only need to patch downwards.
    while (TRUE)
    {
        _ASSERTE(pMT->IsInterface() ||
                 pMT->GetClass()->GetNumVtableSlots() >= slot);

        curaddr = (pMT->IsInterface()
                   ? 0
                   : pMT->GetVtable() [slot]);

        // If it points to *our* prestub, patch it.  If somehow it already got
        // patched, we keep hunting downwards (this is probably a race).  For anything
        // else, we are perhaps seeing an override in a child.  Further searches down
        // are likely to be fruitless.
        if (curaddr == prestub)
            pMT->GetVtable() [slot] = codeaddr;
        else
        if (curaddr != codeaddr)
            goto go_sideways;

        // If this is a duplicate, let's scan the rest of the VTable hunting for other
        // hits.
        if (IsDup)
        {
            numSlots = pMT->GetClass()->GetNumVtableSlots();
            for (DWORD i=0; i<numSlots; i++)
                if (pMT->GetVtable() [i] == prestub)
                    pMT->GetVtable() [i] = codeaddr;
        }

        // Whenever we finish a class, we go downwards.

// go_down:

        pClass = pMT->GetClass()->m_ChildrenChain;
        if (pClass)
        {
            pMT = pClass->GetMethodTable();
            continue;
        }

        // If we can go down no further, we go sideways.

go_sideways:

        // We never go sideways from our root.  When we attempt that, we are done.
        if (pMT == baseMT)
            break;

        pClass = pMT->GetClass()->m_SiblingsChain;
        if (pClass)
        {
            pMT = pClass->GetMethodTable();
            continue;
        }

        // If we can go down no further, we go up and then try to go sideways
        // from there.  (We've already done our parent).

// go_up:

        pMT = pMT->GetParentMethodTable();
        goto go_sideways;
    }

    return TRUE;
}




// if this returns E_FAIL and pThrowable is specified, it must be set

HRESULT EEClass::GetDescFromMemberRef(Module *pModule, 
                                      mdMemberRef MemberRef, 
                                      mdToken mdTokenNotToLoad, 
                                      void **ppDesc,
                                      BOOL *pfIsMethod,
                                      OBJECTREF *pThrowable)
{
    _ASSERTE(IsProtectedByGCFrame(pThrowable));

    HRESULT     hr = S_OK;

    LPCUTF8     szMember;
    EEClass *   pEEClass = 0;
    PCCOR_SIGNATURE pSig = NULL;
    DWORD       cSig;
    DWORD rid   = RidFromToken(MemberRef);
    mdToken tk  = TypeFromToken(MemberRef);
    ClassLoader* pLoader = NULL;

    *ppDesc = NULL;
    *pfIsMethod = TRUE;

    if (tk == mdtMemberRef)
    {
        
        Module      *pReference = pModule;

        // In lookup table?
        void *pDatum = pModule->LookupMemberRef(MemberRef, pfIsMethod);

        if (pDatum != NULL)
        {
            if (*pfIsMethod)
                ((MethodDesc*)pDatum)->GetMethodTable()->CheckRestore();
            *ppDesc = pDatum;
            return S_OK;
        }

        // No, so do it the long way
        mdTypeRef   typeref;
        IMDInternalImport *pInternalImport;

        pInternalImport = pModule->GetMDImport();

        szMember = pInternalImport->GetNameAndSigOfMemberRef(
            MemberRef,
            &pSig,
            &cSig
        );

        *pfIsMethod = !isCallConv(MetaSig::GetCallingConventionInfo(pModule, pSig), 
                                  IMAGE_CEE_CS_CALLCONV_FIELD);

        typeref = pInternalImport->GetParentOfMemberRef(MemberRef);

        // If parent is a method def, then this is a varargs method and the
        // desc lives in the same module.
        if (TypeFromToken(typeref) == mdtMethodDef)
        {
            MethodDesc *pDatum = pModule->LookupMethodDef(typeref);
            if (pDatum)
            {
                pDatum->GetMethodTable()->CheckRestore();
                *ppDesc = pDatum;
                return S_OK;
            }
            else   // There is no value for this def so we haven't yet loaded the class.
            {
                // Get the parent of the MethodDef
                mdTypeDef typeDef;
                hr = pInternalImport->GetParentToken(typeref, &typeDef);
                // Make sure it is a typedef
                if (TypeFromToken(typeDef) != mdtTypeDef)
                {
                    _ASSERTE(!"MethodDef without TypeDef as Parent");
                    hr = E_FAIL;
                    goto exit;
                }

                // load the class
                pLoader = pModule->GetClassLoader();
                _ASSERTE(pLoader);
                NameHandle name(pModule, typeDef);
                name.SetTokenNotToLoad(mdTokenNotToLoad);
                pEEClass = pLoader->LoadTypeHandle(&name, pThrowable).GetClass();
                if (pEEClass == NULL)
                {
                    hr = COR_E_TYPELOAD;
                    goto exitThrowable;
                }
                // the class has been loaded and the method should be in the rid map!
                pDatum = pModule->LookupMethodDef(typeref);
                if (pDatum)
                {
                    *ppDesc = pDatum;
                    return S_OK;
                }
                else
                {
                    hr = E_FAIL;
                    goto exit;
                }
            }
        }
        else if (TypeFromToken(typeref) == mdtModuleRef)
        {
            // Global function/variable
            if (FAILED(hr = pModule->GetAssembly()->FindModuleByModuleRef(pInternalImport,
                                                                          typeref,
                                                                          mdTokenNotToLoad,
                                                                          &pModule,
                                                                          pThrowable)))
                goto exit;

            typeref = COR_GLOBAL_PARENT_TOKEN;
        }
        else if (TypeFromToken(typeref) != mdtTypeRef && 
                 TypeFromToken(typeref) != mdtTypeDef && 
                 TypeFromToken(typeref) != mdtTypeSpec)
        {
            // @TODO: Need to handle this.
            hr = E_FAIL;
            goto exit;
        }
        
        NameHandle name(pModule, typeref);
        pLoader = pModule->GetClassLoader();
        _ASSERTE(pLoader);
        name.SetTokenNotToLoad(mdTokenNotToLoad);
        TypeHandle typeHnd = pLoader->LoadTypeHandle(&name, pThrowable);
        pEEClass = typeHnd.GetClass();

        if (pEEClass == NULL)
        {
            hr = COR_E_TYPELOAD;
            goto exitThrowable;
        }

        if (!*pfIsMethod)
        {
            FieldDesc *pFD = pEEClass->FindField(szMember, pSig, cSig, pModule);

            if (pFD == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }

            *ppDesc = (void *) pFD;
            pReference->StoreMemberRef(MemberRef, pFD);
        }
        else
        {
            MethodDesc *pMD;

            pMD = pEEClass->FindMethod(szMember, pSig, cSig, pModule, mdTokenNil, 0, TRUE, typeHnd);

            if (pMD == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }

            *ppDesc = (void *) pMD;
            pReference->StoreMemberRef(MemberRef, pMD);
        }

        hr = S_OK;
    }
    else if (tk == mdtMethodDef)
    {
        *pfIsMethod = TRUE;

        // In lookup table?
        MethodDesc *pDatum = pModule->LookupMethodDef(MemberRef);
        if (!pDatum)
        {
            // No, so do it the long way
            mdTypeDef typeDef;
            hr = pModule->GetMDImport()->GetParentToken(MemberRef, &typeDef); 
            if (FAILED(hr)) 
                return FALSE;   

            NameHandle name(pModule, typeDef);
            name.SetTokenNotToLoad(mdTokenNotToLoad);
            if (!pModule->GetClassLoader()->LoadTypeHandle(&name, pThrowable).GetClass())
            {
                hr = COR_E_TYPELOAD;
                goto exitThrowable;
            }

            // The RID map should have been filled out if we loaded the class
            pDatum = pModule->LookupMethodDef(MemberRef);
            if (!pDatum)
            {
                pSig = pModule->GetMDImport()->GetSigOfMethodDef(MemberRef, &cSig);
                szMember = pModule->GetMDImport()->GetNameOfMethodDef(MemberRef); 
                hr = E_FAIL;
                goto exit;
            }
        }

        pDatum->GetMethodTable()->CheckRestore();
        *ppDesc = pDatum;
        return S_OK;
    }
    else if (tk == mdtFieldDef)
    {
        *pfIsMethod = FALSE;

        // In lookup table?
        FieldDesc *pDatum = pModule->LookupFieldDef(MemberRef);
        if (!pDatum)
        {
            // No, so do it the long way
            mdTypeDef   typeDef;
            hr = pModule->GetMDImport()->GetParentToken(MemberRef, &typeDef); 
            if (FAILED(hr)) 
                return hr;   

            // Load the class - that should set the desc in the rid map
            NameHandle name(pModule, typeDef);
            name.SetTokenNotToLoad(mdTokenNotToLoad);
            if (!pModule->GetClassLoader()->LoadTypeHandle(&name, pThrowable).GetClass())
            {
                hr = COR_E_TYPELOAD;
                goto exitThrowable;
            }

            pDatum = pModule->LookupFieldDef(MemberRef);
            if (!pDatum)
            {
                pSig = pModule->GetMDImport()->GetSigOfFieldDef(MemberRef, &cSig);
                szMember = pModule->GetMDImport()->GetNameOfFieldDef(MemberRef); 
                hr = E_FAIL;
                goto exit;
            }
        }

        pDatum->GetMethodTableOfEnclosingClass()->CheckRestore();
            
#ifdef EnC_SUPPORTED
        if (pModule->IsEditAndContinue()) {
            EnCFieldDesc *pFD = (EnCFieldDesc*)pDatum;
            // we may not have the full FieldDesc info at applyEnC time becuase we don't  
            // have a thread so can't do things like load classes (due to possible exceptions)
            if (pFD->IsEnCNew() && pFD->NeedsFixup())
            {
                if (FAILED(hr=pFD->Fixup(MemberRef)))
                    return hr;
            }
        }
#endif // EnC_SUPPORTED

        *ppDesc = pDatum;
        return S_OK;
    }
    else
    {
        szMember = NULL;
        hr = E_FAIL;
    }

exit:
    if (FAILED(hr) && pThrowable) {
        DefineFullyQualifiedNameForClass();
        LPUTF8 szClassName;

        if (pEEClass)
        {
            szClassName = GetFullyQualifiedNameForClass(pEEClass);
        }
        else
        {
            szClassName = "?";
        }

        if (!*pfIsMethod)
        {
            LPUTF8 szFullName;
            MAKE_FULLY_QUALIFIED_MEMBER_NAME(szFullName, NULL, szClassName, szMember, NULL);
            #define MAKE_TRANSLATIONFAILED szwFullName=L""
            MAKE_WIDEPTR_FROMUTF8_FORPRINT(szwFullName, szFullName);
            #undef MAKE_TRANSLATIONFAILED
            CreateExceptionObject(kMissingFieldException, IDS_EE_MISSING_FIELD, szwFullName, NULL, NULL, pThrowable);
        } 
        else 
        {
            if (pSig && pModule)
            {
                MetaSig tmp(pSig, pModule);
                SigFormat sf(tmp, szMember ? szMember : "?", szClassName, NULL);
                #define MAKE_TRANSLATIONFAILED szwFullName=L""
                MAKE_WIDEPTR_FROMUTF8_FORPRINT(szwFullName, sf.GetCString());
                #undef MAKE_TRANSLATIONFAILED
                CreateExceptionObject(kMissingMethodException, IDS_EE_MISSING_METHOD, szwFullName, NULL, NULL, pThrowable);
            }
            else
                CreateExceptionObject(kMissingMethodException, IDS_EE_MISSING_METHOD, L"?", NULL, NULL, pThrowable);
            
        }
    }
exitThrowable:
    return hr;
}

HRESULT EEClass::GetMethodDescFromMemberRef(Module *pModule, mdMemberRef MemberRef, MethodDesc **ppMethodDesc, OBJECTREF *pThrowable)
{
    _ASSERTE(IsProtectedByGCFrame(pThrowable));
    BOOL fIsMethod;
    // We did not find this in the various permutations available to methods now so use the fallback!
    HRESULT hr = GetDescFromMemberRef(pModule, MemberRef, (void **) ppMethodDesc, &fIsMethod, pThrowable);
    if (SUCCEEDED(hr) && !fIsMethod)
    {
        hr = E_FAIL;
        *ppMethodDesc = NULL;
    }
    return hr;
}

HRESULT EEClass::GetFieldDescFromMemberRef(Module *pModule, mdMemberRef MemberRef, FieldDesc **ppFieldDesc, OBJECTREF *pThrowable)
{
    _ASSERTE(IsProtectedByGCFrame(pThrowable));
    BOOL fIsMethod;
    HRESULT hr = GetDescFromMemberRef(pModule, MemberRef, (void **) ppFieldDesc, &fIsMethod, pThrowable);
    if (SUCCEEDED(hr) && fIsMethod)
    {
        hr = E_FAIL;
        *ppFieldDesc = NULL;
    }
    return hr;
}


// Implementations of SparseVTableMap methods.

SparseVTableMap::SparseVTableMap()
{
    m_MapList = NULL;
    m_MapEntries = 0;
    m_Allocated = 0;
    m_LastUsed = 0;
    m_VTSlot = 0;
    m_MTSlot = 0;
}

SparseVTableMap::~SparseVTableMap()
{
    if (m_MapList != NULL)
    {
        delete [] m_MapList;
        m_MapList = NULL;
    }
}

// Allocate or expand the mapping list for a new entry.
BOOL SparseVTableMap::AllocOrExpand()
{
    if (m_MapEntries == m_Allocated) {

        Entry *maplist = new Entry[m_Allocated + MapGrow];
        if (maplist == NULL)
            return false;

        if (m_MapList != NULL)
            memcpy(maplist, m_MapList, m_MapEntries * sizeof(Entry));

        m_Allocated += MapGrow;
        delete [] m_MapList;
        m_MapList = maplist;

    }

    return true;
}

// While building mapping list, record a gap in VTable slot numbers.
BOOL SparseVTableMap::RecordGap(WORD StartMTSlot, WORD NumSkipSlots)
{
    _ASSERTE((StartMTSlot == 0) || (StartMTSlot > m_MTSlot));
    _ASSERTE(NumSkipSlots > 0);

    // We use the information about the current gap to complete a map entry for
    // the last non-gap. There is a special case where the vtable begins with a
    // gap, so we don't have a non-gap to record.
    if (StartMTSlot == 0) {
        _ASSERTE((m_MTSlot == 0) && (m_VTSlot == 0));
        m_VTSlot = NumSkipSlots;
        return true;
    }

    // We need an entry, allocate or expand the list as necessary.
    if (!AllocOrExpand())
        return false;

    // Update the list with an entry describing the last non-gap in vtable
    // entries.
    m_MapList[m_MapEntries].m_Start = m_MTSlot;
    m_MapList[m_MapEntries].m_Span = StartMTSlot - m_MTSlot;
    m_MapList[m_MapEntries].m_MapTo = m_VTSlot;

    m_VTSlot += (StartMTSlot - m_MTSlot) + NumSkipSlots;
    m_MTSlot = StartMTSlot;

    m_MapEntries++;

    return true;
}

// Finish creation of mapping list.
BOOL SparseVTableMap::FinalizeMapping(WORD TotalMTSlots)
{
    _ASSERTE(TotalMTSlots >= m_MTSlot);

    // If mapping ended with a gap, we have nothing else to record.
    if (TotalMTSlots == m_MTSlot)
        return true;

    // Allocate or expand the list as necessary.
    if (!AllocOrExpand())
        return false;

    // Update the list with an entry describing the last non-gap in vtable
    // entries.
    m_MapList[m_MapEntries].m_Start = m_MTSlot;
    m_MapList[m_MapEntries].m_Span = TotalMTSlots - m_MTSlot;
    m_MapList[m_MapEntries].m_MapTo = m_VTSlot;

    // Update VT slot cursor, because we use it to determine total number of
    // vtable slots for GetNumVtableSlots.
    m_VTSlot += TotalMTSlots - m_MTSlot;

    m_MapEntries++;

    return true;
}

// Lookup a VTable slot number from a method table slot number.
WORD SparseVTableMap::LookupVTSlot(WORD MTSlot)
{
    // As an optimization, check the last entry which yielded a correct result.
    if ((MTSlot >= m_MapList[m_LastUsed].m_Start) &&
        (MTSlot < (m_MapList[m_LastUsed].m_Start + m_MapList[m_LastUsed].m_Span)))
        return (MTSlot - m_MapList[m_LastUsed].m_Start) + m_MapList[m_LastUsed].m_MapTo;

    // Check all MT slots spans to see which one our input slot lies in.
    for (WORD i = 0; i < m_MapEntries; i++) {
        if ((MTSlot >= m_MapList[i].m_Start) &&
            (MTSlot < (m_MapList[i].m_Start + m_MapList[i].m_Span))) {
            m_LastUsed = i;
            return (MTSlot - m_MapList[i].m_Start) + m_MapList[i].m_MapTo;
        }
    }

    _ASSERTE(!"Invalid MethodTable slot");
    return ~0;
}

// Retrieve the number of slots in the vtable (both empty and full).
WORD SparseVTableMap::GetNumVTableSlots()
{
    return m_VTSlot;
}

HRESULT SparseVTableMap::Save(DataImage *image, mdToken attribution)
{
    HRESULT hr;
    
    IfFailRet(image->StoreStructure(this, sizeof(SparseVTableMap), 
                                    DataImage::SECTION_CLASS,
                                    DataImage::DESCRIPTION_CLASS,
                                    attribution));
    
    IfFailRet(image->StoreStructure(m_MapList, m_Allocated * sizeof(Entry),
                                    DataImage::SECTION_CLASS,
                                    DataImage::DESCRIPTION_CLASS,
                                    attribution));
    
    return S_OK;
}

HRESULT SparseVTableMap::Fixup(DataImage *image)
{
    HRESULT hr;

    IfFailRet(image->FixupPointerField(&m_MapList));

    return S_OK;
}

void MethodTable::GetExtent(BYTE **pStart, BYTE **pEnd)
{
    BYTE *start, *end;

    if (ContainsPointers())
        start = (BYTE*) CGCDesc::GetCGCDescFromMT(this)->GetLowestSeries();
    else
        start = (BYTE*) this;

    end = (BYTE*) (m_pIMap + m_wNumInterface);

    *pStart = start;
    *pEnd = end;
}

HRESULT MethodTable::Save(DataImage *image)
{
    HRESULT hr;

    _ASSERTE(IsRestored());

    BYTE *start, *end;

    GetExtent(&start, &end);

    IfFailRet(image->StoreStructure(start, (ULONG)(end - start), 
                                    DataImage::SECTION_METHOD_TABLE,
                                    DataImage::DESCRIPTION_METHOD_TABLE,
                                    GetClass()->GetCl()));

    if (IsInterface())
    {
        // Make sure our guid is computed

        GUID dummy;
        GetClass()->GetGuid(&dummy, TRUE);

        _ASSERTE(m_pGuidInfo != NULL);

        IfFailRet(image->StoreStructure(m_pGuidInfo, sizeof(GuidInfo),
                                        DataImage::SECTION_METHOD_TABLE,
                                        DataImage::DESCRIPTION_METHOD_TABLE,
                                        GetClass()->GetCl()));
    }

    return m_pEEClass->Save(image);
}

HRESULT MethodTable::Fixup(DataImage *image, DWORD *pRidToCodeRVAMap)
{
    HRESULT hr;
    
    _ASSERTE(IsRestored());

    IfFailRet(image->FixupPointerField(&m_pEEClass));
    IfFailRet(image->FixupPointerField(&m_pModule));
    IfFailRet(image->FixupPointerField(&m_pIMap, NULL, 
                                       DataImage::REFERENCE_STORE, 
                                       DataImage::FIXUP_VA, 
                                       TRUE));

    // 
    // This field must be initialized at 
    // load time
    //

    if (IsInterface())
        IfFailRet(image->FixupPointerField(&m_pGuidInfo));
    else
        IfFailRet(image->ZeroPointerField(&m_pInterfaceVTableMap));

    // 
    // Fix flags
    //

    MethodTable *pNewMT = (MethodTable *) image->GetImagePointer(this);
    if (pNewMT == NULL)
        return E_POINTER;

    if (HasClassConstructor()
        || (IsShared() && GetClass()->GetNumStaticFields() > 0))
        pNewMT->m_wFlags &= ~enum_flag_ClassInited;

    pNewMT->m_wFlags |= enum_flag_Unrestored;

    //
    // Fixup static fields:
    // Zero all non-reference fields
    // For reference fields (which need handles allocated),
    //  store (DWORD)(-1) in the field - we'll allocate a handle
    //  for it at load time
    // For value class fields (which need boxed objects allocated),
    //  store the method table pointer for the value class - we'll
    //  allocate the object at load time.
    //

    BYTE *start = (BYTE *) (m_Vtable + m_pEEClass->GetNumMethodSlots());
    BYTE *end = start + GetStaticSize();

    IfFailRet(image->ZeroField(start, end - start));

    SIZE_T fieldCount = m_pEEClass->GetNumInstanceFields();

    if (m_pEEClass->GetParentClass() != NULL)
        fieldCount -= m_pEEClass->GetParentClass()->GetNumInstanceFields();

    FieldDesc *pField = m_pEEClass->GetFieldDescList() + fieldCount;
    FieldDesc *pFieldEnd = pField + m_pEEClass->GetNumStaticFields();
    while (pField < pFieldEnd)
    {
        _ASSERTE(pField->IsStatic());

        //
        // We have to treat class statics & value type statics 
        // specially - they will require additional manual fixup
        // at load time.  To help with this, we assign -1 to
        // all referenced fields (which will be replaced with an
        // allocated handle), and the method table ptr for each
        // value type field (which will be replaced with an allocated
        // boxed instance.)
        //

        if (!pField->IsSpecialStatic())
        {
            switch (pField->GetFieldType())
            {
            case ELEMENT_TYPE_CLASS:
                {
                    BYTE *addr = (BYTE *) m_Vtable;
                    if (IsShared())
                        addr += GetClass()->GetNumMethodSlots()*sizeof(SLOT);
                    addr += pField->GetOffset();

                    void **pFieldPtr = (void **) image->GetImagePointer(addr);
                    if (pFieldPtr == NULL)
                        return E_POINTER;
                    *pFieldPtr = NULL;
                }
                break;

            case ELEMENT_TYPE_VALUETYPE:
                {
                    BYTE *addr = (BYTE *) m_Vtable;
                    if (IsShared())
                        addr += GetClass()->GetNumMethodSlots()*sizeof(SLOT);
                    addr += pField->GetOffset();

                    MethodTable *pMT = pField->GetTypeOfField()->GetMethodTable();
                    IfFailRet(image->FixupPointerFieldToToken(addr, pMT, 
                                                              pMT->GetModule(),
                                                              mdtTypeDef));
                }
                break;

            default:
                break;
            }
        }
        pField++;
    }

    // 
    // Fixup vtable
    //

    unsigned slotNumber = 0;
    while (slotNumber < m_cbSlots)
    {
        SLOT *pSlot = &m_Vtable[slotNumber];
        //
        // Find the method desc from the slot.
        //

        MethodDesc *pMD = EEClass::GetUnknownMethodDescForSlotAddress(*pSlot);
        _ASSERTE(pMD != NULL);
        
        BOOL fSecurity = (pMD->GetSecurityFlags() != 0);
        BOOL fRemotingIntercepted = pMD->IsRemotingIntercepted();

        //
        // If the method needs a security check, we need 
        // to always go through the stub.
        //

        void *code;
        if (fSecurity || fRemotingIntercepted)
            code = NULL;
        else
            IfFailRet(image->GetFunctionAddress(pMD, &code));

        if (code == NULL)
        {
            if (pMD->GetModule() == GetModule())
            {
                IfFailRet(image->FixupPointerField(pSlot, 
                                                   pMD->GetPreStubAddr()));
            }
            else
            {
                _ASSERTE(!pMD->IsStatic());

                // We prefer to use the slot number directly; that way the
                // correct slot gets fixed up by the stub.  But in some rare cases
                // involving interfaces we cannot recover the MethodDesc from the actual slot number; in 
                // such cases we use the destination MethodDesc's slot number and rely on
                // the fixup code scanning the vtable to backpatch the right slot.

                DWORD targetSlotNumber = slotNumber;

                if (slotNumber >= m_pEEClass->GetParentClass()->GetNumVtableSlots())
                {
                    MethodTable *pParentMT = m_pEEClass->GetParentClass()->GetMethodTable();

                    InterfaceInfo_t *pInterface = GetInterfaceForSlot(slotNumber);
                    if (pInterface == NULL)
                    {
                        // We are in a slot which isn't covered by an interface.

                        targetSlotNumber = pMD->GetSlot();

                        _ASSERTE(targetSlotNumber < m_pEEClass->GetParentClass()->GetNumVtableSlots());
                        _ASSERTE(m_pEEClass->GetParentClass()->
                                 GetUnknownMethodDescForSlot(targetSlotNumber)
                                 == pMD);
                    }
                    else
                    {
                        MethodTable *pInterfaceMT = pInterface->m_pMethodTable;
                        InterfaceInfo_t *pParentInterface = pParentMT->FindInterface(pInterfaceMT);

                        if (pParentInterface == NULL)
                        {
                            if (pMD->GetMethodTable() == pInterfaceMT)
                            {
                                // We are inheriting the interface's method desc; the fixup code can figure 
                                // this out.

                                _ASSERTE(pMD->IsComPlusCall());
                                _ASSERTE(IsComObjectType() || GetClass()->IsAbstract());
                                _ASSERTE(pInterfaceMT->GetClass()->
                                         GetUnknownMethodDescForSlot(targetSlotNumber 
                                                                     - pInterface->m_wStartSlot)
                                         == pMD);
                            }
                            else
                            {
                                // We've implemented a new interface with a parent's
                                // MethodDesc.  In this case we must use the real MD's slot number.

                                targetSlotNumber = pMD->GetSlot();

                                _ASSERTE(targetSlotNumber < m_pEEClass->GetParentClass()->GetNumVtableSlots());
                                _ASSERTE(m_pEEClass->GetParentClass()->
                                         GetUnknownMethodDescForSlot(targetSlotNumber)
                                         == pMD);
                            }
                        }
                        else
                        {
                            // Our parent implemented this interface.  Any methods
                            // which implement the interface which are inherited from
                            // our parent will also be on our parent's interface implementation
                            // The fixup logic can figure out where this is so use 
                            // the real slot number.

                            _ASSERTE(m_pEEClass->GetParentClass()->
                                     GetUnknownMethodDescForSlot(targetSlotNumber
                                                                 - pInterface->m_wStartSlot 
                                                                 + pParentInterface->m_wStartSlot)
                                     == pMD);
                        }
                    }
                }
                else
                {
                    _ASSERTE(m_pEEClass->GetParentClass()->
                             GetUnknownMethodDescForSlot(targetSlotNumber)
                             == pMD);
                }

                IfFailRet(image->FixupPointerField(pSlot, 
                                           GetModule()->GetJumpTargetTable() + 
                                           X86JumpTargetTable::ComputeTargetOffset(targetSlotNumber)));
            }
        }
        else
            IfFailRet(image->FixupPointerField(pSlot, code,
                                               DataImage::REFERENCE_FUNCTION));

        slotNumber++;
    }

    // 
    // Fixup Interface map
    //

    InterfaceInfo_t *pIMap = m_pIMap;
    InterfaceInfo_t *pIMapEnd = pIMap + m_wNumInterface;
    while (pIMap < pIMapEnd)
    {
        IfFailRet(image->FixupPointerFieldToToken(&pIMap->m_pMethodTable,
                                                  NULL, pIMap->m_pMethodTable->GetModule(),
                                                  mdtTypeDef));
        pIMap++;
    }

    return m_pEEClass->Fixup(image, this, pRidToCodeRVAMap);
}

void EEClass::GetExtent(BYTE **pStart, BYTE **pEnd)
{
    *pStart = (BYTE *) this;
    *pEnd = *pStart + 
      (HasLayout() ? sizeof(LayoutEEClass)
       : IsDelegateClass() || IsMultiDelegateClass() ? sizeof(DelegateEEClass)
       : IsEnum() ? sizeof(EnumEEClass)
       : sizeof(EEClass));
}

HRESULT EEClass::Save(DataImage *image)
{
    HRESULT hr;

    _ASSERTE(IsRestored());

    BYTE *start, *end;

    GetExtent(&start, &end);

    IfFailRet(image->StoreStructure(start, (ULONG)(end - start),
                                    DataImage::SECTION_CLASS,
                                    DataImage::DESCRIPTION_CLASS,
                                    GetCl()));

#ifdef _DEBUG
    if (!image->IsStored(m_szDebugClassName))
        IfFailRet(image->StoreStructure(m_szDebugClassName, (ULONG)(strlen(m_szDebugClassName)+1),
                                        DataImage::SECTION_DEBUG, 
                                   DataImage::DESCRIPTION_DEBUG, 
                                   mdTokenNil, 1));
#endif // _DEBUG

    if (m_pSparseVTableMap != NULL)
        IfFailRet(m_pSparseVTableMap->Save(image, GetCl()));

    //
    // Save FieldDescs
    //

    SIZE_T fieldCount = m_wNumInstanceFields + m_wNumStaticFields;
    if (GetParentClass() != NULL)
        fieldCount -= GetParentClass()->m_wNumInstanceFields;

    IfFailRet(image->StoreStructure(m_pFieldDescList, (ULONG)(fieldCount * sizeof(FieldDesc)),
                                    DataImage::SECTION_FIELD_DESC,
                                    DataImage::DESCRIPTION_FIELD_DESC));

    FieldDesc *pFD = m_pFieldDescList;
    FieldDesc *pFDEnd = pFD + fieldCount;
    while (pFD < pFDEnd)
    {
        IfFailRet(pFD->SaveContents(image));
        pFD++;
    }

    // 
    // Save MethodDescs
    //

    MethodDescChunk *chunk = m_pChunks;
    while (chunk != NULL)
    {
        IfFailRet(chunk->Save(image));
        chunk = chunk->GetNextChunk();
    }

    if (HasLayout())
    {
        EEClassLayoutInfo *pInfo = &((LayoutEEClass*)this)->m_LayoutInfo;

        if (pInfo->m_numCTMFields > 0)
            IfFailRet(image->StoreStructure(pInfo->m_pFieldMarshalers, 
                                            pInfo->m_numCTMFields * MAXFIELDMARSHALERSIZE, 
                                            DataImage::SECTION_FIELD_INFO,
                                            DataImage::DESCRIPTION_FIELD_DESC,
                                            GetCl()));
    }

    if (IsEnum())
    {
        EnumEEClass *pEnumClass = (EnumEEClass*) this;

        pEnumClass->BuildEnumTables();

        if (pEnumClass->GetEnumCount() > 0)
        {
            DWORD enumCount = pEnumClass->GetEnumCount();
            IfFailRet(image->StoreStructure(pEnumClass->m_values, 
                                            enumCount * (1<<pEnumClass->GetEnumLogSize()),
                                            DataImage::SECTION_FIELD_INFO,
                                            DataImage::DESCRIPTION_FIELD_DESC,
                                            GetCl()));
            IfFailRet(image->StoreStructure(pEnumClass->m_names, 
                                            enumCount * sizeof(LPCUTF8),
                                            DataImage::SECTION_FIELD_INFO,
                                            DataImage::DESCRIPTION_FIELD_DESC,
                                            GetCl()));
            
            LPCUTF8 *pNames = pEnumClass->m_names;
            LPCUTF8 *pNamesEnd = pNames + enumCount;
            while (pNames < pNamesEnd)
            {
                if (!image->IsStored((void*) *pNames))
                    image->StoreStructure((void *) *pNames, (ULONG)strlen(*pNames)+1,
                                          DataImage::SECTION_FIELD_INFO,
                                          DataImage::DESCRIPTION_FIELD_DESC,
                                          GetCl());

                pNames++;
            }
        }
    }

#if CHECK_APP_DOMAIN_LEAKS
    //
    // Make sure we've computed our agility flags, in case a later load of this
    // prejit file occurs with leak detection enabled.
    //

    if (!IsAppDomainAgilityDone())
        SetAppDomainAgileAttribute(TRUE);
#endif

    return S_OK;
}

DWORD EEClass::FieldDescListSize()
{
    DWORD fieldCount = m_wNumInstanceFields + m_wNumStaticFields;
    if (GetParentClass() != NULL)
        fieldCount -= GetParentClass()->m_wNumInstanceFields;
    return fieldCount;
}

HRESULT EEClass::Fixup(DataImage *image, MethodTable *pMethodTable, DWORD *pRidToCodeRVAMap)
{
    HRESULT hr = S_OK;

    _ASSERTE(IsRestored());

#ifdef _DEBUG
    IfFailRet(image->FixupPointerField(&m_szDebugClassName));
#endif // _DEBUG

    if (m_pSparseVTableMap != NULL)
    {
        IfFailRet(image->FixupPointerField(&m_pSparseVTableMap));
        IfFailRet(m_pSparseVTableMap->Fixup(image));
    }

    if (GetParentClass() != NULL)
        IfFailRet(image->FixupPointerFieldToToken(GetParentClassPtr(),
                                                  GetParentClass()->GetMethodTable(), 
                                                  GetParentClass()->GetModule(),
                                                  mdtTypeDef));

    //
    // We pass in the method table, because some classes (e.g. remoting proxy)
    // have fake method tables set up in them & we want to restore the regular
    // one.
    //
    IfFailRet(image->FixupPointerField(&m_pMethodTable, pMethodTable));

    //
    // Clear the restored flag & class init flag (if appropriate)
    //

    EEClass *pNewClass = (EEClass *) image->GetImagePointer(this);
    if (pNewClass == NULL)
        return E_POINTER;

    pNewClass->m_VMFlags |= VMFLAG_UNRESTORED;

    if (!IsThunking()) // assume thunking has no inits - 
                       // this case triggers asserts in FindMethod
    {
        if (GetMethodTable()->HasClassConstructor()
            || (IsShared() && GetNumStaticFields() > 0))
            pNewClass->m_VMFlags &= ~VMFLAG_INITED;
    }

    //
    // Fixup FieldDescs
    //

    SIZE_T fieldCount = FieldDescListSize();

    IfFailRet(image->FixupPointerField(&m_pFieldDescList));
    FieldDesc *pField = m_pFieldDescList;
    FieldDesc *pFieldEnd = pField + fieldCount;
    while (pField < pFieldEnd)
    {
        IfFailRet(pField->Fixup(image));
        pField++;
    }

    //
    // Fixup MethodDescs
    //

    IfFailRet(image->FixupPointerField(&m_pChunks));
    MethodDescChunk *chunk = m_pChunks;
    while (chunk != NULL)
    {
        IfFailRet(chunk->Fixup(image, pRidToCodeRVAMap));
        chunk = chunk->GetNextChunk();
    }

    // These fields will be lazy inited if we zero them
    IfFailRet(image->ZeroPointerField(&m_pComclassfac));
    IfFailRet(image->ZeroPointerField(&m_pccwTemplate));
    
    IfFailRet(image->ZeroPointerField(&m_ExposedClassObject));
    IfFailRet(image->ZeroPointerField(&m_pLoader));

    // 
    // Clear interface ID to -1 so it
    // is lazy inited on startup.
    //
    UINT32 *newID = (UINT32 *) image->GetImagePointer(&m_dwInterfaceId);
    if (newID == NULL)
        return E_POINTER;
    *newID = -1;

    if (HasLayout())
    {
        EEClassLayoutInfo *pInfo = &((LayoutEEClass*)this)->m_LayoutInfo;
        
        IfFailRet(image->FixupPointerField(&pInfo->m_pFieldMarshalers));

        FieldMarshaler *pFM = pInfo->m_pFieldMarshalers;
        FieldMarshaler *pFMEnd = (FieldMarshaler*) ((BYTE *)pFM + pInfo->m_numCTMFields*MAXFIELDMARSHALERSIZE);
        while (pFM < pFMEnd)
        {
            IfFailRet(pFM->Fixup(image));
            ((BYTE*&)pFM) += MAXFIELDMARSHALERSIZE;
        }
    }
    else if (IsDelegateClass() || IsMultiDelegateClass())
    {
        DelegateEEClass *pDelegateClass = (DelegateEEClass *) this; 

        IfFailRet(image->FixupPointerField(&pDelegateClass->m_pInvokeMethod));
        if (pDelegateClass->m_pBeginInvokeMethod != NULL)
            IfFailRet(image->FixupPointerField(&pDelegateClass->m_pBeginInvokeMethod));
        if (pDelegateClass->m_pEndInvokeMethod != NULL)
        IfFailRet(image->FixupPointerField(&pDelegateClass->m_pEndInvokeMethod));

        IfFailRet(image->ZeroPointerField(&((DelegateEEClass*)this)->m_pUMThunkMarshInfo));
        IfFailRet(image->ZeroPointerField(&((DelegateEEClass*)this)->m_pStaticShuffleThunk));
    }
    else if (IsEnum())
    {
        EnumEEClass *pEnumClass = (EnumEEClass*) this;

        if (pEnumClass->GetEnumCount() > 0)
        {
            IfFailRet(image->FixupPointerField(&pEnumClass->m_values));
            IfFailRet(image->FixupPointerField(&pEnumClass->m_names));

            DWORD enumCount = pEnumClass->GetEnumCount();
            
            LPCUTF8 *pNames = pEnumClass->m_names;
            LPCUTF8 *pNamesEnd = pNames + enumCount;
            while (pNames < pNamesEnd)
            {
                IfFailRet(image->FixupPointerField(pNames));
                pNames++;
            }
        }
    }


    return S_OK;
}

void EEClass::Unload()
{
    LOG((LF_APPDOMAIN, LL_INFO100, "EEClass::Unload %8.8x, MethodTable %8.8x, %s\n", this, m_pMethodTable, m_szDebugClassName));

    
    // clean up any COM Data
    if (m_pccwTemplate)
        UnloadCCWTemplate(m_pccwTemplate);
    m_pccwTemplate = NULL;

    if (m_pComclassfac)
        UnloadComclassfac(m_pComclassfac);
    m_pComclassfac = NULL;    
}

/**************************************************************************/
// returns true if 'this' delegate is structurally equivalent to 'toDelegate'
// delegagate.  For example if
//      delegate Object delegate1(String)
//      delegate String delegate2(Object)
// then
//      delegate2->CanCastTo(delegate1)
//
// note that the return type can be any subclass (covariant) 
// but the args need to be superclasses (contra-variant)
    
BOOL DelegateEEClass::CanCastTo(DelegateEEClass* toDelegate) {

    MetaSig fromSig(m_pInvokeMethod->GetSig(), m_pInvokeMethod ->GetModule());
    MetaSig toSig(toDelegate->m_pInvokeMethod->GetSig(), toDelegate->m_pInvokeMethod ->GetModule());

    unsigned numArgs = fromSig.NumFixedArgs();
    if (numArgs != toSig.NumFixedArgs() ||  
        fromSig.GetCallingConventionInfo() != toSig.GetCallingConventionInfo())
        return false;

    TypeHandle fromType = fromSig.GetRetTypeHandle();
    TypeHandle toType = toSig.GetRetTypeHandle();

    if (fromType.IsNull() || toType.IsNull() || !fromType.CanCastTo(toType))
        return(false);

    while (numArgs > 0) {
        fromSig.NextArg();
        toSig.NextArg();
        fromType = fromSig.GetTypeHandle();
        toType = toSig.GetTypeHandle();
        if (fromType.IsNull() || toType.IsNull() || !toType.CanCastTo(fromType))
            return(false);
        --numArgs;
    }
    return(true);
}

struct TempEnumValue
{
    LPCUTF8 name;
    UINT64 value;
};

class TempEnumValueSorter : public CQuickSort<TempEnumValue>
{
  public:
    TempEnumValueSorter(TempEnumValue *pArray, SSIZE_T iCount) 
      : CQuickSort<TempEnumValue>(pArray, iCount) {}

    int Compare(TempEnumValue *pFirst, TempEnumValue *pSecond)
    {
        if (pFirst->value == pSecond->value)
            return 0;
        if (pFirst->value > pSecond->value)
            return 1;
        else
            return -1;
    }
};

int EnumEEClass::GetEnumLogSize()
{
    switch (GetMethodTable()->GetNormCorElementType())
    {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        return 0;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        return 1;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        return 2;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
        return 3;

    default:
        _ASSERTE(!"Illegal enum type");
        return 0;
    }
}

HRESULT EnumEEClass::BuildEnumTables()
{
    HRESULT hr;

    _ASSERTE(IsEnum());

    // Note about synchronization:
    // This routine is synchronized OK without any locking since it's idempotent. (although it
    // may leak in races.)
    // Right now we'll be satisfied with this - external code can lock if appropriate.

    if (EnumTablesBuilt())
        return S_OK;

    IMDInternalImport *pImport = GetMDImport();

    HENUMInternal fields;
    IfFailRet(pImport->EnumInit(mdtFieldDef, GetCl(), &fields));

    //
    // Note that we're fine treating signed types as unsigned, because all we really
    // want to do is sort them based on a convenient strong ordering.
    //

    int logSize = GetEnumLogSize();
    int size = 1<<logSize;

    ULONG fieldCount = pImport->EnumGetCount(&fields)-1; // Omit one for __value field

    if (fieldCount > 0)
    {
        CQuickArray<TempEnumValue> temps;

        if (FAILED(temps.ReSize(fieldCount)))
            return E_OUTOFMEMORY;

        TempEnumValue *pTemps = temps.Ptr();

        // The following is not portable code - it assumes that the address of all union members
        // is the same.
        _ASSERTE((offsetof(MDDefaultValue, m_byteValue)
                  == offsetof(MDDefaultValue, m_usValue))
                 && (offsetof(MDDefaultValue, m_ulValue)
                     == offsetof(MDDefaultValue, m_ullValue)));

        mdFieldDef field;
        int nTotalInstanceFields = 0;
        while (pImport->EnumNext(&fields, &field))
        {
            if (IsFdStatic(pImport->GetFieldDefProps(field)))
            {
                pTemps->name = pImport->GetNameOfFieldDef(field);

                MDDefaultValue defaultValue;
                IfFailRet(pImport->GetDefaultValue(field, &defaultValue));
                switch (logSize)
                {
                case 0:
                    pTemps->value = defaultValue.m_byteValue;
                    break;
                case 1:
                    pTemps->value = defaultValue.m_usValue;
                    break;
                case 2:
                    pTemps->value = defaultValue.m_ulValue;
                    break;
                case 3:
                    pTemps->value = defaultValue.m_ullValue;
                    break;
                }
                pTemps++;
            }
            else
            {
                nTotalInstanceFields++;
            }
        }

        _ASSERTE((nTotalInstanceFields == 1) && "Zero or Multiple instance fields in an enum!");

        //
        // Check to see if we are already sorted.  This may seem extraneous, but is 
        // actually probably the normal case.
        //

        BOOL sorted = TRUE;

        pTemps = temps.Ptr();
        TempEnumValue *pTempsEnd = pTemps + fieldCount - 1;
        while (pTemps < pTempsEnd)
        {
            if (pTemps[0].value > pTemps[1].value)
            {
                sorted = FALSE;
                break;
            }
            pTemps++;
        }

        if (!sorted)
        {
            TempEnumValueSorter sorter(temps.Ptr(), fieldCount);
            sorter.Sort();
        }

        // Last chance to exit race without leaking!
        if (EnumTablesBuilt())
            return S_OK;
        
        LPCUTF8 *pNames = (LPCUTF8 *) GetAssembly()->GetHighFrequencyHeap()->AllocMem(fieldCount * sizeof(LPCUTF8));
        BYTE *pValues = (BYTE *) GetAssembly()->GetHighFrequencyHeap()->AllocMem(fieldCount * size);

        pTemps = temps.Ptr();
        pTempsEnd = pTemps + fieldCount;
        
        LPCUTF8 *pn = pNames;
        BYTE *pv = pValues;

        while (pTemps < pTempsEnd)
        {
            *pn++ = pTemps->name;
            switch (logSize)
            {
            case 0:
                *pv++ = (BYTE) pTemps->value;
                break;

            case 1:
                *(USHORT*)pv = (USHORT) pTemps->value;
                pv += sizeof(USHORT);
                break;

            case 2:
                *(UINT*)pv = (UINT) pTemps->value;
                pv += sizeof(UINT);
                break;

            case 3:
                *(UINT64*)pv = (UINT64) pTemps->value;
                pv += sizeof(UINT64);
                break;
            }
            pTemps++;
        }

        m_names = pNames;
        m_values = pValues;

        pImport->EnumClose(&fields);
    }

    m_countPlusOne = fieldCount+1;

    return S_OK;
}

DWORD EnumEEClass::FindEnumValueIndex(BYTE value)
{
    _ASSERTE(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_I1
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_U1
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_BOOLEAN);

    CBinarySearch<BYTE> searcher(GetEnumByteValues(), GetEnumCount());

    const BYTE *found = searcher.Find(&value);
    if (found == NULL)
        return NOT_FOUND;
    else
        return found - m_byteValues;
}

DWORD EnumEEClass::FindEnumValueIndex(USHORT value)
{
    _ASSERTE(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_I2
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_U2
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_CHAR);

    CBinarySearch<USHORT> searcher(GetEnumShortValues(), GetEnumCount());

    const USHORT *found = searcher.Find(&value);
    if (found == NULL)
        return NOT_FOUND;
    else
        return found - m_shortValues;
}

DWORD EnumEEClass::FindEnumValueIndex(UINT value)
{
    _ASSERTE(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_I4
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_U4
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_I
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_U);

    CBinarySearch<UINT> searcher(GetEnumIntValues(), GetEnumCount());

    const UINT *found = searcher.Find(&value);
    if (found == NULL)
        return NOT_FOUND;
    else
        return found - m_intValues;
}

DWORD EnumEEClass::FindEnumValueIndex(UINT64 value)
{
    _ASSERTE(GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_I8
             || GetMethodTable()->GetNormCorElementType() == ELEMENT_TYPE_U8);

    CBinarySearch<UINT64> searcher(GetEnumLongValues(), GetEnumCount());

    const UINT64 *found = searcher.Find(&value);
    if (found == NULL)
        return NOT_FOUND;
    else
        return found - m_longValues;
}

DWORD EnumEEClass::FindEnumNameIndex(LPCUTF8 name)
{
    LPCUTF8 *names = GetEnumNames();
    LPCUTF8 *namesEnd = names + GetEnumCount();

    // Same identity is the most common case
    // & doesn't touch string data
    while (names < namesEnd)
    {
        if (name == *names)
            return names - GetEnumNames();
        names++;
    }

    // otherwise compare strings
    while (names < namesEnd)
    {
        if (strcmp(name, *names) == 0)
            return names - GetEnumNames();
        names++;
    }
    
    return NOT_FOUND;
}

BOOL TypeHandle::IsEnum() 
{
    if (!IsUnsharedMT()) 
        return(false);
    return(AsMethodTable()->GetClass()->IsEnum());
}

EEClass* TypeHandle::GetClass()
{
    MethodTable* pMT = GetMethodTable();
    return(pMT ? pMT->GetClass() : 0);
}

EEClass* TypeHandle::AsClass() 
{
    MethodTable* pMT = AsMethodTable();
    return(pMT ? pMT->GetClass() : 0);
} 

BOOL TypeHandle::IsRestored()
{ 
    return !IsUnsharedMT() || GetMethodTable()->IsRestored(); 
}

void TypeHandle::CheckRestore()
{ 
    if (IsUnsharedMT())
    {
        MethodTable *pMT = GetMethodTable();
        if (!pMT->IsRestored())
            pMT->CheckRestore();
    }
}

OBJECTREF TypeHandle::CreateClassObj()
{
    OBJECTREF o;

    switch(GetNormCorElementType()) {
    case ELEMENT_TYPE_ARRAY:
    case ELEMENT_TYPE_SZARRAY:
    case ELEMENT_TYPE_BYREF:
    case ELEMENT_TYPE_PTR:
        o = ((ParamTypeDesc*)AsTypeDesc())->CreateClassObj();
    break;

    case ELEMENT_TYPE_TYPEDBYREF: 
    {
        EEClass* cls = COMMember::g_pInvokeUtil->GetAnyRef();
        o = cls->GetExposedClassObject();
    } 
    break;

    // for this release a function pointer is mapped into an IntPtr. This result in a loss of information. Fix next release
    case ELEMENT_TYPE_FNPTR:
        o = TheIntPtrClass()->GetClass()->GetExposedClassObject();
        break;

    default:
        if (!IsUnsharedMT()) {
            _ASSERTE(!"Bad Type");
            o = NULL;
        }
        EEClass* cls = AsClass();
        // We never create the Type object for the transparent proxy...
        if (cls->GetMethodTable()->IsTransparentProxyType())
            return 0;
        o = cls->GetExposedClassObject();
        break;
    }
    
    return o;
}

#if CHECK_APP_DOMAIN_LEAKS

BOOL TypeHandle::IsAppDomainAgile()
{
    if (IsUnsharedMT())
    {
        MethodTable *pMT = AsMethodTable();
        return pMT->GetClass()->IsAppDomainAgile();
    }
    else if (IsArray())
    {
        TypeHandle th = AsArray()->GetElementTypeHandle();
        return th.IsArrayOfElementsAppDomainAgile();
    }
    else
    {
        // @todo: consider other types of type handles agile?
        return FALSE;
    }
}

BOOL TypeHandle::IsCheckAppDomainAgile()
{
    if (IsUnsharedMT())
    {
        MethodTable *pMT = AsMethodTable();
        return pMT->GetClass()->IsCheckAppDomainAgile();
    }
    else if (IsArray())
    {
        TypeHandle th = AsArray()->GetElementTypeHandle();  
        return th.IsArrayOfElementsCheckAppDomainAgile();
    }
    else
    {
        // @todo: consider other types of type handles agile?
        return FALSE;
    }
}

BOOL TypeHandle::IsArrayOfElementsAppDomainAgile()
{
    if (IsUnsharedMT())
    {
        MethodTable *pMT = AsMethodTable();
        return (pMT->GetClass()->GetAttrClass() & tdSealed) && pMT->GetClass()->IsAppDomainAgile();
    }
    else
    {
        // I'm not sure how to prove a typedesc is sealed, so
        // just bail and return FALSE here rather than recursing.

        return FALSE;
    }
}

BOOL TypeHandle::IsArrayOfElementsCheckAppDomainAgile()
{
    if (IsUnsharedMT())
    {
        MethodTable *pMT = AsMethodTable();
        return (pMT->GetClass()->IsAppDomainAgile()
                && (pMT->GetClass()->GetAttrClass() & tdSealed) == 0)
          || pMT->GetClass()->IsCheckAppDomainAgile();
    }
    else
    {
        // I'm not sure how to prove a typedesc is sealed, so
        // just bail and return FALSE here rather than recursing.

        return FALSE;
    }
}
#endif

FieldDescIterator::FieldDescIterator(EEClass *pClass, int iteratorType)
{
    m_iteratorType = iteratorType;
    m_pClass = pClass;
    m_currField = -1;
#ifdef EnC_SUPPORTED
    m_isEnC = pClass->GetModule()->IsEditAndContinue();
    m_pCurrListElem = NULL;
#endif // EnC_SUPPORTED

    m_totalFields = m_pClass->GetNumIntroducedInstanceFields();

    if (!(iteratorType & (int)INSTANCE_FIELDS))
        // if not handling instances then skip them by setting curr to last one
        m_currField = m_pClass->GetNumIntroducedInstanceFields() - 1;

    if (iteratorType & (int)STATIC_FIELDS)
        m_totalFields += m_pClass->GetNumStaticFields();
}

FieldDesc* FieldDescIterator::Next()
{
    ++m_currField;
    if (m_currField >= m_totalFields)
        return NULL;
#ifdef EnC_SUPPORTED
    if (m_isEnC)
    {
        FieldDesc *pFD = NextEnC();

        // Either it's not EnC, or it is and it's been fixed up so we can use it, or
        // we're the Debugger RC thread, we can't fix it up, but it's ok since our
        // logic will check & make sure we don't try and use it.
        _ASSERTE(!pFD->IsEnCNew() || 
                 !((EnCFieldDesc*)pFD)->NeedsFixup() ||
                 g_pDebugInterface->GetRCThreadId() == GetCurrentThreadId() );
        return pFD;
    }
#endif // EnC_SUPPORTED
    return (m_pClass->GetFieldDescListRaw()) + m_currField;
}

#ifdef EnC_SUPPORTED
FieldDesc* FieldDescIterator::NextEnC()
{
    EnCEEClassData *pEnCClass = ((EditAndContinueModule*)(m_pClass->GetModule()))->GetEnCEEClassData(m_pClass, TRUE);
    int numIntroducedFields = m_pClass->GetNumIntroducedInstanceFields();
    if (m_iteratorType & (int)INSTANCE_FIELDS &&
        m_currField < numIntroducedFields)
    {
        if (! pEnCClass || m_currField < numIntroducedFields - pEnCClass->m_dwNumAddedInstanceFields) {
            return (m_pClass->GetFieldDescListRaw()) + m_currField;
        } else if (m_pCurrListElem) {
            _ASSERTE(m_pCurrListElem->m_next);
            m_pCurrListElem = m_pCurrListElem->m_next;
            return &m_pCurrListElem->m_fieldDesc;
        } else {
            _ASSERTE(pEnCClass->m_pAddedInstanceFields);
            m_pCurrListElem = pEnCClass->m_pAddedInstanceFields;
            return &m_pCurrListElem->m_fieldDesc;
        }
    }

    int staticFieldOffset = m_currField - numIntroducedFields;
    if (! pEnCClass) {
        _ASSERTE(staticFieldOffset  < m_pClass->GetNumStaticFields());
        return (m_pClass->GetFieldDescListRaw()) + staticFieldOffset + numIntroducedFields;

    } else {

        if (staticFieldOffset  < m_pClass->GetNumStaticFields() - pEnCClass->m_dwNumAddedStaticFields) {
            return (m_pClass->GetFieldDescListRaw()) + staticFieldOffset + numIntroducedFields - pEnCClass->m_dwNumAddedInstanceFields;

        } else if (m_pCurrListElem && m_pCurrListElem->m_fieldDesc.IsStatic()) {
            _ASSERTE(m_pCurrListElem->m_next);
            m_pCurrListElem = m_pCurrListElem->m_next;
            return &m_pCurrListElem->m_fieldDesc;
        } else {
            _ASSERTE(pEnCClass->m_pAddedStaticFields);
            m_pCurrListElem = pEnCClass->m_pAddedStaticFields;
            return &m_pCurrListElem->m_fieldDesc;
        }
    }
}
#endif // EnC_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\classnames.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "namespace.h"

// These system class names are not assembly qualified.

#define g_ActivationServicesClassName "System.Runtime.Remoting.Activation.ActivationServices"
#define g_AppDomainClassName "System.AppDomain"
#define g_ArrayClassName "System.Array"
#define g_AssemblyBuilderClassName "System.Reflection.Emit.AssemblyBuilder"
#define g_AssemblyClassName "System.Reflection.Assembly"
#define g_AssemblyHashAlgorithmClassName "System.Configuration.Assemblies.AssemblyHashAlgorithm"
#define g_AssemblyNameClassName "System.Reflection.AssemblyName"
#define g_AssemblyNameFlagsClassName "System.Reflection.AssemblyNameFlags"

#define g_ByteArrayClassName "System.Byte[]"
#define g_BinderClassName "System.Reflection.Binder"

#define g_CollectionsArrayList "System.Collections.ArrayList"
#define g_CollectionsEnumerableItfName "System.Collections.IEnumerable"
#define g_CollectionsEnumeratorClassName "System.Collections.IEnumerator"
#define g_ColorClassName "System.Drawing.Color"
#define g_ColorTranslatorClassName "System.Drawing.ColorTranslator"
#define g_ComObjectClassName "System.__ComObject"
#define g_ConsoleClassName "System.Console"
#define g_ContextBoundObjectClassName "System.ContextBoundObject"
#define g_ContextClassName "System.Runtime.Remoting.Contexts.Context"
#define g_ContextProxyClassName "System.__ContextProxy"
#define g_CultureInfoClassName "System.Globalization.CultureInfo"

#define g_DateClassName     "System.DateTime"
#define g_DelegateClassName "System.Delegate"
#define g_DecimalClassName "System.Decimal"

#define g_EnumClassName "System.Enum"
#define g_EnumeratorToEnumClassName "System.Runtime.InteropServices.CustomMarshalers.EnumeratorToEnumVariantMarshaler"
#define g_EvidenceClassName "System.Security.Policy.Evidence"
#define g_ExceptionClassName "System.Exception"
#define g_EnvironmentClassName "System.Environment"
#define g_ThreadStopExceptionClassName "System.Threading.ThreadStopException"
#define g_ThreadAbortExceptionClassName "System.Threading.ThreadAbortException"
#define g_ExecutionEngineExceptionClassName "System.ExecutionEngineException"

#define g_HashtableName "System.Collections.Hashtable"
#define g_IdentityClassName "System.Runtime.Remoting.Identity"
#define g_IdentityInfoClassName "System.Security.Policy.IdentityInfo"
#define g_InteropRegistrationService "System.Runtime.InteropServices.RegistrationServices"
#define g_InteropTCEAdapterGenEventSource "System.Runtime.InteropServices.TCEAdapterGen.EventSource"
#define g_InteropDispatchWrapperClassName "System.Runtime.InteropServices.DispatchWrapper"
#define g_InteropUnknownWrapperClassName "System.Runtime.InteropServices.UnknownWrapper"
#define g_InteropErrorWrapperClassName "System.Runtime.InteropServices.ErrorWrapper"
#define g_InteropCurrencyWrapperClassName "System.Runtime.InteropServices.CurrencyWrapper"

#define g_JitHelpers "System.__jithelper"

#define g_LocalDataStoreClassName "System.LocalDataStore"

#define g_MarshalByRefObjectClassName "System.MarshalByRefObject"
#define g_MessageClassName "System.Runtime.Remoting.Messaging.Message"
#define g_MultiDelegateClassName "System.MulticastDelegate"

#define g_NamedAttributeClassName "System.NamedAttribute"

#define g_ObjectClassName "System.Object"
#define g_ObjectName "Object"
#define g_ObjectArrayClassName "System.Object[]"
#define g_OleAutBinderClassName "System.OleAutBinder"
#define g_OperatingSystemClassName "System.OperatingSystem"
#define g_SystemExceptionClassName "System.SystemException"
#define g_OutOfMemoryExceptionClassName "System.OutOfMemoryException"
#define g_AppDomainUnloadedExceptionClassName "System.AppDomainUnloadedException"

#define g_PermissionListSetClassName "System.Security.PermissionListSet"
#define g_PermissionSetClassName "System.Security.PermissionSet"
#define g_PermissionTokenFactoryName "System.Security.PermissionTokenFactory"
#define g_PlatformIDClassName "System.PlatformID"
#define g_PolicyExceptionClassName "System.Security.Policy.PolicyException"

#define g_RealProxyClassName "System.Runtime.Remoting.Proxies.RealProxy"
#define g_ReflectionClassName "System.RuntimeType"
#define g_ReflectionConstructorName "System.Reflection.RuntimeConstructorInfo"
#define g_ReflectionDynamicModuleName "System.Reflection.Emit.ModuleBuilder"
#define g_ReflectionEventInfoName "System.Reflection.RuntimeEventInfo"
#define g_ReflectionExpandoItfName "System.Runtime.InteropServices.Expando.IExpando"
#define g_ReflectionFieldName "System.Reflection.RuntimeFieldInfo"
#define g_ReflectionMemberInfoName "System.Reflection.MemberInfo"
#define g_ReflectionMethodBaseName "System.Reflection.MethodBase"
#define g_ReflectionMethodInfoName "System.Reflection.MethodInfo"
#define g_ReflectionFieldInfoName "System.Reflection.FieldInfo"
#define g_ReflectionPropertyInfoName "System.Reflection.PropertyInfo"
#define g_ReflectionConstructorInfoName "System.Reflection.ConstructorInfo"
#define g_ReflectionMethodName "System.Reflection.RuntimeMethodInfo"
#define g_ReflectionModuleName "System.Reflection.Module"
#define g_ReflectionNameValueName "System.Reflection.NameValueName"
#define g_ReflectionParamInfoName "System.Reflection.ParameterInfo"
#define g_ReflectionPermissionClassName "System.Security.Permissions.ReflectionPermission"
#define g_ReflectionPointerClassName "System.Reflection.Pointer"
#define g_ReflectionPropInfoName "System.Reflection.RuntimePropertyInfo"
#define g_ReflectionReflectItfName "System.Reflection.IReflect"
#define g_ReflectionCustAttrProviderItfName "System.Reflection.ICustomAttributeProvider"
#define g_ReflectionTargetInvocationExceptionClassName "System.Reflection.TargetInvocationException"
#define g_ReflectionTypeLoadExceptionClassName "System.Reflection.ReflectionTypeLoadException"
#define g_RemotingProxyClassName "System.Runtime.Remoting.Proxies.RemotingProxy"
#define g_RemotingServicesClassName "System.Runtime.Remoting.RemotingServices"
#define g_RuntimeArgumentHandleClassName "System.RuntimeArgumentHandle"
#define g_RuntimeArgumentHandleName      "RuntimeArgumentHandle"
#define g_RuntimeFieldHandleClassName    "System.RuntimeFieldHandle"
#define g_RuntimeFieldHandleName         "RuntimeFieldHandle"
#define g_RuntimeMethodHandleClassName   "System.RuntimeMethodHandle"
#define g_RuntimeMethodHandleName        "RuntimeMethodHandle"
#define g_RuntimeTypeHandleClassName     "System.RuntimeTypeHandle"
#define g_RuntimeTypeHandleName          "RuntimeTypeHandle"

#define g_SecurityCallContextClassName "System.Security.Principal.SecurityCallContext"
#define g_SecurityCallersClassName "System.Security.Principal.SecurityCallers"
#define g_SecurityIdentityClassName "System.Security.Principal.SecurityIdentity"
#define g_SecurityPermissionClassName "System.Security.Permissions.SecurityPermission"
#define g_SerializationExceptionName "System.Runtime.SerializationException"
#define g_ServerIdentityClassName "System.Runtime.Remoting.ServerIdentity"
#define g_StackOverflowExceptionClassName "System.StackOverflowException"
#define g_StaticContainerClassName "System.__StaticContainer"
#define g_StringBufferClassName "System.Text.StringBuilder"
#define g_StringBufferName "StringBuilder"
#define g_StringClassName "System.String"
#define g_StringName "String"
#define g_SharedStaticsClassName "System.SharedStatics"

#define g_ThreadClassName "System.Threading.Thread"
#define g_TransparentProxyClassName "System.Runtime.Remoting.Proxies.__TransparentProxy"
#define g_TypeClassName   "System.Type"
#define g_TypeLoadExceptionClassName "System.TypeLoadException"
#define g_TypedReferenceClassName "System.TypedReference"

#define g_UnloadWorkerClassName "System.UnloadWorker"

#define g_ValueTypeClassName "System.ValueType"
#define g_MissingClassName "System.Reflection.Missing"
#define g_ActivatorClassName "System.Activator"
#define g_VariantArrayClassName "System.Variant[]"
#define g_VariantClassName "System.Variant"
#define g_VersionClassName "System.Version"
#define g_VoidPtrClassName "System.Void*"
#define g_GuidClassName "System.Guid"
#define g_ENCHelperClassName "System.Diagnostics.EditAndContinueHelper"
#define g_IConfigHelper "System.IConfigHelper"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\clsload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// clsload.cpp
//

#include "common.h"
#include "winwrap.h"
#include "ceeload.h"
#include "siginfo.hpp"
#include "vars.hpp"
#include "clsload.hpp"
#include "class.h"
#include "method.hpp"
#include "ecall.h"
#include "stublink.h"
#include "object.h"
#include "excep.h"
#include "threads.h"
#include "compluswrapper.h"
#include "COMClass.h"
#include "COMMember.h"
#include "COMString.h"
#include "COMStringBuffer.h"
#include "COMSystem.h"
#include"Comsynchronizable.h"
#include "COMCallWrapper.h"
#include "threads.h"
#include "classfac.h"
#include "ndirect.h"
#include "security.h"
#include "DbgInterface.h"
#include "log.h"
#include "EEConfig.h"
#include "NStruct.h"
#include "jitinterface.h"
#include "COMVariant.h"
#include "InternalDebug.h"
#include "utilcode.h"
#include "permset.h"
#include "vars.hpp"
#include "Assembly.hpp"
#include "PerfCounters.h"
#include "EEProfInterfaces.h"
#include "eehash.h"
#include "typehash.h"
#include "COMDelegate.h"
#include "array.h"
#include "zapmonitor.h"
#include "COMNlsInfo.h"
#include "stackprobe.h"
#include "PostError.h"
#include "wrappers.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


enum CorEntryPointType
{
    EntryManagedMain,                   // void main(String[])
    EntryCrtMain                        // unsigned main(void)
};

// forward decl
void ValidateMainMethod(MethodDesc * pFD, CorEntryPointType *pType);

//@todo get from a resource file
WCHAR* wszClass = L"Class";
WCHAR* wszFile =  L"File"; 

extern BOOL CompareCLSID(UPTR u1, UPTR u2);

void ThrowMainMethodException(MethodDesc* pMD, UINT resID) 
{
    THROWSCOMPLUSEXCEPTION();
    DefineFullyQualifiedNameForClassW();                                                 
    LPCWSTR szClassName = GetFullyQualifiedNameForClassW(pMD->GetClass());               
    LPCUTF8 szUTFMethodName = pMD->GetMDImport()->GetNameOfMethodDef(pMD->GetMemberDef());              
    #define MAKE_TRANSLATIONFAILED szMethodName=L""
    MAKE_WIDEPTR_FROMUTF8_FORPRINT(szMethodName, szUTFMethodName);                                
    #undef MAKE_TRANSLATIONFAILED
    COMPlusThrowHR(COR_E_METHODACCESS, resID, szClassName, szMethodName);                                                   
}

// These UpdateThrowable routines should only be called in 'Catch' clause (since they do rethrow)
void UpdateThrowable(OBJECTREF* pThrowable) {
    if (pThrowable == RETURN_ON_ERROR)
        return;
    if (pThrowable == THROW_ON_ERROR) {
        DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
        COMPlusRareRethrow();
    }
    *pThrowable = GETTHROWABLE();
}

unsigned NameHandle::GetFullName(char* buff, unsigned buffLen)
{
    if (IsConstructed())
    {  
        CorElementType kind = GetKind();
      
        return TypeDesc::ConstructName(kind, 
                                       CorTypeInfo::IsModifier(kind) ? GetElementType() : TypeHandle(),
                                       kind == ELEMENT_TYPE_ARRAY ? GetRank() : 0,
                                       buff, buffLen);
    }
    else 
    {
        if(GetName() == NULL)
            return 0;

        strcpy(buff, GetName());
        return (unsigned)strlen(buff);
    }
}


//
// Find a class given name, using the classloader's global list of known classes.  
// Returns NULL if class not found.
TypeHandle ClassLoader::FindTypeHandle(NameHandle* pName, 
                                       OBJECTREF *pThrowable)
{
    SAFE_REQUIRES_N4K_STACK(3);

#ifdef _DEBUG
    pName->Validate();
#endif

    // Lookup in the classes that this class loader knows about
    TypeHandle typeHnd = LookupTypeHandle(pName, pThrowable);

    if(typeHnd.IsNull()) {
        
#ifdef _DEBUG
        // Use new to conserve stack space here - this is in the path of handling a stack overflow exception
        char *name = new char [MAX_CLASSNAME_LENGTH + 1];
        if (name != NULL)
            pName->GetFullName(name, MAX_CLASSNAME_LENGTH);
        LPWSTR pwCodeBase;
        GetAssembly()->GetCodeBase(&pwCodeBase, NULL);
        LOG((LF_CLASSLOADER, LL_INFO10, "Failed to find class \"%s\" in the manifest for assembly \"%ws\"\n", name, pwCodeBase));
        delete [] name;
#endif

        COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cLoadFailures++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cLoadFailures++);
        
        if (pThrowableAvailable(pThrowable) && *((Object**) pThrowable) == NULL) 
            m_pAssembly->PostTypeLoadException(pName, IDS_CLASSLOAD_GENERIC, pThrowable);
    }
    
    return typeHnd;
}

//@TODO: Need to allow exceptions to be thrown when classloader is cleaned up
EEClassHashEntry_t* ClassLoader::InsertValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser)
{
    //    COMPLUS_TRY {
        EEClassHashEntry_t *pEntry = m_pAvailableClasses->InsertValue(pszNamespace, pszClassName, Data, pEncloser);
    
        //If we're keeping a table for case-insensitive lookup, keep that up to date
        if (m_pAvailableClassesCaseIns && pEntry) {
            LPUTF8 pszLowerCaseNS;
            LPUTF8 pszLowerCaseName;
            //What do we want to do if we can't create a key?
            if ((!CreateCanonicallyCasedKey(pszNamespace, pszClassName, &pszLowerCaseNS, &pszLowerCaseName)) ||
                (!m_pAvailableClassesCaseIns->InsertValue(pszLowerCaseNS, pszLowerCaseName, pEntry, pEntry->pEncloser)))
                return NULL;
        }
        return pEntry;
        //}
        //COMPLUS_CATCH {
        //} COMPLUS_END_CATCH

        //return NULL;
}

BOOL ClassLoader::CompareNestedEntryWithExportedType(IMDInternalImport *pImport,
                                                mdExportedType mdCurrent,
                                                EEClassHashEntry_t *pEntry)
{
    LPCUTF8 Key[2];

    do {
        pImport->GetExportedTypeProps(mdCurrent,
                                 &Key[0],
                                 &Key[1],
                                 &mdCurrent,
                                 NULL, //binding (type def)
                                 NULL); //flags

        if (m_pAvailableClasses->CompareKeys(pEntry, Key)) {
            // Reached top level class for mdCurrent - return whether
            // or not pEntry is a top level class
            // (pEntry is a top level class if its pEncloser is NULL)
            if ((TypeFromToken(mdCurrent) != mdtExportedType) ||
                (mdCurrent == mdExportedTypeNil))
                return (!pEntry->pEncloser);
        }
        else // Keys don't match - wrong entry
            return FALSE;
    }
    while ((pEntry = pEntry->pEncloser) != NULL);

    // Reached the top level class for pEntry, but mdCurrent is nested
    return FALSE;
}


BOOL ClassLoader::CompareNestedEntryWithTypeDef(IMDInternalImport *pImport,
                                                mdTypeDef mdCurrent,
                                                EEClassHashEntry_t *pEntry)
{
    LPCUTF8 Key[2];

    do {
        pImport->GetNameOfTypeDef(mdCurrent, &Key[1], &Key[0]);

        if (m_pAvailableClasses->CompareKeys(pEntry, Key)) {
            // Reached top level class for mdCurrent - return whether
            // or not pEntry is a top level class
            // (pEntry is a top level class if its pEncloser is NULL)
            if (FAILED(pImport->GetNestedClassProps(mdCurrent, &mdCurrent)))
                return (!pEntry->pEncloser);
        }
        else // Keys don't match - wrong entry
            return FALSE;
    }
    while ((pEntry = pEntry->pEncloser) != NULL);

    // Reached the top level class for pEntry, but mdCurrent is nested
    return FALSE;
}


BOOL ClassLoader::CompareNestedEntryWithTypeRef(IMDInternalImport *pImport,
                                                mdTypeRef mdCurrent,
                                                EEClassHashEntry_t *pEntry)
{
    LPCUTF8 Key[2];
    
    do {
        pImport->GetNameOfTypeRef(mdCurrent, &Key[0], &Key[1]);

        if (m_pAvailableClasses->CompareKeys(pEntry, Key)) {
            mdCurrent = pImport->GetResolutionScopeOfTypeRef(mdCurrent);
            // Reached top level class for mdCurrent - return whether
            // or not pEntry is a top level class
            // (pEntry is a top level class if its pEncloser is NULL)
            if ((TypeFromToken(mdCurrent) != mdtTypeRef) ||
                (mdCurrent == mdTypeRefNil))
                return (!pEntry->pEncloser);
        }
        else // Keys don't match - wrong entry
            return FALSE;
    }
    while ((pEntry = pEntry->pEncloser)!=NULL);

    // Reached the top level class for pEntry, but mdCurrent is nested
    return FALSE;
}


BOOL ClassLoader::IsNested(NameHandle* pName, mdToken *mdEncloser)
{
    if (pName->GetTypeModule()) {
        switch(TypeFromToken(pName->GetTypeToken())) {
        case mdtTypeDef:
            return (SUCCEEDED(pName->GetTypeModule()->GetMDImport()->GetNestedClassProps(pName->GetTypeToken(), mdEncloser)));
            
        case mdtTypeRef:
            *mdEncloser = pName->GetTypeModule()->GetMDImport()->GetResolutionScopeOfTypeRef(pName->GetTypeToken());
            return ((TypeFromToken(*mdEncloser) == mdtTypeRef) &&
                    (*mdEncloser != mdTypeRefNil));

        case mdtExportedType:
            pName->GetTypeModule()->GetAssembly()->GetManifestImport()->GetExportedTypeProps(pName->GetTypeToken(),
                                                                                        NULL, // namespace
                                                                                        NULL, // name
                                                                                        mdEncloser,
                                                                                        NULL, //binding (type def)
                                                                                        NULL); //flags
            return ((TypeFromToken(*mdEncloser) == mdtExportedType) &&
                    (*mdEncloser != mdExportedTypeNil));

        case mdtBaseType:
            if (pName->GetBucket())
                return TRUE;
            return FALSE;

        default:
            _ASSERTE(!"Unexpected token type");
            return FALSE;
        }
    }
    else
        return FALSE;
}

EEClassHashEntry_t *ClassLoader::GetClassValue(EEClassHashTable *pTable,
                                               NameHandle *pName, HashDatum *pData)
{
    mdToken             mdEncloser;
    EEClassHashEntry_t  *pBucket;

#if _DEBUG
    if (pName->GetName())
    {
        if (pName->GetNameSpace() == NULL)
            LOG((LF_CLASSLOADER, LL_INFO1000, "Looking up %s by name.", 
                 pName->GetName()));
        else
            LOG((LF_CLASSLOADER, LL_INFO1000, "Looking up %s.%s by name.", 
                 pName->GetNameSpace(), pName->GetName()));
    }
#endif

    if (IsNested(pName, &mdEncloser)) {
        Module *pModule = pName->GetTypeModule();
        _ASSERTE(pModule);
        if ((pBucket = pTable->GetValue(pName, pData, TRUE)) != NULL) {
            switch (TypeFromToken(pName->GetTypeToken())) {
            case mdtTypeDef:
                while ((!CompareNestedEntryWithTypeDef(pModule->GetMDImport(),
                                                       mdEncloser,
                                                       pBucket->pEncloser)) &&
                       (pBucket = pTable->FindNextNestedClass(pName, pData, pBucket)) != NULL);
                break;
            case mdtTypeRef:
                while ((!CompareNestedEntryWithTypeRef(pModule->GetMDImport(),
                                                       mdEncloser,
                                                       pBucket->pEncloser)) &&
                       (pBucket = pTable->FindNextNestedClass(pName, pData, pBucket)) != NULL);
                break;
            case mdtExportedType:
                while ((!CompareNestedEntryWithExportedType(pModule->GetAssembly()->GetManifestImport(),
                                                       mdEncloser,
                                                       pBucket->pEncloser)) &&
                       (pBucket = pTable->FindNextNestedClass(pName, pData, pBucket)) != NULL);
                break;
            default:
                while ((pBucket->pEncloser != pName->GetBucket())  &&
                       (pBucket = pTable->FindNextNestedClass(pName, pData, pBucket)) != NULL);
            }
        }
    }
    else
        // Check if this non-nested class is in the table of available classes.
        pBucket = pTable->GetValue(pName, pData, FALSE);

    return pBucket;
}

BOOL ClassLoader::LazyAddClasses()
{
    HRESULT hr;
    BOOL result = FALSE;

    // Add any unhashed modules into our hash tables, and try again.

    Module *pModule = m_pHeadModule;
    while (pModule) {
        if (!pModule->AreClassesHashed()) { 
            mdTypeDef      td;
            HENUMInternal  hTypeDefEnum;

            if (!pModule->IsResource())
            {
                IMDInternalImport *pImport = pModule->GetMDImport();
            
                hr = pImport->EnumTypeDefInit(&hTypeDefEnum);
                if (SUCCEEDED(hr)) {
                    // Now loop through all the classdefs adding the CVID and scope to the hash
                    while(pImport->EnumTypeDefNext(&hTypeDefEnum, &td)) {

                        hr = AddAvailableClassHaveLock(pModule,
                                                       pModule->GetClassLoaderIndex(), td);
                        /*
                        if(FAILED(hr) && (hr != CORDBG_E_ENC_RE_ADD_CLASS)) 
                            break;
                        */
                    }
                    pImport->EnumTypeDefClose(&hTypeDefEnum);
                }
            }

            result = TRUE;

            pModule->SetClassesHashed();

            LOG((LF_CLASSLOADER, LL_INFO10, "%S's classes added to hash table\n", 
                 pModule->GetFileName()));

            FastInterlockDecrement((LONG*)&m_cUnhashedModules);
        }

        pModule = pModule->GetNextModule();
    }

    return result;
}


//
// Find or load a class known to this classloader (any module).  Does NOT go to the registry - it only looks
// at loaded modules
//
// It is not a serious failure when this routine does not find the class in the available table. Therefore, do not
// post an error. However, if it does find it in the table and there is a failure loading this class then
// an error should be posted.
//
// It's okay to give NULL for pModule and a nil token for cl in the NameHandle if it's
// guaranteed that this is not a nested type.  Otherwise, cl should be a
// TypeRef or TypeDef, and pModule should be the Module that token applies to
HRESULT ClassLoader::FindClassModule(NameHandle* pName,
                                     TypeHandle* pType, 
                                     mdToken* pmdClassToken,
                                     Module** ppModule,
                                     mdToken *pmdFoundExportedType,
                                     EEClassHashEntry_t** ppEntry,
                                     OBJECTREF* pThrowable)
{
    _ASSERTE(pName);
    HashDatum   Data;
    Module *    pUncompressedModule;
    mdTypeDef   UncompressedCl;
    HRESULT     hr = S_OK;
    EEClassHashEntry_t *pBucket;
    EEClassHashEntry_t **ppBucket = &(pName->m_pBucket);
    EEClassHashTable *pTable = NULL;
    NameHandle  lowerCase;
    
    switch (pName->GetTable()) {
    case nhConstructed :
    {
        EETypeHashEntry_t *pBucket = m_pAvailableParamTypes->GetValue(pName, &Data);
        if (pBucket == NULL)
            return COR_E_TYPELOAD;
        if (pType) 
            *pType = TypeHandle(Data);
        return S_OK;
    }

    case nhCaseInsensitive :
    {
        {
            CLR_CRITICAL_SECTION(&m_AvailableClassLock);
            if (!m_pAvailableClassesCaseIns) 
            m_pAvailableClassesCaseIns = m_pAvailableClasses->MakeCaseInsensitiveTable(this);
        
        }
        // Use the case insensitive table
        pTable = m_pAvailableClassesCaseIns;

        // Create a low case version of the namespace and name
        LPUTF8 pszLowerNameSpace = NULL;
        LPUTF8 pszLowerClassName = "";
        int allocLen;
        if(pName->GetNameSpace()) {
            allocLen = (int)strlen(pName->GetNameSpace());
            if(allocLen) {
                allocLen += 2;
                pszLowerNameSpace = (LPUTF8)_alloca(allocLen);
                if (!InternalCasingHelper::InvariantToLower(pszLowerNameSpace, allocLen, pName->GetNameSpace()))
                    pszLowerNameSpace = NULL;
            }
        }
        _ASSERTE(pName->GetName());
        allocLen = (int)strlen(pName->GetName());
        if(allocLen) {
            allocLen += 2;
            pszLowerClassName = (LPUTF8)_alloca(allocLen);
            if (!InternalCasingHelper::InvariantToLower(pszLowerClassName, allocLen, pName->GetName()))
                return COR_E_TYPELOAD;
        }

        // Substitute the lower case version of the name.
        // The field are will be released when we leave this scope
        lowerCase = *pName;
        lowerCase.SetName(pszLowerNameSpace, pszLowerClassName);
        pName = &lowerCase;
        break;
    }
    case nhCaseSensitive :
        pTable = m_pAvailableClasses;
        break;
    }
    
    // Remember if there are any unhashed modules.  We must do this before
    // the actual look to avoid a race condition with other threads doing lookups.
    BOOL incomplete = (m_cUnhashedModules > 0);
    
    pBucket = GetClassValue(pTable, pName, &Data);
    if (pBucket == NULL) {

        LockAvailableClasses();

        // Try again with the lock.  This will protect against another thread reallocating
        // the hash table underneath us
        pBucket = GetClassValue(pTable, pName, &Data);

        if (pBucket == NULL && m_cUnhashedModules > 0 && LazyAddClasses())
            // Try yet again with the new classes added
            pBucket = GetClassValue(pTable, pName, &Data);

        UnlockAvailableClasses();
    }

    if (!pBucket) {
#ifdef _DEBUG
        // Use new to conserve stack space here - this is in the path of handling a stack overflow exception
        char *nameS = new char [MAX_CLASSNAME_LENGTH + 1];
        if (nameS != NULL)
            pName->GetFullName(nameS, MAX_CLASSNAME_LENGTH);
        LPWSTR pwCodeBase;
        GetAssembly()->GetCodeBase(&pwCodeBase, NULL);
        LOG((LF_CLASSLOADER, LL_INFO10, "Failed to find Bucket in hash table \"%s\" in me \"%ws\" Incomplete = %d\n", nameS, pwCodeBase, incomplete));
        delete [] nameS;
#endif
        return COR_E_TYPELOAD;
    }

    if(pName->GetTable() == nhCaseInsensitive) {
        _ASSERTE(Data);
        pBucket = (EEClassHashEntry_t*) Data;
        Data = pBucket->Data;
    }

    if (pName->GetTypeToken() == mdtBaseType)
        *ppBucket = pBucket;

    // Lower bit is a discriminator.  If the lower bit is NOT SET, it means we have
    // a TypeHandle. Otherwise, we have a Module/CL.
    if ((((size_t) Data) & 1) == 0) {
        if(pType) *pType = TypeHandle(Data);
        if(ppEntry) *ppEntry = pBucket;
        return S_OK;
    }

    // We have a Module/CL
    mdExportedType mdCT;
    hr = UncompressModuleAndClassDef(Data, pName->GetTokenNotToLoad(),
                                     &pUncompressedModule, &UncompressedCl,
                                     &mdCT, pThrowable);
    
    if(SUCCEEDED(hr)) {
        if(pmdClassToken) *pmdClassToken = UncompressedCl;
        if(ppModule) *ppModule = pUncompressedModule;
        if(ppEntry) *ppEntry = pBucket;
        if(pmdFoundExportedType) *pmdFoundExportedType = mdCT;
    }
#ifdef _DEBUG
    else {
        // Use new to conserve stack space here - this is in the path of handling a stack overflow exception
        char *nameS = new char [MAX_CLASSNAME_LENGTH + 1];
        if (nameS != NULL)
            pName->GetFullName(nameS, MAX_CLASSNAME_LENGTH);
        LPWSTR pwCodeBase;
        GetAssembly()->GetCodeBase(&pwCodeBase, NULL);
        LOG((LF_CLASSLOADER, LL_INFO10, "Failed to uncompress entry for \"%s\" in me \"%ws\" \n", nameS, pwCodeBase));
        delete [] nameS;
    }
#endif

    return hr;
}


// Does not post an exception if the type was not found.  Use FindTypeHandle()
// instead if you need that.
//
// Find or load a class known to this classloader (any module).  Does NOT look
// in the system assembly or any other 'magic' place 
TypeHandle ClassLoader::LookupTypeHandle(NameHandle* pName, 
                                         OBJECTREF *pThrowable /*=NULL*/)
{
    TypeHandle  typeHnd; 
    Module*     pFoundModule = NULL;
    mdToken     FoundCl;
    EEClassHashEntry_t* pEntry = NULL;
    mdExportedType FoundExportedType;

        // we don't want to throw exeptions in this routine.  
    if (pThrowable == THROW_ON_ERROR)
        pThrowable = RETURN_ON_ERROR;

    HRESULT hr = FindClassModule(pName,
                                 &typeHnd, 
                                 &FoundCl, 
                                 &pFoundModule,
                                 &FoundExportedType,
                                 &pEntry, 
                                 pThrowable);
    


    if (!typeHnd.IsNull())  // Found the cached value
        return typeHnd;
    
    if(SUCCEEDED(hr)) {         // Found a cl, pModule pair
        if(pFoundModule->GetClassLoader() == this) {
            BOOL fTrustTD = TRUE;
            BOOL fVerifyTD = (FoundExportedType && 
                              !(m_pAssembly->m_cbPublicKey ||
                                m_pAssembly->GetSecurityModule()->GetSecurityDescriptor()->IsSigned()));

            // verify that FoundCl is a valid token for pFoundModule, because
            // it may be just the hint saved in an ExportedType in another scope
            if (fVerifyTD) {
                HENUMInternal phTDEnum;
                DWORD dwElements = 0;
                if (pFoundModule->GetMDImport()->EnumTypeDefInit(&phTDEnum) == S_OK) {
                    dwElements = pFoundModule->GetMDImport()->EnumGetCount(&phTDEnum);              
                    pFoundModule->GetMDImport()->EnumTypeDefClose(&phTDEnum);
                    // assumes max rid is incremented by one for globals (0x02000001)
                    if (RidFromToken(FoundCl) > dwElements+1)
                        fTrustTD = FALSE;
                }
            }

            NameHandle name;
            name.SetTokenNotToLoad(pName->GetTokenNotToLoad());
            name.SetRestore(pName->GetRestore());
            if (fTrustTD) {
                name.SetTypeToken(pFoundModule, FoundCl);
                typeHnd = LoadTypeHandle(&name, pThrowable, FALSE);
            }

            // If we used a TypeDef saved in a ExportedType, if we didn't verify
            // the hash for this internal module, don't trust the TD value.
            if (fVerifyTD) {
                BOOL fNoMatch;
                if (typeHnd.IsNull())
                    fNoMatch = TRUE;
                else {
                    CQuickBytes qb;
                    CQuickBytes qb2;
                    ns::MakePath(qb,
                                 pName->GetNameSpace(),
                                 pName->GetName());
                    LPSTR szName = (LPSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));
                    typeHnd.GetName(szName, MAX_CLASSNAME_LENGTH);
                    fNoMatch = strcmp((LPSTR) qb.Ptr(), szName);
                }
                
                if (fNoMatch) {
                    if (SUCCEEDED(FindTypeDefByExportedType(m_pAssembly->GetManifestImport(),
                                                            FoundExportedType,
                                                            pFoundModule->GetMDImport(),
                                                            &FoundCl))) {
                        name.SetTypeToken(pFoundModule, FoundCl);
                        typeHnd = LoadTypeHandle(&name, pThrowable, FALSE);
                    }
                    else {
                        return TypeHandle();
                    }
                }
            }
        }
        else {
            typeHnd = pFoundModule->GetClassLoader()->LookupTypeHandle(pName, pThrowable);
        }

        // Replace AvailableClasses Module entry with EEClass entry
        if (!typeHnd.IsNull() && typeHnd.IsRestored())
            pEntry->Data = typeHnd.AsPtr();
    } 
    else {// See if it is an array, or other type constructed on the fly
        typeHnd = FindParameterizedType(pName, pThrowable);
    }

    if (!typeHnd.IsNull() && typeHnd.IsRestored()) 
    {
        // Move any system interfaces defined for this type to the current domain.
        if(typeHnd.IsUnsharedMT())
        {
            if (!MapInterfaceToCurrDomain(typeHnd, pThrowable))
                typeHnd = TypeHandle();
        }
    }

    return typeHnd;
}

BOOL ClassLoader::MapInterfaceToCurrDomain(TypeHandle InterfaceType, OBJECTREF *pThrowable)
{
    BOOL bSuccess = TRUE;

    // Only do the mapping if we can get the current domain.
    // On Server GC thread or concurrent GC thread, we do not know
    // the Current Domain.
    AppDomain *pDomain = SystemDomain::GetCurrentDomain();
    if (pDomain)
    {
        COMPLUS_TRY
        {
            InterfaceType.GetClass()->MapSystemInterfacesToDomain(pDomain);
        }
        COMPLUS_CATCH
        {
            UpdateThrowable(pThrowable);

                // TODO we really need to be much more uniform about not catching 
                // uncatchable exceptions.  We also need to make this easier to 
                // to dot he check. - vancem
            BEGIN_ENSURE_PREEMPTIVE_GC();
            OBJECTREF Exception = GETTHROWABLE();
            GCPROTECT_BEGIN(Exception)
            {
                // Some exceptions should never be caught.
                if (IsUncatchable(&Exception)) 
                {
                   DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
                   COMPlusRareRethrow();
                }
            }
            GCPROTECT_END();

            // The operation has failed.
            bSuccess = FALSE;

            END_ENSURE_PREEMPTIVE_GC();
        }
        COMPLUS_END_CATCH
    }

    return bSuccess;
}

//   For non-nested classes, gets the ExportedType name and finds the corresponding
// TypeDef.
//   For nested classes, gets the name of the ExportedType and its encloser.
// Recursively gets and keeps the name for each encloser until we have the top
// level one.  Gets the TypeDef token for that.  Then, returns from the
// recursion, using the last found TypeDef token in order to find the
// next nested level down TypeDef token.  Finally, returns the TypeDef
// token for the type we care about.
HRESULT ClassLoader::FindTypeDefByExportedType(IMDInternalImport *pCTImport, mdExportedType mdCurrent,
                                          IMDInternalImport *pTDImport, mdTypeDef *mtd)
{
    mdToken mdImpl;
    LPCSTR szcNameSpace;
    LPCSTR szcName;
    HRESULT hr;

    pCTImport->GetExportedTypeProps(mdCurrent,
                               &szcNameSpace,
                               &szcName,
                               &mdImpl,
                               NULL, //binding
                               NULL); //flags
    if ((TypeFromToken(mdImpl) == mdtExportedType) &&
        (mdImpl != mdExportedTypeNil)) {
        // mdCurrent is a nested ExportedType
        if (FAILED(hr = FindTypeDefByExportedType(pCTImport, mdImpl, pTDImport, mtd)))
            return hr;

        // Get TypeDef token for this nested type
        return pTDImport->FindTypeDef(szcNameSpace, szcName, *mtd, mtd);
    }

    // Get TypeDef token for this top-level type
    return pTDImport->FindTypeDef(szcNameSpace, szcName, mdTokenNil, mtd);
}


BOOL ClassLoader::CreateCanonicallyCasedKey(LPCUTF8 pszNameSpace, LPCUTF8 pszName, LPUTF8 *ppszOutNameSpace, LPUTF8 *ppszOutName)
{
    //Calc & allocate path length
    //Includes terminating null
    int iNSLength = (int)(strlen(pszNameSpace) + 1);
    int iNameLength = (int)(strlen(pszName) + 1);
    *ppszOutNameSpace = (LPUTF8)(GetHighFrequencyHeap()->AllocMem(iNSLength + iNameLength));
    if (!*ppszOutNameSpace) {
        _ASSERTE(!"Unable to allocate buffer");
        goto ErrorExit;
    }
    *ppszOutName = *ppszOutNameSpace + iNSLength;

    if ((InternalCasingHelper::InvariantToLower(*ppszOutNameSpace, iNSLength, pszNameSpace) < 0) ||
        (InternalCasingHelper::InvariantToLower(*ppszOutName, iNameLength, pszName) < 0)) {
        _ASSERTE(!"Unable to convert to lower-case");
        goto ErrorExit;
    }

    return TRUE;

 ErrorExit:
    //We allocated the string on our own heap, so we don't have to worry about cleaning up,
    //the EE will take care of that during shutdown.  We'll keep a common exit point in case
    //we change our mind.
    return FALSE;
}


void ClassLoader::FindParameterizedTypeHelper(MethodTable   **pTemplateMT,
                                              OBJECTREF      *pThrowable)
{
    COMPLUS_TRY
    {
        *pTemplateMT = TheUIntPtrClass();
    }
    COMPLUS_CATCH
    {
        UpdateThrowable(pThrowable);
    }
    COMPLUS_END_CATCH
}


/* load a parameterized type */
TypeHandle ClassLoader::FindParameterizedType(NameHandle* pName,
                                              OBJECTREF *pThrowable /*=NULL*/)
{
    // We post an exception if of GetArrayTypeHandle returns null. By the time we are 
    // done with GetArrayTypeHandle() we have searched all the available assemblies 
    // and have failed. If we are not an array then do not post an error  
    // because we have only searched our assembly.
    
    TypeHandle typeHnd = TypeHandle();
    CorElementType kind = pName->GetKind();
    unsigned rank = 0;
    NameHandle paramHandle;     // The name handle of the element type for a parameterized type
    TypeHandle paramType;       // The looked-up type handle of the element type 
    NameHandle normHandle;      // The normalized name handle
    char* nameSpace = NULL;
    char* name = NULL;

    // Legacy mangling: deconstruct string to determine ELEMENT_TYPE_?, rank (for arrays), and paramType
    // Also required for Type::GetType in reflection
    if (kind == ELEMENT_TYPE_CLASS)
    {
        // _ASSERTE(!"You should be creating arrays using typespecs");

        LPCUTF8 pszClassName = pName->GetName();

        // Find the element type 
        unsigned len = (unsigned)strlen(pszClassName);
        if (len < 2)
            return(typeHnd);        // Not a parameterized type

        LPUTF8 ptr = const_cast<LPUTF8>(&pszClassName[len-1]);

        switch(*ptr) {
        case ']':
            --ptr;
            if (*ptr == '[') {
                kind = ELEMENT_TYPE_SZARRAY;
                rank = 1;
            }
            else {
                // it is not a szarray however it could still be a single dimension array
                kind = ELEMENT_TYPE_ARRAY;
                rank = 1;
                while(ptr > pszClassName) {
                    if (*ptr == ',') 
                        rank++; // now we now is a MD array
                    else if (*ptr == '*') {
                        // we need to normalize the [*,*] form to [,]. Remove the '*',except if we have [*]
                        // The reason is that [*,*] == [,] 
                        if (rank == 1) {
                            if (ptr[-1] == '[') {
                                // this is the [*], remember [*] != [] 
                                ptr--;
                                break;
                            }
                        }
                        // remove the * by compacting the string
                        for (int i = 0; ptr[i]; i++)
                            ptr[i] = ptr[i + 1];
                    }
                    else
                        break;
                    --ptr;
                }
            }
            if (ptr <= pszClassName || *ptr != '[') {
                m_pAssembly->PostTypeLoadException(pName, IDS_CLASSLOAD_BAD_NAME, pThrowable);
                return(typeHnd);
            }
            break;
        case '&':
            kind = ELEMENT_TYPE_BYREF;
            break;
        case '*':
            kind = ELEMENT_TYPE_PTR;
            break;
        default:
            return(typeHnd);        // Fail
        }
    
        /* If we are here, then we have found a parameterized type.  ptr points
           just beyond the end of the element type involved.  */
        SIZE_T iParamName = ptr - pszClassName;
        CQuickBytes qb;
        LPSTR paramName = (LPSTR) qb.Alloc(iParamName+1);
        memcpy(paramName, pszClassName, iParamName);
        paramName[iParamName] = 0;
        
        /* Get the element type */ 
        paramHandle = NameHandle(*pName);
        paramHandle.SetName(paramName);
        
        paramType = LookupTypeHandle(&paramHandle, pThrowable);
        if (paramType.IsNull())
            return(typeHnd);
    
        normHandle = NameHandle(kind, paramType, rank);
    }

    // New hash-consed scheme for constructed types
    else
    {
        paramType = pName->GetElementType();
        if (paramType.IsNull())
            return(typeHnd);
    
        kind = (CorElementType) pName->GetKind();
        rank = pName->GetRank();
        normHandle = *pName;    

        _ASSERTE((kind != ELEMENT_TYPE_ARRAY) || rank > 0);
        _ASSERTE((kind != ELEMENT_TYPE_SZARRAY) || rank == 1);
    }
    
    /* Parameterized types live in the class loader of the element type */
    ClassLoader* paramLoader = paramType.GetModule()->GetClassLoader();
    
    // let <Type>* type have a method table
    // System.IntPtr's method table is used for types like int*, void *, string * etc.
    MethodTable* templateMT = 0;
    if (!CorTypeInfo::IsArray(kind) && (kind == ELEMENT_TYPE_PTR || kind == ELEMENT_TYPE_FNPTR))
        FindParameterizedTypeHelper(&templateMT, pThrowable);

    CRITICAL_SECTION_HOLDER(availableClassLock, &paramLoader->m_AvailableClassLock);
    availableClassLock.Enter(); // availableClassLock will free the lock when it goes out of scope

    // Check in case another thread added the parameterized type
    if (SUCCEEDED(paramLoader->FindClassModule(&normHandle,
                                               &typeHnd,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               pThrowable)))
    {
        return(typeHnd);
    }

    _ASSERTE(typeHnd.IsNull());

    // Create a new type descriptor and insert into constructed type table
    if (CorTypeInfo::IsArray(kind)) {

        // Arrays of BYREFS not allowed
        if (paramType.GetNormCorElementType() == ELEMENT_TYPE_BYREF || paramType.GetNormCorElementType() == ELEMENT_TYPE_TYPEDBYREF) {
            m_pAssembly->PostTypeLoadException(pName, IDS_CLASSLOAD_CANTCREATEARRAYCLASS, pThrowable);
            return(typeHnd);
        }
        
        // We really don't need this check anymore. 
        if (rank > MAX_RANK) {
            m_pAssembly->PostTypeLoadException(pName, IDS_CLASSLOAD_RANK_TOOLARGE, pThrowable);
            return(typeHnd);
        }

        templateMT = paramLoader->CreateArrayMethodTable(paramType, kind, rank, pThrowable);
        if (templateMT == 0){
            return(typeHnd);
        }
    }
    else {
        // no parameterized type allowed on a reference
        if (paramType.GetNormCorElementType() == ELEMENT_TYPE_BYREF || paramType.GetNormCorElementType() == ELEMENT_TYPE_TYPEDBYREF) {
            m_pAssembly->PostTypeLoadException(pName, IDS_CLASSLOAD_GENERIC, pThrowable);
            return(typeHnd);
        }
    }

    BYTE* mem = (BYTE*) paramLoader->GetAssembly()->GetLowFrequencyHeap()->AllocMem(sizeof(ParamTypeDesc));   
    if (mem == NULL) {
        PostOutOfMemoryException(pThrowable);
        return(typeHnd);
    }

    typeHnd = TypeHandle(new(mem)  ParamTypeDesc(kind, templateMT, paramType));

    if (kind == ELEMENT_TYPE_SZARRAY) {
        CorElementType type = paramType.GetSigCorElementType();
        if (type <= ELEMENT_TYPE_R8) {
            _ASSERTE(g_pPredefinedArrayTypes[type] == 0 || g_pPredefinedArrayTypes[type] == typeHnd.AsArray());
            g_pPredefinedArrayTypes[type] = typeHnd.AsArray();
        }
        else if (paramType.GetMethodTable() == g_pObjectClass) {
            _ASSERTE(g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT] == 0 ||
                     g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT] == typeHnd.AsArray());
            g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT] = typeHnd.AsArray();
        }
        else if (paramType.GetMethodTable() == g_pStringClass) {
            _ASSERTE(g_pPredefinedArrayTypes[ELEMENT_TYPE_STRING] == 0 ||
                     g_pPredefinedArrayTypes[ELEMENT_TYPE_STRING] == typeHnd.AsArray());
            g_pPredefinedArrayTypes[ELEMENT_TYPE_STRING] = typeHnd.AsArray();
        }
    }

#ifdef _DEBUG
    if (CorTypeInfo::IsArray(kind) && ! ((ArrayClass*)(templateMT->GetClass()))->m_szDebugClassName) {
        char pszClassName[MAX_CLASSNAME_LENGTH+1];
        int len = pName->GetFullName(pszClassName, MAX_CLASSNAME_LENGTH);
        BYTE* mem = (BYTE*) paramLoader->GetAssembly()->GetLowFrequencyHeap()->AllocMem(len+1);   

        if (mem) {
            nameSpace = (char*) mem;
            strcpy(nameSpace, pszClassName);

            name = ns::FindSep(nameSpace);
            if (name == 0) {                // No namespace, name is the whole thing
                name = nameSpace;
                nameSpace = "";
            }
            else {
                *name++ = 0;                // First part is namespace, second is the name 
            }

        ArrayClass* arrayClass = (ArrayClass*) templateMT->GetClass();
            arrayClass->m_szDebugClassName = name;
        }
    }
#endif

    // Insert into table of parameterized types
    paramLoader->m_pAvailableParamTypes->InsertValue(&normHandle, typeHnd.AsPtr());
    return(typeHnd);
}

//
// Return a class that is already loaded
// 
TypeHandle ClassLoader::LookupInModule(NameHandle* pName)
{
    mdToken cl = pName->GetTypeToken();
    Module* pModule = pName->GetTypeModule();
    
    _ASSERTE(pModule &&
             (TypeFromToken(cl) == mdtTypeRef || 
              TypeFromToken(cl) == mdtTypeDef ||
              TypeFromToken(cl) == mdtTypeSpec));

    if (TypeFromToken(cl) == mdtTypeDef) 
        return pModule->LookupTypeDef(cl);
    else if (TypeFromToken(cl) == mdtTypeRef) 
        return pModule->LookupTypeRef(cl);
    
    return(TypeHandle());
}
 
//
// Returns the module given an index
//
Module *ClassLoader::LookupModule(DWORD dwIndex)
{
    Module *pModule = m_pHeadModule; 
    
    while (dwIndex > 0)
    {
        _ASSERTE(pModule);
        pModule = pModule->GetNextModule();
        dwIndex--;
    }

    _ASSERTE(pModule);
    return pModule;
}


//
// Free all modules associated with this loader
//
void ClassLoader::FreeModules()
{
    Module *pModule, *pNext;

    for (pModule = m_pHeadModule; pModule; pModule = pNext)
    {
        pNext = pModule->GetNextModule();

        // Have the module free its various tables and some of the EEClass links
        pModule->Destruct();
    }

    m_pHeadModule = NULL;
}
void ClassLoader::FreeArrayClasses()
{
    ArrayClass *pSearch;
    ArrayClass *pNext;

    for (pSearch = m_pHeadArrayClass; pSearch; pSearch = pNext)
    {
        pNext = pSearch->GetNext ();
        pSearch->destruct();
    }
}

#if ZAP_RECORD_LOAD_ORDER
void ClassLoader::CloseLoadOrderLogFiles()
{
    Module *pModule;

    for (pModule = m_pHeadModule; pModule; pModule = pModule->GetNextModule())
    {
        // Have the module write it's load order file
        pModule->CloseLoadOrderLogFile();
    }
}
#endif

void ClassLoader::UnlinkClasses(AppDomain *pDomain)
{
    Module *pModule;

    for (pModule = m_pHeadModule; pModule; pModule = pModule->GetNextModule())
    {
        pModule->UnlinkClasses(pDomain);
    }
}

ClassLoader::~ClassLoader()
{
#ifdef _DEBUG
//     LOG((
//         LF_CLASSLOADER, 
//         INFO3, 
//         "Deleting classloader %x\n"
//         "  >EEClass data:     %10d bytes\n"
//         "  >Classname hash:   %10d bytes\n"
//         "  >FieldDesc data:   %10d bytes\n"
//         "  >MethodDesc data:  %10d bytes\n"
//         "  >Converted sigs:   %10d bytes\n"
//         "  >GCInfo:           %10d bytes\n"
//         "  >Interface maps:   %10d bytes\n"
//         "  >MethodTables:     %10d bytes\n"
//         "  >Vtables:          %10d bytes\n"
//         "  >Static fields:    %10d bytes\n"
//         "# methods:           %10d\n"
//         "# field descs:       %10d\n"
//         "# classes:           %10d\n"
//         "# dup intf slots:    %10d\n"
//         "# array classrefs:   %10d\n"
//         "Array class overhead:%10d bytes\n",
//         this,
//             m_dwEEClassData,
//             m_pAvailableClasses->m_dwDebugMemory,
//             m_dwFieldDescData,
//             m_dwMethodDescData,
//             m_dwDebugConvertedSigSize,
//             m_dwGCSize,
//             m_dwInterfaceMapSize,
//             m_dwMethodTableSize,
//             m_dwVtableData,
//             m_dwStaticFieldData,
//         m_dwDebugMethods,
//         m_dwDebugFieldDescs,
//         m_dwDebugClasses,
//         m_dwDebugDuplicateInterfaceSlots,
//         m_dwDebugArrayClassRefs,
//         m_dwDebugArrayClassSize
//     ));
#endif

#if 0
    if (m_pConverterModule) 
        m_pConverterModule->Release();  
#endif

    FreeArrayClasses();
    FreeModules();

    if (m_pAvailableClasses)
        delete(m_pAvailableClasses);

    if (m_pAvailableParamTypes)
        delete(m_pAvailableParamTypes);

    if (m_pAvailableClassesCaseIns) {
        delete(m_pAvailableClassesCaseIns);
    }

    if (m_pUnresolvedClassHash)
        delete(m_pUnresolvedClassHash);

    if (m_fCreatedCriticalSections)
    {
#if 0
        DeleteCriticalSection(&m_ConverterModuleLock);
#endif
        DeleteCriticalSection(&m_UnresolvedClassLock);
        DeleteCriticalSection(&m_AvailableClassLock);
        DeleteCriticalSection(&m_ModuleListCrst);
    }
}


ClassLoader::ClassLoader()
{
    m_pUnresolvedClassHash          = NULL;
    m_pAvailableClasses             = NULL;
    m_pAvailableParamTypes          = NULL;
    m_fCreatedCriticalSections      = FALSE;
    m_cUnhashedModules              = 0;
            
#if 0
    m_pConverterModule      = NULL;
#endif
    m_pHeadModule           = NULL;
    m_pNext                 = NULL;
    m_pHeadArrayClass       = NULL;

    m_pAvailableClassesCaseIns = NULL;

#ifdef _DEBUG
    m_dwDebugMethods        = 0;
    m_dwDebugFieldDescs     = 0;
    m_dwDebugClasses        = 0;
    m_dwDebugArrayClassRefs = 0;
    m_dwDebugDuplicateInterfaceSlots = 0;
    m_dwDebugArrayClassSize   = 0;
    m_dwDebugConvertedSigSize = 0;
    m_dwGCSize              = 0;
    m_dwInterfaceMapSize    = 0;
    m_dwMethodTableSize     = 0;
    m_dwVtableData          = 0;
    m_dwStaticFieldData     = 0;
    m_dwFieldDescData       = 0;
    m_dwMethodDescData      = 0;
    m_dwEEClassData         = 0;
#endif
}


BOOL ClassLoader::Init()
{
    BOOL    fSuccess = FALSE;

    m_pUnresolvedClassHash = new (GetAssembly()->GetLowFrequencyHeap(), UNRESOLVED_CLASS_HASH_BUCKETS) EEScopeClassHashTable();
    if (m_pUnresolvedClassHash == NULL)
        goto exit;

    m_pAvailableClasses = new (GetAssembly()->GetLowFrequencyHeap(), AVAILABLE_CLASSES_HASH_BUCKETS, this, FALSE /* bCaseInsensitive */) EEClassHashTable();
    if (m_pAvailableClasses == NULL)
        goto exit;

    m_pAvailableParamTypes = new (GetAssembly()->GetLowFrequencyHeap(), AVAILABLE_CLASSES_HASH_BUCKETS) EETypeHashTable();
    if (m_pAvailableParamTypes == NULL)
        goto exit;

    InitializeCriticalSection(&m_UnresolvedClassLock);
#if 0
    InitializeCriticalSection(&m_ConverterModuleLock);
#endif
    InitializeCriticalSection(&m_AvailableClassLock);
    InitializeCriticalSection(&m_ModuleListCrst);
    m_fCreatedCriticalSections = TRUE;

    fSuccess = TRUE;

    CorTypeInfo::CheckConsistancy();
exit:
    return fSuccess;
}

void ClassLoader::Unload()
{
    Module *pModule, *pNext;

    for (pModule = m_pHeadModule; pModule; pModule = pNext)
    {
        pNext = pModule->GetNextModule();

        // Have the module free its various tables and some of the EEClass links
        pModule->Unload();
    }
}


//@todo get a better key
static ULONG GetKeyFromGUID(const GUID *pguid)
{
    ULONG key = *(ULONG *) pguid;

    if (key <= DELETED)
        key = DELETED+1;

    return key;
}

//
// look up the interface class by iid
//
EEClass*    ClassLoader::LookupClass(REFIID iid)
{
    _ASSERTE(GetAssembly());
    _ASSERTE(GetAssembly()->Parent());
    return GetAssembly()->Parent()->LookupClass(iid);
}

// Insert class in the hash table
void    ClassLoader::InsertClassForCLSID(EEClass* pClass)
{
    _ASSERTE(GetAssembly());
    _ASSERTE(GetAssembly()->Parent());
    GetAssembly()->Parent()->InsertClassForCLSID(pClass);
}

//
// Find a class which is in the unresolved class list, and return its entry.
//
LoadingEntry_t *ClassLoader::FindUnresolvedClass(Module *pModule, mdTypeDef cl)
{
    HashDatum   Data;

    if (m_pUnresolvedClassHash->GetValue((mdScope)pModule, cl, &Data) == FALSE)
        return NULL;

    return (LoadingEntry_t *) Data;
}


// Given a class token and a module, look up the class.  Load it if it is not already
// loaded.  Note that the class can be defined in other modules than 'pModule' (that is
// 'cl' can be a typeRef as well as a typeDef
//
TypeHandle ClassLoader::LoadTypeHandle(NameHandle* pName, OBJECTREF *pThrowable,
                                       BOOL dontLoadInMemoryType/*=TRUE*/)
{
    _ASSERTE(IsProtectedByGCFrame(pThrowable));
    if (pThrowable == THROW_ON_ERROR) {
        THROWSCOMPLUSEXCEPTION();   
    }

    SAFE_REQUIRES_N4K_STACK(4);

    IMDInternalImport *pInternalImport;
    TypeHandle  typeHnd;

    // First, attempt to find the class if it is already loaded

    typeHnd = LookupInModule(pName);
    if (!typeHnd.IsNull() && (typeHnd.IsRestored() || !pName->GetRestore()))
        return(typeHnd);

    // We do not allow loading type handle during GC,
    // or by a thread without EEE setup, such as concurrent GC thread.
    //_ASSERTE(!dbgOnly_IsSpecialEEThread());
    //_ASSERTE(!g_pGCHeap->IsGCInProgress() || GetThread() != g_pGCHeap->GetGCThread());
    
    _ASSERTE(pName->GetTypeToken());
    _ASSERTE(pName->GetTypeModule());
    pInternalImport = pName->GetTypeModule()->GetMDImport();

    if (IsNilToken(pName->GetTypeToken()) || !pInternalImport->IsValidToken(pName->GetTypeToken()) )
    {
#ifdef _DEBUG
        LOG((LF_CLASSLOADER, LL_INFO10, "Bogus class token to load: 0x%08x\n", pName->GetTypeToken()));
#endif
        m_pAssembly->PostTypeLoadException("<unknown>", IDS_CLASSLOAD_BADFORMAT, pThrowable);
        return TypeHandle();       // return NULL
    }
	
    if (TypeFromToken(pName->GetTypeToken()) == mdtTypeRef)
    {
        Assembly *pFoundAssembly;
        HRESULT hr = pName->GetTypeModule()->GetAssembly()->FindAssemblyByTypeRef(pName, &pFoundAssembly, pThrowable);
        if (hr == CLDB_S_NULL) {
            // Try manifest file for nil-scoped TypeRefs
            pFoundAssembly = pName->GetTypeModule()->GetAssembly();
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            // Not in my module, have to look it up by name 
            LPCUTF8 pszNameSpace;
            LPCUTF8 pszClassName;
            pInternalImport->GetNameOfTypeRef(pName->GetTypeToken(), &pszNameSpace, &pszClassName);
            pName->SetName(pszNameSpace, pszClassName);
            
            typeHnd = pFoundAssembly->GetLoader()->FindTypeHandle(pName, pThrowable);

            if (!typeHnd.IsNull()) // Add it to the rid map  
                pName->GetTypeModule()->StoreTypeRef(pName->GetTypeToken(), typeHnd);
        }

        return TypeHandle(typeHnd.AsPtr());
    }
    else if (TypeFromToken(pName->GetTypeToken()) == mdtTypeSpec)
    {
        ULONG cSig;
        PCCOR_SIGNATURE pSig;

        pInternalImport->GetTypeSpecFromToken(pName->GetTypeToken(), &pSig, &cSig);
        SigPointer sigptr(pSig);
        return sigptr.GetTypeHandle(pName->GetTypeModule(), pThrowable);
    }   
    _ASSERTE(TypeFromToken(pName->GetTypeToken()) == mdtTypeDef);
    

    // At this point, we need more stack
    {
        REQUIRES_16K_STACK; //@stack can we remove this?


        // *****************************************************************************
        //
        //             Important invariant:
        //
        // The rule here is that we never go to LoadTypeHandle if a Find should succeed.
        // This is vital, because otherwise a stack crawl will open up opportunities for
        // GC.  Since operations like setting up a GCFrame will trigger a crawl in stress
        // mode, a GC at that point would be disastrous.  We can't assert this, because
        // of race conditions.  (In other words, the type could suddently be find-able
        // because another thread loaded it while we were in this method.

        // Not found - try to load it unless we are told not to

        if ( (pName->GetTypeToken() == pName->GetTokenNotToLoad()) ||
             (pName->GetTokenNotToLoad() == tdAllTypes) ) {
            typeHnd = TypeHandle();
            m_pAssembly->PostTypeLoadException(pInternalImport,
                                               pName->GetTypeToken(),
                                               IDS_CLASSLOAD_GENERIC,
                                               pThrowable);
        }
        else if (pName->GetTypeModule()->IsInMemory()) {
 
            // Don't try to load types that are not in available table, when this
            // is an in-memory module.  Raise the type-resolve event instead.
            AppDomain* pDomain = SystemDomain::GetCurrentDomain();
            _ASSERTE(pDomain);
            typeHnd = TypeHandle();

            LPUTF8 pszFullName;
            LPCUTF8 className;
            LPCUTF8 nameSpace;
            pInternalImport->GetNameOfTypeDef(pName->GetTypeToken(), &className, &nameSpace);
            MAKE_FULL_PATH_ON_STACK_UTF8(pszFullName, 
                                         nameSpace,
                                         className);

            // Avoid infinite recursion
            if (pName->GetTokenNotToLoad() != tdAllAssemblies) {
                Assembly *pAssembly = pDomain->RaiseTypeResolveEvent(pszFullName, pThrowable);
                if (pAssembly) {
                    pName->SetName(nameSpace, className);
                    pName->SetTokenNotToLoad(tdAllAssemblies);
                    typeHnd = pAssembly->LookupTypeHandle(pName, pThrowable);
                }
            }

            if (typeHnd.IsNull())
                m_pAssembly->PostTypeLoadException(pszFullName,
                                                   IDS_CLASSLOAD_GENERIC,
                                                   pThrowable);
        }
        else {
            BEGIN_ENSURE_PREEMPTIVE_GC();
            typeHnd = LoadTypeHandle(pName->GetTypeModule(), pName->GetTypeToken(), pThrowable);
            END_ENSURE_PREEMPTIVE_GC();
        }
    }

    return typeHnd;
}

HRESULT ClassLoader::GetEnclosingClass(IMDInternalImport *pInternalImport, Module *pModule, mdTypeDef cl, mdTypeDef *tdEnclosing, OBJECTREF *pThrowable)
{
    _ASSERTE(tdEnclosing);
    *tdEnclosing = mdTypeDefNil;

    DWORD dwMemberAccess = 0;

    HRESULT hr = pInternalImport->GetNestedClassProps(cl, tdEnclosing);

    if (FAILED(hr)) {
        return (hr == CLDB_E_RECORD_NOTFOUND) ? S_OK : hr;
    }

    if (TypeFromToken(*tdEnclosing) != mdtTypeDef) {
        m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_ENCLOSING, pThrowable);
        return COR_E_TYPELOAD;
    }

    return S_OK;
}

HRESULT ClassLoader::LoadParent(IMDInternalImport *pInternalImport, Module *pModule, mdToken cl, EEClass** ppClass, OBJECTREF *pThrowable)
{

    _ASSERTE(ppClass);

    mdTypeRef   crExtends;
    EEClass *   pParentClass = NULL;
    DWORD       dwAttrClass;

    // Initialize the return value;
    *ppClass = NULL;

    // Now load all dependencies of this class
    pInternalImport->GetTypeDefProps(
        cl, 
        &dwAttrClass, // AttrClass
        &crExtends
    );

    if (RidFromToken(crExtends) == mdTokenNil)
    {
//          if(cl == COR_GLOBAL_PARENT_TOKEN)
//              pParentClass = g_pObjectClass->GetClass();
    }
    else
    {
        // Load and resolve parent class
        NameHandle pParent(pModule, crExtends);
        pParentClass = LoadTypeHandle(&pParent, pThrowable).GetClass();

        if (pParentClass == NULL)
        {
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_PARENTNULL, pThrowable);
            return COR_E_TYPELOAD;
        }

        // cannot inherit from an interface
        if (pParentClass->IsInterface())
        {
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_PARENTINTERFACE, pThrowable);
            return COR_E_TYPELOAD;
        }

        if (IsTdInterface(dwAttrClass))
        {
            // Interfaces must extend from Object
            if (! pParentClass->IsObjectClass())
            {
                m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_INTERFACEOBJECT, pThrowable);
                return COR_E_TYPELOAD;
            }
        }
    }

    *ppClass = pParentClass;
    return S_OK;
}


TypeHandle ClassLoader::LoadTypeHandle(Module *pModule, mdTypeDef cl, OBJECTREF *pThrowable,
                                       BOOL dontRestoreType)
{
    HRESULT hr = E_FAIL;
    EEClass *   pClass = NULL;
    LoadingEntry_t  *pLoadingEntry;
    DWORD       rid;
    BOOL        fHoldingUnresolvedClassLock = FALSE;
    BOOL        fHoldingLoadingEntryLock = FALSE;
    IMDInternalImport* pInternalImport;
    TypeHandle  typeHnd;

    STRESS_LOG2(LF_CLASSLOADER,  LL_INFO1000, "LoadTypeHandle: Loading Class from Module %p token %x)\n", pModule, cl);

    _ASSERTE(!GetThread()->PreemptiveGCDisabled());

    pInternalImport = pModule->GetMDImport();
    rid = RidFromToken(cl);
    if(!((TypeFromToken(cl)==mdtTypeDef) && rid && pInternalImport->IsValidToken(cl)))
    {
#ifdef _DEBUG
        LOG((LF_CLASSLOADER, LL_INFO10, "Bogus class token to load: 0x%08x\n", cl));
#endif
        m_pAssembly->PostTypeLoadException("<unknown>", IDS_CLASSLOAD_BADFORMAT, pThrowable);
        return TypeHandle();       // return NULL
    }


#ifdef _DEBUG
    if (pThrowable == THROW_ON_ERROR) {
        THROWSCOMPLUSEXCEPTION();   
    }
    
    LPCUTF8 className;
    LPCUTF8 nameSpace;
    pInternalImport->GetNameOfTypeDef(cl, &className, &nameSpace);
    if (g_pConfig->ShouldBreakOnClassLoad(className))
        _ASSERTE(!"BreakOnClassLoad");
#endif _DEBUG

retry:
    CRITICAL_SECTION_HOLDER_BEGIN(unresolvedClassLock, &m_UnresolvedClassLock);
    unresolvedClassLock.Enter();

    // Is it in the hash of classes currently being loaded?
    pLoadingEntry = FindUnresolvedClass(pModule, cl);

    CRITICAL_SECTION_HOLDER_BEGIN(loadingEntryLock, 0);

    if (pLoadingEntry)
    {
        loadingEntryLock.SetCriticalSection(&pLoadingEntry->m_CriticalSection);

        // Add ourselves as a thread waiting for the class to load
        pLoadingEntry->m_dwWaitCount++;

        // It is in the hash, which means that another thread is waiting for it (or that we are 
        // already loading this class on this thread, which should never happen, since that implies
        // a recursive dependency).
        unresolvedClassLock.Leave();

        // Wait for class to be loaded by another thread
        loadingEntryLock.Enter();
        loadingEntryLock.Leave();
       
        // Result of other thread loading the class
        hr = pLoadingEntry->m_hrResult;

        // Get a pointer to the EEClass being loaded

        pClass = pLoadingEntry->m_pClass;

        // Get any exception that was thrown
        if (FAILED (hr)) {
#ifdef _DEBUG
            LOG((LF_CLASSLOADER, LL_INFO10, "Failed to loaded in other entry: %x\n", hr));
#endif
            Thread* pThread = GetThread();
            if (pThrowableAvailable(pThrowable))
            {
                pThread->DisablePreemptiveGC();
                *pThrowable = pLoadingEntry->GetErrorObject();
                pThread->EnablePreemptiveGC();
            }
        }
#ifdef _DEBUG
        // If this happens, someone somewhere has screwed things up mightily
        _ASSERTE(hr != 0xCDCDCDCD);
#endif

        // Enter the global lock
        unresolvedClassLock.Enter();

        // If we were the last thread waiting for this class, delete the LoadingEntry
        if (--pLoadingEntry->m_dwWaitCount == 0)
            delete(pLoadingEntry);

        unresolvedClassLock.Leave();

        if (SUCCEEDED(hr))
            return TypeHandle(pClass->GetMethodTable());
        else if (hr == E_ABORT) {
#ifdef _DEBUG
            LOG((LF_CLASSLOADER, LL_INFO10, "need to retry LoadTypeHandle: %x\n", hr));
#endif
            goto retry;
        }
        else {
            // Will only post new exception if pThrowable is NULL.
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
            return TypeHandle();       // return NULL
        }
    }

    COMPLUS_TRY {

        _ASSERTE(unresolvedClassLock.IsHeld());

        // The class was not being loaded.  However, it may have already been loaded after our
        // first FindTypeHandle() and before taking the lock.
        NameHandle name(pModule, cl);
        name.SetRestore(!dontRestoreType);
        typeHnd = LookupInModule(&name);
        if (!typeHnd.IsNull() && (typeHnd.IsRestored() || dontRestoreType))
        {
            // Found it, leave global lock
            unresolvedClassLock.Leave();
            return typeHnd;
        }

        // It was not loaded, and it is not being loaded, so we must load it.  Create a new LoadingEntry.
        pLoadingEntry = LoadingEntry_t::newEntry();
        if (pLoadingEntry == NULL)
        {
            // Error, leave global lock
            unresolvedClassLock.Leave();
            PostOutOfMemoryException(pThrowable);
            return TypeHandle();       // return NULL
        }

        loadingEntryLock.SetCriticalSection(&pLoadingEntry->m_CriticalSection);
        
        // Add LoadingEntry to hash table of unresolved classes
        m_pUnresolvedClassHash->InsertValue((mdScope)pModule, cl, (HashDatum) pLoadingEntry );

        TRIGGERS_TYPELOAD();

        // Enter the lock on our class, so that all threads waiting for it will now block
        loadingEntryLock.Enter();

        // Leave the global lock, so that other threads may now start waiting on our class's lock
        unresolvedClassLock.Leave();

        if (!typeHnd.IsNull()) {
            // RESTORE
            _ASSERTE(typeHnd.IsUnsharedMT());
            pClass = typeHnd.GetClass();
            pClass->Restore();
            hr = S_OK;
        }
        else {
            hr = LoadTypeHandleFromToken(pModule, cl, &pClass, pThrowable);
        }


#ifdef PROFILING_SUPPORTED
        if (SUCCEEDED(hr))
        {
            // Record load of the class for the profiler, whether successful or not.
            if (CORProfilerTrackClasses())
            {
                g_profControlBlock.pProfInterface->ClassLoadStarted((ThreadID) GetThread(),
                                                                    (ClassID) TypeHandle(pClass).AsPtr());
            }

            // Record load of the class for the profiler, whether successful or not.
            if (CORProfilerTrackClasses())
            {
                g_profControlBlock.pProfInterface->ClassLoadFinished((ThreadID) GetThread(),
                                                                     (ClassID) TypeHandle(pClass).AsPtr(),
                                                                     SUCCEEDED(hr) ? S_OK : hr);
            }
        }
#endif //PROFILING_SUPPORTED


        // Enter the global lock
        unresolvedClassLock.Enter();

        // Unlink this class from the unresolved class list
        m_pUnresolvedClassHash->DeleteValue((mdScope)pModule, cl );

        if (--pLoadingEntry->m_dwWaitCount == 0)
        {
            loadingEntryLock.Leave();
            delete(pLoadingEntry);
        }
        else
        {
            // At least one other thread is waiting for this class, so set result code
            pLoadingEntry->m_pClass = pClass;
            pLoadingEntry->m_hrResult = hr;
            _ASSERTE (SUCCEEDED(hr) || *pThrowable != NULL);
            if (FAILED (hr)) 
            {
                Thread* pThread = GetThread();
                pThread->DisablePreemptiveGC();
                pLoadingEntry->SetErrorObject(*pThrowable);
                pThread->EnablePreemptiveGC();

                LOG((LF_CLASSLOADER, LL_INFO10, "Setting entry to failed: %x, %0x (class)\n", hr, pClass));
            }
            // Unblock other threads so that they can see the result code
            loadingEntryLock.Leave();
        }

        // Leave the global lock
        unresolvedClassLock.Leave();

    } COMPLUS_CATCH {

        LOG((LF_CLASSLOADER, LL_INFO10, "Caught an exception loading: %x, %0x (Module)\n", cl, pModule));

        Thread* pThread = GetThread();
        pThread->DisablePreemptiveGC();

        OBJECTREF throwable = GETTHROWABLE();

        // Some exceptions shouldn't cause other threads to fail.  We set
        // hr to E_ABORT to indicate this state.
        if (IsAsyncThreadException(&throwable)
            || IsExceptionOfType(kExecutionEngineException, &throwable))
            hr = E_ABORT;
        else
            hr = COR_E_TYPELOAD;

        // Release the global lock.
        if (unresolvedClassLock.IsHeld())
            unresolvedClassLock.Leave();

        // Fix up the loading entry.
        if (loadingEntryLock.IsHeld()) {
            unresolvedClassLock.Enter();
            _ASSERTE(pLoadingEntry->m_dwWaitCount > 0);

            // Unlink this class from the unresolved class list
            m_pUnresolvedClassHash->DeleteValue((mdScope)pModule, cl );

            if (--pLoadingEntry->m_dwWaitCount == 0)
            {
                loadingEntryLock.Leave();
                 delete(pLoadingEntry);
            }
            else
            {
                // At least one other thread is waiting for this class, so set result code
                pLoadingEntry->m_pClass = NULL;
                pLoadingEntry->m_hrResult = COR_E_TYPELOAD;
                pLoadingEntry->SetErrorObject(throwable);
                // Unblock other threads so that they can see the result code
                loadingEntryLock.Leave();
            }
            unresolvedClassLock.Leave();
        }

        UpdateThrowable(pThrowable);

        // Some exceptions should never be caught.
        if (IsUncatchable(pThrowable)) {
           DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
           COMPlusRareRethrow();
        }
       pThread->EnablePreemptiveGC();
    } COMPLUS_END_CATCH

    _ASSERTE(!unresolvedClassLock.IsHeld());
    _ASSERTE(!loadingEntryLock.IsHeld());

    CRITICAL_SECTION_HOLDER_END(loadingEntryLock);
    CRITICAL_SECTION_HOLDER_END(unresolvedClassLock);

    if (SUCCEEDED(hr)) {

        LOG((LF_CLASSLOADER, LL_INFO100, "Successfully loaded class %s\n", pClass->m_szDebugClassName));

#ifdef DEBUGGING_SUPPORTED
        if (CORDebuggerAttached())
            pClass->NotifyDebuggerLoad();
#endif // DEBUGGING_SUPPORTED

#if defined(ENABLE_PERF_COUNTERS)
        GetGlobalPerfCounters().m_Loading.cClassesLoaded ++;
        GetPrivatePerfCounters().m_Loading.cClassesLoaded ++;
#endif

        pClass->GetModule()->LogClassLoad(pClass);

        return TypeHandle(pClass->GetMethodTable());

    } else {
        if (hr == E_OUTOFMEMORY)
            PostOutOfMemoryException(pThrowable);
        else
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);

        LOG((LF_CLASSLOADER, LL_INFO10, "Returning null type handle for: %x, %0x (Module)\n", cl, pModule));

        return TypeHandle();       // return NULL
    }
}


// This service is called for normal classes -- and for the pseudo class we invent to
// hold the module's public members.
HRESULT ClassLoader::LoadTypeHandleFromToken(Module *pModule, mdTypeDef cl, EEClass** ppClass, OBJECTREF *pThrowable)
{
    HRESULT hr = S_OK;
    EEClass *pClass;
    EEClass *pParentClass;
    mdTypeDef tdEnclosing = mdTypeDefNil;
    DWORD       cInterfaces;
    BuildingInterfaceInfo_t *pInterfaceBuildInfo = NULL;
    IMDInternalImport* pInternalImport;
    LayoutRawFieldInfo *pLayoutRawFieldInfos = NULL;
    HENUMInternal   hEnumInterfaceImpl;
    mdInterfaceImpl ii;

    pInternalImport = pModule->GetMDImport();

    _ASSERTE(ppClass);
    *ppClass = NULL;

    DWORD rid = RidFromToken(cl);
    if ((rid==0) || (rid==0x00FFFFFF) || (rid > pInternalImport->GetCountWithTokenKind(mdtTypeDef) + 1))
    {
        m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
        return COR_E_TYPELOAD;
    }

#ifdef _IA64_
    //
    // @TODO_IA64: this needs to be put back in.  the reason it's gone is that
    // we end up trying to load mscorlib which we don't have yet
    //
    pParentClass = NULL;
#else // !_IA64_
    // @TODO: CTS, we may not need to disable preemptiveGC before we getting the parent.
    hr = LoadParent(pInternalImport, pModule, cl, &pParentClass, pThrowable);
    if(FAILED(hr)) return hr;
#endif // !_IA64_
    
    if (pParentClass) {
            // Since methods on System.Array assume the layout of arrays, we can not allow
            // subclassing of arrays, it is sealed from the users point of view.  
        if (IsTdSealed(pParentClass->GetAttrClass()) || pParentClass->GetMethodTable() == g_pArrayClass) {
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_SEALEDPARENT, pThrowable);
            return COR_E_TYPELOAD;
        }
    }

    hr = GetEnclosingClass(pInternalImport, pModule, cl, &tdEnclosing, pThrowable);
    if(FAILED(hr)) return hr;

    BYTE nstructPackingSize, nstructNLT;
    BOOL fExplicitOffsets;
    BOOL fIsBlob;
    fIsBlob = FALSE;
    hr = HasLayoutMetadata(pInternalImport, cl, pParentClass, &nstructPackingSize, &nstructNLT, &fExplicitOffsets, &fIsBlob);
    if(FAILED(hr)) 
    {
        m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
        return hr;
    }

    BOOL        fHasLayout;
    fHasLayout = (hr == S_OK);

    BOOL        fIsEnum;
    fIsEnum = g_pEnumClass != NULL && pParentClass == g_pEnumClass->GetClass();

    BOOL        fIsAnyDelegateClass = pParentClass && pParentClass->IsAnyDelegateExact();

    // Create a EEClass entry for it, filling out a few fields, such as the parent class token.
    hr = EEClass::CreateClass(pModule, cl, fHasLayout, fIsAnyDelegateClass, fIsBlob, fIsEnum, &pClass);
    if(FAILED(hr)) 
        return hr;

    pClass->SetParentClass (pParentClass);  
    if (pParentClass)
    {
        if (pParentClass->IsMultiDelegateExact()) 
            pClass->SetIsMultiDelegate();
        else if (pParentClass->IsSingleDelegateExact()) 
        {
                // We don't want MultiCastDelegate class itself to return true for IsSingleCastDelegate
                // rather than do a name match, we look for the fact that it is not sealed
            if (pModule->GetAssembly() != SystemDomain::SystemAssembly())
            {
                BAD_FORMAT_ASSERT(!"Inheriting directly form Delegate class illegal");
                m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
                return COR_E_TYPELOAD;

            }
#ifdef _DEBUG
            else 
            {
                // Only MultiCastDelegate should inherit from Delegate
                LPCUTF8 className;
                LPCUTF8 nameSpace;
                pInternalImport->GetNameOfTypeDef(cl, &className, &nameSpace);
                _ASSERTE(strcmp(className, "MulticastDelegate") == 0);
            }
#endif

            // Note we do not allow single cast delegates anymore
        }

        if (pClass->IsAnyDelegateClass() &&!IsTdSealed(pClass->GetAttrClass())) 
        {
            BAD_FORMAT_ASSERT(!"Delegate class not sealed");
            m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
            return COR_E_TYPELOAD;
        }
    }

    // Set it so if a failure happens it can be deleted
    *ppClass = pClass;

    if (tdEnclosing != mdTypeDefNil) {
        pClass->SetIsNested();
        _ASSERTE(IsTdNested(pClass->GetProtection()));
    }
    else if(IsTdNested(pClass->GetProtection()))
    {
        m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
        return COR_E_TYPELOAD;
    }

    // Now load all the interfaces
    hr = pInternalImport->EnumInit(mdtInterfaceImpl, cl, &hEnumInterfaceImpl);
    if (FAILED(hr)) return hr;

    cInterfaces = pInternalImport->EnumGetCount(&hEnumInterfaceImpl);

    if (cInterfaces != 0)
    {
        EE_TRY_FOR_FINALLY {
        DWORD i;

        // Allocate the BuildingInterfaceList table
        pInterfaceBuildInfo = (BuildingInterfaceInfo_t *) _alloca(cInterfaces * sizeof(BuildingInterfaceInfo_t));
        
        for (i = 0; pInternalImport->EnumNext(&hEnumInterfaceImpl, &ii); i++)
        {
            mdTypeRef crInterface;
            mdToken   crIntType;

            // Get properties on this interface
            crInterface = pInternalImport->GetTypeOfInterfaceImpl(ii);
            // validate the token
            crIntType = RidFromToken(crInterface)&&pInternalImport->IsValidToken(crInterface) ?
                TypeFromToken(crInterface) : 0;
            switch(crIntType)
            {
                case mdtTypeDef:
                case mdtTypeRef:
                case mdtTypeSpec:
                    break;
                default:
                {
                    m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_INTERFACENULL, pThrowable);
                    return COR_E_TYPELOAD;
                }
            }

            // Load and resolve interface
            NameHandle myInterface(pModule, crInterface);
            pInterfaceBuildInfo[i].m_pClass = LoadTypeHandle(&myInterface, pThrowable).GetClass();
            if (pInterfaceBuildInfo[i].m_pClass == NULL)
            {
                m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_INTERFACENULL, pThrowable);
                return COR_E_TYPELOAD;
            }

            // Ensure this is an interface
            if (pInterfaceBuildInfo[i].m_pClass->IsInterface() == FALSE)
            {
                m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_NOTINTERFACE, pThrowable);
                return COR_E_TYPELOAD;
            }
        }
            _ASSERTE(i == cInterfaces);
        }
        EE_FINALLY {
        pInternalImport->EnumClose(&hEnumInterfaceImpl);
        } EE_END_FINALLY;
    }

    pClass->SetNumInterfaces ((WORD) cInterfaces);

    if (fHasLayout)
    {
        ULONG           cFields;
        HENUMInternal   hEnumField;
        hr = pInternalImport->EnumInit(mdtFieldDef, cl, &hEnumField);
        if (FAILED(hr)) return hr;

        cFields = pInternalImport->EnumGetCount(&hEnumField);

        pLayoutRawFieldInfos = (LayoutRawFieldInfo*)_alloca((1+cFields) * sizeof(LayoutRawFieldInfo));
        // MD Val check: PackingSize
        if((nstructPackingSize > 128) || 
           (nstructPackingSize & (nstructPackingSize-1)))
        {
            BAD_FORMAT_ASSERT(!"ClassLayout:Invalid PackingSize");
            if (pThrowable) m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
            return COR_E_TYPELOAD;
        }

        // @perf: High frequency or low frequency heap?
        hr = CollectLayoutFieldMetadata(cl, 
                                        nstructPackingSize, 
                                        nstructNLT, 
                                        fExplicitOffsets,
                                        pClass->GetParentClass(), 
                                        cFields, 
                                        &hEnumField, 
                                        pModule, 
                                        &(((LayoutEEClass *) pClass)->m_LayoutInfo), 
                                        pLayoutRawFieldInfos,
                                        pThrowable);
        pInternalImport->EnumClose(&hEnumField);
        if (FAILED(hr)) return hr;
    }


    // Resolve this class, given that we know now that all of its dependencies are loaded and resolved.  
    hr = pClass->BuildMethodTable(pModule, cl, pInterfaceBuildInfo, pLayoutRawFieldInfos, pThrowable);

    // Be very careful about putting more code here. The class is already accessable by other threads
    // Therefore, pClass should not be modified after BuildMethodTable.

    // This is legal, since it only affects perf.
    if (SUCCEEDED(hr) && pParentClass)
        pParentClass->NoticeSubtype(pClass);

    return hr;
}

TypeHandle ClassLoader::FindArrayForElem(TypeHandle elemType, CorElementType arrayKind, unsigned rank, OBJECTREF *pThrowable) {

    // Try finding it in our cache of primitive SD arrays
    if (arrayKind == ELEMENT_TYPE_SZARRAY) {
        CorElementType type = elemType.GetSigCorElementType();
        if (type <= ELEMENT_TYPE_R8) {
            ArrayTypeDesc* typeDesc = g_pPredefinedArrayTypes[type];
            if (typeDesc != 0)
                return(TypeHandle(typeDesc));
        }
        else if (elemType.AsMethodTable() == g_pObjectClass) {
            // Code duplicated because Object[]'s SigCorElementType is E_T_CLASS, not OBJECT
            ArrayTypeDesc* typeDesc = g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT];
            if (typeDesc != 0)
                return(TypeHandle(typeDesc));
        }
        else if (elemType.AsMethodTable() == g_pStringClass) {
            // Code duplicated because String[]'s SigCorElementType is E_T_CLASS, not STRING
            ArrayTypeDesc* typeDesc = g_pPredefinedArrayTypes[ELEMENT_TYPE_STRING];
            if (typeDesc != 0)
                return(TypeHandle(typeDesc));
        }
        rank = 1;
    }
    NameHandle arrayName(arrayKind, elemType, rank);
    return elemType.GetModule()->GetClassLoader()->FindTypeHandle(&arrayName, pThrowable);
}

//
// Load the object class. This is done separately so security can be set
void ClassLoader::SetBaseSystemSecurity()
{
    GetAssembly()->GetSecurityDescriptor()->SetSystemClasses();
}

HRESULT ClassLoader::AddAvailableClassDontHaveLock(Module *pModule, DWORD dwModuleIndex, mdTypeDef classdef)
{
    CLR_CRITICAL_SECTION(&m_AvailableClassLock);
    HRESULT hr = AddAvailableClassHaveLock(pModule, dwModuleIndex, classdef);
    return hr;
}


HashDatum ClassLoader::CompressModuleIndexAndClassDef(DWORD dwModuleIndex, mdToken cl)
{
    //
    // X = discriminator (vs. EEClass*)
    // V = discriminator for manifest reference vs
    //     module reference.
    // ? = not used
    //
    // if V is 1 then the layout looks like
    // 10987654321098765432109876543210
    // V???CCCCCCCCCCCCCCCCCCCCCCCCCCCX
    // Mask of the manifest tokens upper 4 bits because
    // it is guaranteed to be 6.
    //
    // if V is 0 then the layout looks like
    // 10987654321098765432109876543210
    // 3 2         1        
    // VmmmmmmmmmCCCCCCCCCCCCCCCCCCCCCX
    // 
    if(dwModuleIndex == -1) {
        _ASSERTE(TypeFromToken(cl) == mdtExportedType);
            
        HashDatum dl = (HashDatum)((size_t)(1 << 31) | (((size_t)cl & 0x0fffffff) << 1) | 1); // mask of the token type
        return dl;
    }
    else {
        _ASSERTE(dwModuleIndex < 0x1ff);
        _ASSERTE((cl & 0x003FFFFF) < MAX_CLASSES_PER_MODULE);
        return (HashDatum) (((size_t)dwModuleIndex << 22) | ((cl & 0x003FFFFF) << 1) | 1);
    }
}

HRESULT ClassLoader::UncompressModuleAndClassDef(HashDatum Data, mdToken tokenNotToLoad,
                                                 Module **ppModule, mdTypeDef *pCL,
                                                 mdExportedType *pmdFoundExportedType,
                                                 OBJECTREF* pThrowable)
{
    HRESULT hr = S_OK;
    DWORD dwData = (DWORD)(size_t)Data; // @TODO WIN64 - Pointer Truncation
    _ASSERTE((dwData & 1) == 1);
    _ASSERTE(pCL);
    _ASSERTE(ppModule);
    if(dwData & (1 << 31)) {
        *pmdFoundExportedType = ((dwData >> 1) & ((1 << 28) -1 )) | mdtExportedType;
        hr = m_pAssembly->FindModuleByExportedType(*pmdFoundExportedType, tokenNotToLoad,
                                                   mdTypeDefNil, ppModule, pCL, pThrowable);
    }
    else {
        //@TODO: this code assumes that a token fits into 20 bits!
        //  THIS ASSUMPTION VIOLATES THE ARCHITECTURE OF THE METADATA.
        //  IT HAS BEEN TRUE TO DATE, BUT TOKENS ARE OPAQUE!
        *pCL = ((dwData >> 1) & ((1 << 21)-1)) | mdtTypeDef;
        *ppModule = LookupModule(dwData >> 22);
        *pmdFoundExportedType = NULL;
    }       
    return hr;
}

mdToken ClassLoader::UncompressModuleAndClassDef(HashDatum Data)
{
    DWORD dwData = (DWORD)(size_t) Data; // @TODO WIN64 - Pointer Truncation
    _ASSERTE((dwData & 1) == 1);

    if(dwData & (1 << 31))
        return ((dwData >> 1) & ((1 << 28) -1 )) | mdtExportedType;
    else
        //@TODO: this code assumes that a token fits into 20 bits!
        //  THIS ASSUMPTION VIOLATES THE ARCHITECTURE OF THE METADATA.
        //  IT HAS BEEN TRUE TO DATE, BUT TOKENS ARE OPAQUE!
        return ((dwData >> 1) & ((1 << 21)-1)) | mdtTypeDef;
}


//
// This routine must be single threaded!  The reason is that there are situations which allow
// the same class name to have two different mdTypeDef tokens (for example, we load two different DLLs
// simultaneously, and they have some common class files, or we converte the same class file
// simultaneously on two threads).  The problem is that we do not want to overwrite the old
// <classname> -> pModule mapping with the new one, because this may cause identity problems.
//
// This routine assumes you already have the lock.  Use AddAvailableClassDontHaveLock() if you
// don't have it.
//
HRESULT ClassLoader::AddAvailableClassHaveLock(Module *pModule, DWORD dwModuleIndex, mdTypeDef classdef)
{
    LPCUTF8        pszName;
    LPCUTF8        pszNameSpace;
    HashDatum      ThrowawayData;
    EEClassHashEntry_t *pBucket;


    pModule->GetMDImport()->GetNameOfTypeDef(classdef, &pszName, &pszNameSpace);

    mdTypeDef      enclosing;
    if (SUCCEEDED(pModule->GetMDImport()->GetNestedClassProps(classdef, &enclosing))) {
        // nested class
        LPCUTF8 pszEnclosingName;
        LPCUTF8 pszEnclosingNameSpace;
        mdTypeDef enclEnclosing;

        // Find this type's encloser's entry in the available table.
        // We'll save a pointer to it in the new hash entry for this type.
        BOOL fNestedEncl = SUCCEEDED(pModule->GetMDImport()->GetNestedClassProps(enclosing, &enclEnclosing));

        pModule->GetMDImport()->GetNameOfTypeDef(enclosing, &pszEnclosingName, &pszEnclosingNameSpace);
        if ((pBucket = m_pAvailableClasses->GetValue(pszEnclosingNameSpace,
                                                    pszEnclosingName,
                                                    &ThrowawayData,
                                                    fNestedEncl)) != NULL) {
            if (fNestedEncl) {
                // Find entry for enclosing class - NOTE, this assumes that the
                // enclosing class's TypeDef or ExportedType was inserted previously,
                // which assumes that, when enuming TD's, we get the enclosing class first
                while ((!CompareNestedEntryWithTypeDef(pModule->GetMDImport(),
                                                       enclEnclosing,
                                                       pBucket->pEncloser)) &&
                       (pBucket = m_pAvailableClasses->FindNextNestedClass(pszEnclosingNameSpace,
                                                                           pszEnclosingName,
                                                                           &ThrowawayData,
                                                                           pBucket)) != NULL);
            }
        }

        if (!pBucket) {
            STRESS_ASSERT(0);   // @TODO remove after bug 93333 is fixed
            BAD_FORMAT_ASSERT(!"enclosing type not found");
            return COR_E_BADIMAGEFORMAT;  //Enclosing type not found in hash table
        }

        // In this hash table, if the lower bit is set, it means a Module, otherwise it means EEClass*
        ThrowawayData = CompressModuleIndexAndClassDef(dwModuleIndex, classdef);
        if (!InsertValue(pszNameSpace, pszName, ThrowawayData, pBucket))
            return E_OUTOFMEMORY;
    }
    else
    {
        // Don't add duplicate top-level classes.  Top-level classes are
        // added to the beginning of the bucket, while nested classes are
        // added to the end.  So, a duplicate top-level class could hide
        // the previous type's EEClass* entry in the hash table.
        EEClassHashEntry_t *pEntry;

        // In this hash table, if the lower bit is set, it means a Module, otherwise it means EEClass*
        ThrowawayData = CompressModuleIndexAndClassDef(dwModuleIndex, classdef);
        pBucket = NULL;
        BOOL bFound = FALSE;
        // ThrowawayData is an IN OUT param. Going in its the pointer to the new value if the entry needs 
        // to be inserted. The OUT param points to the value stored in the hash table.
        if ((pEntry = m_pAvailableClasses->InsertValueIfNotFound(pszNameSpace, pszName, &ThrowawayData, pBucket, FALSE, &bFound)) != NULL) {
            if (bFound) {
                if ((size_t)ThrowawayData & 0x1) {
                    if((size_t)ThrowawayData & (1 << 31)) {
                        // it's a ComType - check the 'already seen' bit and if on reprot a class loading exception
                        // otherwise set it 
                        if ((size_t)ThrowawayData & 0x40000000) {
                            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
                            BAD_FORMAT_ASSERT(!"Bad Compressed Class Info");
                            return COR_E_BADIMAGEFORMAT;
                        }
                        else {
                            ThrowawayData = (HashDatum)((size_t)ThrowawayData | 0x40000000);
                            m_pAvailableClasses->UpdateValue(pEntry, &ThrowawayData);
                        }
                }
                else {
                    //@TODO: this code assumes that a token fits into 20 bits!
                    //  THIS ASSUMPTION VIOLATES THE ARCHITECTURE OF THE METADATA.
                    //  IT HAS BEEN TRUE TO DATE, BUT TOKENS ARE OPAQUE!
                    // Edit and Continue may enter this function trying to add the same typedef, if that is the case
                    // don't give any error
                    // Given that the below code path returns CORDBG_E_ENC_RE_ADD_CLASS, the Win64
                    // people ought to ask the ClassLoader people if we still even need this if statement.
                    if (pModule != LookupModule((DWORD)(size_t)ThrowawayData >> 22)) // @TODO WIN64 - Pointer Truncation
                        return CORDBG_E_ENC_RE_ADD_CLASS;
                    else
                        return S_OK;
                }       
            }
            else {
                // When the value in the hash table is a MethodTable, the class and the module have been loaded already,
                // we can get here only if a second module has a non public class with the same name
                // If we're being told to re-load this b/c of EnC, ignore it, just like above

                // We'd like to be able to assert this, but it'll trigger on EnC, even
                // though EnC may attemp to "re-add" a previously loaded class.
                //_ASSERTE(((MethodTable*)ThrowawayData)->GetModule() != pModule);
                return CORDBG_E_ENC_RE_ADD_CLASS;
            }
             }
           else
           {
                //If we're keeping a table for case-insensitive lookup, keep that up to date
                if (m_pAvailableClassesCaseIns && pEntry) {
                    LPUTF8 pszLowerCaseNS;
                    LPUTF8 pszLowerCaseName;
                    //What do we want to do if we can't create a key?
                    if ((!CreateCanonicallyCasedKey(pszNameSpace, pszName, &pszLowerCaseNS, &pszLowerCaseName)) ||
                        (!m_pAvailableClassesCaseIns->InsertValue(pszLowerCaseNS, pszLowerCaseName, pEntry, pEntry->pEncloser)))
                        return E_OUTOFMEMORY;
                }
           }
        }
        else
            return E_OUTOFMEMORY;
    }
   
    return S_OK;
}

HRESULT ClassLoader::AddExportedTypeHaveLock(LPCUTF8 pszNameSpace,
                                             LPCUTF8 pszName,
                                             mdExportedType cl,
                                             IMDInternalImport* pAsmImport,
                                             mdToken mdImpl)
{
    HashDatum ThrowawayData;

    if (TypeFromToken(mdImpl) == mdtExportedType) {
        // nested class
        LPCUTF8 pszEnclosingNameSpace;
        LPCUTF8 pszEnclosingName;
        mdToken nextImpl;
        EEClassHashEntry_t *pBucket;
        pAsmImport->GetExportedTypeProps(mdImpl,
                                        &pszEnclosingNameSpace,
                                        &pszEnclosingName,
                                        &nextImpl,
                                        NULL,  // type def
                                        NULL); // flags

        // Find entry for enclosing class - NOTE, this assumes that the
        // enclosing class's ExportedType was inserted previously, which assumes that,
        // when enuming ExportedTypes, we get the enclosing class first
        if ((pBucket = m_pAvailableClasses->GetValue(pszEnclosingNameSpace,
                                                    pszEnclosingName,
                                                    &ThrowawayData,
                                                    TypeFromToken(nextImpl) == mdtExportedType)) != NULL) {
            do {
                // check to see if this is the correct class
                if (UncompressModuleAndClassDef(ThrowawayData) == mdImpl) {
                    ThrowawayData = CompressModuleIndexAndClassDef((DWORD) -1, cl);

                    // we explicitely don't check for the case insensitive hash table because we know it cannot have been created yet
                    if (m_pAvailableClasses->InsertValue(pszNameSpace, pszName, ThrowawayData, pBucket))
                        return S_OK;
                    
                    return E_OUTOFMEMORY;
                }
                pBucket = m_pAvailableClasses->FindNextNestedClass(pszEnclosingNameSpace, pszEnclosingName, &ThrowawayData, pBucket);
            } while (pBucket);
        }

        // If the encloser is not in the hash table, this nested class
        // was defined in the manifest module, so it doesn't need to be added
        return S_OK;
    }
    else
    {
        // Defined in the manifest module - add to the hash table by TypeDef instead
        if (mdImpl == mdFileNil)
            return S_OK;

        // Don't add duplicate top-level classes
        // In this hash table, if the lower bit is set, it means a Module, otherwise it means EEClass*
        ThrowawayData = CompressModuleIndexAndClassDef((DWORD) -1, cl);
        // ThrowawayData is an IN OUT param. Going in its the pointer to the new value if the entry needs 
        // to be inserted. The OUT param points to the value stored in the hash table.
        BOOL bFound = FALSE;
        if (!m_pAvailableClasses->InsertValueIfNotFound(pszNameSpace, pszName, &ThrowawayData, NULL, FALSE, &bFound)) {
            // we explicitely don't check for the case insensitive hash table because we know it cannot have been created yet
            return E_OUTOFMEMORY;
        }

        // make sure the type is the same, that is it's coming from the same module. 
        // This should actually never happen because there is no point in inserting the same
        // type twice in the COMType table but given this smells awfully like an error this double 
        // check seems very cheap
        _ASSERTE((size_t)ThrowawayData & (1 << 31));
        mdToken foundTypeImpl;
        mdExportedType foundExportedType = UncompressModuleAndClassDef(ThrowawayData);
        pAsmImport->GetExportedTypeProps(foundExportedType,
                                        NULL,
                                        NULL,
                                        &foundTypeImpl,  // description
                                        NULL,
                                        NULL); // flags
        if (mdImpl != foundTypeImpl) {
            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
            BAD_FORMAT_ASSERT(!"Bad Exported Type");
            return COR_E_BADIMAGEFORMAT;
        }
    }

    return S_OK;
}


//
// Returns the fully qualified name of a classref.  Since code emitters are currently emitting the wrong
// thing (e.g. [LFoo; instead of [Foo, and [I instead of [<I4, we have to translate.
//
// pszName must be of size >= MAX_CLASSNAME_LENGTH
//
/* static */ BOOL ClassLoader::GetFullyQualifiedNameOfClassRef(Module *pModule, mdTypeRef cr, LPUTF8 pszFQName)
{
    LPCUTF8     pszName;
    LPCUTF8     pszNamespace;

    if (TypeFromToken(cr) == mdtTypeRef)
        pModule->GetMDImport()->GetNameOfTypeRef(cr, &pszNamespace, &pszName);
    else
    {
        // TypeDef token
        if (TypeFromToken(cr) != mdtTypeDef)
            return FALSE;

        pModule->GetMDImport()->GetNameOfTypeDef(cr, &pszName, &pszNamespace);
    }

    return ns::MakePath(pszFQName, MAX_CLASSNAME_LENGTH, pszNamespace, pszName);
}


//
// Returns whether we can cast the provided objectref to the provided template.
//
// pTemplate CANNOT be an array class.  However, pRef can be.
//
// However, pRef can be an array class, and the appropriate thing will happen.
//
// If an interface, does a dynamic interface check on pRef.
//
/* static */ BOOL ClassLoader::CanCastToClassOrInterface(OBJECTREF pRef, EEClass *pTemplate)
{
    _ASSERTE(pTemplate->IsArrayClass() == FALSE);

    // Try to make this as fast as possible in the non-context (typical) case.  In
    // effect, we just hoist the test out of GetTrueMethodTable() and do it here.
    MethodTable *pMT = pRef->GetTrueMethodTable();

    EEClass *pRefClass = pMT->m_pEEClass;

    if (pTemplate->IsInterface())
    {
        return pRefClass->SupportsInterface(pRef, pTemplate->GetMethodTable());
    }
    else
    {
        // The template is a regular class.

        // Check inheritance hierarchy
        do
        {
            if (pRefClass == pTemplate)
                return TRUE;

            pRefClass = pRefClass->GetParentClass();
        } while (pRefClass);

        return FALSE;
    }
}


//
// Returns whether we can cast the provided objectref to the provided template.
//
// pTemplate CANNOT be an array class.  However, pRef can be.
//
// Does NOT do a dynamic interface check -does a static check.
//
/* static */ BOOL ClassLoader::StaticCanCastToClassOrInterface(EEClass *pRefClass, EEClass *pTemplate)
{
    MethodTable *pMTTemplate = pTemplate->GetMethodTable();

    if (pMTTemplate->IsArray())
        return FALSE;

    if (pTemplate->IsInterface())
    {
        return pRefClass->StaticSupportsInterface(pMTTemplate);
    }
    else
    {
        // The template is a regular class.

        // Check inheritance hierarchy
        do
        {
            if (pRefClass == pTemplate)
                return TRUE;

            pRefClass = pRefClass->GetParentClass();
        } while (pRefClass);

        return FALSE;
    }
}


//
// Run-time cast check, used for isinst and castclass.  Returns whether the provided objectref can be cast to the
// provided classref.
//
// If mdTypeRef is an interface, returns whether "this" implements the interface.
// If mdTypeRef is a class, returns whether this class is the same as or a subclass of it.
//
// Handles array classrefs and array objrefs.
//
// Returns COR_E_TYPELOAD if the cast cannot be done, or E_ACCESSDENIED if the class cannot be loaded (so you can throw a TypeLoadException).
//
/* static */ HRESULT ClassLoader::CanCastTo(Module *pModule, OBJECTREF pRef, mdTypeRef cr)
{
    ClassLoader *   pLoader = pModule->GetClassLoader();
    NameHandle name;
    name.SetTypeToken(pModule, cr);
    TypeHandle clsHandle = pLoader->LoadTypeHandle(&name);

    if (clsHandle.IsNull())
        return E_ACCESSDENIED;
    return(CanCastTo(pRef, clsHandle));
}

/* static */ HRESULT ClassLoader::CanCastTo(OBJECTREF pRef, TypeHandle clsHandle)
{
    // Do the likely case first
    if (clsHandle.IsUnsharedMT())
    {
        // Not an array class
        _ASSERTE(clsHandle.AsMethodTable()->IsArray() == FALSE);

        // Follow regular code path
        if (CanCastToClassOrInterface(pRef, clsHandle.AsClass()))
            return S_OK;
        else
            return COR_E_TYPELOAD;
    }

    if (clsHandle.AsTypeDesc()->CanCastTo(clsHandle))
        return S_OK;

    return COR_E_TYPELOAD;
}

//
// Checks access.
/* static */ BOOL ClassLoader::CanAccessMethod(MethodDesc *pCurrentMethod, MethodDesc *pMD)
{
    return CanAccess(pCurrentMethod->GetClass(),
                     pCurrentMethod->GetModule()->GetAssembly(),
                     pMD->GetClass(),
                     pMD->GetModule()->GetAssembly(),
                     pMD->GetAttrs());
}

//
// Checks access.
/* static */ BOOL ClassLoader::CanAccessField(MethodDesc *pCurrentMethod, FieldDesc *pFD)
{

    _ASSERTE(fdPublic == mdPublic);
    _ASSERTE(fdPrivate == mdPrivate);
    _ASSERTE(fdFamily == mdFamily);
    _ASSERTE(fdAssembly == mdAssem);
    _ASSERTE(fdFamANDAssem == mdFamANDAssem);
    _ASSERTE(fdFamORAssem == mdFamORAssem);
    _ASSERTE(fdPrivateScope == mdPrivateScope);

    return CanAccess(pCurrentMethod->GetClass(),
                     pCurrentMethod->GetModule()->GetAssembly(),
                     pFD->GetEnclosingClass(),
                     pFD->GetModule()->GetAssembly(),
                     pFD->GetFieldProtection());
}


BOOL ClassLoader::CanAccessClass(EEClass *pCurrentClass,
                                 Assembly *pCurrentAssembly,
                                 EEClass *pTargetClass,
                                 Assembly *pTargetAssembly)
{
    if (! pTargetClass)
        return TRUE;

    if (! pTargetClass->IsNested()) {
        // a non-nested class can be either all public or accessible only from the current assembly
        if (IsTdPublic(pTargetClass->GetProtection()))
            return TRUE;
        else
            return (pTargetAssembly == pCurrentAssembly);
    }

    DWORD dwProtection = mdPublic;

    switch(pTargetClass->GetProtection()) {
        case tdNestedPublic:
            dwProtection = mdPublic;
            break;
        case tdNestedFamily:
            dwProtection = mdFamily;
            break;
        case tdNestedPrivate:
            dwProtection = mdPrivate;
            break;
        case tdNestedFamORAssem:
            dwProtection = mdFamORAssem;
            break;
        case tdNestedFamANDAssem:
            dwProtection = mdFamANDAssem;
            break;
        case tdNestedAssembly:
            dwProtection = mdAssem;
            break;
        default:
            _ASSERTE(!"Unexpected class visibility flag value");
    }

    // this class is nested, so we need to use it's enclosing class as the target point for
    // the check. So if are trying to access A::B need to check if can access things in 
    // A with the visibility of B so pass A as our target class and visibility of B within 
    // A as our member access
    return CanAccess(pCurrentClass, 
                     pCurrentAssembly, 
                     pTargetClass->GetEnclosingClass(), 
                     pTargetAssembly, 
                     dwProtection);
}


// This is a front-end to CheckAccess that handles the nested class scope. If can't access
// from the current point and are a nested class, then try from the enclosing class.
BOOL ClassLoader::CanAccess(EEClass *pCurrentClass,
                            Assembly *pCurrentAssembly,
                            EEClass *pTargetClass,
                            Assembly *pTargetAssembly,
                            DWORD dwMemberAccess)
{
    if (CheckAccess(pCurrentClass,
                    pCurrentAssembly,
                    pTargetClass,
                    pTargetAssembly,
                    dwMemberAccess))
        return TRUE;

    if (! pCurrentClass || ! pCurrentClass->IsNested())
        return FALSE;

    // a nested class has access to anything in the enclosing class scope, so check if can access
    // it from the enclosing class of the current class. Call CanAccess rather than CheckAccess so
    // that can do recursive nested class checking
    return CanAccess(pCurrentClass->GetEnclosingClass(),
                     pCurrentAssembly,
                     pTargetClass,
                     pTargetAssembly,
                     dwMemberAccess);
}

// pCurrentClass can be NULL in the case of a global function
// pCurrentClass it the point from which we're trying to access something
// pTargetClass is the class containing the member we are trying to access
// dwMemberAccess is the member access within pTargetClass of the member we are trying to access
BOOL ClassLoader::CheckAccess(EEClass *pCurrentClass,
                              Assembly *pCurrentAssembly,
                              EEClass *pTargetClass,
                              Assembly *pTargetAssembly,
                              DWORD dwMemberAccess)
{
    // we're trying to access a member that is contained in the class pTargetClass, so need to 
    // check if have access to pTargetClass itself from the current point before worry about 
    // having access to the member within the class
    if (! CanAccessClass(pCurrentClass,
                         pCurrentAssembly, 
                         pTargetClass, 
                         pTargetAssembly))
        return FALSE;

    if (IsMdPublic(dwMemberAccess))
        return TRUE;
    
    // This is module-scope checking, to support C++ file & function statics.
    if (IsMdPrivateScope(dwMemberAccess)) {
        if (pCurrentClass == NULL)
            return FALSE;

        _ASSERTE(pTargetClass);
        
        return (pCurrentClass->GetModule() == pTargetClass->GetModule());
    }

#ifdef _DEBUG
    if (pTargetClass == NULL &&
        (IsMdFamORAssem(dwMemberAccess) ||
         IsMdFamANDAssem(dwMemberAccess) ||
         IsMdFamily(dwMemberAccess))) {
        BAD_FORMAT_ASSERT(!"Family flag is not allowed on global functions");
    }
#endif

    if(pTargetClass == NULL || IsMdAssem(dwMemberAccess))
        return (pTargetAssembly == pCurrentAssembly);
    
    // Nested classes can access all members of the parent class.
    do {
        if (pCurrentClass == pTargetClass)
            return TRUE;

        if (IsMdFamORAssem(dwMemberAccess)) {
            if (pCurrentAssembly == pTargetAssembly)
                return TRUE;
            
            // Remember that pCurrentClass can be NULL on entry to this function
            if (!pCurrentClass)
                return FALSE;
            
            EEClass *pClass = pCurrentClass->GetParentClass();
            while (pClass) {
                if (pClass == pTargetClass)
                    return TRUE;
                
                pClass = pClass->GetParentClass();
            }
        }

        if (!pCurrentClass)
            return FALSE;

        if (IsMdPrivate(dwMemberAccess)) {
            if (!pCurrentClass->IsNested())
                return FALSE;
        }

        else if (IsMdFamANDAssem(dwMemberAccess) &&
                 (pCurrentAssembly != pTargetAssembly))
            return FALSE;

        else  {  // fam, famANDassem
            EEClass *pClass = pCurrentClass->GetParentClass();
            while (pClass) {
                if (pClass == pTargetClass)
                    return TRUE;
                
                pClass = pClass->GetParentClass();
            }
        }

        pCurrentClass = pCurrentClass->GetEnclosingClass();
    } while (pCurrentClass);

    return FALSE;
}

// pClassOfAccessingMethod : The point from which access needs to be checked. 
//                           NULL for global functions
// pClassOfMember          : The class containing the member being 
//                           accessed.
//                           NULL for global functions
// pClassOfInstance        : The class containing the member being accessed. 
//                           Could be same as pTargetClass
//                           Instance Class is required to verify family access
//                           NULL for global functions
// dwMemberAccess          : The member access within pTargetClass of the 
//                           member being accessed
/* static */
BOOL ClassLoader::CanAccess(EEClass  *pClassOfAccessingMethod, 
                            Assembly *pAssemblyOfAccessingMethod, 
                            EEClass  *pClassOfMember, 
                            Assembly *pAssemblyOfClassContainingMember, 
                            EEClass  *pClassOfInstance,
                            DWORD     dwMemberAccess)
{
    // we're trying to access a member that is contained in the class pTargetClass, so need to 
    // check if have access to pTargetClass itself from the current point before worry about 
    // having access to the member within the class
    if (!CanAccessClass(pClassOfAccessingMethod,
                        pAssemblyOfAccessingMethod, 
                        pClassOfMember,
                        pAssemblyOfClassContainingMember))
        return FALSE;

/* @Review : Do we need to do this check ?
             This check will fail if the instance class changed it's protection
             after current class is compiled.

    // The instance itself could not be accessable from current class.
    if (pClassOfMember != pClassOfInstance)
    {
        if (!CanAccessClass(pClassOfAccessingMethod,
                            pAssemblyOfAccessingMethod,
                            pClassOfInstance,
                            pAssemblyOfInstance));
            return FALSE;
    }
*/

    if (IsMdPublic(dwMemberAccess))
        return TRUE;

    if (IsMdPrivateScope(dwMemberAccess))
        return (pClassOfAccessingMethod->GetModule() == pClassOfMember->GetModule());

    if (pClassOfMember == NULL || IsMdAssem(dwMemberAccess))
        return (pAssemblyOfClassContainingMember == pAssemblyOfAccessingMethod);

    // Nested classes can access all members of the parent class.
    do {

#ifdef _DEBUG
        if (pClassOfMember == NULL &&
            (IsMdFamORAssem(dwMemberAccess) ||
             IsMdFamANDAssem(dwMemberAccess) ||
             IsMdFamily(dwMemberAccess)))
            _ASSERTE(!"Family flag is not allowed on global functions");
#endif

        if (pClassOfMember == pClassOfAccessingMethod)
            return TRUE;

        if (IsMdPrivate(dwMemberAccess)) {
            if (!pClassOfAccessingMethod->IsNested())
                return FALSE;
        }

        else if (IsMdFamORAssem(dwMemberAccess)) {
            if (pAssemblyOfAccessingMethod == pAssemblyOfClassContainingMember)
                return TRUE;
            
            return CanAccessFamily(pClassOfAccessingMethod, 
                                   pClassOfMember, 
                                   pClassOfInstance);
        }

        else if (IsMdFamANDAssem(dwMemberAccess) &&
                 (pAssemblyOfAccessingMethod != pAssemblyOfClassContainingMember))
            return FALSE;

        // family, famANDAssem
        else if (CanAccessFamily(pClassOfAccessingMethod, 
                                pClassOfMember, 
                                pClassOfInstance))
            return TRUE;

        pClassOfAccessingMethod = pClassOfAccessingMethod->GetEnclosingClass();
    } while (pClassOfAccessingMethod);

    return FALSE;
}

// Allowed only if 
// Target >= Current >= Instance 
// where '>=' is 'parent of or equal to' relation
//
// Current is the function / method where an attempt is made to access a member 
// of Target, which is marked with family access, on an object of type Instance
//
// Eg.
//
// class X
//   member x : family access
//
// class Y
//   member y : family access
//
// class A, extends X
//   member a : family access
//
// class B, extends X
//   member b : family access
//
// class C, extends A
//   member c : family access
//
//  (X > A)
//  (X > B)
//  (A > C)
//
//   Y is unrelated to X, A or C
//
//
//  CanAccessFamily of  will pass only for :
//
//  --------------------------
//  Target | Cur | Instance
//  --------------------------
//   x.X   |  X  |  X, A, B, C
//   x.X   |  A  |  A, C
//   x.X   |  B  |  B
//   x.X   |  C  |  C
//   a.A   |  A  |  A, C
//   a.A   |  C  |  C
//   b.B   |  B  |  B
//   c.C   |  C  |  C
//   y.Y   |  Y  |  Y
//
//

/* static */
BOOL ClassLoader::CanAccessFamily(EEClass *pCurrentClass,
                                  EEClass *pTargetClass,
                                  EEClass *pInstanceClass)
{
    _ASSERTE(pTargetClass);
    _ASSERTE(pInstanceClass);

/* 
    This function does not assume Target >= Instance 
    Hence commenting out this Debug code.
    Will return FALSE if Instance is not a subtype of Target

#ifdef _DEBUG
    EEClass *pTmp;
    // Instance is a child of or equal to Target
    pTmp = pInstanceClass;

    while (pTmp)
    {
        if (pTmp == pTargetClass)
            break;

        pTmp = pTmp->m_pParentClass;
    }

    _ASSERTE(pTmp);
#endif

*/

    if (pCurrentClass == NULL)
        return FALSE;

    // check if Instance is a child of or equal to Current
    do {
        EEClass *pCurInstance = pInstanceClass;

        while (pCurInstance) {
            if (pCurInstance == pCurrentClass) {
                // check if Current is child or equal to Target
                while (pCurrentClass) {
                    if (pCurrentClass == pTargetClass)
                        return TRUE;
                    pCurrentClass = pCurrentClass->GetParentClass();
                }

                return FALSE;
            }

            pCurInstance = pCurInstance->GetParentClass();
        }

        pInstanceClass = pInstanceClass->GetEnclosingClass();
    } while (pInstanceClass);
        
    return FALSE;
}

static HRESULT RunMainPre()
{
    _ASSERTE(GetThread() != 0);
    g_fWeControlLifetime = TRUE;
    return S_OK;
}

static HRESULT RunMainPost()
{
    HRESULT hr = S_OK;

    Thread *td = GetThread();
    _ASSERTE(td);

    td->EnablePreemptiveGC();
    g_pThreadStore->WaitForOtherThreads();
    td->DisablePreemptiveGC();
    
    // Turn on memory dump checking in debug mode.
#ifdef _DEBUG
    if (SUCCEEDED(hr))
        _DbgRecord();
#endif
    return hr;
}

#ifdef STRESS_THREAD
struct Stress_Thread_Param
{
    MethodDesc *pFD;
    short numSkipArgs;
    CorEntryPointType EntryType;
    Thread* pThread;
};

struct Stress_Thread_Worker_Param
{
    Stress_Thread_Param *lpParameter;
    ULONG retVal;
};

static void Stress_Thread_Proc_Worker (Stress_Thread_Worker_Param *args)
{
    DWORD       cCommandArgs = 0;  // count of args on command line
    DWORD       arg = 0;
    LPWSTR      *wzArgs = NULL; // command line args
    PTRARRAYREF StrArgArray = NULL;
    __int32 RetVal = E_FAIL;
    
    Stress_Thread_Param *lpParam = (Stress_Thread_Param *)args->lpParameter;
    if (lpParam->EntryType == EntryManagedMain)
    {
        wzArgs = CorCommandLine::GetArgvW(&cCommandArgs);
        if (cCommandArgs > 0)
        {
            if (!wzArgs)
            {
                args->retVal = E_INVALIDARG;
                return;
            }
        }
    }
    COMPLUS_TRY 
    {
        // Build the parameter array and invoke the method.
        if (lpParam->EntryType == EntryManagedMain)
        {

            // Allocate a COM Array object with enough slots for cCommandArgs - 1
            StrArgArray = (PTRARRAYREF) AllocateObjectArray((cCommandArgs - lpParam->numSkipArgs), g_pStringClass);
            GCPROTECT_BEGIN(StrArgArray);
            if (!StrArgArray)
                COMPlusThrowOM();
            // Create Stringrefs for each of the args
            for( arg = lpParam->numSkipArgs; arg < cCommandArgs; arg++)
            {
                STRINGREF sref = COMString::NewString(wzArgs[arg]);
                StrArgArray->SetAt(arg-lpParam->numSkipArgs, (OBJECTREF) sref);
            }

            StackElemType stackVar = 0;
            *(ArgTypeAddr(&stackVar, PTRARRAYREF)) = StrArgArray;
            RetVal = (__int32)(lpParam->pFD->Call((const __int64 *)&stackVar));
            GCPROTECT_END();
        }
        // For no argument version.
        else
        {
            StackElemType stackVar = 0;
            RetVal = (__int32)(lpParam->pFD->Call((const __int64 *)&stackVar));
        }

        if (lpParam->pFD->IsVoid()) 
        {
            RetVal = GetLatchedExitCode();
        }

        //@TODO - LBS
        // When we get mainCRTStartup from the C++ then this should be able to go away.
        fflush(stdout);
        fflush(stderr);

    }
    COMPLUS_CATCHEX(COMPLUS_CATCH_NEVER_CATCH)
    {
    } COMPLUS_END_CATCH
    args->retVal = RetVal;
}

static DWORD WINAPI Stress_Thread_Proc (LPVOID lpParameter)
{
    Stress_Thread_Worker_Param args = {(Stress_Thread_Param*)lpParameter,0};
    __int32 RetVal = E_FAIL;
    
    Stress_Thread_Param *lpParam = (Stress_Thread_Param *)lpParameter;
    Thread *pThread = lpParam->pThread;
    pThread->HasStarted();
    AppDomain *pKickOffDomain = pThread->GetKickOffDomain();
    
    COMPLUS_TRYEX(pThread)
    {
        // should always have a kickoff domain - a thread should never start in a domain that is unloaded
        // because otherwise it would have been collected because nobody can hold a reference to thread object
        // in a domain that has been unloaded. But it is possible that we started the unload, in which 
        // case this thread wouldn't be allowed in or would be punted anyway.
        if (! pKickOffDomain)
            COMPlusThrow(kAppDomainUnloadedException);
        if (pKickOffDomain != lpParam->pThread->GetDomain())
        {
            pThread->DoADCallBack(pKickOffDomain->GetDefaultContext(), Stress_Thread_Proc_Worker, &args);
        }
        else
        {
            Stress_Thread_Proc_Worker(&args);
        }
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH;
    delete lpParameter;
    // Enable preemptive GC so a GC thread can suspend me.
    pThread->EnablePreemptiveGC();
    return args.retVal;
}

extern CStackArray<Thread **> StressThread;
LONG StressThreadLock = 0;
static void Stress_Thread_Start (LPVOID lpParameter)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pCurThread = GetThread();
    if (pCurThread->m_stressThreadCount == -1) {
        pCurThread->m_stressThreadCount = g_pConfig->GetStressThreadCount();
    }
    DWORD dwThreads = pCurThread->m_stressThreadCount;
    if (dwThreads <= 1)
        return;

    Thread ** threads = new (throws) Thread* [dwThreads-1];

    while (FastInterlockCompareExchange((void**)&StressThreadLock,(void*)1,(void*)0) != 0)
        __SwitchToThread (1);

    StressThread.Push(threads);
    FastInterlockExchange(&StressThreadLock, 0);

    DWORD n;
    for (n = 0; n < dwThreads-1; n ++)
    {
        threads[n] = SetupUnstartedThread();
        if (threads[n] == NULL)
            COMPlusThrowOM();

        threads[n]->m_stressThreadCount = dwThreads/2;
        threads[n]->IncExternalCount();
        DWORD newThreadId;
        HANDLE h;
        Stress_Thread_Param *param = new (throws) Stress_Thread_Param;

        param->pFD = ((Stress_Thread_Param*)lpParameter)->pFD;
        param->numSkipArgs = ((Stress_Thread_Param*)lpParameter)->numSkipArgs;
        param->EntryType = ((Stress_Thread_Param*)lpParameter)->EntryType;
        param->pThread = threads[n];
        h = threads[n]->CreateNewThread(0, Stress_Thread_Proc, param, &newThreadId);
        ::SetThreadPriority (h, THREAD_PRIORITY_NORMAL);
        threads[n]->SetThreadId(newThreadId);
    }

    for (n = 0; n < dwThreads-1; n ++)
    {
        ::ResumeThread(threads[n]->GetThreadHandle());
    }
    __SwitchToThread (0);
}

#endif

static HRESULT RunMain(MethodDesc *pFD ,
                       short numSkipArgs,
                       PTRARRAYREF *stringArgs = NULL)
{
    __int32 RetVal;
    DWORD       cCommandArgs = 0;  // count of args on command line
    DWORD       arg = 0;
    LPWSTR      *wzArgs = NULL; // command line args
    HRESULT     hr = S_OK;

    RetVal = -1;

    // The exit code for the process is communicated in one of two ways.  If the
    // entrypoint returns an 'int' we take that.  Otherwise we take a latched
    // process exit code.  This can be modified by the app via System.SetExitCode()
    // 
    SetLatchedExitCode (0);

    if (!pFD)
    {
        _ASSERTE(!"Must have a function to call!");
        return E_FAIL;
    }

    CorEntryPointType EntryType = EntryManagedMain;
    ValidateMainMethod(pFD, &EntryType);

    if ((EntryType == EntryManagedMain) &&
        (stringArgs == NULL))
    {
        // If you look at the DIFF on this code then you will see a major change which is that we
        // no longer accept all the different types of data arguments to main.  We now only accept
        // an array of strings.
        
        wzArgs = CorCommandLine::GetArgvW(&cCommandArgs);
        // In the WindowsCE case where the app has additional args the count will come back zero.
        if (cCommandArgs > 0)
        {
            if (!wzArgs)
                return E_INVALIDARG;
        }
    }

#if ZAPMONITOR_ENABLED
    if (g_pConfig->MonitorZapStartup())
    {
        ZapMonitor::ReportAll("Main Executing", 
                              g_pConfig->MonitorZapStartup() >= 2,
                              g_pConfig->MonitorZapStartup() >= 4);

    if (g_pConfig->MonitorZapExecution())
        ZapMonitor::ResetAll();
    else
        ZapMonitor::DisableAll();
    }
#endif
    
    COMPLUS_TRY 
    {
        StackElemType stackVar = 0;

        // Build the parameter array and invoke the method.
        if (EntryType == EntryManagedMain)
        {
#ifdef STRESS_THREAD
            Stress_Thread_Param Param = {pFD, numSkipArgs, EntryType, 0};
            Stress_Thread_Start (&Param);
#endif
        
            PTRARRAYREF StrArgArray = NULL;
            GCPROTECT_BEGIN(StrArgArray);

#ifdef _IA64_
            //
            // @TODO_IA64:  implement command line args
            //
            // this is #ifdefed out because we don't have the 
            // string class from mscorlib
            //
#else // !_IA64_
            if (stringArgs == NULL)
            {
                // Allocate a COM Array object with enough slots for cCommandArgs - 1
                StrArgArray = (PTRARRAYREF) AllocateObjectArray((cCommandArgs - numSkipArgs), g_pStringClass);
                if (!StrArgArray)
                    COMPlusThrowOM();
                // Create Stringrefs for each of the args
                for( arg = numSkipArgs; arg < cCommandArgs; arg++)
                {
                    STRINGREF sref = COMString::NewString(wzArgs[arg]);
                    StrArgArray->SetAt(arg-numSkipArgs, (OBJECTREF) sref);
                }

                *(ArgTypeAddr(&stackVar, PTRARRAYREF)) = StrArgArray;
            }
            else {
                *(ArgTypeAddr(&stackVar, PTRARRAYREF)) = *stringArgs;
            }
#endif // !_IA64_

            // Execute the method through the interpreter
            // @TODO - LBS
            // Eventually the return value will need to be ripped off this as well
            // since main is supposed to be a void.  I am leaving this for testing.
            // Here need to pass an appropriately wide argument for the platform

            // @Todo - Larry, you were going to examine this code for 64-bit.  StackElemType
            // is a 4 byte value but Call() requires a 64-bit value.  It happens to work
            // here because on 32-bit the value is cast and the correct 4 bytes are copied.
            // But it looks unsafe and in fact broke the equivalent RunDllMain code below.
            RetVal = (__int32)(pFD->Call((const __int64 *)&stackVar));
            GCPROTECT_END();
        }
        // For no argument version.
        else
        {
#ifdef STRESS_THREAD
            Stress_Thread_Param Param = {pFD, 0, EntryType, 0};
            Stress_Thread_Start (&Param);
#endif
            RetVal = (__int32)(pFD->Call((const __int64 *)&stackVar));
        }

        if (!pFD->IsVoid()) 
            SetLatchedExitCode (RetVal);
        
        //@TODO - LBS
        // When we get mainCRTStartup from the C++ then this should be able to go away.
        fflush(stdout);
        fflush(stderr);
    }
    COMPLUS_CATCHEX(COMPLUS_CATCH_NEVER_CATCH)
    {
    } COMPLUS_END_CATCH

    return hr;
}


// @Todo: For M10, this only runs unmanaged native classic entry points for
// the IJW mc++ case.
HRESULT RunDllMain(MethodDesc *pMD, HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    if (!pMD)
    {
        _ASSERTE(!"Must have a valid function to call!");
        return E_INVALIDARG;
    }

    BOOL gotException = TRUE;
    __try
    {
        COMPLUS_TRY
        {
                // This call is inherantly unverifiable entry point.   
            if (dwReason==DLL_PROCESS_ATTACH && !Security::CanSkipVerification(pMD->GetModule()))
                return SECURITY_E_UNVERIFIABLE;

            SigPointer sig(pMD->GetSig());
            if (sig.GetData() != IMAGE_CEE_CS_CALLCONV_DEFAULT)
                return COR_E_METHODACCESS;
            if (sig.GetData() != 3)
                return COR_E_METHODACCESS;
            if (sig.GetElemType() != ELEMENT_TYPE_I4)                                               // return type = int32
                return COR_E_METHODACCESS;
            if (sig.GetElemType() != ELEMENT_TYPE_PTR || sig.GetElemType() != ELEMENT_TYPE_VOID)    // arg1 = void*
                return COR_E_METHODACCESS;
            if (sig.GetElemType() != ELEMENT_TYPE_U4)                                               // arg2 = uint32
                return COR_E_METHODACCESS;
            if (sig.GetElemType() != ELEMENT_TYPE_PTR || sig.GetElemType() != ELEMENT_TYPE_VOID)    // arg3 = void* 
                return COR_E_METHODACCESS;

            // Set up a callstack with the values from the OS in the arguement array
            // in right to left order.
            __int64 stackVar[3];
            stackVar[0] = (__int64) lpReserved;
            stackVar[1] = (__int64)dwReason;
            stackVar[2] = (__int64)hInst;

            // Call the method in question with the arguements.
            INT32 RetVal = (__int32)(pMD->Call((const __int64 *)&stackVar[0]));
            gotException = FALSE;
        }
        COMPLUS_FINALLY
        {
        } COMPLUS_END_FINALLY
    }
    __except( (DefaultCatchHandler(), COMPLUS_EXCEPTION_EXECUTE_HANDLER) )
    {
        Thread *pThread = GetThread();
        if (! pThread->PreemptiveGCDisabled())
            pThread->DisablePreemptiveGC();
        // don't do anything - just want to catch it
    }

    return S_OK;
}


//
// Given a PELoader, find the .descr section and call the first function there
//
HRESULT ClassLoader::ExecuteMainMethod(Module *pModule, PTRARRAYREF *stringArgs)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc             *pFD = NULL;
    HRESULT                 hr = E_FAIL;
    Thread *                pThread = NULL;
    BOOL                    fWasGCDisabled;
    IMAGE_COR20_HEADER *    Header;
    mdToken                 ptkParent;  
    CorEntryPointType       EntryPointType = EntryManagedMain;
    OBJECTREF pReThrowable = NULL;


    _ASSERTE(pModule);
    _ASSERTE(pModule->IsPEFile());
    
    Header = pModule->GetCORHeader();

    IfFailGoto(RunMainPre(), exit2);

    // Disable GC if not already disabled
    pThread = GetThread();

    fWasGCDisabled = pThread->PreemptiveGCDisabled();
    if (fWasGCDisabled == FALSE)
        pThread->DisablePreemptiveGC();

    GCPROTECT_BEGIN(pReThrowable);
    
    // This thread looks like it wandered in -- but actually we rely on it to keep the
    // process alive.
    pThread->SetBackground(FALSE);

    // Must have a method def token for the entry point.    
    if (TypeFromToken(Header->EntryPointToken) != mdtMethodDef) 
    {
        _ASSERTE(0 && "EntryPointToken was not a Method Def token, illegal");
        COMPlusThrowHR(COR_E_MISSINGMETHOD, IDS_EE_ILLEGAL_TOKEN_FOR_MAIN, NULL, NULL);
    }   

    // We have a MethodDef.  We need to get its properties and the class token for it.
    IfFailGoto(pModule->GetMDImport()->GetParentToken(Header->EntryPointToken,&ptkParent), exit);

    if (ptkParent != COR_GLOBAL_PARENT_TOKEN)
    {
        ON_EXCEPTION {
        COMPLUS_TRY
        {
                // This code needs a class init frame, because without it, the
                // debugger will assume any code that results from searching for a
                // type handle (ie, loading an assembly) is the first line of a program.
                DebuggerClassInitMarkFrame __dcimf;

                EEClass* InitialClass;
                OBJECTREF pThrowable = NULL;
                GCPROTECT_BEGIN(pThrowable);

                NameHandle name;
                name.SetTypeToken(pModule, ptkParent);
                InitialClass = LoadTypeHandle(&name,&pThrowable).GetClass();
                if (!InitialClass)
                {
                    COMPlusThrow(pThrowable);
                }

                GCPROTECT_END();

                pFD =  InitialClass->FindMethod((mdMethodDef)Header->EntryPointToken);  

                __dcimf.Pop();
        }
        COMPLUS_CATCH
        { 
            pReThrowable=GETTHROWABLE();
            pFD = NULL;
        
        }
        COMPLUS_END_CATCH
        } CALL_DEFAULT_CATCH_HANDLER(FALSE);
    }   
    else
    { 
        ON_EXCEPTION {
        COMPLUS_TRY 
        {   
                pFD =  pModule->FindFunction((mdToken)Header->EntryPointToken); 
        }   
        COMPLUS_CATCH   
        {   
            pReThrowable=GETTHROWABLE();
            pFD = NULL; 
        }   
        COMPLUS_END_CATCH
        } CALL_DEFAULT_CATCH_HANDLER(FALSE);
    }

    if (!pFD)
    {
        if (pReThrowable!=NULL)
            COMPlusThrow(pReThrowable);
        else
            COMPlusThrowHR(COR_E_MISSINGMETHOD, IDS_EE_FAILED_TO_FIND_MAIN, NULL, NULL); 
    }

    hr = RunMain(pFD, 1, stringArgs);

exit:

    GCPROTECT_END(); //pReThrowable
exit2:
    //RunMainPost is supposed to be called on the main thread of an EXE,
    //after that thread has finished doing useful work.  It contains logic
    //to decide when the process should get torn down.  So, don't call it from
    // AppDomain.ExecuteAssembly()
    if (stringArgs == NULL)
        RunMainPost();

    return hr;
}
    

// Returns true if this is a valid main method?
void ValidateMainMethod(MethodDesc * pFD, CorEntryPointType *pType)
{
    _ASSERTE(pType);
        // Must be static, but we don't care about accessibility
    THROWSCOMPLUSEXCEPTION();
    if ((pFD->GetAttrs() & mdStatic) == 0) 
        ThrowMainMethodException(pFD, IDS_EE_MAIN_METHOD_MUST_BE_STATIC);

        // Check for types
    PCCOR_SIGNATURE pCurMethodSig;
    DWORD       cCurMethodSig;

    pFD->GetSig(&pCurMethodSig, &cCurMethodSig);
    SigPointer sig(pCurMethodSig);

    ULONG nCallConv = sig.GetData();    
    if (nCallConv != IMAGE_CEE_CS_CALLCONV_DEFAULT)
        ThrowMainMethodException(pFD, IDS_EE_LOAD_BAD_MAIN_SIG);

    ULONG nParamCount = sig.GetData(); 

    CorElementType nReturnType = sig.GetElemType();
    if ((nReturnType != ELEMENT_TYPE_VOID) && (nReturnType != ELEMENT_TYPE_I4) && (nReturnType != ELEMENT_TYPE_U4)) 
         ThrowMainMethodException(pFD, IDS_EE_MAIN_METHOD_HAS_INVALID_RTN);

    if (nParamCount == 0)
        *pType = EntryCrtMain;
    else 
    {
        *pType = EntryManagedMain;

        if (nParamCount != 1) 
            ThrowMainMethodException(pFD, IDS_EE_TO_MANY_ARGUMENTS_IN_MAIN);

        CorElementType argType = sig.GetElemType();
        if (argType != ELEMENT_TYPE_SZARRAY || sig.GetElemType() != ELEMENT_TYPE_STRING)
            ThrowMainMethodException(pFD, IDS_EE_LOAD_BAD_MAIN_SIG);
    }
}

//*****************************************************************************
// This guy will set up the proper thread state, look for the module given
// the hinstance, and then run the entry point if there is one.
//*****************************************************************************
HRESULT ClassLoader::RunDllMain(DWORD dwReason)
{
    MethodDesc  *pMD;
    Module      *pModule;
    Thread      *pThread = NULL;
    BOOL        fWasGCDisabled = -1;
    HRESULT     hr = S_FALSE;           // Assume no entry point.
    
    // @Todo: Craig, in M10 we do not guarantee that we can run managed
    // code on a thread that may be shutting down.  So we agreed that
    // if you are in detach, we must skip the user code which is a hole.
    pThread = GetThread();
    if ((!pThread && (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)) ||
        g_fEEShutDown)
    {
        return S_OK;
    }

    // Setup the thread state to cooperative to run managed code.
    fWasGCDisabled = pThread->PreemptiveGCDisabled();
    if (fWasGCDisabled == FALSE)
        pThread->DisablePreemptiveGC();

    // For every module with a user entry point, signal detach.
    for (pModule = m_pHeadModule;  pModule;  pModule = pModule->GetNextModule()) {
        // See if there even is an entry point.
        pMD = pModule->GetDllEntryPoint();
        if (!pMD)
            continue;
    
        // Run through the helper which will do exception handling for us.
        hr = ::RunDllMain(pMD, (HINSTANCE) pModule->GetILBase(), dwReason, NULL);
        if (FAILED(hr))
            goto ErrExit;
    }

ErrExit:    
    // Return thread state.
    if (pThread && fWasGCDisabled == FALSE)
        pThread->EnablePreemptiveGC();
    return (hr);
}


void ThrowClassLoadException(IMDInternalImport *pInternalImport, mdTypeDef classToken, UINT resID)
{
    THROWSCOMPLUSEXCEPTION();

    LPCUTF8 pszName, pszNameSpace;
    pInternalImport->GetNameOfTypeDef(classToken, &pszName, &pszNameSpace);

    LPUTF8      pszFullyQualifiedName = NULL;

    if (*pszNameSpace) {
        MAKE_FULLY_QUALIFIED_NAME(pszFullyQualifiedName, pszNameSpace, pszName);
    }
    else
        pszFullyQualifiedName = (LPUTF8) pszName;

    #define MAKE_TRANSLATIONFAILED pszFullyQualifiedNameW=L""
    MAKE_WIDEPTR_FROMUTF8_FORPRINT(pszFullyQualifiedNameW, pszFullyQualifiedName);
    #undef MAKE_TRANSLATIONFAILED
    COMPlusThrow(kTypeLoadException, resID, pszFullyQualifiedNameW);
}


typedef struct _EEHandle {
    DWORD Status[1];
} EEHandle, *PEEHandle;


#ifdef EnC_SUPPORTED
// This function applies a set of EditAndContinue snapshots to the EE. Instead of actually applying
// the changes, can simply query to make sure that they will be successful. 
HRESULT ClassLoader::ApplyEditAndContinue(EnCInfo *pEnCInfo, 
                                          UnorderedEnCErrorInfoArray *pEnCError, 
                                          UnorderedEnCRemapArray *pEnCRemapInfo,
                                          BOOL checkOnly)
{
#ifdef _DEBUG
    BOOL shouldBreak = g_pConfig->GetConfigDWORD(L"EncApplyBreak", 0);
    if (shouldBreak > 0) {
        _ASSERTE(!"EncApplyBreak in ApplyEditAndContinue");
    }
#endif
    
    _ASSERTE(pEnCInfo); 

    HRESULT hrOverall = S_OK;

    SIZE_T count = pEnCInfo->count;
    EnCEntry *entries = (EnCEntry *) (pEnCInfo + 1);

    CBinarySearchILMap *pILM = new (nothrow) CBinarySearchILMap(); 

    // Check for out of memory
    _ASSERTE(pILM);
    TESTANDRETURNMEMORY(pILM);
    
    // go through each module specified and apply changes.
    // After we try and apply the changes, we'll iterate over all the new
    // errorInfo's & fill in some info (DebuggerModule, AppDomain, error string, etc)
    for (SIZE_T i=0; i < count; i++) 
    {  
        if(!entries[i].module)
            continue;

        // Remember where the last error was so we can fill in info starting
        // at the next new one.
        HRESULT hr = S_OK;
        USHORT iStartingErr = pEnCError->Count();
        DebuggerModule *dm = g_pDebugInterface->TranslateRuntimeModule(entries[i].module);
        _ASSERTE(dm);

        // If the module isn't in edit and continue mode, then we're screwed.
        if (!entries[i].module->IsEditAndContinue())
        {
            EnCErrorInfo *pError = pEnCError->Append();
            
            if (pError == NULL)
                hr = E_OUTOFMEMORY;
            else
            {
                _ASSERTE(entries[i].module->GetAssembly());
                _ASSERTE(entries[i].module->GetAssembly()->GetManifestImport());
                mdModule mdMod;
                mdMod = entries[i].module->GetAssembly()->GetManifestImport()
                        ->GetModuleFromScope();
                ADD_ENC_ERROR_ENTRY(pError, 
                                    CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED, 
                                    NULL, //filled in later
                                    mdMod);
                                        
                hr = E_FAIL;             
            }
        }

        // Will the edit and continue work?
        if (!FAILED(hr))
        {
            EditAndContinueModule *pModule = (EditAndContinueModule*)(entries[i].module);   

            BYTE *pbCur = (BYTE*)pEnCInfo + entries[i].offset +
                entries[i].peSize + entries[i].symSize;
            pILM->SetVariables( (UnorderedILMap *)(pbCur + sizeof(int)), *(int*)pbCur);
            
            hr = pModule->ApplyEditAndContinue(&entries[i], 
                                               (BYTE*)pEnCInfo + entries[i].offset,
                                               pILM,
                                               pEnCError,
                                               pEnCRemapInfo,
                                               checkOnly); 
        }

        // We'll get N >= 0 errors from the attempt, and we'll need to fill in the 
        // module/appdomain information here.
        USHORT iEndingErr = pEnCError->Count();
        EnCErrorInfo *pError = pEnCError->Table();
        
        while (iStartingErr < iEndingErr)
        {
            EnCErrorInfo *pErrorCur = &(pError[iStartingErr]);
            pErrorCur->m_module = dm;
            pErrorCur->m_appDomain = entries[i].module->GetDomain();
            HRESULT hrIgnore = FormatRuntimeErrorVa(
                pErrorCur->m_sz,
                ENCERRORINFO_MAX_STRING_SIZE,
                pErrorCur->m_hr,
                NULL);
            iStartingErr++;
        }

        // We specifically don't want to return till we've gather all possible
        // errors from all the modules we're dealing with.
        // Once we know the operation is failing, retain the most
        // informative error message that we've got.
        if (FAILED(hr) && hrOverall != E_FAIL)
            hrOverall = hr;
    }   

#ifdef _DEBUG
    if(REGUTIL::GetConfigDWORD(L"BreakOnEnCFail",0) && FAILED(hrOverall))
        _ASSERTE(!"ApplyEditAndContinue failed - stop here?");
#endif //_DEBUG
    
    if (pILM)
        delete pILM;
    return hrOverall;
}

#endif // EnC_SUPPORTED

LoaderHeap* ClassLoader::GetLowFrequencyHeap()
{
    return GetAssembly()->GetLowFrequencyHeap();
}

LoaderHeap* ClassLoader::GetHighFrequencyHeap()
{
    return GetAssembly()->GetHighFrequencyHeap();
}

LoaderHeap* ClassLoader::GetStubHeap()
{
    return GetAssembly()->GetStubHeap();
}

//-------------------------------------------------------------------------
// Walks over all stub caches in the system and does a FreeUnused sweep over them.
//-------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID FreeUnusedStubs()
{
    ECall::FreeUnusedStubs();
    NDirect::FreeUnusedStubs();
}
#endif /* SHOULD_WE_CLEANUP */


//-------------------------------------------------------------------------
// CorCommandLine state and methods
//-------------------------------------------------------------------------
// Class to encapsulate Cor Command line processing

// Statics for the CorCommandLine class
DWORD                CorCommandLine::m_NumArgs     = 0;
LPWSTR              *CorCommandLine::m_ArgvW       = 0;
CorCommandLine::Bits CorCommandLine::m_Bits        = CLN_Nothing;

#ifdef _DEBUG
LPWSTR  g_CommandLine;
#endif

// Set argvw from command line
VOID CorCommandLine::SetArgvW(LPWSTR lpCommandLine)
{
    if(!m_ArgvW) {
        _ASSERTE(lpCommandLine);

        INDEBUG(g_CommandLine = lpCommandLine);

        InitializeLogging();        // This is so early, we may not be initialized
        LOG((LF_ALL, LL_INFO10, "Executing program with command line '%S'\n", lpCommandLine));
        
        m_ArgvW = SegmentCommandLine(lpCommandLine, &m_NumArgs);

        // Now that we have everything in a convenient form, do all the COR-specific
        // parsing.
        ParseCor();
    }
}

// Retrieve the command line
LPWSTR* CorCommandLine::GetArgvW(DWORD *pNumArgs)
{
    if (pNumArgs != 0)
        *pNumArgs = m_NumArgs;

    return m_ArgvW;
}


// Parse the command line (removing stuff inside -cor[] and setting bits)
void CorCommandLine::ParseCor()
{
    if (m_NumArgs >= 3)  // e.g. -COR "xxxx xxx" or /cor "xx"
        if ((m_ArgvW[1][0] == '/' || m_ArgvW[1][0] == '-') &&
            (_wcsicmp(m_ArgvW[1]+1, L"cor") == 0))
        {
            // There is a COR section to the 
            LOG((LF_ALL, LL_INFO10, "Parsing COR command line '%S'\n", m_ArgvW[2]));

            LPWSTR  pCorCmdLine = m_ArgvW[2];

            // The application doesn't see any of the COR arguments.  We don't have to
            // worry about releasing anything, because it's all allocated in a single
            // block -- which is how we release it in CorCommandLine::Shutdown().
            m_NumArgs -= 2;
            for (DWORD i=1; i<m_NumArgs; i++)
                m_ArgvW[i] = m_ArgvW[i+2];

            // Now whip through pCorCmdLine and set all the COR specific switches.
            // Assert if anything is in an invalid format and then ignore the whole
            // thing.
            // @TODO cwb: revisit the failure policy after we see what we are actually
            // using this facility for, in the shipping product.
            WCHAR   *pWC1 = pCorCmdLine;

            if (*pWC1 == '"')
                pWC1++;

            while (*pWC1)
            {

                if (*pWC1 == ' ')
                {
                    pWC1++;
                    continue;
                }
                
                // Anything else is either the end, or a surprise
                break;
            }
        }
}


// Terminate the command line, ready to be reinitialized without reloading
#ifdef SHOULD_WE_CLEANUP
void CorCommandLine::Shutdown()
{
    if (m_ArgvW)
        delete [] m_ArgvW;

    m_NumArgs = 0;
    m_ArgvW = 0;
    m_Bits = CLN_Nothing;
}
#endif /* SHOULD_WE_CLEANUP */

// -------------------------------------------------------
// Class loader stub manager functions & globals
// -------------------------------------------------------

MethodDescPrestubManager *MethodDescPrestubManager::g_pManager = NULL;

BOOL MethodDescPrestubManager::Init()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    g_pManager = new (nothrow) MethodDescPrestubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);

    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
void MethodDescPrestubManager::Uninit()
{
    delete g_pManager;
}
#endif /* SHOULD_WE_CLEANUP */

BOOL MethodDescPrestubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    //
    // First, check if it looks like a stub.
    //

#ifdef _X86_
    if (*(BYTE*)stubStartAddress != 0xe8 &&
        *(BYTE*)stubStartAddress != 0xe9 &&
        *(BYTE*)stubStartAddress != X86_INSTR_HLT    // may be in special interlocked replace window for cpus not supporting cmpxchg 
        )
        return FALSE;
#endif

    return m_rangeList.IsInRange(stubStartAddress);
}

BOOL MethodDescPrestubManager::DoTraceStub(const BYTE *stubStartAddress, 
                                           TraceDestination *trace)
{
    trace->type = TRACE_STUB;

#ifdef _X86_
    if (stubStartAddress[0] == 0xe9)
    {
        trace->address = (BYTE*)getJumpTarget(stubStartAddress);
    }
    else
    {
#else
    {
#endif _X86_
        MethodDesc *md = MethodDesc::GetMethodDescFromStubAddr((BYTE*)stubStartAddress);

        // If the method is not IL, then we patch the prestub because no one will ever change the call here at the
        // MethodDesc. If, however, this is an IL method, then we are at risk to have another thread backpatch the call
        // here, so we'd miss if we patched the prestub. Therefore, we go right to the IL method and patch IL offset 0
        // by using TRACE_UNJITTED_METHOD.
        if (!md->IsIL())
        {
            trace->address = (BYTE*)getCallTarget(stubStartAddress);
        }
        else
        {
            trace->address = (BYTE*)md;
            trace->type = TRACE_UNJITTED_METHOD;
        }
    }


    LOG((LF_CORDB, LL_INFO10000,
         "MethodDescPrestubManager::DoTraceStub yields TRACE_STUB to 0x%08x "
         "for input 0x%08x\n",
         trace->address, stubStartAddress));

    return TRUE;
}


StubLinkStubManager *StubLinkStubManager::g_pManager = NULL;

BOOL StubLinkStubManager::Init()
{
    g_pManager = new (nothrow) StubLinkStubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);

    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
void StubLinkStubManager::Uninit()
{
    delete g_pManager;
}
#endif /* SHOULD_WE_CLEANUP */

BOOL StubLinkStubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    return m_rangeList.IsInRange(stubStartAddress);
}

BOOL StubLinkStubManager::DoTraceStub(const BYTE *stubStartAddress, 
                                      TraceDestination *trace)
{
    LOG((LF_CORDB, LL_INFO10000,
         "StubLinkStubManager::DoTraceStub: stubStartAddress=0x%08x\n",
         stubStartAddress));
        
    Stub *stub = Stub::RecoverStub((const BYTE *)stubStartAddress);

    LOG((LF_CORDB, LL_INFO10000,
         "StubLinkStubManager::DoTraceStub: stub=0x%08x\n", stub));

    //
    // If this is an intercept stub, we may be able to step
    // into the intercepted stub.  
    //
    // !!! Note that this case should not be necessary, it's just
    // here until I get all of the patch offsets & frame patch
    // methods in place.
    //
    BYTE *pRealAddr = NULL;
    if (stub->IsIntercept())
    {
        InterceptStub *is = (InterceptStub*)stub;
    
        if (*is->GetInterceptedStub() == NULL)
        {
            pRealAddr = *is->GetRealAddr();
            LOG((LF_CORDB, LL_INFO10000, "StubLinkStubManager::DoTraceStub"
                " Intercept stub, no following stub, real addr:0x%x\n",
                pRealAddr));
        }
        else
        {
            stub = *is->GetInterceptedStub();

            pRealAddr = (BYTE*)stub->GetEntryPoint();
    
            LOG((LF_CORDB, LL_INFO10000,
                 "StubLinkStubManager::DoTraceStub: intercepted "
                 "stub=0x%08x, ep=0x%08x\n",
                 stub, stub->GetEntryPoint()));
        }
        _ASSERTE( pRealAddr );
        
        // !!! will push a frame???
        return TraceStub(pRealAddr, trace); 
    }
    else if (stub->IsMulticastDelegate())
    {
        LOG((LF_CORDB, LL_INFO10000,
             "StubLinkStubManager(MCDel)::DoTraceStub: stubStartAddress=0x%08x\n",
             stubStartAddress));
     
        stub = Stub::RecoverStub((const BYTE *)stubStartAddress);

        LOG((LF_CORDB, LL_INFO10000,
             "StubLinkStubManager(MCDel)::DoTraceStub: stub=0x%08x MGR_PUSH to entrypoint:0x%x\n", stub,
             (BYTE*)stub->GetEntryPoint()));

        // If it's a MC delegate, then we want to set a BP & do a context-ful
        // manager push, so that we can figure out if this call will be to a
        // single multicast delegate or a multi multicast delegate
        trace->type = TRACE_MGR_PUSH;
        trace->address = (BYTE*)stub->GetEntryPoint();
        trace->stubManager = this;

        return TRUE;
    }
    else if (stub->GetPatchOffset() == 0)
    {
        LOG((LF_CORDB, LL_INFO10000,
             "StubLinkStubManager::DoTraceStub: patch offset is 0!\n"));
        
        return FALSE;
    }
    else
    {
        trace->type = TRACE_FRAME_PUSH;
        trace->address = ((const BYTE *) stubStartAddress) + stub->GetPatchOffset();

        LOG((LF_CORDB, LL_INFO10000,
             "StubLinkStubManager::DoTraceStub: frame push to 0x%08x\n",
             trace->address));

        return TRUE;
    }
}

BOOL StubLinkStubManager::TraceManager(Thread *thread, 
                              TraceDestination *trace,
                              CONTEXT *pContext, 
                              BYTE **pRetAddr)
{
#ifdef _X86_ // references to pContext->Ecx are x86 specific

    // NOTE that we're assuming that this will be called if and ONLY if
    // we're examing a multicast delegate stub.  Otherwise, we'll have to figure out
    // what we're looking iat

    // The return address is at ESP+4. The original call went to the call at the head of the MethodDesc for the
    // delegate. The call at the head of the MethodDesc got us here. So we need to return to the original call site
    // (ESP+4), not to the data in the MethodDesc (ESP).
    (*pRetAddr) = *(BYTE **)(size_t)(pContext->Esp+4);
    
    LOG((LF_CORDB,LL_INFO10000, "SLSM:TM at 0x%x, retAddr is 0x%x\n", pContext->Eip, (*pRetAddr)));

    BYTE **ppbDest = NULL;
    // If we got here, then we're here b/c we're at the start of
    //   a multicast delegate stub - figure out either 
    //  a) this is a single MC, go directly to the dest
    //  b) this is a single, static MC, get the hidden dest & go there
    //  c) this is a multi MC, traverse the list & go to the first
    //  d) this is a multi, static MC, traverse the list & go to the first

    ULONG cbOff = Object::GetOffsetOfFirstField() + 
            COMDelegate::m_pPRField->GetOffset();

    BYTE *pbDel = (BYTE *)(size_t)pContext->Ecx;
    BYTE *pbDelPrev = *(BYTE **)(pbDel + 
                                  Object::GetOffsetOfFirstField() 
                                  + COMDelegate::m_pPRField->GetOffset());

    LOG((LF_CORDB,LL_INFO10000, "StubLinkStubManager(MCDel)::TraceManaager: prev: 0x%x\n", pbDelPrev));

    if (pbDelPrev == NULL)
    {
        if (IsStaticDelegate(pbDel))
        {
            // Then what we've got is actually a static delegate, meaning that the
            // REAL function pointer is hidden away in another field of the delegate.
            ppbDest = GetStaticDelegateRealDest(pbDel);

            // This is a bit of a hack, as I don't really know how this works.  Anyway, a multicast
            // static delegate has it's 
            if (*ppbDest == NULL)
            {
                // "single" multicast delegate - no frames, just a direct call
                ppbDest = GetSingleDelegateRealDest(pbDel);
            }

            // If it's still null, then we can't trace into, so turn this into a step over
            if (*ppbDest == NULL)
                return FALSE;

            LOG((LF_CORDB,LL_INFO10000, "StubLinkStubManager(SingleStaticDel)::TraceManaager: ppbDest: 0x%x "
                "*ppbDest:0x%x (%s::%s)\n", ppbDest, *ppbDest,
                ((MethodDesc*)((*ppbDest)+5))->m_pszDebugClassName,
                ((MethodDesc*)((*ppbDest)+5))->m_pszDebugMethodName));
            
        }
        else
        {
            // "single" multicast delegate - no frames, just a direct call
            ppbDest = GetSingleDelegateRealDest(pbDel);
        }
        
        LOG((LF_CORDB,LL_INFO10000, "StubLinkStubManager(MCDel)::TraceManaager: ppbDest: 0x%x "
            "*ppbDest:0x%x\n", ppbDest, *ppbDest));

        return StubManager::TraceStub( *ppbDest, trace );
    }

    // Otherwise, we're going for the first invoke of the multi case.
    // In order to go to the correct spot, we've got to walk to the
    // back of the list, and figure out where that's going to, then
    // put a breakpoint there...

    while (pbDelPrev)
    {
        pbDel = pbDelPrev;
        pbDelPrev = *(BYTE**)(pbDel + 
                                Object::GetOffsetOfFirstField() 
                                + COMDelegate::m_pPRField->GetOffset());
    }

    if (IsStaticDelegate(pbDel))
    {
        // Then what we've got is actually a static delegate, meaning that the
        // REAL function pointer is hidden away in another field of the delegate.
        ppbDest = GetStaticDelegateRealDest(pbDel);

        LOG((LF_CORDB,LL_INFO10000, "StubLinkStubManager(StaticMultiDel)::TraceManaager: ppbDest: 0x%x "
            "*ppbDest:0x%x (%s::%s)\n", ppbDest, *ppbDest,
            ((MethodDesc*)((*ppbDest)+5))->m_pszDebugClassName,
            ((MethodDesc*)((*ppbDest)+5))->m_pszDebugMethodName));
        
    }
    else
    {
        // "single" multicast delegate - no frames, just a direct call
        LOG((LF_CORDB,LL_INFO10000, "StubLinkStubManager(MultiDel)::TraceManaager: ppbDest: 0x%x "
            "*ppbDest:0x%x (%s::%s)\n", ppbDest, *ppbDest));
        ppbDest = GetSingleDelegateRealDest(pbDel);
    }

    return StubManager::TraceStub(*ppbDest,trace);
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - StubLinkStubManager::TraceManager (clsload.cpp)");
    return FALSE;
#endif // _X86_
}

// If something is a 'mulicast' delegate, then it's actually a static delegate
// if the instance pointer points back to the delegate itself.  This is done
// so that the argument sliding stub (which is what the Function Pointer field
// points to) can get the REAL function pointer out of the delegate, just as
// we do.
//
// Another way to recgonize a static delegate is if the target is in fact a delegate.
//
// @todo Force these to be inline, if the compiler doesn't do it already.
BOOL StubLinkStubManager::IsStaticDelegate(BYTE *pbDel)
{
#ifdef _X86_
    ULONG cbOff = Object::GetOffsetOfFirstField() + 
                COMDelegate::m_pORField->GetOffset();
    BYTE **ppbDest= (BYTE **)(pbDel + cbOff);

    if (*ppbDest == pbDel)
        return TRUE;
    else
    {
        FieldDesc *pFD = COMDelegate::GetOR();
        OBJECTREF target = pFD->GetRefValue(Int64ToObj((__int64)pbDel));
        EEClass *cl = target->GetClass();

        if (cl->IsDelegateClass() || cl->IsMultiDelegateClass())
            return TRUE;
        else
            return FALSE;
    }
#else // !_X86_
    _ASSERTE(!"@TODO IA64 - StubLinkStubManager::IsStaticDelegate (ClsLoad.cpp)");
    return FALSE;
#endif // _X86_
}

BYTE **StubLinkStubManager::GetStaticDelegateRealDest(BYTE *pbDel)
{
    ULONG cbOff = Object::GetOffsetOfFirstField() + 
            COMDelegate::m_pFPAuxField->GetOffset();
    return (BYTE **)(pbDel + cbOff);
}

BYTE **StubLinkStubManager::GetSingleDelegateRealDest(BYTE *pbDel)
{
    // Right where you'd expect it.
    ULONG cbOff = Object::GetOffsetOfFirstField() 
                + COMDelegate::m_pFPField->GetOffset();
    return (BYTE **)(pbDel + cbOff);
}

UpdateableMethodStubManager *UpdateableMethodStubManager::g_pManager = NULL;

BOOL UpdateableMethodStubManager::Init()
{
    g_pManager = new (nothrow) UpdateableMethodStubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);
    if ((g_pManager->m_pHeap = new LoaderHeap(4096,4096, 
                                             &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                             &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize), 
                                             &g_pManager->m_rangeList)) == NULL) {
        delete g_pManager;
        g_pManager = NULL;
        return FALSE;
    }

    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
void UpdateableMethodStubManager::Uninit()
{
        delete g_pManager;
}
#endif /* SHOULD_WE_CLEANUP */

BOOL UpdateableMethodStubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    //
    // First, check if it looks like our stub.
    //

    _ASSERTE(stubStartAddress);

#ifdef _X86_
    if (*(BYTE*)stubStartAddress != 0xe9)
        return FALSE;
#endif

    return m_rangeList.IsInRange(stubStartAddress);
}

BOOL UpdateableMethodStubManager::CheckIsStub(const BYTE *stubStartAddress, const BYTE **stubTargetAddress)
{
    if (!g_pManager || ! g_pManager->CheckIsStub(stubStartAddress))
        return FALSE;
    if (stubTargetAddress)
        *stubTargetAddress = g_pManager->GetStubTargetAddr(stubStartAddress);
    return TRUE;
}
MethodDesc *UpdateableMethodStubManager::Entry2MethodDesc(const BYTE *IP, MethodTable *pMT)
{
    const BYTE *newIP;
    if (CheckIsStub(IP, &newIP))
    {
        MethodDesc *method = IP2MethodDesc(newIP);
        _ASSERTE(method);
        return method;
    }
    else
    {
        return NULL;
    }
}

BOOL UpdateableMethodStubManager::DoTraceStub(const BYTE *stubStartAddress, 
                                           TraceDestination *trace)
{
    trace->type = TRACE_STUB;
    trace->address = (BYTE*)getJumpTarget(stubStartAddress);

    LOG((LF_CORDB, LL_INFO10000,
         "UpdateableMethodStubManager::DoTraceStub yields TRACE_STUB to 0x%08x "
         "for input 0x%08x\n",
         trace->address, stubStartAddress));

    return TRUE;
}

Stub *UpdateableMethodStubManager::GenerateStub(const BYTE *addrOfCode)
{
    if (!g_pManager && !g_pManager->Init())
        return NULL;
        
    BYTE *stubBuf = (BYTE*)g_pManager->m_pHeap->AllocMem(JUMP_ALLOCATE_SIZE);
    if (!stubBuf)
        return NULL;
        
    BYTE *stub = getStubJumpAddr(stubBuf);
    emitJump(stub, (BYTE*)addrOfCode);

    return (Stub*)stub;
}

Stub *UpdateableMethodStubManager::UpdateStub(Stub *currentStub, const BYTE *addrOfCode)
{
    _ASSERTE(g_pManager->CheckIsStub((BYTE*)currentStub));
    updateJumpTarget((BYTE*)currentStub, (BYTE*)addrOfCode);
    return currentStub;
}


HRESULT ClassLoader::InsertModule(Module *pModule, mdFile kFile, DWORD* pdwIndex)
{
    DWORD dwIndex;
    
    LOCKCOUNTINCL("InsertModule in clsload.hpp");
    EnterCriticalSection(&m_ModuleListCrst);
    
    if (m_pHeadModule) {
        // Already added as manifest file
        if (m_pHeadModule == pModule)
            goto ErrExit;
        
        Module *pPrev;
        dwIndex = 1;
        
        // Must insert at end of list, because each module has an index, and it must never change
        for (pPrev = m_pHeadModule; pPrev->GetNextModule(); pPrev = pPrev->GetNextModule()) {
            // Already added
            if (pPrev == pModule) 
                goto ErrExit;
            
            dwIndex++;
        }
        
        pPrev->SetNextModule(pModule);
    }
    else {
        // This will be the first module in the list
        m_pHeadModule = pModule;
        dwIndex = 0;
    }
    
    pModule->SetNextModule(NULL);
    
    FastInterlockIncrement((LONG*)&m_cUnhashedModules);
    
    LeaveCriticalSection(&m_ModuleListCrst);
    LOCKCOUNTDECL("InsertModule in clsload.hpp");
    *pdwIndex = dwIndex;
    
    if (kFile != mdFileNil)
        m_pAssembly->m_pManifest->StoreFile(kFile, pModule);
    
    return S_OK;
    
 ErrExit:
    // Found a duplicate
    
    if (kFile == mdFileNil) {
        LeaveCriticalSection(&m_ModuleListCrst);
        LOCKCOUNTDECL("InsertModule in clsload.hpp");
    }
    else {
        mdToken mdFoundFile = m_pAssembly->m_pManifest->FindFile(pModule);
        LeaveCriticalSection(&m_ModuleListCrst);
        LOCKCOUNTDECL("InsertModule in clsload.hpp");
        
        // There are probably two File defs in the metadata for the same
        // file, and both are being loaded.  (Or maybe there's a File def
        // for the manifest file.)
        if (mdFoundFile != kFile) {
            STRESS_ASSERT(0);   // TODO remove after bug 93333 is fixed
            BAD_FORMAT_ASSERT(!"Invalid File entry");
            return COR_E_BADIMAGEFORMAT;
        }
    }
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\codeman.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// codeman.cpp - a managment class for handling multiple code managers
// Created 2/20/95 - larrysu, adapted from jitifc.cpp
//
//
#include "common.h"
#include "jitInterface.h"
#include "corjit.h"
#include "EETwain.h"
#include "EEConfig.h"
#include "excep.h"
#include "EjitMgr.h"
#include "appdomain.hpp"
#include "codeman.h"
#include "minidumppriv.h"

#include "FJIT_EETwain.h"
#include "wsperf.h"
#include "jitperf.h"
#include "ShimLoad.h"
#include <dump-tables.h>
Crst *ExecutionManager::m_pExecutionManagerCrst = NULL;
RangeSection *ExecutionManager::m_RangeTree = NULL;
Crst *ExecutionManager::m_pRangeCrst = NULL;
IJitManager *ExecutionManager::m_pJitList = NULL;
EECodeManager *ExecutionManager::m_pDefaultCodeMan = NULL;
BYTE ExecutionManager::m_ExecutionManagerCrstMemory[sizeof(Crst)];
BYTE ExecutionManager::m_fFailedToLoad = 0x00;
RangeSection *ExecutionManager::m_pLastUsedRS = NULL;
volatile LONG ExecutionManager::m_dwReaderCount = 0;
volatile LONG ExecutionManager::m_dwWriterLock = 0;

// We cannot syncronize pre-emptive mode readers like we can for cooperative readers, so use a reader/writer lock to drain all
// the pre-emptive readers so can delete from the structures

#define READER_INCREMENT(pReaderCount, pWriterLock)  \
    __try {  \
		InterlockedIncrement((LPLONG)(pReaderCount)); \
		while (*pWriterLock) \
			__SwitchToThread(0); \
			

#define READER_DECREMENT(pReaderCount) \
    } \
    __finally \
    { \
		InterlockedDecrement((LPLONG)(pReaderCount)); \
    }
   
//**********************************************************************************
//  IJitManager
//**********************************************************************************
IJitManager::IJitManager()
{
    m_IsDefaultCodeMan = FALSE;
    m_runtimeSupport = NULL;
    m_JITCompiler = NULL;
}

IJitManager::~IJitManager()
{
   // Unload the JIT DLL
   if ((m_runtimeSupport) && (!m_IsDefaultCodeMan))
        delete m_runtimeSupport;
   m_runtimeSupport = NULL;
   if (m_JITCompiler) {
        // @TODO - LBS
        // We need to get support for us being shutdown through CoUnitialize
        // When this happens we can fix this !RunningOnWin95 hack
        if(!g_fProcessDetach || !RunningOnWin95())
            FreeLibrary(m_JITCompiler);
    }
    // Null all pointers to make sure checks fail!
    m_JITCompiler = NULL;

}

BOOL IJitManager::LoadJIT(LPCWSTR szJITdll)
{
    Thread  *thread = GetThread();
    BOOL     toggleGC = (thread && thread->PreemptiveGCDisabled());
    BOOL     res = TRUE;

    if (toggleGC)
        thread->EnablePreemptiveGC();

    DWORD lgth = _MAX_PATH + 1;
    WCHAR wszFile[_MAX_PATH + 1];
    if(FAILED(GetInternalSystemDirectory(wszFile, &lgth)))
        goto leav;
    wcscat(wszFile, szJITdll);

    m_JITCompiler = WszLoadLibrary(wszFile);

    if (!m_JITCompiler)
    {
        res = FALSE;
        goto leav;
    }

    {
        typedef ICorJitCompiler* (__stdcall* pGetJitFn)();
        pGetJitFn getJitFn = (pGetJitFn) GetProcAddress(m_JITCompiler, "getJit");

        DWORD cpuType = GetSpecificCpuType();
        switch (cpuType & 0x0000FFFF)
        {
        case 5:
            g_pConfig->SetCpuFlag(CORJIT_FLG_TARGET_PENTIUM);
            break;
        case 6:
            g_pConfig->SetCpuFlag(CORJIT_FLG_TARGET_PPRO);
            break;
        case 0xF:
            g_pConfig->SetCpuFlag(CORJIT_FLG_TARGET_P4);
            break;
        default:
            g_pConfig->SetCpuFlag(0);
            break;
        }

        // The upper 16 bits of cpuType contain the CPU capabilities.  If bits
        // 15 (CMOV) and bit 0 (FPU) are set, then we can use the CMOV and FCOMI
        // instructions.

        if (((cpuType >> 16) & 0x8001) == 0x8001)
        {
            g_pConfig->SetCpuCapabilities(CORJIT_FLG_USE_CMOV |
                                          CORJIT_FLG_USE_FCOMI);
        }


        if (getJitFn)
            m_jit = (*getJitFn)();

        if (!m_jit)
        {
            res = FALSE;
            goto leav;
        }
    }

leav:
    if (toggleGC)
        thread->DisablePreemptiveGC();

    return res;
}

BOOL IJitManager::UpdateFunction(MethodDesc *pFunction, COR_ILMETHOD *pNewCode)
{
    // Note that this will result in our re-DoPrestub'ing the method, so 
    // all interceptors (security, remoting) will be redone.
    _ASSERTE(pNewCode != 0 || pFunction->IsNDirect());

    if (! pFunction->IsNDirect()) {
        // subtract base because code expects an RVA and will add base back to get actual address
        DWORD dwNewDescr = (DWORD)((BYTE *)pNewCode - pFunction->GetModule()->GetILBase()); // @TODO - LBS pointer math

        pFunction->SetRVA(dwNewDescr);
    }

    // reset any flags relevant to the old code
    pFunction->ClearFlagsOnUpdate();

    //
    // TODO_IA64: this code looks very dubious...
    //
    // What we're trying to do here is restore the MethodDesc to it's initial, pristine
    // state.  We can just thwack stuff since we've got the runtime frozen for debugging -
    // If anyone else knows a better way of doing this, I"d be happy to use it...
    //
    // Note that this only works since we've very carefullly made sure that _all_ references 
    // to the Method's code must be to the call/jmp blob immediately in front of the 
    // MethodDesc itself.  See MethodDesc::IsEnCMethod()
    SLOT *callAddr = ((SLOT*)pFunction)-1;
    InterlockedExchangePointer((void**)callAddr, 
        (void *)((size_t)ThePreStub()->GetEntryPoint() - ((size_t)callAddr+ sizeof(UINT32))) );
    *(((BYTE*)pFunction)-5) = 0xe8;  // thwack this back to "CALL"
    
    return TRUE;
}

BOOL IJitManager::JITFunction(MethodDesc *pFunction)
{
#ifdef _DEBUG
        fprintf(stderr, "ICodeManager::JITFunction\n");
#endif

        // JIT the new code if not already jitted

        return TRUE;
}

BOOL IJitManager::ForceReJIT(MethodDesc *pFunction)
{
    // Same caveats as UpdateFunction also apply.
    // This method currently does not deal with interceptors therefor the following...

    // @TODO - LBS
    // Check for interceptors and then walk the list of interceptors to put the code
    // off the last interceptor in the chain.  Currently we just wire the code in and
    // do not check for interceptors.  Also the real way I want this to work is to build
    // a Edit&Continue stub.  Currently I am just using the prestub.
    _ASSERTE(pFunction->GetModule()->SupportsUpdateableMethods());

    _ASSERTE(! pFunction->IsNDirect());

    // Get the address of the stub.
    const BYTE *pAddrOfCode = pFunction->GetAddrofCode();

    // If it really is a pre-stub, update it.
    if (UpdateableMethodStubManager::CheckIsStub(pAddrOfCode, NULL))
    {
        // Restore the RVA for the JIT.
        ULONG dwRVA;
        pFunction->GetMDImport()->GetMethodImplProps(pFunction->GetMemberDef(), &dwRVA, NULL);
        pFunction->SetRVA(dwRVA);
        // reset any flags relevant to the old code
        pFunction->ClearFlagsOnUpdate();
        // make our stub just jump to the prestub to force rejit
        UpdateableMethodStubManager::UpdateStub((Stub*)pAddrOfCode, pFunction->GetPreStubAddr());
    }
    else
        return FALSE;

    return TRUE;
}

// When we unload an appdomain, we need to make sure that any threads that are crawling through
// our heap or rangelist are out. For cooperative-mode threads, we know that they will have
// been stopped when we suspend the EE so they won't be touching an element that is about to be deleted. 
// However for pre-emptive mode threads, they could be stalled right on top of the element we want
// to delete, so we need to apply the reader lock to them and wait for them to drain.
inline IJitManager::ScanFlag IJitManager::GetScanFlags()
{
    Thread *pThread = GetThread();
    if (!pThread || pThread->PreemptiveGCDisabled() || pThread == g_pGCHeap->GetGCThread())
        return ScanNoReaderLock;
    
    return ScanReaderLock;
}

//**********************************************************************************
//  EEJitManager
//**********************************************************************************

EEJitManager::EEJitManager()
{
    m_next = NULL;
    m_pCodeHeap = NULL;
    m_jit = NULL;
    m_pCodeHeapCritSec = NULL;
    m_dwReaderCount = 0;
    m_dwWriterLock = 0;

#ifdef MDTOKEN_CACHE 
    for (int i=0; i<HASH_BUCKETS; i++) 
        m_JitCodeHashTable[i] = NULL;
    m_pJitHeapCacheUnlinkedList = NULL;
#endif 
    
}

EEJitManager::~EEJitManager()
{
    // Free the code heaps!
    ScavengeJitHeaps(TRUE);

    // delete the domain lists
    DomainCodeHeapList **ppList = m_DomainCodeHeaps.Table();
    int count = m_DomainCodeHeaps.Count();
    for (int i=0; i < count; i++)
    {
        if (ppList[i])
            delete ppList[i];
    }

    // Teminate the critial section!
    delete m_pCodeHeapCritSec;

    m_next = NULL;
}


BOOL EEJitManager::LoadJIT(LPCWSTR wzJITdll)
{
    _ASSERTE((m_jit == NULL) && (m_JITCompiler == NULL));

    // These both should be null to call LoadJIT!
    if ((m_jit != 0) || (m_JITCompiler != 0))
        return FALSE;

    m_pCodeHeapCritSec = new (&m_CodeHeapCritSecInstance) Crst("JitMetaHeapCrst",CrstSingleUseLock);

    BOOL retval = IJitManager::LoadJIT(wzJITdll);
    if (!retval) {
        delete m_pCodeHeapCritSec;
        m_pCodeHeapCritSec = NULL;
    }
    return retval;
}




///////////////////////////////////////////////////////////////////////
////   some mmgr stuff for JIT, especially for jit code blocks
///////////////////////////////////////////////////////////////////////
//
// In order to quickly find the start of a jit code block
// we keep track of all those positions via a map.
// Each entry in this map represents 32 byte (a bucket) of the code heap.
// We make the assumption that no two code-blocks can start in
// the same 32byte bucket;
// Additionally we assume that every code header is DWORD aligned.
// Because we cannot guarantee that jitblocks always start at
// multiples of 32 bytes we cannot use a simple bitmap; instead we
// use a nibble (4 bit) per bucket and encode the offset of the header
// inside the bucket (in DWORDS). In order to make initialization
// easier we add one to the real offset, a nibble-value of zero
// means that there is no header start in the resp. bucket.
// In order to speed up "backwards scanning" we start numbering
// nibbles inside a DWORD from the highest bits (28..31). Because
// of that we can scan backwards inside the DWORD with right shifts.

HeapList *EEJitManager::NewCodeHeap(LoaderHeap *pJitMetaHeap, size_t MaxCodeHeapSize)
{
    HeapList *pHp = NULL;
    LoaderHeap *pHeap = NULL;

    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());

    //
    // @todo ia64: fix LoaderHeap to take size_t
    //
    size_t cacheSize = 0;

#ifdef MDTOKEN_CACHE
    cacheSize = GetCodeHeapCacheSize (MaxCodeHeapSize + sizeof(HeapList));
#endif // #ifdef MDTOKEN_CACHE

    if ((pHeap = new LoaderHeap((DWORD)MaxCodeHeapSize + sizeof(HeapList) + cacheSize, PREINIT_SIZE, 
                                &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize))
                                ) != NULL)
    {
        WS_PERF_ADD_HEAP(EEJIT_HEAP, pHeap);
        WS_PERF_SET_HEAP(EEJIT_HEAP);

        pHp = (HeapList *)pHeap->AllocMem(sizeof(HeapList), TRUE);
        if (pHp)
        {
            WS_PERF_UPDATE_DETAIL("EEJitManager:NewCodeHeap:sizeof(HeapList", sizeof(HeapList), pHp);
//            AddName((int)pHp & 0xFFFFF000, "JitHeap");

#ifdef MDTOKEN_CACHE
            pHp->pCacheSpacePtr = (PBYTE)pHeap->AllocMem (cacheSize, TRUE /* GrowHeap */);
            pHp->bCacheSpaceSize = (pHp->pCacheSpacePtr == NULL) ? 0 : cacheSize;
#endif // #ifdef MDTOKEN_CACHE

            size_t heapSize = pHeap->GetReservedBytesFree();
            _ASSERTE (heapSize >= MaxCodeHeapSize);

            WS_PERF_SET_HEAP(EEJITMETA_HEAP);
			pHp->pHdrMap = (DWORD*)pJitMetaHeap->AllocMem(HEAP2MAPSIZE(heapSize+0x1000));
            if (pHp->pHdrMap)
            {
                WS_PERF_UPDATE_DETAIL("EEJitManager:NewCodeHeap:HEAP2MAPSize", HEAP2MAPSIZE(MaxCodeHeapSize+0x1000), pHp->pHdrMap);

                pHp->startAddress = pHp->endAddress = (PBYTE)pHp + sizeof(HeapList) 
#ifdef MDTOKEN_CACHE
                                                        + pHp->bCacheSpaceSize
#endif // #ifdef MDTOKEN_CACHE
                    ;

                pHp->pHeap = pHeap;
                pHp->hpNext = m_pCodeHeap;
                pHp->mapBase = (PBYTE)((SIZE_T)pHp->startAddress & ~0xfff);  // round to next lower 4K
                pHp->maxCodeHeapSize = heapSize;

                // We do not need to memset this memory, since VirtualAlloc() guarantees that the memory is zero.
                // Furthermore, if we avoid writing to it, these pages don't come into our working set

                pHp->changeStart = 0;
                pHp->changeEnd = 0;
                pHp->cBlocks = 0;
                if (!ExecutionManager::AddRange((LPVOID) pHp, &pHeap->GetAllocPtr()[heapSize],this, NULL))
                {
                    delete pHeap;
                    return FALSE;
                }
#ifdef MDTOKEN_CACHE
                // Since the virtualalloc'ed memory is MEM_RESERVED in the LoaderHeap at a page boundary the
                // following assertion shold be true. If you added some structs between the start of the LoaderHeap and the startAddress
                // then update this ASSERTEand the following if condition appropriately.
                _ASSERTE (((size_t)(pHp->startAddress -  (sizeof(HeapList) + pHp->bCacheSpaceSize + sizeof(LoaderHeapBlock))) & 0x00000FFF) == 0);
                _ASSERTE (pHp->pHeap->GetFirstBlockVirtualAddress() && (((size_t)pHp->pHeap->GetFirstBlockVirtualAddress() & 0x00000FFF) == 0));
                
                // Check if the LoaderHeap's start address is 64 KB aligned. Our Jit code heap cache works iff this is true.
                if (((size_t)pHp->pHeap->GetFirstBlockVirtualAddress() & 0x0000FFFF) == 0)
                {
                    AddRangeToJitHeapCache (pHp->startAddress, pHp->startAddress+pHp->maxCodeHeapSize, pHp);
                }
#endif // #ifdef MDTOKEN_CACHE
                m_pCodeHeap = pHp;
#ifdef MDTOKEN_CACHE
#ifdef _DEBUG
                DebugCheckJitHeapCacheValidity ();
#endif // _DEBUG
#endif // #ifdef MDTOKEN_CACHE
                return pHp;
            }
            // We use to heap free here now we will just leak this into the loaderheap which will clean it up.
        }
        delete pHeap;
    }
    return NULL;

}

CodeHeader* EEJitManager::allocCode(MethodDesc* pFD, size_t blockSize)
{
    CodeHeader * pCodeHdr = NULL;

    blockSize += sizeof(CodeHeader);

#ifdef _X86_
    // Normally 4 bytes into a 8-byte align area is the bad alignment
    unsigned badAlign = 4;

    if (g_pConfig->GenOptimizeType() != OPT_SIZE)
    {
        // The Intel x86 architecture rules and guidelines for alignment
        // of method entry points:
        //
        //  1. Method entry points should be 16-byte aligned when less
        //  than 8-bytes away from a 16-byte boundry.
        //
        // Since AllocMem already returns a 4-byte aligned value and we
        // need to 8-byte align the method entry point, so that the JIT
        // can inturn 8-byte align the loop entry headers.
        //
        // Thus we always ask for 4 extra bytes so that we can make this
        // adjustment when necessary.
        ///
        blockSize += sizeof(int);

        // We expect that the sizeof a CodeHeader is a multiple of 4
        _ASSERTE((sizeof(CodeHeader) % sizeof(int)) == 0);

        // Normally 4 bytes into a 8-byte align area is the bad alignment
        // but since we add a CodeHeader structure immediately before
        // the method entry point we have to calculate the badAlign value
        badAlign = (badAlign - sizeof(CodeHeader)) & 0x7;
    }
#endif

    // Ensure minimal size
    if (blockSize < BBT)
        blockSize = BBT;

    m_pCodeHeapCritSec->Enter();


   HeapList *pCodeHeap = GetCodeHeap(pFD);

    if (!pCodeHeap)
        return NULL;

    WS_PERF_SET_HEAP(EEJIT_HEAP);
 
    size_t mem = (size_t) (pCodeHeap->pHeap)->AllocMem(blockSize,FALSE);
    if (mem == 0)
    {
        // The current heap couldn't handle our request. Let's try a new heap.
        pCodeHeap = NewCodeHeap(pFD, blockSize);
		if (pCodeHeap == 0)
			return NULL;

        WS_PERF_SET_HEAP(EEJIT_HEAP);
        mem = (size_t)(pCodeHeap->pHeap)->AllocMem(blockSize,FALSE);
		_ASSERTE(mem);
    }

    if (mem != 0)
    {
        // We expect mem to be at least DWORD aligned
        _ASSERTE((mem & 0x3) == 0);

#ifdef _X86_
        if (g_pConfig->GenOptimizeType() != OPT_SIZE)
        {
            if ((mem & 0x7) == badAlign)
            {
                // Use the extra 4 bytes that we allocated
                // So that the code section is always 8-byte aligned
                mem += 4;
            }
        }
#endif

        pCodeHdr = (CodeHeader *)(mem);

        WS_PERF_UPDATE_DETAIL("EEJitManager:allocCode:blocksize", blockSize, pCodeHdr);
        JIT_PERF_UPDATE_X86_CODE_SIZE(blockSize);

        pCodeHeap->changeStart++;               // mark that we are about to make changes

        if ((PBYTE)pCodeHdr < pCodeHeap->mapBase)
        {
            PBYTE newBase = (PBYTE)((size_t)pCodeHdr & ~0xfff);

            _ASSERTE((size_t)(pCodeHeap->endAddress-newBase) < pCodeHeap->maxCodeHeapSize+0x1000);
            // we have to shift the nibble map and re-adjust mapBase
            MoveMemory((pCodeHeap->pHdrMap)+HEAP2MAPSIZE(pCodeHeap->mapBase-newBase),
                        pCodeHeap->pHdrMap,
                        HEAP2MAPSIZE(RD2PAGE(pCodeHeap->endAddress-pCodeHeap->mapBase))
                        );
            // clear everything in front of the start of old (shifted) map
            // OR just the area that has been previously used
            memset(pCodeHeap->pHdrMap, 0,
                    min(HEAP2MAPSIZE(pCodeHeap->mapBase-newBase),
                        HEAP2MAPSIZE(RD2PAGE(pCodeHeap->endAddress-pCodeHeap->mapBase)))
                   );
            pCodeHeap->mapBase = newBase;
        }
        pCodeHdr->phdrJitEHInfo= NULL;
        pCodeHdr->phdrJitGCInfo = NULL;
        pCodeHdr->hdrMDesc = pFD;

        SETHEADER(pCodeHeap->pHdrMap, ((PBYTE)pCodeHdr-pCodeHeap->mapBase));

        if ((PBYTE)pCodeHdr < pCodeHeap->startAddress)
            pCodeHeap->startAddress = (PBYTE)pCodeHdr;
        if (((size_t) pCodeHdr)+blockSize > (size_t)pCodeHeap->endAddress)
            pCodeHeap->endAddress = (PBYTE)((size_t)pCodeHdr+blockSize);

        pCodeHeap->cBlocks++;

        pCodeHeap->changeEnd++;
    }
    else
    {
        return NULL;
    }

    m_pCodeHeapCritSec->Leave();
    return (pCodeHdr);
}

EEJitManager::DomainCodeHeapList *EEJitManager::GetCodeHeapList(BaseDomain *pDomain)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());

    DomainCodeHeapList **ppList = m_DomainCodeHeaps.Table();
    DomainCodeHeapList *pList = NULL;
    int count = m_DomainCodeHeaps.Count();
    for (int i=0; i < count; i++)
    {
        if (ppList[i]->m_pDomain == pDomain ||
            ! ppList[i]->m_pDomain->CanUnload() && ! pDomain->CanUnload())
        {
            pList = ppList[i];
        }
    }
    return pList;
}

HeapList* EEJitManager::GetCodeHeap(MethodDesc *pMD)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());

    BaseDomain *pDomain = pMD->GetClass()->GetDomain();
    _ASSERTE(pDomain);

    // loop through the m_DomainCodeHeaps to find the AD
    // if not found, then create it
    DomainCodeHeapList *pList = GetCodeHeapList(pDomain);
    if (pList)
    {
        _ASSERTE(pList->m_CodeHeapList.Count() > 0);
        // last one is always the most current
        return pList->m_CodeHeapList[pList->m_CodeHeapList.Count()-1];
    }
    // not found so need to create one
    pList = new DomainCodeHeapList();
    if (! pList)
        return NULL;

    DomainCodeHeapList **ppList = m_DomainCodeHeaps.Append();

    if (! ppList) {
        delete pList;
        return NULL;
    }

    pList->m_pDomain = pDomain;
    *ppList = pList;
    return NewCodeHeap(pList, 0);
}

HeapList* EEJitManager::NewCodeHeap(MethodDesc *pMD, size_t MaxCodeHeapSize)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());

    BaseDomain *pDomain = pMD->GetClass()->GetDomain();
    _ASSERTE(pDomain);

    // create a new code heap for the given AD

    DomainCodeHeapList *pList = GetCodeHeapList(pDomain);
    _ASSERTE(pList);
    return NewCodeHeap(pList, MaxCodeHeapSize);
}

HeapList* EEJitManager::NewCodeHeap(DomainCodeHeapList *pADHeapList, size_t MaxCodeHeapSize)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());
    // create a new code heap for the given AD

    HeapList **ppHeapList = pADHeapList->m_CodeHeapList.Append();
    if (! ppHeapList)
        return NULL;
    HeapList *pHeapList = NewCodeHeap(pADHeapList->m_pDomain->GetLowFrequencyHeap(), MaxCodeHeapSize);
    if (! pHeapList)
        return NULL;
    *ppHeapList = pHeapList;
    return pHeapList;
}

LoaderHeap *EEJitManager::GetJitMetaHeap(MethodDesc *pMD)
{
    BaseDomain *pDomain = pMD->GetClass()->GetDomain();
    _ASSERTE(pDomain);
    
    return pDomain->GetLowFrequencyHeap();
}

BYTE* EEJitManager::allocGCInfo(CodeHeader* pCodeHeader, DWORD blockSize)
{
    WS_PERF_SET_HEAP(EEJITMETA_HEAP);
    pCodeHeader->phdrJitGCInfo = (BYTE*) GetJitMetaHeap(pCodeHeader->hdrMDesc)->AllocMem(blockSize);
    WS_PERF_UPDATE_DETAIL("EEJitManager:allocGCInfo:blocksize", blockSize, pCodeHeader->phdrJitGCInfo);
    JIT_PERF_UPDATE_X86_CODE_SIZE(blockSize);
    return(pCodeHeader->phdrJitGCInfo);
}

EE_ILEXCEPTION* EEJitManager::allocEHInfo(CodeHeader* pCodeHeader, unsigned numClauses)
{
    // Note - pCodeHeader->phdrJitEHInfo - sizeof(unsigned) contains the number of EH clauses
    WS_PERF_SET_HEAP(EEJITMETA_HEAP);
    BYTE *EHInfo = (BYTE *)GetJitMetaHeap(pCodeHeader->hdrMDesc)->AllocMem(EE_ILEXCEPTION::Size(numClauses) + sizeof(unsigned));
    pCodeHeader->phdrJitEHInfo = (EE_ILEXCEPTION*) (EHInfo + sizeof(unsigned));
    JIT_PERF_UPDATE_X86_CODE_SIZE(EE_ILEXCEPTION::Size(numClauses) + sizeof(unsigned));
    WS_PERF_UPDATE_DETAIL("EEJitManager:allocEHInfo:blocksize", EE_ILEXCEPTION::Size(numClauses) + sizeof(unsigned), EHInfo);
    pCodeHeader->phdrJitEHInfo->Init(numClauses);
    *((unsigned *)EHInfo) = numClauses;
    return(pCodeHeader->phdrJitEHInfo);
}

// creates an enumeration and returns the number of EH clauses
unsigned EEJitManager::InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState)
{
    *pEnumState = 1;     // since the EH info is not compressed, the clause number is used to do the enumeration
    BYTE *EHInfo = (BYTE *)((CodeHeader*)MethodToken)->phdrJitEHInfo;
    if (!EHInfo)
        return 0;
    EHInfo -= sizeof(unsigned);
    return *((unsigned *)EHInfo);
}

EE_ILEXCEPTION_CLAUSE*  EEJitManager::GetNextEHClause(METHODTOKEN MethodToken,
                              //unsigned clauseNumber,
                              EH_CLAUSE_ENUMERATOR* pEnumState,
                              EE_ILEXCEPTION_CLAUSE* pEHClauseOut)
{
    EE_ILEXCEPTION* pExceptions;

    pExceptions = ((CodeHeader*)MethodToken)->phdrJitEHInfo;
    _ASSERTE(sizeof(EE_ILEXCEPTION_CLAUSE) == sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    (*pEnumState)++;
    return pExceptions->EHClause((unsigned) *pEnumState - 2);
}

void EEJitManager::ResolveEHClause(METHODTOKEN MethodToken,
                              //unsigned clauseNumber,
                              EH_CLAUSE_ENUMERATOR* pEnumState,
                              EE_ILEXCEPTION_CLAUSE* pEHClauseOut)
{
    Module *pModule = NULL;
    EE_ILEXCEPTION* pExceptions;

    pExceptions = ((CodeHeader*)MethodToken)->phdrJitEHInfo;
    pModule = ((CodeHeader*)MethodToken)->hdrMDesc->GetModule();
    // use -2 because need to go back to previous one, as enum will have already been updated
    _ASSERTE(*pEnumState >= 2);
    EE_ILEXCEPTION_CLAUSE *pClause = pExceptions->EHClause((unsigned) *pEnumState - 2);
    _ASSERTE(IsTypedHandler(pClause));

    m_pCodeHeapCritSec->Enter();
    // check first as if has already been resolved then token will have been replaced with EEClass
    if (! HasCachedEEClass(pClause)) {
        // Resolve to class if defined in an *already loaded* scope.
        NameHandle name(pModule, (mdToken)(size_t)pClause->pEEClass); // @TODO WIN64 - pointer truncation
        name.SetTokenNotToLoad(tdAllTypes);
        TypeHandle typeHnd = pModule->GetClassLoader()->LoadTypeHandle(&name);
        if (!typeHnd.IsNull()) {
            pClause->pEEClass = typeHnd.GetClass();
            SetHasCachedEEClass(pClause);
        }
    }
    if (HasCachedEEClass(pClause))
        // only copy if actually resolved it. Either we did it or another thread did
        copyExceptionClause(pEHClauseOut, pClause);

    m_pCodeHeapCritSec->Leave();
}


void EEJitManager::RemoveJitData (METHODTOKEN token) //CodeHeader* pCHdr)
{
    CodeHeader* pCHdr = (CodeHeader*) token;

    HeapList *pHp = m_pCodeHeap;

    m_pCodeHeapCritSec->Enter();

    while (pHp && ((pHp->startAddress > (PBYTE)pCHdr) ||
                    (pHp->endAddress < (PBYTE)((size_t)pCHdr+sizeof(CodeHeader))) ))
    {
        pHp = pHp->hpNext;
    }

    _ASSERTE(pHp);

    _ASSERTE(pHp->pHdrMap);
    _ASSERTE(pHp->cBlocks);

    pHp->changeStart++;

    RESETHEADER(pHp->pHdrMap, (size_t)((PBYTE)pCHdr-pHp->mapBase));

    pHp->cBlocks--;

    pHp->changeEnd++;

    m_pCodeHeapCritSec->Leave();

    SafeDelete (pCHdr->phdrJitGCInfo);
    BYTE *EHInfo = (BYTE *)pCHdr->phdrJitEHInfo;
    if (EHInfo)
        SafeDelete (EHInfo - sizeof(unsigned));

    // We do not delete each codeheder because when we destroy pHeap all its piecies will be blown away
    return;
}

// appdomain is being unloaded, so delete any data associated with it. We have to do this in two stages.
// On the first stage, we remove the elements from the list. On the second stage, which occurs after a GC
// we know that only threads who were in preemptive mode prior to the GC could possibly still be looking
// at an element that is about to be deleted. All such threads are guarded with a reader count, so if the
// count is 0, we can safely delete, otherwise we must add to the cleanup list to be deleted later. We know 
// there can only be one unload at a time, so we can use a single var to hold the unlinked, but not deleted,
// elements.
void EEJitManager::Unload(AppDomain *pDomain)
{
    CLR_CRST(m_pCodeHeapCritSec);

    DomainCodeHeapList **ppList = m_DomainCodeHeaps.Table();
    int count = m_DomainCodeHeaps.Count();
    int i;
    for (i=0; i < count; i++) {
        if (ppList[i]->m_pDomain == pDomain) {
            break;
        }
    }

    if (i == count)
        return;

    DomainCodeHeapList *pList = ppList[i];
    m_DomainCodeHeaps.DeleteByIndex(i);

    // pHeapList is allocated in pHeap, so only need to delete the LoaderHeap itself
    count = pList->m_CodeHeapList.Count();
    for (i=0; i < count; i++) {
        HeapList *pHeapList = pList->m_CodeHeapList[i];
        DeleteCodeHeap(pHeapList);
    }

    // this is ok to do delete as anyone accessing the DomainCodeHeapList structure holds the critical section.
    delete pList;
}

EEJitManager::DomainCodeHeapList::DomainCodeHeapList()
{
    m_pDomain = NULL;
}

EEJitManager::DomainCodeHeapList::~DomainCodeHeapList()
{
}

//static BOOL bJitHeapShutdown = FALSE;

void EEJitManager::DeleteCodeHeap(HeapList *pHeapList)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());

#ifdef MDTOKEN_CACHE
#ifdef _DEBUG    
    DebugCheckJitHeapCacheValidity ();
#endif // #ifdef _DEBUG
#endif // #ifdef MDTOKEN_CACHE

    // noone can update the m_pCodeHeap except under the CritSec, so this is ok
    if (m_pCodeHeap == pHeapList)
        m_pCodeHeap = m_pCodeHeap->hpNext;
    else
    {
        HeapList *pHp = m_pCodeHeap;
        while (pHp->hpNext != pHeapList)
        {
            pHp = pHp->hpNext;
            _ASSERTE(pHp != NULL);  // should always find the HeapList
        }
        pHp->hpNext = pHp->hpNext->hpNext;
    }
    ExecutionManager::DeleteRange(pHeapList);
#ifdef MDTOKEN_CACHE
    DeleteJitHeapCache (pHeapList);
    m_pJitHeapCacheUnlinkedList = 0; // automatically deleted when the LoaderHeap is deleted.
#ifdef _DEBUG
    DebugCheckJitHeapCacheValidity ();
#endif // _DEBUG
#endif // #ifdef MDTOKEN_CACHE

    _ASSERTE(m_dwWriterLock == 0);
    // pHeapList is allocated in pHeap, so only need to delete the LoaderHeap itself
   	while (TRUE)
	{
		InterlockedIncrement(&m_dwWriterLock);
		if (m_dwReaderCount == 0)
			break;
		InterlockedDecrement(&m_dwWriterLock);
		__SwitchToThread(0);
	}
	__try
	{
        delete pHeapList->pHeap;
    }
	__finally
	{
		InterlockedDecrement(&m_dwWriterLock);
	}
}

VOID EEJitManager::ScavengeJitHeaps(BOOL bHeapShutdown)
{
    // so can't be doing an unload or anything if suspended for GC
    _ASSERTE(GCHeap::GetSuspendReason() == GCHeap::SUSPEND_FOR_GC);

    HeapList *pHp = m_pCodeHeap;
    HeapList *pHpPrev = NULL;

#ifdef MDTOKEN_CACHE
#ifdef _DEBUG    
    DebugCheckJitHeapCacheValidity ();
#endif // #ifdef _DEBUG
    // this doesn't do any deletions so doesn't need to be in lock
    ScavengeJitHeapCache ();
#endif // #ifdef MDTOKEN_CACHE

    _ASSERTE(m_dwWriterLock == 0);
    while (TRUE)
	{
		InterlockedIncrement(&m_dwWriterLock);
		if (m_dwReaderCount == 0)
			break;
		InterlockedDecrement(&m_dwWriterLock);
		__SwitchToThread(0);
	}
	__try
	{
		while (pHp)
		{
			// during process detach everything should be cleaned-up
			// If this is not a native heap
			if (pHp->pHeap == NULL)
			{
				// Only do this if we are shutting down
				if (bHeapShutdown)
				{

					HeapList *pHpTmp = pHp;     // pHp->next is destroyed in HeapFree

					pHp = pHp->hpNext;

					if (pHpPrev)
						pHpPrev = pHp;
					else
						m_pCodeHeap = pHp;

					delete (pHpTmp->pHdrMap);
					delete (pHpTmp);
				}
				else
				{
					pHpPrev = pHp;
					pHp = pHp->hpNext;
				}
			}
			else
			{
				if (pHp->cBlocks == 0 || bHeapShutdown)
				{
					HeapList *pHpTmp = pHp;     // pHp->next is destroyed in HeapFree

					pHp = pHp->hpNext;

					if (pHpPrev)
						pHpPrev = pHp;
					else
						m_pCodeHeap = pHp;

						delete pHpTmp->pHeap;
				}
				else
				{
					pHpPrev = pHp;
					pHp = pHp->hpNext;
				}
			}
		}
	}
	__finally
	{
		InterlockedDecrement(&m_dwWriterLock);
	}
}

MethodDesc* EEJitManager::JitCode2MethodDesc(SLOT currentPC, ScanFlag scanFlag)
{
    METHODTOKEN methodToken;
    DWORD pcOffset;
    JitCode2MethodTokenAndOffset(currentPC,&methodToken,&pcOffset, scanFlag);
    if (methodToken)
        return JitTokenToMethodDesc(methodToken, scanFlag);   // @TODO: get rid of this call by returning methodToken from JitCode2MethodTokenAndOffset function
    else
        return NULL;
}

void EEJitManager::JitCode2MethodTokenAndOffsetWrapper(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset)
{
    READER_INCREMENT(&m_dwReaderCount, &m_dwWriterLock)
    {
        JitCode2MethodTokenAndOffset(currentPC, pMethodToken, pPCOffset, ScanNoReaderLock);
    }
    READER_DECREMENT(&m_dwReaderCount);
}

void EEJitManager::JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset, ScanFlag scanFlag)
{
    if (scanFlag != IJitManager::ScanNoReaderLock && IJitManager::GetScanFlags() != IJitManager::ScanNoReaderLock)
        JitCode2MethodTokenAndOffsetWrapper(currentPC, pMethodToken, pPCOffset);

    HeapList *pHp = NULL;
    CodeHeader *pCHdr;
    PBYTE tick;
    
#ifdef _DEBUG
    HeapList *pDebugHp = m_pCodeHeap;
    while (pDebugHp) 
    {
        if ( (pDebugHp->startAddress < currentPC) &&
             (pDebugHp->endAddress >= currentPC) )
        {
            break;
        }
        pDebugHp = pDebugHp->hpNext;
    }
#endif // _DEBUG

#ifdef MDTOKEN_CACHE
    HashEntry* hashEntry = NULL;

    size_t index = ((size_t)currentPC & 0x00ff0000) >> 16; 
    LOG((LF_SYNC, LL_INFO10000, "JitCode2MethodTokenAndOffset_CacheCompare: %0x\t%0x\n", index, ((size_t)currentPC) & 0xffff0000));
    hashEntry = m_JitCodeHashTable[index];
    while (hashEntry)
    {
        if (hashEntry->currentPC == ((size_t)currentPC & 0xffff0000)) 
        {
            pHp = hashEntry->pHp;
            _ASSERTE (currentPC >= pHp->startAddress && currentPC <= pHp->endAddress);
            LOG((LF_SYNC, LL_INFO1000, "JitCode2MethodTokenAndOffset_CacheHit: %0x\t%0x\n", (size_t)currentPC & 0xffff0000, pHp));
            goto foundHeader;
        }
        hashEntry = hashEntry->pNext;
    }
#endif

    // Reached here imples that we didn't find the range in the cache or the cache is off
    pHp = m_pCodeHeap;
    while (pHp) 
    {
        if ( (pHp->startAddress < currentPC) &&
             (pHp->endAddress >= currentPC) )
        {
            break;
        }
        pHp = pHp->hpNext;
    }

#ifdef MDTOKEN_CACHE
foundHeader:
#endif // #ifdef MDTOKEN_CACHE

    // Whatever methid we use to ge to the heap node the following should be true
    _ASSERTE ((pHp == pDebugHp) && "JitCode2MethodToken cache incorrect");

    if ((pHp == NULL) || (currentPC < pHp->startAddress) || (currentPC > pHp->endAddress))
    {
        _ASSERTE(!"JC2MD: argument not in jit code range");

        *pMethodToken = NULL;
        return;
    }

    // we now access the nibble-map and are prone to race conditions
    // since we are strictly a "reader" we just use a simple counter
    // scheme to detect if something changed while we were accessing
    // the map. In that case we simply try it again.
    while (1)
    {

        tick = pHp->changeEnd;

        pCHdr = (CodeHeader*) ((size_t)(FindHeader(pHp->pHdrMap,
                                        currentPC-pHp->mapBase))
                                + pHp->mapBase);
        // now check if something has changed while we were accessing
        // the map
        if (tick == pHp->changeStart)
        {
                                    // no changes, we are done
            _ASSERTE(currentPC > (PBYTE)pCHdr);
            *pMethodToken = (METHODTOKEN) pCHdr;
            *pPCOffset = (DWORD)(currentPC - GetCodeBody(pCHdr)); // @TODO - LBS pointer math
            
            return;  // return JitTokenToMethodDesc(pCHdr); // if we change the method signature
        }

        // get in sync with the writers
        // potentially bad (stacking up writers, that will then
        // make changes while we are reading again),
        // but since we have not that many
        // writers, it will be fine
        m_pCodeHeapCritSec->Enter();
        m_pCodeHeapCritSec->Leave();
    }

    return;    
}

void  EEJitManager::ResumeAtJitEH(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)
{
    BYTE* startAddress = JitToken2StartAddress(pCf->GetMethodToken());
    ::ResumeAtJitEH(pCf,startAddress,EHClausePtr,nestingLevel,pThread, unwindStack);
}

int  EEJitManager::CallJitEHFilter(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj)
{
    BYTE* startAddress = JitToken2StartAddress(pCf->GetMethodToken());
    return ::CallJitEHFilter(pCf,startAddress,EHClausePtr,nestingLevel,thrownObj);
}

void   EEJitManager::CallJitEHFinally(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel)
{
    BYTE* startAddress = JitToken2StartAddress(pCf->GetMethodToken());
    ::CallJitEHFinally(pCf,startAddress,EHClausePtr,nestingLevel);
}

///////////////////////////////////////////////////////////////////////
////   some mmgr stuff for JIT, especially for jit code blocks
///////////////////////////////////////////////////////////////////////
//
// In order to quickly find the start of a jit code block
// we keep track of all those positions via a map.
// Each entry in this map represents 32 byte (a bucket) of the code heap.
// We make the assumption that no two code-blocks can start in
// the same 32byte bucket; which is fairly easy to proof because
// the code header alone is already 28 bytes long.
// Additionally we assume that every code header is DWORD aligned.
// Because we cannot guarantee that jitblocks always start at
// multiples of 32 bytes we cannot use a simple bitmap; instead we
// use a nibble (4 bit) per bucket and encode the offset of the header
// inside the bucket (in DWORDS). In order to make initialization
// easier we add one to the real offset, a nibble-value of zero
// means that there is no header start in the resp. bucket.
// In order to speed up "backwards scanning" we start numbering
// nibbles inside a DWORD from the highest bits (28..31). Because
// of that we can scan backwards inside the DWORD with right shifts.


void EEJitManager::NibbleMapSet(DWORD * pMap, size_t pos, DWORD value)
{
    DWORD index = (DWORD)pos/NPDW;
    DWORD mask = ~(DWORD)(0xf0000000 >> ((pos%NPDW)*4));

//  printf("[Set: pos=%5x, val=%d]\n", pos, value);

    value = value << POS2SHIFTCOUNT(pos);

    // assert that we don't overwrite an existing offset
    // (it's a reset or it is empty)
    _ASSERTE(!value || !((*(pMap+index))& ~mask));

    *(pMap+index) = ((*(pMap+index))&mask)|value;
}

DWORD* EEJitManager::FindHeader(DWORD * pMap, size_t addr)
{
    DWORD tmp;

    size_t startPos = ADDR2POS(addr);   // align to 32byte buckets
                                        // ( == index into the array of nibbles)
    DWORD offset = ADDR2OFFS(addr);
                                    // this is the offset inside the bucket + 1


    _ASSERTE(offset == ((offset) & 0xf));

    pMap += (startPos/NPDW);        // points to the proper DWORD of the map

                                    // get DWORD and shift down our nibble

    tmp = (*pMap) >> POS2SHIFTCOUNT(startPos);


    // don't allow equality in the next check (tmp&0xf == offset)
    // there are code blocks that terminate with a call instruction
    // (like call throwobject), i.e. their return address is
    // right behind the code block. If the memory manager allocates
    // heap blocks w/o gaps, we could find the next header in such
    // cases. Therefore we exclude the first DWORD of the header
    // from our search, but since we call this function for code
    // anyway (which starts at the end of the header) this is not
    // a problem.
    if ((tmp&0xf) && ((tmp&0xf) < offset) )
    {
        return POSOFF2ADDR(startPos, tmp&0xf);
    }

    // is there a header in the remainder of the DWORD ?
    tmp = tmp >> 4;

    if (tmp)
    {
        startPos--;
        while (!(tmp&0xf))
        {
            tmp = tmp >> 4;
            startPos--;
        }
        return POSOFF2ADDR(startPos, tmp&0xf);
    }

    // we skipped the remainder of the DWORD,
    // so we must set startPos to the highest position of
    // previous DWORD

    startPos = (startPos/NPDW) * NPDW - 1;

    // skip "headerless" DWORDS

    while (0 == (tmp = *(--pMap)))
        startPos -= NPDW;

    while (!(tmp&0xf))
    {
        tmp = tmp >> 4;
        startPos--;
    }

    return POSOFF2ADDR(startPos, tmp&0xf);
}

//*******************************************************
// Execution Manager
//*******************************************************

// Init statics
BOOL ExecutionManager::Init()
{
    m_pExecutionManagerCrst = new (&m_ExecutionManagerCrstMemory) Crst("ExecuteManCrst", CrstExecuteManLock);
    _ASSERTE(m_pExecutionManagerCrst);

    m_pRangeCrst = ::new Crst("ExecuteManRangeCrst", CrstExecuteManRangeLock);

    m_pDefaultCodeMan = new EECodeManager();

    if (m_pExecutionManagerCrst && m_pDefaultCodeMan)
        return TRUE;
    else
        return FALSE;
}

#ifdef SHOULD_WE_CLEANUP
void ExecutionManager::Terminate()
{
    // Delete Crst

    if (m_pExecutionManagerCrst)
        delete m_pExecutionManagerCrst;
    m_pExecutionManagerCrst = NULL;

    if (m_pRangeCrst) {
        ::delete m_pRangeCrst;
    }

    // Delete default codemanager

    if (m_pDefaultCodeMan)
        delete m_pDefaultCodeMan;
    m_pDefaultCodeMan = NULL;

    // Delete Jit managers

    if (m_pJitList)
    {
        IJitManager *walker = m_pJitList;
        while (walker)
        {
            m_pJitList = walker->m_next;
            delete(walker);
            walker = m_pJitList;
        }
    }
    m_pJitList = NULL;

    // Delete Ranges
    DeleteRanges(m_RangeTree);
    m_RangeTree = NULL;

    return;
}
#endif /* SHOULD_WE_CLEANUP */

IJitManager* ExecutionManager::FindJitManNonZeroWrapper(SLOT currentPC)
{
    IJitManager *ret = NULL;
    
    READER_INCREMENT(&m_dwReaderCount, &m_dwWriterLock)
    {
        ret = FindJitManNonZero(currentPC, IJitManager::ScanNoReaderLock);
    }
    READER_DECREMENT(&m_dwReaderCount);

    return ret;
}

//**************************************************************************
// Find a jit manager from the current locations of the IP
//
IJitManager* ExecutionManager::FindJitManNonZero(SLOT currentPC, IJitManager::ScanFlag scanFlag)
{
    if (scanFlag != IJitManager::ScanNoReaderLock && IJitManager::GetScanFlags() != IJitManager::ScanNoReaderLock)
        FindJitManNonZeroWrapper(currentPC);

    RangeSection* pLastUsedRS = m_pLastUsedRS;
    if (pLastUsedRS &&
        currentPC >= (PBYTE)pLastUsedRS->LowAddress &&
        currentPC <= (PBYTE)pLastUsedRS->HighAddress)
    {
        return pLastUsedRS->pjit;
    }

    RangeSection *pRS = m_RangeTree;
    // Walk the range tree and find the module containing this address

    while (pRS)
    {
        if (currentPC < (PBYTE)pRS->LowAddress)
            pRS=pRS->pleft;
        else if (currentPC > (PBYTE)pRS->HighAddress)
            pRS=pRS->pright;
        else
        {
            m_pLastUsedRS = pRS;
            return pRS->pjit;
        }
    }

    // We know pRS is NULL, so just cast it to the right type.
    return ((IJitManager*) pRS);
}

//**************************************************************************
// Find a code manager for a particular type of code
// ie. IL, Managed Native or OPT_IL
//
IJitManager* ExecutionManager::FindJitForType(DWORD Flags)
{
    if (!m_pJitList)
        return NULL;

    IJitManager *walker = m_pJitList;

    while (walker)
    {
        if (walker->IsJitForType(Flags))
            return walker;
        else
            walker = walker->m_next;
    }
    return walker;
}

/*********************************************************************/
// This static method on the codemanager returns the jit for the appropriate
// code type!
//
IJitManager* ExecutionManager::GetJitForType(DWORD Flags)
{

    // If we have instantiated code managers then we need to walk the and see if one of them handles this codetype.

    IJitManager *jitMgr = FindJitForType(Flags);

    // if we don't have a code manager for this type then we need to instantiate one and add it to the list!
    if (!jitMgr)
    {
        // Take the code manager lock
        // jitMgr->LoadJIT will toggle GC mode.
        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pExecutionManagerCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();
        // See if someone added it while we were taking the lock!
        jitMgr = FindJitForType(Flags);

        if (!jitMgr)
        {
            if (Flags == miManaged_IL_EJIT)
            {
                jitMgr = new EconoJitManager();
                if (jitMgr) 
                {
                    g_miniDumpData.ppbEEJitManagerVtable = ((PBYTE *) jitMgr);
                    // we need the address of the vtable, so...
                    // BUGBUG? We're assuming that the vtable is the first
                    // word of the type.
                    ULONG_PTR* pJit = reinterpret_cast<ULONG_PTR*>(jitMgr);
                    g_ClassDumpData.pEEJitManagerVtable = *pJit;
                }
            }
            else if (COR_IS_METHOD_MANAGED_NATIVE(Flags))
            {
                // @todo - This is an odd code path.  I don't want to fall through the switch
                // so I will so the assignments and free the crst and return here!
                jitMgr = new MNativeJitManager();
                if (jitMgr)
                {
                    g_miniDumpData.ppbMNativeJitManagerVtable = ((PBYTE *) jitMgr);
                    // we need the address of the vtable, so...
                    // BUGBUG? We're assuming that the vtable is the first
                    // word of the type.
                    ULONG_PTR* pJit = reinterpret_cast<ULONG_PTR*>(jitMgr);
                    g_ClassDumpData.pMNativeJitManagerVtable = *pJit;
                }

                if (jitMgr)
                {
                    if (((MNativeJitManager *)jitMgr)->Init())
                    {
                        // @todo - using the default now for all managed code
                        jitMgr->SetCodeManager(m_pDefaultCodeMan, TRUE);
                        jitMgr->SetCodeType(Flags);
                        AddJitManager(jitMgr);
                    }
                    else
                    {
                        delete jitMgr;
                        jitMgr = NULL;
                    }
                }
                // Release the code manager lock
                m_pExecutionManagerCrst->Leave();
                return jitMgr;
            }
            else
            {
                jitMgr = new EEJitManager();
                if (jitMgr)
                {
                    g_miniDumpData.ppbEEJitManagerVtable = ((PBYTE *) jitMgr);
                    // we need the address of the vtable, so...
                    // BUGBUG? We're assuming that the vtable is the first
                    // word of the type.
                    ULONG_PTR* pJit = reinterpret_cast<ULONG_PTR*>(jitMgr);
                    g_ClassDumpData.pEEJitManagerVtable = *pJit;
                }
            }
            if (!jitMgr)
            {
                _ASSERTE(!"Failed to allocate space for the code manager!");
                return NULL;
            }

            // @TODO - LBS
            // I am just using this switch because we only have two jits.
            // I can make this a registry check in the future but it
            // doesn't make sense yet.
            //
    
            switch (Flags & (miCodeTypeMask | miUnmanaged | miManaged_IL_EJIT))
            {
                case (miManaged | miIL):
                    if (!(jitMgr->LoadJIT(L"MSCORJIT.DLL")))
                    {
                        if (!(m_fFailedToLoad & FAILED_JIT))
                        {
                            CorMessageBoxCatastrophic(NULL,
                                  L"Unable to load Jit Compiler (MSCORJIT.DLL)\r\n"
                                  L"File may be missing or corrupt.\r\n"
                                  L"Please check your setup or rerun setup!",
                                  L"Configuration Error",
                                  MB_OK|MB_ICONINFORMATION,
                                  TRUE);
                            m_fFailedToLoad = m_fFailedToLoad | FAILED_JIT;
                        }
                    delete jitMgr;
                    jitMgr = NULL;
                    }
                    else
                    {
                        jitMgr->SetCodeManager(m_pDefaultCodeMan, TRUE);
                        jitMgr->SetCodeType(Flags);
                    }
                    break;
    
                case (miManaged | miOPTIL):
                    if (!(jitMgr->LoadJIT(L"MSCOROJT.DLL")))
                    {
                        if (!(m_fFailedToLoad & FAILED_OJIT))
                        {
                            CorMessageBoxCatastrophic(NULL,
                                  L"Unable to load OptJit Compiler (MSCOROJT.DLL)\r\n"
                                  L"File may be missing or corrupt.\r\n"
                                  L"Please check your setup or rerun setup!",
                                  L"Configuration Error",
                                  MB_OK|MB_ICONINFORMATION,
                                  TRUE);
                            m_fFailedToLoad = m_fFailedToLoad | FAILED_OJIT;
                        }
                    delete jitMgr;
                    jitMgr = NULL;
                    }
                    else
                    {
                        jitMgr->SetCodeManager(m_pDefaultCodeMan,TRUE);
                        jitMgr->SetCodeType(Flags);
                    }
                    break;
    
                // This is the type that is set if we have used the Econo-Jit!!!
                case miManaged_IL_EJIT:
                    if (!(jitMgr->LoadJIT(L"MSCOREJT.DLL")))
                    {
                        if (!(m_fFailedToLoad & FAILED_EJIT))
                            m_fFailedToLoad = m_fFailedToLoad | FAILED_EJIT;
                        delete jitMgr;
                        jitMgr = NULL;
                    }
                    else
                    {
                        ICodeManager *newCodeMan = new Fjit_EETwain();
                        if (newCodeMan)
                        {
                            jitMgr->SetCodeManager(newCodeMan, FALSE);
                            jitMgr->SetCodeType(Flags);
                        }
                        else
                        {
                            delete jitMgr;
                            jitMgr = NULL;
                        }
                    }
                    break;
    
                default :
                    // If we got here then something odd happened
                    // and we need to free the codeMgr and exit
                    _ASSERTE(0 && "Unknown impl type");
                    delete jitMgr;
                    jitMgr = NULL;
                    break;
            }
            // If we created a new codeMgr and successfully loaded the
            // correct JIT then we need to add this code manager to the
            // list.  This is a simple add to the end of the list.
            if (jitMgr != NULL)
                AddJitManager(jitMgr);
        }
        // Release the code manager lock
        m_pExecutionManagerCrst->Leave();
    }

    return jitMgr;
}

void ExecutionManager::Unload(AppDomain *pDomain)
{
    IJitManager *pMan = m_pJitList;
    while (pMan)
    {
        pMan->Unload(pDomain);
        pMan = pMan->m_next;
    }
}

void ExecutionManager::AddJitManager(IJitManager * newjitmgr)
{
    // This is the first code manager added.
    if (!m_pJitList)
        m_pJitList = newjitmgr;
    // else walk the list.
    else
    {
        IJitManager *walker = m_pJitList;
        while (walker->m_next)
            walker = walker->m_next;
        walker->m_next = newjitmgr;
    }
}

CORCOMPILE_METHOD_HEADER *ExecutionManager::GetMethodHeaderForAddressWrapper(LPVOID startAddress, IJitManager::ScanFlag scanFlag)
{
    CORCOMPILE_METHOD_HEADER *ret = NULL;
    
    READER_INCREMENT(&m_dwReaderCount, &m_dwWriterLock)
    {
        ret = GetMethodHeaderForAddress(startAddress, IJitManager::ScanNoReaderLock);
    }
    READER_DECREMENT(&m_dwReaderCount);

    return ret;
}

CORCOMPILE_METHOD_HEADER *ExecutionManager::GetMethodHeaderForAddress(LPVOID startAddress, IJitManager::ScanFlag scanFlag)
{
    if (scanFlag != IJitManager::ScanNoReaderLock && IJitManager::GetScanFlags() != IJitManager::ScanNoReaderLock)
        return GetMethodHeaderForAddressWrapper(startAddress);

    DWORD   ipmapsize = 0;
    DWORD   numentries = 0;
    DWORD   count = 0;
    DWORD   startRVA = 0;
    IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY*    pIPMap = NULL;
    RangeSection *pRS = m_RangeTree;

    // Walk the range tree and find the module containing this address
    while (TRUE)
    {
        if (pRS == NULL)
            return NULL;

        if ((startAddress >= pRS->LowAddress) && (startAddress <= pRS->HighAddress))
            // We found the right module!
            break;
        else
            if (startAddress < pRS->LowAddress)
                pRS=pRS->pleft;
            else
                pRS=pRS->pright;
    }
    // Verify that this is a module
    if (pRS->ptable == NULL)
        return NULL;

    return (CORCOMPILE_METHOD_HEADER *) 
      ((size_t) EEJitManager::FindHeader((DWORD *) pRS->ptable, 
                                         (size_t) startAddress - (size_t) pRS->LowAddress)
       + (size_t) pRS->LowAddress);
}

BOOL ExecutionManager::AddRange(LPVOID pStartRange,LPVOID pEndRange,IJitManager* pJit,LPVOID pTable)
{
    RangeSection *pnewrange = NULL;
    _ASSERTE(pStartRange && pEndRange && pJit);

    if (!(pStartRange && pEndRange && pJit))
        return FALSE;

    READER_INCREMENT(&m_dwReaderCount, &m_dwWriterLock)
    {
        pnewrange = new RangeSection;

        if (!pnewrange)
            return FALSE;

        pnewrange->LowAddress = pStartRange;
        pnewrange->HighAddress = pEndRange;

        pnewrange->pjit = pJit;
        pnewrange->ptable = pTable;

        pnewrange->pright = NULL;
        pnewrange->pleft = NULL;

        m_pRangeCrst->Enter();
        {
            if (m_RangeTree)
            {
                RangeSection *rangewalker = NULL;
                RangeSection *rangewalker2 = NULL;

                rangewalker = rangewalker2 = m_RangeTree;
                while (rangewalker)
                {
                    if (pnewrange->LowAddress < rangewalker->LowAddress)
                    {
                        rangewalker2=rangewalker;
                        rangewalker = rangewalker->pleft;
                    }
                    else
                    {
                        rangewalker2=rangewalker;
                        rangewalker = rangewalker->pright ;
                    }

                }
                if (pnewrange->LowAddress < rangewalker2->LowAddress)
                    rangewalker2->pleft = pnewrange;
                else
                    rangewalker2->pright = pnewrange;
            }
            else
                m_RangeTree = pnewrange;
        }
        m_pRangeCrst->Leave();
    }
    READER_DECREMENT(&m_dwReaderCount);

    return TRUE;
}

// Deletes a single range starting at pStartRange
void ExecutionManager::DeleteRange(LPVOID pStartRange)
{
    _ASSERTE(m_dwWriterLock == 0);
    while (TRUE)
	{
		InterlockedIncrement(&m_dwWriterLock);
		if (m_dwReaderCount == 0)
			break;
		InterlockedDecrement(&m_dwWriterLock);
		__SwitchToThread(0);
	}
	__try
	{
        m_pRangeCrst->Enter();
        RangeSection *rangewalker = m_RangeTree;
        RangeSection *rangewalker2 = m_RangeTree;
        while (rangewalker->LowAddress != pStartRange)
        {
            if (pStartRange < rangewalker->LowAddress)
            {
                rangewalker2=rangewalker;
                rangewalker = rangewalker->pleft;
            }
            else
            {
                rangewalker2=rangewalker;
                rangewalker = rangewalker->pright ;
            }
            _ASSERTE(rangewalker);
        }
        // m_RangeTree is not updated anywhere else - it is initially set when we handle
        // the default domain so could remove this and just assert that haven't asked
        // to delete the root range.
        if (rangewalker == m_RangeTree) // special case the root
        {
            if (rangewalker->pleft == NULL)
            {
                m_RangeTree = rangewalker->pright;
            }
            else if (rangewalker->pright == NULL)
            {
                m_RangeTree = rangewalker->pleft;
            }
            else // both left and right children are non-null
            {
                m_RangeTree = rangewalker->pleft;
                rangewalker2 = m_RangeTree;
                while (rangewalker2->pright)
                    rangewalker2 = rangewalker2->pright;
                rangewalker2->pright = rangewalker->pright;
            }
        }
        // deleted range is not the root
        else if (rangewalker == rangewalker2->pleft)
        {
            if (rangewalker->pleft == NULL)
            {
                rangewalker2->pleft = rangewalker->pright;
            }
            else if (rangewalker->pright == NULL)
            {
                rangewalker2->pleft = rangewalker->pleft;
            }
            else // both left and right children are non-null
            {
                rangewalker2->pleft = rangewalker->pright;
                rangewalker2 = rangewalker->pright;
                while (rangewalker2->pleft)
                    rangewalker2 = rangewalker2->pleft;
                rangewalker2->pleft = rangewalker->pleft;
            }
        }
        else //(rangewalker == rangewalker2->pright)
        {
            if (rangewalker->pleft == NULL)
            {
                rangewalker2->pright = rangewalker->pright;
            }
            else if (rangewalker->pright == NULL)
            {
                rangewalker2->pright = rangewalker->pleft;
            }
            else // both left and right children are non-null
            {
                rangewalker2->pright = rangewalker->pleft;
                rangewalker2 = rangewalker->pleft;
                while (rangewalker2->pright)
                    rangewalker2 = rangewalker2->pright;
                rangewalker2->pright = rangewalker->pright;
            }
        }
        if (m_pLastUsedRS == rangewalker)
            m_pLastUsedRS = NULL;

        delete rangewalker;
    }
    __finally
	{
		InterlockedDecrement(&m_dwWriterLock);
        m_pRangeCrst->Leave();
	}
}

// This is a recursive delete.  If we are here then we are cleaning up so don't need critical section.
void ExecutionManager::DeleteRanges(RangeSection *subtree)
{
    if (!subtree)
        return;

    DeleteRanges(subtree->pleft);
    DeleteRanges(subtree->pright);
    if (m_pLastUsedRS == subtree)
        m_pLastUsedRS = NULL;
    delete subtree;
}

//***************************************************************************************
//***************************************************************************************
MNativeJitManager::MNativeJitManager()
{
    m_next = NULL;
    m_pMNativeCritSec = NULL;
}

MNativeJitManager::~MNativeJitManager()
{
    m_next = NULL;
    if (m_pMNativeCritSec)
    {
        delete m_pMNativeCritSec;
        m_pMNativeCritSec = NULL;
    }
}

BOOL MNativeJitManager::Init()
{

    m_pMNativeCritSec = new (&m_pMNativeCritSecInstance) Crst("JitMetaHeapCrst",CrstSingleUseLock);
    if (m_pMNativeCritSec)
        return TRUE;
    else
        return FALSE;
}


unsigned MNativeJitManager::InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState)
{
    Module *pModule = NULL;
    *pEnumState = 1;     // since the EH info is not compressed, the clause number is used to do the enumeration

    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) MethodToken);

    EE_ILEXCEPTION *pExceptions= (EE_ILEXCEPTION*) pHeader->exceptionInfo;
    if (pExceptions == NULL)
        return 0;

    return pExceptions->EHCount();
    }

EE_ILEXCEPTION_CLAUSE*  MNativeJitManager::GetNextEHClause(METHODTOKEN MethodToken,
                              //unsigned clauseNumber,
                              EH_CLAUSE_ENUMERATOR* pEnumState,
                              EE_ILEXCEPTION_CLAUSE* pEHClauseOut)
{
    _ASSERTE(sizeof(EE_ILEXCEPTION_CLAUSE) == sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));

    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) MethodToken);

    EE_ILEXCEPTION *pExceptions= (EE_ILEXCEPTION*) pHeader->exceptionInfo;
    if (pExceptions == NULL)
        return 0;

    (*pEnumState)++;

    return pExceptions->EHClause((unsigned) *pEnumState - 2);
}

void MNativeJitManager::ResolveEHClause(METHODTOKEN MethodToken,
                              //unsigned clauseNumber,
                              EH_CLAUSE_ENUMERATOR* pEnumState,
                              EE_ILEXCEPTION_CLAUSE* pEHClauseOut)
{
    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) MethodToken);

    EE_ILEXCEPTION *pExceptions= (EE_ILEXCEPTION*) pHeader->exceptionInfo;
    _ASSERTE(pExceptions != NULL);

    // use -2 because need to go back to previous one, as enum will have already been updated
    _ASSERTE(*pEnumState >= 2);
    EE_ILEXCEPTION_CLAUSE *pClause = pExceptions->EHClause((unsigned) *pEnumState - 2);
    _ASSERTE(IsTypedHandler(pClause));

    m_pMNativeCritSec->Enter();
    // check first as if has already been resolved then token will have been replaced with EEClass
    if (! HasCachedEEClass(pClause)) {
        Module *pModule = ((MethodDesc*)pHeader->methodDesc)->GetModule();
        // Resolve to class if defined in an *already loaded* scope.
        NameHandle name(pModule, (mdToken)(size_t)pClause->pEEClass); // @TODO WIN64 - pointer truncation
        name.SetTokenNotToLoad(tdAllTypes);
        TypeHandle typeHnd = pModule->GetClassLoader()->LoadTypeHandle(&name);
        if (!typeHnd.IsNull()) {
            pClause->pEEClass = typeHnd.GetClass();
            SetHasCachedEEClass(pClause);
        }
    }
    if (HasCachedEEClass(pClause))
        // only copy if actually resolved it. Either we did it or another thread did
        copyExceptionClause(pEHClauseOut, pClause);

    m_pMNativeCritSec->Leave();
}


MethodDesc* MNativeJitManager::JitCode2MethodDesc(SLOT currentPC, IJitManager::ScanFlag scanFlag)
{
    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) currentPC);

    return (MethodDesc *) pHeader->methodDesc;
}

void MNativeJitManager::JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset, IJitManager::ScanFlag scanFlag)
{
    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) currentPC);

    SIZE_T methodStart = (SIZE_T) (pHeader+1);

    // We are using the method start as the MethodToken!
    *pMethodToken = (METHODTOKEN) methodStart;

    *pPCOffset = (DWORD)(SIZE_T)(currentPC - methodStart);
    return;
}

BYTE* MNativeJitManager::JitToken2StartAddress(METHODTOKEN methodToken, IJitManager::ScanFlag scanFlag)
{
    return (BYTE*) methodToken;
}

void  MNativeJitManager::ResumeAtJitEH(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)
{
    BYTE* startAddress = (BYTE*) pCf->GetMethodToken();
    ::ResumeAtJitEH(pCf,startAddress,EHClausePtr,nestingLevel,pThread, unwindStack);
}

int  MNativeJitManager::CallJitEHFilter(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj)
{
    BYTE* startAddress = (BYTE*) pCf->GetMethodToken();
    return ::CallJitEHFilter(pCf,startAddress,EHClausePtr,nestingLevel,thrownObj);

}

void   MNativeJitManager::CallJitEHFinally(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel)
{
    BYTE* startAddress = (BYTE*) pCf->GetMethodToken();
    ::CallJitEHFinally(pCf,startAddress,EHClausePtr,nestingLevel);
}


//**************************************************
// Helpers
//**************************************************

inline DWORD MIN (DWORD a, DWORD b)
{
    if (a < b)
        return a;
    else
        return b;
}



#ifdef MDTOKEN_CACHE
size_t EEJitManager::GetCodeHeapCacheSize (size_t bAllocationRequest)
{
    // For every 64 KB we need one HasnEntry. Rounded up to the next 64 KB mem.
    _ASSERTE ((RESERVED_BLOCK_ROUND_TO_PAGES * 4096) >= 0x10000);
    return ((bAllocationRequest/0x10000)+1) * sizeof (HashEntry);
}

void EEJitManager::AddRangeToJitHeapCache (PBYTE startAddr, PBYTE endAddr, HeapList *pHp)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());
    _ASSERTE (((size_t)(pHp->startAddress -  (sizeof(HeapList) + pHp->bCacheSpaceSize + sizeof(LoaderHeapBlock))) & 0x0000FFFF) == 0);
    _ASSERTE (pHp->pHeap->GetFirstBlockVirtualAddress() && (((size_t)pHp->pHeap->GetFirstBlockVirtualAddress() & 0x0000FFFF) == 0));
    
    HashEntry* hashEntry = NULL;

    size_t currAddr = (size_t)startAddr & 0xffff0000;
    size_t cacheSpaceSizeLeft = pHp->bCacheSpaceSize;
    PBYTE cacheSpacePtr = pHp->pCacheSpacePtr;
    while ((currAddr < (size_t)endAddr) && (cacheSpaceSizeLeft > 0))
    {
        _ASSERTE ((cacheSpaceSizeLeft % sizeof (HashEntry)) == 0);
        _ASSERTE (cacheSpacePtr && "Cache ptr and size ou of sync");

        size_t index = (currAddr & 0x00ff0000) >> 16; 
        hashEntry = new (cacheSpacePtr) HashEntry(); // in place ctor
        hashEntry->currentPC = currAddr;
        hashEntry->pHp = pHp;
        hashEntry->pNext = m_JitCodeHashTable[index];
        m_JitCodeHashTable[index] = hashEntry;
        currAddr += 0x00010000; //64 KB chunks
        LOG((LF_SYNC, LL_INFO1000, "AddRangeToJitHeapCache: %0x\t%0x\t%0x\n", index, currAddr, pHp));
        
        cacheSpacePtr += sizeof (HashEntry);
        cacheSpaceSizeLeft -= sizeof (HashEntry);
    }
    
}

void EEJitManager::DeleteJitHeapCache (HeapList *pHp)
{
    _ASSERTE(m_pCodeHeapCritSec->OwnedByCurrentThread());
    
    // If the following condition is not true then this heap node was not inserted in the cache
    _ASSERTE (pHp->pHeap->GetFirstBlockVirtualAddress());
    if (((size_t)pHp->pHeap->GetFirstBlockVirtualAddress() & 0x0000FFFF) != 0)
        return;

    PBYTE startAddr = pHp->startAddress;
    PBYTE endAddr = pHp->startAddress+pHp->maxCodeHeapSize;

    size_t currAddr = (size_t)startAddr & 0xffff0000;
    while (currAddr < (size_t)endAddr)
    {
        size_t index = (currAddr & 0x00ff0000) >> 16; 
        HashEntry *hashEntry = m_JitCodeHashTable[index];
        _ASSERTE (hashEntry && "JitHeapCache entry not found");
        if (hashEntry && (hashEntry->currentPC == currAddr))
        {
            m_JitCodeHashTable[index] = hashEntry->pNext;
            hashEntry->pNext = m_pJitHeapCacheUnlinkedList;
            m_pJitHeapCacheUnlinkedList = hashEntry;
        }
        else
        {
            // We are guaranteed to find all the sub heaps in the collision lists.
            _ASSERTE (hashEntry && hashEntry->pNext && "JitHeapCache entry not found");
            while (hashEntry && hashEntry->pNext && (hashEntry->pNext->currentPC != currAddr))
            {
                hashEntry = hashEntry->pNext;
                _ASSERTE (hashEntry && hashEntry->pNext && "JitHeapCache entry not found");
            }
            if (hashEntry && hashEntry->pNext && (hashEntry->pNext->currentPC == currAddr))
            {
                HashEntry *ptmpEntry = hashEntry->pNext;
                hashEntry->pNext = hashEntry->pNext->pNext;
                ptmpEntry->pNext = m_pJitHeapCacheUnlinkedList;
                m_pJitHeapCacheUnlinkedList = ptmpEntry;
            }
        }
        currAddr += 0x00010000; //64 KB chunks
        LOG((LF_SYNC, LL_INFO1000, "UnlinkJitHeapCache: %0x\t%0x\t%0x\n", index, currAddr, hashEntry));
    }
}

void EEJitManager::ScavengeJitHeapCache ()
{
    // This is safe even if readers are in the cache because we 
    // are not deleting the hash table's collision linked lists.
    // The memory for the nodes of the collicion linked list is 
    // contained in the heap node itself and would get deleted 
    // in ScavengeJitHeaps()
    for (int i=0; i<HASH_BUCKETS; i++) 
        m_JitCodeHashTable[i] = NULL;
}

#ifdef _DEBUG
BOOL EEJitManager::DebugContainedInHeapList (HeapList *pHashEntryHp)
{
    HeapList *pHp = m_pCodeHeap;
    while (pHp)
    {
        if (pHp == pHashEntryHp)
            return TRUE;
        pHp = pHp->hpNext;
    }
    return FALSE;
}

void EEJitManager::DebugCheckJitHeapCacheValidity ()
{
    HeapList *pHp = m_pCodeHeap;
    while (pHp)
    {
        
        PBYTE startAddr = pHp->startAddress;
        PBYTE endAddr = pHp->startAddress+pHp->maxCodeHeapSize;

        size_t currAddr = (size_t)startAddr & 0xffff0000;
        while (currAddr < (size_t)endAddr)
        {
            size_t index = (currAddr & 0x00ff0000) >> 16; 
            HashEntry *hashEntry = m_JitCodeHashTable[index];
            _ASSERTE (hashEntry && "JitHeapCache entry not found");
            if (hashEntry && (hashEntry->currentPC == currAddr))
            {
                // found the entry
            }
            else
            {
                // We are guaranteed to find all the sub heaps in the collision lists.
                _ASSERTE (hashEntry && hashEntry->pNext && "JitHeapCache entry not found");
                while (hashEntry && hashEntry->pNext && (hashEntry->pNext->currentPC != currAddr))
                {
                    hashEntry = hashEntry->pNext;
                    _ASSERTE (hashEntry && "JitHeapCache entry not found");
                }
                if (hashEntry && (hashEntry->currentPC == currAddr))
                {
                    // found the entry
                }
            }
            currAddr += 0x00010000; //64 KB chunks
        }
        pHp = pHp->hpNext;
    }

    for (int i=0; i<HASH_BUCKETS; i++)
    {
        HashEntry *hashEntry = m_JitCodeHashTable[i];
        while (hashEntry)
        {
            if (!DebugContainedInHeapList (hashEntry->pHp))
            {
                _ASSERTE (!"Inconsistent JitHeapCache found");
            }
            hashEntry = hashEntry->pNext;
        }
    }

}
#endif // _DEBUG
#endif // #ifdef MDTOKEN_CACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\clsload.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// clsload.hpp
//
#ifndef _H_CLSLOAD
#define _H_CLSLOAD

#include "crst.h"
#include "class.h"
#include "ceeload.h"
#include "eehash.h"
#include "typehash.h"
#include "vars.hpp"
#include "enc.h"
#include "stubmgr.h"
#include "..\Debug\Inc\Common.h"
#include <member-offset-info.h>

// SystemDomain is a friend of ClassLoader.
class SystemDomain;
class Assembly;
class ClassLoader;
struct EnCInfo;
interface IEnCErrorCallback;

#define STUB_HEAP_RESERVE_SIZE 8192
#define STUB_HEAP_COMMIT_SIZE   4096

#define RIDMAP_RESERVE_SIZE 32768
#define RIDMAP_COMMIT_SIZE   4096

// Hash table parameter for unresolved class hash
#define UNRESOLVED_CLASS_HASH_BUCKETS 8

// Hash table parameter of available classes (name -> module/class) hash
#define AVAILABLE_CLASSES_HASH_BUCKETS 1024

// Used by Module Index / CL hash
#define MAX_CLASSES_PER_MODULE (1 << 21)

// This is information required to look up a type in the loader. Besides the
// basic name there is the meta data information for the type, whether the
// the name is case sensitive, and tokens not to load. This last item allows
// the loader to prevent a type from being recursively loaded.
typedef enum NameHandleTable
{
    nhCaseSensitive = 0,
    nhCaseInsensitive = 1,
    nhConstructed = 2,
} NameHandleTable;


    // This token can be used on a pThrowable, it is just a token that says
    // don't return the throwable, just throw it instead 

#define THROW_ON_ERROR ((OBJECTREF*) 1) 
#define RETURN_ON_ERROR (NULL)                   // We do this all the time right now.  
inline bool  pThrowableAvailable(OBJECTREF* pThrowable) { return (size_t(pThrowable) > size_t(THROW_ON_ERROR)); }
    // used in a catch handler, updates pThrowable GETHROWABLE, if available
    // if pthrowable == THROW_ON_ERROR then also rethrow
void UpdateThrowable(OBJECTREF* pThrowable);

class NameHandle
{
    friend ClassLoader;
    friend EETypeHashTable;

    // Three discriminable possibilities:
    // (1) class name (if m_WhichTable != nhConstructed)
    //     Key1 : pointer to namespace (LPCUTF8, possibly null?)
    //     Key2 : pointer to name (LPCUTF8)
    // (2) array type (if m_WhichTable = nhConstructed): 
    //     Key1 : rank << 16 | kind     for kind = ELEMENT_TYPE_{ARRAY,SZARRAY,GENERICARRAY}
    //     Key2 : element type handle
    // (3) byref/pointer type (if m_WhichTable = nhConstructed)
    //     Key1 : kind                  for kind = ELEMENT_TYPE_BYREF or ELEMENT_TYPE_PTR
    //     Key2 : element type handle   
    INT_PTR Key1;
    INT_PTR Key2;

    Module* m_pTypeScope;
    mdToken m_mdType;
    mdToken m_mdTokenNotToLoad;
    NameHandleTable m_WhichTable;
    BOOL    m_fDontRestore;
    EEClassHashEntry_t *m_pBucket;

public:
    
    NameHandle() 
    { memset((void*) this, NULL, sizeof(*this)); }

    NameHandle(LPCUTF8 name) :
        Key1(NULL),
        Key2((INT_PTR) name),
        m_pTypeScope(NULL),
        m_mdType(mdTokenNil),
        m_mdTokenNotToLoad(tdNoTypes),
        m_WhichTable(nhCaseSensitive),
        m_fDontRestore(FALSE),
        m_pBucket(NULL)
    {}

    NameHandle(LPCUTF8 nameSpace, LPCUTF8 name) :
        Key1((INT_PTR) nameSpace),
        Key2((INT_PTR) name),
        m_pTypeScope(NULL),
        m_mdType(mdTokenNil),
        m_mdTokenNotToLoad(tdNoTypes),
        m_WhichTable(nhCaseSensitive),
        m_fDontRestore(FALSE),
        m_pBucket(NULL)
    {}

    NameHandle(DWORD kind, TypeHandle elemType, DWORD rank = 0) :
        Key1(kind | rank << 16),
        Key2((INT_PTR) elemType.AsPtr()),
        m_pTypeScope(NULL),
        m_mdType(mdTokenNil),
        m_mdTokenNotToLoad(tdNoTypes),
        m_WhichTable(nhConstructed),
        m_fDontRestore(FALSE),
        m_pBucket(NULL)
    {}

    NameHandle(Module* pModule, mdToken token) :
        Key1(NULL),
        Key2(NULL),
        m_pTypeScope(pModule),
        m_mdType(token),
        m_mdTokenNotToLoad(tdNoTypes),
        m_WhichTable(nhCaseSensitive),
        m_fDontRestore(FALSE),
        m_pBucket(NULL)
    {}

    NameHandle(NameHandle& p)
    {
        Key1 = p.Key1;
        Key2 = p.Key2;
        m_pTypeScope = p.m_pTypeScope;
        m_mdType = p.m_mdType;
        m_mdTokenNotToLoad = p.m_mdTokenNotToLoad;
        m_WhichTable = p.m_WhichTable;
        m_fDontRestore = p.m_fDontRestore;
        m_pBucket = p.m_pBucket;
    }

    void SetName(LPCUTF8 pName)
    {
        _ASSERTE(!IsConstructed());
        Key2 = (INT_PTR) pName;
    }

    void SetName(LPCUTF8 pNameSpace, LPCUTF8 pName)
    {
        _ASSERTE(!IsConstructed());
        Key1 = (INT_PTR) pNameSpace;
        Key2 = (INT_PTR) pName;
    }

    LPCUTF8 GetName()
    {
        _ASSERTE(!IsConstructed());
        return (LPCUTF8) Key2;
    }

    LPCUTF8 GetNameSpace()
    {
        _ASSERTE(!IsConstructed());
        return (LPCUTF8) Key1;
    }

    unsigned GetFullName(char* buff, unsigned buffLen);

    DWORD GetRank()
    {
        _ASSERTE(IsConstructed());
        return Key1 >> 16;
    }

    CorElementType GetKind()
    {
        if (IsConstructed()) return (CorElementType) (Key1 & 0xffff);
        else return ELEMENT_TYPE_CLASS;
    }

    TypeHandle GetElementType()
    {
        _ASSERTE(IsConstructed());
        return TypeHandle((void*) Key2);
    }

    void SetTypeToken(Module* pModule, mdToken mdToken)
    {
        m_pTypeScope = pModule;
        m_mdType = mdToken;
    }

    Module* GetTypeModule()
    {
        return m_pTypeScope;
    }

    mdToken GetTypeToken()
    {
        return m_mdType;
    }

    void SetTokenNotToLoad(mdToken mdtok)
    {
        m_mdTokenNotToLoad = mdtok;
    }
    
    mdToken GetTokenNotToLoad()
    {
        return m_mdTokenNotToLoad;
    }

    void SetCaseInsensitive()
    {
        m_WhichTable = nhCaseInsensitive;
    }

    void SetCaseSensitive()
    {
        m_WhichTable = nhCaseSensitive;
    }

    NameHandleTable GetTable()
    {
        return m_WhichTable;
    }
   
    void SetRestore(BOOL value)
    {
        m_fDontRestore = !value;
    }

    BOOL GetRestore()
    {
        return !m_fDontRestore;
    }

    BOOL IsConstructed()
    {
        return (m_WhichTable == nhConstructed);
    }

    void SetBucket(EEClassHashEntry_t * pBucket)
    {
        m_pBucket = pBucket;
    }


    EEClassHashEntry_t * GetBucket()
    {
        return m_pBucket;
    }

#ifdef _DEBUG
    void Validate()
    {
      if (!IsConstructed())
    {
          _ASSERTE(GetName());
          _ASSERTE(ns::IsValidName(GetName()));
        }
    }
#endif

};



        
// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE
//
// A word about EEClass vs. MethodTable
// ------------------------------------
//
// At compile-time, we are happy to touch both MethodTable and EEClass.  However,
// at runtime we want to restrict ourselves to the MethodTable.  This is critical
// for common code paths, where we want to keep the EEClass out of our working
// set.  For uncommon code paths, like throwing exceptions or strange Contexts
// issues, it's okay to access the EEClass.
//
// To this end, the TypeHandle (CLASS_HANDLE) abstraction is now based on the
// MethodTable pointer instead of the EEClass pointer.  If you are writing a
// runtime helper that calls GetClass() to access the associated EEClass, please
// stop to wonder if you are making a mistake.
//
// **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE  **  NOTE

class ClassLoader
{
    friend class EEClass;
    friend class SystemDomain;
    friend class AppDomain;
    friend class Assembly;
    friend class Module;

    // the following three classes are friends because they will call LoadTypeHandle by token directly
    friend class COMDynamicWrite;
    friend class COMModule;
    friend class TypeLibExporter;

    friend struct MEMBER_OFFSET_INFO(ClassLoader);

private:
    // Classes for which load is in progress
    EEScopeClassHashTable * m_pUnresolvedClassHash;
    CRITICAL_SECTION    m_UnresolvedClassLock;

    // Protects linked list of Modules loaded by this loader
    CRITICAL_SECTION    m_ModuleListCrst; 

    // Hash of available classes by name to Module or EEClass
    EEClassHashTable  * m_pAvailableClasses;

    // Cannoically-cased hashtable of the available class names for 
    // case insensitive lookup.  Contains pointers into 
    // m_pAvailableClasses.
    EEClassHashTable * m_pAvailableClassesCaseIns;

    EETypeHashTable   *m_pAvailableParamTypes;

    // Protects addition of elements to m_pAvailableClasses
    CRITICAL_SECTION    m_AvailableClassLock;

#if 0
    // Converter module for this loader (may be NULL if we haven't converted a file yet)
    CorModule   *   m_pConverterModule;
#endif

    // Have we created all of the critical sections yet?
    BOOL                m_fCreatedCriticalSections;

    // Do we have any modules which need to have their classes added to 
    // the available list?
    volatile LONG       m_cUnhashedModules;

    // List of ArrayClasses loaded by this loader
    // This list is protected by m_pAvailableClassLock
    ArrayClass *        m_pHeadArrayClass;

    // Back reference to the assembly
    Assembly*           m_pAssembly;
    
public:
    LoaderHeap* GetLowFrequencyHeap();
    LoaderHeap* GetHighFrequencyHeap();
    LoaderHeap* GetStubHeap();

#if 0
    // Converter module needs to access these - enforces single-threaded conversion of class files
    // within this loader (and instance of the ClassConverter)
    CRITICAL_SECTION    m_ConverterModuleLock;
#endif

    // Next classloader in global list
    ClassLoader *       m_pNext; 

    // Head of list of modules loaded by this loader
    Module *            m_pHeadModule;

#ifdef _DEBUG
    DWORD               m_dwDebugMethods;
    DWORD               m_dwDebugFieldDescs; // Doesn't include anything we don't allocate a FieldDesc for
    DWORD               m_dwDebugClasses;
    DWORD               m_dwDebugDuplicateInterfaceSlots;
    DWORD               m_dwDebugArrayClassRefs;
    DWORD               m_dwDebugArrayClassSize;
    DWORD               m_dwDebugConvertedSigSize;
    DWORD               m_dwGCSize;
    DWORD               m_dwInterfaceMapSize;
    DWORD               m_dwMethodTableSize;
    DWORD               m_dwVtableData;
    DWORD               m_dwStaticFieldData;
    DWORD               m_dwFieldDescData;
    DWORD               m_dwMethodDescData;
    size_t              m_dwEEClassData;
#endif

public:
    ClassLoader();
    ~ClassLoader();

    Module *LookupModule(DWORD dwIndex);
    static HashDatum CompressModuleIndexAndClassDef(DWORD dwModuleIndex, mdToken cl);
    HRESULT UncompressModuleAndClassDef(HashDatum Data, mdToken tokenNotToLoad,
                                        Module **ppModule, mdTypeDef *pCL,
                                        mdExportedType *pmdFoundExportedType,
                                        OBJECTREF *pThrowable=NULL);
    static mdToken UncompressModuleAndClassDef(HashDatum Data);

    BOOL LazyAddClasses();

    // Lookup the hash table entry from the hash table
    EEClassHashEntry_t *GetClassValue(EEClassHashTable *pTable,
                                      NameHandle *pName, 
                                      HashDatum *pData);

    // It's okay to give NULL for pModule and a nil token for cl if it's
    // guaranteed that this is not a nested type.
    HRESULT FindClassModule(NameHandle* pName,
                            TypeHandle* pType, 
                            mdToken* pmdClassToken,
                            Module** ppModule, 
                            mdToken *pmdFoundExportedType,
                            EEClassHashEntry_t** ppEntry,
                            OBJECTREF *pThrowable=NULL);

    BOOL Init();
    void FreeArrayClasses();
    void SetBaseSystemSecurity();

    HRESULT ExecuteMainMethod(Module *pModule, PTRARRAYREF *stringArgs = NULL);

    HRESULT RunDllMain(DWORD dwReason);

    static BOOL InitializeEE();

#ifdef EnC_SUPPORTED
    static HRESULT ApplyEditAndContinue(EnCInfo *pEnCInfo, 
                                        UnorderedEnCErrorInfoArray *pEnCError,
                                        UnorderedEnCRemapArray *pEnCRemapInfo,
                                        BOOL checkOnly);
#endif // EnC_SUPPORTED
 
    void SetAssembly(Assembly* assem)
    {
        m_pAssembly = assem;
    }
    Assembly* GetAssembly()
    {
        return m_pAssembly;
    }
    void    FreeModules();

#if ZAP_RECORD_LOAD_ORDER
    void    CloseLoadOrderLogFiles();
#endif

    void UnlinkClasses(AppDomain *pDomain);
    
    // Look up a class given a type token (TypeDef, TypeRef, TypeSpec), and a module 
    TypeHandle LoadTypeHandle(NameHandle* pName, 
                              OBJECTREF *pThrowable=NULL,
                              BOOL dontLoadInMemoryType=TRUE);
    
    // Look up a class by name
    // It's okay to give NULL for pModule and a nil token for cl if it's
    //   guaranteed that this is not a nested type.  Otherwise, cl can be a
    //   TypeDef or TypeRef, and pModule must be the Module that token applies to
    TypeHandle FindTypeHandle(NameHandle* pName,
                              OBJECTREF *pThrowable=NULL);


    // Look up a class given just a name, and optionally a Module.  
    TypeHandle FindTypeHandle(LPCUTF8 pszClassName, 
                              OBJECTREF *pThrowable=NULL) 
    {
        NameHandle typeName(pszClassName);
        return FindTypeHandle(&typeName, pThrowable);
    }


    EEClass* LoadClass(LPCUTF8 pszClassName, 
                       OBJECTREF *pThrowable=NULL) 
    {
        return FindTypeHandle(pszClassName, pThrowable).GetClass();
    }


    // Find the array with kind 'arrayKind' (either ARRAY, SZARRAY, GENERICARRAY)
    // and 'rank' for 'elemType'.  
    TypeHandle FindArrayForElem(TypeHandle elemType, CorElementType arrayKind, unsigned rank=0, OBJECTREF *pThrowable=NULL);

    // Looks up class in the local module table, if it is there it succeeds, 
    // Otherwise it fails, This is meant only for optimizations etc
    TypeHandle LookupInModule(NameHandle* pName);

    static EEClass *LoadClass(CLSID clsid, OBJECTREF *pThrowable=NULL);
        


    LoadingEntry_t *FindUnresolvedClass(Module *pModule, mdTypeDef cl);

    HRESULT AddAvailableClassDontHaveLock(Module *pModule, DWORD dwModuleIndex, mdTypeDef classdef);
    HRESULT AddAvailableClassHaveLock(Module *pModule, DWORD dwModuleIndex, mdTypeDef classdef);
    HRESULT AddExportedTypeHaveLock(LPCUTF8 pszNameSpace,
                               LPCUTF8 pszName,
                               mdExportedType cl,
                               IMDInternalImport* pAsmImport,
                               mdToken mdImpl);

    static BOOL GetFullyQualifiedNameOfClassRef(Module *pModule, mdTypeRef cr, LPUTF8 pszFQName);
    static BOOL CanCastToClassOrInterface(OBJECTREF pRef, EEClass *pTemplate);
    static BOOL StaticCanCastToClassOrInterface(EEClass *pClass, EEClass *pTemplate);
    static HRESULT CanCastTo(Module *pModule, OBJECTREF pRef, mdTypeRef cr);
    static HRESULT CanCastTo(OBJECTREF pRef, TypeHandle clsHnd);
    static void TranslateBrokenClassRefName(LPUTF8 pszFQName);
    static BOOL CanAccessMethod(MethodDesc *pCurrentMethod, MethodDesc *pMD);
    static BOOL CanAccessField(MethodDesc *pCurrentMethod, FieldDesc *pFD);
    static BOOL CanAccessClass(EEClass *pCurrentClass, Assembly *pCurrentAssembly, EEClass *pTargetClass, Assembly *pTargetAssembly);
    static BOOL CanAccess(EEClass *pCurrentMethod, Assembly *pCurrentAssembly, EEClass *pEnclosingClass,  Assembly *pEnclosingAssembly, DWORD dwMemberAttrs);
    static BOOL CanAccess(EEClass  *pClassOfAccessingMethod, Assembly *pAssemblyOfAccessingMethod, EEClass  *pClassOfClassContainingMember, Assembly *pAssemblyOfClassContainingMember, EEClass  *pClassOfInstance, DWORD  dwMemberAccess);
    static BOOL CanAccessFamily(EEClass *pCurrentClass,  EEClass *pTargetClass, EEClass *pInstanceClass);
    static BOOL CheckAccess(EEClass *pCurrentMethod, Assembly *pCurrentAssembly, EEClass *pEnclosingClass, Assembly *pEnclosingAssembly, DWORD dwMemberAttrs);

    HRESULT InsertModule(Module *pModule, mdFile kFile, DWORD* pdwIndex);
    
    void LockAvailableClasses()
    {
        LOCKCOUNTINCL("LockAvailableClasses in clsload.hpp");

        EnterCriticalSection(&m_AvailableClassLock);
    }

    void UnlockAvailableClasses()
    {
        LeaveCriticalSection(&m_AvailableClassLock);
        LOCKCOUNTDECL("UnLockAvailableClasses in clsload.hpp");

    }

        // look up the interface class by iid
    EEClass*            LookupClass(REFIID iid); 
    // Insert class in the hash table
    void                InsertClassForCLSID(EEClass* pClass);


    //Creates a key with both the namespace and name converted to lowercase and
    //made into a proper namespace-path.
    //Returns true if it was successful, false otherwise.
    BOOL CreateCanonicallyCasedKey(LPCUTF8 pszNameSpace, LPCUTF8 pszName, LPUTF8 *ppszOutNameSpace, LPUTF8 *ppszOutName);

    // Unload this class loader on appdomain termination
    void Unload();

    HRESULT FindTypeDefByExportedType(IMDInternalImport *pCTImport,
                                 mdExportedType mdCurrent,
                                 IMDInternalImport *pTDImport,
                                 mdTypeDef *mtd);
protected:

    // Loads a class. This is the inner call from the multi-threaded load. This load must
    // be protected in some manner.
    HRESULT LoadTypeHandleFromToken(Module *pModule, mdTypeDef cl, EEClass** ppClass, OBJECTREF *pThrowable);


private:
    BOOL IsNested(NameHandle* pName, mdToken *mdEncloser);
    // Helpers for FindClassModule()
    BOOL CompareNestedEntryWithTypeDef(IMDInternalImport *pImport,
                                       mdTypeDef mdCurrent,
                                       EEClassHashEntry_t *pEntry);
    BOOL CompareNestedEntryWithTypeRef(IMDInternalImport *pImport,
                                       mdTypeRef mdCurrent,
                                       EEClassHashEntry_t *pEntry);
    BOOL CompareNestedEntryWithExportedType(IMDInternalImport *pImport,
                                       mdExportedType mdCurrent,
                                       EEClassHashEntry_t *pEntry);

    //Finds a type lookin only in the classes known to the class loader,
    //Does not call other 'magic' lookup places.  You usually want to call
    //FindTypeHandle instead. 
    TypeHandle LookupTypeHandle(NameHandle* pName,
                                OBJECTREF *pThrowable = NULL);

    // Maps the specified interface to the current domain.
    BOOL MapInterfaceToCurrDomain(TypeHandle InterfaceType, OBJECTREF *pThrowable);

    // Locates a token, the token must be a typedef and GC should be enabled.
    TypeHandle LoadTypeHandle(Module *pModule, mdTypeDef cl, OBJECTREF *pThrowable=NULL,
                              BOOL dontRestoreType=FALSE);

    // Locates the parent of a token. The token must be a typedef.
    HRESULT LoadParent(IMDInternalImport *pInternalImport, 
                       Module *pModule, 
                       mdToken cl, 
                       EEClass** ppClass, 
                       OBJECTREF *pThrowable=NULL);

    // Locates the enclosing class of a token if any. The token must be a typedef.
    HRESULT GetEnclosingClass(IMDInternalImport *pInternalImport, 
                              Module *pModule, 
                              mdTypeDef cl, 
                              mdTypeDef *tdEnclosing, 
                              OBJECTREF *pThrowable=NULL);


    TypeHandle FindParameterizedType(NameHandle* pName,
                                     OBJECTREF *pThrowable);

    void FindParameterizedTypeHelper(MethodTable    **pTemplateMT,
                                     OBJECTREF       *pThrowable);

    // Creates a new Method table for an array.  Used to make type handles 
    // Note that if kind == SZARRAY or ARRAY, we get passed the GENERIC_ARRAY
    // needed to create the array.  That way we dont need to load classes during
    // the class load, which avoids the need for a 'being loaded' list
    MethodTable* CreateArrayMethodTable(TypeHandle elemType, CorElementType kind, unsigned rank, OBJECTREF* pThrowable);

    // This is called from CreateArrayMethodTable
    MethodTable* CreateGenericArrayMethodTable(TypeHandle elemType);
    
    // Generate a short sig for an array accessor
    BOOL GenerateArrayAccessorCallSig(TypeHandle elemTypeHnd, 
                                      DWORD   dwRank,
                                      DWORD   dwFuncType, // Load, store, or <init>
                                      Module* pModule,    // Where the sig gets created
                                      PCCOR_SIGNATURE *ppSig, // Generated signature
                                      DWORD * pcSig       // Generated signature size
    );

    // Insert the class in the classes hash table and if needed in the case insensitive one
    EEClassHashEntry_t *InsertValue(LPCUTF8 pszNamespace, LPCUTF8 pszClassName, HashDatum Data, EEClassHashEntry_t *pEncloser);

};

//-------------------------------------------------------------------------
// Walks over all stub caches in the system and does a FreeUnused sweep over them.
//-------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID FreeUnusedStubs();
#endif /* SHOULD_WE_CLEANUP */



// Class to encapsulate Cor Command line processing
class CorCommandLine
{
public:

//********** TYPES

    // Note: We don't bother with interlocked operations as we manipulate these bits,
    // because we don't anticipate free-threaded access.  (Most of this is used only
    // during startup / shutdown).
    enum Bits
    {
        CLN_Nothing         = 0
    };

//********** DATA

    // Hold the current (possibly parsed) command line here
    static DWORD            m_NumArgs;
    static LPWSTR          *m_ArgvW;
    static Bits             m_Bits;

//********** METHODS

    // parse the command line
    static VOID             SetArgvW(LPWSTR lpCommandLine);

    // Retrieve the parsed command line
    static LPWSTR          *GetArgvW(DWORD *pNumArgs);

    // Terminate the command line, ready to be reinitialized without reloading
#ifdef SHOULD_WE_CLEANUP
    static void             Shutdown();
#endif /* SHOULD_WE_CLEANUP */

private:
    // Parse the command line (removing stuff inside -cor[] and setting bits)
    static void             ParseCor();
};


// -------------------------------------------------------
// Stub manager classes for method desc prestubs & normal 
// frame-pushing, StubLinker created stubs
// -------------------------------------------------------

class LockedRangeList : public RangeList
{
  public:

    LockedRangeList() : RangeList()
    {
        InitializeCriticalSection(&m_crst);
    }

    ~LockedRangeList()
    {
        DeleteCriticalSection(&m_crst);
    }

    void Lock()
    {
        LOCKCOUNTINCL("Lock in clsload.hpp");

        EnterCriticalSection(&m_crst);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_crst);
        LOCKCOUNTDECL("Unlock in clsload.hpp");

    }

  private:  
    CRITICAL_SECTION m_crst;
};

class MethodDescPrestubManager : public StubManager
{
  public:

    static MethodDescPrestubManager *g_pManager;

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    MethodDescPrestubManager() : StubManager(), m_rangeList() {}
    ~MethodDescPrestubManager() {}

    LockedRangeList m_rangeList;

    BOOL CheckIsStub(const BYTE *stubStartAddress);

  private:

    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace);

    MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)  {return NULL;}

};

// Note that this stub was written by a debugger guy, and thus when he refers to 'multicast'
// stub, he really means multi or single cast stub.  This was done b/c the same stub
// services both types of stub.
// Note from the debugger guy: the way to understand what this manager does is to
// first grok EmitMulticastInvoke for the platform you're working on (right now, just x86).
// Then return here, and understand that (for x86) the only way we know which method
// we're going to invoke next is by inspecting EDI when we've got the debuggee stopped
// in the stub, and so our trace frame will either (FRAME_PUSH) put a breakpoint
// in the stub, or (if we hit the BP) examine EDI, etc, & figure out where we're going next.
class StubLinkStubManager : public StubManager
{
  public:

    static StubLinkStubManager *g_pManager;

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    StubLinkStubManager() : StubManager(), m_rangeList() {}
    ~StubLinkStubManager() {}

    LockedRangeList m_rangeList;

    BOOL CheckIsStub(const BYTE *stubStartAddress);

  private:
    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace);
    virtual BOOL TraceManager(Thread *thread, 
                              TraceDestination *trace,
                              CONTEXT *pContext, 
                              BYTE **pRetAddr);

    MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)  {return NULL;}
    
  public: // used by MulticastFrame::TraceFrame
    BOOL IsStaticDelegate(BYTE *pbDel);
    BYTE **GetStaticDelegateRealDest(BYTE *pbDel);
    BYTE **GetSingleDelegateRealDest(BYTE *pbDel);
} ; 

// stub manager for EnC & Dynamic profiling
class UpdateableMethodStubManager : public StubManager
{
  public:

    static UpdateableMethodStubManager *g_pManager;

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    UpdateableMethodStubManager() : StubManager(), m_rangeList() {}
    ~UpdateableMethodStubManager() { delete m_pHeap;}

    LockedRangeList m_rangeList;

    static Stub *GenerateStub(const BYTE *addrOfCode);
    static Stub *UpdateStub(Stub *currentStub, const BYTE *newAddrOfCode);
    const BYTE* GetStubTargetAddr(const BYTE *stubStartAddress) {
        _ASSERTE(CheckIsStub(stubStartAddress));
        return (BYTE*)getJumpTarget(stubStartAddress);
    }

    BOOL CheckIsStub(const BYTE *stubStartAddress);

    static BOOL CheckIsStub(const BYTE *stubStartAddress, const BYTE **stubTargetAddress);
    MethodDesc *Entry2MethodDesc(const BYTE *IP, MethodTable *pMT);


 private:
    LoaderHeap *m_pHeap;

    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace);

};

// Stub manager for thunks.
class ThunkHeapStubManager : public StubManager
{
  public:

    static ThunkHeapStubManager *g_pManager;

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    ThunkHeapStubManager() : StubManager(), m_rangeList() {}
    ~ThunkHeapStubManager() {}

    LockedRangeList m_rangeList;

    BOOL CheckIsStub(const BYTE *stubStartAddress);

  private:
    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace);
    MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)  {return NULL;}
}; 

// -------------------------------------------------------
// Stub managed for IJWNOADThunk
// -------------------------------------------------------
class IJWNOADThunkStubManager : public StubManager
{
  public:

    static IJWNOADThunkStubManager *g_pManager;

    static BOOL Init();

#ifdef SHOULD_WE_CLEANUP
    static void Uninit();
#endif /* SHOULD_WE_CLEANUP */

    IJWNOADThunkStubManager();
    ~IJWNOADThunkStubManager();

    // Check if it's a stub by looking at the content
    virtual BOOL CheckIsStub(const BYTE *stubStartAddress);

  private:
    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace)
    {
        // Just need IsTransitionStub() to be able to recogize that this is a stub.
        // We don't need to trace it.
        return FALSE;
    }
    
    MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)  {return NULL;}
}; 

#endif /* _H_CLSLOAD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comarrayhelpers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Helper methods for the Array class
// Specifically, this contains indexing, sorting & searching templates.
// Brian Grunkemeyer   March, 2001.


#ifndef _COMARRAYHELPERS_H_
#define _COMARRAYHELPERS_H_

#include "fcall.h"


template <class KIND>
class ArrayHelpers
{
public:
    static int IndexOf(KIND array[], UINT32 index, UINT32 count, KIND value) {
        _ASSERTE(array != NULL && index >= 0 && count >= 0);
        for(UINT32 i=index; i<index+count; i++)
            if (array[i] == value)
                return i;
        return -1;
    }

    static int LastIndexOf(KIND array[], UINT32 index, UINT32 count, KIND value) {
        _ASSERTE(array != NULL && index >= 0 && count >= 0);
        // Note (index - count) may be -1.
        for(UINT32 i=index; (int)i>(int)(index - count); i--)
            if (array[i] == value)
                return i;
        return -1;
    }

    // This needs to be written this way to handle unsigned numbers & wraparound issues,
    // I believe.  Perhaps someone can come up with some better way using subtraction,
    // but I don't know what it would be off-hand.
    inline static int Compare(KIND value1, KIND value2) {
        if (value1 < value2)
            return -1;
        else if (value1 > value2)
            return 1;
        return 0;
    }

    static int BinarySearchBitwiseEquals(KIND array[], int index, int length, KIND value) {
        _ASSERTE(array != NULL && length >= 0 && index >= 0);
        int lo = index;
        int hi = index + length - 1;
        // Note: if length == 0, hi will be Int32.MinValue, and our comparison
        // here between 0 & -1 will prevent us from breaking anything.
        while (lo <= hi) {
            int i = (lo + hi) >> 1;
            int c = Compare(array[i], value);
            if (c == 0) return i;
            if (c < 0) {
                lo = i + 1;
            }
            else {
                hi = i - 1;
            }
        }
        return ~lo;
    }

    static void QuickSort(KIND keys[], KIND items[], int left, int right) {
        // Make sure left != right in your own code.
        _ASSERTE(keys != NULL && left < right);
        do {
            int i = left;
            int j = right;
            KIND x = keys[(i + j) >> 1];
            do {
                while (Compare(keys[i], x) < 0) i++;
                while (Compare(x, keys[j]) < 0) j--;
                _ASSERTE(i>=left && j<=right);  // make sure Compare isn't broken.
                if (i > j) break;
                if (i < j) {
                    KIND key = keys[i];
                    keys[i] = keys[j];
                    keys[j] = key;
                    if (items != NULL) {
                        KIND item = items[i];
                        items[i] = items[j];
                        items[j] = item;
                    }
                }
                i++;
                j--;
            } while (i <= j);
            if (j - left <= right - i) {
                if (left < j) QuickSort(keys, items, left, j);
                left = i;
            }
            else {
                if (i < right) QuickSort(keys, items, i, right);
                right = j;
            }
        } while (left < right);
    }

    static void Reverse(KIND array[], UINT32 index, UINT32 count) {
        _ASSERTE(array != NULL);
        if (count == 0) {
            return;
        }
        UINT32 i = index;
        UINT32 j = index + count - 1;
        while(i < j) {
            KIND temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            i++;
            j--;
        }
    }
};


class ArrayHelper
{
    public:
    // These methods return TRUE or FALSE for success or failure, and the real
    // result is an out param.  They're helpers to make operations on SZ arrays of 
    // primitives significantly faster.
    static FCDECL5(INT32, TrySZIndexOf, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal);
    static FCDECL5(INT32, TrySZLastIndexOf, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal);
    static FCDECL5(INT32, TrySZBinarySearch, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal);

    static FCDECL4(INT32, TrySZSort, ArrayBase * keys, ArrayBase * items, UINT32 left, UINT32 right);
    static FCDECL3(INT32, TrySZReverse, ArrayBase * array, UINT32 index, UINT32 count);
};

#endif // _COMARRAYHELPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comarrayhelpers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "common.h"

#include <object.h>
#include <winnls.h>
#include "ceeload.h"

#include "utilcode.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "classNames.h"
#include "COMArrayHelpers.h"

// A fast IndexOf method for arrays of primitive types.  Returns TRUE or FALSE
// if it succeeds, and stores result in retVal.
FCIMPL5(INT32, ArrayHelper::TrySZIndexOf, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal)
    VALIDATEOBJECTREF(array);
    _ASSERTE(array != NULL);

    // @TODO: Eventually, consider adding support for single dimension arrays with
    // non-zero lower bounds.  VB might care.  
    if (array->GetRank() != 1 || array->GetLowerBoundsPtr()[0] != 0)
        return FALSE;

    _ASSERTE(retVal != NULL);
	_ASSERTE(index <= array->GetNumComponents());
	_ASSERTE(count <= array->GetNumComponents());
	_ASSERTE(array->GetNumComponents() >= index + count);
    *retVal = 0xdeadbeef;  // Initialize the return value.
    // value can be NULL, but of course, will not be in primitive arrays.
    
    TypeHandle arrayTH = array->GetElementTypeHandle();
    const CorElementType arrayElType = arrayTH.GetSigCorElementType();
    if (!CorTypeInfo::IsPrimitiveType(arrayElType))
        return FALSE;
    // Handle special case of looking for a NULL object in a primitive array.
    if (value == NULL) {
        *retVal = -1;
        return TRUE;
    }
    TypeHandle valueTH = value->GetTypeHandle();
    if (arrayTH != valueTH)
        return FALSE;

    
    switch(arrayElType) {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        *retVal = ArrayHelpers<U1>::IndexOf((U1*) array->GetDataPtr(), index, count, *(U1*)value->UnBox());
        break;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        *retVal = ArrayHelpers<U2>::IndexOf((U2*) array->GetDataPtr(), index, count, *(U2*)value->UnBox());
        break;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
    IN_WIN32(case ELEMENT_TYPE_I:)
    IN_WIN32(case ELEMENT_TYPE_U:)
        *retVal = ArrayHelpers<U4>::IndexOf((U4*) array->GetDataPtr(), index, count, *(U4*)value->UnBox());
        break;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
    IN_WIN64(case ELEMENT_TYPE_I:)
    IN_WIN64(case ELEMENT_TYPE_U:)
        *retVal = ArrayHelpers<U8>::IndexOf((U8*) array->GetDataPtr(), index, count, *(U8*)value->UnBox());
        break;

    default:
        _ASSERTE(!"Unrecognized primitive type in ArrayHelper::TrySZIndexOf");
        return FALSE;
    }
    return TRUE;
FCIMPLEND

// A fast LastIndexOf method for arrays of primitive types.  Returns TRUE or FALSE
// if it succeeds, and stores result in retVal.
FCIMPL5(INT32, ArrayHelper::TrySZLastIndexOf, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal)
{
    VALIDATEOBJECTREF(array);
    _ASSERTE(array != NULL);

    // @TODO: Eventually, consider adding support for single dimension arrays with
    // non-zero lower bounds.  VB might care.  
    if (array->GetRank() != 1 || array->GetLowerBoundsPtr()[0] != 0)
        return FALSE;

    _ASSERTE(retVal != NULL);
    *retVal = 0xdeadbeef;  // Initialize the return value.
    // value can be NULL, but of course, will not be in primitive arrays.
    
    TypeHandle arrayTH = array->GetElementTypeHandle();
    const CorElementType arrayElType = arrayTH.GetSigCorElementType();
    if (!CorTypeInfo::IsPrimitiveType(arrayElType))
        return FALSE;
    // Handle special case of looking for a NULL object in a primitive array.
    // Also handle case where the array is of 0 length.
    if (value == NULL || array->GetNumComponents() == 0) {
        *retVal = -1;
        return TRUE;
    }

	_ASSERTE(index < array->GetNumComponents());
	_ASSERTE(count <= array->GetNumComponents());
    _ASSERTE(index + 1 >= count);

    TypeHandle valueTH = value->GetTypeHandle();
    if (arrayTH != valueTH)
        return FALSE;

    
    switch(arrayElType) {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        *retVal = ArrayHelpers<U1>::LastIndexOf((U1*) array->GetDataPtr(), index, count, *(U1*)value->UnBox());
        break;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        *retVal = ArrayHelpers<U2>::LastIndexOf((U2*) array->GetDataPtr(), index, count, *(U2*)value->UnBox());
        break;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
    IN_WIN32(case ELEMENT_TYPE_I:)
    IN_WIN32(case ELEMENT_TYPE_U:)
        *retVal = ArrayHelpers<U4>::LastIndexOf((U4*) array->GetDataPtr(), index, count, *(U4*)value->UnBox());
        break;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
    IN_WIN64(case ELEMENT_TYPE_I:)
    IN_WIN64(case ELEMENT_TYPE_U:)
        *retVal = ArrayHelpers<U8>::LastIndexOf((U8*) array->GetDataPtr(), index, count, *(U8*)value->UnBox());
        break;

    default:
        _ASSERTE(!"Unrecognized primitive type in ArrayHelper::TrySZLastIndexOf");
        return FALSE;
    }
    return TRUE;
}
FCIMPLEND


FCIMPL5(INT32, ArrayHelper::TrySZBinarySearch, ArrayBase * array, UINT32 index, UINT32 count, Object * value, INT32 * retVal)
    VALIDATEOBJECTREF(array);
    _ASSERTE(array != NULL);

    // @TODO: Eventually, consider adding support for single dimension arrays with
    // non-zero lower bounds.  VB might care.  
    if (array->GetRank() != 1 || array->GetLowerBoundsPtr()[0] != 0)
        return FALSE;

    _ASSERTE(retVal != NULL);
	_ASSERTE(index <= array->GetNumComponents());
	_ASSERTE(count <= array->GetNumComponents());
	_ASSERTE(array->GetNumComponents() >= index + count);
    *retVal = 0xdeadbeef;  // Initialize the return value.
    // value can be NULL, but of course, will not be in primitive arrays.

    TypeHandle arrayTH = array->GetElementTypeHandle();
    const CorElementType arrayElType = arrayTH.GetSigCorElementType();
    if (!CorTypeInfo::IsPrimitiveType(arrayElType))
        return FALSE;
    // Handle special case of looking for a NULL object in a primitive array.
    if (value == NULL) {
        *retVal = -1;
        return TRUE;
    }

    switch(arrayElType) {
    case ELEMENT_TYPE_I1:
		*retVal = ArrayHelpers<I1>::BinarySearchBitwiseEquals((I1*) array->GetDataPtr(), index, count, *(I1*)value->UnBox());
		break;

    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        *retVal = ArrayHelpers<U1>::BinarySearchBitwiseEquals((U1*) array->GetDataPtr(), index, count, *(U1*)value->UnBox());
        break;

    case ELEMENT_TYPE_I2:
        *retVal = ArrayHelpers<I2>::BinarySearchBitwiseEquals((I2*) array->GetDataPtr(), index, count, *(I2*)value->UnBox());
        break;

    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        *retVal = ArrayHelpers<U2>::BinarySearchBitwiseEquals((U2*) array->GetDataPtr(), index, count, *(U2*)value->UnBox());
        break;

    case ELEMENT_TYPE_I4:
        *retVal = ArrayHelpers<I4>::BinarySearchBitwiseEquals((I4*) array->GetDataPtr(), index, count, *(I4*)value->UnBox());
        break;

    case ELEMENT_TYPE_U4:
        *retVal = ArrayHelpers<U4>::BinarySearchBitwiseEquals((U4*) array->GetDataPtr(), index, count, *(U4*)value->UnBox());
        break;

    case ELEMENT_TYPE_R4:
        *retVal = ArrayHelpers<R4>::BinarySearchBitwiseEquals((R4*) array->GetDataPtr(), index, count, *(R4*)value->UnBox());
        break;

    case ELEMENT_TYPE_I8:
        *retVal = ArrayHelpers<I8>::BinarySearchBitwiseEquals((I8*) array->GetDataPtr(), index, count, *(I8*)value->UnBox());
        break;

    case ELEMENT_TYPE_U8:
        *retVal = ArrayHelpers<U8>::BinarySearchBitwiseEquals((U8*) array->GetDataPtr(), index, count, *(U8*)value->UnBox());
        break;

	case ELEMENT_TYPE_R8:
        *retVal = ArrayHelpers<R8>::BinarySearchBitwiseEquals((R8*) array->GetDataPtr(), index, count, *(R8*)value->UnBox());
        break;

    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        // In V1.0, IntPtr & UIntPtr are not fully supported types.  They do 
        // not implement IComparable, so searching & sorting for them should
        // fail.  In V1.1 or V2.0, this should change.  -- BrianGru, 3/20/2001
        return FALSE;

    default:
        _ASSERTE(!"Unrecognized primitive type in ArrayHelper::TrySZBinarySearch");
        return FALSE;
    }
    return TRUE;
FCIMPLEND


FCIMPL4(INT32, ArrayHelper::TrySZSort, ArrayBase * keys, ArrayBase * items, UINT32 left, UINT32 right)
    VALIDATEOBJECTREF(keys);
	VALIDATEOBJECTREF(items);
    _ASSERTE(keys != NULL);

    // @TODO: Eventually, consider adding support for single dimension arrays with
    // non-zero lower bounds.  VB might care.  
    if (keys->GetRank() != 1 || keys->GetLowerBoundsPtr()[0] != 0)
        return FALSE;

	_ASSERTE(left <= right);
	_ASSERTE(right < keys->GetNumComponents() || keys->GetNumComponents() == 0);

    TypeHandle keysTH = keys->GetElementTypeHandle();
    const CorElementType keysElType = keysTH.GetSigCorElementType();
    if (!CorTypeInfo::IsPrimitiveType(keysElType))
        return FALSE;
	if (items != NULL) {
		TypeHandle itemsTH = items->GetElementTypeHandle();
		if (keysTH != itemsTH)
			return FALSE;   // Can't currently handle sorting different types of arrays.
	}

	// Handle special case of a 0 element range to sort.
	// Consider both Sort(array, x, x) and Sort(zeroLen, 0, zeroLen.Length-1);
	if (left == right || right == 0xffffffff)
		return TRUE;

    switch(keysElType) {
    case ELEMENT_TYPE_I1:
		ArrayHelpers<I1>::QuickSort((I1*) keys->GetDataPtr(), (I1*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
		break;

    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        ArrayHelpers<U1>::QuickSort((U1*) keys->GetDataPtr(), (U1*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_I2:
        ArrayHelpers<I2>::QuickSort((I2*) keys->GetDataPtr(), (I2*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
		ArrayHelpers<U2>::QuickSort((U2*) keys->GetDataPtr(), (U2*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_I4:
		ArrayHelpers<I4>::QuickSort((I4*) keys->GetDataPtr(), (I4*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_U4:
        ArrayHelpers<U4>::QuickSort((U4*) keys->GetDataPtr(), (U4*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_R4:
        ArrayHelpers<R4>::QuickSort((R4*) keys->GetDataPtr(), (R4*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_I8:
        ArrayHelpers<I8>::QuickSort((I8*) keys->GetDataPtr(), (I8*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_U8:
        ArrayHelpers<U8>::QuickSort((U8*) keys->GetDataPtr(), (U8*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

	case ELEMENT_TYPE_R8:
        ArrayHelpers<R8>::QuickSort((R8*) keys->GetDataPtr(), (R8*) (items == NULL ? NULL : items->GetDataPtr()), left, right);
        break;

    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        // In V1.0, IntPtr & UIntPtr are not fully supported types.  They do 
        // not implement IComparable, so searching & sorting for them should
        // fail.  In V1.1 or V2.0, this should change.  -- BrianGru, 3/20/2001
        return FALSE;

    default:
        _ASSERTE(!"Unrecognized primitive type in ArrayHelper::TrySZSort");
        return FALSE;
    }
    return TRUE;
FCIMPLEND

FCIMPL3(INT32, ArrayHelper::TrySZReverse, ArrayBase * array, UINT32 index, UINT32 count)
{
    VALIDATEOBJECTREF(array);
    _ASSERTE(array != NULL);

    // @TODO: Eventually, consider adding support for single dimension arrays with
    // non-zero lower bounds.  VB might care.  
    if (array->GetRank() != 1 || array->GetLowerBoundsPtr()[0] != 0)
        return FALSE;

	_ASSERTE(index <= array->GetNumComponents());
	_ASSERTE(count <= array->GetNumComponents());
	_ASSERTE(array->GetNumComponents() >= index + count);

    TypeHandle arrayTH = array->GetElementTypeHandle();
    const CorElementType arrayElType = arrayTH.GetSigCorElementType();
    if (!CorTypeInfo::IsPrimitiveType(arrayElType))
        return FALSE;

    switch(arrayElType) {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        ArrayHelpers<U1>::Reverse((U1*) array->GetDataPtr(), index, count);
        break;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        ArrayHelpers<U2>::Reverse((U2*) array->GetDataPtr(), index, count);
        break;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
    IN_WIN32(case ELEMENT_TYPE_I:)
    IN_WIN32(case ELEMENT_TYPE_U:)
        ArrayHelpers<U4>::Reverse((U4*) array->GetDataPtr(), index, count);
        break;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
    IN_WIN64(case ELEMENT_TYPE_I:)
    IN_WIN64(case ELEMENT_TYPE_U:)
        ArrayHelpers<U8>::Reverse((U8*) array->GetDataPtr(), index, count);
        break;

    default:
        _ASSERTE(!"Unrecognized primitive type in ArrayHelper::TrySZReverse");
        return FALSE;
    }
    return TRUE;
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\codeman.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/******************************************************************************

Module Name:

    codeman.h

Abstract:

    Wrapper to facilitate Multiple JIT support in the COM+ Runtime

    The ExecutionManager is responsible for managing the RangeSections.
    Given an IP, it can find the RangeSection which holds that IP.

    RangeSections contain the JITed codes. Each RangeSection knows the 
    IJitManager which created it.

    An IJitManager knows about which method bodiess live in each RangeSection.
    It can handle methods of one given CodeType. It can map a method body to
    a MethodDesc. It knows where the GCInfo about the method lives.

    An ICodeManager knows how to crack a specific format of GCInfo. There is
    a default format (handled by ExecutionManager::GetDefaultCodeManager())
    which can be shared by different IJitManagers/IJitCompilers.

    An ICorJitCompiler knows how to generate code for a method IL, and produce
    GCInfo in a format which the corresponding IJitManager's ICodeManager 
    can handle.

                                            ExecutionManager
                                                    |
                        +-----------+---------------+---------------+-----------+--- ...
                        |           |                               |           |
                     CodeType       |                            CodeType       |
                        |           |                               |           |
                        v           v                               v           v
+------------+      +--------+<---- R       +------------+      +--------+<---- R
|ICorJitCompiler|<---->|IJitMan |<---- R       |ICorJitCompiler|<---->|IJitMan |<---- R
+------------+      +--------+<---- R       +------------+      +--------+<---- R
                        |       x   .                               |       x   .
                        |        \  .                               |        \  .
                        v         \ .                               v         \ .
                    +--------+      R                           +--------+      R
                    |ICodeMan|                                  |ICodeMan|     (RangeSections)
                    +--------+                                  +--------+       

******************************************************************************/

#ifndef __CODEMAN_HPP__

#define __CODEMAN_HPP__

// this is the define the make ejitted code recognizable from regular jit even though they are
// both IL.

#define   miManaged_IL_EJIT             (miMaxMethodImplVal + 1)

#include "crst.h"
#include "EETwain.h"
#include "ceeload.h"
#include "jitinterface.h"
#include <member-offset-info.h>

class MethodDesc;
class ICorJitCompiler;
class IJitManager;
class EEJitManager;
class ExecutionManager;
class Thread;
class CrawlFrame;
//struct EE_ILEXCEPTION_CLAUSE : public IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT {
//};
struct EE_ILEXCEPTION;
struct EE_ILEXCEPTION_CLAUSE;
typedef unsigned EH_CLAUSE_ENUMERATOR;

inline DWORD MIN (DWORD a, DWORD b);

#define MDTOKEN_CACHE 1

typedef struct _hpCodeHdr 
{
    BYTE               *phdrJitGCInfo;
    // Note - (pCodeHeader->phdrJitEHInfo - sizeof(unsigned)) contains the number of EH clauses
    // See EEJitManager::allocEHInfo
    EE_ILEXCEPTION     *phdrJitEHInfo;
    MethodDesc         *hdrMDesc;
} CodeHeader;

#define GETJITINFOPTR(x) ((CodeHeader*)x)->phdrJitInfoBlock
#define GETJITEHTABLE(x) ((((CodeHeader*)x)->phdrJitEhTable) ? (unsigned)(((CodeHeader*)x)->phdrJitEhTable)+ sizeof(WORD) : NULL)
#define GETJITEHCOUNT(x) ((((CodeHeader*)x)->phdrJitEhTable) ? *((WORD*)(((CodeHeader*)x)->phdrJitEhTable)): 0)
#define GETJITPPMD(x)    (&((CodeHeader*)x)->hdrMDesc)

struct HeapList
{
    HeapList           *hpNext;
    LoaderHeap         *pHeap;
    PBYTE               startAddress;
    PBYTE               endAddress;
    volatile PBYTE      changeStart;
    volatile PBYTE      changeEnd;
    PBYTE               mapBase;
    DWORD              *pHdrMap;
    DWORD               cBlocks;
    size_t              maxCodeHeapSize;
#ifdef MDTOKEN_CACHE
    PBYTE               pCacheSpacePtr;
    size_t              bCacheSpaceSize;
#endif // #ifdef MDTOKEN_CACHE
};

typedef struct _rangesection
{
    void               *LowAddress;
    void               *HighAddress;

    IJitManager        *pjit;
    void               *ptable;

    struct _rangesection *pright;
    struct _rangesection *pleft;
} RangeSection;



/*****************************************************************************/

#define FAILED_JIT      0x01
#define FAILED_OJIT     0x02
#define FAILED_EJIT     0x04

#define MIH_GC_OFFSET (offsetof(IMAGE_COR_MIH_ENTRY, MIHData) - offsetof(IMAGE_COR_MIH_ENTRY, Flags))

struct _METHODTOKEN {};
typedef struct _METHODTOKEN * METHODTOKEN;  // METHODTOKEN = startAddress for managed native
                                            //             = codeheader for EEJitManager
                                            //             = JittedMethodInfo for EconoJitManager

class IJitManager 
{
public:
    enum ScanFlag    {ScanReaderLock, ScanNoReaderLock};

    IJitManager();
    virtual ~IJitManager();

    virtual BOOL SupportsPitching() = 0;
    // Note that one shouldn't call IsMethodInfoValid unless
    // SupportsPitching() is TRUE;
    virtual BOOL IsMethodInfoValid(METHODTOKEN methodToken) = 0;

    virtual MethodDesc* JitCode2MethodDesc(SLOT currentPC, ScanFlag scanFlag=ScanReaderLock) = 0;
    virtual void        JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset, ScanFlag scanFlag=ScanReaderLock) = 0;
    virtual MethodDesc* JitTokenToMethodDesc(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock)=0;
    virtual BYTE*       JitToken2StartAddress(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock)=0;
    virtual unsigned    InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState)=0;
    virtual EE_ILEXCEPTION_CLAUSE*      GetNextEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHclause)=0; 
    virtual void        ResolveEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHClauseOut)=0;
    virtual void*       GetGCInfo(METHODTOKEN MethodToken)=0;
    virtual void        RemoveJitData(METHODTOKEN MethodToken)=0;
    virtual void        Unload(MethodDesc *pFD)=0;      // for class unloading
    virtual void        Unload(AppDomain *pDomain)=0;   // for appdomain unloading
    virtual BOOL        LoadJIT(LPCWSTR szJITdll);
    virtual void        ResumeAtJitEH   (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)=0;
    virtual int         CallJitEHFilter (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj)=0;
    virtual void        CallJitEHFinally(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel)=0;

    virtual HRESULT     alloc(size_t code_len, 
                              unsigned char** pCode,
                              size_t EHinfo_len, 
                              unsigned char** pEHinfo,
                              size_t GCinfo_len, 
                              unsigned char** pGCinfo,
                              MethodDesc* pMethodDescriptor)=0;
    // The following three should eventually go away and replaced by the single alloc above
    virtual CodeHeader*         allocCode(MethodDesc* pFD, size_t numBytes)=0;
    virtual BYTE*               allocGCInfo(CodeHeader* pCodeHeader, DWORD numBytes)=0;
    virtual EE_ILEXCEPTION*     allocEHInfo(CodeHeader* pCodeHeader, unsigned numClauses)=0;

    virtual BOOL            IsStub(const BYTE* address)=0;
    virtual const BYTE*     FollowStub(const BYTE* address)=0;

    void SetCodeManager(ICodeManager *codeMgr, BOOL bIsDefault)
    {
        m_runtimeSupport = codeMgr;
        m_IsDefaultCodeMan = bIsDefault;
        return;
    }

    ICodeManager *GetCodeManager() 
    {
        // @TODO - LBS
        // This really needs to go back to the MIH if it is for Managed Native!
        return m_runtimeSupport;
    }

    void SetCodeType(DWORD type)
    {
        m_CodeType = type;
        return;
    }

    DWORD GetCodeType()
    {
        return(m_CodeType);
    }

    BOOL IsJitForType(DWORD type)
    {
        if (type == m_CodeType)
            return TRUE;
        else
            return FALSE;
    }
    
    virtual BYTE* GetNativeEntry(BYTE* startAddress)=0;
    // Edit & Continue functions
    static BOOL UpdateFunction(MethodDesc *pFunction, COR_ILMETHOD *pNewCode);
    static BOOL JITFunction(MethodDesc *pFunction);
    static BOOL ForceReJIT(MethodDesc *pFunction);

    static ScanFlag GetScanFlags();

    // The calls onto the jit!
    ICorJitCompiler           *m_jit;
    IJitManager           *m_next;

protected:

    DWORD           m_CodeType;
    BOOL            m_IsDefaultCodeMan;
    ICodeManager*   m_runtimeSupport;
    HINSTANCE       m_JITCompiler;
};


/*****************************************************************************/

class EEJitManager :public IJitManager
{
    friend struct MEMBER_OFFSET_INFO(EEJitManager);

public:

    EEJitManager();
    ~EEJitManager();

    //LPVOID HeapStartAddress();    No one seems to be using it

    //LPVOID HeapEndAddress();      No one seems to be using it
    virtual void        JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset, ScanFlag scanFlag=ScanReaderLock);
    virtual MethodDesc* JitCode2MethodDesc(SLOT currentPC, ScanFlag scanFlag);
    static  BYTE*       JitToken2StartAddressStatic(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock);
    virtual BYTE*       JitToken2StartAddress(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock);
    virtual unsigned    InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState);
    virtual EE_ILEXCEPTION_CLAUSE*      GetNextEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHclause); 
    virtual void        ResolveEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHClauseOut);
    void*               GetGCInfo(METHODTOKEN methodToken);
    virtual void        RemoveJitData(METHODTOKEN methodToken);
    virtual void        Unload(MethodDesc *pFD) {}
    virtual void        Unload(AppDomain *pDomain);
    virtual BOOL        LoadJIT(LPCWSTR wzJITdll);
    virtual void        ResumeAtJitEH   (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack);
    virtual int         CallJitEHFilter (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj);
    virtual void        CallJitEHFinally(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel);
    _inline HRESULT     alloc(size_t code_len, 
                              unsigned char** pCode,
                              size_t EHinfo_len, 
                              unsigned char** pEHinfo,
                              size_t GCinfo_len, 
                              unsigned char** pGCinfo,
                              MethodDesc* pMethodDescriptor)
    {
        _ASSERTE(!"NYI - should not get here!");
        return (E_FAIL);
    }

    CodeHeader*         allocCode(MethodDesc* pFD, size_t numBytes);
    BYTE*               allocGCInfo(CodeHeader* pCodeHeader, DWORD numBytes);
    EE_ILEXCEPTION*     allocEHInfo(CodeHeader* pCodeHeader, unsigned numClauses);

    inline virtual BOOL     IsStub(const BYTE* address)
    { // This is needed by the debugger, this code manager does not produce stubs, so always return false 
        return false;
    }

    inline virtual const BYTE* FollowStub(const BYTE* address)
    {
        _ASSERTE(!"Should not be called");
        return NULL;
    }

    inline MethodDesc* JitTokenToMethodDesc(METHODTOKEN MethodToken, ScanFlag scanFlag)
    {
        return ((CodeHeader*) MethodToken)->hdrMDesc;
    }

    // Heap Managament functions
    static void NibbleMapSet(DWORD *pMap, size_t pos, DWORD value);
    static DWORD* FindHeader(DWORD *pMap, size_t addr);

    inline virtual BYTE* GetNativeEntry(BYTE* startAddress)
    {
        return startAddress;
    }

    BOOL SupportsPitching() { return FALSE; }
    BOOL IsMethodInfoValid(METHODTOKEN methodToken) {return TRUE;}


/* =========== NOT CURRENTLY USED =====================
    void *NewNativeHeap(DWORD startAddr, DWORD length);
    BOOL IsJITforCurrentIP(DWORD currentPC);
   =========== NOT CURRENTLY USED ===================*/

private :
    struct DomainCodeHeapList {
        BaseDomain *m_pDomain;
        CDynArray<HeapList *> m_CodeHeapList;
        DomainCodeHeapList();
        ~DomainCodeHeapList();
    };
    VOID        ScavengeJitHeaps(BOOL bHeapShutdown);       // no external client seems to be using it

    HeapList*   NewCodeHeap(LoaderHeap *pJitMetaHeap, size_t MaxCodeHeapSize); 
    HeapList*   NewCodeHeap(MethodDesc *pMD, size_t MaxCodeHeapSize);
    HeapList*   NewCodeHeap(DomainCodeHeapList *pHeapList, size_t MaxCodeHeapSize);
    DomainCodeHeapList *GetCodeHeapList(BaseDomain *pDomain);
    HeapList*   GetCodeHeap(MethodDesc *pMD);
    LoaderHeap* GetJitMetaHeap(MethodDesc *pMD);
    void        DeleteCodeHeap(HeapList *pHeapList);

    static BYTE* GetCodeBody(CodeHeader* pCodeHeader)
    {
        return ((BYTE*) (pCodeHeader + 1));
    }

    CodeHeader * GetCodeHeader(void* startAddress)
    {
         return ((CodeHeader*)(((size_t) startAddress)&~3)) - 1;
    }
    inline void copyExceptionClause(EE_ILEXCEPTION_CLAUSE* dest, EE_ILEXCEPTION_CLAUSE* src)
    {
        memcpy(dest, src, sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    }

    CodeHeader* JitCode2CodeHeader(DWORD currentPC);
    HeapList    *m_pCodeHeap;
    Crst        *m_pCodeHeapCritSec;
    BYTE        m_CodeHeapCritSecInstance[sizeof(Crst)];

    // must hold critical section to access this structure.
    CUnorderedArray<DomainCodeHeapList *, 5> m_DomainCodeHeaps;

    // infrastructure to manage readers so we can lock them out and delete domain data
    volatile LONG        m_dwReaderCount;
    volatile LONG        m_dwWriterLock;

	void JitCode2MethodTokenAndOffsetWrapper(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset);
    IJitManager* FindJitManNonZeroWrapper(SLOT currentPC);

#ifdef MDTOKEN_CACHE
	void AddRangeToJitHeapCache (PBYTE startAddr, PBYTE endAddr, HeapList* pHp);
    void DeleteJitHeapCache (HeapList *pHeapList);
    size_t GetCodeHeapCacheSize (size_t bAllocationRequest);
    void ScavengeJitHeapCache ();

    const static DWORD HASH_BUCKETS = 256;
    typedef struct _HashEntry
    {
        size_t currentPC; // Key stored as (currentPC & 0xFFFF0000), hash is computed as (currentPC & 0x00FF0000) >> 16
        HeapList *pHp;    // Value points to the HeapList's node
        struct _HashEntry* pNext;
    } HashEntry;
    HashEntry *m_JitCodeHashTable[HASH_BUCKETS];
    HashEntry *m_pJitHeapCacheUnlinkedList;
#ifdef _DEBUG
    BOOL DebugContainedInHeapList (HeapList *pHashEntryHp);
    void DebugCheckJitHeapCacheValidity ();
#endif // _DEBUG
#endif // MDTOKEN_CACHE


};


//*****************************************************************************
// This class manages code managers and jitters.  It has only static
// members.  It should never be constucted.
//*****************************************************************************

class ExecutionManager
{
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(ExecutionManager);
    
    static IJitManager*  FindJitManNonZeroWrapper(SLOT currentPC);
    static IJitManager*  FindJitManNonZero(SLOT currentPC, IJitManager::ScanFlag scanFlag=IJitManager::ScanReaderLock);
public :

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    // this gets called a lot for stackwalking, so inline the zero case
    static IJitManager*   FindJitMan(SLOT currentPC, IJitManager::ScanFlag scanFlag=IJitManager::ScanReaderLock)
    {
        return (currentPC ? FindJitManNonZero(currentPC, scanFlag) : NULL);
    }

    static IJitManager*   FindJitManPCOnly(SLOT currentPC)
    {
        return (currentPC ? FindJitManNonZeroWrapper(currentPC) : NULL);
    }

    // Find a code manager from the current locations of the IP
    static ICodeManager* FindCodeMan(SLOT currentPC, IJitManager::ScanFlag scanFlag=IJitManager::ScanReaderLock) 
    {
        IJitManager * pJitMan = FindJitMan(currentPC, scanFlag);
        return pJitMan ? pJitMan->GetCodeManager() : NULL;
    }

    static IJitManager*   FindJitForType(DWORD Flags);
    static IJitManager*   GetJitForType(DWORD Flags);

    static void           Unload(AppDomain *pDomain);
    
    static void           AddJitManager(IJitManager * newjitmgr);
    static BOOL           AddRange(LPVOID StartRange,LPVOID EndRange,
                                   IJitManager* pJit, LPVOID Table);
    static void           DeleteRange(LPVOID StartRange);

    static void           DeleteRanges(RangeSection *subtree);
    static ICodeManager*  GetDefaultCodeManager()
    {
        return m_pDefaultCodeMan;    
    }
    static CORCOMPILE_METHOD_HEADER*    GetMethodHeaderForAddress(LPVOID startAddress, IJitManager::ScanFlag scanFlag=IJitManager::ScanReaderLock);
    static CORCOMPILE_METHOD_HEADER*    GetMethodHeaderForAddressWrapper(LPVOID startAddress, IJitManager::ScanFlag scanFlag=IJitManager::ScanReaderLock);

private : 

    static RangeSection    *m_RangeTree;
    static IJitManager     *m_pJitList;
    static EECodeManager   *m_pDefaultCodeMan;
    static Crst            *m_pExecutionManagerCrst;
    static BYTE             m_ExecutionManagerCrstMemory[sizeof(Crst)];
    static Crst            *m_pRangeCrst;
    static BYTE             m_fFailedToLoad;

    // since typically have one code heap for AD, if are still in the same
    // AD will usually want the same range we just found something in.
    static RangeSection    *m_pLastUsedRS;

    // infrastructure to manage readers so we can lock them out and delete domain data
    // make ReaderCount volatile because we have order dependency in READER_INCREMENT
    static volatile LONG   m_dwReaderCount;
    static volatile LONG   m_dwWriterLock;
};


// this is only called from a couple of places, but inlining helps EH perf
inline void* EEJitManager::GetGCInfo(METHODTOKEN methodToken)
{
    return ((CodeHeader*)methodToken)->phdrJitGCInfo;
}

inline unsigned char* EEJitManager::JitToken2StartAddress(METHODTOKEN MethodToken, IJitManager::ScanFlag scanFlag)
{
    return JitToken2StartAddressStatic(MethodToken, scanFlag);
}

inline BYTE* EEJitManager::JitToken2StartAddressStatic(METHODTOKEN MethodToken, IJitManager::ScanFlag scanFlag)
{ 
    if (MethodToken)
        return GetCodeBody((CodeHeader *) MethodToken);
    return NULL;
}


//*****************************************************************************
// Stub JitManager for Managed native.

class MNativeJitManager : public IJitManager 
{
public:
    MNativeJitManager();
    ~MNativeJitManager();

    BOOL Init();

    virtual MethodDesc* JitCode2MethodDesc(SLOT currentPC, ScanFlag scanFlag=ScanReaderLock);
    virtual void JitCode2MethodTokenAndOffset(SLOT currentPC, METHODTOKEN* pMethodToken, DWORD* pPCOffset, ScanFlag scanFlag=ScanReaderLock);
    
    virtual MethodDesc* JitTokenToMethodDesc(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock)
    {
        return JitCode2MethodDesc((SLOT) MethodToken, scanFlag);
    }

    virtual BYTE*       JitToken2StartAddress(METHODTOKEN MethodToken, ScanFlag scanFlag=ScanReaderLock);
    virtual unsigned    InitializeEHEnumeration(METHODTOKEN MethodToken, EH_CLAUSE_ENUMERATOR* pEnumState);

    virtual EE_ILEXCEPTION_CLAUSE*      GetNextEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHclause);
    
    virtual void        ResolveEHClause(METHODTOKEN MethodToken,
                                        EH_CLAUSE_ENUMERATOR* pEnumState, 
                                        EE_ILEXCEPTION_CLAUSE* pEHClauseOut);
    
    virtual void*       GetGCInfo(METHODTOKEN MethodToken);
    
    virtual void        ResumeAtJitEH   (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack);
    virtual int         CallJitEHFilter (CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj);
    virtual void        CallJitEHFinally(CrawlFrame* pCf, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel);

    virtual void        RemoveJitData(METHODTOKEN MethodToken) {}
    virtual void        Unload(MethodDesc *pFD) {}
    virtual void        Unload(AppDomain *pDomain) {}

    virtual BOOL        LoadJIT(LPCWSTR szJITdll) { return TRUE; }

    BOOL SupportsPitching() { return FALSE; }
    BOOL IsMethodInfoValid(METHODTOKEN methodToken) {return TRUE;}

    virtual HRESULT     alloc(size_t code_len, 
                              unsigned char** pCode,
                              size_t EHinfo_len, 
                              unsigned char** pEHinfo,
                              size_t GCinfo_len, 
                              unsigned char** pGCinfo,
                              MethodDesc* pMethodDescriptor)
    {
        _ASSERTE(!"Managed Native NYI : alloc");
        return E_NOTIMPL;
    }
    // The following three should eventually go away and replaced by the single alloc above
    virtual CodeHeader*         allocCode(MethodDesc* pFD, size_t numBytes)
    {
        _ASSERTE(!"Managed Native NYI : allocCode");
        return NULL;
    }
    virtual BYTE*               allocGCInfo(CodeHeader* pCodeHeader, DWORD numBytes)
    {
        _ASSERTE(!"Managed Native NYI : allocGCInfo");
        return NULL;
    }
    virtual EE_ILEXCEPTION*     allocEHInfo(CodeHeader* pCodeHeader, unsigned numClauses)
    {
        _ASSERTE(!"Managed Native NYI : allocEHInfo");
        return NULL;
    }
    virtual BOOL IsStub(const BYTE* address) { return FALSE; }
    virtual const BYTE* FollowStub(const BYTE* address) { return NULL; } 


    virtual BYTE* GetNativeEntry(BYTE* startAddress) { return startAddress; }
    
    // E&C functions
    virtual BOOL UpdateFunction(MethodDesc *pFunction, COR_ILMETHOD *pNewCode)
    {
        _ASSERTE(!"Managed Native NYI : E&C Support");
        return FALSE;
    }

    virtual BOOL JITFunction(MethodDesc *pFunction)
    {
        _ASSERTE(!"Managed Native NYI : E&C Support");
        return FALSE;
    }

    virtual BOOL ForceReJIT(MethodDesc *pFunction)
    {
        _ASSERTE(!"Managed Native NYI : E&C Support");
        return FALSE;
    }

private :
    Crst        *m_pMNativeCritSec;
    BYTE        m_pMNativeCritSecInstance[sizeof(Crst)];

    inline void copyExceptionClause(EE_ILEXCEPTION_CLAUSE* dest, EE_ILEXCEPTION_CLAUSE* src)
    {
        memcpy(dest, src, sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    }

};

inline void* MNativeJitManager::GetGCInfo(METHODTOKEN methodToken)
{
    CORCOMPILE_METHOD_HEADER *pHeader = ExecutionManager::GetMethodHeaderForAddress((void *) methodToken);

    return pHeader->gcInfo;
}

//*****************************************************************************
// Implementation of the ICodeInfo interface

class EECodeInfo : public ICodeInfo
{
public:

    EECodeInfo(METHODTOKEN token, IJitManager * pJM);
    EECodeInfo(METHODTOKEN token, IJitManager * pJM, MethodDesc * pMD);

    const char* __stdcall getMethodName(const char **moduleName /* OUT */ );
    DWORD       __stdcall getMethodAttribs();
    DWORD       __stdcall getClassAttribs();
    void        __stdcall getMethodSig(CORINFO_SIG_INFO *sig /* OUT */ );
    LPVOID      __stdcall getStartAddress();
    void *                getMethodDesc_HACK() { return m_pMD; }

    METHODTOKEN         m_methodToken;
    MethodDesc         *m_pMD;
    IJitManager        *m_pJM;
    static CEEInfo     s_ceeInfo;
};


//*****************************************************************************

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comarrayinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// COMArrayInfo
//	This file defines the native methods for the ArrayInfo class
//	found in reflection.  ArrayInfo allows for late bound access
//	to COM+ Arrays.
//
// Author: Daryl Olander (darylo)
// Date: August 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef __COMARRAYINFO_H__
#define __COMARRAYINFO_H__

#include "fcall.h"

class COMArrayInfo
{
private:
	// CreateObject
	// Given an array and offset, we will either 1) return the object or create a boxed version
	//	(This object is returned as a LPVOID so it can be directly returned.)
	static BOOL CreateObject(BASEARRAYREF* arrObj,DWORD dwOffset,TypeHandle elementType,ArrayClass* pArray, Object*& newObject);

	// SetFromObject
	// Given an array and offset, we will set the object or value.
	static void SetFromObject(BASEARRAYREF* arrObj,DWORD dwOffset,TypeHandle elementType,ArrayClass* pArray,OBJECTREF* pObj);

public:
	// This method will create a new array of type type, with zero lower
	//	bounds and rank.
	struct _CreateInstanceArgs {
 		DECLARE_ECALL_I4_ARG(INT32, length3); 
 		DECLARE_ECALL_I4_ARG(INT32, length2); 
 		DECLARE_ECALL_I4_ARG(INT32, length1); 
  		DECLARE_ECALL_I4_ARG(INT32, rank); 
 		DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, type); 
	};
	static LPVOID __stdcall CreateInstance(_CreateInstanceArgs* args);

	struct _CreateInstanceExArgs {
 		DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, lowerBounds); 
 		DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, lengths); 
 		DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, type); 
	};
	static LPVOID __stdcall CreateInstanceEx(_CreateInstanceExArgs* args);

	// GetValue
	// This method will return a value found in an array as an Object
    static FCDECL4(Object*, GetValue, ArrayBase * _refThis, INT32 index1, INT32 index2, INT32 index3);

	struct _GetValueExArgs {
 		DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, refThis);
 		DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, indices);
	};
	static LPVOID __stdcall GetValueEx(_GetValueExArgs* args);

	// SetValue
	// This set of methods will set a value in an array
	struct _SetValueArgs {
 		DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, refThis);
		DECLARE_ECALL_I4_ARG(INT32, index3); 
		DECLARE_ECALL_I4_ARG(INT32, index2); 
		DECLARE_ECALL_I4_ARG(INT32, index1); 
 		DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
	};
	static void __stdcall SetValue(_SetValueArgs* args);

	struct _SetValueExArgs {
 		DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, refThis);
 		DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, indices);
 		DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);		// Return reference
	};
	static void __stdcall SetValueEx(_SetValueExArgs* args);

	// This method will initialize an array from a TypeHandle
	//	to a field.
	static FCDECL2(void, InitializeArray, ArrayBase* vArrayRef, HANDLE handle);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcache.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_COMCACHE
#define _H_COMCACHE

#include "contxt.h"
#include "list.h"
#include "ctxtcall.h"

//================================================================
// Forward declarations.
struct InterfaceEntry;
struct IUnkEntry;
struct ComPlusWrapper;
class CtxEntryCache;
class CtxEntry;
class ApartmentCallbackHelper;
class Thread;

//================================================================
// OLE32 helpers.
LPVOID GetCurrentCtxCookie(BOOL fThreadDeath = FALSE);
HRESULT GetCurrentObjCtx(IUnknown **ppObjCtx);
LPVOID SetupOleContext();
BOOL IsComProxy(IUnknown *pUnk);
HRESULT wCoMarshalInterThreadInterfaceInStream(REFIID riid,LPUNKNOWN pUnk,
											   LPSTREAM *ppStm, BOOL fIsProxy);
HRESULT GetCurrentThreadTypeNT5(THDTYPE* pType);
HRESULT GetCurrentApartmentTypeNT5(APTTYPE* pType);
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, BYTE** ppBuf);


//==============================================================
// IUnkEntry: represent a single COM component 
struct IUnkEntry
{
    // The context entry needs to be a friend to be able to call InitSpecial.
    friend CtxEntry;

    LPVOID          m_pCtxCookie;   // context for the interface
    CtxEntry*       m_pCtxEntry;    // context entry for the interface
    IUnknown*       m_pUnknown;     // IUnknown interface
    								// valid
    long            m_Busy;         // A flag used for synchronization
    IStream*        m_pStream;      // IStream used for marshalling 
    union
    {
        struct
        {
            int      m_fLazyMarshallingAllowed : 1;  // Used to determine if lazy marshalling of the stream is allowed
            int      m_fApartmentCallback : 1;       // downlevel platform apartment callback
        };
        DWORD        m_dwBits;
    };

    // Initialize the entry.
    void Init(IUnknown *pUnk, BOOL bEagerlyMarshalToStream);

    // Free the IUnknown entry.
    VOID Free(BOOL bReleaseCtxEntry = TRUE);

    // Get IUnknown for the current context from IUnkEntry
    IUnknown* GetIUnknownForCurrContext();

    // Unmarshal IUnknown for the current context from IUnkEntry
    IUnknown* UnmarshalIUnknownForCurrContext();

    // Release the stream. This will force UnmarshalIUnknownForCurrContext to transition
    // into the context that owns the IP and re-marshal it to the stream.
    void ReleaseStream();

private:
    // Special init function called from the CtxEntry.
    void InitSpecial(IUnknown *pUnk, BOOL bEagerlyMarshalToStream, CtxEntry *pCtxEntry);

    // Callback called to marshal the IUnknown into a stream lazily.
    static HRESULT MarshalIUnknownToStreamCallback(LPVOID pData);

    // Helper function called from MarshalIUnknownToStreamCallback.
    HRESULT MarshalIUnknownToStream(bool fIsNormal = TRUE);

    // Method to try and start updating the the entry.
    BOOL TryUpdateEntry()
    {
        return FastInterlockExchange(&m_Busy, 1) == 0;
    }

    // Method to end updating the entry.
    VOID EndUpdateEntry()
    {
        m_Busy = 0;
    }
};


//==============================================================
// Interface Entry represents a single COM IP
struct InterfaceEntry
{
    // Member of the entry. These must be volatile so the compiler
    // will not try and optimize reads and writes to them.
    MethodTable * volatile  m_pMT;                  // Interface asked for
    IUnknown * volatile     m_pUnknown;             // Result of query

    // Initialize the entry.
    void Init(MethodTable *pMT, IUnknown *pUnk)
    {
        // This should never be called on an entry that was already initialized.
        _ASSERTE(m_pUnknown == NULL && m_pMT == NULL);

        // Its important the fields be set in this order.
        m_pUnknown = pUnk;
        m_pMT = pMT;
    }

    // Helper to determine if the entry is free.
    BOOL IsFree() {return m_pUnknown == NULL;}
};


//==============================================================
// An entry representing a COM+ 1.0 context or an appartment.
class CtxEntry
{
    // The CtxEntryCache needs to be able to see the internals
    // of the CtxEntry.
    friend CtxEntryCache;

private:
    // Disallow creation and deletion of the CtxEntries.
    CtxEntry(LPVOID pCtxCookie, Thread *pSTAThread);
    ~CtxEntry();

    // Initialization method called from the CtxEntryCache.
    BOOL Init();

    // Helper method to allocate an IUnkEntry instance.
    IUnkEntry *AllocateIUnkEntry();

public:
    // Add a reference to the CtxEntry.
    DWORD AddRef()
    {
        ULONG cbRef = FastInterlockIncrement((LONG *)&m_dwRefCount);
        LOG((LF_INTEROP, LL_INFO100, "CtxEntry::Addref %8.8x with %d\n", this, cbRef));
        return cbRef;
    }

    // Release a reference to the CtxEntry.
    DWORD Release();

	// DoAppropriate wait helpers.
	void EnterAppropriateWait();
    void SignalWaiters()
    {
        SetEvent(m_hEvent);
    }
	void ResetEvent()
	{
		::ResetEvent(m_hEvent);
	}

    // Function to enter the context. The specified callback function will
    // be called from within the context.
    HRESULT EnterContext(PFNCTXCALLBACK pCallbackFunc, LPVOID pData);

    // Accessor for the context cookie.
    LPVOID GetCtxCookie()
    {
        return m_pCtxCookie;
    }

    // Accessor for the STA thread.
    Thread *GetSTAThread()
    {
        return m_pSTAThread;
    }

private:
    // Accessor for the object context.
    LPVOID GetObjCtx()
    {
        return m_pObjCtx;
    }

    // Callback function called by DoCallback.
    static HRESULT __stdcall EnterContextCallback(ComCallData* pData);

    // Helper method to release the IUnkEntry for the callback helper.
    void ReleaseCallbackHelperIUnkEntry();

    DLink           m_Link;                 // The DList link, must be first member.
    LPVOID          m_pCtxCookie;           // The OPAQUE context cookie.
    IUnknown       *m_pObjCtx;              // The object context interface.
    DWORD           m_dwRefCount;           // The ref count.
    HANDLE          m_hEvent;               // Handle for synchronization.
    IUnkEntry      *m_pDoCallbackHelperUnkEntry;    // IUnkEntry to the callback helper on legacy platforms.
    Thread         *m_pSTAThread;           // STA thread associated with the context, if any
};


//==============================================================
// The cache of context entries.
class CtxEntryCache
{
    // The CtxEntry needs to be able to call some of the private
    // method of the CtxEntryCache.
    friend CtxEntry;

private:
    // Disallow creation and deletion of the CtxEntryCache.
    CtxEntryCache();
    ~CtxEntryCache();

public:
    // Static initialization routine for the CtxEntryCache.
    static BOOL Init();

    // Static termination routine for the CtxEntryCache.
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    // Static accessor for the one and only instance of the CtxEntryCache.
    static CtxEntryCache *GetCtxEntryCache()
    {
        _ASSERTE(s_pCtxEntryCache);
        return s_pCtxEntryCache;
    }

    // Method to retrieve/create a CtxEntry for the specified context cookie.
    CtxEntry *FindCtxEntry(LPVOID pCtxCookie, Thread *pSTAThread);
    
private:
    // Helper function called from the CtxEntry.
    void TryDeleteCtxEntry(LPVOID pCtxCookie);

    // Leave the reader lock.
    void Lock()
    {
		m_Lock.GetLock();
    }

    // Leave the writer lock.
    void UnLock()
    {
		m_Lock.FreeLock();
    }

    // Typedef for the singly linked list of context entries.
    typedef DList<CtxEntry, offsetof(CtxEntry, m_Link)> CTXENTRYDLIST;

	// CtxEntry list
    CTXENTRYDLIST		    m_ctxEntryList;

	// spin lock for fast synchronization	
	SpinLock                m_Lock;
    
    // The one and only instance for the context entry cache.
    static CtxEntryCache *  s_pCtxEntryCache;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comarrayinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This file contains the native methods that support the ArrayInfo class
//
// Author: Daryl Olander (darylo)
// Date: August, 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "COMArrayInfo.h"
#include "ReflectWrap.h"
#include "excep.h"
#include "COMMember.h"
#include "Field.h"
#include "remoting.h"
#include "COMCodeAccessSecurityEngine.h"

LPVOID __stdcall COMArrayInfo::CreateInstance(_CreateInstanceArgs* args)
{
    LPVOID rv;
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args->type != 0);
    ReflectClass* pRC = (ReflectClass*) args->type->GetData();

    // Never create an array of TypedReferences, at least for now.
    if (pRC->GetTypeHandle().GetClass()->ContainsStackPtr())
        COMPlusThrow(kNotSupportedException, L"NotSupported_ContainsStackPtr[]");

    CorElementType CorType = pRC->GetCorElementType();

    // If we're trying to create an array of pointers or function pointers,
    // check that the caller has skip verification permission.
    if (CorType == ELEMENT_TYPE_PTR || CorType == ELEMENT_TYPE_FNPTR)
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);

    // Allocate the rank one array
    if (args->rank==1 && CorType >= ELEMENT_TYPE_BOOLEAN && CorType <= ELEMENT_TYPE_R8) {
        OBJECTREF pRet;
        pRet = AllocatePrimitiveArray(CorType,args->length1);
        *((OBJECTREF *)&rv) = pRet;
        return rv;
    }

    // Find the Array class...
    ClassLoader* pLoader = pRC->GetModule()->GetClassLoader();
    TypeHandle typeHnd;

    _ASSERTE(pLoader);
    OBJECTREF throwable = 0;
    GCPROTECT_BEGIN(throwable);

    // Why not use FindArrayForElem??
    NameHandle typeName(args->rank == 1 ? ELEMENT_TYPE_SZARRAY : ELEMENT_TYPE_ARRAY,pRC->GetTypeHandle(),args->rank);

    typeHnd = pLoader->FindTypeHandle(&typeName, &throwable);
    if(throwable != 0)
        COMPlusThrow(throwable);
    GCPROTECT_END();

    _ASSERTE(!typeHnd.IsNull());

    _ASSERTE(args->rank >= 1 && args->rank <= 3);
    DWORD boundsSize;
    DWORD* bounds;
    if (typeHnd.AsArray()->GetNormCorElementType() != ELEMENT_TYPE_ARRAY) {
        boundsSize = args->rank;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));
        bounds[0] = args->length1;
        if (args->rank > 1) {
            bounds[1] = args->length2;
            if (args->rank == 3) {
                bounds[2] = args->length3;
            }
        }
    }
    else {
        boundsSize = args->rank * 2;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));
        bounds[0] = 0;
        bounds[1] = args->length1;
        if (args->rank > 1) {
            bounds[2] = 0;
            bounds[3] = args->length2;
            if (args->rank == 3) {
                bounds[4] = 0;
                bounds[5] = args->length3;
            }
        }
    }

    PTRARRAYREF pRet = (PTRARRAYREF) AllocateArrayEx(typeHnd, bounds, boundsSize);
    *((PTRARRAYREF *)&rv) = pRet;
    return rv;
}

// TODO These two routines are almost identical!! can we please factor them?
LPVOID __stdcall COMArrayInfo::CreateInstanceEx(_CreateInstanceExArgs* args)
{
    LPVOID rv;
    THROWSCOMPLUSEXCEPTION();

    int rank = args->lengths->GetNumComponents();
    bool lowerb = (args->lowerBounds != NULL) ? true : false;

    _ASSERTE(args->type != 0);
    ReflectClass* pRC = (ReflectClass*) args->type->GetData();

    // Never create an array of TypedReferences, ArgIterator, RuntimeArgument handle
    if (pRC->GetTypeHandle().GetClass()->ContainsStackPtr())
        COMPlusThrow(kNotSupportedException, L"NotSupported_ContainsStackPtr[]");

    CorElementType CorType = pRC->GetCorElementType();

    // If we're trying to create an array of pointers or function pointers,
    // check that the caller has skip verification permission.
    if (CorType == ELEMENT_TYPE_PTR || CorType == ELEMENT_TYPE_FNPTR)
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);

    // Find the Array class...
    ClassLoader* pLoader = pRC->GetModule()->GetClassLoader();
    TypeHandle typeHnd;
    _ASSERTE(pLoader);
    OBJECTREF throwable = 0;
    GCPROTECT_BEGIN(throwable);

    // Why not use FindArrayForElem??
    NameHandle typeName((rank == 1 && !lowerb) ? ELEMENT_TYPE_SZARRAY : ELEMENT_TYPE_ARRAY,pRC->GetTypeHandle(),rank);
    typeHnd = pLoader->FindTypeHandle(&typeName, &throwable);
    if(throwable != 0)
        COMPlusThrow(throwable);
    GCPROTECT_END();

    _ASSERTE(!typeHnd.IsNull());

    DWORD boundsSize;
    DWORD* bounds;
    if (typeHnd.AsArray()->GetNormCorElementType() != ELEMENT_TYPE_ARRAY) {
        boundsSize = rank;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));

        for (int i=0;i<rank;i++) {
            bounds[i] = args->lengths->m_Array[i];
        }
    }
    else {
        boundsSize = rank*2;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));

        int i,j;
        for (i=0,j=0;i<rank;i++,j+=2) {
            if (args->lowerBounds != 0) {
                bounds[j] = args->lowerBounds->m_Array[i];
                bounds[j+1] = args->lengths->m_Array[i];
            }
            else  {
                bounds[j] = 0;
                bounds[j+1] = args->lengths->m_Array[i];
            }
        }
    }

    PTRARRAYREF pRet = (PTRARRAYREF) AllocateArrayEx(typeHnd, bounds, boundsSize);
    *((PTRARRAYREF *)&rv) = pRet;
    return rv;
}

FCIMPL4(Object*, COMArrayInfo::GetValue, ArrayBase * _refThis, INT32 index1, INT32 index2, INT32 index3)
{
    _ASSERTE(_refThis != NULL);
    BASEARRAYREF refThis(_refThis);
    ArrayClass*     pArray;
    TypeHandle      arrayElementType;

    // Validate the array args
    THROWSCOMPLUSEXCEPTION();
    arrayElementType = refThis->GetElementTypeHandle();
    EEClass* pEEC = refThis->GetClass();
    pArray = (ArrayClass*) pEEC;

    DWORD Rank = pArray->GetRank();
    DWORD dwOffset = 0;
    DWORD dwMultiplier  = 1;
    const DWORD *pBoundsPtr = refThis->GetBoundsPtr();
    const DWORD *pLowerBoundsPtr = refThis->GetLowerBoundsPtr();


    _ASSERTE(Rank <= 3);

    for (int i = Rank-1; i >= 0; i--) {
        DWORD dwIndex;
        if (i == 2)
            dwIndex = index3 - pLowerBoundsPtr[i];
        else if (i == 1)
            dwIndex = index2 - pLowerBoundsPtr[i];
        else
            dwIndex = index1 - pLowerBoundsPtr[i];
        // Bounds check each index
        if (dwIndex >= pBoundsPtr[i])
            FCThrow(kIndexOutOfRangeException);

        dwOffset += dwIndex * dwMultiplier;
        dwMultiplier *= pBoundsPtr[i];
    }

    // Get the type of the element...
    CorElementType type = arrayElementType.GetSigCorElementType();
    // If it's a value type, erect a helper method frame before  
    // calling CreateObject.
    Object* rv = NULL;
    if (arrayElementType.GetMethodTable()->IsValueClass()) {
        HELPER_METHOD_FRAME_BEGIN_RET_1(refThis);
         if (!CreateObject(&refThis, dwOffset, arrayElementType, pArray, rv))
			COMPlusThrow(kNotSupportedException, L"NotSupported_Type");		// createObject only fails if it sees a type it does not know about
        HELPER_METHOD_FRAME_END();
    }
    else {
        if (!CreateObject(&refThis, dwOffset, arrayElementType, pArray, rv))
			FCThrowRes(kNotSupportedException, L"NotSupported_Type");		// createObject only fails if it sees a type it does not know about
    }
    FC_GC_POLL_AND_RETURN_OBJREF(rv);
}
FCIMPLEND


LPVOID __stdcall COMArrayInfo::GetValueEx(_GetValueExArgs* args)
{
    ArrayClass*     pArray;
    TypeHandle      arrayElementType;
    I4ARRAYREF      pIndices = args->indices;

    // Validate the array args
    THROWSCOMPLUSEXCEPTION();
    arrayElementType = ((BASEARRAYREF) args->refThis)->GetElementTypeHandle();
    EEClass* pEEC = args->refThis->GetClass();
    pArray = (ArrayClass*) pEEC;

    DWORD Rank = pArray->GetRank();
    DWORD dwOffset = 0;
    DWORD dwMultiplier  = 1;

    const DWORD *pBoundsPtr = args->refThis->GetBoundsPtr();
    const DWORD *pLowerBoundsPtr = args->refThis->GetLowerBoundsPtr();
    for (int i = Rank-1; i >= 0; i--) {
        DWORD dwIndex = pIndices->m_Array[i] - pLowerBoundsPtr[i];

        // Bounds check each index
        if (dwIndex >= pBoundsPtr[i])
            COMPlusThrow(kIndexOutOfRangeException);

        dwOffset += dwIndex * dwMultiplier;
        dwMultiplier *= pBoundsPtr[i];
    }

    Object* rv = NULL;
    if (!CreateObject(&args->refThis,dwOffset,arrayElementType,pArray, rv))
		COMPlusThrow(kNotSupportedException, L"NotSupported_Type");		// createObject only fails if it sees a type it does not know about

    return rv;
}


void __stdcall COMArrayInfo::SetValue(_SetValueArgs* args)
{
    ArrayClass*     pArray;
    TypeHandle      arrayElementType;

    // Validate the array args
    THROWSCOMPLUSEXCEPTION();
    arrayElementType = ((BASEARRAYREF) args->refThis)->GetElementTypeHandle();
    EEClass* pEEC = args->refThis->GetClass();
    pArray = (ArrayClass*) pEEC;

    DWORD Rank = pArray->GetRank();
    DWORD dwOffset = 0;
    DWORD dwMultiplier  = 1;
    const DWORD *pBoundsPtr = args->refThis->GetBoundsPtr();
    const DWORD *pLowerBoundsPtr = args->refThis->GetLowerBoundsPtr();
    _ASSERTE(Rank <= 3);
    for (int i = Rank-1; i >= 0; i--) {
        DWORD dwIndex;
        if (i == 2)
            dwIndex = args->index3 - pLowerBoundsPtr[i];
        else if (i == 1)
            dwIndex = args->index2 - pLowerBoundsPtr[i];
        else
            dwIndex = args->index1 - pLowerBoundsPtr[i];

        // Bounds check each index
        if (dwIndex >= pBoundsPtr[i])
            COMPlusThrow(kIndexOutOfRangeException);

        dwOffset += dwIndex * dwMultiplier;
        dwMultiplier *= pBoundsPtr[i];
    }

    SetFromObject(&args->refThis,dwOffset,arrayElementType,pArray,&args->obj);
}

void __stdcall COMArrayInfo::SetValueEx(_SetValueExArgs* args)
{
    ArrayClass*     pArray;
    TypeHandle      arrayElementType;
    I4ARRAYREF      pIndices = args->indices;

    // Validate the array args
    THROWSCOMPLUSEXCEPTION();
    arrayElementType = ((BASEARRAYREF) args->refThis)->GetElementTypeHandle();
    EEClass* pEEC = args->refThis->GetClass();
    pArray = (ArrayClass*) pEEC;

    DWORD Rank = pArray->GetRank();
    DWORD dwOffset = 0;
    DWORD dwMultiplier  = 1;
    const DWORD *pBoundsPtr = args->refThis->GetBoundsPtr();
    const DWORD *pLowerBoundsPtr = args->refThis->GetLowerBoundsPtr();

    for (int i = Rank-1; i >= 0; i--) {
        DWORD dwIndex = pIndices->m_Array[i] - pLowerBoundsPtr[i];

        // Bounds check each index
        if (dwIndex >= pBoundsPtr[i])
            COMPlusThrow(kIndexOutOfRangeException);

        dwOffset += dwIndex * dwMultiplier;
        dwMultiplier *= pBoundsPtr[i];
    }

    SetFromObject(&args->refThis,dwOffset,arrayElementType,pArray,&args->obj);
}

// CreateObject
// Given an array and offset, we will either set rv to the object or create a boxed version
//  (This object is returned as a LPVOID so it can be directly returned.)
// Returns true if successful - otherwise, you should throw an exception.
BOOL COMArrayInfo::CreateObject(BASEARRAYREF* arrObj,DWORD dwOffset,TypeHandle elementType,ArrayClass* pArray, Object* &rv)
{
    // Get the type of the element...
    CorElementType type = elementType.GetSigCorElementType();
    switch (type) {
    case ELEMENT_TYPE_VOID:
        rv = 0;
        return true;

    case ELEMENT_TYPE_PTR:
        _ASSERTE(0);
        //COMVariant::NewPtrVariant(retObj,value,th);
        break;

    case ELEMENT_TYPE_CLASS:        // Class
    case ELEMENT_TYPE_SZARRAY:      // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:        // General Array
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_OBJECT:
        {
            _ASSERTE(pArray->GetMethodTable()->GetComponentSize() == sizeof(OBJECTREF));
            BYTE* pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * sizeof(OBJECTREF));
            OBJECTREF o (*(Object **) pData);
            rv = OBJECTREFToObject(o);
            return true;
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
    case ELEMENT_TYPE_BOOLEAN:      // boolean
    case ELEMENT_TYPE_I1:           // sbyte
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_I2:           // short
    case ELEMENT_TYPE_U2:           
    case ELEMENT_TYPE_CHAR:         // char
    case ELEMENT_TYPE_I4:           // int
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_I8:           // long
    case ELEMENT_TYPE_U8:       
    case ELEMENT_TYPE_R4:           // float
    case ELEMENT_TYPE_R8:           // double
        {
            // Watch for GC here.  We allocate the object and then
            //  grab the void* to the data we are going to copy.
            OBJECTREF obj = AllocateObject(elementType.AsMethodTable());
            WORD wComponentSize = pArray->GetMethodTable()->GetComponentSize();
            BYTE* pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * wComponentSize);
            CopyValueClass(obj->UnBox(), pData, elementType.AsMethodTable(), obj->GetAppDomain());
            rv = OBJECTREFToObject(obj);
            return true;
        }
        break;
    case ELEMENT_TYPE_END:
    default:
        _ASSERTE(!"Unknown Type");
        return false;
    }
    // This is never hit because we exit from the switch statement.
    return false;
}


// SetFromObject
// Given an array and offset, we will set the object or value.  Returns whether it
// succeeded or failed (due to an unknown primitive type, etc).
void COMArrayInfo::SetFromObject(BASEARRAYREF* arrObj,DWORD dwOffset,TypeHandle elementType,
            ArrayClass* pArray,OBJECTREF* pObj)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv = 0;

    // Get the type of the element...
    CorElementType elemtype = elementType.GetSigCorElementType();
    CorElementType srcType = ELEMENT_TYPE_END;
    if ((*pObj) != 0)
        srcType = (*pObj)->GetMethodTable()->GetNormCorElementType();

    switch (elemtype) {
    case ELEMENT_TYPE_VOID:
        break;

    case ELEMENT_TYPE_PTR:
        _ASSERTE(0);
        //COMVariant::NewPtrVariant(retObj,value,th);
        break;

    case ELEMENT_TYPE_CLASS:        // Class
    case ELEMENT_TYPE_SZARRAY:      // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:        // General Array
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_OBJECT:
        {
            BYTE *pData;

            // This is the univeral zero so we set that and go
            if (*pObj == 0) {
                _ASSERTE(pArray->GetMethodTable()->GetComponentSize() == sizeof(OBJECTREF));
                pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * sizeof(OBJECTREF));
                ClearObjectReference(((OBJECTREF*)pData));
                return;
            }
            TypeHandle srcTh = (*pObj)->GetTypeHandle();

            if (srcTh.GetMethodTable()->IsThunking()) {
                srcTh = TypeHandle(srcTh.GetMethodTable()->AdjustForThunking(*pObj));
            }

            //  cast to the target.
            if (!srcTh.CanCastTo(elementType)) {
                BOOL fCastOK = FALSE;
                if ((*pObj)->GetMethodTable()->IsThunking()) {
                    fCastOK = CRemotingServices::CheckCast(*pObj, elementType.AsClass());
                }
                if (!fCastOK) {
                    COMPlusThrow(kInvalidCastException,L"InvalidCast_StoreArrayElement");
                }
            }

            // CRemotingServices::CheckCast above may have allowed a GC.  So delay
            // calculation until here.
            _ASSERTE(pArray->GetMethodTable()->GetComponentSize() == sizeof(OBJECTREF));
            pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * sizeof(OBJECTREF));
            SetObjectReference(((OBJECTREF*)pData),*pObj,(*arrObj)->GetAppDomain());
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
        {
            WORD wComponentSize = pArray->GetMethodTable()->GetComponentSize();
            BYTE* pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * wComponentSize);

            // Null is the universal zero...
            if (*pObj == 0) {
                InitValueClass(pData,elementType.AsMethodTable());
                return;
            }
            TypeHandle srcTh = (*pObj)->GetTypeHandle();

            //  cast to the target.
            if (!srcTh.CanCastTo(elementType))
                COMPlusThrow(kInvalidCastException, L"InvalidCast_StoreArrayElement");
            CopyValueClass(pData,(*pObj)->UnBox(),elementType.AsMethodTable(),
                           (*arrObj)->GetAppDomain());
            break;
        }
        break;

    case ELEMENT_TYPE_BOOLEAN:      // boolean
    case ELEMENT_TYPE_I1:           // byte
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_I2:           // short
    case ELEMENT_TYPE_U2:           
    case ELEMENT_TYPE_CHAR:         // char
    case ELEMENT_TYPE_I4:           // int
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
    case ELEMENT_TYPE_I8:           // long
    case ELEMENT_TYPE_U8:       
    case ELEMENT_TYPE_R4:           // float
    case ELEMENT_TYPE_R8:           // double
        {
            // Get a properly widened type
            INT64 value = 0;
            if (*pObj != 0) {
                if (!InvokeUtil::IsPrimitiveType(srcType))
                    COMPlusThrow(kInvalidCastException, L"InvalidCast_StoreArrayElement");

                COMMember::g_pInvokeUtil->CreatePrimitiveValue(elemtype,srcType,*pObj,&value);
            }

            WORD wComponentSize = pArray->GetMethodTable()->GetComponentSize();
            BYTE* pData  = ((BYTE*) (*arrObj)->GetDataPtr()) + (dwOffset * wComponentSize);
            memcpyNoGCRefs(pData,&value,wComponentSize);
            break;
        }
        break;
    case ELEMENT_TYPE_END:
    default:
			// As the assert says, this should never happen unless we get a wierd type
        _ASSERTE(!"Unknown Type");
		COMPlusThrow(kNotSupportedException, L"NotSupported_Type");
    }
}

// This method will initialize an array from a TypeHandle to a field.

FCIMPL2(void, COMArrayInfo::InitializeArray, ArrayBase* pArrayRef, HANDLE handle)

    BASEARRAYREF arr = BASEARRAYREF(pArrayRef);
    if (arr == 0)
        FCThrowVoid(kArgumentNullException);
        
    FieldDesc* pField = (FieldDesc*) handle;
    if (pField == NULL)
        FCThrowVoid(kArgumentNullException);
    if (!pField->IsRVA())
        FCThrowVoid(kArgumentException);

	// Note that we do not check that hte field is actually in the PE file that is initializing 
	// the array. Basically the data being published is can be accessed by anyone with the proper
	// permissions (C# marks these as assembly visibility, and thus are protected from outside 
	// snooping)


    CorElementType type = arr->GetElementType();
    if (!CorTypeInfo::IsPrimitiveType(type))
        FCThrowVoid(kArgumentException);

    DWORD dwCompSize = arr->GetComponentSize();
    DWORD dwElemCnt = arr->GetNumComponents();
    DWORD dwTotalSize = dwCompSize * dwElemCnt;

    DWORD size;

    // @perf: We may not want to bother loading the field's class since it's typically
    // a specially generated singleton class.  If so, we should still check the
    // range vs. the image size.

    HELPER_METHOD_FRAME_BEGIN_1(arr);
    size = pField->GetSize();
    HELPER_METHOD_FRAME_END();

    // make certain you don't go off the end of the rva static
    if (dwTotalSize > size)
        FCThrowVoid(kArgumentException);

    void *ret = pField->GetStaticAddressHandle(NULL);

    memcpyNoGCRefs(arr->GetDataPtr(), ret, dwTotalSize);
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "common.h"
#include <CrtWrap.h>
#include "ComCache.h"
#include "spinlock.h"
#include "tls.h"
#include "frames.h"
#include "threads.h"
#include "log.h"
#include "mscoree.h"
#include "COMPlusWrapper.h"
#include "EEConfig.h"
#include "perfcounters.h"
#include "mtx.h"
#include "oletls.h"
#include "contxt.h"
#include "ctxtcall.h"
#include "notifyexternals.h"
#include "ApartmentCallbackHelper.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif // CUSTOMER_CHECKED_BUILD

//================================================================
// Guid definitions.
const IID IID_IObjContext = {0x000001C6,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const GUID IID_IEnterActivityWithNoLock = { 0xd7174f82, 0x36b8, 0x4aa8, { 0x80, 0x0a, 0xe9, 0x63, 0xab, 0x2d, 0xfa, 0xb9 } };

//================================================================
// Static members.
CtxEntryCache *CtxEntryCache::s_pCtxEntryCache = NULL;

// sanity check., to find stress bug #82137
VOID CheckValidIUnkEntry(IUnkEntry* pUnkEntry)
{
   THROWSCOMPLUSEXCEPTION();
   if ( pUnkEntry->m_pUnknown == (IUnknown*)0xBADF00D
      || pUnkEntry->m_pCtxCookie != pUnkEntry->m_pCtxEntry->GetCtxCookie())
   {
        COMPlusThrow(kInvalidComObjectException, IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER);
   }
}

// Version that returns an HR instead of throwing.
HRESULT HRCheckValidIUnkEntry(IUnkEntry* pUnkEntry)
{
   if ( pUnkEntry->m_pUnknown == (IUnknown*)0xBADF00D
      || pUnkEntry->m_pCtxCookie != pUnkEntry->m_pCtxEntry->GetCtxCookie())
   {
        return COR_E_INVALIDCOMOBJECT;
   }

   return S_OK;
}
//================================================================
// Initialize the entry.
void IUnkEntry::Init(IUnknown *pUnk, BOOL bEagerlyMarshalToStream)
{
    // Find our context cookie
    LPVOID pCtxCookie = GetCurrentCtxCookie();

    // Find our STA (if any)
    Thread *pSTAThread = GetThread();
    if (pSTAThread->GetApartment() != Thread::AS_InSTA)
        pSTAThread = NULL;
    else if (RunningOnWinNT5())
    {
        // We are in an STA thread.  But we may be in a NA context, so do an extra
        // check for that case.

        APTTYPE type;
        if (SUCCEEDED(GetCurrentApartmentTypeNT5(&type))
            && type == APTTYPE_NA)
            pSTAThread = NULL;
    }

    // Set up IUnkEntry's state.
    m_pUnknown = pUnk;
    m_pCtxCookie = pCtxCookie;
    m_Busy = FALSE;
    m_pStream = NULL;
    m_pCtxEntry = CtxEntryCache::GetCtxEntryCache()->FindCtxEntry(pCtxCookie, pSTAThread);
    m_dwBits = 0;
    m_fLazyMarshallingAllowed = !bEagerlyMarshalToStream;

    CheckValidIUnkEntry(this);  
    // Eagerly marshal the IUnknown pointer to the stream if specified.
    if (bEagerlyMarshalToStream)
        MarshalIUnknownToStreamCallback(this);
   
}

//================================================================
// Special init function called from the CtxEntry. This version of
// init takes the context entry and does not add ref it.
void IUnkEntry::InitSpecial(IUnknown *pUnk, BOOL bEagerlyMarshalToStream, CtxEntry *pCtxEntry)
{
    // The context entry passed in must represent the current context.
    _ASSERTE(pCtxEntry->GetCtxCookie() == GetCurrentCtxCookie());

    // Set up IUnkEntry's state.
    m_pUnknown = pUnk;
    m_pCtxCookie = pCtxEntry->GetCtxCookie();
    m_Busy = FALSE;
    m_pStream = NULL;
    m_pCtxEntry = pCtxEntry;
    m_dwBits = 0;
    m_fLazyMarshallingAllowed = !bEagerlyMarshalToStream;
    m_fApartmentCallback = TRUE;

    CheckValidIUnkEntry(this);        
    // Eagerly marshal the IUnknown pointer to the stream if specified.
    if (bEagerlyMarshalToStream)
        MarshalIUnknownToStream(FALSE);

    
}

//================================================================
// Free the IUnknown entry.
VOID IUnkEntry::Free(BOOL bReleaseCtxEntry)
{
    // The following code is unsafe if the process is going away (calls into
    // DLLs we don't know are even mapped).
    if (g_fProcessDetach)
    {
        // The code for the component that implements the IStream interface
        // that is used inside the IUnkEntry lives inside the EE so we should
        // always be able to free it.
        IStream *pOldStream = m_pStream;
        if (InterlockedExchangePointer((PVOID*)&m_pStream, NULL) == (PVOID)pOldStream)
        {
            if (pOldStream != NULL)
                pOldStream->Release();
        }

        // Release the ref count we have on the CtxEntry if specified.
        if (bReleaseCtxEntry)
            m_pCtxEntry->Release();
        
        LogInteropLeak(this);
        return;
    }
    
    // Make sure we are in preemptive GC mode before we call out to COM.
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        // Log the de-allocation of the IUnknown entry.
        LOG((LF_INTEROP, LL_INFO10000, "IUnkEntry::Free called for context 0x%08X, to release entry with m_pUnknown %p, on thread %p\n", m_pCtxCookie, m_pUnknown, GetThread())); 
    
        IStream* pStream = m_pStream;
        m_pStream = NULL;
        ULONG cbRef;  

        // This should release the stream, object in the stream and the memory on which the stream was created
        if (pStream)
            SafeReleaseStream(pStream);

        // now release the IUnknown that we hold
        cbRef = SafeRelease(m_pUnknown);
        LogInteropRelease(m_pUnknown, cbRef, "Identity Unknown");

        // mark the entry as dead
        m_pUnknown = (IUnknown*)0xBADF00D;
     
        // Release the ref count we have on the CtxEntry if specified.
        if (bReleaseCtxEntry)
            m_pCtxEntry->Release();
    }
    END_ENSURE_PREEMPTIVE_GC();
}

//================================================================
// Get IUnknown for the current context from IUnkEntry
IUnknown* IUnkEntry::GetIUnknownForCurrContext()
{
    IUnknown* pUnk = NULL;
    LPVOID pCtxCookie = GetCurrentCtxCookie();

   CheckValidIUnkEntry(this);
   
    if (m_pCtxCookie == pCtxCookie)
    {
        pUnk = m_pUnknown;
        ULONG cbRef = SafeAddRef(pUnk);
        LogInteropAddRef(pUnk, cbRef, " GetIUnknownFromEntry");
    }

    if (!pUnk)
    {
        pUnk = UnmarshalIUnknownForCurrContext();
    }

    return pUnk;
}

//================================================================
// Unmarshal IUnknown for the current context from IUnkEntry
IUnknown* IUnkEntry::UnmarshalIUnknownForCurrContext()
{
#ifdef CUSTOMER_CHECKED_BUILD
    HRESULT hrCDH;
#endif // CUSTOMER_CHECKED_BUILD

    HRESULT hr = S_OK;
    IUnknown *pUnk = m_pUnknown;
    BOOL fRetry = TRUE;
    BOOL fUnmarshalFailed = FALSE;

    CheckValidIUnkEntry(this);
    // Make sure we are in preemptive GC mode before we call out to COM.
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        CheckValidIUnkEntry(this);

        // Need to synchronize
        while (fRetry)
        {
            // Marshal the interface to the stream if it hasn't been done yet.
            if ((m_pStream == NULL) && (m_fLazyMarshallingAllowed))
            {
#ifndef CUSTOMER_CHECKED_BUILD
                MarshalIUnknownToStreamCallback(this);
#else
                hrCDH = MarshalIUnknownToStreamCallback(this);

                if (hrCDH == RPC_E_DISCONNECTED)        // All failed HRESULTs are mapped to RPC_E_DISCONNECTED in EnterContext().
                {
                    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_DisconnectedContext))
                    {
                        pCdh->LogInfo(L"Failed to enter object context. No proxy will be used.",
                                      CustomerCheckedBuildProbe_DisconnectedContext);
                    }
                }
                else if (m_pStream == NULL)
                {
                    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_NotMarshalable))
                    {
                        pCdh->LogInfo(L"Component is not marshalable.  No proxy will be used.", CustomerCheckedBuildProbe_NotMarshalable);
                    }
                }
#endif // CUSTOMER_CHECKED_BUILD
            }

            if (TryUpdateEntry())                
            {
                // Reset the EnterAppropriateWait event.
                m_pCtxEntry->ResetEvent();

                // If the interface is not marshalable or if we failed to 
                // enter the context, then we don't have any choice but to 
                // use the raw IP.
                if (m_pStream == NULL)
                {
                    // We retrieved an IP so stop retrying.
                    fRetry = FALSE;
                        
                    // Give out this IUnknown we are holding
                    IUnknown* pUnk = m_pUnknown;
                    ULONG cbRef = SafeAddRef(pUnk);
                    LogInteropAddRef(pUnk, cbRef, "UnmarshalIUnknownForCurrContext handing out raw IUnknown");
                }
                else
                {
                    // we got control for this entry
                    // GetInterface for the current context 
                    HRESULT hr;
                    hr = CoUnmarshalInterface(m_pStream, IID_IUnknown, (void **)&pUnk);
            
                    // If the objref in the stream times out, we need to go an marshal into the 
                    // stream once again.
                    if (FAILED(hr))
                    {
                        _ASSERTE(m_pStream);

                        // If we're not allowing lazy marshalling, return NULL immediately
                        if (!m_fLazyMarshallingAllowed)
                        {
                            pUnk = NULL;
                            fRetry = FALSE;
                        }
                        
                        else
                        {
                            // This should release the stream, object in the stream and the memory on which the stream was created
                            SafeReleaseStream(m_pStream);                        
                            m_pStream = NULL;

                            // If unmarshal failed twice, then bail out.
                            if (fUnmarshalFailed)
                                fRetry = FALSE;

                            // Remember we failed to unmarshal.
                            fUnmarshalFailed = TRUE;
                        }
                    }
                    else
                    {   
                        // We managed to unmarshal the IP from the stream, stop retrying.
                        fRetry = FALSE;

                        // Reset the stream to the begining
                        LARGE_INTEGER li;
                        LISet32(li, 0);
                        ULARGE_INTEGER li2;
                        m_pStream->Seek(li, STREAM_SEEK_SET, &li2);

                        DWORD mshlFlgs = !m_fApartmentCallback
                                         ? MSHLFLAGS_NORMAL
                                         : MSHLFLAGS_TABLESTRONG;
                
                        // Marshal the interface into the stream TABLE with appropriate flags
                        hr = CoMarshalInterface(m_pStream, 
                            IID_IUnknown, pUnk, MSHCTX_INPROC, NULL, mshlFlgs);
                
                        // Reset the stream to the begining
                        LISet32(li, 0);
                        m_pStream->Seek(li, STREAM_SEEK_SET, &li2);
                    }
                }
            
                // Done with the entry.
                EndUpdateEntry();

                // Signal other waiters.
                m_pCtxEntry->SignalWaiters();
            }
            else
            {
                m_pCtxEntry->EnterAppropriateWait();
            }
        } 
    }
    END_ENSURE_PREEMPTIVE_GC();

    return pUnk;
}

// Release the stream. This will force UnmarshalIUnknownForCurrContext to transition
// into the context that owns the IP and re-marshal it to the stream.
void IUnkEntry::ReleaseStream()
{
    // This should release the stream, object in the stream and the memory on which the stream was created
    SafeReleaseStream(m_pStream);                        
    m_pStream = NULL;
}


//================================================================
// Callback called to marshal the IUnknown into a stream lazily.
HRESULT IUnkEntry::MarshalIUnknownToStreamCallback(LPVOID pData)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    IUnkEntry *pUnkEntry = (IUnkEntry*)pData;

    // This should never be called during process detach.
    _ASSERTE(!g_fProcessDetach);
    hr = HRCheckValidIUnkEntry(pUnkEntry);        
    if (hr != S_OK)
        return hr;
    
    LPVOID pCurrentCtxCookie = GetCurrentCtxCookie();
    if (pCurrentCtxCookie == pUnkEntry->m_pCtxCookie)
    {
        // We are in the right context marshal the IUnknown to the 
        // stream directly.
        hr = pUnkEntry->MarshalIUnknownToStream();
    }
    else
    {
        // Transition into the context to marshal the IUnknown to 
        // the stream.
        hr = pUnkEntry->m_pCtxEntry->EnterContext(MarshalIUnknownToStreamCallback, pUnkEntry);
    }

    return hr;
}

//================================================================
// Helper function to marshal the IUnknown pointer to the stream.
HRESULT IUnkEntry::MarshalIUnknownToStream(bool fIsNormal)
{
    IStream *pStream = NULL;

    // This must always be called in the right context.
    _ASSERTE(m_pCtxCookie == GetCurrentCtxCookie());

    // ensure we register this cookie
    HRESULT hr = wCoMarshalInterThreadInterfaceInStream(IID_IUnknown, 
                                m_pUnknown, &pStream, fIsNormal);
    if ((hr == REGDB_E_IIDNOTREG) ||
        (hr == E_FAIL) ||
        (hr == E_NOINTERFACE) ||
        (hr == E_INVALIDARG) ||
        (hr == E_UNEXPECTED))
    {
        // Interface is not marshallable.
        pStream = NULL;
        hr      = S_OK;
    }

    // Try to set the stream in the IUnkEntry. If another thread already set it,
    // then we need to release the stream we just set up.
    if (FastInterlockCompareExchange((void**)&m_pStream, (void*)pStream, (void*)0) != (void*)0)
        SafeReleaseStream(pStream);

    return hr;
}

//================================================================
// Constructor for the context entry.
CtxEntry::CtxEntry(LPVOID pCtxCookie, Thread *pSTAThread)
: m_pCtxCookie(pCtxCookie)
, m_pObjCtx(NULL)
, m_dwRefCount(0)
, m_hEvent(NULL)
, m_pDoCallbackHelperUnkEntry(NULL)
, m_pSTAThread(pSTAThread)
{
}

//================================================================
// Destructor for the context entry.
CtxEntry::~CtxEntry()
{
    // Validate the ref count is 0.
    _ASSERTE(m_dwRefCount == 0);
    
    // Delete the event if we managed to create it.
    if(m_hEvent)
        CloseHandle(m_hEvent);

    if (RunningOnWinNT5())
    {
        // If the context is a valid context then release it.
        if (m_pObjCtx && !g_fProcessDetach)
        {
            m_pObjCtx->Release();
            m_pObjCtx = NULL;
        }
    }
    else
    {
        // Clean up the data required to enter apartments on legacy platforms.
        if (m_pDoCallbackHelperUnkEntry)
        {
            m_pDoCallbackHelperUnkEntry->Free(FALSE);
            delete m_pDoCallbackHelperUnkEntry;
            m_pDoCallbackHelperUnkEntry = NULL;
        }
    }

    // Set the context cookie to 0xBADF00D to indicate the current context
    // has been deleted.
    
    m_pCtxCookie = (LPVOID)0xBADF00D;
}

//================================================================
// Initialization method for the context entry.
BOOL CtxEntry::Init()
{
    BOOL bSuccess = FALSE;
    IUnknown *pApartmentCallbackUnk = NULL;

    // COM had better be started up at this point.
    _ASSERTE(g_fComStarted && "COM has not been started up, ensure QuickCOMStartup is called before any COM objects are used!");

    COMPLUS_TRY
    {
        // Create the event used for pumping.
        m_hEvent = WszCreateEvent(NULL,  // security attributes
                                  FALSE, // manual event
                                  TRUE,  // initial state is not signalled
                                  NULL); // no name

        // If we could not allocate the event, then the init failed.
        if (!m_hEvent)
            COMPlusThrowOM();

        if (RunningOnWinNT5())
        {
            // If we are running on NT5, then retrieve the IObjectContext.
            HRESULT hr = GetCurrentObjCtx(&m_pObjCtx);
            _ASSERTE(SUCCEEDED(hr));

            // In case the call to GetCurrentObjCtx fails (which should never really happen)
            // we will throw an exception.
            if (FAILED(hr))
                COMPlusThrowHR(hr);
        }
        else
        {
            // Create an instance of the apartment callback helper.
            ApartmentCallbackHelper::CreateInstance(&pApartmentCallbackUnk);

            // Allocate and initialize the IUnkEntry that will be used to manage
            // the stream that will contain the apartment callback helper. We need
            // to eagerly marshal the IUnknown to the stream because we will not
            // be able to do it later.
            m_pDoCallbackHelperUnkEntry = AllocateIUnkEntry();
            m_pDoCallbackHelperUnkEntry->InitSpecial(pApartmentCallbackUnk, TRUE, this);
        }

        // Initialization succeeded.
        bSuccess = TRUE;
    }
    COMPLUS_CATCH 
    {
        // An exception occured, we need to clean up.
        m_pCtxCookie = NULL;
        if (pApartmentCallbackUnk)
        {
            pApartmentCallbackUnk->Release();
        }
        if (m_pDoCallbackHelperUnkEntry)
        {
            m_pDoCallbackHelperUnkEntry->Free(FALSE);
            delete m_pDoCallbackHelperUnkEntry;
            m_pDoCallbackHelperUnkEntry = NULL;
        }

        // Initialization failed.
        bSuccess = FALSE;
    }
    COMPLUS_END_CATCH

    return bSuccess;
}

//================================================================
// Helper routine called by Init().
IUnkEntry *CtxEntry::AllocateIUnkEntry()
{
    return new (throws) IUnkEntry();
}

//================================================================
// Method to decrement the ref count of the context entry.
DWORD CtxEntry::Release()
{
    LPVOID pCtxCookie = m_pCtxCookie;

    _ASSERTE(m_dwRefCount > 0);
    LONG cbRef = FastInterlockDecrement((LONG*)&m_dwRefCount);
    LOG((LF_INTEROP, LL_INFO100, "CtxEntry::Release %8.8x with %d\n", this, cbRef));

    // If the ref count falls to 0, try and delete the ctx entry.
    // This might not end up deleting it if another thread tries to
    // retrieve this ctx entry at the same time this one tries
    // to delete it.
    if (cbRef == 0)
        CtxEntryCache::GetCtxEntryCache()->TryDeleteCtxEntry(pCtxCookie);

    // WARNING: The this pointer cannot be used at this point.
    return cbRef;
}

//================================================================
// Method to wait and pump messages.
void CtxEntry::EnterAppropriateWait()
{
    _ASSERTE(!GetThread() || !GetThread()->PreemptiveGCDisabled());

    // wait and pump messages
    GetThread()->DoAppropriateWait(1, &m_hEvent, FALSE, 10, TRUE, NULL);
}

//================================================================
// Struct passed in to DoCallback.
struct CtxEntryEnterContextCallbackData
{
    PFNCTXCALLBACK m_pUserCallbackFunc;
    LPVOID         m_pUserData;
    LPVOID         m_pCtxCookie;
    HRESULT        m_UserCallbackHR;
};

#define RPC_E_WORD_DISCONNECT_BUG (HRESULT)0x800706ba

//================================================================
// Method to transition into the context and call the callback
// from within the context.
HRESULT CtxEntry::EnterContext(PFNCTXCALLBACK pCallbackFunc, LPVOID pData)
{
    HRESULT hr = S_OK;
    DWORD cbRef;

    // This should not be called if the this context is the current context.
    _ASSERTE(m_pCtxCookie != GetCurrentCtxCookie());

    // If we are in process detach, we cannot safely try to enter another context
    // since we don't know if OLE32 is still loaded.
    if (g_fProcessDetach)
    {
        LOG((LF_INTEROP, LL_INFO100, "Entering into context 0x08X has failed since we are in process detach\n", m_pCtxCookie)); 
        return RPC_E_DISCONNECTED;
    }

    // Disallow throwing exceptions from this method.
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // Make sure we are in preemptive GC mode before we call out to COM.
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        // Prepare the information struct passed into the callback.
        CtxEntryEnterContextCallbackData CallbackInfo;
        CallbackInfo.m_pUserCallbackFunc = pCallbackFunc;
        CallbackInfo.m_pUserData = pData;
        CallbackInfo.m_pCtxCookie = m_pCtxCookie;
        CallbackInfo.m_UserCallbackHR = E_FAIL;

        if (RunningOnWinNT5())
        {
            // Make sure we aren't trying to enter the current context.
            _ASSERTE(m_pCtxCookie != GetCurrentCtxCookie());
    
            // Retrieve the IContextCallback interface from the IObjectContext.
            IContextCallback* pCallback = NULL;
            hr = m_pObjCtx->QueryInterface(IID_IContextCallback, (void**)&pCallback);
            LogInteropQI(m_pObjCtx, IID_IContextCallback, hr, "QI for IID_IContextCallback");
            _ASSERTE(SUCCEEDED(hr) && pCallback);
    
            // Setup the callback data structure with the callback Args
            ComCallData callBackData;  
            callBackData.dwDispid = 0;
            callBackData.dwReserved = 0;
            callBackData.pUserDefined = &CallbackInfo;

            // @TODO !!! REMOVE THIS AFTER ole32 IS FIXED !!!
            // vladser: This beautiful peace of code below is a nasty workaround for
            // the bug in ole32.dll, that basically allowes to make a callback on a
            // context from a cleaned up apartement that causes an AV in
            // ole32!CComApartment__GetRemUnk.
            __try {
                // Transition into the context  
                hr = pCallback->ContextCallback(EnterContextCallback, &callBackData, IID_IEnterActivityWithNoLock, 2, NULL);
            } __except ( (GetExceptionCode() == STATUS_ACCESS_VIOLATION) ? 
                         EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
            { 
                // swallow the AV that comes from cleaned up apartement
                hr = RPC_E_SERVER_DIED_DNE;
            }

             // Release the IContextCallback.
            cbRef = pCallback->Release();
            LogInteropRelease(pCallback, cbRef, "IContextCallback interface");
        }
        else
        {
            IApartmentCallback *pCallback = NULL;
            IUnknown *pUnk = NULL;

            // Unmarshal the apartment callback helper to the current context.
            COMPLUS_TRY
            {
                pUnk = m_pDoCallbackHelperUnkEntry->GetIUnknownForCurrContext();
            }
            COMPLUS_CATCH
            {
                // In case of exception, ee just fall through and we will return RPC_E_DISCONNECTED.
            }
            COMPLUS_END_CATCH

            if (pUnk != NULL)
            {
                // QI for the IApartmentCallback interface.
                hr = pUnk->QueryInterface(IID_IApartmentCallback, (void**)&pCallback);
                LogInteropQI(pUnk, IID_IApartmentCallback, hr, "QI for IID_IApartmentCallback");

                // An hr of E_NOINTERFACE is most likely because mscoree.tlb is not registered.
                _ASSERTE(hr != E_NOINTERFACE && "Did you forget to register mscoree.tlb?");

                // If we succeeded in retrieving the IApartmentCallback interface, then call
                // back on it.
                if (SUCCEEDED(hr))
                {
                    // Setup the callback data structure with the callback Args
                    ComCallData callBackData;  
                    callBackData.dwDispid = 0;
                    callBackData.dwReserved = 0;
                    callBackData.pUserDefined = &CallbackInfo;

                    // Transition into the context  
                    hr = pCallback->DoCallback((SIZE_T)EnterContextCallback, (SIZE_T)&callBackData);

                     // Release the IContextCallback.
                    cbRef = pCallback->Release();
                    LogInteropRelease(pCallback, cbRef, "IContextCallback interface");
                }

                 // Release the IUnknown for the apartment callback helper.
                cbRef = pUnk->Release();
                LogInteropRelease(pUnk, cbRef, "IUnknown interface");
            }
            else
            {
                // the apartment probably shutdown, so we can't unmarshal the IUnknown
                // for the current apartment
                hr = RPC_E_DISCONNECTED;
            }
        }

        if (FAILED(hr))
        {
            // The context is disconnected so we cannot transition into it.
            LOG((LF_INTEROP, LL_INFO100, "Entering into context 0x08X has failed since the context has disconnected\n", m_pCtxCookie)); 

            // Set the HRESULT to RPC_E_DISCONNECTED so callers of EnterContext only have one
            // HRESULT to check against.
            hr = RPC_E_DISCONNECTED;
        }
        else
        {
            // The user callback function should not fail.
            _ASSERTE(SUCCEEDED(CallbackInfo.m_UserCallbackHR));
        }
    }
    END_ENSURE_PREEMPTIVE_GC();

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

//================================================================
// Callback function called by DoCallback.
HRESULT __stdcall CtxEntry::EnterContextCallback(ComCallData* pComCallData)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    Thread *pThread = GetThread();
    
    // Make sure the thread has been set before we call the user callback function.
    if (!pThread)
    {
        // huh! we are in the middle of shutdown
        // and there is no way we can add a new thread
        // so let us just return RPC_E_DISCONNECTED
        // look at the pCallBack->DoCallback above
        // to see why we are returning this SCODE
        if(g_fEEShutDown)
            return RPC_E_DISCONNECTED;

        // Otherwise, we need to create a managed thread object for this new thread
        else
        {
            pThread = SetupThread();
            _ASSERTE(pThread);
        }
    }
    
    // Retrieve the callback data.
    CtxEntryEnterContextCallbackData *pData = (CtxEntryEnterContextCallbackData*)pComCallData->pUserDefined;

    // at this point we should be in the right context on NT4,
    // if not then it is possible that the actual apartment state for this
    // thread has changed and we have stale info in our thread or the CtxEntry

    if (pData->m_pCtxCookie != GetCurrentCtxCookie())
    {
        return RPC_E_DISCONNECTED;
    }
    
    // Call the user callback function and store the return value the 
    // callback data.
    pData->m_UserCallbackHR = pData->m_pUserCallbackFunc(pData->m_pUserData);

    // Return S_OK to indicate the context transition was successfull.
    return S_OK;
}

CtxEntryCache::CtxEntryCache()
{
    m_ctxEntryList.Init();  
    m_Lock.Init(LOCK_COMCTXENTRYCACHE);
}

CtxEntryCache::~CtxEntryCache()
{
    while (!m_ctxEntryList.IsEmpty())
    {
        // Log the CtxEntries that have leaked and delete them.
        CtxEntry *pCtxEntry = m_ctxEntryList.RemoveHead();
        LOG((LF_INTEROP, LL_INFO100, "Leaked CtxEntry %8.8x with CtxCookie %8.8x, ref count %d\n", pCtxEntry, pCtxEntry->GetCtxCookie(), pCtxEntry->m_dwRefCount));
        pCtxEntry->m_dwRefCount = 0;
        delete pCtxEntry;
    }
}

BOOL CtxEntryCache::Init()
{
    // This should never be called more than once.
    _ASSERTE(!s_pCtxEntryCache);

    // Allocate the one and only instance of the context entry cache.
    s_pCtxEntryCache = new (nothrow) CtxEntryCache();
    if (!s_pCtxEntryCache)
        return FALSE;

    // The initialization was successfull.
    return TRUE;
}

// Static termination routine for the CtxEntryCache.
#ifdef SHOULD_WE_CLEANUP
void CtxEntryCache::Terminate()
{
    // Make sure Terminate() has not already been called.
    _ASSERTE(s_pCtxEntryCache);

    // Delete the context entry cache and set the static member to NULL.
    delete s_pCtxEntryCache;
    s_pCtxEntryCache = NULL;
}
#endif /* SHOULD_WE_CLEANUP */

CtxEntry *CtxEntryCache::FindCtxEntry(LPVOID pCtxCookie, Thread *pSTAThread)
{
    THROWSCOMPLUSEXCEPTION();

    CtxEntry *pCtxEntry = NULL;

    // Switch to preemptive GC mode before we take the lock
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        Lock();

        // Try to find a context entry for the context cookie.
        for (pCtxEntry = m_ctxEntryList.GetHead(); pCtxEntry != NULL; pCtxEntry = m_ctxEntryList.GetNext(pCtxEntry))
        {
            if (pCtxEntry->m_pCtxCookie == pCtxCookie)
                break;
        }

        // If we don't already have a context entry for the context cookie,
        // we need to create one.
        if (!pCtxEntry)
        {
            pCtxEntry = new (nothrow) CtxEntry(pCtxCookie, pSTAThread);
            if (pCtxEntry && pCtxEntry->Init())
            {
                // We successfully allocated and initialized the entry.
                m_ctxEntryList.InsertTail(pCtxEntry);
            }
            else
            {
                // We ran out of memory.
                pCtxEntry = NULL;
            }
        }

        // If we managed to find or allocate the entry, we need to addref it before
        // we leave the lock.
        if (pCtxEntry)
            pCtxEntry->AddRef();

        UnLock();
    }
    END_ENSURE_PREEMPTIVE_GC();

    // If failed to allocate the entry, throw an exception.
    if (!pCtxEntry)
        COMPlusThrowOM();

    _ASSERTE(pCtxCookie == pCtxEntry->GetCtxCookie());
    _ASSERTE(pSTAThread == pCtxEntry->GetSTAThread());

    // Returned the found or allocated entry.
    return pCtxEntry;
}
    
void CtxEntryCache::TryDeleteCtxEntry(LPVOID pCtxCookie)
{
    // Switch to preemptive GC mode before we take the lock
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        Lock();

        CtxEntry *pCtxEntry = NULL;

        // Try to find a context entry for the context cookie.
        for (pCtxEntry = m_ctxEntryList.GetHead(); pCtxEntry != NULL; pCtxEntry = m_ctxEntryList.GetNext(pCtxEntry))
        {
            if (pCtxEntry->m_pCtxCookie == pCtxCookie)
                break;
        }       

        // If the ref count of the context entry is still 0, then we can 
        // remove the ctx entry and delete it.
        if (pCtxEntry && pCtxEntry->m_dwRefCount == 0)
        {
            // First remove the context entry from the list.
            m_ctxEntryList.Remove(pCtxEntry);

            // We need to unlock the context entry cache before we delete the 
            // context entry since this can cause release to be called on
            // an IP which can cause us to re-enter the runtime thus causing a
            // deadlock.
            UnLock();

            // We can now safely delete the context entry.
            delete pCtxEntry;
        }
        else
        {
            UnLock();
        }
    }
    END_ENSURE_PREEMPTIVE_GC();
}

HRESULT GetCurrentObjCtx(IUnknown **ppObjCtx)
{
    _ASSERTE(g_fComStarted);
    _ASSERTE(RunningOnWinNT5());

    // Type pointer to CoGetObjectContext function in ole32
    typedef HRESULT (__stdcall *TCoGetObjectContext)(REFIID riid, void **ppv);

    // Retrieve the address of the CoGetObjectContext function.
    static TCoGetObjectContext g_pCoGetObjectContext = NULL;
    if (g_pCoGetObjectContext == NULL)
    {
        //  We will load the Ole32.DLL and look for CoGetObjectContext fn.
        HINSTANCE   hiole32;         // the handle to ole32.dll

        hiole32 = WszGetModuleHandle(L"OLE32.DLL");
        if (hiole32)
        {
            // we got the handle now let's get the address
            g_pCoGetObjectContext = (TCoGetObjectContext) GetProcAddress(hiole32, "CoGetObjectContext");
            _ASSERTE(g_pCoGetObjectContext != NULL);
        }
        else
        {
            _ASSERTE(!"OLE32.dll not loaded ");
        }
    }

    _ASSERTE(g_pCoGetObjectContext != NULL);                
    return (*g_pCoGetObjectContext)(IID_IUnknown, (void **)ppObjCtx);
}

//=====================================================================
// LPVOID SetupOleContext()
extern BOOL     g_fComStarted;
LPVOID SetupOleContext()
{
    IUnknown* pObjCtx = NULL;
    
    // Make sure we are in preemptive GC mode before we call out to COM.
    BEGIN_ENSURE_PREEMPTIVE_GC()
    {   
        if (RunningOnWinNT5() && g_fComStarted)
        {               
            HRESULT hr = GetCurrentObjCtx(&pObjCtx);
            if (hr == S_OK)
            {
                SOleTlsData* _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
                if (_pData && _pData->pCurrentCtx == NULL)
                    _pData->pCurrentCtx = (CObjectContext*)pObjCtx;   // no release !!!!
                else
                {
                    ULONG cbRef = SafeRelease(pObjCtx);
                }
            }
        }
    }
    END_ENSURE_PREEMPTIVE_GC();

    return pObjCtx;
}

//================================================================
// LPVOID GetCurrentCtxCookie(BOOL fThreadDeath)
LPVOID GetCurrentCtxCookie(BOOL fThreadDeath)
{
    // check if com is started
    if (!g_fComStarted) return NULL;
    
    if (SystemHasNewOle32())
    {        
        LPVOID pctx = (LPVOID)GetFastContextCookie();
        _ASSERTE(pctx);
        return pctx;
    }
    if (!RunningOnWinNT5())
    {
        Thread* pThread = GetThread();

        if (pThread && pThread->GetFinalApartment() == Thread::AS_InMTA)
        {
            // the cookie for all MTA threads is the same
            return (LPVOID)0x1;
        }
        return pThread;
    }
    else
    {    
        // Win2K without our changes
        {
            SOleTlsData* _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
            if(!_pData || !_pData->pCurrentCtx) 
            {
                // call CoGetObjectContext to setup the context            
                if (!g_fEEShutDown && !fThreadDeath)
                {
                    //@todo remove this once ole32 fixes thier bug
                    return SetupOleContext();                       
                }
                else
                    return 0;
            }

            _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
            _ASSERTE(_pData);
            _ASSERTE(_pData->pCurrentCtx);
            return _pData->pCurrentCtx;             
        }
    }
}

//+-------------------------------------------------------------------------
//
//  HRESULT GetCurrentThreadTypeNT5(THDTYPE* pType)
// 
HRESULT GetCurrentThreadTypeNT5(THDTYPE* pType)
{
    _ASSERTE(RunningOnWinNT5());
    _ASSERTE(pType);

    HRESULT hr = E_FAIL;
    IObjectContext *pObjCurrCtx = (IObjectContext *)GetCurrentCtxCookie(FALSE);
    if(pObjCurrCtx)
    {
        IComThreadingInfo* pThreadInfo;
        hr = pObjCurrCtx->QueryInterface(IID_IComThreadingInfo, (void **)&pThreadInfo);
        if(hr == S_OK)
        {
            _ASSERTE(pThreadInfo);
            hr = pThreadInfo->GetCurrentThreadType(pType);
            pThreadInfo->Release();
        }
    }  
    return hr;
}

//+-------------------------------------------------------------------------
//
//  HRESULT GetCurrentApartmentTypeNT5(APTTYPE* pType)
// 
HRESULT GetCurrentApartmentTypeNT5(APTTYPE* pType)
{
    _ASSERTE(RunningOnWinNT5());
    _ASSERTE(pType);

    HRESULT hr = E_FAIL;
    IObjectContext *pObjCurrCtx = (IObjectContext *)GetCurrentCtxCookie(FALSE);
    if(pObjCurrCtx)
    {
        IComThreadingInfo* pThreadInfo;
        hr = pObjCurrCtx->QueryInterface(IID_IComThreadingInfo, (void **)&pThreadInfo);
        if(hr == S_OK)
        {
            _ASSERTE(pThreadInfo);
            hr = pThreadInfo->GetCurrentApartmentType(pType);
            pThreadInfo->Release();
        }
    }  
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function: STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, BYTE** ppBuf))
//  Create a stream in the memory
// 
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, BYTE** ppBuf)
{
    LPSTREAM        pstm = NULL;

#ifdef PLATFORM_CE
    return NULL;
#else // !PLATFORM_CE
#if 0

    HANDLE          h;
    

    h = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, cb);
    if (NULL==h)
    {
            return NULL;
    }

    if (CreateStreamOnHGlobal (h, TRUE, &pstm) != NOERROR)
    {
            return NULL;
    }
#else
    
    BYTE* pMem = new BYTE[cb];
    if (pMem)
    {
        HRESULT hr = CInMemoryStream::CreateStreamOnMemory(pMem, cb, &pstm, TRUE);
        _ASSERTE(hr == S_OK || pstm == NULL);
    }
    if(ppBuf)
        *ppBuf = pMem;
#endif
    return pstm;
#endif // !PLATFORM_CE
}

//=====================================================================
// BOOL IsComProxy(IUnknown *pUnk)
BOOL IsComProxy(IUnknown *pUnk)
{
    _ASSERTE(pUnk != NULL);
    HRESULT hr;
    IUnknown* pOld;

    hr = SafeQueryInterface(pUnk, IID_IStdIdentity, &pOld);
    if (hr != S_OK)
    {
        hr = SafeQueryInterface(pUnk, IID_IStdWrapper, &pOld);
        if (hr != S_OK)
        {
            return FALSE;
        }
    }
    SafeRelease(pOld);
    return TRUE;
}

//=====================================================================
// HRESULT wCoMarshalInterThreadInterfaceInStream
HRESULT wCoMarshalInterThreadInterfaceInStream(
                                                         REFIID riid,
                                                         LPUNKNOWN pUnk,
                                                         LPSTREAM *ppStm, BOOL fIsNormal)
{
#ifdef PLATFORM_CE
    return E_NOTIMPL;
#else // !PLATFORM_CE
    HRESULT hr;
    LPSTREAM pStm = NULL;

    DWORD mshlFlgs = fIsNormal ? MSHLFLAGS_NORMAL : MSHLFLAGS_TABLESTRONG;

    ULONG lSize;
    hr = CoGetMarshalSizeMax(&lSize, IID_IUnknown, pUnk, MSHCTX_INPROC,
        NULL, mshlFlgs);

    if (hr == S_OK)
    {
        // Create a stream
        pStm = CreateMemStm(lSize, NULL);

        if (pStm != NULL)
        {
            // Marshal the interface into the stream TABLE STRONG
            hr = CoMarshalInterface(pStm, riid, pUnk, MSHCTX_INPROC, NULL,
                                mshlFlgs);
        }
        else
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // Reset the stream to the begining
        LARGE_INTEGER li;
        LISet32(li, 0);
        ULARGE_INTEGER li2;
        pStm->Seek(li, STREAM_SEEK_SET, &li2);

        // Set the return value
        *ppStm = pStm;
    }
    else
    {
        // Cleanup if failure
        if (pStm != NULL)
        {
            pStm->Release();
        }

        *ppStm = NULL;
    }

    // Return the result
    return hr;
#endif // !PLATFORM_CE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcall.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ComCall.CPP -
//
// Com to Com+ call support.

#include "common.h"

#include "vars.hpp"
#include "ml.h"
#include "stublink.h"
#include "excep.h"
#include "mlgen.h"
#include "comcall.h"
#include "cgensys.h"
#include "method.hpp"
#include "siginfo.hpp"
#include "comcallwrapper.h"
#include "mlcache.h"
#include "field.h"
#include "COMVariant.h"
#include "Security.h"
#include "COMCodeAccessSecurityEngine.h"

#include "marshaler.h"
#include "mlinfo.h"

#include "DbgInterface.h"

#ifndef NUM_ARGUMENT_REGISTERS
#define DEFINE_ARGUMENT_REGISTER_NOTHING
#include "eecallconv.h"
#endif
#if NUM_ARGUMENT_REGISTERS != 2
#pragma message("@TODO ALPHA - ComCall.cpp")
#pragma message("              If the register-based calling convention changes, so must this file.")
//#error "If the register-based calling convention changes, so must this file."
#endif


// get stub for com to com+ call

static BOOL CreateComCallMLStub(ComCallMethodDesc *pMD, OBJECTREF *ppThrowable);

static INT64 __stdcall ComToComPlusWorker      (Thread *pThread, ComMethodFrame *pFrame);
static INT64 __stdcall ComToComPlusSimpleWorker(Thread *pThread, ComMethodFrame *pFrame);

typedef INT64 (__stdcall* PFN)(void);


SpinLock ComCall::m_lock;

static Stub *g_pGenericComCallStubFields = NULL;
static Stub *g_pGenericComCallStub       = NULL;
static Stub *g_pGenericComCallSimpleStub = NULL;

#ifdef _DEBUG
BOOL ComCall::dbg_StubIsGenericComCallStub(Stub *candidate)
{
    return (candidate == g_pGenericComCallStubFields ||
            candidate == g_pGenericComCallStub ||
            candidate == g_pGenericComCallSimpleStub);
}
#endif

        
//---------------------------------------------------------
// Compile a native (ASM) version of the ML stub.
//
// This method should compile into the provided stublinker (but
// not call the Link method.)
//
// It should return the chosen compilation mode.
//
// If the method fails for some reason, it should return
// INTERPRETED so that the EE can fall back on the already
// created ML code.
//---------------------------------------------------------
MLStubCache::MLStubCompilationMode ComCallMLStubCache::CompileMLStub(const BYTE *pRawMLStub,
                           StubLinker *pstublinker, void *callerContext)
{
    MLStubCompilationMode   ret = INTERPRETED;
#ifdef _X86_

    COMPLUS_TRY 
    {
        CPUSTUBLINKER       *psl = (CPUSTUBLINKER *)pstublinker;
        const ComCallMLStub *pheader = (const ComCallMLStub *) pRawMLStub;

        if (ComCall::CompileSnippet(pheader, psl, callerContext))
        {
            ret = STANDALONE;
            __leave;
        }
    } 
    COMPLUS_CATCH
    {
        _ASSERTE(ret == INTERPRETED);
    } 
    COMPLUS_END_CATCH
#endif
    return ret;

}


// A more specialized version of the base MLStubCache::Canonicalize().  This version
// understands how we compile the ML into two snippets which have dependencies on
// one another.
void ComCallMLStubCache::Canonicalize(ComCallMethodDesc *pCMD)
{
    Stub                   *pEnterCall, *pLeaveCall;
    Stub                   *pEnterML, *pLeaveML;
    MLStubCompilationMode   enterMode = STANDALONE, leaveMode = STANDALONE;

    pEnterML = pCMD->GetEnterMLStub();
    pEnterCall = (pEnterML
                  ? MLStubCache::Canonicalize(pEnterML->GetEntryPoint(),
                                               &enterMode, NULL)
                  : 0);

    // Quite orthogonal to the entry stub, do the leave stub:
    pLeaveML = pCMD->GetLeaveMLStub();
    pLeaveCall = (pLeaveML
                  ? MLStubCache::Canonicalize(pLeaveML->GetEntryPoint(),
                                               &leaveMode, NULL)
                  : 0);

    // We have both of them ready.  Either, both, or neither has been
    // compiled.
    pCMD->InstallExecuteStubs(pEnterCall, pLeaveCall);

    // Based on the modes, we can either call directly to the entrypoint of the
    // stub (with all the registers set as expected for marshaling) or we need
    // to call a generic helper that will perform a call to RunML with the correct
    // arguments.
    pCMD->m_EnterHelper = (pEnterCall == 0
                           ? 0
                           : (enterMode == INTERPRETED
                              ? ComCall::GenericHelperEnter
                              : (COMCALL_HELPER) pEnterCall->GetEntryPoint()));

    _ASSERTE(pCMD->m_EnterHelper == 0 ||
             (enterMode == INTERPRETED || enterMode == STANDALONE));

    pCMD->m_LeaveHelper = (pLeaveCall == 0
                           ? 0
                           : (leaveMode == INTERPRETED
                              ? ComCall::GenericHelperLeave
                              : (COMCALL_HELPER) pLeaveCall->GetEntryPoint()));

    _ASSERTE(pCMD->m_LeaveHelper == 0 ||
             (leaveMode == INTERPRETED || leaveMode == STANDALONE));
}


//---------------------------------------------------------
// One-time init
//---------------------------------------------------------
/*static*/ 
BOOL ComCall::Init()
{
    // If the assert below ever fires, someone's tried to add a field to
    // ComCallGCInfo (defined in comcall.h). Since this structure is overlayed
    // on the last dword of an UnmanagedToManagedCallFrame::NegInfo structure
    // kept on the stack frame, this is not a trivial change, and should be
    // scrutinized carefully.
    _ASSERTE(sizeof(ComCallGCInfo) == sizeof(DWORD));

    m_lock.Init(LOCK_COMCALL);

    return TRUE;
}

//---------------------------------------------------------
// One-time cleanup
//---------------------------------------------------------
/*static*/ 
#ifdef SHOULD_WE_CLEANUP
VOID ComCall::Terminate()
{
    if (g_pGenericComCallStubFields != NULL)
    {
        g_pGenericComCallStubFields->DecRef();
        g_pGenericComCallStubFields = NULL;
    }
    if (g_pGenericComCallStub != NULL)
    {
        g_pGenericComCallStub->DecRef();
        g_pGenericComCallStub = NULL;
    }
    if (g_pGenericComCallSimpleStub != NULL)
    {
        g_pGenericComCallSimpleStub->DecRef();
        g_pGenericComCallSimpleStub = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */


//---------------------------------------------------------
// Creates the generic ComCall stub.
//---------------------------------------------------------
/*static*/ 
Stub* ComCall::CreateGenericComCallStub(StubLinker *pstublinker, BOOL isFieldAccess,
                                        BOOL isSimple)
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *psl = (CPUSTUBLINKER*)pstublinker;
   
#ifdef _X86_
   
    CodeLabel* rgRareLabels[] = { psl->NewCodeLabel(),
                                  psl->NewCodeLabel(),
                                  psl->NewCodeLabel()
                                };


    CodeLabel* rgRejoinLabels[] = { psl->NewCodeLabel(),
                                    psl->NewCodeLabel(),
                                    psl->NewCodeLabel()
                                };

    if (rgRareLabels[0] == NULL ||
        rgRareLabels[1] == NULL ||
        rgRareLabels[2] == NULL ||
        rgRejoinLabels[0] == NULL ||
        rgRejoinLabels[1] == NULL ||
        rgRejoinLabels[2] == NULL  )
    {
        COMPlusThrowOM();
    }

    // emit the initial prolog
    // NOTE: Don't profile field accesses yet.
    psl->EmitComMethodStubProlog(ComMethodFrame::GetMethodFrameVPtr(), rgRareLabels,
                                 rgRejoinLabels, ComToManagedExceptHandler, !isFieldAccess);

    // set up SEH for anything if not a field access

    psl->X86EmitPushReg(kESI);      // push frame as an ARG
    psl->X86EmitPushReg(kEBX);       // push ebx (push current thread as ARG)

    LPVOID pTarget = (isFieldAccess
                      ? (LPVOID)FieldCallWorker
                      : (isSimple
                         ? (LPVOID)ComToComPlusSimpleWorker
                         : (LPVOID)ComToComPlusWorker));

    psl->X86EmitCall(psl->NewExternalCodeLabel(pTarget), 8); // on CE pop 8 bytes or args on return

    // emit the epilog
    // NOTE: Don't profile field accesses yet.
    psl->EmitSharedComMethodStubEpilog(ComMethodFrame::GetMethodFrameVPtr(), rgRareLabels, rgRejoinLabels,
                                       ComCallMethodDesc::GetOffsetOfReturnThunk(), !isFieldAccess);
#else
        _ASSERTE(!"Platform not yet supported");
#endif
    return psl->Link(SystemDomain::System()->GetStubHeap());
}

//---------------------------------------------------------
// Stub* CreateGenericStub(StubLinker *psl, BOOL fFieldAccess)
//---------------------------------------------------------

Stub* CreateGenericStub(StubLinker *psl, BOOL fFieldAccess, BOOL fSimple)
{
    Stub* pCandidate = NULL;
    COMPLUS_TRY
    {
        pCandidate = ComCall::CreateGenericComCallStub(psl, fFieldAccess, fSimple);      
    }
    COMPLUS_CATCH
    {
        pCandidate = NULL;
    }
    COMPLUS_END_CATCH
    return pCandidate;
}



//---------------------------------------------------------
// BOOL SetupGenericStubs()
//---------------------------------------------------------

static BOOL SetupGenericStubs()
{
    if (g_pGenericComCallStubFields != NULL &&
        g_pGenericComCallStub       != NULL && 
        g_pGenericComCallSimpleStub != NULL)
    {
        return TRUE;
    }

    StubLinker slCall, slFields, slSimple;
    Stub      *candidate;

    // Build each one.  If we get a collision on replacement, favor the one that's
    // already there.  (We have lifetime issues with these, because they are used
    // in every VTable without refcounting, so we don't want them to change
    // underneath us).

    candidate = CreateGenericStub(&slCall, FALSE/*notField*/, FALSE/*notSimple*/);
    if (candidate != NULL)
    {
        if (FastInterlockCompareExchange((void **) &g_pGenericComCallStub,
                                         candidate, 0) != 0)
        {
            candidate->DecRef();
        }

        candidate = CreateGenericStub(&slFields, TRUE/*Field*/, FALSE/*notSimple*/);
        if (candidate != NULL)
        {
            if (FastInterlockCompareExchange((void **) &g_pGenericComCallStubFields,
                                             candidate, 0) != 0)
            {
                candidate->DecRef();
            }

            candidate = CreateGenericStub(&slSimple, FALSE/*notField*/, TRUE/*Simple*/);
            if (candidate != NULL)
            {
                if (FastInterlockCompareExchange((void **) &g_pGenericComCallSimpleStub,
                                                 candidate, 0) != 0)
                {
                    candidate->DecRef();
                }
                // success
                return TRUE;
            }
        }
    }

    // failure
    return FALSE;
}

//---------------------------------------------------------
// INT64 __stdcall ComToComPlusWorker(Thread *pThread, 
//                                  ComMethodFrame* pFrame)
//---------------------------------------------------------
// calls that propagate from COM to COMPLUS
// disable frame pointer omissions,as we are doing an _alloca
// and the our call to the function destroys ESP pointer
// probably need to come up with a better solution post m3.

// We make room on the stack for two registers, which is all our register-based
// calling convention currently supports.

struct ComToComPlusWorker_Args {
    ComMethodFrame *pFrame;
    INT64 (__stdcall *targetFcn)(Thread *, ComMethodFrame *);
    INT64 returnValue;
};
    
static void ComToComPlusWorker_Wrapper(ComToComPlusWorker_Args *args)
{
    IUnknown **pip = (IUnknown **)args->pFrame->GetPointerToArguments();
    IUnknown *pUnk = (IUnknown *)*pip; 

    // Obtain the managed 'this' for the call
    ComCallWrapper  *pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);

    Thread *pThread = GetThread();

    EE_TRY_FOR_FINALLY
    {
        args->returnValue = args->targetFcn(pThread, args->pFrame);
    }
    EE_FINALLY
    {
        // in non-exception case, this will have already been cleaned up
        // at the end of the ComToComPlusWorker function. This will handle
        // cleanup for the exception case so that we get cleaned up before
        // we leave the domain.
        args->pFrame->ComMethodFrame::NonVirtual_GetCleanupWorkList()->Cleanup(GOT_EXCEPTION());
    }
    EE_END_FINALLY;
}

static
INT64 __stdcall ComToComPlusWorker(Thread *pThread, ComMethodFrame* pFrame)
{
#ifndef _X86_
    _ASSERTE(!"NYI");
    return 0;
#else
    _ASSERTE(pFrame != NULL);
    _ASSERTE(pThread);

    // bypass virtualization of frame throughout this method to shave some cycles,
    // so assert that it is indeed what we expect:
    _ASSERTE(pFrame->GetVTablePtr() == ComMethodFrame::GetMethodFrameVPtr());

    IUnknown **pip = (IUnknown **)pFrame->GetPointerToArguments();

    IUnknown *pUnk = (IUnknown *)*pip; 
    _ASSERTE(pUnk != NULL);

    // Obtain the managed 'this' for the call
    ComCallWrapper  *pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);
    _ASSERTE(pWrap != NULL);

    if (pWrap->NeedToSwitchDomains(pThread, FALSE))
    {
	    AppDomain *pTgtDomain = pWrap->GetDomainSynchronized();
	    if (!pTgtDomain)
	        return COR_E_APPDOMAINUNLOADED;
   
        ComToComPlusWorker_Args args = {pFrame, ComToComPlusWorker};
        pThread->DoADCallBack(pTgtDomain->GetDefaultContext(), ComToComPlusWorker_Wrapper, &args);
        return args.returnValue;
    }

    //INT64				tempReturnValue; // used in case the function has an out-retval
    INT64               returnValue;
    PFN                 pfnToCall;
    ComCallGCInfo      *pGCInfo;
    CleanupWorkList    *pCleanup;
    ComCallMethodDesc  *pCMD;
    unsigned            methSlot;

    pGCInfo = (ComCallGCInfo*) pFrame->ComMethodFrame::NonVirtual_GetGCInfoFlagPtr();
    pCMD = (ComCallMethodDesc *) pFrame->ComMethodFrame::GetDatum();

    LOG((LF_STUBS, LL_INFO1000, "Calling ComToComPlusWorker %s::%s \n", pCMD->GetMethodDesc()->m_pszDebugClassName, pCMD->GetMethodDesc()->m_pszDebugMethodName));

    // Need to check for the presence of a security link demand on the target
    // method. If we're hosted inside of an app domain with security, we perform
    // the link demand against that app domain's grant set.
    MethodDesc *pRealMD = pCMD->GetMethodDesc();
    Security::CheckLinkDemandAgainstAppDomain(pRealMD);
 
    _ASSERTE((pCMD->m_HeaderToUse.m_flags & enum_CMLF_Simple) == 0);

    methSlot = pCMD->GetSlot();

        // clean up work list, used for allocating local data
    pCleanup = pFrame->ComMethodFrame::NonVirtual_GetCleanupWorkList();

    _ASSERTE(pCleanup != NULL);

    // Allocate enough memory to store both the destination buffer and
    // the locals.  But first, increase the likelihood that all the automatics
    // are reserved on the stack.

    UINT32           cbAlloc;
    BYTE            *pAlloc;
    BYTE            *pRestoreStack;
    BYTE            *plocals, *pdst, *pregs;
    VOID            *psrc;
    OBJECTREF        oref;
    INT64            comReturnValue;
    COMCALL_HELPER   helper;

#ifdef _DEBUG
    BYTE            *paranoid;
#endif

// !!! DON'T DO ANY STACK ALLOCATIONS FROM THIS POINT FORWARDS:

    cbAlloc = pCMD->GetBufferSize();

    _ASSERTE(cbAlloc == (pCMD->m_HeaderToUse.m_cbDstBuffer +
                         pCMD->m_HeaderToUse.m_cbLocals +
                         pCMD->m_HeaderToUse.m_cbHandles +
                         (NUM_ARGUMENT_REGISTERS * STACK_ELEM_SIZE)));
    _ASSERTE((cbAlloc & 3) == 0);   // for "rep stosd" below

    // A poor man's version of _alloca().  Note that we will take stack exceptions
    // as they occur.  Also, we need to zero memory so we can call cleanup at any
    // time without ambiguity.
    __asm
    {
        mov     [pRestoreStack], esp
        mov     ecx, [cbAlloc]
        xor     eax, eax
        sub     esp, ecx
        cld
        shr     ecx, 2
        mov     edi, esp
        mov     [pAlloc], esp
        rep     stosd
    }

    pregs = pAlloc + pCMD->m_HeaderToUse.m_cbDstBuffer;
    plocals = pregs + (NUM_ARGUMENT_REGISTERS * STACK_ELEM_SIZE);
    
    // check for invalid wrappers in the debug build
    // in the retail all bets are off
    _ASSERTE(ComCallWrapper::GetRefCount(pWrap, FALSE) != 0 ||
             pWrap->IsAggregated());

    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Marshal the args.  This could call out to a compiled stub, or to a
    // helper that will RunML.
    helper = pCMD->m_EnterHelper;
    if (helper)
    {
        psrc = pip+1;
        // move the dst pointer to end for __stdcall
        pdst = pregs;

        pFrame->ComMethodFrame::NonVirtual_SetDstArgsPointer(pdst);

        // protect args during marshalling
        EnableArgsGCProtection(pGCInfo);

        if (helper == ComCall::GenericHelperEnter)
        {
            if (pCleanup) {
                // Checkpoint the current thread's fast allocator (used for temporary
                // buffers over the call) and schedule a collapse back to the checkpoint in
                // the cleanup list. Note that if we need the allocator, it is
                // guaranteed that a cleanup list has been allocated.
                void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
                pCleanup->ScheduleFastFree(pCheckpoint);
                pCleanup->IsVisibleToGc();
            }

            RunML(((ComCallMLStub *) pCMD->GetEnterMLStub()->GetEntryPoint())->GetMLCode(),
                  psrc,
                  pdst,
                  (UINT8 * const) plocals,
                  pCleanup);
        }
        else if (helper != NULL)
        {
            // We can't assert that m_cbLocals is 0, even though the following compiled
            // helper cannot handle locals.  That's because there are two helpers and
            // only one may be compiled -- and the other may deal with the locals.
            // _ASSERTE(pheader->m_cbLocals == 0);
            __asm
            {
                mov     ecx, [psrc]
                mov     edx, [pdst]
                call    [helper]
            }
        }
    }

    // @TODO context cwb: The following is hideously expensive for various reasons:
    //
    // Move the wrapper's context out of the SimpleWrapper section (we need to
    // reconsider SimpleWrappers anyway).
    //
    // Do the context manipulation inside the generic stub, where we have the
    // current thread object in a register anyway.
    //
    // Plug the context hole with N/Direct entrypoints, including exports.
    //GetThread()->SetContext(pWrap->GetObjectContext());
    

    // Call the target.  We must defer getting the object ref until the last possible
    // moment, because the frame will NOT protect this arg.
    oref = pWrap->GetObjectRef();

    *((OBJECTREF *)(pregs + STACK_ELEM_SIZE)) = oref;

#ifdef _DEBUG
    MethodDesc* pMD = pCMD->GetMethodDesc();
    LPCUTF8 name = pMD->GetName();  
    LPCUTF8 cls = pMD->GetClass()->m_szDebugClassName;
#endif

    // Find the actual code to call.
    if(pCMD->IsVirtual()) 
    {
        MethodTable *pMT = oref->GetMethodTable();
        if (pMT->IsTransparentProxyType())
        {
            // For transparent proxies, we need to call on the interface method desc.
            pfnToCall = (PFN) pCMD->GetInterfaceMethodDesc()->GetPreStubAddr();
        }
        else
        {
            // we know the slot number for this method desc, grab the actual
            // address from the vtable for this slot. The slot number should
            // remain the same through out the heirarchy.
            pfnToCall = (PFN) *(oref->GetMethodTable()->GetVtable() + pCMD->GetSlot());
        }
    }
    else
    {
        pfnToCall =  (PFN) *(pCMD->GetMethodDesc()->GetMethodTable()->GetVtable() + pCMD->GetSlot());
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall((const BYTE *) pfnToCall);
#endif // DEBUGGING_SUPPORTED

    // disable protect args after marshalling
    DisableArgsGCProtection(pGCInfo);

#ifdef _DEBUG
    __asm
    {
        mov     [paranoid], esp
    }
    _ASSERTE(paranoid == pAlloc);
#endif

    __asm
    {
        mov     eax, [pregs]
        mov     edx, [eax]
        mov     ecx, [eax+4]
        call    [pfnToCall]
        INDEBUG(nop)                // This is a tag that we use in an assert.  Fcalls expect to
                                    // be called from Jitted code or from certain blessed call sites like
                                    // this one.  (See HelperMethodFrame::InsureInit)
        mov     dword ptr [comReturnValue], eax
        mov     dword ptr [comReturnValue+4], edx
    }


    if (pCMD->m_HeaderToUse.IsR4RetVal())
    {
        getFPReturn(4, comReturnValue);
    } 
    else if (pCMD->m_HeaderToUse.IsR8RetVal())
    {
        getFPReturn(8, comReturnValue);
    }


    // WARNING: Don't do any floating point stuff until we can call the m_LeaveHelper
    // routine to preserve what's on top of the floating point stack, if appropriate.

    returnValue = S_OK;

    helper = pCMD->m_LeaveHelper;
    if (helper)
    {
        pdst = NULL;

        // Marshal the return value and propagate any [out] parameters back.
        if (pCMD->m_HeaderToUse.IsReturnsHR()
            && !pCMD->m_HeaderToUse.IsVoidRetVal())
		{
            pdst = *(BYTE **)( ((BYTE*)pip) + pCMD->GetNumStackBytes() - sizeof(void*) );
		}
		else
		{
 		    pdst = (BYTE *) &returnValue;
		}

		if (pdst != NULL)  // If caller didn't supply a buffer for an [out,retval] - don't
						   // run unmarshaler - we may leak a return value.
		{

	        pdst += pCMD->m_HeaderToUse.Is8RetVal() ? 8 : 4;
	
		    if (helper == ComCall::GenericHelperLeave)
			{
				EnableRetGCProtection(pGCInfo);		
                if (pCMD->m_HeaderToUse.IsRetValNeedsGCProtect()) {
                    OBJECTREF oref = ObjectToOBJECTREF(*(Object**)&comReturnValue);
                    GCPROTECT_BEGIN(oref);
                    RunML(((ComCallMLStub *) pCMD->GetLeaveMLStub()->GetEntryPoint())->GetMLCode(),
                            &oref,
                            pdst,
                            (UINT8 * const) plocals,
                            pCleanup);
                    GCPROTECT_END();
                    comReturnValue = (INT64) OBJECTREFToObject(oref);
                        
                } else {

                    RunML(((ComCallMLStub *) pCMD->GetLeaveMLStub()->GetEntryPoint())->GetMLCode(),
                            &comReturnValue,
                            pdst,
                            (UINT8 * const) plocals,
                            pCleanup);
                }
				DisableRetGCProtection(pGCInfo);               
			}
			else if (helper != NULL)
			{
				// We can't assert that m_cbLocals is 0, even though the following compiled
				// helper cannot handle locals.  That's because there are two helpers and
				// only one may be compiled -- and the other may deal with the locals.
				// _ASSERTE(pheader->m_cbLocals == 0);
				__asm
				{
					lea     ecx, [comReturnValue]
					mov     edx, [pdst]
					call    [helper]
				}
			}
		}
    }


    // Now we have to put the stack back the way it was.  Otherwise, we'll pop off
    // some saved registers before we use EBP to unwind the stack.  The problem is
    // that the call we made via pfnToCall has popped part of the pAlloc buffer off
    // the stack.  It's not worth figuring out how much.  Instead, just smash back
    // to what it was before our "_alloca".
#ifdef _DEBUG
    __asm
    {
        mov     [paranoid], esp
    }
    _ASSERTE(paranoid >= pAlloc && paranoid <= pRestoreStack);
#endif

    __asm
    {
        mov     esp, [pRestoreStack]
    }

    pCleanup->Cleanup(FALSE);


    return returnValue;
#endif
}


//---------------------------------------------------------
// INT64 __stdcall ComToComPlusSimpleWorker(Thread *pThread, 
//                                  ComMethodFrame* pFrame)
//---------------------------------------------------------
// This is a simpler version of ComToComPlusWorker.  If we've optimized away all
// the marshaling and unmarshaling, we'll blow up when we try to access all those
// null pointers!

static 
INT64 __stdcall ComToComPlusSimpleWorker(Thread *pThread, ComMethodFrame* pFrame)
{
#ifndef _X86_
    _ASSERTE(!"NYI");
    return 0;
#else
    _ASSERTE(pFrame != NULL);
    _ASSERTE(pThread);

    IUnknown        *pUnk;
    ComCallWrapper  *pWrap;

    pUnk = *(IUnknown **)pFrame->GetPointerToArguments();
    _ASSERTE(pUnk != NULL);

    // Obtain the managed 'this' for the call
    pWrap =  ComCallWrapper::GetWrapperFromIP(pUnk);
    _ASSERTE(pWrap != NULL);

    if (pWrap->NeedToSwitchDomains(pThread, FALSE))
    {
	    AppDomain *pTgtDomain = pWrap->GetDomainSynchronized();
	    if (!pTgtDomain)
	    	return COR_E_APPDOMAINUNLOADED;
    
        ComToComPlusWorker_Args args = {pFrame, ComToComPlusSimpleWorker};
        pThread->DoADCallBack(pTgtDomain->GetDefaultContext(), ComToComPlusWorker_Wrapper, &args);
        return args.returnValue;
    }

    PFN     pfnToCall;

    // bypass virtualization of frame here to shave some cycles:
    _ASSERTE(pFrame->GetVTablePtr() == ComMethodFrame::GetMethodFrameVPtr());
    ComCallMethodDesc *pCMD = (ComCallMethodDesc *)(pFrame->ComMethodFrame::GetDatum());

    _ASSERTE(pCMD->m_HeaderToUse.m_flags & enum_CMLF_Simple);

    // Need to check for the presence of a security link demand on the target
    // method. If we're hosted inside of an app domain with security, we perform
    // the link demand against that app domain's grant set.
    MethodDesc *pRealMD = pCMD->GetMethodDesc();
    Security::CheckLinkDemandAgainstAppDomain(pRealMD);

    // check for invalid wrappers in the debug build
    // in the retail all bets are off
    _ASSERTE(ComCallWrapper::GetRefCount(pWrap, FALSE) != 0);
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // @TODO context cwb: The following is hideously expensive for various reasons:
    //
    // Move the wrapper's context out of the SimpleWrapper section (we need to
    // reconsider SimpleWrappers anyway).
    //
    // Do the context manipulation inside the generic stub, where we have the
    // current thread object in a register anyway.
    //
    // Plug the context hole with N/Direct entrypoints, including exports.
    //GetThread()->SetContext(pWrap->GetObjectContext());

    // Call the target.
    OBJECTREF        oref;
    oref = pWrap->GetObjectRef();

    // Find the actual code to call.
    if(pCMD->IsVirtual()) 
    {
        MethodTable *pMT = oref->GetMethodTable();
        if (pMT->IsTransparentProxyType())
        {
            // For transparent proxies, we need to call on the interface method desc.
            pfnToCall = (PFN) pCMD->GetInterfaceMethodDesc()->GetPreStubAddr();
        }
        else
        {
            // we know the slot number for this method desc, grab the actual
            // address from the vtable for this slot. The slot number should
            // remain the same through out the heirarchy.
            pfnToCall = (PFN) *(oref->GetMethodTable()->GetVtable() + pCMD->GetSlot());
        }
    }
    else
    {
        pfnToCall =  (PFN) *(pCMD->GetMethodDesc()->GetMethodTable()->GetVtable() + pCMD->GetSlot());
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
    {
        g_pDebugInterface->TraceCall((const BYTE *) pfnToCall);
    }
#endif // DEBUGGING_SUPPORTED
    
    __asm
    {
        mov     ecx, [oref]
        call    [pfnToCall]
        INDEBUG(nop)                // This is a tag that we use in an assert.  Fcalls expect to
                                    // be called from Jitted code or from certain blessed call sites like
                                    // this one.  (See HelperMethodFrame::InsureInit)
        // intentionally discard the results
    }
    return S_OK;
#endif
}


//FieldCall Worker
static 
INT64 __stdcall FieldCallWorker(Thread *pThread, ComMethodFrame* pFrame)
{
#ifndef _X86_
    _ASSERTE(!"NYI");
    return 0;
#else
    _ASSERTE(pFrame != NULL);
    INT64 returnValue = S_OK;
    OBJECTREF pThrownObject = NULL;

    ComCallGCInfo gcDummy;
    ComCallGCInfo* pGCInfo = &gcDummy; //init gcinfo pointer

    CleanupWorkList *pCleanup = NULL;
    void *pRestoreStack = NULL;

    COMPLUS_TRY 
    {
        IUnknown** pip = (IUnknown **)pFrame->GetPointerToArguments();
        IUnknown* pUnk = (IUnknown *)*pip; 
        _ASSERTE(pUnk != NULL);

        ComCallWrapper* pWrap =  ComCallWrapper::GetWrapperFromIP(pUnk);

        _ASSERTE(pWrap != NULL);

        if (pWrap->NeedToSwitchDomains(pThread, FALSE))
        {
	        AppDomain *pTgtDomain = pWrap->GetDomainSynchronized();
    	    if (!pTgtDomain)
                return COR_E_APPDOMAINUNLOADED;
        
            ComToComPlusWorker_Args args = {pFrame, FieldCallWorker};
            pThread->DoADCallBack(pTgtDomain->GetDefaultContext(), ComToComPlusWorker_Wrapper, &args);
            returnValue = args.returnValue;
        }

        ComCallMethodDesc *pCMD = (ComCallMethodDesc *)(pFrame->GetDatum());
        _ASSERTE(pCMD->IsFieldCall());      

        FieldDesc* pFD = pCMD->GetFieldDesc();
        _ASSERTE(pFD != NULL);
    
        // clean up work list, used for allocating local data
        pCleanup = pFrame->GetCleanupWorkList();

        VOID   *psrc = pip+1;

        // check for invalid wrappers in the debug build
        // in the retail all bets are off
        _ASSERTE(ComCallWrapper::GetRefCount(pWrap, FALSE) != 0);

        // @TODO context cwb: The following is hideously expensive for various reasons:
        //
        // Move the wrapper's context out of the SimpleWrapper section (we need to
        // reconsider SimpleWrappers anyway).
        //
        // Do the context manipulation inside the generic stub, where we have the
        // current thread object in a register anyway.
        //
        // Plug the context hole with N/Direct entrypoints, including exports.
        //GetThread()->SetContext(pWrap->GetObjectContext());

        //pThread->DisablePreemptiveGC();

        COMCALL_HELPER helper;
        OBJECTREF oref = NULL;
        OBJECTREF tempOref = NULL;
        INT64 tempBuffer;
        UINT32 cbAlloc;
        void *pfld;
        void *pdst;
        UINT8 *pAlloc;

#ifdef _DEBUG
        void *paranoid;
#endif

        GCPROTECT_BEGIN(oref);
        GCPROTECT_BEGIN(tempOref);

        // !!! DON'T DO ANY STACK ALLOCATIONS FROM THIS POINT FORWARDS:

        cbAlloc = pCMD->GetBufferSize();

        _ASSERTE(cbAlloc == (pCMD->m_HeaderToUse.m_cbDstBuffer +
                             pCMD->m_HeaderToUse.m_cbLocals +
                             pCMD->m_HeaderToUse.m_cbHandles +
                             (NUM_ARGUMENT_REGISTERS * STACK_ELEM_SIZE)));
        _ASSERTE(pCMD->m_HeaderToUse.m_cbDstBuffer == 0);
        _ASSERTE(pCMD->m_HeaderToUse.m_cbHandles == 0);
        _ASSERTE((cbAlloc & 3) == 0);   // for "rep stosd" below

        // A poor man's version of _alloca().  Note that we will take stack exceptions
        // as they occur.  

        // @todo: don't bother to zero memory

        __asm
          {
              mov     [pRestoreStack], esp
              mov     ecx, [cbAlloc]
              xor     eax, eax
              sub     esp, ecx
              cld
              shr     ecx, 2
              mov     edi, esp
              mov     [pAlloc], esp
              rep     stosd
          }

        oref = pWrap->GetObjectRef();

        pfld = pFD->GetAddress(oref->GetAddress());

        // Call the enter helper.

        helper = pCMD->m_EnterHelper;

        if (helper == ComCall::GenericHelperEnter)
        {
            if (pCleanup) {
                // Checkpoint the current thread's fast allocator (used for temporary
                // buffers over the call) and schedule a collapse back to the checkpoint in
                // the cleanup list. Note that if we need the allocator, it is
                // guaranteed that a cleanup list has been allocated.
                void *pCheckpoint = pThread->m_MarshalAlloc.GetCheckpoint();
                pCleanup->ScheduleFastFree(pCheckpoint);
                pCleanup->IsVisibleToGc();
            }

            // This switch is in place because RunML may GC in the case of string
            // allocations, etc.         
            if(pFD->IsObjRef())
            {
                tempOref = *((OBJECTREF *)pfld);
                pdst = &OBJECTREF_TO_UNCHECKED_OBJECTREF(tempOref);
            }
            else
            {
                // borrow the returnValue as an INT64 to hold contents of field                
                pdst = &tempBuffer;
                tempBuffer = *(INT64 *)pfld;
            }        
            
            RunML(((ComCallMLStub *) pCMD->GetEnterMLStub()->GetEntryPoint())->GetMLCode(),
                  psrc,
                  pdst,                                    
                  pAlloc,
                  pCleanup);

            // Update the field from our dummy location.
            pFD->SetInstanceField(oref, pdst);              
        }
        else if (helper != NULL)
        {
            __asm
              {
                  mov     ecx, [psrc]
                  mov     edx, [pfld]
                  call    [helper]
              }
        }

        // Call the leave helper

        psrc = &returnValue;
    
        helper = pCMD->m_LeaveHelper;

        if (helper == ComCall::GenericHelperEnter)
        {
            RunML(((ComCallMLStub *) pCMD->GetEnterMLStub()->GetEntryPoint())->GetMLCode(),
                  psrc,
                  pfld,
                  pAlloc,
                  pCleanup);
        }
        else if (helper != NULL)
        {
            __asm
              {
                  mov     ecx, [psrc]
                  mov     edx, [pfld]
                  call    [helper]
              }
        }

        if (pCleanup)
        {
            pCleanup->Cleanup(FALSE);
        }



        if (pRestoreStack != NULL)
        {
#ifdef _DEBUG
            __asm
            {
                mov     [paranoid], esp
            }
            _ASSERTE(paranoid == pAlloc);
#endif

            __asm
            {
                mov     esp, [pRestoreStack]
            }
        }

        GCPROTECT_END(); // tempOref
        GCPROTECT_END(); // oref
    } 
    COMPLUS_CATCH 
    {
        // clean up
        if (pCleanup)
            pCleanup->Cleanup(TRUE);

        // disable protect args in case exception occurred during marshalling
        if(pGCInfo != NULL)
            DisableArgsGCProtection(pGCInfo);

        if (((ComCallMethodDesc *)(pFrame->GetDatum()))->m_HeaderToUse.IsReturnsHR())
            returnValue = SetupErrorInfo(GETTHROWABLE());
        else
        {
            // @todo: what do do here - anything? RaiseException?
            returnValue = 0;
        }
    }
    COMPLUS_END_CATCH

    return returnValue;
#endif
}


//---------------------------------------------------------
// Either creates or retrieves from the cache, a stub to
// invoke ComCall methods. Each call refcounts the returned stub.
// This routines throws a COM+ exception rather than returning
// NULL.
//---------------------------------------------------------
/*static*/ 
Stub* ComCall::GetComCallMethodStub(StubLinker *pstublinker, ComCallMethodDesc *pCMD)
{

    THROWSCOMPLUSEXCEPTION();

    if (!SetupGenericStubs())
        return NULL;

    // The stub style we return is to a single generic stub for method calls and to
    // a single generic stub for field accesses.  The generic stub parameterizes
    // its behavior based on the ComCallMethodDesc.  This contains two entrypoints
    // -- one for marshaling the args and one for unmarshaling the return value and
    // outbounds.  These entrypoints may be compiled or they may be generic routines
    // that RunML.  Either way, the snippets of ML / compiled ML can be cached and
    // shared based on the signature.
    //
    // @TODO cwb: rethink having 1 vs. 2 generic stubs for field accesses.

    // Perhaps we have already built this stub and installed it on pCMD.  If not,
    // progress through each stage of the manufacture -- but be aware that
    // another thread may be racing us to the finish.
    if (pCMD->GetEnterMLStub() == NULL)
    {
        OBJECTREF  pThrowable;

        if (!CreateComCallMLStub(pCMD, &pThrowable))
            COMPlusThrow(pThrowable);
    }

    // Now we want to canonicalize each piece and install them into the pCMD.
    // These should be shared, if possible.  The entrypoints might be to generic
    // RunML services or to compiled ML stubs. Either way, they are cached/shared
    // based on signature.

    GetThread()->GetDomain()->GetComCallMLStubCache()->Canonicalize(pCMD);

    // Finally, we need to build a stub that represents the entire call.  This
    // is always generic.

    return (pCMD->IsFieldCall()
            ? g_pGenericComCallStubFields
            : ((pCMD->m_HeaderToUse.m_flags & enum_CMLF_Simple)
               ? g_pGenericComCallSimpleStub
               : g_pGenericComCallStub));
}

//---------------------------------------------------------
// Call at strategic times to discard unused stubs.
//---------------------------------------------------------
/*static*/ VOID ComCall::FreeUnusedStubs()
{
    GetThread()->GetDomain()->GetComCallMLStubCache()->FreeUnusedStubs();
}


//---------------------------------------------------------
// Creates a new stub for a ComCall call. Return refcount is 1.
// This Worker() routine is broken out as a separate function
// for purely logistical reasons: our COMPLUS exception mechanism
// can't handle the destructor call for StubLinker so this routine
// has to return the exception as an outparam. 
//---------------------------------------------------------
static BOOL CreateComCallMLStubWorker(ComCallMethodDesc *pCMD,
                                        MLStubLinker *psl,
                                        MLStubLinker *pslPost,
                                        PCCOR_SIGNATURE szMetaSig,
                                        HENUMInternal *phEnumParams,
                                        BOOL fReturnsHR,
                                        Module* pModule,
                                        OBJECTREF *ppException)
{
    Stub* pstub = NULL;
    Stub* pstubPost = NULL;
    int iLCIDArg = (UINT)-1;

    COMPLUS_TRY 
    {
        THROWSCOMPLUSEXCEPTION();
    
        IMDInternalImport *pInternalImport = pModule->GetMDImport();
        _ASSERTE(pInternalImport);

        _ASSERTE(pCMD->IsMethodCall());

        CorElementType  mtype;
        MetaSig         msig(szMetaSig, pModule);
        ComCallMLStub   header;
        LPCSTR          szName;
        USHORT          usSequence;
        DWORD           dwAttr;
        mdParamDef      returnParamDef = mdParamDefNil;
        mdParamDef      currParamDef = mdParamDefNil;
        MethodDesc      *pMD = NULL;
                
        pMD = pCMD->GetInterfaceMethodDesc();
        if (pMD == NULL)
            pMD = pCMD->GetMethodDesc();

#ifdef _DEBUG
        LPCUTF8         szDebugName = pMD->m_pszDebugMethodName;
        LPCUTF8         szDebugClassName = pMD->m_pszDebugClassName;
#endif

        header.Init();
        if (fReturnsHR)
            header.SetReturnsHR();
        header.m_cbDstBuffer = 0;
        if (msig.IsObjectRefReturnType())
            header.SetRetValNeedsGCProtect();
    
        // Emit space for the header. We'll go back and fill it in later.
        psl->MLEmitSpace(sizeof(header));
        pslPost->MLEmitSpace(sizeof(header));

        // Our calling convention allows us to enregister 2 args.  For ComCalls,
        // the first arg is always consumed for 'this'.  The remaining args are
        // sensitive to fUsedRegister.
        BOOL fUsedRegister = FALSE;
        BOOL pslNoop = TRUE;
        BOOL pslPostNoop = TRUE;

        int numArgs = msig.NumFixedArgs();

        SigPointer returnSig = msig.GetReturnProps();

        UINT16 nativeArgSize = sizeof(void*);

        //
        // Look for a hidden first arg that contains return type info - it will have
        // sequence 0. In most cases, the sequence number will start at 1, but for 
        // value types return values or others that can't return in register, there will be a 
        // parameter with sequence 0 describing the return type.
        //

        do 
        {
            if (phEnumParams && pInternalImport->EnumNext(phEnumParams, &currParamDef))
            {
                szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);
                if (usSequence == 0)
                {
                    // The first parameter, if it has sequence 0, actually describes the return type.
                    returnParamDef = currParamDef;
                }
            }
            else
            {
                usSequence = (USHORT)-1;
            }
        }
        while (usSequence == 0);

        //
        // Marshal the arguments first
        //
                                               
        BOOL fBadCustomMarshalerLoad = FALSE;
        OBJECTREF pCustomMarshalerLoadException = NULL;
        GCPROTECT_BEGIN(pCustomMarshalerLoadException);
        
        // If this is a method call then check to see if we need to do LCID conversion.
        iLCIDArg = GetLCIDParameterIndex(pMD->GetMDImport(), pMD->GetMemberDef());
        if (iLCIDArg != -1)
            iLCIDArg++;

        // Look up the best fit mapping info via Assembly & Interface level attributes
        BOOL BestFit = TRUE;
        BOOL ThrowOnUnmappableChar = FALSE;
        ReadBestFitCustomAttribute(pMD, &BestFit, &ThrowOnUnmappableChar);

        MarshalInfo *pMarshalInfo = (MarshalInfo*)_alloca(sizeof(MarshalInfo) * numArgs);
        BOOL fUnbump = FALSE;
        int iArg = 1;
        while (ELEMENT_TYPE_END != (mtype = msig.NextArg()))
        {
            // Check to see if this is the parameter after which we need to read the LCID from.
            if (iArg == iLCIDArg)
            {
                psl->MLEmit(ML_LCID_N2C);
                nativeArgSize += sizeof(LCID);
            }

            // Watch out for enums
            if (mtype == ELEMENT_TYPE_VALUETYPE)
                mtype = msig.GetArgProps().Normalize(pModule);

            mdParamDef paramDef = mdParamDefNil;

            //
            // If it's a register arg, move the dest to point to the
            // register area
            //

            // !!! bug !!! 
            // Need to also detect if arg is value class with
            // ELEMENT_TYPE_CLASS sig

            if (!fUsedRegister && gElementTypeInfo[mtype].m_enregister && !msig.HasRetBuffArg())
            {
                psl->MLEmit(ML_BUMPDST);
                UINT16 tmp16 = header.m_cbDstBuffer;
                if (!SafeAddUINT16(&tmp16, MLParmSize(sizeof(void*))))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

                // This is assuming the dest size is promoted to sizeof(void*)
                psl->Emit16(tmp16);
                fUsedRegister = TRUE;
                fUnbump = TRUE;
            }

            //
            // Make a note if the arg has gc protection requirements.
            //
        
            if (TRUE /* @todo: !!! m_type has gc refs*/)
                header.SetArgsGCProtReq();

            //
            // Get the parameter token if the current argument has one.
            //

            if (usSequence == iArg)
            {
                paramDef = currParamDef;

                if (pInternalImport->EnumNext(phEnumParams, &currParamDef))
                {
                    szName = pInternalImport->GetParamDefProps(currParamDef, &usSequence, &dwAttr);

                    // Validate that the param def tokens are in order.
                    _ASSERTE((usSequence > iArg) && "Param def tokens are not in order");
                }
                else
                {
                    usSequence = (USHORT)-1;
                }
            }

            //
            // Generate the ML for the arg.
            //

            //   Lame beta-1 hack to address a common problem that's not easily
            //   solvable in an elegant way: properly recovering with an HRESULT
            //   failure due to failure to load a custom marshalers.
            //
            //   MarshalInfo() throws in this case, and this case only. We want
            //   to keep processing marshalinfo's so that we can compute the
            //   arg stacksize properly (otherwise, the caller can't recover.)
            //   But we want don't want to lose the error information from the
            //   classloader either, so we can't just dump a ML_THROW into the stream
            //   and forget about it. So we catch the exception and hold it just long
            //   enough so we parse everything we have to to compute the stack arg size
            //   and give us a fighting chance to return with the stack correctly
            //   balanced.
            COMPLUS_TRY
            {
                new (pMarshalInfo + iArg - 1)MarshalInfo(pModule, msig.GetArgProps(), paramDef, 
                     MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, TRUE, iArg, BestFit, ThrowOnUnmappableChar

#ifdef CUSTOMER_CHECKED_BUILD
                     ,pMD
#endif
#ifdef _DEBUG
                     ,szDebugName, szDebugClassName, NULL, iArg
#endif
                    );
            }
            COMPLUS_CATCH
            {
                pCustomMarshalerLoadException = GETTHROWABLE();
                fBadCustomMarshalerLoad = TRUE;
            }
            COMPLUS_END_CATCH
            pMarshalInfo[iArg - 1].GenerateArgumentML(psl, pslPost, FALSE);

            //
            // If we had a register arg, bump back to the normal place.
            //

            if (fUnbump)
            {
                psl->MLEmit(ML_BUMPDST);
                psl->Emit16(-header.m_cbDstBuffer);
                fUnbump = FALSE;
            }
            else
            {
                if (!SafeAddUINT16(&header.m_cbDstBuffer, pMarshalInfo[iArg - 1].GetComArgSize()))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

            }
            if (fBadCustomMarshalerLoad || pMarshalInfo[iArg - 1].GetMarshalType() == MarshalInfo::MARSHAL_TYPE_UNKNOWN)
            {
                nativeArgSize += MLParmSize(sizeof(LPVOID));
            }
            else
            {
                nativeArgSize += pMarshalInfo[iArg - 1].GetNativeArgSize();
            }

            //
            // Increase the argument index.
            //

            iArg++;

            // @todo: it's possible that either of these could actually
            // still be noops.  Should be more accurate.
            pslNoop = FALSE; // we can't ignore psl anymore
            pslPostNoop = FALSE; // we can't ignore pslPost anymore
        }

        // Check to see if this is the parameter after which we need to read the LCID from.
        if (iArg == iLCIDArg)
        {
            psl->MLEmit(ML_LCID_N2C);
            nativeArgSize += sizeof(LCID);
            pslNoop = FALSE; // we can't ignore psl anymore
        }

        // Make sure that there are not more param def tokens then there are COM+ arguments.
        _ASSERTE( usSequence == (USHORT)-1 && "There are more parameter information tokens then there are COM+ arguments" );


        //
        // Now generate ML for the return value
        //


        if (msig.GetReturnType() != ELEMENT_TYPE_VOID)
        {
            MarshalInfo::MarshalType marshalType;

            MarshalInfo info(pModule, returnSig, returnParamDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0,
                            BestFit, ThrowOnUnmappableChar

#ifdef CUSTOMER_CHECKED_BUILD
                             ,pMD
#endif
#ifdef _DEBUG
                             ,szDebugName, szDebugClassName, NULL, 0
#endif
                             );
            marshalType = info.GetMarshalType();


            if (marshalType == MarshalInfo::MARSHAL_TYPE_VALUECLASS ||
                marshalType == MarshalInfo::MARSHAL_TYPE_BLITTABLEVALUECLASS ||
                marshalType == MarshalInfo::MARSHAL_TYPE_GUID ||
                marshalType == MarshalInfo::MARSHAL_TYPE_DECIMAL
                )
            {
                //
                // Our routine returns a value class, which means that
                // the marshaler will pass a byref for the result.
                // 
                MethodTable *pMT = msig.GetRetTypeHandle().AsMethodTable();
                UINT         managedSize = msig.GetRetTypeHandle().GetSize();

                if (!fReturnsHR)
                {
                    COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }
                _ASSERTE(IsManagedValueTypeReturnedByRef(managedSize));

                psl->MLEmit(ML_BUMPDST);
                UINT16 tmp16 = header.m_cbDstBuffer;
                if (!SafeAddUINT16(&tmp16, MLParmSize(sizeof(void*))))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

                psl->Emit16(tmp16);

                if (pMT->GetClass()->IsBlittable())
                {
                    psl->MLEmit(sizeof(LPVOID) == 4 ? ML_COPY4 : ML_COPY8);
                }
                else
                {
                    psl->MLEmit(ML_STRUCTRETN2C);
                    psl->EmitPtr(pMT);
                    pslPost->MLEmit(ML_STRUCTRETN2C_POST);
                    pslPost->Emit16(psl->MLNewLocal(sizeof(ML_STRUCTRETN2C_SR)));
                }
                fUsedRegister = TRUE;
                nativeArgSize += MLParmSize(sizeof(LPVOID));
            }
            else if (marshalType == MarshalInfo::MARSHAL_TYPE_DATE && fReturnsHR)
            {
                psl->MLEmit(ML_BUMPDST);
                UINT16 tmp16 = header.m_cbDstBuffer;
                if (!SafeAddUINT16(&tmp16, MLParmSize(sizeof(void*))))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

                psl->Emit16(tmp16);

                psl->MLEmit(ML_DATETIMERETN2C);
                pslPost->MLEmit(ML_DATETIMERETN2C_POST);
                pslPost->Emit16(psl->MLNewLocal(sizeof(ML_DATETIMERETN2C_SR)));

                fUsedRegister = TRUE;
                nativeArgSize += MLParmSize(sizeof(LPVOID));
            }
            else if (marshalType == MarshalInfo::MARSHAL_TYPE_CURRENCY && fReturnsHR)
            {
                psl->MLEmit(ML_BUMPDST);
                UINT16 tmp16 = header.m_cbDstBuffer;
                if (!SafeAddUINT16(&tmp16, MLParmSize(sizeof(void*))))
                {
                    COMPlusThrow(kMarshalDirectiveException, IDS_EE_SIGTOOCOMPLEX);
                }

                psl->Emit16(tmp16);

                psl->MLEmit(ML_CURRENCYRETN2C);
                pslPost->MLEmit(ML_CURRENCYRETN2C_POST);
                pslPost->Emit16(psl->MLNewLocal(sizeof(ML_CURRENCYRETN2C_SR)));

                fUsedRegister = TRUE;
                nativeArgSize += MLParmSize(sizeof(LPVOID));
            }
            else
            {

                if (msig.HasRetBuffArg())
                {
                    COMPlusThrow(kTypeLoadException, IDS_EE_NDIRECT_UNSUPPORTED_SIG);
                }

				
				COMPLUS_TRY
                {
    
                    info.GenerateReturnML(psl, pslPost, FALSE, fReturnsHR);
                    if (info.IsFpu())
                    {
                        if (info.GetMarshalType() == MarshalInfo::MARSHAL_TYPE_FLOAT)
                        {
                            header.SetR4RetVal();
                        }
                        else
                        {
                            _ASSERTE(info.GetMarshalType() == MarshalInfo::MARSHAL_TYPE_DOUBLE);
                            header.SetR8RetVal();
                        }
                    }
	                nativeArgSize += info.GetNativeArgSize();
                }
                COMPLUS_CATCH
                {
					// another stupid stack-restore guessing game: almost all COM interop methods
					// return thru buffers, so assume we had one extra argument as a buffer.
					// (it's reasonably safe to assume a "void" return isn't going to cause
					// MarshalInfo to throw...)
					nativeArgSize += sizeof(LPVOID);
                    pCustomMarshalerLoadException = GETTHROWABLE();
                    fBadCustomMarshalerLoad = TRUE;
                }
                COMPLUS_END_CATCH
	

            }

            // @todo: it's possible that either of these could actually
            // still be noops.  Should be more accurate.
            pslNoop = FALSE; // we can't ignore psl anymore
            pslPostNoop = FALSE; // we can't ignore pslPost anymore
        }
        else
            header.SetVoidRetVal();

        psl->MLEmit(ML_END);
        pslPost->MLEmit(ML_END);

        if (fUsedRegister)
            header.SetEnregistered();

        header.m_cbLocals = psl->GetLocalSize();

        if (msig.Is64BitReturn())
            header.Set8RetVal();

        if (pslNoop)
            pstub = NULL;
        else
        {
            pstub = psl->Link();
            *((ComCallMLStub *)(pstub->GetEntryPoint())) = header;
            PatchMLStubForSizeIs(sizeof(header) + (BYTE*)(pstub->GetEntryPoint()),
                                 numArgs,
                                 pMarshalInfo);
        }

        if (pslPostNoop)
            pstubPost = NULL;
        else
        {
            pstubPost = pslPost->Link();
            *((ComCallMLStub *)(pstubPost->GetEntryPoint())) = header;
        }

        //
        // Fill in return thunk with proper native arg size.
        //

        BYTE *pMethodDescMemory = ((BYTE*)pCMD) + pCMD->GetOffsetOfReturnThunk();

#ifdef _X86_                    
        pMethodDescMemory[0] = 0xc2;

        if (!(nativeArgSize < 0x7fff))
        {
            COMPlusThrow(kTypeLoadException, IDS_EE_SIGTOOCOMPLEX);
        }

        *(SHORT *)&pMethodDescMemory[1] = (SHORT)nativeArgSize;
#else
        _ASSERTE(!"ComCall.cpp (CreateComCallMLStubWorker) Implement non-x86");
#endif
        
        pCMD->SetNumStackBytes(nativeArgSize);

        GCPROTECT_END();
        if (pCustomMarshalerLoadException != NULL)
        {
            COMPlusThrow(pCustomMarshalerLoadException);
        }

        //MLSummary summary;
        //summary.ComputeMLSummary(header.GetMLCode());
        //_ASSERTE(header.m_cbLocals == summary.m_cbTotalLocals);
        //header.m_cbHandles = summary.m_cbTotalHandles;
    }
    COMPLUS_CATCH 
    {
        *ppException = GETTHROWABLE();

        if (pstub)
        {
            pstub->DecRef();
        }

        return FALSE;
    }
    COMPLUS_END_CATCH

    pCMD->InstallMLStubs(pstub, pstubPost);

    return TRUE;
}



//---------------------------------------------------------
// Creates a new stub for a FieldCall call. Return refcount is 1.
// This Worker() routine is broken out as a separate function
// for purely logistical reasons: our COMPLUS exception mechanism
// can't handle the destructor call for StubLinker so this routine
// has to return the exception as an outparam. 
//---------------------------------------------------------
static BOOL CreateFieldCallMLStubWorker(ComCallMethodDesc *pCMD,
                                          MLStubLinker      *psl,
                                          MLStubLinker      *pslPost,
                                          PCCOR_SIGNATURE   szMetaSig,
                                          mdFieldDef        fieldDef,
                                          BOOL              fReturnsHR,
                                          Module*           pModule,
                                          OBJECTREF         *ppException,
                                          CorElementType    cetype,
                                          BOOL              IsGetter)
{
    Stub* pstub = NULL;
    Stub* pstubPost = NULL;

    COMPLUS_TRY 
    {
        THROWSCOMPLUSEXCEPTION();
    
        FieldSig fsig(szMetaSig, pModule);
        ComCallMLStub header;

        header.Init();
        if (fReturnsHR)
            header.SetReturnsHR();
        header.SetFieldCall();
        
        // Emit space for the header. We'll go back and fill it in later.
        psl->MLEmitSpace(sizeof(header));

#if 0
        // If our parameter is in a register, bump the dst pointer to
        // the register area.  
        if ((!IsGetter || fReturnsHR)
            && gElementTypeInfo[cetype].m_enregister)
        {
            psl->MLEmit(ML_BUMPDST);
            psl->Emit16(header.m_cbDstBuffer + MLParmSize(sizeof(void*)));
        }
#endif

        // Look up the best fit mapping info via Assembly & Interface level attributes
        BOOL BestFit = TRUE;
        BOOL ThrowOnUnmappableChar = FALSE;
        MethodTable* pMT = pCMD->GetFieldDesc()->GetMethodTableOfEnclosingClass();
        ReadBestFitCustomAttribute(pMT->GetClass()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);


        //
        // Generate the ML
        //

        SigPointer sig = fsig.GetProps();
        MarshalInfo info(pModule, sig, fieldDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                     ,NULL
#endif
                     );

        if (IsGetter)
        {
            header.SetGetter();
            info.GenerateGetterML(psl, pslPost, fReturnsHR);
        }
        else
        {
            header.SetVoidRetVal();
            info.GenerateSetterML(psl, pslPost);
        }

        //
        // Note that only one of the linkers ever gets used, so
        // don't bother to link them both.
        //

        if (IsGetter && !fReturnsHR)
        {
            pslPost->MLEmit(ML_END);
            header.m_cbLocals = pslPost->GetLocalSize();

            pstubPost = pslPost->Link();
            *((ComCallMLStub *)(pstubPost->GetEntryPoint())) = header;
        }
        else
        {
            psl->MLEmit(ML_END);
            header.m_cbLocals = psl->GetLocalSize();

            pstub = psl->Link();
            *((ComCallMLStub *)(pstub->GetEntryPoint())) = header;
        }

        //
        // Fill in return thunk with proper native arg size.
        //

        BYTE *pMethodDescMemory = ((BYTE*)pCMD) + pCMD->GetOffsetOfReturnThunk();

        UINT16 nativeArgSize = info.GetNativeArgSize() + sizeof(void*);

#ifdef _X86_                    
        pMethodDescMemory[0] = 0xc2;
        if (!(nativeArgSize < 0x7fff))
        {
            COMPlusThrow(kTypeLoadException, IDS_EE_SIGTOOCOMPLEX);
        }
        *(SHORT *)&pMethodDescMemory[1] = (SHORT)nativeArgSize;
#else
        _ASSERTE(!"ComCall.cpp (CreateFieldCallMLStubWorker) Implement non-x86");
#endif

        pCMD->SetNumStackBytes(nativeArgSize);

    }
    COMPLUS_CATCH 
    {
        *ppException = GETTHROWABLE();
        return FALSE;
    }
    COMPLUS_END_CATCH

    pCMD->InstallMLStubs(pstub, pstubPost);

    return TRUE;
}



static BOOL CreateComCallMLStub(ComCallMethodDesc* pCMD, OBJECTREF *ppThrowable)
{
    _ASSERTE(pCMD != NULL);

    PCCOR_SIGNATURE     pSig;
    DWORD               cSig;
    MLStubLinker        sl, slPost;
    BOOL                res = FALSE;
    
    if (pCMD->IsFieldCall())
    {
        FieldDesc          *pFD = pCMD->GetFieldDesc();

        _ASSERTE(pFD != NULL);

        BOOL                IsGetter = pCMD->IsFieldGetter();
        CorElementType      cetype = pFD->GetFieldType();
        mdFieldDef          fieldDef = pFD->GetMemberDef();

        // @todo: need to figure out if we can get this from the metadata,
        // or if it even makes sense to support a value of FALSE here.
        BOOL                fReturnsHR = TRUE; 
        
        pFD->GetSig(&pSig, &cSig);
        res = CreateFieldCallMLStubWorker(pCMD, &sl, &slPost, 
                                          pSig, fieldDef, fReturnsHR, 
                                          pFD->GetModule(),
                                          ppThrowable, cetype, IsGetter);
    }
    else
    {
        MethodDesc *pMD = pCMD->GetInterfaceMethodDesc();
        if (pMD == NULL)
            pMD = pCMD->GetMethodDesc();

        _ASSERTE(pMD != NULL);
        pMD->GetSig(&pSig, &cSig);

        IMDInternalImport *pInternalImport = pMD->GetMDImport();
        mdMethodDef md = pMD->GetMemberDef();

        HENUMInternal hEnumParams, *phEnumParams;
        HRESULT hr = pInternalImport->EnumInit(mdtParamDef, 
                                                md, &hEnumParams);
        if (FAILED(hr))
            phEnumParams = NULL;
        else
            phEnumParams = &hEnumParams;

        ULONG ulCodeRVA;
        DWORD dwImplFlags;
        pInternalImport->GetMethodImplProps(md, &ulCodeRVA,
                                                  &dwImplFlags);

		// Determine if we need to do HRESULT munging for this method.
        BOOL fReturnsHR = !IsMiPreserveSig(dwImplFlags);

        res = CreateComCallMLStubWorker(pCMD, &sl, &slPost, 
                                        pSig, phEnumParams, fReturnsHR,
                                        pMD->GetModule(), ppThrowable);
    }

    return res;
}


// Discard all the resources owned by this stub (including releasing reference counts
// on shared resources).
void ComCall::DiscardStub(ComCallMethodDesc *pCMD)
{
#ifdef _X86_
    Stub    *pStub;

    pStub = pCMD->GetEnterMLStub();
    if (pStub)
        pStub->DecRef();

    pStub = pCMD->GetLeaveMLStub();
    if (pStub)
        pStub->DecRef();

    pStub = pCMD->GetEnterExecuteStub();
    if (pStub)
        pStub->DecRef();

    pStub = pCMD->GetLeaveExecuteStub();
    if (pStub)
        pStub->DecRef();
#elif defined(CHECK_PLATFORM_BUILD)
    #error"Platform not yet supported"
#else
    _ASSERTE(!"Platform not yet supported");
#endif
}

// Take the pCMD which is passed in a register by the common stub and do a RunML of
// the appropriate bit of ML.
#ifndef _X86_
INT64 ComCall::GenericHelperEnter()
#else // _X86_
INT64 __declspec(naked) ComCall::GenericHelperEnter()
#endif // !_X86_
{
#ifdef _X86_
    /*
    RunML(((ComCallMLStub *) pCMD->GetEnterMLStub()->GetEntryPoint())->GetMLCode(),
          psrc,
          pdst,
          (UINT8 * const) plocals,
          pCleanup);
    */
    __asm
    {
        ret
    }
#else
    _ASSERTE(!"Platform not supported yet");
    return 0;
#endif
}

#ifndef _X86_
INT64 ComCall::GenericHelperLeave()
#else // _X86_
INT64 __declspec(naked) ComCall::GenericHelperLeave()
#endif // !_X86_
{
#ifdef _X86_
    /*
    RunML(((ComCallMLStub *) pCMD->GetEnterMLStub()->GetEntryPoint())->GetMLCode(),
          &nativeReturnValue,
          ((BYTE *)pdst) + pCMD->m_HeaderToUse->Is8RetVal() ? 8 : 4,
          (UINT8 * const) plocals,
          pCleanup);
    */
    __asm
    {
        ret
    }
#else
    _ASSERTE(!"Platform not supported yet");
    return 0;
#endif
}

// Atomically install both the ML stubs into the ComCallMethodDesc.  (The
// leave stub may be NULL if this is a field accessor).
void ComCallMethodDesc::InstallMLStubs(Stub *stubEnter, Stub *stubLeave)
{
    if (stubEnter != NULL)
        InstallFirstStub(&m_EnterMLStub, stubEnter);

    ComCallMLStub   *enterHeader, *leaveHeader;

    if (stubLeave != NULL)
        InstallFirstStub(&m_LeaveMLStub, stubLeave);

    // Now that the stubs are installed via a race, grab the headers.
    enterHeader = (m_EnterMLStub
                   ? (ComCallMLStub *) m_EnterMLStub->GetEntryPoint()
                   : 0);

    leaveHeader = (m_LeaveMLStub
                   ? (ComCallMLStub *) m_LeaveMLStub->GetEntryPoint()
                   : 0);

    if (enterHeader == NULL)
    {
        if (leaveHeader == NULL)
        {
            m_HeaderToUse.m_flags |= enum_CMLF_Simple;
            return;
        }
        else
            m_HeaderToUse = *leaveHeader;
    }
    else
        m_HeaderToUse = *enterHeader;

    // Precompute some stuff that's too expensive to do at call time:
    m_BufferSize = (m_HeaderToUse.m_cbDstBuffer +
                    m_HeaderToUse.m_cbLocals +
                    m_HeaderToUse.m_cbHandles +
                    (NUM_ARGUMENT_REGISTERS * STACK_ELEM_SIZE));
}

// attempt to get the native arg size. Since this is called on
// a failure path after we've failed to turn the metadata into
// an MLStub, the chances of success are low.
DWORD ComCallMethodDesc::GuessNativeArgSizeForFailReturn()
{
    DWORD ans = 0;

    COMPLUS_TRY 
    {
        ans = GetNativeArgSize();
    }
    COMPLUS_CATCH
    {
        // 
        ans = 0;
    } 
    COMPLUS_END_CATCH
    return ans;

}

// returns the size of the native argument list. 
DWORD ComCallMethodDesc::GetNativeArgSize()
{
    if (m_StackBytes)
        return m_StackBytes;

    BOOL                res = FALSE;
    
    if (IsFieldCall())
    {
        FieldDesc          *pFD = GetFieldDesc();

        _ASSERTE(pFD != NULL);

        BOOL                IsGetter = IsFieldGetter();
        CorElementType      cetype = pFD->GetFieldType();
        mdFieldDef          fieldDef = pFD->GetMemberDef();
        Module *            pModule = pFD->GetModule();

        // @todo: need to figure out if we can get this from the metadata,
        // or if it even makes sense to support a value of FALSE here.
        BOOL                fReturnsHR = TRUE; 
        
        PCCOR_SIGNATURE     pSig;
        DWORD               cSig;
        pFD->GetSig(&pSig, &cSig);
        FieldSig fsig(pSig, pModule);

        SigPointer sig = fsig.GetProps();

        // Look up the best fit mapping info via Assembly & Interface level attributes
        BOOL BestFit = TRUE;
        BOOL ThrowOnUnmappableChar = FALSE;
        MethodTable* pMT = pFD->GetMethodTableOfEnclosingClass();
        ReadBestFitCustomAttribute(pMT->GetClass()->GetMDImport(), pMT->GetClass()->GetCl(), &BestFit, &ThrowOnUnmappableChar);
    
        MarshalInfo info(pModule, pSig, fieldDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
            ,NULL
#endif
            );

        if (IsGetter)
            info.GenerateGetterML(NULL, NULL, fReturnsHR);
        else
            info.GenerateSetterML(NULL, NULL);

        UINT16 nativeArgSize = sizeof(void*) + info.GetNativeArgSize();
        return nativeArgSize;
    } 

    MethodDesc *pMD = GetInterfaceMethodDesc();
    if (pMD == NULL)
        pMD = GetMethodDesc();

    _ASSERTE(pMD != NULL);

    PCCOR_SIGNATURE     pSig;
    DWORD               cSig;
    pMD->GetSig(&pSig, &cSig);
    IMDInternalImport *pInternalImport = pMD->GetMDImport();
    mdMethodDef md = pMD->GetMemberDef();

    ULONG ulCodeRVA;
    DWORD dwImplFlags;
    pInternalImport->GetMethodImplProps(md, &ulCodeRVA, &dwImplFlags);

	// Determine if we need to do HRESULT munging for this method.
    BOOL fReturnsHR = !IsMiPreserveSig(dwImplFlags);

    HENUMInternal hEnumParams, *phEnumParams;
    HRESULT hr = pInternalImport->EnumInit(mdtParamDef, 
                                            md, &hEnumParams);
    if (FAILED(hr))
        phEnumParams = NULL;
    else
        phEnumParams = &hEnumParams;

    CorElementType  mtype;
    MetaSig         msig(pSig, pMD->GetModule());

#ifdef _DEBUG
    LPCUTF8         szDebugName = pMD->m_pszDebugMethodName;
    LPCUTF8         szDebugClassName = pMD->m_pszDebugClassName;
#endif

    UINT16 nativeArgSize = sizeof(void*);

    mdParamDef      returnParamDef = mdParamDefNil;

    USHORT usSequence;
    mdParamDef paramDef = mdParamDefNil;

    if (phEnumParams && pInternalImport->EnumNext(phEnumParams, &paramDef))
    {
        DWORD dwAttr;
        LPCSTR szName;
        szName = pInternalImport->GetParamDefProps(paramDef, &usSequence, &dwAttr);
        if (usSequence == 0)
        {
            // The first parameter, if has sequence 0, actually describes the return type.
            returnParamDef = paramDef;
            // get the next one so are ready for loop below
            if (! pInternalImport->EnumNext(phEnumParams, &paramDef))
                paramDef = mdParamDefNil;
        }
    }

    // Look up the best fit mapping info via Assembly & Interface level attributes
    BOOL BestFit = TRUE;
    BOOL ThrowOnUnmappableChar = FALSE;
    ReadBestFitCustomAttribute(pMD, &BestFit, &ThrowOnUnmappableChar);

    DWORD iArg = 1;
    while (ELEMENT_TYPE_END != (mtype = msig.NextArg()))
    {
        _ASSERTE(paramDef != mdParamDefNil && "There are less parameter information tokens then there are COM+ arguments" );

        MarshalInfo info(pMD->GetModule(), msig.GetArgProps(), paramDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 
                         0, TRUE, iArg, BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                         ,pMD
#endif
#ifdef _DEBUG
                         ,szDebugClassName, szDebugName, NULL, iArg
#endif
            );
        info.GenerateArgumentML(NULL, NULL, FALSE);
        nativeArgSize += info.GetNativeArgSize();
        if (! pInternalImport->EnumNext(phEnumParams, &paramDef))
            paramDef = mdParamDefNil;
        ++iArg;
    }
    _ASSERTE((paramDef == mdParamDefNil) && "There are more parameter information tokens then there are COM+ arguments" );

    // now calculate return val size. returnParmDef could be nil in which case will use default
    // size. Otherwise will use the def with sequence 0 pulled out of the enum above 
    if (msig.GetReturnType() != ELEMENT_TYPE_VOID) {
        SigPointer returnSig = msig.GetReturnProps();
        MarshalInfo info(pMD->GetModule(), returnSig, returnParamDef, MarshalInfo::MARSHAL_SCENARIO_COMINTEROP, 0, 0, FALSE, 0,
                         BestFit, ThrowOnUnmappableChar
#ifdef CUSTOMER_CHECKED_BUILD
                         ,pMD
#endif
#ifdef _DEBUG
                        ,szDebugName, szDebugClassName, NULL, 0
#endif
        );
        info.GenerateReturnML(NULL, NULL, FALSE, fReturnsHR);
        nativeArgSize += info.GetNativeArgSize();
    }
    m_StackBytes = nativeArgSize;
    return nativeArgSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// COMCALL.H -
//
//

#ifndef __COMCALL_H__
#define __COMCALL_H__

#include "util.hpp"
#include "ml.h"
#include "SpinLock.h"
#include "mlcache.h"

struct ComCallMLStub;
class  ComCallMLStubCache;
class ComCallWrapperCache;



// @TODO cwb:
//
// I've left one thing here in a horrendous state.  The factoring of state between
// the ComCallMethodDesc and the various stubs is not correct.  Also, we have far
// too many stubs in the method desc.  We really only need 1 enter stub and 1 leave
// stub.  Then we should use some bits to tell us what kind each one is.
//
// In order to avoid having to reconstruct all this from the bits, we should then
// have enough different stubs and workers that each one is tuned to the different
// configurations (e.g. RunML for Enter and call compiled for Leave).


//=======================================================================
// class com call
//=======================================================================
class ComCall
{
public:
    //---------------------------------------------------------
    // One-time init
    //---------------------------------------------------------
    static BOOL Init();

    //---------------------------------------------------------
    // One-time cleanup
    //---------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
    static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

    // helper to create a generic stub for com calls
    static Stub* CreateGenericComCallStub(StubLinker *pstublinker, BOOL isFieldAccess,
                                          BOOL isSimple);

    // either creates or retrieves from the cache, a stub for field access
    // from com to com+
    static Stub* GetFieldCallMethodStub(StubLinker *pstublinker, ComCallMethodDesc *pMD);

    //---------------------------------------------------------
    // Either creates or retrieves from the cache, a stub to
    // invoke com to com+
    // Each call refcounts the returned stub.
    // This routines throws a COM+ exception rather than returning
    // NULL.
    //---------------------------------------------------------
    static Stub* GetComCallMethodStub(StubLinker *psl, ComCallMethodDesc *pMD);

    //---------------------------------------------------------
    // Call at strategic times to discard unused stubs.
    //---------------------------------------------------------
    static VOID  FreeUnusedStubs();

    // Compile a snippet of ML, from an ML stub, into native code.
    static BOOL  CompileSnippet(const ComCallMLStub *header, CPUSTUBLINKER *psl,
                                void *state);
    
    // Generic helper that wraps an ML-based helper.  It conforms to the highly
    // customized register calling convention that exists between the ComCall stub
    // and its helpers, then forwards the call to RunML.
    static INT64 GenericHelperEnter();
    static INT64 GenericHelperLeave();

    static void  DiscardStub(ComCallMethodDesc *pCMD);

    //---------------------------------------------------------
    // On class unload
    //---------------------------------------------------------
    static VOID UnloadStub(DWORD nativeArgSize, BOOL fPopRet, SLOT *pVtableEntryAddr);

    //---------------------------------------------------------
    // On class unload
    //---------------------------------------------------------
    static VOID DiscardUnloadedStub(SLOT pVtableEntryAddr);


#ifdef _DEBUG
    // Is this one of the generic ComCall stubs?
    static BOOL  dbg_StubIsGenericComCallStub(Stub *candidate);
#endif

    static void LOCK()
	{
		m_lock.GetLock();
	}
    static void UNLOCK()
	{
		m_lock.FreeLock();
	}

private:
    ComCall() {};     // prevent "new"'s on this class

    static SpinLock m_lock;

};




//=======================================================================
// The ML stub for ComCall begins with this header. Immediately following
// this header are the ML codes for marshaling the arguments, terminated
// by ML_INTERRUPT. Immediately following that are the ML codes for
// marshaling the return value, terminated by ML_END.
//=======================================================================

enum ComCallMLFlags
{
    enum_CMLF_IsHR           = 0x001, // If true the com function returns a HR
    enum_CMLF_VOIDRETVAL     = 0x002, // com+ sig return type is void
    enum_CMLF_R4RETVAL       = 0x004, // com+ sig return type is a float
    enum_CMLF_R8RETVAL       = 0x008, // com+ sig return type is double
    enum_CMLF_ISGCPROTECTREQ = 0x010, // if TRUE, then the arg list contains objects (other than 'this')
    enum_CMLF_Enregistered   = 0x020, // we enregistered args
    enum_CMLF_IsFieldCall    = 0x040, // is field call
    enum_CMLF_IsGetter       = 0x080, // is field call getter
    enum_CMLF_Simple         = 0x100, // Use SimpleWorker
	enum_CMLF_8RETVAL		 = 0x200, // 8 byte return value
	enum_CMLF_RetValNeedsGCProtect = 0x400 // return value need to be GC-protected
};

#pragma pack(push)
#pragma pack(1)

// *** WARNING ***
// This structure overlays the m_fGCEnabled field of a
// UnmanagedToManagedCallFrame::NegInfo structure on the frame. Add fields at
// your peril.
// *** WARNING ***
struct ComCallGCInfo
{
    INTPTR      m_fArgsGCProtect;   // Bit 0 for args, bit 1 for return value
    //@todo add more info
};

struct ComCallMLStub
{
    UINT16        m_cbDstBuffer;  //# of bytes required in the destination buffer
    UINT16        m_cbLocals;     //# of bytes required in the local array
    UINT16        m_cbHandles;    // # of handles required
    UINT16        m_flags;        //flags (see above ComCallFlags enum values)

    void Init()
    {
        m_cbDstBuffer = 0;
        m_cbLocals    = 0;
        m_flags = 0;
        m_cbHandles = 0;
    }

    
#ifdef _DEBUG
    BOOL ValidateML()
    {
        MLSummary summary;
        summary.ComputeMLSummary(GetMLCode());
        _ASSERTE(summary.m_cbTotalHandles == m_cbHandles);
        _ASSERTE(summary.m_cbTotalLocals == m_cbLocals);
        return TRUE;
    }
#endif

    const MLCode *GetMLCode() const
    {
        return (const MLCode *)(this+1);
    }

    BOOL IsFieldCall()
    {
        return m_flags & enum_CMLF_IsFieldCall;
    }

    void SetFieldCall()
    {
        m_flags |= enum_CMLF_IsFieldCall;
    }

    void SetGetter()
    {
        m_flags |= enum_CMLF_IsGetter;
    }

    BOOL IsGetter()
    {
        _ASSERTE(IsFieldCall());
        return m_flags & enum_CMLF_IsGetter;
    }

    BOOL IsReturnsHR()
    {
        return m_flags & enum_CMLF_IsHR;
    }

    void SetReturnsHR()
    {
        m_flags |= enum_CMLF_IsHR;
    }

    BOOL IsVoidRetVal()
    {
        return m_flags & enum_CMLF_VOIDRETVAL;
    }

    void SetVoidRetVal()
    {
        m_flags |= enum_CMLF_VOIDRETVAL;
    }

    BOOL Is8RetVal()
    {
        return (m_flags & enum_CMLF_8RETVAL) != 0;
    }

    void Set8RetVal()
    {
        m_flags |= enum_CMLF_8RETVAL;
    }

    BOOL UsesHandles()
    {
        return m_cbHandles > 0;
    }

    unsigned GetHandleCount()
    {
        _ASSERTE(ValidateML());
        return m_cbHandles;
    }

    void SetHandleCount(unsigned cbHandles)
    {
        m_cbHandles = cbHandles;
    }

    BOOL IsArgsGCProtReq()
    {
        _ASSERTE(ValidateML());
        return m_flags & enum_CMLF_ISGCPROTECTREQ;
    }

    void SetArgsGCProtReq()
    {
        m_flags |= enum_CMLF_ISGCPROTECTREQ;
    }

    void SetEnregistered()
    {
        m_flags |= enum_CMLF_Enregistered;
    }

    BOOL IsEnregistered()
    {
        return m_flags & enum_CMLF_Enregistered;
    }

    BOOL IsR4RetVal()
    {
        return m_flags & enum_CMLF_R4RETVAL;
    }
    
    BOOL IsR8RetVal()
    {
        return m_flags & enum_CMLF_R8RETVAL;
    }

    void SetR4RetVal()
    {
        m_flags |= enum_CMLF_R4RETVAL;
    }

    void SetR8RetVal()
    {
        m_flags |= enum_CMLF_R8RETVAL;
    }

    BOOL RetValToOutParam()
    {
        return ((m_flags & (enum_CMLF_IsHR | enum_CMLF_VOIDRETVAL)) == enum_CMLF_IsHR);
    }

	BOOL SetRetValNeedsGCProtect()
    {
        return m_flags |= enum_CMLF_RetValNeedsGCProtect;
    }

	BOOL IsRetValNeedsGCProtect()
    {
        return m_flags & enum_CMLF_RetValNeedsGCProtect;
    }
};

#pragma pack(pop)

//helpers
inline void EnableArgsGCProtection(ComCallGCInfo* pInfo)
{
    pInfo->m_fArgsGCProtect |= 1;
}

inline void DisableArgsGCProtection(ComCallGCInfo* pInfo)
{
    pInfo->m_fArgsGCProtect &= ~1;
}

inline INTPTR IsArgsGCProtectionEnabled(ComCallGCInfo* pInfo)
{
    return pInfo->m_fArgsGCProtect & 1;
}

//helpers
inline void EnableRetGCProtection(ComCallGCInfo* pInfo)
{
    pInfo->m_fArgsGCProtect |= 2;
}

inline void DisableRetGCProtection(ComCallGCInfo* pInfo)
{
    pInfo->m_fArgsGCProtect &= ~2;
}

inline INTPTR IsRetGCProtectionEnabled(ComCallGCInfo* pInfo)
{
    return pInfo->m_fArgsGCProtect & 2;
}

enum ComCallFlags
{
        enum_IsVirtual      = 0x1,      // If true the method is virtual on the managed side
        enum_IsFieldCall    = 0x2,      // is field call
        enum_IsGetter       = 0x4       // is field call getter
};


//-----------------------------------------------------------------------
// Operations specific to ComCall methods. We use a derived class to get
// the compiler involved in enforcing proper method type usage.
//-----------------------------------------------------------------------
typedef INT64 (*COMCALL_HELPER) ();
struct ComCallMLStub;


class ComCallMethodDesc 
{
    DWORD   m_flags; // see ComCallFlags enum above
    union
    {
		struct 
		{
			MethodDesc* m_pMD;
			MethodDesc* m_pInterfaceMD;
		};
        FieldDesc*  m_pFD;
    };

	struct 
	{
		// We have 5 stubs.  These are the ML and (possibly) compiled versions of the
		// snippet for entering the call and the snippet for unwinding the call.
		// Finally, we have the stub that wraps everything up.  For now, we don't
		// need to track that outer stub.

		Stub   *m_EnterMLStub;
		Stub   *m_LeaveMLStub;
		Stub   *m_EnterExecuteStub;
		Stub   *m_LeaveExecuteStub;
	};

    // Precompute the buffer size to save us a little time during calls.
    UINT16  m_BufferSize;
    UINT16  m_StackBytes;

public:

    // We might have either an Enter and a Leave stub, either or none.  Furthermore,
    // the canonicalization process will replace the enter and leave stubs with
    // equivalent versions, independently.  We can increase the level of sharing
    // by hoisting the header out, so that e.g. the return value processing is
    // independent of the buffer shape.  This should be a big win.
    ComCallMLStub    m_HeaderToUse;

    // The helpers that we call from the generic stub. These helpers are used to
    // parameterize the behavior of the generic stub's call processing.
    COMCALL_HELPER  m_EnterHelper;
    COMCALL_HELPER  m_LeaveHelper;

    // init method
    void InitMethod(MethodDesc *pMD, MethodDesc *pInterfaceMD)
    {
        _ASSERTE(pMD != NULL);
        m_flags = pMD->IsVirtual() ? enum_IsVirtual : 0;

        m_pMD = pMD;
		m_pInterfaceMD = pInterfaceMD;

        m_EnterMLStub =
        m_LeaveMLStub =
        m_EnterExecuteStub =
        m_LeaveExecuteStub = 0;

        m_EnterHelper = m_LeaveHelper = 0;
        m_BufferSize = 0;
        m_StackBytes = 0;
    }

    // init field
    void InitField(FieldDesc* pField, BOOL isGetter )
    {
        _ASSERTE(pField != NULL);
        m_pFD = pField;
        m_flags = enum_IsFieldCall; // mark the attribute as a field
        if (isGetter)
            m_flags|= enum_IsGetter;
    };

    // is field call
    BOOL IsFieldCall()
    {
        return (m_flags & enum_IsFieldCall);
    }

    BOOL IsMethodCall()
    {
        return !IsFieldCall();
    }

    // is field getter
    BOOL IsFieldGetter()
    {
        _ASSERTE(m_flags & enum_IsFieldCall);
        return (m_flags  & enum_IsGetter);
    }

    // is a virtual method
    BOOL IsVirtual()
    {
        _ASSERTE(IsMethodCall());
        return (m_flags  & enum_IsVirtual);
    }

    //get method desc
    MethodDesc* GetMethodDesc()
    {
        _ASSERTE(!IsFieldCall());
        _ASSERTE(m_pMD != NULL);
        return m_pMD;
    }

    //get interface method desc
    MethodDesc* GetInterfaceMethodDesc()
    {
        _ASSERTE(!IsFieldCall());
        return m_pInterfaceMD;
    }

    // get field desc
    FieldDesc* GetFieldDesc()
    {
        _ASSERTE(IsFieldCall());
        _ASSERTE(m_pFD != NULL);
        return m_pFD;
    }

    // get module
    Module* GetModule();

    // interlocked replace stub
    void InstallFirstStub(Stub** ppStub, Stub *pNewStub);

    // Accessors for our stubs.  These are the ML and entrypoint versions
    // of the snippet for entering the call and the snippet for unwinding the call.
    //
    // There are no SetStub() variants, since these must be performed atomically.
    // This is the case even if we are using the stub cache, to avoid messing up
    // the reference counts.
    Stub   *GetEnterMLStub()
    {
        return m_EnterMLStub;
    }
    Stub   *GetLeaveMLStub()
    {
        return m_LeaveMLStub;
    }
    Stub   *GetEnterExecuteStub()
    {
        return m_EnterExecuteStub;
    }
    Stub   *GetLeaveExecuteStub()
    {
        return m_LeaveExecuteStub;
    }

    UINT32 GetBufferSize()
    {
        return m_BufferSize;
    }

    // get slot number for the method
    unsigned GetSlot()
    {
        _ASSERTE(IsMethodCall());
        _ASSERTE(m_pMD != NULL);
        return m_pMD->GetSlot();
    }

    // get num stack bytes to pop
    unsigned GetNumStackBytes() 
	{ 
		return m_StackBytes; 
	}

	void SetNumStackBytes(unsigned b) 
	{ 
		m_StackBytes = b; 
	}

    static DWORD GetOffsetOfReturnThunk()
    {
        return -METHOD_PREPAD;
    }

    static DWORD GetOffsetOfMethodDesc()
    {
        return ((DWORD) offsetof(class ComCallMethodDesc, m_pMD));
    }

    static DWORD GetOffsetOfInterfaceMethodDesc()
    {
        return ((DWORD) offsetof(class ComCallMethodDesc, m_pInterfaceMD));
    }

    //get call sig
    PCCOR_SIGNATURE GetSig()
    {
        _ASSERTE(IsMethodCall());
        _ASSERTE(m_pMD != NULL);
        return m_pMD->GetSig();
    }

    // Atomically install both the ML stubs into the ComCallMethodDesc.  
	// Either stub may be NULL if it's a noop.
    void InstallMLStubs(Stub *stubEnter, Stub *stubLeave);

    // Atomically install both the Entrypoint stubs into the ComCallMethodDesc.  (The
    // leave stub may be NULL if this is a field accessor.  Either may be NULL if
    // we couldn't find any interesting content.  Indeed, InstallMLStubs above was
    // responsible for discarding stubs if that was the case.).
    void InstallExecuteStubs(Stub *stubEnter, Stub *stubLeave)
    {
        if (stubEnter)
            InstallFirstStub(&m_EnterExecuteStub, stubEnter);

        if (stubLeave)
            InstallFirstStub(&m_LeaveExecuteStub, stubLeave);
    }

    // returns the size of the native argument list
    DWORD GetNativeArgSize();


    // attempt to get the native arg size. Since this is called on
    // a failure path after we've failed to turn the metadata into
    // an MLStub, the chances of success are low.
    DWORD GuessNativeArgSizeForFailReturn();
};


class ComCallMLStubCache : public MLStubCache
{
public:
    // This is a more specialized version of the base MLStubCache::Canonicalize().
    // It understands that we actually compile 2 snippets.
    void  Canonicalize(ComCallMethodDesc *pCMD);

private:
    //---------------------------------------------------------
    // Compile a native (ASM) version of the ML stub.
    //
    // This method should compile into the provided stublinker (but
    // not call the Link method.)
    //
    // It should return the chosen compilation mode.
    //
    // If the method fails for some reason, it should return
    // INTERPRETED so that the EE can fall back on the already
    // created ML code.
    //---------------------------------------------------------
    virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                           StubLinker *pstublinker, void *callerContext);

    //---------------------------------------------------------
    // Tells the MLStubCache the length of an ML stub.
    //---------------------------------------------------------
    virtual UINT Length(const BYTE *pRawMLStub)
    {
        ComCallMLStub *pmlstub = (ComCallMLStub *)pRawMLStub;
        return sizeof(ComCallMLStub) + MLStreamLength(pmlstub->GetMLCode());
    }
};



#endif // __COMCALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcallwrapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Com Callable wrapper  classes
**
**      //  %%Created by: rajak
===========================================================*/

#ifndef _COMCALLWRAPPER_H
#define _COMCALLWRAPPER_H

#include "vars.hpp"
#include "stdinterfaces.h"
#include "threads.h"
#include "objecthandle.h"
#include "comutilnative.h"
#include "spinlock.h"
#include "comcall.h"
#include "dispatchinfo.h"

class CCacheLineAllocator;
class ConnectionPoint;

class ComCallWrapperCache
{
    enum {
        AD_IS_UNLOADING = 0x01,
    };

    LONG    m_cbRef;
    CCacheLineAllocator *m_pCacheLineAllocator;
    AppDomain *m_pDomain;
    LONG    m_dependencyCount;

public:
    ComCallWrapperCache();
    ~ComCallWrapperCache();

    // spin lock for fast synchronization
    SpinLock        m_lock;

    // create a new WrapperCache (one per domain)
    static ComCallWrapperCache *Create(AppDomain *pDomain);
    // cleanup this cache
    void Terminate();

    // refcount
    LONG    AddRef();
    LONG    Release();

    // lock
    void LOCK()
    {
        m_lock.GetLock();
    }
    void UNLOCK()
    {
        m_lock.FreeLock();
    }

    bool CanShutDown()
    {
        return m_cbRef == 1;
    }

    CCacheLineAllocator *GetCacheLineAllocator()
    {
        return m_pCacheLineAllocator;
    }

    AppDomain *GetDomain()
    {
        return (AppDomain*)((size_t)m_pDomain & ~AD_IS_UNLOADING);
    }

    void ClearDomain()
    {
        m_pDomain = (AppDomain *)AD_IS_UNLOADING;
    }

    void SetDomainIsUnloading()
    {
        m_pDomain = (AppDomain*)((size_t)m_pDomain | AD_IS_UNLOADING);
    }

    BOOL IsDomainUnloading()
    {
        return ((size_t)m_pDomain & AD_IS_UNLOADING) != 0;
    }

 };

//---------------------------------------------------------------------------------
// COM called wrappers on COM+ objects
//  Purpose: Expose COM+ objects as COM classic Interfaces
//  Reqmts:  Wrapper has to have the same layout as the COM2 interface
//
//  The wrapper objects are aligned at 16 bytes, and the original this
//  pointer is replicated every 16 bytes, so for any COM2 interface
//  within the wrapper, the original 'this' can be obtained by masking
//  low 4 bits of COM2 IP.
//
//           16 byte aligned                            COM2 Vtable
//           +-----------+
//           | Org. this |
//           +-----------+                              +-----+
// COM2 IP-->| VTable ptr|----------------------------->|slot1|
//           +-----------+           +-----+            +-----+
// COM2 IP-->| VTable ptr|---------->|slot1|            |slot2|
//           +-----------+           +-----+            +     +
//           | VTable ptr|           | ....|            | ... |
//           +-----------+           +     +            +     +
//           | Org. this |           |slotN|            |slotN|
//           +           +           +-----+            +-----+
//           |  ....     |
//           +           +
//           |  |
//           +-----------+
//
//
//  VTable and Stubs: can share stub code, we need to have different vtables
//                    for different interfaces, so the stub can jump to different
//                    marshalling code.
//  Stubs : adjust this pointer and jump to the approp. address,
//  Marshalling params and results, based on the method signature the stub jumps to
//  approp. code to handle marshalling and unmarshalling.
//
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Header on top of Vtables that we create for COM callable interfaces
//--------------------------------------------------------------------------------
#pragma pack(push)
#pragma pack(1)

struct IUnkVtable
{
    SLOT          m_qi; // IUnk::QI
    SLOT          m_addref; // IUnk::AddRef
    SLOT          m_release; // IUnk::Release
};

struct IDispatchVtable : IUnkVtable
{
    // idispatch methods
    SLOT        m_GetTypeInfoCount;
    SLOT        m_GetTypeInfo;
    SLOT        m_GetIDsOfNames;
    SLOT        m_Invoke;
};

enum Masks
{
    enum_InterfaceTypeMask      = 0x3,
    enum_ClassInterfaceTypeMask = 0x3,
    enum_ClassVtableMask        = 0x4,
    enum_UseOleAutDispatchImpl  = 0x8,
    enum_LayoutComplete         = 0x10,
    enum_ComVisible             = 0x40,
    enum_SigClassCannotLoad     = 0x80,
    enum_SigClassLoadChecked    = 0x100,
    enum_ComClassItf            = 0x200
};

struct ComMethodTable
{
    SLOT             m_ptReserved; //= (SLOT) 0xDEADC0FF;  reserved
    MethodTable*     m_pMT; // pointer to the VMs method table
    ULONG            m_cbSlots; // number of slots in the interface (excluding IUnk/IDisp)
    ULONG            m_cbRefCount; // ref-count the vtable as it is being shared
    size_t           m_Flags; // make sure this is initialized to zero
    LPVOID           m_pMDescr; // pointer to methoddescr.s owned by this MT
    ITypeInfo*       m_pITypeInfo; // cached pointer to ITypeInfo
    DispatchInfo*    m_pDispatchInfo; // The dispatch info used to expose IDispatch to COM.
    IID              m_IID; // The IID of the interface.

    // Cleanup, frees all the stubs and the vtable
    void Cleanup();

    // The appropriate finalize method must be called before the COM method table is
    // exposed to COM or before any methods are called on it.
    BOOL LayOutClassMethodTable();
    BOOL LayOutInterfaceMethodTable(MethodTable* pClsMT, unsigned iMapIndex);

    // Accessor for the IDispatch information.
    DispatchInfo *GetDispatchInfo();

    LONG AddRef()
    {
        return ++m_cbRefCount;
    }

    LONG            Release()
    {
        _ASSERTE(m_cbRefCount > 0);
        // use a different var here becuase cleanup will delete the object
        // so can no longer make member refs
        LONG cbRef = --m_cbRefCount;
        if (cbRef == 0)
            Cleanup();
        return cbRef;
    }

    CorIfaceAttr GetInterfaceType()
    {
        if (IsClassVtable())
            return ifDual;
        else
            return (CorIfaceAttr)(m_Flags & enum_InterfaceTypeMask);
    }

    CorClassIfaceAttr GetClassInterfaceType()
    {
        _ASSERTE(IsClassVtable());
        return (CorClassIfaceAttr)(m_Flags & enum_ClassInterfaceTypeMask);
    }

    BOOL IsClassVtable()
    {
        return (m_Flags & enum_ClassVtableMask) != 0;
    }

    BOOL IsComClassItf()
    {
        return (m_Flags & enum_ComClassItf) != 0;        
    }

    BOOL IsUseOleAutDispatchImpl()
    {
        // This should only be called on the class VTable.
        _ASSERTE(IsClassVtable());
        return (m_Flags & enum_UseOleAutDispatchImpl) != 0;
    }

    BOOL IsLayoutComplete()
    {
        return (m_Flags & enum_LayoutComplete) != 0;
    }

    BOOL IsComVisible()
    {
        return (m_Flags & enum_ComVisible) != 0;
    }

    BOOL IsSigClassLoadChecked()
    {
        return (m_Flags & enum_SigClassLoadChecked) != 0;
    }

    BOOL IsSigClassCannotLoad()
    {
        return (m_Flags & enum_SigClassCannotLoad) != 0;
    }

    VOID SetSigClassCannotLoad()
    {
        m_Flags |= enum_SigClassCannotLoad;
    }

    VOID SetSigClassLoadChecked()
    {
        m_Flags |= enum_SigClassLoadChecked;
    }

    DWORD GetSlots()
    {
        return m_cbSlots;
    }

    ITypeInfo*  GetITypeInfo()
    {
        return m_pITypeInfo;
    }

    void SetITypeInfo(ITypeInfo *pITI);

    static int GetNumExtraSlots(CorIfaceAttr ItfType)
    {
        return ItfType == ifVtable ? 3 : 7;
    }

    BOOL IsSlotAField(unsigned i)
    {
        _ASSERTE(IsLayoutComplete());
        _ASSERTE( i < m_cbSlots);

        i += (GetInterfaceType() == ifVtable) ? 3 : 7;
        SLOT* rgVtable = (SLOT*)((ComMethodTable *)this+1);
        ComCallMethodDesc* pCMD = (ComCallMethodDesc *)(((BYTE *)rgVtable[i])+METHOD_CALL_PRESTUB_SIZE);
        return pCMD->IsFieldCall();
    }

    MethodDesc* GetMethodDescForSlot(unsigned i)
    {
        _ASSERTE(IsLayoutComplete());
        _ASSERTE(i < m_cbSlots);
        _ASSERTE(!IsSlotAField(i));

        i += (GetInterfaceType() == ifVtable) ? 3 : 7;
        SLOT* rgVtable = (SLOT*)((ComMethodTable *)this+1);
        ComCallMethodDesc* pCMD = (ComCallMethodDesc *)(((BYTE *)rgVtable[i])+METHOD_CALL_PRESTUB_SIZE);
        _ASSERTE(pCMD->IsMethodCall());
        return pCMD->GetMethodDesc();
    }

    ComCallMethodDesc* GetFieldCallMethodDescForSlot(unsigned i)
    {
        _ASSERTE(IsLayoutComplete());
        _ASSERTE(i < m_cbSlots);
        _ASSERTE(IsSlotAField(i));

        i += (GetInterfaceType() == ifVtable) ? 3 : 7;
        SLOT* rgVtable = (SLOT*)((ComMethodTable *)this+1);
        ComCallMethodDesc* pCMD = (ComCallMethodDesc *)(((BYTE *)rgVtable[i])+METHOD_CALL_PRESTUB_SIZE);
        _ASSERTE(pCMD->IsFieldCall());
        return (ComCallMethodDesc *)pCMD;
    }

    BOOL OwnedbyThisMT(ComCallMethodDesc* pCMD)
    {
        _ASSERTE(pCMD != NULL);
        if (!IsClassVtable())
            return TRUE;
        if (m_pMDescr != NULL)
        {
            ULONG cbSize = *(ULONG *)m_pMDescr;
            return (
                ((SLOT)pCMD >= (SLOT)m_pMDescr) &&
                ((SLOT)pCMD <= ((SLOT)m_pMDescr+cbSize))
                );
        }
        return FALSE;
    }

    ComMethodTable *GetParentComMT();

    static inline ComMethodTable* ComMethodTableFromIP(IUnknown* pUnk)
    {
        _ASSERTE(pUnk != NULL);

        ComMethodTable* pMT = (*(ComMethodTable**)pUnk) - 1;
        // validate the object
        _ASSERTE((SLOT)(size_t)0xDEADC0FF == pMT->m_ptReserved );

        return pMT;
    }
};

#pragma pack(pop)


//--------------------------------------------------------------------------------
// COM callable wrappers for COM+ objects
//--------------------------------------------------------------------------------
class MethodTable;
class ComCallWrapper;

class ComCallWrapperTemplate
{
protected:
    // Release all vtables
    static void ReleaseAllVtables(ComCallWrapperTemplate* pTemplate);

    // helpers
    static ComCallWrapperTemplate* CreateTemplate(MethodTable* pMT);

    // Create a non laid out COM method table for the specified class or interface.
    static ComMethodTable* CreateComMethodTableForClass(MethodTable *pClassMT);
    static ComMethodTable* CreateComMethodTableForInterface(MethodTable* pInterfaceMT);

    // protected constructor
    ComCallWrapperTemplate()
    {
        // protected constructor, don't instantiate me directly
    }

    ComMethodTable*             m_pClassComMT;

public:

    ULONG                       m_cbInterfaces;
    LONG                       m_cbRefCount;
    ComCallWrapperTemplate*     m_pParent;
    MethodTable*                m_pMT;
    SLOT*                       m_rgpIPtr[1];

    static BOOL Init();
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    // Ref-count the templates
    LONG         AddRef()
    {
        return InterlockedIncrement(&m_cbRefCount);
    }

    LONG         Release()
    {
        _ASSERTE(m_cbRefCount > 0);
        // use a different var here becuase cleanup will delete the object
        // so can no longer make member refs
        LONG cbRef = InterlockedDecrement(&m_cbRefCount);
        if (cbRef == 0)
        {
            ReleaseAllVtables(this);
        }
        return cbRef;
    }

    ComMethodTable* GetClassComMT()
    {
        return m_pClassComMT;
    }

    ComMethodTable* GetComMTForItf(MethodTable *pItfMT);

    SLOT* GetClassVtable()
    {
        return (SLOT*)((ComMethodTable *)m_pClassComMT + 1);
    }

    // template accessor, creates a template if one is not available
    static ComCallWrapperTemplate* GetTemplate(MethodTable* pMT);

    // this method sets up the class method table for the IClassX and also lays it out.
    static ComMethodTable *SetupComMethodTableForClass(MethodTable *pMT, BOOL bLayOutComMT);

    // helper to cleanup stubs and vtable
    static void CleanupComData(LPVOID pWrap);
};

// forward
struct SimpleComCallWrapper;
struct ComPlusWrapper;

class ComCallWrapper
{
public:

    enum
    {
        NumVtablePtrs = 6,
        //@todo fix this
        enum_ThisMask = ~0x1f, // mask on IUnknown ** to get at the OBJECT-REF handle
#ifdef _WIN64
        enum_RefMask = 0xC000000000000000,
#else // !_WIN64
        enum_RefMask = 0xC0000000, // mask to examine whether the ref-count part is a link
                                   // to the next block or a ref count. High 2 bits mean ref count.
#endif // _WIN64
    };

    // every block contains a pointer to the OBJECTREF
    // that has been registered with the GC
    OBJECTHANDLE  m_ppThis; // pointer to OBJECTREF

    AppDomain *GetDomainSynchronized();
    BOOL NeedToSwitchDomains(Thread *pThread, BOOL throwIfUnloaded);
    BOOL IsUnloaded();
    void MakeAgile(OBJECTREF pObj);
    void CheckMakeAgile(OBJECTREF pObj);

    VOID ResetHandleStrength();
    VOID MarkHandleWeak();

    VOID ReconnectWrapper()
    {
        _ASSERTE(! IsUnloaded());
        SyncBlock* pSyncBlock = GetSyncBlock();
        _ASSERTE(pSyncBlock);
        // NULL out the object in our handle
        StoreObjectInHandle(m_ppThis, NULL);
        // remove the _comData from syncBlock
        pSyncBlock->SetComCallWrapper(NULL);
    }

    BOOL IsHandleWeak();

    ComCallWrapperCache *GetWrapperCache();

    union
    {
        size_t   m_cbLinkedRefCount; // ref-count slot for linked wrappers
        SLOT*    m_rgpIPtr[NumVtablePtrs]; // variable size block of vtable pointers
    };
    union
    {
        ComCallWrapper* m_pNext; // link wrappers
        size_t   m_cbRefCount; // If the entire wrapper fits in a single block,
                               // the link data is used as a ref-count and the high two bits are set
    };

    // Return the context that this wrapper lives in
    Context *GetObjectContext(Thread *pThread);

protected:
    // don't instantiate this class directly
    ComCallWrapper()
    {
    }
    ~ComCallWrapper()
    {
    }
    void Init();

    inline static void SetNext(ComCallWrapper* pWrap, ComCallWrapper* pNextWrapper)
    {
        _ASSERTE(pWrap != NULL);
        pWrap->m_pNext = pNextWrapper;
    }

    inline static ComCallWrapper* GetNext(ComCallWrapper* pWrap)
    {
        _ASSERTE(pWrap != NULL);
        _ASSERTE((pWrap->m_cbRefCount & enum_RefMask) != enum_RefMask); // Make sure this isn't a ref count
        return pWrap->m_pNext;
    }

    // accessor to wrapper object in the sync block
    inline static ComCallWrapper* TryGetWrapperFromSyncBlock(OBJECTREF pObj)
    {
        // get a reference to the pointer to ComCallWrapper within
        // OBJECTREF's sync block
        _ASSERTE(GetThread() == 0 ||
                 dbgOnly_IsSpecialEEThread() ||
                 GetThread()->PreemptiveGCDisabled());
        _ASSERTE (pObj != NULL);

        // the following call could throw an exception
        // if a sycnblock couldn'be allocated
        SyncBlock *pSync = pObj->GetSyncBlock();
        _ASSERTE (pSync != NULL);
        ComCallWrapper* pWrap = (ComCallWrapper*)pSync->GetComCallWrapper();
        return pWrap;
    }

    // walk the list and free all blocks
    static void FreeWrapper(ComCallWrapper* pWrap, ComCallWrapperCache *pWrapperCache);

   // helper to create a wrapper
    static ComCallWrapper* __stdcall CreateWrapper(OBJECTREF* pObj);

    // helper to get the IUnknown* within a wrapper
    static SLOT** GetComIPLocInWrapper(ComCallWrapper* pWrap, unsigned iIndex);

    // helper to get index within the interface map for an interface that matches
    // the guid
    static signed GetIndexForIID(REFIID riid, MethodTable *pMT, MethodTable **ppIntfMT);
    // helper to get index within the interface map for an interface that matches
    // the interface MT
    static signed GetIndexForIntfMT(MethodTable *pMT, MethodTable *pIntfMT);

    // helper to get wrapper from sync block
    static ComCallWrapper* GetStartWrapper(ComCallWrapper* pWrap);

    // heler to create a wrapper from a template
    static ComCallWrapper* CopyFromTemplate(ComCallWrapperTemplate* pTemplate,
                                            ComCallWrapperCache *pWrapperCache,
                                            OBJECTHANDLE oh);

public:

    // helper to determine the app domain of a created object
    static Context* GetExecutionContext(OBJECTREF pObj, OBJECTREF *pServer);

    static BOOL IsWrapperActive(ComCallWrapper* pWrap)
    {
        // Since its called by GCPromote, we assume that this is the start wrapper
        ULONG cbRef = ComCallWrapper::GetRefCount(pWrap, TRUE);
        _ASSERTE(cbRef>=0);
        return ((cbRef > 0) && !pWrap->IsHandleWeak());
    }

    // IsLinkedWrapper
    inline static unsigned IsLinked(ComCallWrapper* pWrap)
    {
        _ASSERTE(pWrap != NULL);
        return unsigned ((pWrap->m_cbRefCount & enum_RefMask) != enum_RefMask);
    }


    // wrapper is guaranteed to be present
    // accessor to wrapper object in the sync block
    inline static ComCallWrapper* GetWrapperForObject(OBJECTREF pObj)
    {
        // get a reference to the pointer to ComCallWrapper within
        // OBJECTREF's sync block
        _ASSERTE(GetThread() == 0 ||
                 dbgOnly_IsSpecialEEThread() ||
                 GetThread()->PreemptiveGCDisabled());
        _ASSERTE (pObj != NULL);

        SyncBlock *pSync = pObj->GetSyncBlockSpecial();
        _ASSERTE (pSync != NULL);
        ComCallWrapper* pWrap = (ComCallWrapper*)pSync->GetComCallWrapper();
        return pWrap;
    }

    // get inner unknown
    HRESULT GetInnerUnknown(void **pv);
    IUnknown* GetInnerUnknown();

    // Init outer unknown
    void InitializeOuter(IUnknown* pOuter);

    // is the object aggregated by a COM component
    BOOL IsAggregated();
    // is the object a transparent proxy
    BOOL IsObjectTP();
    // is the object extends from (aggregates) a COM component
    BOOL IsExtendsCOMObject();
    // get syncblock stored in the simplewrapper
    SyncBlock* GetSyncBlock();
    // get outer unk
    IUnknown* GetOuter();
    // the following 2 methods are applicable only
    // when the com+ class extends from COM class
    // set ComPlusWrapper for base COM class
    void SetComPlusWrapper(ComPlusWrapper* pPlusWrap);
    // get ComPlusWrapper for base COM class
    ComPlusWrapper* GetComPlusWrapper();

    // Get IClassX interface pointer from the wrapper.
    IUnknown* GetIClassXIP();

    // Get the IClassX method table from the wrapper.
    ComMethodTable *GetIClassXComMT();

    // Get the IDispatch interface pointer from the wrapper.
    IDispatch *GetIDispatchIP();

    //Get ObjectRef from wrapper
    inline OBJECTREF GetObjectRef()
    {
#if 0
        Thread *pThread = GetThread();
        _ASSERTE(pThread == 0 || pThread == g_pGCHeap->GetGCThread() || pThread->GetDomain() == GetDomainSynchronized());
#endif
        return GetObjectRefRareRaw();
    }

    // Get ObjectRef from wrapper - this is called by GetObjectRef and GetStartWrapper.
    // Need this becuase GetDomainSynchronized will call GetStartWrapper which will call
    // GetObjectRef which will cause a little bit of nasty infinite recursion.
    inline OBJECTREF GetObjectRefRareRaw()
    {
#ifdef _DEBUG
        Thread *pThread = GetThread();
        // make sure preemptive GC is disabled
        _ASSERTE(pThread == 0 ||
                 dbgOnly_IsSpecialEEThread() ||
                 pThread->PreemptiveGCDisabled());
        _ASSERTE(m_ppThis != NULL);
#endif
        return ObjectFromHandle(m_ppThis);
    }

    // clean up an object wrapper
    static void Cleanup(ComCallWrapper* pWrap);

    // fast access to wrapper for a com+ object,
    // inline check, and call out of line to create, out of line version might cause gc
    //to be enabled
    static ComCallWrapper* __stdcall InlineGetWrapper(OBJECTREF* pObj);

    //Get RefCount
    inline static ULONG GetRefCount(ComCallWrapper* pWrap, BOOL bCurrWrapIsStartWrap)
    {
        _ASSERTE(pWrap != NULL);
        size_t *pLong = &pWrap->m_cbRefCount;

        // If the field is not being used as a reference...
        if ((*pLong & enum_RefMask) != enum_RefMask)
        {
            if (!bCurrWrapIsStartWrap)
            {
                // linked wrappers, have the refcount in a different slot
                // find the start wrapper
                pLong = &GetStartWrapper(pWrap)->m_cbLinkedRefCount;
            }
            else
            {
                // The current wrapper is guaranteed to be the start wrapper so simply
                // return its ref count.
                pLong = &pWrap->m_cbLinkedRefCount;
            }
        }

        return  (ULONG)((*(size_t*)pLong) & ~enum_RefMask);
    }


    // AddRef a wrapper
    inline static ULONG AddRef(ComCallWrapper* pWrap)
    {
        _ASSERTE(pWrap != NULL);
        size_t *pLong = &pWrap->m_cbRefCount;

        // If the field is not being used as a reference...
        if ((*pLong & enum_RefMask) != enum_RefMask)
        {
            // linked wrappers, have the refcount in a different slot
            pLong = &GetStartWrapper(pWrap)->m_cbLinkedRefCount;
        }

        ULONG cbCount = FastInterlockIncrement((LONG*)pLong) & ~enum_RefMask;
        _ASSERTE(cbCount > 0); // If the cbCount is zero, then we just overflowed the ref count...

        return cbCount;
    }

    // Release for a Wrapper object
    inline static ULONG Release(ComCallWrapper* pWrap, BOOL bCurrWrapIsStartWrap = FALSE)
    {
        _ASSERTE(pWrap != NULL);
        size_t *pLong = &pWrap->m_cbRefCount;

        // If the field is not being used as a reference...
        if ((*pLong & enum_RefMask) != enum_RefMask)
        {
			if (!bCurrWrapIsStartWrap)
			{
				// linked wrappers, have the refcount in a different slot
				// find the start wrapper
				pLong = &GetStartWrapper(pWrap)->m_cbLinkedRefCount;
			}
			else
			{
				// The current wrapper is guaranteed to be the start wrapper so simply
				// return its ref count.
				pLong = &pWrap->m_cbLinkedRefCount;
			}
		}

        // Need to make sure we aren't releaseing a released object. If the ref count is 0, we are, and that's bad. But
        // for m_cbRefCount, 0 is really enum_RefMask, since we're using the high 2 bits...
        if ((*pLong & ~enum_RefMask) == 0)
        {
            _ASSERTE(!"Invalid release call on already released object");
            return -1;
        }
        LONG cbCount = FastInterlockDecrement((LONG*)pLong) & ~enum_RefMask;

/* The following code is broken and was only there to ensure cleanup on shutdown
   This is soon to be obsolete, since we have the steady state working set tests
   to detect memory leak problems. 

        if (cbCount == 0)
        {
            // zombied wrapper, should not hold a strong reference to the object
            // if shutdown scenario, do the remaining cleanup
            // @TODO:  Instead of using g_fEEShutDown as a boolean, we should be
            //         checking for the bit that indicates where we are in the
            //         shutdown with respect to syncblocks & COM.
            if (g_fEEShutDown)
            {
                // Zero the COM stuff from the sync block so we don't try to cleanup
                // a second time as we SyncBlock::Detach().
                SyncBlock  *psb = 0;
                //BEGIN_ENSURE_COOPERATIVE_GC();
                OBJECTREF   or = pWrap->GetObjectRef();

                if (or != 0)
                {
                    psb = or->GetSyncBlockSpecial();
                    _ASSERTE (psb != NULL);
                }
                //END_ENSURE_COOPERATIVE_GC();
                Cleanup(pWrap);
                if (psb)
                    psb->SetComCallWrapper(0);
            }
        }
*/
        // assert ref-count hasn't fallen below zero
        // bug in the com ip user code.
        _ASSERTE(cbCount >= 0);
        return cbCount;
    }

    // Set Simple Wrapper, for std interfaces such as IProvideClassInfo
    // etc.
    static void SetSimpleWrapper(ComCallWrapper* pWrap, SimpleComCallWrapper* pSimpleWrap)
    {
        _ASSERTE(pWrap != NULL);
        unsigned sindex = IsLinked(pWrap) ? 2 : 1;
        pWrap->m_rgpIPtr[sindex] = (SLOT*)pSimpleWrap;
    }

    //Get Simple wrapper, for std interfaces such as IProvideClassInfo
    static SimpleComCallWrapper* GetSimpleWrapper(ComCallWrapper* pWrap)
    {
        _ASSERTE(pWrap != NULL);
        unsigned sindex = 1;
        if (IsLinked(pWrap))
        {
            sindex = 2;
            pWrap = GetStartWrapper(pWrap);
        }
        return (SimpleComCallWrapper *)pWrap->m_rgpIPtr[sindex];
    }


    // Get wrapper from IP, for std. interfaces like IDispatch
    inline static ComCallWrapper* GetWrapperFromIP(IUnknown* pUnk)
    {
        _ASSERTE(pUnk != NULL);

        ComCallWrapper* pWrap = (ComCallWrapper*)((size_t)pUnk & enum_ThisMask);
        // validate the object, to allow addref and release we don't need the
        // the object, this is true duing shutdown
        //_ASSERTE(pWrap->m_ppThis != NULL);

        return pWrap;
    }

    inline static ComCallWrapper* GetStartWrapperFromIP(IUnknown* pUnk)
    {
        ComCallWrapper* pWrap = GetWrapperFromIP(pUnk);
        if (IsLinked(pWrap))
        {
            pWrap = GetStartWrapper(pWrap);
        }
        return pWrap;
    }

    // Get an interface from wrapper, based on riid or pIntfMT
    static IUnknown* GetComIPfromWrapper(ComCallWrapper *pWrap, REFIID riid, MethodTable* pIntfMT, BOOL bCheckVisibility);

private:

    // QI for one of the standard interfaces exposed by managed objects.
    static IUnknown* QIStandardInterface(ComCallWrapper* pWrap, Enum_StdInterfaces index);
};

//--------------------------------------------------------------------------------
// simple ComCallWrapper for all simple std interfaces, that are not used very often
// like IProvideClassInfo, ISupportsErrorInfo etc.
//--------------------------------------------------------------------------------
struct SimpleComCallWrapper
{
private:
    friend ComCallWrapper;

    enum SimpleComCallWrapperFlags
    {
        enum_IsAggregated             = 0x1,
        enum_IsExtendsCom             = 0x2,
        enum_IsHandleWeak             = 0x4,
        enum_IsObjectTP               = 0x8,
        enum_IsAgile                  = 0x10,
        enum_IsRefined                = 0x20,
    }; 

    CQuickArray<ConnectionPoint*> *m_pCPList;
    DWORD m_flags;

public:
    SyncBlock*          m_pSyncBlock; // syncblock for the ObjecRef
    StreamOrCookie      m_pOuterCookie; //outer unknown cookie
    ComPlusWrapper*     m_pBaseWrap; // when a COM+ class extends a COM class
                                     // this data member represents the ComPlusWrapper
                                    // for the base COM class


    SLOT*               m_rgpVtable[enum_LastStdVtable];  // pointer to an array of std. vtables
    ComCallWrapper*     m_pWrap;
    EEClass*            m_pClass;
    Context*            m_pContext;
    ComCallWrapperCache *m_pWrapperCache;    
    ComCallWrapperTemplate* m_pTemplate;

    DWORD m_dwDomainId;
    // when we make the object agile, need to save off the original handle so we can clean
    // it up when the object goes away.
    // @nice jenh: would be nice to overload one of the other values with this, but then
    // would have to synchronize on it too
    OBJECTHANDLE m_hOrigDomainHandle;

    HRESULT IErrorInfo_hr();
    BSTR    IErrorInfo_bstrDescription();
    BSTR    IErrorInfo_bstrSource();
    BSTR    IErrorInfo_bstrHelpFile();
    DWORD   IErrorInfo_dwHelpContext();
    GUID    IErrorInfo_guid();

    // Information required by the IDispatchEx standard interface.
    DispatchExInfo*     m_pDispatchExInfo;

    // The method table for the IExpando and IReflect interfaces.
    static MethodTable* m_pIExpandoMT;
    static MethodTable* m_pIReflectMT;

    // non virtual methods
    SimpleComCallWrapper();

    VOID Cleanup();

    ~SimpleComCallWrapper();


    VOID ResetSyncBlock()
    {
        m_pSyncBlock = NULL;

    }

    void* operator new(size_t size, void* spot) {   return (spot); }
    void operator delete(void* spot) {}


    SyncBlock* GetSyncBlock()
    {
        return m_pSyncBlock;
    }

    // Init, with the EEClass, pointer to the vtable of the interface
    // and the main ComCallWrapper if the interface needs it
    void InitNew(OBJECTREF oref, ComCallWrapperCache *pWrapperCache,
                 ComCallWrapper* pWrap, Context* pContext, SyncBlock* pSyncBlock,
                 ComCallWrapperTemplate* pTemplate);
    // used by reconnect wrapper to new object
    void ReInit(SyncBlock* pSyncBlock);

    void InitOuter(IUnknown* pOuter);

    void SetComPlusWrapper(ComPlusWrapper* pPlusWrap)
    {
        _ASSERTE(m_pBaseWrap == NULL  || pPlusWrap == NULL);
        m_pBaseWrap = pPlusWrap;
    }
    
    ComPlusWrapper* GetComPlusWrapper()
    {
        return m_pBaseWrap;
    }

    IUnknown* GetOuter();

    // get inner unknown
    HRESULT GetInnerUnknown(void **ppv)
    {
        _ASSERTE(ppv != NULL);
        *ppv = QIStandardInterface(this, enum_InnerUnknown);
        if (*ppv)
        {            
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    IUnknown* GetInnerUnknown()
    {
        IUnknown* pUnk = QIStandardInterface(this, enum_InnerUnknown);
        return pUnk;
    }

    OBJECTREF GetObjectRef()
    {
        return GetMainWrapper(this)->GetObjectRef();
    }

    Context *GetObjectContext(Thread *pThread)
    {
        if (IsAgile())
            return pThread->GetContext();
        _ASSERTE(! IsUnloaded());
        return m_pContext;
    }

    ComCallWrapperCache* GetWrapperCache()
    {
        return m_pWrapperCache;
    }

    // Connection point helper methods.
    BOOL FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP);
    void EnumConnectionPoints(IEnumConnectionPoints **ppEnumCP);

    AppDomain *GetDomainSynchronized()
    {
        // Use this when are working in unmanaged code and will be getting at the
        // domain pointer. Don't need to do any explicit synchronization because if we are in
        // unmanaged code if an unload starts during the time we are messing
        // with the domain pointer, it will eventually stop the EE in order to unwind
        // the threads, which will allow us to finish our work. We won't just get
        // stopped in the middle and have the domain disappear from under us. If an
        // unload has already started prior to us getting the domain id, then it will
        // have been removed from the Id table well before the domain is nuked so we
        // will just get back null and we will know the domain has gone away.
        // If subsequently call into managed to do an AD callback, the remoting code
        // grabs the domain ID and uses it to guard against the domain being unloaded
        // so are OK to use the domain pointer until the point where transition into managed.
        // If is an agile object, just return the current domain as won't need to switch.
        if (IsAgile())
            return GetThread()->GetDomain();

        return SystemDomain::System()->GetAppDomainAtId(m_dwDomainId);
    }

    // before convert this to a domain ptr, must always add a dependency to the wrapper cache
    // to ensure that the domain doesn't go away underneath you.
    BOOL GetDomainID()
    {
        return m_dwDomainId;
    }

    // if you call this you must either pass TRUE for throwIfUnloaded or check
    // after the result before accessing any pointers that may be invalid.
    FORCEINLINE BOOL NeedToSwitchDomains(Thread *pThread, BOOL throwIfUnloaded)
    {
        if (IsAgile() || m_dwDomainId == pThread->GetDomain()->GetId())
            return FALSE;

       if (! IsUnloaded() || ! throwIfUnloaded)
           return TRUE;

       THROWSCOMPLUSEXCEPTION();

       COMPlusThrow(kAppDomainUnloadedException);
       return TRUE;
    }


    BOOL IsUnloaded()
    {
        return GetDomainSynchronized() == NULL;
    }

    BOOL ShouldBeAgile()
    {
        return (m_pClass->IsCCWAppDomainAgile() &&! IsAgile() && GetThread()->GetDomain() != GetDomainSynchronized());
    }

    void MakeAgile(OBJECTHANDLE origHandle)
    {
        m_hOrigDomainHandle = origHandle;
        FastInterlockOr((ULONG*)&m_flags, enum_IsAgile);
    }

    BOOL IsAgile()
    {
        return m_flags & enum_IsAgile;
    }

    BOOL IsObjectTP()
    {
        return m_flags & enum_IsObjectTP;
    }

    BOOL IsRefined()
    {
        return m_flags & enum_IsRefined;
    }

    void MarkRefined()
    {
        FastInterlockOr((ULONG*)&m_flags, enum_IsRefined);
    }

    // is the object aggregated by a COM component
    BOOL IsAggregated()
    {
        return m_flags & enum_IsAggregated;
    }

    void MarkAggregated()
    {
        FastInterlockOr((ULONG*)&m_flags, enum_IsAggregated);
    }

    BOOL IsHandleWeak()
    {
        return m_flags & enum_IsHandleWeak;
    }

    void MarkHandleWeak()
    {
        FastInterlockOr((ULONG*)&m_flags, enum_IsHandleWeak);
    }

    VOID ResetHandleStrength()
    {
        //_ASSERTE(m_fWrapperDeactivated == 1);
        FastInterlockAnd((ULONG*)&m_flags, ~enum_IsHandleWeak);
    }

    // is the object extends from (aggregates) a COM component
    BOOL IsExtendsCOMObject()
    {
        return m_flags & enum_IsExtendsCom;
    }

    // Used for the creation and deletion of simple wrappers
    static SimpleComCallWrapper* CreateSimpleWrapper();
    static void FreeSimpleWrapper(SimpleComCallWrapper* p);

    // Determines if the EEClass associated with the ComCallWrapper supports exceptions.
    static BOOL SupportsExceptions(EEClass *pEEClass);

    // Determines if the EEClass supports IReflect / IExpando.
    static BOOL SupportsIReflect(EEClass *pEEClass);
    static BOOL SupportsIExpando(EEClass *pEEClass);

    // Loads the reflection types used by the SimpleComCallWrapper. Returns TRUE if
    // the types have been loaded properly and FALSE otherwise.
    static BOOL LoadReflectionTypes();

    static SimpleComCallWrapper* GetWrapperFromIP(IUnknown* pUnk);
    // get the main wrapper
    static ComCallWrapper*  GetMainWrapper(SimpleComCallWrapper * pWrap)
    {
        _ASSERTE(pWrap != NULL);
        return pWrap->m_pWrap;
    }
    static inline ULONG AddRef(IUnknown *pUnk)
    {
        SimpleComCallWrapper *pSimpleWrap = GetWrapperFromIP(pUnk);
        // aggregation check
        IUnknown *pOuter = pSimpleWrap->GetOuter();
        if (pOuter != NULL)
            return pOuter->AddRef();

        ComCallWrapper *pWrap = GetMainWrapper(pSimpleWrap);
        _ASSERTE(GetThread()->GetDomain() == pWrap->GetDomainSynchronized());
        return ComCallWrapper::AddRef(pWrap);
    }

    static inline ULONG Release(IUnknown *pUnk)
    {
        SimpleComCallWrapper *pSimpleWrap = GetWrapperFromIP(pUnk);
        // aggregation check
        IUnknown *pOuter = pSimpleWrap->GetOuter();
        if (pOuter != NULL)
            return SafeRelease(pOuter);
        ComCallWrapper *pWrap = GetMainWrapper(pSimpleWrap);
        return ComCallWrapper::Release(pWrap);
    }

private:
    // Methods to initialize the DispatchEx and exception info.
    void InitExceptionInfo();
    BOOL InitDispatchExInfo();

    // Methods to set up the connection point list.
    void SetUpCPList();
    void SetUpCPListHelper(MethodTable **apSrcItfMTs, int cSrcItfs);
    ConnectionPoint *CreateConnectionPoint(ComCallWrapper *pWrap, MethodTable *pEventMT);
    CQuickArray<ConnectionPoint*> *CreateCPArray();

    // QI for well known interfaces from within the runtime direct fetch, instead of guid comparisons
    static IUnknown* __stdcall QIStandardInterface(SimpleComCallWrapper* pWrap, Enum_StdInterfaces index);

    // QI for well known interfaces from within the runtime based on an IID.
    static IUnknown* __stdcall QIStandardInterface(SimpleComCallWrapper* pWrap, REFIID riid);
};


//--------------------------------------------------------------------------------
// ComCallWrapper* ComCallWrapper::InlineGetWrapper(OBJECTREF pObj)
// returns the wrapper for the object, if not yet created, creates one
// returns null for out of memory scenarios.
// Note: the wrapper is returned AddRef'd and should be Released when finished
// with.
//--------------------------------------------------------------------------------
inline ComCallWrapper* __stdcall ComCallWrapper::InlineGetWrapper(OBJECTREF* ppObj)
{
    _ASSERTE(ppObj != NULL);
    // get the wrapper for this com+ object
    ComCallWrapper* pWrap = TryGetWrapperFromSyncBlock(*ppObj);

    if (pWrap != NULL)
    {
        ComCallWrapper::AddRef(pWrap);
    }
    else
    {
        pWrap =  CreateWrapper(ppObj);
        if (pWrap)
        {
            ComCallWrapper::AddRef(pWrap);
        }
    }
    return pWrap;
}

//--------------------------------------------------------------------------------
//HRESULT  ComCallWrapper::QIStandardInterface(ComCallWrapper* pWrap, Enum_StdInterfaces index)
// QI for well known interfaces from within the runtime
// direct fetch, instead of guid comparisons
//--------------------------------------------------------------------------------
inline IUnknown *ComCallWrapper::QIStandardInterface(ComCallWrapper* pWrap, Enum_StdInterfaces index)
{
    IUnknown *pUnk = NULL;

    if (index == enum_IUnknown)
    {
        unsigned fIsLinked = IsLinked(pWrap);
        int islot = fIsLinked ? 1 : 0;
        pUnk = (IUnknown*)&pWrap->m_rgpIPtr[islot];
    }
    else
    {
        SimpleComCallWrapper* pSimpleWrap = GetSimpleWrapper(pWrap);
        pUnk = SimpleComCallWrapper::QIStandardInterface(pSimpleWrap, index);
    }

    return pUnk;
}

//--------------------------------------------------------------------------------
// Return the context that this wrapper lives in
//--------------------------------------------------------------------------------
inline Context *ComCallWrapper::GetObjectContext(Thread *pThread)
{
    // @TODO context cwb: Rethink the relationship between the Simple wrapper and
    // the main wrapper.  Also move the wrapper's context into an IP slot of the main
    // wrapper, for faster calls in.
    return GetSimpleWrapper(this)->GetObjectContext(pThread);
}

FORCEINLINE AppDomain *ComCallWrapper::GetDomainSynchronized()
{
    return GetSimpleWrapper(this)->GetDomainSynchronized();
}

inline BOOL ComCallWrapper::NeedToSwitchDomains(Thread *pThread, BOOL throwIfUnloaded)
{
    return GetSimpleWrapper(this)->NeedToSwitchDomains(pThread, throwIfUnloaded);
}

inline BOOL ComCallWrapper::IsUnloaded()
{
    return GetSimpleWrapper(this)->IsUnloaded();
}

inline void ComCallWrapper::CheckMakeAgile(OBJECTREF pObj)
{
    if (GetSimpleWrapper(this)->ShouldBeAgile())
        MakeAgile(pObj);
}

#endif _COMCALLWRAPPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcertificatestore.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:
//  
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//---------------------------------------------------------------------------

#pragma once
#include <wincrypt.h>

class COMCertificateStore
{
public:
    struct _OpenCertificateStoreArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, thisRef);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _SaveCertificateStoreArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, length);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, certs);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    static void OpenCertificateStore(_OpenCertificateStoreArgs *);
    static void SaveCertificateStore(_SaveCertificateStoreArgs *);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcallwrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//--------------------------------------------------------------------------
// wrapper.cpp
//
// Implementation for various Wrapper classes
//
//  COMWrapper      : COM callable wrappers for COM+ interfaces
//  ContextWrapper  : Wrappers that intercept cross context calls
//      //  %%Created by: rajak
//--------------------------------------------------------------------------

#include "common.h"

#include "object.h"
#include "field.h"
#include "method.hpp"
#include "class.h"
#include "ComCallWrapper.h"
#include "compluswrapper.h"
#include "cachelinealloc.h"
#include "orefcache.h"
#include "threads.h"
#include "ceemain.h"
#include "excep.h"
#include "stublink.h"
#include "cgensys.h"
#include "comcall.h"
#include "compluscall.h"
#include "objecthandle.h"
#include "comutilnative.h"
#include "eeconfig.h"
#include "interoputil.h"
#include "dispex.h"
#include "ReflectUtil.h"
#include "PerfCounters.h"
#include "remoting.h"
#include "COMClass.h"
#include "GuidFromName.h"
#include "wsperf.h"
#include "security.h"
#include "ComConnectionPoints.h"

#include <objsafe.h>    // IID_IObjctSafe

// IObjectSafety not implemented for Default domain
#define _HIDE_OBJSAFETY_FOR_DEFAULT_DOMAIN 

//#define PRINTDETAILS // Define this to print debugging information.
#ifdef PRINTDETAILS
#include "stdio.h"
#define dprintf printf
#else

void dprintf(char *s, ...)
{
}
#endif

// The enum that describes the value of the IDispatchImplAttribute custom attribute.
enum IDispatchImplType
{
    SystemDefinedImpl   = 0,
    InternalImpl        = 1,
    CompatibleImpl      = 2
};

// The default impl type for types that do not have an impl type specified.
#define DEFAULT_IDISPATCH_IMPL_TYPE InternalImpl

// Startup and shutdown lock
EXTERN  SpinLock        g_LockStartup;

BYTE g_CreateWrapperTemplateCrstSpace[sizeof(Crst)];
Crst *g_pCreateWrapperTemplateCrst;

MethodTable * SimpleComCallWrapper::m_pIReflectMT = NULL;
MethodTable * SimpleComCallWrapper::m_pIExpandoMT = NULL;

// helper macros
#define IsMultiBlock(numInterfaces) ((numInterfaces)> (NumVtablePtrs-2))
#define NumStdInterfaces 2

Stub* GenerateFieldAccess(StubLinker *pstublinker, short offset, bool fLong);
// This is the prestub that is used for Com calls entering COM+
VOID __cdecl ComCallPreStub();
//@TODO handle classes with more than 12 interfaces

//--------------------------------------------------------------------------
// ComCallable wrapper manager
// constructor
//--------------------------------------------------------------------------
ComCallWrapperCache::ComCallWrapperCache()
{
    m_cbRef = 0;
    m_lock.Init(LOCK_COMWRAPPER_CACHE);
    m_pCacheLineAllocator = NULL;
    m_dependencyCount = 0;
}


//-------------------------------------------------------------------
// ComCallable wrapper manager
// destructor
//-------------------------------------------------------------------
ComCallWrapperCache::~ComCallWrapperCache()
{
    LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::~ComCallWrapperCache %8.8x in domain %8.8x %S\n", this, GetDomain(), GetDomain() ? GetDomain()->GetFriendlyName(FALSE) : NULL));
    if (m_pCacheLineAllocator) 
    {
        delete m_pCacheLineAllocator;
        m_pCacheLineAllocator = NULL;
    }
    AppDomain *pDomain = GetDomain();   // don't use member directly, need to mask off flags
    if (pDomain) 
    {
        // clear hook in AppDomain as we're going away
        pDomain->ResetComCallWrapperCache();
    }
}


//-------------------------------------------------------------------
// ComCallable wrapper manager
// Create/Init method
//-------------------------------------------------------------------
ComCallWrapperCache *ComCallWrapperCache::Create(AppDomain *pDomain)
{
    ComCallWrapperCache *pWrapperCache = new ComCallWrapperCache();
    if (pWrapperCache != NULL)
    {        
        LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::Create %8.8x in domain %8.8x %S\n", pWrapperCache, pDomain, pDomain->GetFriendlyName(FALSE)));

        pWrapperCache->m_pDomain = pDomain;

        pWrapperCache->m_pCacheLineAllocator = new CCacheLineAllocator;
        if (! pWrapperCache->m_pCacheLineAllocator) {
            goto error;
        }   
        pWrapperCache->AddRef();
    }
    return pWrapperCache;

error:
    delete pWrapperCache;
    return NULL;
}


//-------------------------------------------------------------------
// ComCallable wrapper manager
// Terminate, called to cleanup
//-------------------------------------------------------------------
void ComCallWrapperCache::Terminate()
{
    LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::Terminate %8.8x in domain %8.8x %S\n", this, GetDomain(), GetDomain() ? GetDomain()->GetFriendlyName(FALSE) : NULL));
    LONG i = Release();

    // Release will delete when hit 0, so if non-zero and are in shutdown, delete anyway.
    if (i != 0 && g_fEEShutDown)
    {
        // this could be a bug in the user code,
        // but we will clean up anyway
        delete this;
        LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::Terminate deleting\n"));
    }
}

//-------------------------------------------------------------------
// ComCallable wrapper manager 
// LONG AddRef()
//-------------------------------------------------------------------
LONG    ComCallWrapperCache::AddRef()
{
    COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cCCW++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cCCW++);
    
    LONG i = FastInterlockIncrement(&m_cbRef);
    LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::Addref %8.8x with %d in domain %8.8x %S\n", this, i, GetDomain() ,GetDomain()->GetFriendlyName(FALSE)));
    return i;
}

//-------------------------------------------------------------------
// ComCallable wrapper manager 
// LONG Release()
//-------------------------------------------------------------------
LONG    ComCallWrapperCache::Release()
{
    COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cCCW--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cCCW--);

    LONG i = FastInterlockDecrement(&m_cbRef);
    _ASSERTE(i >=0);
    LOG((LF_INTEROP, LL_INFO100, "ComCallWrapperCache::Release %8.8x with %d in domain %8.8x %S\n", this, i, GetDomain(), GetDomain() ? GetDomain()->GetFriendlyName(FALSE) : NULL));
    if ( i == 0)
    {
        delete this;
    }

    return i;
}

//--------------------------------------------------------------------------
// inline MethodTable* GetMethodTableFromWrapper(ComCallWrapper* pWrap)
// helper to access the method table gc safe
//--------------------------------------------------------------------------
MethodTable* GetMethodTableFromWrapper(ComCallWrapper* pWrap)
{
    _ASSERTE(pWrap != NULL);
    
    Thread* pThread = GetThread();
    unsigned fGCDisabled = pThread->PreemptiveGCDisabled();
    if (!fGCDisabled)
    {
        // disable pre-emptive GC
        pThread->DisablePreemptiveGC();    
    }

    //get the object from the wrapper
    OBJECTREF pObj = pWrap->GetObjectRef();
    // get the method table for the object
    MethodTable *pMT = pObj->GetTrueMethodTable();

    if (!fGCDisabled)
    {
        // enable GC
        pThread->EnablePreemptiveGC();
    }   

    return pMT;
}

//--------------------------------------------------------------------------
// void ComMethodTable::Cleanup()
// free the stubs and the vtable 
//--------------------------------------------------------------------------
void ComMethodTable::Cleanup()
{
    unsigned cbExtraSlots = GetNumExtraSlots(GetInterfaceType());
    unsigned cbSlots = m_cbSlots;
    SLOT* pComVtable = (SLOT *)(this + 1);

    // If we have created and laid out the method desc then we need to delete them.
    if (IsLayoutComplete())
    {
#ifdef PROFILING_SUPPORTED
        // This notifies the profiler that the vtable is being destroyed
        if (CORProfilerTrackCCW())
        {
#if defined(_DEBUG)
            WCHAR rIID[40]; // {00000000-0000-0000-0000-000000000000}
            GuidToLPWSTR(m_IID, rIID, lengthof(rIID));
            LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableDestroyed Class:%hs, IID:%ls, vTbl:%#08x\n", 
                 m_pMT->GetClass()->m_szDebugClassName, rIID, pComVtable));
#else
            LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableDestroyed Class:%#x, IID:{%08x-...}, vTbl:%#08x\n", 
                 m_pMT->GetClass(), m_IID.Data1, pComVtable));
#endif
            g_profControlBlock.pProfInterface->COMClassicVTableDestroyed(
                (ClassID) TypeHandle(m_pMT->GetClass()).AsPtr(), m_IID, pComVtable, (ThreadID) GetThread());
        }
#endif // PROFILING_SUPPORTED

        for (unsigned i = cbExtraSlots; i < cbSlots+cbExtraSlots; i++)
        {
            ComCallMethodDesc* pCMD = (ComCallMethodDesc *)(((BYTE *)pComVtable[i]) + METHOD_CALL_PRESTUB_SIZE);
            if (pComVtable[i] == (SLOT)-1 || ! OwnedbyThisMT(pCMD))
                continue;
                    // All the stubs that are in a COM->COM+ VTable are to the generic
                    // helpers (g_pGenericComCallStubFields, etc.).  So all we do is
                    // discard the resources held by the ComMethodDesc.
                    ComCall::DiscardStub(pCMD);
                }
            }

    if (m_pDispatchInfo)
        delete m_pDispatchInfo;
    if (m_pMDescr)
        delete m_pMDescr;
    if (m_pITypeInfo && !g_fProcessDetach)
        SafeRelease(m_pITypeInfo);
    delete [] this;
}

//--------------------------------------------------------------------------
//  ComMethodTable* ComCallWrapperTemplate::IsDuplicateMD(MethodDesc *pMD, unsigned int ix)
//  Determines is the specified method desc is a duplicate.
//--------------------------------------------------------------------------
bool IsDuplicateMD(MethodDesc *pMD, unsigned int ix)
{
    if (!pMD->IsDuplicate())
        return false;
    if (pMD->GetSlot() == ix)
        return false;
    return true;
}

bool IsOverloadedComVisibleMember(MethodDesc *pMD, MethodDesc *pParentMD)
{
    mdToken tkMember;
    mdToken tkParentMember;
    mdMethodDef mdAssociate;
    mdMethodDef mdParentAssociate;
    IMDInternalImport *pMDImport = pMD->GetMDImport();
    IMDInternalImport *pParantMDImport = pParentMD->GetMDImport();

    // Array methods should never be exposed to COM.
    if (pMD->IsArray())
        return FALSE;
    
    // Check to see if the new method is a property accessor.
    if (pMDImport->GetPropertyInfoForMethodDef(pMD->GetMemberDef(), &tkMember, NULL, NULL) == S_OK)
    {
        mdAssociate = pMD->GetMemberDef();
    }
    else
    {
        tkMember = pMD->GetMemberDef();
        mdAssociate = mdTokenNil;
    }

    // If the new member is not visible from COM then it isn't an overloaded public member.
    if (!IsMemberVisibleFromCom(pMDImport, tkMember, mdAssociate))
        return FALSE;

    // Check to see if the parent method is a property accessor.
    if (pMDImport->GetPropertyInfoForMethodDef(pParentMD->GetMemberDef(), &tkParentMember, NULL, NULL) == S_OK)
    {
        mdParentAssociate = pParentMD->GetMemberDef();
    }
    else
    {
        tkParentMember = pParentMD->GetMemberDef();
        mdParentAssociate = mdTokenNil;
    }

    // If the old member is visible from COM then the new one is not a public overload.
    if (IsMemberVisibleFromCom(pParantMDImport, tkParentMember, mdParentAssociate))
        return FALSE;

    // The new member is a COM visible overload of a non COM visible member.
    return TRUE;
}

bool IsNewComVisibleMember(MethodDesc *pMD)
{
    mdToken tkMember;
    mdMethodDef mdAssociate;
    IMDInternalImport *pMDImport = pMD->GetMDImport();
    
    // Array methods should never be exposed to COM.
    if (pMD->IsArray())
        return FALSE;

    // Check to see if the method is a property accessor.
    if (pMDImport->GetPropertyInfoForMethodDef(pMD->GetMemberDef(), &tkMember, NULL, NULL) == S_OK)
    {
        mdAssociate = pMD->GetMemberDef();
    }
    else
    {
        tkMember = pMD->GetMemberDef();
        mdAssociate = mdTokenNil;
    }

    // Check to see if the member is visible from COM.
    return IsMemberVisibleFromCom(pMDImport, tkMember, mdAssociate) ? true : false;
}

bool IsStrictlyUnboxed(MethodDesc *pMD)
{
    EEClass *pClass = pMD->GetClass();

    for (int i = 0; i < pClass->GetNumVtableSlots(); i++)
    {
        MethodDesc *pCurrMD = pClass->GetUnknownMethodDescForSlot(i);
        if (pCurrMD->GetMemberDef() == pMD->GetMemberDef())
            return false;
    }

    return true;
}

typedef CQuickArray<EEClass*> CQuickEEClassPtrs;

//--------------------------------------------------------------------------
// Lay's out the members of a ComMethodTable that represents an IClassX.
//--------------------------------------------------------------------------
BOOL ComMethodTable::LayOutClassMethodTable()
{
    _ASSERTE(!IsLayoutComplete());

    unsigned i;
    IDispatchVtable* pDispVtable;
    SLOT *pComVtable;
    unsigned cbPrevSlots;
    unsigned cbAlloc;
    BYTE*  pMethodDescMemory = NULL;
    unsigned cbNumParentVirtualMethods = 0;
    unsigned cbTotalParentFields = 0;
    unsigned cbParentComMTSlots = 0;
    EEClass *pClass = m_pMT->GetClass();
    EEClass* pComPlusParentClass = pClass->GetParentComPlusClass();
    EEClass* pParentClass = pClass->GetParentClass();
    EEClass* pCurrParentClass = pParentClass;
    EEClass* pCurrClass = pClass;
    ComMethodTable* pParentComMT = NULL; 
    const unsigned cbExtraSlots = 7;
    CQuickEEClassPtrs apClassesToProcess;
    int cClassesToProcess = 0;


    //
    // If we have a parent ensure its IClassX COM method table is laid out.
    //

    if (pComPlusParentClass)
    {
        pParentComMT = ComCallWrapperTemplate::SetupComMethodTableForClass(pComPlusParentClass->GetMethodTable(), TRUE);
        if (!pParentComMT)
            return FALSE;
        cbParentComMTSlots = pParentComMT->m_cbSlots;
    }


    //
    // Take a lock and check to see if another thread has already laid out the ComMethodTable.
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();
    g_pCreateWrapperTemplateCrst->Enter();
    END_ENSURE_PREEMPTIVE_GC();
    if (IsLayoutComplete())
    {
        g_pCreateWrapperTemplateCrst->Leave();
        return TRUE;
    }


    //
    // Set up the IUnknown and IDispatch methods.
    //

    // IDispatch vtable follows the header
    pDispVtable = (IDispatchVtable*)(this + 1);

    // Setup IUnknown vtable
    pDispVtable->m_qi      = (SLOT)Unknown_QueryInterface;
    pDispVtable->m_addref  = (SLOT)Unknown_AddRef;
    pDispVtable->m_release = (SLOT)Unknown_Release;


    // Set up the common portion of the IDispatch vtable.
    pDispVtable->m_GetTypeInfoCount = (SLOT)Dispatch_GetTypeInfoCount_Wrapper;
    pDispVtable->m_GetTypeInfo = (SLOT)Dispatch_GetTypeInfo_Wrapper;

     // If the class interface is a pure disp interface then we need to use the
    // internal implementation of IDispatch for GetIdsOfNames and Invoke.
    if (GetClassInterfaceType() == clsIfAutoDisp)
    {
        // Use the internal implementation.
        pDispVtable->m_GetIDsOfNames = (SLOT)InternalDispatchImpl_GetIDsOfNames;
        pDispVtable->m_Invoke = (SLOT)InternalDispatchImpl_Invoke;
    }
    else
    {
        // We need to set the entry points to the Dispatch versions which determine
        // which implementation to use at runtime based on the class that implements
        // the interface.
        pDispVtable->m_GetIDsOfNames = (SLOT)Dispatch_GetIDsOfNames_Wrapper;
        pDispVtable->m_Invoke = (SLOT)Dispatch_Invoke_Wrapper;
    }

    //
    // Copy the members down from our parent's template.
    //

    pComVtable = (SLOT *)pDispVtable;
    if (pParentComMT)
    {
        SLOT *pPrevComVtable = (SLOT *)(pParentComMT + 1);
        CopyMemory(pComVtable + cbExtraSlots, pPrevComVtable + cbExtraSlots, sizeof(SLOT) * cbParentComMTSlots);
    }    


    //
    // Allocate method desc's for the rest of the slots.
    //

    cbAlloc = (METHOD_PREPAD + sizeof(ComCallMethodDesc)) * (m_cbSlots - cbParentComMTSlots);
    if (cbAlloc > 0)
    {
        m_pMDescr = pMethodDescMemory = new BYTE[cbAlloc + sizeof(ULONG)]; 
        if (pMethodDescMemory == NULL)
            goto LExit;
        
        // initialize the method desc memory to zero
        FillMemory(pMethodDescMemory, cbAlloc, 0x0);

        *(ULONG *)pMethodDescMemory = cbAlloc; // fill in the size of the memory

        // move past the size
        pMethodDescMemory+=sizeof(ULONG);
    }


    //
    // Create an array of all the classes that need to be laid out.
    //

    do 
    {
        if (FAILED(apClassesToProcess.ReSize(cClassesToProcess + 2)))
            goto LExit;
        apClassesToProcess[cClassesToProcess++] = pCurrClass;
        pCurrClass = pCurrClass->GetParentClass();
    } 
    while (pCurrClass != pComPlusParentClass);
    apClassesToProcess[cClassesToProcess++] = pCurrClass;


    //
    // Set up the COM call method desc's for all the methods and fields that were introduced
    // between the current class and its parent COM+ class. This includes any methods on
    // COM classes.
    //

    cbPrevSlots = cbParentComMTSlots + cbExtraSlots;
    for (cClassesToProcess -= 2; cClassesToProcess >= 0; cClassesToProcess--)
    {
        //
        // Retrieve the current class and the current parent class.
        //

        pCurrClass = apClassesToProcess[cClassesToProcess];
        pCurrParentClass = apClassesToProcess[cClassesToProcess + 1];


        //
        // Retrieve the number of fields and vtable methods on the parent class.
        //

        if (pCurrParentClass)
        {
            cbTotalParentFields = pCurrParentClass->GetNumInstanceFields();       
            cbNumParentVirtualMethods = pCurrParentClass->GetNumVtableSlots();
        }


        //
        // Set up the COM call method desc's for methods that were not public in the parent class
        // but were made public in the current class.
        //

        for (i = 0; i < cbNumParentVirtualMethods; i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
            MethodDesc* pParentMD = pCurrParentClass->GetUnknownMethodDescForSlot(i);
    
            if (pMD && !IsDuplicateMD(pMD, i) && IsOverloadedComVisibleMember(pMD, pParentMD))
            {
                // some bytes are reserved for CALL xxx before the method desc
                ComCallMethodDesc* pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);
                pNewMD->InitMethod(pMD, NULL);

                emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);  

                pComVtable[cbPrevSlots++] = (SLOT)getStubCallAddr((MethodDesc*)pNewMD);     
                pMethodDescMemory += (METHOD_PREPAD + sizeof(ComCallMethodDesc));
            }
        }


        //
        // Set up the COM call method desc's for all newly introduced public methods.
        //

        for (i = cbNumParentVirtualMethods; i < pCurrClass->GetNumVtableSlots(); i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
    
            if (pMD != NULL && !IsDuplicateMD(pMD, i) && IsNewComVisibleMember(pMD))
            {
                // some bytes are reserved for CALL xxx before the method desc
                ComCallMethodDesc* pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);
                pNewMD->InitMethod(pMD, NULL);

                emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);  

                pComVtable[cbPrevSlots++] = (SLOT)getStubCallAddr((MethodDesc*)pNewMD);     
                pMethodDescMemory += (METHOD_PREPAD + sizeof(ComCallMethodDesc));
            }
        }


        //
        // Add the non virtual methods introduced on the current class.
        //

        for (i = pCurrClass->GetNumVtableSlots(); i < pCurrClass->GetNumMethodSlots(); i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
    
            if (pMD != NULL && !IsDuplicateMD(pMD, i) && IsNewComVisibleMember(pMD) && !pMD->IsStatic() && !pMD->IsCtor() && (!pCurrClass->IsValueClass() || (GetClassInterfaceType() != clsIfAutoDual && IsStrictlyUnboxed(pMD))))
            {
                // some bytes are reserved for CALL xxx before the method desc
                ComCallMethodDesc* pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);
                pNewMD->InitMethod(pMD, NULL);

                emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);  

                pComVtable[cbPrevSlots++] = (SLOT)getStubCallAddr((MethodDesc*)pNewMD);     
                pMethodDescMemory += (METHOD_PREPAD + sizeof(ComCallMethodDesc));
            }
        }


        //
        // Set up the COM call method desc's for the public fields defined in the current class.
        //

        FieldDescIterator fdIterator(pCurrClass, FieldDescIterator::INSTANCE_FIELDS);
        FieldDesc* pFD = NULL;
        while ((pFD = fdIterator.Next()) != NULL)
        {
            if (IsMemberVisibleFromCom(pFD->GetMDImport(), pFD->GetMemberDef(), mdTokenNil)) // if it is a public field grab it
            {
                // set up a getter method
                // some bytes are reserved for CALL xxx before the method desc
                ComCallMethodDesc* pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);
                pNewMD->InitField(pFD, TRUE);
                emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);          

                pComVtable[cbPrevSlots++] = (SLOT)getStubCallAddr((MethodDesc *)pNewMD);                
                pMethodDescMemory+= (METHOD_PREPAD + sizeof(ComCallMethodDesc));

                // setup a setter method
                // some bytes are reserved for CALL xxx before the method desc
                pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);
                pNewMD->InitField(pFD, FALSE);
                emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);          
            
                pComVtable[cbPrevSlots++] = (SLOT)getStubCallAddr((MethodDesc*)pNewMD);
                pMethodDescMemory+= (METHOD_PREPAD + sizeof(ComCallMethodDesc));
            }
        }
    }
    _ASSERTE(m_cbSlots == (cbPrevSlots - cbExtraSlots));


    //
    // Set the layout complete flag and release the lock.
    //

    m_Flags |= enum_LayoutComplete;
    g_pCreateWrapperTemplateCrst->Leave();

    return TRUE;

LExit:
    if (pMethodDescMemory)
        delete [] pMethodDescMemory;

    return FALSE;
}

//--------------------------------------------------------------------------
// Lay out the members of a ComMethodTable that represents an interface.
//--------------------------------------------------------------------------
BOOL ComMethodTable::LayOutInterfaceMethodTable(MethodTable* pClsMT, unsigned iMapIndex)
{
    _ASSERTE(pClsMT);
    // make sure this is a not interface method table
    // this should be the class method table
    _ASSERTE(!pClsMT->IsInterface());

    EEClass *pItfClass = m_pMT->GetClass();
    SLOT* pIntfVtable = m_pMT->GetVtable();
    CorIfaceAttr ItfType = m_pMT->GetComInterfaceType();
    ULONG cbExtraSlots = GetNumExtraSlots(ItfType);

    BYTE *pMethodDescMemory = NULL;
    GUID *pItfIID = NULL;
    IUnkVtable* pUnkVtable;
    SLOT *pComVtable;
    unsigned i;

    if (!IsLayoutComplete())
    {
        if (!IsSigClassLoadChecked())
        {
            BOOL fCheckSuccess = TRUE;
            unsigned cbSlots = pItfClass->GetNumVtableSlots();

          
            COMPLUS_TRY
            {
                // check the sigs of the methods to see if we can load
                // all the classes
                for (i = 0; i < cbSlots; i++)
                {           
                    MethodDesc* pIntfMD = m_pMT->GetClass()->GetMethodDescForSlot(i);
                    MetaSig::CheckSigTypesCanBeLoaded(pIntfMD->GetSig(), pIntfMD->GetModule());
                }       
            }
            COMPLUS_CATCH
            {
                BEGIN_ENSURE_COOPERATIVE_GC();
                HRESULT hr = SetupErrorInfo(GETTHROWABLE());
                SetSigClassCannotLoad();
                END_ENSURE_COOPERATIVE_GC();
            }
            COMPLUS_END_CATCH

            SetSigClassLoadChecked();
        }
        
        _ASSERTE(IsSigClassLoadChecked() != 0);
        // check if all types loaded successfully
        if (IsSigClassCannotLoad())
        {
            LogInterop(L"CLASS LOAD FAILURE: in Interface method signature");
            // setup ErrorInfo 
            return FALSE;
        }
    }

    // Take a lock and check to see if another thread has already laid out the ComMethodTable.
    BEGIN_ENSURE_PREEMPTIVE_GC();
    g_pCreateWrapperTemplateCrst->Enter();
    END_ENSURE_PREEMPTIVE_GC();
    if (IsLayoutComplete())
    {
        g_pCreateWrapperTemplateCrst->Leave();
        return TRUE;
    }

    // Retrieve the start slot and the number of slots in the interface.
    unsigned startslot = pClsMT->GetInterfaceMap()[iMapIndex].m_wStartSlot;
    unsigned cbSlots = pItfClass->GetNumVtableSlots();

    // IUnk vtable follows the header
    pUnkVtable = (IUnkVtable*)(this + 1);
    pComVtable = (SLOT *)pUnkVtable;

    // Set all vtable slots to -1 for sparse vtables. That way we catch attempts
    // to access empty slots quickly and, during cleanup, we can tell empty
    // slots from full ones.
    if (m_pMT->IsSparse())
        memset(pUnkVtable + cbExtraSlots, -1, m_cbSlots * sizeof(SLOT));

    // Setup IUnk vtable
    pUnkVtable->m_qi      = (SLOT)Unknown_QueryInterface;
    pUnkVtable->m_addref  = (SLOT)Unknown_AddRef;
    pUnkVtable->m_release = (SLOT)Unknown_Release;

    if (ItfType != ifVtable)
    {
        // Setup the IDispatch vtable.
        IDispatchVtable* pDispVtable = (IDispatchVtable*)pUnkVtable;

        // Set up the common portion of the IDispatch vtable.
        pDispVtable->m_GetTypeInfoCount = (SLOT)Dispatch_GetTypeInfoCount_Wrapper;
        pDispVtable->m_GetTypeInfo = (SLOT)Dispatch_GetTypeInfo_Wrapper;

        // If the interface is a pure disp interface then we need to use the internal 
        // implementation since OleAut does not support invoking on pure disp interfaces.
        if (ItfType == ifDispatch)
        {
            // Use the internal implementation.
            pDispVtable->m_GetIDsOfNames = (SLOT)InternalDispatchImpl_GetIDsOfNames;
            pDispVtable->m_Invoke = (SLOT)InternalDispatchImpl_Invoke;
        }
        else
        {
            // We need to set the entry points to the Dispatch versions which determine
            // which implmentation to use at runtime based on the class that implements
            // the interface.
            pDispVtable->m_GetIDsOfNames = (SLOT)Dispatch_GetIDsOfNames_Wrapper;
            pDispVtable->m_Invoke = (SLOT)Dispatch_Invoke_Wrapper;
        }
    }

    // Method descs are at the end of the vtable
    // m_cbSlots interfaces methods + IUnk methods
    pMethodDescMemory = (BYTE *)&pComVtable[m_cbSlots + cbExtraSlots];

    for (i = 0; i < cbSlots; i++)
    {
        // Some space for a CALL xx xx xx xx stub is reserved before the beginning of the MethodDesc
        ComCallMethodDesc* pNewMD = (ComCallMethodDesc *) (pMethodDescMemory + METHOD_PREPAD);

        MethodDesc* pClassMD = pClsMT->GetMethodDescForSlot(startslot+i);
        MethodDesc* pIntfMD = m_pMT->GetClass()->GetMethodDescForSlot(i);
        pNewMD->InitMethod(pClassMD, pIntfMD);

        emitStubCall((MethodDesc*)pNewMD, (BYTE*)ComCallPreStub);
        pComVtable[pIntfMD->GetComSlot()] = (SLOT)getStubCallAddr((MethodDesc*)pNewMD);          

        pMethodDescMemory += (METHOD_PREPAD + sizeof(ComCallMethodDesc));
    }

    // Set the layout complete flag and release the lock.
    m_Flags |= enum_LayoutComplete;
    g_pCreateWrapperTemplateCrst->Leave();

#ifdef PROFILING_SUPPORTED
    // Notify profiler of the CCW, so it can avoid double-counting.
    if (CORProfilerTrackCCW())
    {
#if defined(_DEBUG)
        WCHAR rIID[40]; // {00000000-0000-0000-0000-000000000000}
        GuidToLPWSTR(m_IID, rIID, lengthof(rIID));
        LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableCreated Class:%hs, IID:%ls, vTbl:%#08x\n", 
             pItfClass->m_szDebugClassName, rIID, pUnkVtable));
#else
        LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableCreated Class:%#x, IID:{%08x-...}, vTbl:%#08x\n", 
             pItfClass, m_IID.Data1, pUnkVtable));
#endif
        g_profControlBlock.pProfInterface->COMClassicVTableCreated((ClassID) TypeHandle(pItfClass).AsPtr(),
            m_IID, pUnkVtable, m_cbSlots+cbExtraSlots, (ThreadID) GetThread());
    }
#endif // PROFILING_SUPPORTED
    
    return TRUE;
}

//--------------------------------------------------------------------------
// Retrieves the DispatchInfo associated with the COM method table. If
// the DispatchInfo has not been initialized yet then it is initilized.
//--------------------------------------------------------------------------
DispatchInfo *ComMethodTable::GetDispatchInfo()
{
    THROWSCOMPLUSEXCEPTION();

    if (!m_pDispatchInfo)
    {
        // We are about to use reflection so make sure it is initialized.
        COMClass::EnsureReflectionInitialized();

        // Reflection no longer initializes variants, so initialize it as well
        COMVariant::EnsureVariantInitialized();

        // Create the DispatchInfo object.
        DispatchInfo *pDispInfo = new DispatchInfo(this);
        if (!pDispInfo)
            COMPlusThrowOM();

        // Synchronize the DispatchInfo with the actual expando object.
        pDispInfo->SynchWithManagedView();

        // Swap the lock into the class member in a thread safe manner.
        if (NULL != FastInterlockCompareExchange((void**)&m_pDispatchInfo, pDispInfo, NULL))
            delete pDispInfo;
    }

    return m_pDispatchInfo;
}

//--------------------------------------------------------------------------
// Set an ITypeInfo pointer for the method table.
//--------------------------------------------------------------------------
void ComMethodTable::SetITypeInfo(ITypeInfo *pNew)
{
    ITypeInfo *pOld;
    pOld = (ITypeInfo*)InterlockedExchangePointer((PVOID*)&m_pITypeInfo, (PVOID)pNew);
    // TypeLibs are refcounted pointers.
    if (pNew != pOld)
    {
        if (pNew)
            SafeAddRef(pNew);
        if (pOld)
            SafeRelease(pOld);
    }
}

//--------------------------------------------------------------------------
// Return the parent ComMethodTable.
//--------------------------------------------------------------------------
ComMethodTable *ComMethodTable::GetParentComMT()
{
    _ASSERTE(IsClassVtable());

    MethodTable *pParentComPlusMT = m_pMT->GetComPlusParentMethodTable();
    if (!pParentComPlusMT)
        return NULL;

    ComCallWrapperTemplate *pTemplate = (ComCallWrapperTemplate*)pParentComPlusMT->GetComCallWrapperTemplate();
    if (!pTemplate)
        return NULL;

    return pTemplate->GetClassComMT();
}

//--------------------------------------------------------------------------
// static void ComCallWrapperTemplate::ReleaseAllVtables(ComCallWrapperTemplate* pTemplate)
//  ReleaseAllVtables, and if the vtable ref-count reaches 0, free them up
//--------------------------------------------------------------------------
void ComCallWrapperTemplate::ReleaseAllVtables(ComCallWrapperTemplate* pTemplate)
{
    _ASSERTE(pTemplate != NULL);
    _ASSERTE(pTemplate->m_pMT != NULL);
   
    for (unsigned j = 0; j < pTemplate->m_cbInterfaces; j++)
    {
        SLOT* pComVtable = pTemplate->m_rgpIPtr[j];
        ComMethodTable* pHeader = (ComMethodTable*)pComVtable-1;      
        pHeader->Release(); // release the vtable   

            #ifdef _DEBUG
                #ifdef _WIN64
                pTemplate->m_rgpIPtr[j] = (SLOT *)(size_t)0xcdcdcdcdcdcdcdcd;
                #else // !_WIN64
                pTemplate->m_rgpIPtr[j] = (SLOT *)(size_t)0xcdcdcdcd;
                #endif
            #endif
    }

    pTemplate->m_pClassComMT->Release();
    delete[]  pTemplate;
}

//--------------------------------------------------------------------------
// Determines if the Compatible IDispatch implementation is required for
// the specified class.
//--------------------------------------------------------------------------
bool IsOleAutDispImplRequiredForClass(EEClass *pClass)
{
    HRESULT             hr;
    const BYTE *        pVal;                 
    ULONG               cbVal;                 
    Assembly *          pAssembly = pClass->GetAssembly();
    IDispatchImplType   DispImplType = SystemDefinedImpl;

    // First check for the IDispatchImplType custom attribute first.
    hr = pClass->GetMDImport()->GetCustomAttributeByName(pClass->GetCl(), INTEROP_IDISPATCHIMPL_TYPE, (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        _ASSERTE("The IDispatchImplAttribute custom attribute is invalid" && cbVal);
        DispImplType = (IDispatchImplType)*(pVal + 2);
        if ((DispImplType > 2) || (DispImplType < 0))
            DispImplType = SystemDefinedImpl;
    }

    // If the custom attribute was set to something other than system defined then we will use that.
    if (DispImplType != SystemDefinedImpl)
        return (bool) (DispImplType == CompatibleImpl);

    // Check to see if the assembly has the IDispatchImplType attribute set.
    if (pAssembly->IsAssembly())
    {
        hr = pAssembly->GetManifestImport()->GetCustomAttributeByName(pAssembly->GetManifestToken(), INTEROP_IDISPATCHIMPL_TYPE, (const void**)&pVal, &cbVal);
        if (hr == S_OK)
        {
            _ASSERTE("The IDispatchImplAttribute custom attribute is invalid" && cbVal);
            DispImplType = (IDispatchImplType)*(pVal + 2);
            if ((DispImplType > 2) || (DispImplType < 0))
                DispImplType = SystemDefinedImpl;
        }
    }

    // If the custom attribute was set to something other than system defined then we will use that.
    if (DispImplType != SystemDefinedImpl)
        return (bool) (DispImplType == CompatibleImpl);

    // Removed registry key check per reg cleanup bug 45978
    // Effect: Will return false so code cleanup
    return false;
 }

//--------------------------------------------------------------------------
// Creates a ComMethodTable for a class's IClassX.
//--------------------------------------------------------------------------
ComMethodTable* ComCallWrapperTemplate::CreateComMethodTableForClass(MethodTable *pClassMT)
{
    _ASSERTE(pClassMT != NULL);
    _ASSERTE(!pClassMT->IsInterface());
    _ASSERTE(!pClassMT->GetComPlusParentMethodTable() || pClassMT->GetComPlusParentMethodTable()->GetComCallWrapperTemplate());
    // for remoted components we allow this
    //_ASSERTE(!pClassMT->GetClass()->IsComImport());
    
    unsigned cbNewPublicFields = 0;
    unsigned cbNewPublicMethods = 0;
    unsigned cbTotalSlots;
    GUID* pIClassXIID = NULL;
    EEClass* pClass = pClassMT->GetClass();
    EEClass* pComPlusParentClass = pClass->GetParentComPlusClass();
    EEClass* pParentClass = pClass->GetParentClass();
    EEClass* pCurrParentClass = pComPlusParentClass;
    EEClass* pCurrClass = pClass;
    CorClassIfaceAttr ClassItfType = pClassMT->GetComClassInterfaceType();
    ComMethodTable *pComMT = NULL;
    ComMethodTable *pParentComMT;
    unsigned cbTotalParentFields = 0;
    unsigned cbNumParentVirtualMethods = 0;
    unsigned cbParentComMTSlots = 0;
    unsigned i;
    const unsigned cbExtraSlots = 7;
    CQuickEEClassPtrs apClassesToProcess;
    int cClassesToProcess = 0;

    // If the specified class has a parent then retrieve information on him.
    if (pComPlusParentClass)
    {
        ComCallWrapperTemplate *pComPlusParentTemplate = (ComCallWrapperTemplate *)pComPlusParentClass->GetComCallWrapperTemplate();
        _ASSERTE(pComPlusParentTemplate);
        pParentComMT = pComPlusParentTemplate->GetClassComMT();
        cbParentComMTSlots = pParentComMT->m_cbSlots;
    }

    // Create an array of all the classes for which we need to compute the added members.
    do 
    {
        if (FAILED(apClassesToProcess.ReSize(cClassesToProcess + 2)))
            goto LExit;
        apClassesToProcess[cClassesToProcess++] = pCurrClass;
        pCurrClass = pCurrClass->GetParentClass();
    } 
    while (pCurrClass != pComPlusParentClass);
    apClassesToProcess[cClassesToProcess++] = pCurrClass;

    // Compute the number of methods and fields that were added between our parent 
    // COM+ class and the current class. This includes methods on COM classes
    // between the current class and its parent COM+ class.
    for (cClassesToProcess -= 2; cClassesToProcess >= 0; cClassesToProcess--)
    {
        // Retrieve the current class and the current parent class.
        pCurrClass = apClassesToProcess[cClassesToProcess];
        pCurrParentClass = apClassesToProcess[cClassesToProcess + 1];

        // Retrieve the number of fields and vtable methods on the parent class.
        if (pCurrParentClass)
        {
            cbTotalParentFields = pCurrParentClass->GetNumInstanceFields();       
            cbNumParentVirtualMethods = pCurrParentClass->GetNumVtableSlots();
        }

        // Compute the number of methods that were private but made public on this class.
        for (i = 0; i < cbNumParentVirtualMethods; i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
            MethodDesc* pParentMD = pCurrParentClass->GetUnknownMethodDescForSlot(i);
            if (pMD && !IsDuplicateMD(pMD, i) && IsOverloadedComVisibleMember(pMD, pParentMD))
                cbNewPublicMethods++;
        }

        // Compute the number of public methods that were added.
        for (i = cbNumParentVirtualMethods; i < pCurrClass->GetNumVtableSlots(); i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
            if (pMD && !IsDuplicateMD(pMD, i) && IsNewComVisibleMember(pMD))
                cbNewPublicMethods++;
        }

        // Add the non virtual methods introduced on the current class.
        for (i = pCurrClass->GetNumVtableSlots(); i < pCurrClass->GetNumMethodSlots(); i++)
        {
            MethodDesc* pMD = pCurrClass->GetUnknownMethodDescForSlot(i);
            if (pMD && !IsDuplicateMD(pMD, i) && IsNewComVisibleMember(pMD) && !pMD->IsStatic() && !pMD->IsCtor() && (!pCurrClass->IsValueClass() || (ClassItfType != clsIfAutoDual && IsStrictlyUnboxed(pMD))))
                cbNewPublicMethods++;
        }

        // Compute the number of new public fields this class introduces.
        FieldDescIterator fdIterator(pCurrClass, FieldDescIterator::INSTANCE_FIELDS);
        FieldDesc* pFD;

        while ((pFD = fdIterator.Next()) != NULL)
        {
            if (IsMemberVisibleFromCom(pFD->GetMDImport(), pFD->GetMemberDef(), mdTokenNil))
                cbNewPublicFields++;
        }
    }

    // Alloc space for the class method table, includes getter and setter 
    // for public fields
    cbTotalSlots = cbParentComMTSlots + cbNewPublicFields * 2 + cbNewPublicMethods;

    // Alloc COM vtable & method descs
    pComMT = (ComMethodTable*)new BYTE[sizeof(ComMethodTable) + (cbTotalSlots + cbExtraSlots) * sizeof(SLOT)];
    if (pComMT == NULL)
        goto LExit;

    // set up the header
    pComMT->m_ptReserved = (SLOT)(size_t)0xDEADC0FF;          // reserved
    pComMT->m_pMT  = pClass->GetMethodTable(); // pointer to the class method table    
    pComMT->m_cbRefCount = 0;
    pComMT->m_pMDescr = NULL;
    pComMT->m_pITypeInfo = NULL;
    pComMT->m_pDispatchInfo = NULL;
    pComMT->m_cbSlots = cbTotalSlots; // number of slots not counting IDisp methods.
    pComMT->m_IID = GUID_NULL;

    // Set the flags.
    pComMT->m_Flags = enum_ClassVtableMask | ClassItfType;

    // Determine if the interface is visible from COM.
    if (IsTypeVisibleFromCom(TypeHandle(pComMT->m_pMT)))
        pComMT->m_Flags |= enum_ComVisible;

    // Determine what IDispatch implementation this class should use.
    if (IsOleAutDispImplRequiredForClass(pClass))
        pComMT->m_Flags |= enum_UseOleAutDispatchImpl;

#if _DEBUG
    {
        // In debug set all the vtable slots to 0xDEADCA11.
        SLOT *pComVTable = (SLOT*)(pComMT + 1);
        for (unsigned iComSlots = 0; iComSlots < cbTotalSlots + cbExtraSlots; iComSlots++)
            *(pComVTable + iComSlots) = (SLOT)(size_t)0xDEADCA11;
    }
#endif

    return pComMT;

LExit:

    if (pComMT)
        delete [] pComMT;
    if (pIClassXIID)
        delete pIClassXIID;

    return NULL;
}

//--------------------------------------------------------------------------
// Creates a ComMethodTable for a an interface.
//--------------------------------------------------------------------------
ComMethodTable* ComCallWrapperTemplate::CreateComMethodTableForInterface(MethodTable* pInterfaceMT)
{
    _ASSERTE(pInterfaceMT != NULL);
    _ASSERTE(pInterfaceMT->IsInterface());   

    EEClass *pItfClass = pInterfaceMT->GetClass();
    CorIfaceAttr ItfType = pInterfaceMT->GetComInterfaceType();
    ULONG cbExtraSlots = ComMethodTable::GetNumExtraSlots(ItfType);
    GUID *pItfIID = NULL;

    // @todo get slots off the methodtable
    unsigned cbSlots = pInterfaceMT->GetClass()->GetNumVtableSlots();
    unsigned cbComSlots = pInterfaceMT->IsSparse() ? pInterfaceMT->GetClass()->GetSparseVTableMap()->GetNumVTableSlots() : cbSlots;
    ComMethodTable* pComMT = (ComMethodTable*)new BYTE[sizeof(ComMethodTable) +
        (cbComSlots + cbExtraSlots) * sizeof(SLOT) +            //IUnknown + interface slots
        cbSlots * (METHOD_PREPAD + sizeof(ComCallMethodDesc))]; // method descs
    if (pComMT == NULL)
        goto LExit;

    // set up the header
    pComMT->m_ptReserved = (SLOT)(size_t)0xDEADC0FF;          // reserved
    pComMT->m_pMT  = pInterfaceMT; // pointer to the interface's method table
    pComMT->m_cbSlots = cbComSlots; // number of slots not counting IUnk
    pComMT->m_cbRefCount = 0;
    pComMT->m_pMDescr = NULL;
    pComMT->m_pITypeInfo = NULL;
    pComMT->m_pDispatchInfo = NULL;

    // Set the IID of the interface.
    pItfClass->GetGuid(&pComMT->m_IID, TRUE);

    // Set the flags.
    pComMT->m_Flags = ItfType;

    // Determine if the interface is visible from COM.
    if (IsTypeVisibleFromCom(TypeHandle(pComMT->m_pMT)))
        pComMT->m_Flags |= enum_ComVisible;

    // Determine if the interface is a COM imported class interface.
    if (pItfClass->IsComClassInterface())
        pComMT->m_Flags |= enum_ComClassItf;

#ifdef _DEBUG
    {
        // In debug set all the vtable slots to 0xDEADCA11.
        SLOT *pComVTable = (SLOT*)(pComMT + 1);
        for (unsigned iComSlots = 0; iComSlots < cbComSlots + cbExtraSlots; iComSlots++)
            *(pComVTable + iComSlots) = (SLOT)(size_t)0xDEADCA11;
    }
#endif

    return pComMT;

LExit:
    if (pComMT)
        delete []pComMT;
    if (pItfIID)
        delete pItfIID;

    return NULL;
}

//--------------------------------------------------------------------------
// ComCallWrapper* ComCallWrapper::CreateTemplate(MethodTable* pMT)
//  create a template wrapper, which is cached in the class
//  used for initializing other wrappers for instances of the class
//--------------------------------------------------------------------------
ComCallWrapperTemplate* ComCallWrapperTemplate::CreateTemplate(MethodTable* pMT)
{
    _ASSERTE(pMT != NULL);
    ComCallWrapperTemplate* pTemplate = NULL;
    MethodTable *pParentMT = pMT->GetComPlusParentMethodTable();
    ComCallWrapperTemplate *pParentTemplate = NULL;
    unsigned iItf = 0;

    // Create the parent's template if it has not been created yet.
    if (pParentMT)
    {
        pParentTemplate = (ComCallWrapperTemplate *)pParentMT->GetComCallWrapperTemplate();
        if (!pParentTemplate)
        {
            pParentTemplate = CreateTemplate(pParentMT);
            if (!pParentTemplate)
                return NULL;
        }
    }

    BEGIN_ENSURE_PREEMPTIVE_GC();
    // Take a lock and check to see if another thread has already set up the template.
    g_pCreateWrapperTemplateCrst->Enter();
    END_ENSURE_PREEMPTIVE_GC();
    pTemplate = (ComCallWrapperTemplate *)pMT->GetComCallWrapperTemplate();
    if (pTemplate)
    {
        g_pCreateWrapperTemplateCrst->Leave();
        return pTemplate;
    }

    // Num interfaces in the template.
    unsigned numInterfaces = pMT->GetNumInterfaces();

    // Allocate the template.
    pTemplate = (ComCallWrapperTemplate*)
        new BYTE[sizeof(ComCallWrapperTemplate) + numInterfaces * sizeof(SLOT)];
    if (!pTemplate)
        return NULL;
        
    // Store the information required by the template.
    pTemplate->m_pMT = pMT;
    pTemplate->m_cbInterfaces = numInterfaces;
    pTemplate->m_pParent = pParentTemplate;
    pTemplate->m_cbRefCount = 0;
    
    // Set up the class COM method table.
    pTemplate->m_pClassComMT = CreateComMethodTableForClass(pMT);
    pTemplate->m_pClassComMT->AddRef();

    // Get the vtables of the interfaces from the IPMap
    InterfaceInfo_t* rgIMap = pMT->GetInterfaceMap();

    // We use our parent's COM method tables for the interfaces our parent implements.
    if (pParentMT)
    {
        unsigned numParentInterfaces = pParentMT->GetNumInterfaces();
        for (iItf = 0; iItf < numParentInterfaces; iItf++)
        {
            ComMethodTable *pItfComMT = (ComMethodTable *)pParentTemplate->m_rgpIPtr[iItf] - 1;
            pTemplate->m_rgpIPtr[iItf] = pParentTemplate->m_rgpIPtr[iItf];
            pItfComMT->AddRef();
        }
    }

    // Create the COM method tables for the interfaces that the current class implements but
    // that the parent class does not.
    for (; iItf < numInterfaces; iItf++)
    {
        ComMethodTable *pItfComMT = CreateComMethodTableForInterface(rgIMap[iItf].m_pMethodTable);
        pTemplate->m_rgpIPtr[iItf] = (SLOT*)(pItfComMT + 1);
        pItfComMT->AddRef();
    }

    // Cache the template in class.
    pMT->SetComCallWrapperTemplate(pTemplate);
    pTemplate->AddRef();

    // If the class is visible from COM, then generate the IClassX IID and 
    // store it in the COM method table.
    if (pTemplate->m_pClassComMT->IsComVisible())
    TryGenerateClassItfGuid(TypeHandle(pMT), &pTemplate->m_pClassComMT->m_IID);

    // Notify profiler of the CCW, so it can avoid double-counting.
    if (CORProfilerTrackCCW())
    {
        EEClass *pClass = pMT->GetClass();
        SLOT *pComVtable = (SLOT *)(pTemplate->m_pClassComMT + 1);

#if defined(_DEBUG)
        WCHAR rIID[40]; // {00000000-0000-0000-0000-000000000000}
        GuidToLPWSTR(pTemplate->m_pClassComMT->m_IID, rIID, lengthof(rIID));
        LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableCreated Class:%hs, IID:%ls, vTbl:%#08x\n", 
             pClass->m_szDebugClassName, rIID, pComVtable));
#else
        LOG((LF_CORPROF, LL_INFO100, "COMClassicVTableCreated Class:%#x, IID:{%08x-...}, vTbl:%#08x\n", 
             pClass, pTemplate->m_pClassComMT->m_IID.Data1, pComVtable));
#endif
        g_profControlBlock.pProfInterface->COMClassicVTableCreated(
            (ClassID) TypeHandle(pClass).AsPtr(), pTemplate->m_pClassComMT->m_IID, pComVtable,
            pTemplate->m_pClassComMT->m_cbSlots +
                ComMethodTable::GetNumExtraSlots(pTemplate->m_pClassComMT->GetInterfaceType()),
            (ThreadID) GetThread());
    }

    // Release the lock now that we have finished setting up the ComCallWrapperTemplate for 
    // the class.
    g_pCreateWrapperTemplateCrst->Leave();
    return pTemplate;
}

ComMethodTable* ComCallWrapperTemplate::GetComMTForItf(MethodTable *pItfMT)
{
    // Look through all the implemented interfaces to see if the specified 
    // one is present.
    for (UINT iItf = 0; iItf < m_cbInterfaces; iItf++)
    {
        ComMethodTable *pItfComMT = (ComMethodTable *)m_rgpIPtr[iItf] - 1;
        if (pItfComMT->m_pMT == pItfMT)
            return pItfComMT;
    }

    // The class does not implement the specified interface.
    return NULL;
}

//--------------------------------------------------------------------------
// ComCallWrapperTemplate* ComCallWrapperTemplate::GetTemplate(MethodTable* pMT)
// look for a template in the method table, if not create one
//--------------------------------------------------------------------------
ComCallWrapperTemplate* ComCallWrapperTemplate::GetTemplate(MethodTable* pMT)
{
    _ASSERTE(!pMT->IsInterface());

    // Check to see if the specified class already has a template set up.
    ComCallWrapperTemplate* pTemplate = (ComCallWrapperTemplate *)pMT->GetComCallWrapperTemplate();
    if (pTemplate)
        return pTemplate;

    // Create the template and return it. CreateTemplate will take care of synchronization.
    return CreateTemplate(pMT);
}

//--------------------------------------------------------------------------
// ComMethodTable *ComCallWrapperTemplate::SetupComMethodTableForClass(MethodTable *pMT)
// Sets up the wrapper template for the speficied class and sets up a COM 
// method table for the IClassX interface of the specified class. If the 
// bLayOutComMT flag is set then if the IClassX COM method table has not 
// been laid out yet then it will be.
//--------------------------------------------------------------------------
ComMethodTable *ComCallWrapperTemplate::SetupComMethodTableForClass(MethodTable *pMT, BOOL bLayOutComMT)
{
    _ASSERTE(!pMT->IsInterface());

    // Retrieve the COM call wrapper template for the class.
    ComCallWrapperTemplate *pTemplate = GetTemplate(pMT);
    if (!pTemplate)
        return NULL;

    // Retrieve the IClassX COM method table.
    ComMethodTable *pIClassXComMT = pTemplate->GetClassComMT();
    _ASSERTE(pIClassXComMT);

    // Lay out the IClassX COM method table if it hasn't been laid out yet and
    // the bLayOutComMT flag is set.
    if (!pIClassXComMT->IsLayoutComplete() && bLayOutComMT)
    {
        if (!pIClassXComMT->LayOutClassMethodTable())
            return NULL;
        _ASSERTE(pIClassXComMT->IsLayoutComplete());
    }

    return pIClassXComMT;
}

//--------------------------------------------------------------------------
// void ComCallWrapperTemplate::CleanupComData(LPVOID pvoid)
// walk the list, and free all vtables and stubs
// free wrapper
//--------------------------------------------------------------------------
void ComCallWrapperTemplate::CleanupComData(LPVOID pvoid)
{
    if (pvoid != NULL)
    {
        ComCallWrapperTemplate* pTemplate = (ComCallWrapperTemplate*)pvoid;        
        pTemplate->Release();
    }
}

//--------------------------------------------------------------------------
// COM called wrappers on COM+ objects
//  Purpose: Expose COM+ objects as COM classic Interfaces
//  Reqmts:  Wrapper has to have the same layout as the COM2 interface
//                      
//  The wrapper objects are aligned at 16 bytes, and the original this
//  pointer is replicated every 16 bytes, so for any COM2 interface
//  within the wrapper, the original 'this' can be obtained by masking
//  low 4 bits of COM2 IP.
//
//           16 byte aligned                            COM2 Vtable 
//           +-----------+
//           | Org. this |       
//           +-----------+                              +-----+
// COM2 IP-->| VTable ptr|----------------------------->|slot1|
//           +-----------+           +-----+            +-----+
// COM2 IP-->| VTable ptr|---------->|slot1|            |slot2|
//           +-----------+           +-----+            +     +
//           | VTable ptr|           | ....|            | ... |
//           +-----------+           +     +            +     +
//           | Org. this |           |slotN|            |slotN|
//           +           +           +-----+            +-----+ 
//           |  ....     |
//           +           +
//           |  |
//           +-----------+
//  
//
//  VTable and Stubs: can share stub code, we need to have different vtables
//                    for different interfaces, so the stub can jump to different
//                    marshalling code.
//  Stubs : adjust this pointer and jump to the approp. address,
//  Marshalling params and results, based on the method signature the stub jumps to
//  approp. code to handle marshalling and unmarshalling.
//  
//--------------------------------------------------------------------------

// the following 2 methods are applicable only 
// when the com+ class extends from COM class

//--------------------------------------------------------------------------
// void ComCallWrapper::SetComPlusWrapper(ComPlusWrapper* pPlusWrap);
//  set ComPlusWrapper for base COM class
//--------------------------------------------------------------------------
void ComCallWrapper::SetComPlusWrapper(ComPlusWrapper* pPlusWrap)
{
    if (pPlusWrap)
    {
        // mark the complus wrapper as linked
        pPlusWrap->MarkLinkedToCCW();
    }
    GetSimpleWrapper(this)->SetComPlusWrapper(pPlusWrap);
}


//--------------------------------------------------------------------------
// ComPlusWrapper* ComCallWrapper::GetComPlusWrapper()
//  get ComPlusWrapper for base COM class
//--------------------------------------------------------------------------
ComPlusWrapper* ComCallWrapper::GetComPlusWrapper()
{
    ComPlusWrapper* pPlusWrap = GetSimpleWrapper(this)->GetComPlusWrapper();
    if (pPlusWrap)
    {
        _ASSERTE(pPlusWrap->IsLinkedToCCW());
    }
    return pPlusWrap;
}

//--------------------------------------------------------------------------
// void ComCallWrapper::MarkHandleWeak()
//  mark the wrapper as holding a weak handle to the object
//--------------------------------------------------------------------------

void ComCallWrapper::MarkHandleWeak()
{
    _ASSERTE(! IsUnloaded());
    SyncBlock* pSyncBlock = GetSyncBlock();
    _ASSERTE(pSyncBlock);

    GetSimpleWrapper(this)->MarkHandleWeak();
}

//--------------------------------------------------------------------------
// void ComCallWrapper::ResetHandleStrength()
//  mark the wrapper as not having a weak handle
//--------------------------------------------------------------------------

void ComCallWrapper::ResetHandleStrength()
{
    _ASSERTE(! IsUnloaded());
    SyncBlock* pSyncBlock = GetSyncBlock();
    _ASSERTE(pSyncBlock);

    GetSimpleWrapper(this)->ResetHandleStrength();
}


//--------------------------------------------------------------------------
//  BOOL ComCallWrapper::BOOL IsHandleWeak()
// check if the wrapper has been deactivated
//--------------------------------------------------------------------------
BOOL ComCallWrapper::IsHandleWeak()
{
    unsigned sindex = 1;
    if (IsLinked(this))
    {
        sindex = 2;
    }
    SimpleComCallWrapper* pSimpleWrap = (SimpleComCallWrapper *)m_rgpIPtr[sindex];
    
    return pSimpleWrap->IsHandleWeak();
}

//--------------------------------------------------------------------------
// void ComCallWrapper::InitializeOuter(IUnknown* pOuter)
// init outer unknown, aggregation support
//--------------------------------------------------------------------------
void ComCallWrapper::InitializeOuter(IUnknown* pOuter)
{
    GetSimpleWrapper(this)->InitOuter(pOuter);
}


//--------------------------------------------------------------------------
// BOOL ComCallWrapper::IsAggregated()
// check if the wrapper is aggregated
//--------------------------------------------------------------------------
BOOL ComCallWrapper::IsAggregated()
{
    return GetSimpleWrapper(this)->IsAggregated();
}


//--------------------------------------------------------------------------
// BOOL ComCallWrapper::IsObjectTP()
// check if the wrapper is to a TP object
//--------------------------------------------------------------------------
BOOL ComCallWrapper::IsObjectTP()
{
    return GetSimpleWrapper(this)->IsObjectTP();
}



//--------------------------------------------------------------------------
// BOOL ComCallWrapper::IsExtendsCOMObject(()
// check if the wrapper is to a managed object that extends a com object
//--------------------------------------------------------------------------
BOOL ComCallWrapper::IsExtendsCOMObject()
{
    return GetSimpleWrapper(this)->IsExtendsCOMObject();
}

//--------------------------------------------------------------------------
// HRESULT ComCallWrapper::GetInnerUnknown(void** ppv)
// aggregation support, get inner unknown
//--------------------------------------------------------------------------
HRESULT ComCallWrapper::GetInnerUnknown(void **ppv)
{
    _ASSERTE(ppv != NULL);
    _ASSERTE(GetSimpleWrapper(this)->GetOuter() != NULL);
    return GetSimpleWrapper(this)->GetInnerUnknown(ppv);
}

//--------------------------------------------------------------------------
// IUnknown* ComCallWrapper::GetInnerUnknown()
// aggregation support, get inner unknown
//--------------------------------------------------------------------------
IUnknown* ComCallWrapper::GetInnerUnknown()
{
    _ASSERTE(GetSimpleWrapper(this)->GetOuter() != NULL);
    return GetSimpleWrapper(this)->GetInnerUnknown();
}

//--------------------------------------------------------------------------
// Get Outer Unknown on the correct thread
//--------------------------------------------------------------------------
IUnknown* ComCallWrapper::GetOuter()
{
    return GetSimpleWrapper(this)->GetOuter();
}

//--------------------------------------------------------------------------
// SyncBlock* ComCallWrapper::GetSyncBlock()
//--------------------------------------------------------------------------
SyncBlock* ComCallWrapper::GetSyncBlock()
{
    return GetSimpleWrapper(this)->GetSyncBlock();
}

//--------------------------------------------------------------------------
// ComCallWrapper* ComCallWrapper::GetStartWrapper(ComCallWrapper* pWrap)
// get outermost wrapper, given a linked wrapper
// get the start wrapper from the sync block
//--------------------------------------------------------------------------
ComCallWrapper* ComCallWrapper::GetStartWrapper(ComCallWrapper* pWrap)
{
    _ASSERTE(IsLinked(pWrap));
    
    Thread *pThread = GetThread();

    unsigned fToggle = 1;
    if (pThread)
        fToggle = pThread->PreemptiveGCDisabled();
    if (!fToggle)
    {
        // disable GC
        pThread->DisablePreemptiveGC();    
    }
    
    pWrap = (ComCallWrapper*)pWrap->GetObjectRefRareRaw()->GetSyncBlockSpecial()->GetComCallWrapper();
   
    if (!fToggle)
    {
        pThread->EnablePreemptiveGC();
    }
    return pWrap;
}

//--------------------------------------------------------------------------
//ComCallWrapper* ComCallWrapper::CopyFromTemplate(ComCallWrapperTemplate* pTemplate, 
//                                                 OBJECTREF* pRef)
//  create a wrapper and initialize it from the template
//--------------------------------------------------------------------------
ComCallWrapper* ComCallWrapper::CopyFromTemplate(ComCallWrapperTemplate* pTemplate, 
                                                 ComCallWrapperCache *pWrapperCache,
                                                 OBJECTHANDLE oh)
{
    _ASSERTE(pTemplate != NULL);

    // num interfaces on the object    
    size_t numInterfaces = pTemplate->m_cbInterfaces;

    // we have a template, create a wrapper and initialize from the template
    // alloc wrapper, aligned 32 bytes
    ComCallWrapper* pStartWrapper = (ComCallWrapper*)pWrapperCache->GetCacheLineAllocator()->GetCacheLine32();
        
    if (pStartWrapper != NULL)
    {
        LOG((LF_INTEROP, LL_INFO100, "ComCallWrapper::CopyFromTemplate on Object %8.8x, Wrapper %8.8x\n", oh, pStartWrapper));
        // addref commgr
        pWrapperCache->AddRef();
        // init ref count
        pStartWrapper->m_cbRefCount = enum_RefMask; // Initialize to enum_RefMask since its a ref count to start with.
        // store the object handle
        pStartWrapper->m_ppThis = oh;
     
        unsigned blockIndex = 0;
        if (IsMultiBlock(numInterfaces))
        {// ref count in the first slot
            pStartWrapper->m_rgpIPtr[blockIndex++] = 0;
        }
        pStartWrapper->m_rgpIPtr[blockIndex++] = (SLOT *)(pTemplate->GetClassComMT() + 1);
        pStartWrapper->m_rgpIPtr[blockIndex++] = (SLOT *)0; // store the simple wrapper here
        

        ComCallWrapper* pWrapper = pStartWrapper;
        for (unsigned i =0; i< numInterfaces; i++)
        {
            if (blockIndex >= NumVtablePtrs)
            {
                // alloc wrapper, aligned 32 bytes
                ComCallWrapper* pNewWrapper =  
                    (ComCallWrapper*)pWrapperCache->GetCacheLineAllocator()->GetCacheLine32(); 
            
                // Link the wrapper
                SetNext(pWrapper, pNewWrapper);
            
                blockIndex = 0; // reset block index
                if (pNewWrapper == NULL)
                {
                    Cleanup(pStartWrapper);
                    return NULL;
                }
                pWrapper = pNewWrapper;
                // initialize the object reference
                pWrapper->m_ppThis = oh;
            }
            
            pWrapper->m_rgpIPtr[blockIndex++] = pTemplate->m_rgpIPtr[i];
        }
        if (IsLinked(pStartWrapper))
                SetNext(pWrapper, NULL); // link the last wrapper to NULL
    }
    return pStartWrapper;

}

//--------------------------------------------------------------------------
// void ComCallWrapper::Cleanup(ComCallWrapper* pWrap)
// clean up , release gc registered reference and free wrapper
//--------------------------------------------------------------------------
void ComCallWrapper::Cleanup(ComCallWrapper* pWrap)
{    
    LOG((LF_INTEROP, LL_INFO100, "ComCallWrapper::Cleanup on wrapper %8.8x\n", pWrap));
    if (GetRefCount(pWrap, TRUE) != 0)
    {
        // _ASSERTE(g_fEEShutDown == TRUE);
        // could be either in shutdown or forced GC in appdomain unload
        // there are external COM references to this wrapper
        // so let us just forget about cleaning now
        // when the ref-count reaches 0, we will
        // do the cleanup anyway
        return;
    }

    unsigned sindex = 1;
    if (IsLinked(pWrap))
    {
        sindex = 2;
        //pWrap = GetStartWrapper(pWrap);
    }
    
    SimpleComCallWrapper* pSimpleWrap = (SimpleComCallWrapper *)pWrap->m_rgpIPtr[sindex];
  
    ComCallWrapperCache *pWrapperCache = NULL;
    _ASSERTE(pSimpleWrap);

    // Retrieve the COM call wrapper cache before we nuke anything
    pWrapperCache = pSimpleWrap->GetWrapperCache();

    ComPlusWrapper* pPlusWrap = pSimpleWrap->GetComPlusWrapper();
    if (pPlusWrap)
    {
        // Remove the COM+ wrapper from the cache.
        ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();
        _ASSERTE(pCache);

        pCache->LOCK();
        pCache->RemoveWrapper(pPlusWrap);
        pCache->UNLOCK();

        // Cleanup the COM+ wrapper.
        pPlusWrap->Cleanup();
    }

    // get this info before the simple wrapper gets nuked.
    AppDomain *pTgtDomain = NULL;
    BOOL fIsAgile = FALSE;
    if (pSimpleWrap)
    {
        pTgtDomain = pSimpleWrap->GetDomainSynchronized();
        fIsAgile = pSimpleWrap->IsAgile();
        pSimpleWrap->Cleanup();
    }

    if (g_RefCount != 0 || pSimpleWrap->GetOuter() == NULL) 
    {
        SimpleComCallWrapper::FreeSimpleWrapper(pSimpleWrap);
        pWrap->m_rgpIPtr[sindex] = NULL;
    }

    // deregister the handle, in the first block. If no domain, then it's already done
    if (pWrap->m_ppThis && pTgtDomain)
    {
        LOG((LF_INTEROP, LL_INFO100, "ComCallWrapper::Cleanup on Object %8.8x\n", pWrap->m_ppThis));
        //@todo this assert is not valid during process shutdown
        // detect that as special case and reenable the assert
        //_ASSERTE(*(Object **)pWrap->m_ppThis == NULL);
        DestroyRefcountedHandle(pWrap->m_ppThis);
    }
    pWrap->m_ppThis = NULL;
    FreeWrapper(pWrap, pWrapperCache);
}

//--------------------------------------------------------------------------
// void ComCallWrapper::FreeWrapper(ComCallWrapper* pWrap)
// walk the list and free all wrappers
//--------------------------------------------------------------------------
void ComCallWrapper::FreeWrapper(ComCallWrapper* pWrap, ComCallWrapperCache *pWrapperCache)
{
    BEGIN_ENSURE_PREEMPTIVE_GC();
    pWrapperCache->LOCK();
    END_ENSURE_PREEMPTIVE_GC();

    ComCallWrapper* pWrap2 = (IsLinked(pWrap) != 0) ? GetNext(pWrap) : NULL;
        
    while (pWrap2 != NULL)
    {           
        ComCallWrapper* pTempWrap = GetNext(pWrap2);
        pWrapperCache->GetCacheLineAllocator()->FreeCacheLine32(pWrap2);
        pWrap2 = pTempWrap;
    }

    pWrapperCache->GetCacheLineAllocator()->FreeCacheLine32(pWrap);

    pWrapperCache->UNLOCK();

    // release ccw mgr
    pWrapperCache->Release();
}

EEClass* RefineProxy(OBJECTREF pServer)
{
    EEClass* pRefinedClass = NULL;
    GCPROTECT_BEGIN(pServer);
    TRIGGERSGC();
    if (pServer->GetMethodTable()->IsTransparentProxyType())
    {
        // if we have a transparent proxy let us refine it fully 
        // before giving it out to unmanaged code
        REFLECTCLASSBASEREF refClass= CRemotingServices::GetClass(pServer);
        pRefinedClass = ((ReflectClass *)refClass->GetData())->GetClass();
    }
    GCPROTECT_END();
    return pRefinedClass;
}


//--------------------------------------------------------------------------
//ComCallWrapper* ComCallWrapper::CreateWrapper(OBJECTREF* ppObj )
// this function should be called only with pre-emptive GC disabled
// GCProtect the object ref being passed in, as this code could enable gc
//--------------------------------------------------------------------------
ComCallWrapper* ComCallWrapper::CreateWrapper(OBJECTREF* ppObj )
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    _ASSERTE(*ppObj);

    ComCallWrapper* pStartWrapper = NULL;
    OBJECTREF pServer = NULL;
    GCPROTECT_BEGIN(pServer); 

    Context *pContext = GetExecutionContext(*ppObj, &pServer);
    if(pServer == NULL)
        pServer = *ppObj;

    // Force Refine the object if it is a transparent proxy
    RefineProxy(pServer);
     
    // grab the sync block from the server
    SyncBlock* pSyncBlock = pServer->GetSyncBlockSpecial();
    _ASSERTE(pSyncBlock);
    pSyncBlock->SetPrecious();
        
    // if the object belongs to a shared class, need to allocate the wrapper in the default domain. 
    // The object is potentially agile so if allocate out of the current domain and then hand out to 
    // multiple domains we might never release the wrapper for that object and hence never unload the CCWC.
    ComCallWrapperCache *pWrapperCache = NULL;
    MethodTable* pMT = pServer->GetTrueMethodTable();
    if (pMT->IsShared())
        pWrapperCache = SystemDomain::System()->DefaultDomain()->GetComCallWrapperCache();
    else
        pWrapperCache = pContext->GetDomain()->GetComCallWrapperCache();

    pThread->EnablePreemptiveGC();

    //enter Lock
    pWrapperCache->LOCK();

    pThread->DisablePreemptiveGC();

    // check if somebody beat us to it    
    pStartWrapper = GetWrapperForObject(pServer);

    if (pStartWrapper == NULL)
    {
        // need to create a wrapper

        // get the template wrapper
        ComCallWrapperTemplate *pTemplate = ComCallWrapperTemplate::GetTemplate(pMT);
        if (pTemplate == NULL)
            goto LExit; // release the lock and exit

        // create handle for the object. This creates a handle in the current domain. We can't tell
        // if the object is agile in non-checked, so we trust that our checking works and when we 
        // attempt to hand this out to another domain then we will assume that the object is truly
        // agile and will convert the handle to a global handle.
        OBJECTHANDLE oh = pContext->GetDomain()->CreateRefcountedHandle( NULL );
         _ASSERTE(oh);

        // copy from template
        pStartWrapper = CopyFromTemplate(pTemplate, pWrapperCache, oh);
        if (pStartWrapper != NULL)
        {
            SimpleComCallWrapper * pSimpleWrap = SimpleComCallWrapper::CreateSimpleWrapper();
            if (pSimpleWrap != NULL)
            {
                pSimpleWrap->InitNew(pServer, pWrapperCache, pStartWrapper, pContext, pSyncBlock, pTemplate);
                ComCallWrapper::SetSimpleWrapper(pStartWrapper, pSimpleWrap);
            }
            else
            {
                // oops couldn't allocate simple wrapper
                // let us just bail out
                Cleanup(pStartWrapper);
                pStartWrapper = NULL;
                //@TODO should we throw?
            }
        }

        //store the wrapper for the object, in the sync block
        pSyncBlock->SetComCallWrapper( pStartWrapper);

        // Finally, store the object in the handle.  
        // Note that we cannot do this safely until we've populated the sync block,
        // due to logic in the refcounted handle scanning code.
        StoreObjectInHandle( oh, pServer );
    }

LExit:
    // leave lock
    pWrapperCache->UNLOCK();
    GCPROTECT_END();

    return pStartWrapper;
}

// if the object we are creating is a proxy to another appdomain, want to create the wrapper for the
// new object in the appdomain of the proxy target
Context* ComCallWrapper::GetExecutionContext(OBJECTREF pObj, OBJECTREF* pServer )
{
    Context *pContext = NULL;

    if (pObj->GetMethodTable()->IsTransparentProxyType()) 
        pContext = CRemotingServices::GetServerContextForProxy(pObj);

    if (pContext == NULL)
        pContext = GetAppDomain()->GetDefaultContext();

    return pContext;
}


//--------------------------------------------------------------------------
// signed ComCallWrapper::GetIndexForIID(REFIID riid, MethodTable *pMT, MethodTable **ppIntfMT)
//  check if the interface is supported, return a index into the IMap
//  returns -1, if riid is not supported
//--------------------------------------------------------------------------
signed ComCallWrapper::GetIndexForIID(REFIID riid, MethodTable *pMT, MethodTable **ppIntfMT)
{
    _ASSERTE(ppIntfMT != NULL);
    _ASSERTE(pMT);

    ComCallWrapperTemplate *pTemplate = (ComCallWrapperTemplate *)pMT->GetComCallWrapperTemplate();
    _ASSERTE(pTemplate);

    InterfaceInfo_t* rgIMap = pMT->GetInterfaceMap();
    unsigned len = pMT->GetNumInterfaces();    

    // Go through all the implemented methods except the COM imported class interfaces
    // and compare the IID's to find the requested one.
    for (unsigned i = 0; i < len; i++)
    {
        ComMethodTable *pItfComMT = (ComMethodTable *)pTemplate->m_rgpIPtr[i] - 1;
        if(pItfComMT->m_IID == riid && !pItfComMT->IsComClassItf())
        {
            *ppIntfMT = rgIMap[i].m_pMethodTable;
            return i;
        }
    }

    // oops, iface not found
    return  -1;
}

//--------------------------------------------------------------------------
// signed ComCallWrapper::GetIndexForIntfMT(MethodTable *pMT, MethodTable *ppIntfMT)
//  check if the interface is supported, return a index into the IMap
//  returns -1, if riid is not supported
//--------------------------------------------------------------------------
signed ComCallWrapper::GetIndexForIntfMT(MethodTable *pMT, MethodTable *pIntfMT)
{
    _ASSERTE(pIntfMT != NULL);
    InterfaceInfo_t* rgIMap = pMT->GetInterfaceMap();
    unsigned len = pMT->GetNumInterfaces();    

    for (unsigned i =0; i < len; i++)
    {
        if(rgIMap[i].m_pMethodTable == pIntfMT)
        {            
            return i;
        }
    }
    // oops, iface not found
    return  -1;
}

//--------------------------------------------------------------------------
// SLOT** ComCallWrapper::GetComIPLocInWrapper(ComCallWrapper* pWrap, unsigned iIndex)
//  identify the location within the wrapper where the vtable for this index will
//  be stored
//--------------------------------------------------------------------------
SLOT** ComCallWrapper::GetComIPLocInWrapper(ComCallWrapper* pWrap, unsigned iIndex)
{
    _ASSERTE(pWrap != NULL);

    SLOT** pTearOff = NULL;
    while (iIndex >= NumVtablePtrs)
    {
        //@todo delayed creation support
        _ASSERTE(IsLinked(pWrap) != 0);
        pWrap = GetNext(pWrap);
        iIndex-= NumVtablePtrs;
    }
    _ASSERTE(pWrap != NULL);
    pTearOff = (SLOT **)&pWrap->m_rgpIPtr[iIndex];
    return pTearOff;
}

//--------------------------------------------------------------------------
// Get IClassX interface pointer from the wrapper. This method will also
// lay out the IClassX COM method table if it has not yet been laid out.
// The returned interface is AddRef'd.
//--------------------------------------------------------------------------
IUnknown* ComCallWrapper::GetIClassXIP()
{
    // Linked wrappers use up an extra slot in the first block
    // to store the ref-count
    ComCallWrapper *pWrap = this;
    IUnknown *pIntf = NULL;
    unsigned fIsLinked = IsLinked(pWrap);
    int islot = fIsLinked ? 1 : 0;

    // The IClassX VTable pointer is in the start wrapper.
    if (fIsLinked)
        pWrap = ComCallWrapper::GetStartWrapper(pWrap);

    // Lay out of the IClassX COM method table if it has not yet been laid out.
    ComMethodTable *pIClassXComMT = (ComMethodTable*)pWrap->m_rgpIPtr[islot] - 1;
    if (!pIClassXComMT->IsLayoutComplete())
    {
        if (!pIClassXComMT->LayOutClassMethodTable())
            return NULL;
    }

    // Return the IClassX vtable pointer.
    pIntf = (IUnknown*)&pWrap->m_rgpIPtr[islot];

    ULONG cbRef = pIntf->AddRef();        
    // 0xbadF00d implies the AddRef didn't go through
    return (cbRef != 0xbadf00d) ? pIntf : NULL; 
}

//--------------------------------------------------------------------------
// Get the IClassX method table from the wrapper.
//--------------------------------------------------------------------------
ComMethodTable *ComCallWrapper::GetIClassXComMT()
{
    // Linked wrappers use up an extra slot in the first block
    // to store the ref-count
    ComCallWrapper *pWrap = this;
    unsigned fIsLinked = IsLinked(pWrap);
    int islot = fIsLinked ? 1 : 0;

    // The IClassX VTable pointer is in the start wrapper.
    if (fIsLinked)
        pWrap = ComCallWrapper::GetStartWrapper(pWrap);

    // Return the COM method table for the IClassX.
    return (ComMethodTable*)pWrap->m_rgpIPtr[islot] - 1;
}

//--------------------------------------------------------------------------
// IUnknown* ComCallWrapper::GetComIPfromWrapper(ComCallWrapper *pWrap, REFIID riid, MethodTable* pIntfMT, BOOL bCheckVisibility)
// Get an interface from wrapper, based on riid or pIntfMT. The returned interface is AddRef'd.
//--------------------------------------------------------------------------
IUnknown* ComCallWrapper::GetComIPfromWrapper(ComCallWrapper *pWrap, REFIID riid, MethodTable* pIntfMT, BOOL bCheckVisibility)
{
    _ASSERTE(pWrap);
    _ASSERTE(pIntfMT || !IsEqualGUID(riid, GUID_NULL));

    THROWSCOMPLUSEXCEPTION();

    IUnknown* pIntf = NULL;
    ComMethodTable *pIntfComMT = NULL;

    // some interface like IID_IManaged are special and are available
    // in the simple wrapper, so even if the class implements this,
    // we will ignore it and use our implementation
    BOOL fIsSimpleInterface = FALSE;
    
    // linked wrappers use up an extra slot in the first block
    // to store the ref-count
    unsigned fIsLinked = IsLinked(pWrap);
    int islot = fIsLinked ? 1 : 0;

    // scan the wrapper
    if (fIsLinked)
        pWrap = ComCallWrapper::GetStartWrapper(pWrap);

    if (IsEqualGUID(IID_IUnknown, riid))
    {    
        // We don't do visibility checks on IUnknown.
        pIntf = pWrap->GetIClassXIP();
        goto LExit;
    }
    else if (IsEqualGUID(IID_IDispatch, riid))
    {
        // We don't do visibility checks on IDispatch.
        pIntf = pWrap->GetIDispatchIP();
        goto LExit;
    }
    else
    {   
        // If we are aggregated and somehow the aggregator delegated a QI on
        // IManagedObject to us, fail the request so we don't accidently get a
        // COM+ caller linked directly to us.
        if ((IsEqualGUID(riid, IID_IManagedObject)))
        {
            // @TODO 
            // object pooling requires us to get to the underlying TP
            // so special case TPs to expose IManagedObjects
            if (!pWrap->IsObjectTP() && GetSimpleWrapper(pWrap)->GetOuter() != NULL)
                goto LExit;
                            
            fIsSimpleInterface = TRUE;
        }
        
        Thread *pThread = GetThread(); 
        unsigned fToggleGC = !pThread->PreemptiveGCDisabled();
        if (fToggleGC)
            pThread->DisablePreemptiveGC();    

        OBJECTREF pObj = pWrap->GetObjectRef();
        MethodTable *pMT = pObj->GetTrueMethodTable();
    
        if (fToggleGC)
            pThread->EnablePreemptiveGC();

        signed imapIndex = -1;
        if(pIntfMT == NULL)
        {
            // check the interface map for an index     
            if (!fIsSimpleInterface)
            {
                imapIndex = GetIndexForIID(riid, pMT, &pIntfMT);
            }
            if (imapIndex == -1)
            {
                // Check for the standard interfaces.
                SimpleComCallWrapper* pSimpleWrap = ComCallWrapper::GetSimpleWrapper(pWrap);
                _ASSERTE(pSimpleWrap != NULL);
                pIntf = SimpleComCallWrapper::QIStandardInterface(pSimpleWrap, riid);
                if (pIntf)
                    goto LExit;

                // Check if IID is one of IClassX IIDs.
                if (IsIClassX(pMT, riid, &pIntfComMT))
                {
                    // If the class that this IClassX's was generated for is marked 
                    // as ClassInterfaceType.AutoDual then give out the IClassX IP.
                    if (pIntfComMT->GetClassInterfaceType() == clsIfAutoDual || pIntfComMT->GetClassInterfaceType() == clsIfAutoDisp)
                    {
                        // Giveout IClassX
                        pIntf = pWrap->GetIClassXIP();
                        goto LVisibilityCheck;
                    }
                }
            }
        }
        else
        {
            imapIndex = GetIndexForIntfMT(pMT, pIntfMT);
            if (!pIntfMT->GetClass()->IsInterface())
            {
                // class method table
                if (IsInstanceOf(pMT, pIntfMT))
                {
                    // Retrieve the COM method table for the requested interface.
                    pIntfComMT = ComCallWrapperTemplate::SetupComMethodTableForClass(pIntfMT, FALSE);                   

                    // If the class that this IClassX's was generated for is marked 
                    // as ClassInterfaceType.AutoDual then give out the IClassX IP.
                    if (pIntfComMT->GetClassInterfaceType() == clsIfAutoDual || pIntfComMT->GetClassInterfaceType() == clsIfAutoDisp)
                    {
                        // Giveout IClassX
                        pIntf = pWrap->GetIClassXIP();
                        goto LVisibilityCheck;
                    }
                }
            }
        }

        unsigned intfIndex = imapIndex;
        if (imapIndex != -1)
        {
            //NOTE::
            // for linked wrappers, the first block has 2 slots for std interfaces
            // IDispatch and IMarshal, one extra slot in the first block
            // is used for ref-count
            imapIndex += fIsLinked ? 3 : 2; // for std interfaces
        }

        // COM plus objects that extend from COM guys are special
        // unless the CCW points a TP in which case the COM object
        // is remote, so let the calls go through the CCW
        if (pWrap->IsExtendsCOMObject() && !pWrap->IsObjectTP())
        {
            ComPlusWrapper* pPlusWrap = pWrap->GetComPlusWrapper(); 
            _ASSERTE(pPlusWrap != NULL);            
            if (imapIndex != -1)
            {
                // Check if this index is actually an interface implemented by us
                // if it belongs to the base COM guy then we can hand over the call
                // to him
                BOOL bDelegateToBase = FALSE;
                WORD startSlot = pMT->GetStartSlotForInterface(intfIndex);
                if (startSlot != 0)
                {
                    // For such interfaces all the methoddescs point to method desc 
                    // of the interface classs   (OR) a COM Imported class
                    MethodDesc* pClsMD = pMT->GetClass()->GetUnknownMethodDescForSlot(startSlot);      
                    if (pClsMD->GetMethodTable()->IsInterface() || pClsMD->GetClass()->IsComImport())
                    {
                        bDelegateToBase = TRUE;
                    }
                }
                else
                {
                    // The interface has no methods so we cannot override it. Because of this
                    // it makes sense to delegate to the base COM component. 
                    bDelegateToBase = TRUE;
                }

                if (bDelegateToBase)
                {
                    // oops this is is a method of the base COM guy
                    // so delegate the call to him
                    _ASSERTE(pPlusWrap != NULL);
                    pIntf = (pIntfMT != NULL) ? pPlusWrap->GetComIPFromWrapper(pIntfMT)
                                              : pPlusWrap->GetComIPFromWrapper(riid);
                    goto LExit;
                }                
            }
            else 
            if (pIntfMT != NULL)
            {
                pIntf = pPlusWrap->GetComIPFromWrapper(pIntfMT);
                goto LExit;
            }
            else
            if (!IsEqualGUID(riid, GUID_NULL))
            {
                pIntf = pPlusWrap->GetComIPFromWrapper(riid);
                if (pIntf == NULL)
                {
                    // Retrieve the IUnknown pointer for the RCW.
                    IUnknown *pUnk2 = pPlusWrap->GetIUnknown();

                    // QI for the requested interface.
                    HRESULT hr = pPlusWrap->SafeQueryInterfaceRemoteAware(pUnk2, riid, &pIntf);
                    LogInteropQI(pUnk2, riid, hr, "delegate QI for intf");
                    _ASSERTE((!!SUCCEEDED(hr)) == (pIntf != 0));

                    // Release the IUnknown pointer we got from the RCW.
                    ULONG cbRef = SafeRelease(pUnk2);
                    LogInteropRelease(pUnk2, cbRef, "Release after delegate QI for intf");
                }
                goto LExit;
            }
        }

          // check if interface is supported
        if (imapIndex == -1)
            goto LExit;

        // interface method table != NULL
        _ASSERTE(pIntfMT != NULL); 

        // IUnknown* loc within the wrapper
        SLOT** ppVtable = GetComIPLocInWrapper(pWrap, imapIndex);   
        _ASSERTE(ppVtable != NULL);
        _ASSERTE(*ppVtable != NULL); // this should point to COM Vtable or interface vtable
    
        // Finish laying out the interface COM method table if is has not been done yet.
        ComMethodTable *pItfComMT = ComMethodTable::ComMethodTableFromIP((IUnknown*)ppVtable);
        if (!pItfComMT->IsLayoutComplete())
        {
            if (!pItfComMT->LayOutInterfaceMethodTable(pMT, intfIndex))
                goto LExit;
        }

        // The interface pointer is the pointer to the vtable.
        pIntf = (IUnknown*)ppVtable;
    
        ULONG cbRef = pIntf->AddRef();        
        // 0xbadF00d implies the AddRef didn't go through

        if (cbRef == 0xbadf00d)
        {
            pIntf  = NULL; 
            goto LExit;
        }
        
        // Retrieve the COM method table from the interface.
        pIntfComMT = ComMethodTable::ComMethodTableFromIP(pIntf);
    }

LVisibilityCheck:
    // At this point we better have an interface pointer.
    _ASSERTE(pIntf);

    // If the bCheckVisibility flag is set then we need to do a visibility check.
    if (bCheckVisibility)
    {
        _ASSERTE(pIntfComMT);
        if (!pIntfComMT->IsComVisible())
        {
            pIntf->Release();
            pIntf = NULL;
        }
    }

LExit:
    return pIntf;
}

//--------------------------------------------------------------------------
// Get the IDispatch interface pointer for the wrapper. 
// The returned interface is AddRef'd.
//--------------------------------------------------------------------------
IDispatch* ComCallWrapper::GetIDispatchIP()
{
    THROWSCOMPLUSEXCEPTION();

    // Retrieve the IClassX method table.
    ComMethodTable *pComMT = GetIClassXComMT();
    _ASSERTE(pComMT);

    // If the class implements IReflect then use the IDispatchEx implementation.
    if (SimpleComCallWrapper::SupportsIReflect(pComMT->m_pMT->GetClass()))
    {
        // The class implements IReflect so lets let it handle IDispatch calls.
        // We will do this by exposing the IDispatchEx implementation of IDispatch.
        SimpleComCallWrapper* pSimpleWrap = ComCallWrapper::GetSimpleWrapper(this);
        _ASSERTE(pSimpleWrap != NULL);
        return (IDispatch *)SimpleComCallWrapper::QIStandardInterface(pSimpleWrap, IID_IDispatchEx);
    }

    // Retrieve the ComMethodTable of the default interface for the class.
    TypeHandle hndDefItfClass;
    DefaultInterfaceType DefItfType = GetDefaultInterfaceForClass(TypeHandle(pComMT->m_pMT), &hndDefItfClass);
    switch (DefItfType)
    {
        case DefaultInterfaceType_Explicit:
        {
            _ASSERTE(!hndDefItfClass.IsNull());
            _ASSERTE(hndDefItfClass.GetClass()->IsInterface());            
            if (hndDefItfClass.GetMethodTable()->GetComInterfaceType() != ifVtable)
            {
                return (IDispatch*)GetComIPfromWrapper(this, GUID_NULL, hndDefItfClass.GetMethodTable(), FALSE);
            }
            else
            {
                return NULL;
            }
        }

        case DefaultInterfaceType_IUnknown:
        {
            return NULL;
        }

        case DefaultInterfaceType_AutoDual:
        case DefaultInterfaceType_AutoDispatch:
        {
            return (IDispatch*)GetIClassXIP();
        }

        case DefaultInterfaceType_BaseComClass:
        {
            return GetComPlusWrapper()->GetIDispatch();
        }

        default:
        {
            _ASSERTE(!"Invalid default interface type!");
            return NULL;
        }
    }
}

ComCallWrapperCache *ComCallWrapper::GetWrapperCache()
{
    return GetSimpleWrapper(this)->GetWrapperCache();
}

//--------------------------------------------------------------------------
// Only install this stub if it is the first to win the race.  Otherwise we must
// dispose of the new one -- some thread is perhaps already using the first one!
//--------------------------------------------------------------------------
void ComCallMethodDesc::InstallFirstStub(Stub** ppStub, Stub *pNewStub)
{
    _ASSERTE(ppStub != NULL);
    _ASSERTE(sizeof(LONG) == sizeof(Stub*));

    // If we don't want this stub anyway, or if someone else already installed a
    // (hopefully equivalent) stub, then toss the one that was passed in.  Note that
    // we can toss it eagerly, since nobody could have started executing on it yet.
    if (FastInterlockCompareExchange((void **) ppStub, pNewStub, 0) != 0)
    {
        pNewStub->DecRef();
    }
}


//--------------------------------------------------------------------------
//  Module* ComCallMethodDesc::GetModule()
//  Get Module
//--------------------------------------------------------------------------
Module* ComCallMethodDesc::GetModule()
{
    _ASSERTE( IsFieldCall() ? (m_pFD != NULL) : (m_pMD != NULL));

    EEClass* pClass = (IsFieldCall()) ? m_pFD->GetEnclosingClass() : m_pMD->GetClass();
    _ASSERTE(pClass != NULL);

    return pClass->GetModule();
}

#ifdef _X86_
unsigned __stdcall ComFailStubWorker(ComPrestubMethodFrame *pPFrame)
{
    ComCallMethodDesc *pCMD = (ComCallMethodDesc*)pPFrame->GetMethodDesc();
    _ASSERTE(pCMD != NULL);
    return pCMD->GuessNativeArgSizeForFailReturn();
    
}

//--------------------------------------------------------------------------
// This function is logically part of ComPreStubWorker(). The only reason
// it's broken out into a separate function is that StubLinker has a destructor
// and thus, we must put an inner COMPLUS_TRY clause to trap any
// COM+ exceptions that would otherwise bypass the StubLinker destructor.
// Because COMPLUS_TRY is based on SEH, VC won't let us use it in the
// same function that declares the StubLinker object.
//--------------------------------------------------------------------------
struct GetComCallMethodStub_Args {
    StubLinkerCPU *psl;
    ComCallMethodDesc *pCMD;
    Stub **pstub;
};

void GetComCallMethodStub_Wrapper(GetComCallMethodStub_Args *args)
{
    *(args->pstub) = ComCall::GetComCallMethodStub(args->psl, args->pCMD);
}

Stub *ComStubWorker(StubLinkerCPU *psl, ComCallMethodDesc *pCMD, ComCallWrapper *pWrap, Thread *pThread, HRESULT *hr)
{
    _ASSERTE(pCMD != NULL && hr != NULL);

    Stub *pstub = NULL;
    // disable GC when we are generating the stub
    // as this could throw an exception
    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        if (! pWrap->NeedToSwitchDomains(pThread, TRUE))
        {
            pstub = ComCall::GetComCallMethodStub(psl,pCMD);
        }
        else
        {
            GetComCallMethodStub_Args args = { psl, pCMD, &pstub };
            // call through DoCallBack with a domain transition
            pThread->DoADCallBack(pWrap->GetObjectContext(pThread), GetComCallMethodStub_Wrapper, &args);
        }
    }
    COMPLUS_CATCH
    {
        *hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH;

    END_ENSURE_COOPERATIVE_GC();

    return pstub;       
}


//--------------------------------------------------------------------------
// This routine is called anytime a com method is invoked for the first time.
// It is responsible for generating the real stub.
//
// This function's only caller is the ComPreStub.
//
// For the duration of the prestub, the current Frame on the stack
// will be a PrestubMethodFrame (which derives from FramedMethodFrame.)
// Hence, things such as exceptions and gc will work normally.
//
// On rare occasions, the ComPrestub may get called twice because two
// threads try to call the same method simultaneously. 
//--------------------------------------------------------------------------
const BYTE * __stdcall ComPreStubWorker(ComPrestubMethodFrame *pPFrame)
{
    Thread* pThread = SetupThread();

    if (pThread == NULL)
        return 0;

    HRESULT hr = E_FAIL;
    const BYTE *retAddr = NULL;

#ifndef _X86_
    _ASSERTE(!"platform NYI");
    goto exit;
#endif

    // The frame we're about to push is not guarded by any COM+ frame
    // handler.  It'll dangle if an exception is thrown through here.
    CANNOTTHROWCOMPLUSEXCEPTION();

    // The PreStub allocates memory for the frame, but doesn't link it
    // into the chain or fully initialize it. Do so now.
    pThread->DisablePreemptiveGC();     
    pPFrame->Push();

    ComCallMethodDesc *pCMD = (ComCallMethodDesc*)pPFrame->GetMethodDesc();
   
    IUnknown        *pUnk = *(IUnknown **)pPFrame->GetPointerToArguments();
    ComCallWrapper  *pWrap =  ComCallWrapper::GetWrapperFromIP(pUnk);
    Stub *pStub = NULL;

    // check for invalid wrappers in the debug build
    // in the retail all bets are off
    _ASSERTE(ComCallWrapper::GetRefCount(pWrap, FALSE) != 0 ||
             pWrap->IsAggregated());

    // ComStubWorker will remove the unload dependency for us
    {
    StubLinkerCPU psl; // need this here because it has destructor so can't put in ComStubWorker
    pStub = ComStubWorker(&psl, pCMD, pWrap, pThread, &hr);
    }

    if (!pStub)
    {
        goto exit;
    }

    // Now, replace the prestub with the new stub. We have to be careful
    // here because it's possible for two threads to be running the
    // prestub simultaneously. We use InterlockedExchange to ensure
    // atomicity of the switchover.

    UINT32* ppofs = ((UINT32*)pCMD) - 1;

    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((size_t)pCMD) & 3) );


    // either another thread or an unload AD could update the stub address, so must take a lock
    // before as don't know which one and must handle differently
    ComCall::LOCK();
    if  (*ppofs == ((UINT32)((size_t)ComCallPreStub - (size_t)pCMD)))
    {
        *ppofs = (UINT32)((size_t)pStub->GetEntryPoint() - (size_t)pCMD);
#if 0
    if (prevofs != ((UINT32)ComCallPreStub - (UINT32)pCMD))
    {
        // If we got here, some thread swooped in and ran the prestub
        // ahead of us. We don't dare DecRef the replaced stub now because he might
        // be still be on that thread's call stack. Just put him on an orphan
        // list to be cleaned up when the class is destroyed. He'll waste some
        // memory but this is a rare case.
        //
        // Furthermore, the only thing we could be replacing is one of the 3 generic
        // stubs.  (One day, we may build precise stubs -- though there's a debate
        // about the space / speed tradeoff).  The generic stubs don't participate
        // in reference counting, so it would be incorrect to register them as
        // orphans.
#ifdef _DEBUG
        Stub *pPrevStub = Stub::RecoverStub((const BYTE *)(prevofs + (UINT32)pCMD));

        _ASSERTE(ComCall::dbg_StubIsGenericComCallStub(pPrevStub));
#endif
    }
#endif
    }
    ComCall::UNLOCK();

exit:
    // Unlink the PrestubMethodFrame.
    pPFrame->Pop();
    pThread->EnablePreemptiveGC();     

    if (pStub)
        // Return to the ASM portion, which will reexecute using the new stub.
        return pStub->GetEntryPoint(); 

    SetLastError(hr);
    return 0;
}


//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
DWORD __stdcall WrapGetLastError()
{
    return GetLastError();
}

//--------------------------------------------------------------------------
// This is the code that all com call method stubs run initially. 
// Most of the real work occurs in ComStubWorker(), a C++ routine.
// The template only does the part that absolutely has to be in assembly
// language.
//--------------------------------------------------------------------------
__declspec(naked)
VOID __cdecl ComCallPreStub()
{
    __asm{
        push    edx                 //;; Leave room for ComMethodFrame.m_Next
        push    edx                 //;; Leave room for ComMethodFrame.vtable
        
        push    ebp                 //;; Save callee saved registers
        push    ebx                 //;; Save callee saved registers
        push    esi                 //;; Save callee saved registers
        push    edi                 //;; Save callee saved registers

        lea     esi, [esp+SIZE CalleeSavedRegisters]     ;; ESI <= ptr to (still incomplete)
                                                         ;;   PrestubMethodFrame.
#ifdef _DEBUG
;;--------------------------------------------------------------------------
;; Under DEBUG, create enough frame info to enable VC to stacktrace through
;; stubs. Note that this precludes use of EBP inside the stub.
;;--------------------------------------------------------------------------
        mov     eax, [esi+SIZE Frame + 4]       ;; get return address
        push    eax
        push    ebp
        mov     ebp, esp
#endif
        push    esi                 ;; Push frame as argument to PreStubWorker.
        lea     eax,ComPreStubWorker   ;; Call PreStubWorker (must call thru
                                    ;;  register to keep the code location-independent)

#ifdef _DEBUG
;;--------------------------------------------------------------------------
;; For DEBUG, call through WrapCall to maintain VC stack tracing.
;;--------------------------------------------------------------------------
        push    eax
        lea     eax, WrapCall
        call    eax
#else
;;--------------------------------------------------------------------------
;; For RETAIL, just call it.
;;--------------------------------------------------------------------------
        call    eax
#endif

//;; now contains replacement stub. ComStubWorker will  return
//;; NULL if stub creation fails
        cmp eax, 0
        je nostub                   ;;oops we couldn't create a stub
        
#ifdef _DEBUG
        add     esp,SIZE VC5Frame  ;; Deallocate VC stack trace info
#endif

        pop     edi                 ;; Restore callee-saved registers
        pop     esi                 ;; Restore callee-saved registers
        pop     ebx                 ;; Restore callee-saved registers
        pop     ebp                 ;; Restore callee-saved registers
        add     esp, SIZE Frame     ;; Deallocate PreStubMethodFrame
        jmp     eax                   ;; Reexecute with replacement stub.

        // never reaches here
        nop



    nostub:

#ifdef PLATFORM_CE
        int     3                   ;; DebugBreak sim. for now
#endif

        lea     esi, [esp+SIZE CalleeSavedRegisters+8]     ;; ESI <= ptr to (still incomplete)
        push    esi                 ;; Push frame as argument to Fail
        call    ComFailStubWorker   ;; // call failure routine, returns bytes to pop

#ifdef _DEBUG
        add     esp,SIZE VC5Frame  ;; Deallocate VC stack trace info
#endif

        pop     edi                 ;; Restore callee-saved registers
        pop     esi                 ;; Restore callee-saved registers
        pop     ebx                 ;; Restore callee-saved registers
        pop     ebp                 ;; Restore callee-saved registers
        add     esp, SIZE Frame     ;; Deallocate PreStubMethodFrame
        pop     ecx                 ;; method desc
        pop     ecx                 ;; return address
        add     esp, eax            ;; // pop bytes of the stack
        push    ecx                 ;; return address

        // Old comment: We want to generate call dword ptr [GetLastError] since BBT doesn't like the 
        // direct asm call, so stop asm , make the call and return...
        // New comment: Too bad, mixing source and asm like this creates code
        // that trashes a preserved register on checked. So we'll shunt that
        // off to a wrapper fcn so we generate the right import thunk call but
        // don't expose ourselves to asm/C++ mixing issues.

        call    WrapGetLastError    ;; eax <-- lasterror
        ret
    }
}

/*--------------------------------------------------------------------------
    This method is dependent on ComCallPreStub(), therefore it's implementation
    is done right next to it. Similar to FramedMethodFrame::UpdateRegDisplay.
    Note that in rare IJW cases, the immediate caller could be a managed method
    which pinvoke-inlined a call to a COM interface, which happenned to be
    implemented by a managed function via COM-interop. Hence the stack-walker
    needs ComPrestubMethodFrame::UpdateRegDisplay() to work correctly.
*/

void ComPrestubMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();

    // reset pContext; it's only valid for active (top-most) frame

    pRD->pContext = NULL;


    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp  = (DWORD)((size_t)pRD->pPC + sizeof(void*));

    //@TODO: We still need to the following things:
    //          - figure out if we are in a hijacked slot
    //            (no adjustment of ESP necessary)
    //          - adjust ESP (popping the args)
    //          - figure out if the aborted flag is set

    // @TODO: This is incorrect as the caller (of ComPrestub()) expected this to
    // be a pinvoke method. Hence, the calling convention was different
    // Also, m_pFuncDesc may not be a real MethodDesc
#if 0
    if (GetMethodDesc())
    {
        pRD->Esp += (DWORD) GetMethodDesc()->CbStackPop();
    }
#endif

#if 0
    /* this is the old code */
    if (sfType == SFT_JITTOVM)
        pRD->Esp += ((DWORD) this->GetMethodInfo() & ~0xC0000000);
    else if (sfType == SFT_FASTINTERPRETED)
        /* real esp is stored behind copy of return address */
        pRD->Esp = *((DWORD*) pRD->Esp);
    else if (sfType != SFT_JITHIJACK)
        pRD->Esp += (this->GetMethodInfo()->GetParamArraySize() * sizeof(DWORD));
#endif
}

#elif defined(CHECK_PLATFORM_BUILD)
#error "Platform NYI"
#else
inline VOID __cdecl ComCallPreStub() { _ASSERTE(!"Platform NYI"); }
void ComPrestubMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{ _ASSERTE(!"Platform NYI"); }
#endif //_86_


//--------------------------------------------------------------------------
// simple ComCallWrapper for all simple std interfaces, that are not used very often
// like IProvideClassInfo, ISupportsErrorInfo etc.
//--------------------------------------------------------------------------
SimpleComCallWrapper::SimpleComCallWrapper()
{
    memset(this, 0, sizeof(SimpleComCallWrapper));
}   

//--------------------------------------------------------------------------
// VOID SimpleComCallWrapper::Cleanup()
//--------------------------------------------------------------------------
VOID SimpleComCallWrapper::Cleanup()
{
    // in case the caller stills holds on to the IP
    for (int i = 0; i < enum_LastStdVtable; i++)
    {
        m_rgpVtable[i] = 0;
    }
    m_pWrap = NULL;
    m_pClass = NULL;

    if (m_pDispatchExInfo)
    {
        delete m_pDispatchExInfo; 
        m_pDispatchExInfo = NULL;
    }

    if (m_pCPList)
    {
        for (UINT i = 0; i < m_pCPList->Size(); i++)
        {
            delete (*m_pCPList)[i];
        }
        delete m_pCPList;
        m_pCPList = NULL;
    }
    
    // if this object was made agile, then we will have stashed away the original handle
    // so we must release it if the AD wasn't unloaded
    if (IsAgile())
    {
        AppDomain *pTgtDomain = SystemDomain::System()->GetAppDomainAtId(GetDomainID());
        if (pTgtDomain && m_hOrigDomainHandle)
        {
            DestroyRefcountedHandle(m_hOrigDomainHandle);
            m_hOrigDomainHandle = NULL;
        }
    }

    if (m_pTemplate)
    {
        m_pTemplate->Release();
        m_pTemplate = NULL;
    }
    // free cookie
    //if (m_pOuterCookie.m_dwGITCookie)
        //FreeGITCookie(m_pOuterCookie);
}

//--------------------------------------------------------------------------
//destructor
//--------------------------------------------------------------------------
SimpleComCallWrapper::~SimpleComCallWrapper()
{
    Cleanup();
}

//--------------------------------------------------------------------------
// Creates a simple wrapper off the process heap (thus avoiding any debug
// memory tracking) and initializes the memory to zero
// static
//--------------------------------------------------------------------------
SimpleComCallWrapper* SimpleComCallWrapper::CreateSimpleWrapper()
{
    void *p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(SimpleComCallWrapper));
    if (p == NULL) FailFast(GetThread(), FatalOutOfMemory);
    return new (p) SimpleComCallWrapper;
}           

//--------------------------------------------------------------------------
// Frees the memory allocated by a SimpleComCallWrapper
// static
//--------------------------------------------------------------------------
void SimpleComCallWrapper::FreeSimpleWrapper(SimpleComCallWrapper* p)
{
    delete p;
    HeapFree(GetProcessHeap(), 0, p);
}

//--------------------------------------------------------------------------
// Init, with the EEClass, pointer to the vtable of the interface
// and the main ComCallWrapper if the interface needs it
//--------------------------------------------------------------------------
void SimpleComCallWrapper::InitNew(OBJECTREF oref, ComCallWrapperCache *pWrapperCache, 
                                   ComCallWrapper* pWrap, 
                                Context* pContext, SyncBlock* pSyncBlock, ComCallWrapperTemplate* pTemplate)
{
   _ASSERTE(pWrap != NULL);
   _ASSERTE(oref != NULL);

    
    EEClass* pClass = oref->GetTrueClass();

    if (CRemotingServices::IsTransparentProxy(OBJECTREFToObject(oref)))
        m_flags |= enum_IsObjectTP;
    
    _ASSERTE(pClass != NULL);

    m_pClass = pClass;
    m_pWrap = pWrap; 
    m_pWrapperCache = pWrapperCache;
    m_pTemplate = pTemplate;
    m_pTemplate->AddRef();
    
    m_pOuterCookie.m_dwGITCookie = NULL;
    _ASSERTE(pSyncBlock != NULL);
    _ASSERTE(m_pSyncBlock == NULL);

    m_pSyncBlock = pSyncBlock;
    m_pContext = pContext;
    m_dwDomainId = pContext->GetDomain()->GetId();
    m_hOrigDomainHandle = NULL;

    //@TODO: CTS, when we transition into the correct context before creating a wrapper
    // then uncomment the next line
    //_ASSERTE(pContext == GetCurrentContext());
    
    MethodTable* pMT = m_pClass->GetMethodTable();
    _ASSERTE(pMT != NULL);
    if (pMT->IsComObjectType())
        m_flags |= enum_IsExtendsCom;

    for (int i = 0; i < enum_LastStdVtable; i++)
    {
        m_rgpVtable[i] = g_rgStdVtables[i];
    }
    _ASSERTE(g_pExceptionClass != NULL);

    // If the managed object extends a COM base class then we need to set IProvideClassInfo
    // to NULL until we determine if we need to use the IProvideClassInfo of the base class
    // or the one of the managed class.
    if (IsExtendsCOMObject())
        m_rgpVtable[enum_IProvideClassInfo] = NULL;

    // IErrorInfo is valid only for exception classes
    m_rgpVtable[enum_IErrorInfo] = NULL;

    // IDispatchEx is valid only for classes that have expando capabilities.
    m_rgpVtable[enum_IDispatchEx] = NULL;
}

//--------------------------------------------------------------------------
// ReInit,with the new sync block and the urt context
//--------------------------------------------------------------------------
void SimpleComCallWrapper::ReInit(SyncBlock* pSyncBlock)
{
    //_ASSERTE(IsDeactivated());
    _ASSERTE(pSyncBlock != NULL);

    m_pSyncBlock = pSyncBlock;
}


//--------------------------------------------------------------------------
// Initializes the information used for exposing exceptions to COM.
//--------------------------------------------------------------------------
void SimpleComCallWrapper::InitExceptionInfo()
{
    THROWSCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        COMPlusThrowOM();

    // This method manipulates object ref's so we need to switch to cooperative GC mode.
    BOOL bToggleGC = !pThread->PreemptiveGCDisabled();
    if (bToggleGC)
        pThread->DisablePreemptiveGC();

    m_rgpVtable[enum_IErrorInfo] = g_rgStdVtables[enum_IErrorInfo];             

    // Switch back to the original GC mode.
    if (bToggleGC)
        pThread->EnablePreemptiveGC();
}

//--------------------------------------------------------------------------
// Initializes the IDispatchEx information.
//--------------------------------------------------------------------------
BOOL SimpleComCallWrapper::InitDispatchExInfo()
{
    // Make sure the class supports at least IReflect..
    _ASSERTE(SupportsIReflect(m_pClass));

    // Set up the IClassX COM method table that the DispatchExInfo needs.
    ComMethodTable *pIClassXComMT = ComCallWrapperTemplate::SetupComMethodTableForClass(m_pClass->GetMethodTable(), FALSE);
    if (!pIClassXComMT)
        return FALSE;

    // Create the DispatchExInfo object.
    DispatchExInfo *pDispExInfo = new DispatchExInfo(this, pIClassXComMT, SupportsIExpando(m_pClass));
    if (!pDispExInfo)
        return FALSE;

    // Synchronize the DispatchExInfo with the actual expando object.
    pDispExInfo->SynchWithManagedView();

    // Swap the lock into the class member in a thread safe manner.
    if (NULL != FastInterlockCompareExchange((void**)&m_pDispatchExInfo, pDispExInfo, NULL))
        delete pDispExInfo;

    // Set the vtable entry to ensure that the next QI call will return immediatly.
    m_rgpVtable[enum_IDispatchEx] = g_rgStdVtables[enum_IDispatchEx];
    return TRUE;
}

void SimpleComCallWrapper::SetUpCPList()
{
    THROWSCOMPLUSEXCEPTION();

    CQuickArray<MethodTable *> SrcItfList;

    // If the list has already been set up, then return.
    if (m_pCPList)
        return;

    // Retrieve the list of COM source interfaces for the managed class.
    GetComSourceInterfacesForClass(m_pClass->GetMethodTable(), SrcItfList);

    // Call the helper to do the rest of the set up.
    SetUpCPListHelper(SrcItfList.Ptr(), (int)SrcItfList.Size());
}

void SimpleComCallWrapper::SetUpCPListHelper(MethodTable **apSrcItfMTs, int cSrcItfs)
{
    CQuickArray<ConnectionPoint*> *pCPList = NULL;
    ComCallWrapper *pWrap = SimpleComCallWrapper::GetMainWrapper(this);
    int NumCPs = 0;

    EE_TRY_FOR_FINALLY
    {
        // Allocate the list of connection points.
        pCPList = CreateCPArray();
        pCPList->Alloc(cSrcItfs);

        for (int i = 0; i < cSrcItfs; i++)
        {
            COMPLUS_TRY
            {
                // Create a CP helper thru which CP operations will be done.
                ConnectionPoint *pCP;
                pCP = CreateConnectionPoint(pWrap, apSrcItfMTs[i]);

                // Add the connection point to the list.
                (*pCPList)[NumCPs++] = pCP;
            }
            COMPLUS_CATCH
            {
            }
            COMPLUS_END_CATCH
        }

        // Now that we now the actual number of connection points we were
        // able to hook up, resize the array.
        pCPList->ReSize(NumCPs);

        // Finally, we set the connection point list in the simple wrapper. If 
        // no other thread already set it, we set pCPList to NULL to indicate 
        // that ownership has been transfered to the simple wrapper.
        if (InterlockedCompareExchangePointer((void **)&m_pCPList, pCPList, NULL) == NULL)
            pCPList = NULL;
    }
    EE_FINALLY
    {
        if (pCPList)
        {
            // Delete all the connection points.
            for (UINT i = 0; i < pCPList->Size(); i++)
                delete (*pCPList)[i];

            // Delete the list itself.
            delete pCPList;
        }
    }
    EE_END_FINALLY  
}

ConnectionPoint *SimpleComCallWrapper::CreateConnectionPoint(ComCallWrapper *pWrap, MethodTable *pEventMT)
{
    return new(throws) ConnectionPoint(pWrap, pEventMT);
}

CQuickArray<ConnectionPoint*> *SimpleComCallWrapper::CreateCPArray()
{
    return new(throws) CQuickArray<ConnectionPoint*>();
}

//--------------------------------------------------------------------------
// Returns TRUE if the simple wrapper represents a COM+ exception object.
//--------------------------------------------------------------------------
BOOL SimpleComCallWrapper::SupportsExceptions(EEClass *pClass)
{
    while (pClass != NULL) 
    {       
        if (pClass == g_pExceptionClass->GetClass())
        {
            return TRUE;
        }
        pClass = pClass->GetParentComPlusClass();
    }
    return FALSE;
}

//--------------------------------------------------------------------------
// Returns TRUE if the COM+ object that this wrapper represents implements
// IExpando.
//--------------------------------------------------------------------------
BOOL SimpleComCallWrapper::SupportsIReflect(EEClass *pClass)
{
    // Make sure the IReflect interface is loaded before we use it.
    if (!m_pIReflectMT)
    {
        if (!LoadReflectionTypes())
            return FALSE;
    }

    // Check to see if the EEClass associated with the wrapper implements IExpando.
    return (BOOL)(size_t)pClass->FindInterface(m_pIReflectMT);
}

//--------------------------------------------------------------------------
// Returns TRUE if the COM+ object that this wrapper represents implements
// IReflect.
//--------------------------------------------------------------------------
BOOL SimpleComCallWrapper::SupportsIExpando(EEClass *pClass)
{
    // Make sure the IReflect interface is loaded before we use it.
    if (!m_pIExpandoMT)
    {
        if (!LoadReflectionTypes())
            return FALSE;
    }

    // Check to see if the EEClass associated with the wrapper implements IExpando.
    return (BOOL)(size_t)pClass->FindInterface(m_pIExpandoMT);
}

//--------------------------------------------------------------------------
// Loads the IExpando method table and initializes reflection.
//--------------------------------------------------------------------------
BOOL SimpleComCallWrapper::LoadReflectionTypes()
{   
    BOOL     bReflectionTypesLoaded = FALSE;
    Thread  *pCurThread = SetupThread();
    BOOL     bToggleGC = !pCurThread->PreemptiveGCDisabled();

    if (bToggleGC)
        pCurThread->DisablePreemptiveGC();

    COMPLUS_TRY
    {
        OBJECTREF Throwable = NULL;

        // We are about to use reflection so make sure it is initialized.
        COMClass::EnsureReflectionInitialized();

        // Reflection no longer initializes variants, so initialize it as well
        COMVariant::EnsureVariantInitialized();

        // Retrieve the IReflect method table.
        GCPROTECT_BEGIN(Throwable)
        {
            // Retrieve the IReflect method table.
            m_pIReflectMT = g_Mscorlib.GetClass(CLASS__IREFLECT);

            // Retrieve the IExpando method table.
            m_pIExpandoMT = g_Mscorlib.GetClass(CLASS__IEXPANDO);
        }
        GCPROTECT_END();

        bReflectionTypesLoaded = TRUE;
    }
    COMPLUS_CATCH
    {
    }
    COMPLUS_END_CATCH

    if (bToggleGC)
        pCurThread->EnablePreemptiveGC();

    return bReflectionTypesLoaded;
}

//--------------------------------------------------------------------------
// Retrieves the simple wrapper from an IUnknown pointer that is for one
// of the interfaces exposed by the simple wrapper.
//--------------------------------------------------------------------------
SimpleComCallWrapper* SimpleComCallWrapper::GetWrapperFromIP(IUnknown* pUnk)
{
    _ASSERTE(pUnk != NULL);
    SLOT * pVtable = *((SLOT **)pUnk);

    for (int i = 0; i < enum_LastStdVtable; i++)
    {
        if (pVtable == g_rgStdVtables[i])
            break;
    }
    return (SimpleComCallWrapper *)(((BYTE *)(pUnk-i)) - offsetof(SimpleComCallWrapper,m_rgpVtable));
}

// QI for well known interfaces from within the runtime direct fetch, instead of guid comparisons.
// The returned interface is AddRef'd.
IUnknown* __stdcall SimpleComCallWrapper::QIStandardInterface(SimpleComCallWrapper* pWrap, Enum_StdInterfaces index)
{
    // assert for valid index
    _ASSERTE(index < enum_LastStdVtable);
    IUnknown* pIntf = NULL;
    if (pWrap->m_rgpVtable[index] != NULL)
    {
        pIntf = (IUnknown*)&pWrap->m_rgpVtable[index];
    }
    else if (index == enum_IProvideClassInfo)
    {
        BOOL bUseManagedIProvideClassInfo = TRUE;

        // Retrieve the ComMethodTable of the wrapper.
        ComCallWrapper *pMainWrap = GetMainWrapper(pWrap);
        ComMethodTable *pComMT = pMainWrap->GetIClassXComMT();

        // Only extensible RCW's should go down this code path.
        _ASSERTE(pMainWrap->IsExtendsCOMObject());

        // Find the first COM visible IClassX starting at the bottom of the hierarchy and
        // going up the inheritance chain.
        for (; pComMT && !pComMT->IsComVisible(); pComMT = pComMT->GetParentComMT());

        // Since this is an extensible RCW if the COM+ classes that derive from the COM component 
        // are not visible then we will give out the COM component's IProvideClassInfo.
        if (!pComMT || pComMT->m_pMT->GetParentMethodTable() == g_pObjectClass)
        {
            bUseManagedIProvideClassInfo = !pWrap->GetComPlusWrapper()->SupportsIProvideClassInfo();
        }

        // If we either have a visible managed part to the class or if the base class
        // does not implement IProvideClassInfo then use the one on the managed class.
        if (bUseManagedIProvideClassInfo)
        {
            // Object should always be visible.
            _ASSERTE(pComMT);

            // Set up the vtable pointer so that next time we don't have to determine
            // that the IProvideClassInfo is provided by the managed class.
            pWrap->m_rgpVtable[enum_IProvideClassInfo] = g_rgStdVtables[enum_IProvideClassInfo];             

            // Return the interface pointer to the standard IProvideClassInfo interface.
            pIntf = (IUnknown*)&pWrap->m_rgpVtable[enum_IProvideClassInfo];
        }
    }
    else if (index == enum_IErrorInfo)
    {
        if (SupportsExceptions(pWrap->m_pClass))
        {
            // Initialize the exception info before we return the interface.
            pWrap->InitExceptionInfo();
            pIntf = (IUnknown*)&pWrap->m_rgpVtable[enum_IErrorInfo];
        }
    }
    else if (index == enum_IDispatchEx)
    {
        if (SupportsIReflect(pWrap->m_pClass))
        {
            // Initialize the DispatchExInfo before we return the interface.
            pWrap->InitDispatchExInfo();
            pIntf = (IUnknown*)&pWrap->m_rgpVtable[enum_IDispatchEx];
        }
    }       

    if (pIntf)
        pIntf->AddRef();

    return pIntf;
}

// QI for well known interfaces from within the runtime based on an IID.
IUnknown* __stdcall SimpleComCallWrapper::QIStandardInterface(SimpleComCallWrapper* pWrap, REFIID riid)
{
    _ASSERTE(pWrap != NULL);

    IUnknown* pIntf = NULL;

    if (IsEqualGUID(IID_IProvideClassInfo, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IProvideClassInfo);
    }
    else
    if (IsEqualGUID(IID_IMarshal, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IMarshal);
    }
    else
    if (IsEqualGUID(IID_ISupportErrorInfo, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_ISupportsErrorInfo);
    }
    else
    if (IsEqualGUID(IID_IErrorInfo, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IErrorInfo);
    }
    else
    if (IsEqualGUID(IID_IManagedObject, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IManagedObject);
    }
    else
    if (IsEqualGUID(IID_IConnectionPointContainer, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IConnectionPointContainer);
    }
    else
    if (IsEqualGUID(IID_IObjectSafety, riid))
    {
#ifdef _HIDE_OBJSAFETY_FOR_DEFAULT_DOMAIN
        // Don't implement IObjectSafety by default.
        // Use IObjectSafety only for IE Hosting or simillar hosts
        // which create an AppDomain, with sufficient evidence.
        // Unconditionally implementing IObjectSafety would allow
        // Untrusted scripts to use managed components.
        // Managed components could implement it's own IObjectSafety to
        // override this.
        AppDomain *pDomain;

        _ASSERTE(pWrap);

        pDomain = pWrap->GetDomainSynchronized();

        if ((pDomain != NULL) && 
            (!pDomain->GetSecurityDescriptor()->IsDefaultAppDomain()))
#endif

            pIntf = QIStandardInterface(pWrap, enum_IObjectSafety);
    }
    else
    if (IsEqualGUID(IID_IDispatchEx, riid))
    {
        pIntf = QIStandardInterface(pWrap, enum_IDispatchEx);
    }
    return pIntf;
}

//--------------------------------------------------------------------------
// Init Outer unknown, cache a GIT cookie
//--------------------------------------------------------------------------
void SimpleComCallWrapper::InitOuter(IUnknown* pOuter)
{
    if (pOuter != NULL)
    {
        // Yuk this guy would AddRef the outer
        //HRESULT hr = AllocateGITCookie(pOuter, IID_IUnknown, m_pOuterCookie);
        //SafeRelease(pOuter);
        m_pOuterCookie.m_pUnk = pOuter;
        //_ASSERTE(hr == S_OK);
    }
    MarkAggregated();
}

//--------------------------------------------------------------------------
// Get Outer Unknown on the correct thread
//--------------------------------------------------------------------------
IUnknown* SimpleComCallWrapper::GetOuter()
{
    if(m_pOuterCookie.m_dwGITCookie != NULL)
    {
        //return GetIPFromGITCookie(m_pOuterCookie, IID_IUnknown);
        return m_pOuterCookie.m_pUnk;
    }
    return NULL;
}

BOOL SimpleComCallWrapper::FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP)
{
    // If the connection point list hasn't been set up yet, then set it up now.
    if (!m_pCPList)
        SetUpCPList();

    // Search through the list for a connection point for the requested IID.
    for (UINT i = 0; i < m_pCPList->Size(); i++)
    {
        ConnectionPoint *pCP = (*m_pCPList)[i];
        if (pCP->GetIID() == riid)
        {
            // We found a connection point for the requested IID.
            HRESULT hr = pCP->QueryInterface(IID_IConnectionPoint, (void**)ppCP);
            _ASSERTE(hr == S_OK);
            return TRUE;
        }
    }

    return FALSE;
}

void SimpleComCallWrapper::EnumConnectionPoints(IEnumConnectionPoints **ppEnumCP)
{
    THROWSCOMPLUSEXCEPTION();

    // If the connection point list hasn't been set up yet, then set it up now.
    if (!m_pCPList)
        SetUpCPList();

    // Create a new connection point enum.
    ComCallWrapper *pWrap = SimpleComCallWrapper::GetMainWrapper(this);
    ConnectionPointEnum *pCPEnum = new(throws) ConnectionPointEnum(pWrap, m_pCPList);
    
    // Retrieve the IEnumConnectionPoints interface. This cannot fail.
    HRESULT hr = pCPEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnumCP);
    _ASSERTE(hr == S_OK);
}

// MakeAgile needs the object passed in because it has to set it in the new handle
// If the original handle is from an unloaded appdomain, it will no longer be valid
// so we won't be able to get the object.
void ComCallWrapper::MakeAgile(OBJECTREF pObj)
{
    // if this assert fires, then we've called addref from a place where we need to
    // make the object agile but we haven't supplied the object. Need to change the caller.
    _ASSERTE(pObj != NULL);

    OBJECTHANDLE origHandle = m_ppThis;
    OBJECTHANDLE agileHandle = SharedDomain::GetDomain()->CreateRefcountedHandle(pObj);
     _ASSERTE(agileHandle);

    ComCallWrapperCache *pWrapperCache = GetWrapperCache();
    SimpleComCallWrapper *pSimpleWrap = GetSimpleWrapper(this);

    // lock the wrapper cache so nobody else can update to agile while we are
    BEGIN_ENSURE_PREEMPTIVE_GC();
    pWrapperCache->LOCK();
    END_ENSURE_PREEMPTIVE_GC();
    if (pSimpleWrap->IsAgile()) 
    {
        // someone beat us to it
        DestroyRefcountedHandle(agileHandle);
        pWrapperCache->UNLOCK();
        return;
    }

    ComCallWrapper *pWrap = this;
    ComCallWrapper* pWrap2 = IsLinked(this) == 1 ? pWrap : NULL;
    
    while (pWrap2 != NULL)
    {
        pWrap = pWrap2;
        pWrap2 = GetNext(pWrap2);
        pWrap2->m_ppThis = agileHandle;
    }
    pWrap->m_ppThis = agileHandle;

    // so all the handles are updated - now update the simple wrapper
    // keep the lock so someone else doesn't try to
    pSimpleWrap->MakeAgile(origHandle);
    pWrapperCache->UNLOCK();
    return;
}

//---------------------------------------------------------
// One-time init
//---------------------------------------------------------
/*static*/ 
BOOL ComCallWrapperTemplate::Init()
{
    g_pCreateWrapperTemplateCrst = new (g_CreateWrapperTemplateCrstSpace) Crst ("CreateTemplateWrapper", CrstWrapperTemplate, true, false);

    return TRUE;
}

//---------------------------------------------------------
// One-time cleanup
//---------------------------------------------------------
/*static*/ 
#ifdef SHOULD_WE_CLEANUP
VOID ComCallWrapperTemplate::Terminate()
{
    if (g_pCreateWrapperTemplateCrst)
    {
        delete g_pCreateWrapperTemplateCrst;
    }
}
#endif /* SHOULD_WE_CLEANUP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comclass.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: Simon Hall (t-shall)
// Author: Daryl Olander (darylo)
// Date: March 27, 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "COMClass.h"
#include "CorRegPriv.h"
#include "ReflectUtil.h"
#include "COMVariant.h"
#include "COMString.h"
#include "COMMember.h"
#include "COMModule.h"
#include "COMArrayInfo.h"
#include "compluswrapper.h"
#include "CorError.h"
#include "gcscan.h"
#include "method.hpp"
#include "field.h"
#include "AssemblyNative.hpp"
#include "AppDomain.hpp"
#include "COMReflectionCache.hpp"
#include "eeconfig.h"
#include "COMCodeAccessSecurityEngine.h"
#include "Security.h"
#include "CustomAttribute.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED

// This is defined in COMSystem...
extern LPVOID GetArrayElementPtr(OBJECTREF a);

/*======================================================================================
** COMClass data
**/
bool         COMClass::m_fAreReflectionStructsInitialized = false;

MethodTable* COMClass::m_pMTRC_Class = NULL;
FieldDesc*   COMClass::m_pDescrTypes = NULL;
FieldDesc*   COMClass::m_pDescrRetType = NULL;
FieldDesc*   COMClass::m_pDescrRetModType = NULL;
FieldDesc*   COMClass::m_pDescrMatchFlag = NULL;
//FieldDesc*   COMClass::m_pDescrCallConv = NULL;
FieldDesc*   COMClass::m_pDescrAttributes = NULL;

long COMClass::m_ReflectCrstInitialized = 0;
CRITICAL_SECTION    COMClass::m_ReflectCrst;
CRITICAL_SECTION    *COMClass::m_pReflectCrst = NULL;

//The serialization bit work is temporary until 3/15/2000.  After that point, we will
//always check the serialization bit.
#define SERIALIZATION_BIT_UNKNOWN   0xFFFFFFFF
#define SERIALIZATION_BIT_ZERO      0x0
#define SERIALIZATION_BIT_KEY       L"IgnoreSerializationBit"
#define SERIALIZATION_LOG_KEY       L"LogNonSerializable"
DWORD COMClass::m_checkSerializationBit = SERIALIZATION_BIT_UNKNOWN;

Assembly *GetCallersAssembly(StackCrawlMark *stackMark, void *returnIP)
{
    Assembly *pCallersAssembly = NULL;
    if (stackMark)
        pCallersAssembly = SystemDomain::GetCallersAssembly(stackMark);
    else {
        MethodDesc *pCallingMD = IP2MethodDesc((const BYTE *)returnIP);
        if (pCallingMD)
            pCallersAssembly = pCallingMD->GetAssembly();
        else
            // If we failed to determine the caller's method desc, this might
            // indicate a late bound call through reflection. Attempt to
            // determine the real caller through the slower stackwalk method.
            pCallersAssembly = SystemDomain::GetCallersAssembly((StackCrawlMark*)NULL);
    }

    return pCallersAssembly;
}

EEClass *GetCallersClass(StackCrawlMark *stackMark, void *returnIP)
{
    EEClass *pCallersClass = NULL;
    if (stackMark)
        pCallersClass = SystemDomain::GetCallersClass(stackMark);
    else {
        MethodDesc *pCallingMD = IP2MethodDesc((const BYTE *)returnIP);
        if (pCallingMD)
            pCallersClass = pCallingMD->GetClass();
        else
            // If we failed to determine the caller's method desc, this might
            // indicate a late bound call through reflection. Attempt to
            // determine the real caller through the slower stackwalk method.
            pCallersClass = SystemDomain::GetCallersClass((StackCrawlMark*)NULL);
    }

    return pCallersClass;
}

FCIMPL5(Object*, COMClass::GetMethodFromCache, ReflectClassBaseObject* _refThis, StringObject* _name, INT32 invokeAttr, INT32 argCnt, PtrArray* _args)
{
    MemberMethodsCache *pMemberMethodsCache = GetAppDomain()->GetRefMemberMethodsCache();

    REFLECTCLASSBASEREF refThis = REFLECTCLASSBASEREF(_refThis);
    STRINGREF name = STRINGREF(_name);
    PTRARRAYREF args = PTRARRAYREF(_args);
    
    _ASSERTE (argCnt < 6);
    MemberMethods vMemberMethods;
    vMemberMethods.pRC = (ReflectClass*) refThis->GetData();
    vMemberMethods.name = &name;
    vMemberMethods.argCnt = argCnt;
    vMemberMethods.invokeAttr = invokeAttr;
    OBJECTREF* argArray = args->m_Array;
    for (int i = 0; i < argCnt; i ++)
        vMemberMethods.vArgType[i] = (argArray[i] != 0)?argArray[i]->GetMethodTable():0;

    OBJECTREF method;
    if (!pMemberMethodsCache->GetFromCache (&vMemberMethods, method))
        method = NULL;

    FC_GC_POLL_AND_RETURN_OBJREF(OBJECTREFToObject(method));
}
FCIMPLEND

FCIMPL6(void,COMClass::AddMethodToCache, ReflectClassBaseObject* refThis, StringObject* name, INT32 invokeAttr, INT32 argCnt, PtrArray* args, Object* invokeMethod)
{
    MemberMethodsCache *pMemberMethodsCache = GetAppDomain()->GetRefMemberMethodsCache();
    _ASSERTE (pMemberMethodsCache);
    _ASSERTE (argCnt < 6);
    MemberMethods vMemberMethods;
    vMemberMethods.pRC = (ReflectClass*) REFLECTCLASSBASEREF(refThis)->GetData();
    vMemberMethods.name = (STRINGREF*) &name;
    vMemberMethods.argCnt = argCnt;
    vMemberMethods.invokeAttr = invokeAttr;
    OBJECTREF *argArray = (OBJECTREF*)((BYTE*)args + args->GetDataOffset());
    for (int i = 0; i < argCnt; i ++)
        vMemberMethods.vArgType[i] = !argArray[i] ? 0 : argArray[i]->GetMethodTable();
    pMemberMethodsCache->AddToCache (&vMemberMethods, ObjectToOBJECTREF((Object *)invokeMethod));

    FC_GC_POLL();
}
FCIMPLEND

void COMClass::InitializeReflectCrst()
{   
    // There are 3 cases when we come here
    // 1. m_ReflectCrst has not been initialized (m_pReflectCrst == 0)
    // 2. m_ReflectCrst is being initialized (m_pReflectCrst == 1)
    // 3. m_ReflectCrst has been initialized (m_pReflectCrst != 0 and m_pReflectCrst != 1)

    if (m_pReflectCrst == NULL)
    {   
        if (InterlockedCompareExchange(&m_ReflectCrstInitialized, 1, 0) == 0)
        {
            // first one to get in does the initialization
            InitializeCriticalSection(&m_ReflectCrst);
            m_pReflectCrst = &m_ReflectCrst;
        }
        else 
        {
            while (m_pReflectCrst == NULL)
                ::SwitchToThread();
        }
    }


}

// MinimalReflectionInit
// This method will intialize reflection.  It is executed once.
//  This method is synchronized so multiple threads don't attempt to 
//  initalize reflection.
void COMClass::MinimalReflectionInit()
{

    Thread  *thread = GetThread();

    _ASSERTE(thread->PreemptiveGCDisabled());

    thread->EnablePreemptiveGC();
    LOCKCOUNTINCL("MinimalReflectionInit in COMClass.cpp");

    InitializeReflectCrst();

    EnterCriticalSection(&m_ReflectCrst);
    thread->DisablePreemptiveGC();

    if (m_fAreReflectionStructsInitialized) {
        LeaveCriticalSection(&m_ReflectCrst);
        LOCKCOUNTDECL("MinimalReflectionInit in COMClass.cpp");

        return;
    }

    COMMember::CreateReflectionArgs();
    ReflectUtil::Create();
    // At various places we just assume Void has been loaded and m_NormType initialized
    MethodTable* pVoidMT = g_Mscorlib.FetchClass(CLASS__VOID);
    pVoidMT->m_NormType = ELEMENT_TYPE_VOID;

    // Prevent recursive entry...
    m_fAreReflectionStructsInitialized = true;
    LeaveCriticalSection(&m_ReflectCrst);
    LOCKCOUNTDECL("MinimalReflectionInit in COMClass.cpp");

}

MethodTable *COMClass::GetRuntimeType()
{
    if (m_pMTRC_Class)
        return m_pMTRC_Class;

    MinimalReflectionInit();
    _ASSERTE(g_pRefUtil);

    m_pMTRC_Class = g_pRefUtil->GetClass(RC_Class);
    _ASSERTE(m_pMTRC_Class);

    return m_pMTRC_Class;
}

// This is called during termination...
#ifdef SHOULD_WE_CLEANUP
void COMClass::Destroy()
{
    if (m_pReflectCrst)
    {
        DeleteCriticalSection(m_pReflectCrst);
        m_pReflectCrst = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */

// See if a Type object for the given Array already exists.  May very 
// return NULL.
OBJECTREF COMClass::QuickLookupExistingArrayClassObj(ArrayTypeDesc* arrayType) 
{
    // This is designed to be called from FCALL, and we don't want any GC allocations.
    // So make sure Type class has been loaded
    if (!m_pMTRC_Class)
        return NULL;

    // Lookup the array to see if we have already built it.
    ReflectArrayClass* newArray = (ReflectArrayClass*)
        arrayType->GetReflectClassIfExists();
    if (!newArray) {
        return NULL;
    }
    return newArray->GetClassObject();
}

// This will return the Type handle for an object.  It doesn't create
//  the Type Object when called.
FCIMPL1(void*, COMClass::GetTHFromObject, Object* obj)
    if (obj==NULL)
        FCThrowArgumentNull(L"obj");

    VALIDATEOBJECTREF(obj);
    return obj->GetMethodTable();
FCIMPLEND


// This will determine if a class represents a ByRef.
FCIMPL1(INT32, COMClass::IsByRefImpl, ReflectClassBaseObject* refThis)
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);
    return pRC->IsByRef();
FCIMPLEND

// This will determine if a class represents a ByRef.
FCIMPL1(INT32, COMClass::IsPointerImpl, ReflectClassBaseObject* refThis) {
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);
    TypeHandle th = pRC->GetTypeHandle();
    return (th.GetSigCorElementType() == ELEMENT_TYPE_PTR) ? 1 : 0;
}
FCIMPLEND

// IsPointerImpl
// This method will return a boolean indicating if the Type
//  object is a ByRef
FCIMPL1(INT32, COMClass::IsNestedTypeImpl, ReflectClassBaseObject* refThis)
{
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    EEClass* pEEC = pRC->GetClass();
    return (pEEC && pEEC->IsNested()) ? 1 : 0;
}
FCIMPLEND

// GetNestedDeclaringType
// Return the declaring class for a nested type.
FCIMPL1(Object*, COMClass::GetNestedDeclaringType, ReflectClassBaseObject* refThis)
{
    VALIDATEOBJECTREF(refThis);
    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    EEClass* pEEC = pRC->GetClass();

    OBJECTREF o;
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    pEEC = pEEC->GetEnclosingClass();
    o = pEEC->GetExposedClassObject();
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(o);
}
FCIMPLEND

void COMClass::CreateClassObjFromEEClass(EEClass* pVMCClass, REFLECTCLASSBASEREF* pRefClass)
{
    LPVOID   rv   = NULL;

    // This only throws the possible exception raised by the <cinit> on the class
    THROWSCOMPLUSEXCEPTION();

    // call the <cinit> Class
    OBJECTREF Throwable;
    if (!g_pRefUtil->GetClass(RC_Class)->CheckRunClassInit(&Throwable)) {
        COMPlusThrow(Throwable);
    }

    // There was an expectation that we would never come here for e.g. Arrays.  But there
    // are far too many clients who were unaware of that expectation.  The most expedient
    // thing to do for V1 is to simply handle that case here:
    if (pVMCClass->IsArrayClass())
    {
        ArrayClass      *pArrayClass = (ArrayClass *) pVMCClass;
        TypeHandle       th = pArrayClass->GetClassLoader()->FindArrayForElem(
                                pArrayClass->GetElementTypeHandle(),
                                pArrayClass->GetMethodTable()->GetNormCorElementType(),
                                pArrayClass->GetRank());

        *pRefClass = (REFLECTCLASSBASEREF) th.CreateClassObj();

        _ASSERTE(*pRefClass != NULL);
    }
    else
    {
        // Check to make sure this has a member.  If not it must be
        //  special
        _ASSERTE(pVMCClass->GetCl() != mdTypeDefNil);

        // Create a COM+ Class object
        *pRefClass = (REFLECTCLASSBASEREF) AllocateObject(g_pRefUtil->GetClass(RC_Class));

        // Set the data in the COM+ object
        ReflectClass* p = new (pVMCClass->GetDomain()) ReflectBaseClass();
        if (!p)
            COMPlusThrowOM();
        REFLECTCLASSBASEREF tmp = *pRefClass;
        GCPROTECT_BEGIN(tmp);
        p->Init(pVMCClass);
        *pRefClass = tmp;
        GCPROTECT_END();
        (*pRefClass)->SetData(p);
    }
}

// GetMemberMethods
// This method will return all of the members methods which match the specified attributes flag
LPVOID __stdcall COMClass::GetMemberMethods(_GetMemberMethodsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->name == NULL)
        COMPlusThrow(kNullReferenceException);


    bool    checkCall;
    
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // Check the calling convention.
    checkCall = (args->callConv == Any_CC) ? false : true;

    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    szName = GetClassStringVars((STRINGREF) args->name, &bytes, &cName);

    ReflectMethodList* pMeths = pRC->GetMethods();

    // Find methods....
    return COMMember::g_pInvokeUtil->FindMatchingMethods(args->invokeAttr,
                                                         szName,
                                                         cName,
                                                         (args->argTypes != NULL) ? &args->argTypes : NULL,
                                                         args->argCnt,
                                                         checkCall,
                                                         args->callConv,
                                                         pRC,
                                                         pMeths, 
                                                         g_pRefUtil->GetTrueType(RC_Method),
                                                         args->verifyAccess != 0);
}

// GetMemberCons
// This method returns all of the constructors that have a set number of methods.
LPVOID __stdcall COMClass::GetMemberCons(_GetMemberConsArgs* args)
{
    LPVOID  rv;
    bool    checkCall;
    
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // properly get rid of any non sense from the binding flags
    args->invokeAttr &= ~BINDER_FlattenHierarchy;
    args->invokeAttr &= ~BINDER_IgnoreCase;
    args->invokeAttr |= BINDER_DeclaredOnly;

    // Check the calling convention.
    checkCall = (args->callConv == Any_CC) ? false : true;

    ReflectMethodList* pCons = pRC->GetConstructors();

    // Find methods....
    rv = COMMember::g_pInvokeUtil->FindMatchingMethods(args->invokeAttr,
                                                       NULL,
                                                       0,
                                                       (args->argTypes != NULL) ? &args->argTypes : NULL,
                                                       args->argCnt,
                                                       checkCall,
                                                       args->callConv,
                                                       pRC,
                                                       pCons, 
                                                       g_pRefUtil->GetTrueType(RC_Ctor),
                                                       args->verifyAccess != 0);
    
    // Also return whether the type is a delegate (some extra security checks
    // need to be made in this case).
    *args->isDelegate = (pRC->IsClass()) ? pRC->GetClass()->IsAnyDelegateClass() : 0;
    return rv;
}

// GetMemberField
// This method returns all of the fields which match the specified
//  name.
LPVOID __stdcall COMClass::GetMemberField(_GetMemberFieldArgs* args)
{
    DWORD           i;
    PTRARRAYREF     refArr;
    LPVOID          rv;
    RefSecContext   sCtx;


    THROWSCOMPLUSEXCEPTION();

    if (args->name == NULL)
        COMPlusThrow(kNullReferenceException);



    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    ReflectFieldList* pFields = pRC->GetFields();

    CQuickBytes bytes;
    LPSTR szFieldName;
    DWORD cFieldName;

    //@TODO: Assumes args->criteria is of type STRINGREF
    szFieldName = GetClassStringVars((STRINGREF) args->name, &bytes, &cFieldName);

    int fldCnt = 0;
    int* matchFlds = (int*) _alloca(sizeof(int) * pFields->dwTotal);
    memset(matchFlds,0,sizeof(int) * pFields->dwTotal);

    MethodTable *pParentMT = pRC->GetClass()->GetMethodTable();

    DWORD propToLookup = (args->invokeAttr & BINDER_FlattenHierarchy) ? pFields->dwTotal : pFields->dwFields;
    for(i=0; i<propToLookup; i++) {
        // Get the FieldDesc
        if (MatchField(pFields->fields[i].pField, cFieldName, szFieldName, pRC, args->invokeAttr) &&
            (!args->verifyAccess || InvokeUtil::CheckAccess(&sCtx, pFields->fields[i].pField->GetFieldProtection(), pParentMT, 0)))
                matchFlds[fldCnt++] = i;
    }

    // If we didn't find any methods then return
    if (fldCnt == 0)
        return 0;
    // Allocate the MethodInfo Array and return it....
    refArr = (PTRARRAYREF) AllocateObjectArray(fldCnt, g_pRefUtil->GetTrueType(RC_Field));
    GCPROTECT_BEGIN(refArr);
    for (int i=0;i<fldCnt;i++) {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) pFields->fields[matchFlds[i]].GetFieldInfo(pRC);
        refArr->SetAt(i, o);
    }
    *((PTRARRAYREF*) &rv) = refArr;
    GCPROTECT_END();

    return rv;
}


// GetMemberProperties
// This method returns all of the properties that have a set number
//  of arguments.  The methods will be either get or set methods depending
//  upon the invokeAttr flag.
LPVOID __stdcall COMClass::GetMemberProperties(_GetMemberPropertiesArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->name == NULL)
        COMPlusThrow(kNullReferenceException);



    PTRARRAYREF     refArr;
    LPVOID          rv;
    bool            loose;
    RefSecContext   sCtx;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();

    loose = (args->invokeAttr & BINDER_OptionalParamBinding) ? true : false;

    // The Search modifiers
    bool ignoreCase = ((args->invokeAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->invokeAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->invokeAttr & BINDER_Static)  != 0);
    bool addInst = ((args->invokeAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->invokeAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->invokeAttr & BINDER_Public) != 0);

    int bSetter = (args->invokeAttr & BINDER_SetProperty) ? 1 : 0;

    // Get the Properties from the Class
    ReflectPropertyList* pProps = pRC->GetProperties();
    if (pProps->dwTotal == 0)
        return 0;

    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    szName = GetClassStringVars((STRINGREF) args->name, &bytes, &cName);

    DWORD searchSpace = ((args->invokeAttr & BINDER_FlattenHierarchy) != 0) ? pProps->dwTotal : pProps->dwProps;

    MethodTable *pParentMT = pEEC->GetMethodTable();

    int propCnt = 0;
    int* matchProps = (int*) _alloca(sizeof(int) * searchSpace);
    memset(matchProps,0,sizeof(int) * searchSpace);
    for (DWORD i = 0; i < searchSpace; i++) {

        // Check on the name
        if (ignoreCase) {
            if (_stricmp(pProps->props[i].szName, szName) != 0)
                continue;
        }
        else {
            if (strcmp(pProps->props[i].szName, szName) != 0)
                continue;
        }

        // Test the publics/nonpublics
        if (COMMember::PublicProperty(&pProps->props[i])) {
            if (!addPub) continue;
        }
        else {
            if (!addPriv) continue;
            if (args->verifyAccess && !InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
        }

        // Check for static instance 
        if (COMMember::StaticProperty(&pProps->props[i])) {
            if (!addStatic) continue;
        }
        else {
            if (!addInst) continue;
        }

        // Checked the declared methods.
        if (declaredOnly) {
            if (pProps->props[i].pDeclCls != pEEC)
                 continue;
        }

        // Check the specific accessor
        ReflectMethod* pMeth;
        if (bSetter) {
            pMeth = pProps->props[i].pSetter;           
        }
        else {
            pMeth = pProps->props[i].pGetter;
            
        }
        if (pMeth == 0)
            continue;

        ExpandSig* pSig = pMeth->GetSig();
        int argCnt = pSig->NumFixedArgs();

        if (argCnt != args->argCnt) {
            
            IMDInternalImport *pInternalImport = pMeth->pMethod->GetMDImport();
            HENUMInternal   hEnumParam;
            mdParamDef      paramDef = mdParamDefNil;
            mdToken methodTk = pMeth->GetToken();
            if (!IsNilToken(methodTk)) {
            
                HRESULT hr = pInternalImport->EnumInit(mdtParamDef, methodTk, &hEnumParam);
                if (SUCCEEDED(hr)) {
                    if (argCnt < args->argCnt || argCnt == args->argCnt + 1) {
                        // we must have a param array under the first condition, could be a param array under the second

                        int propArgCount = argCnt - bSetter;
                        // get the sig of the last param
                        LPVOID pEnum;
                        pSig->Reset(&pEnum);
                        TypeHandle lastArgType;
                        for (INT32 i = 0; i < propArgCount; i++) 
                            lastArgType = pSig->NextArgExpanded(&pEnum);

                        pInternalImport->EnumReset(&hEnumParam);

                        // get metadata info and token for the last param
                        ULONG paramCount = pInternalImport->EnumGetCount(&hEnumParam);
                        for (ULONG ul = 0; ul < paramCount; ul++) {
                            pInternalImport->EnumNext(&hEnumParam, &paramDef);
                            if (paramDef != mdParamDefNil) {
                                LPCSTR  name;
                                SHORT   seq;
                                DWORD   revWord;
                                name = pInternalImport->GetParamDefProps(paramDef,(USHORT*) &seq, &revWord);
                                if (seq == propArgCount) {
                                    // looks good! check that it is in fact a param array
                                    if (lastArgType.IsArray()) {
                                        if (COMCustomAttribute::IsDefined(pMeth->GetModule(), paramDef, TypeHandle(InvokeUtil::GetParamArrayAttributeTypeHandle()))) {
                                            pInternalImport->EnumClose(&hEnumParam);
                                            goto matchFound;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (loose && argCnt > args->argCnt) {
                        pInternalImport->EnumReset(&hEnumParam);
                        ULONG cArg = (ULONG)(args->argCnt + 1 - bSetter);
                        while (pInternalImport->EnumNext(&hEnumParam, &paramDef)) {
                            LPCSTR  name;
                            SHORT   seq;
                            DWORD   revWord;
                            name = pInternalImport->GetParamDefProps(paramDef,(USHORT*) &seq, &revWord);
                            if ((ULONG)seq < cArg) 
                                continue;
                            else if ((ULONG)seq == cArg && (revWord & pdOptional)) {
                                cArg++;
                                continue;
                            }
                            else {
                                if (!bSetter || (int)seq != argCnt) 
                                    break; // not an optional param, no match
                            }
                        }
                        if (cArg == (ULONG)argCnt + 1 - bSetter) {
                            pInternalImport->EnumClose(&hEnumParam);
                            goto matchFound;
                        }
                    }
                    
                    pInternalImport->EnumClose(&hEnumParam);
                }
            }
            
            continue; // no good
        }
    matchFound:

        if (args->verifyAccess && !InvokeUtil::CheckAccess(&sCtx, pMeth->attrs, pParentMT, 0)) continue;

        // If the method has a linktime security demand attached, check it now.
        if (args->verifyAccess && !InvokeUtil::CheckLinktimeDemand(&sCtx, pMeth->pMethod, false))
            continue;

        matchProps[propCnt++] = i;
    }
    // If we didn't find any methods then return
    if (propCnt == 0)
        return 0;

    // Allocate the MethodInfo Array and return it....
    refArr = (PTRARRAYREF) AllocateObjectArray( propCnt, 
        g_pRefUtil->GetTrueType(RC_Method));
    GCPROTECT_BEGIN(refArr);
    for (int i=0;i<propCnt;i++) {
        ReflectMethod* pMeth;
        if (args->invokeAttr & BINDER_SetProperty)
            pMeth = pProps->props[matchProps[i]].pSetter;           
        else 
            pMeth = pProps->props[matchProps[i]].pGetter;

        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) pMeth->GetMethodInfo(pProps->props[matchProps[i]].pRC);
        refArr->SetAt(i, o);
    }
    *((PTRARRAYREF*) &rv) = refArr;
    GCPROTECT_END();

    return rv;
}

// GetMatchingProperties
// This basically does a matching based upon the properties abstract 
//  signature.
LPVOID __stdcall COMClass::GetMatchingProperties(_GetMatchingPropertiesArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    PTRARRAYREF     refArr;
    LPVOID          rv;
    RefSecContext   sCtx;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();

    // The Search modifiers
    bool ignoreCase = ((args->invokeAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->invokeAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->invokeAttr & BINDER_Static)  != 0);
    bool addInst = ((args->invokeAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->invokeAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->invokeAttr & BINDER_Public) != 0);

    // Get the Properties from the Class
    ReflectPropertyList* pProps = pRC->GetProperties();
    if (pProps->dwTotal == 0)
        return 0;

    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    if (args->name == NULL)
        COMPlusThrow(kNullReferenceException);



    //@TODO: Assumes args->criteria is of type STRINGREF
    szName = GetClassStringVars((STRINGREF) args->name, &bytes, &cName);

    DWORD searchSpace = ((args->invokeAttr & BINDER_FlattenHierarchy) != 0) ? pProps->dwTotal : pProps->dwProps;

    MethodTable *pParentMT = pEEC->GetMethodTable();

    int propCnt = 0;
    int* matchProps = (int*) _alloca(sizeof(int) * searchSpace);
    memset(matchProps,0,sizeof(int) * searchSpace);
    for (DWORD i = 0; i < searchSpace; i++) {

        // Check on the name
        if (ignoreCase) {
            if (_stricmp(pProps->props[i].szName, szName) != 0)
                continue;
        }
        else {
            if (strcmp(pProps->props[i].szName, szName) != 0)
                continue;
        }

        int argCnt = pProps->props[i].pSignature->NumFixedArgs();
        if (args->argCnt != -1 && argCnt != args->argCnt)
            continue;

        // Test the publics/nonpublics
        if (COMMember::PublicProperty(&pProps->props[i])) {
            if (!addPub) continue;
        }
        else {
            if (!addPriv) continue;
            if (args->verifyAccess && !InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
        }

        // Check for static instance 
        if (COMMember::StaticProperty(&pProps->props[i])) {
            if (!addStatic) continue;
        }
        else {
            if (!addInst) continue;
        }

        // Checked the declared methods.
        if (declaredOnly) {
            if (pProps->props[i].pDeclCls != pEEC)
                 continue;
        }

        matchProps[propCnt++] = i;
    }
    // If we didn't find any methods then return
    if (propCnt == 0)
        return 0;

    // Allocate the MethodInfo Array and return it....
    refArr = (PTRARRAYREF) AllocateObjectArray(propCnt, g_pRefUtil->GetTrueType(RC_Prop));
    GCPROTECT_BEGIN(refArr);
    for (int i=0;i<propCnt;i++) {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) pProps->props[matchProps[i]].GetPropertyInfo(pProps->props[matchProps[i]].pRC);
        refArr->SetAt(i, o);
    }
    *((PTRARRAYREF*) &rv) = refArr;
    GCPROTECT_END();

    return rv;
}


// GetMethod
// This method returns an array of MethodInfo object representing all of the methods
//  defined for this class.
LPVOID __stdcall COMClass::GetMethods(_GetMethodsArgs* args)
{
    LPVOID          rv = 0;
    PTRARRAYREF     refArrMethods;

    THROWSCOMPLUSEXCEPTION();

    // Get the EEClass and Vtable associated with args->refThis
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    ReflectMethodList* pMeths = pRC->GetMethods();
    refArrMethods = g_pRefUtil->CreateClassArray(RC_Method,pRC,pMeths,args->bindingAttr, true);
    *((PTRARRAYREF*) &rv) = refArrMethods;
    return rv;
}

// GetConstructor
// This method returns a single constructor which matchs the passed
//  in criteria.
LPVOID __stdcall COMClass::GetConstructors(_GetConstructorsArgs* args)
{
    LPVOID          rv;
    PTRARRAYREF     refArrCtors;

    THROWSCOMPLUSEXCEPTION();

    // Get the EEClass and Vtable associated with args->refThis
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);
    ReflectMethodList* pCons = pRC->GetConstructors();
    refArrCtors = g_pRefUtil->CreateClassArray(RC_Ctor,pRC,pCons,args->bindingAttr, args->verifyAccess != 0);
    *((PTRARRAYREF*) &rv) = refArrCtors;
    return rv;
}



// GetField
// This method will return the specified field
LPVOID __stdcall COMClass::GetField(_GetFieldArgs* args)
{
    HRESULT        hr             = E_FAIL;
    DWORD          i;
    LPVOID         rv  = 0;
    REFLECTBASEREF refField;
    RefSecContext  sCtx;

    THROWSCOMPLUSEXCEPTION();

    if (args->fieldName == 0)
        COMPlusThrowArgumentNull(L"name",L"ArgumentNull_String");


    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    ReflectFieldList* pFields = pRC->GetFields();
    DWORD maxCnt;

    if (args->fBindAttr & BINDER_FlattenHierarchy)
        maxCnt = pFields->dwTotal;
    else
        maxCnt = pFields->dwFields;

    CQuickBytes bytes;
    LPSTR szFieldName;
    DWORD cFieldName;

    //@TODO: Assumes args->criteria is of type STRINGREF
    szFieldName = GetClassStringVars((STRINGREF) args->fieldName, 
                                     &bytes, &cFieldName);

    rv = 0;
    for (i=0; i < maxCnt; i++) {
        if (MatchField(pFields->fields[i].pField,cFieldName,szFieldName, pRC,args->fBindAttr) &&
            InvokeUtil::CheckAccess(&sCtx, pFields->fields[i].pField->GetFieldProtection(), pRC->GetClass()->GetMethodTable(), 0)) {

            // Found the first field that matches, so return it
            refField = pFields->fields[i].GetFieldInfo(pRC);

            // Assign the return value
            *((REFLECTBASEREF*) &rv) = refField;
            break;
        }
    }
    return rv;
}

LPVOID __stdcall COMClass::MatchField(FieldDesc* pCurField,DWORD cFieldName,
    LPUTF8 szFieldName,ReflectClass* pRC,int bindingAttr)
{
    _ASSERTE(pCurField);

    // Public/Private members
    bool addPub = ((bindingAttr & BINDER_Public) != 0);
    bool addPriv = ((bindingAttr & BINDER_NonPublic) != 0);
    if (pCurField->IsPublic()) {
        if (!addPub) return 0;
    }
    else {
        if (!addPriv) return 0;
    }

    // Check for static instance 
    bool addStatic = ((bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((bindingAttr & BINDER_Instance)  != 0);
    if (pCurField->IsStatic()) {
        if (!addStatic) return 0;
    }
    else {
        if (!addInst) return 0;
    }

    // Get the name of the field
    LPCUTF8 pwzCurFieldName = pCurField->GetName();

    // If the names do not match, reject field
    if(strlen(pwzCurFieldName) != cFieldName)
        return 0;

    // Case sensitive compare
    bool ignoreCase = ((bindingAttr & BINDER_IgnoreCase)  != 0);
    if (ignoreCase) {
        if (_stricmp(pwzCurFieldName, szFieldName) != 0)
            return 0;
    }
    else {
        if (memcmp(pwzCurFieldName, szFieldName, cFieldName))
            return 0;
    }

    bool declaredOnly = ((bindingAttr & BINDER_DeclaredOnly)  != 0);
    if (declaredOnly) {
        EEClass* pEEC = pRC->GetClass();
        if (pCurField->GetEnclosingClass() != pEEC)
             return 0;
    }

     return pCurField;
}

// GetFields
// This method will return a FieldInfo array of all of the
//  fields defined for this Class
LPVOID __stdcall COMClass::GetFields(_GetFieldsArgs* args)
{
    LPVOID          rv;

    THROWSCOMPLUSEXCEPTION();

    // Get the class for this object
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    ReflectFieldList* pFields = pRC->GetFields();
    PTRARRAYREF refArrFields = g_pRefUtil->CreateClassArray(RC_Field,pRC,pFields,args->bindingAttr, args->bRequiresAccessCheck != 0);
    *((PTRARRAYREF*) &rv) = refArrFields;
    return rv;
}


// GetEvent
// This method will return the specified event based upon
//  the name
LPVOID __stdcall COMClass::GetEvent(_GetEventArgs* args)
{
    LPVOID          rv;
    RefSecContext   sCtx;

    THROWSCOMPLUSEXCEPTION();
    if (args->eventName == NULL)
        COMPlusThrowArgumentNull(L"name",L"ArgumentNull_String");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();

    // Get the events from the Class
    ReflectEventList* pEvents = pRC->GetEvents();
    if (pEvents->dwTotal == 0)
        return 0;

    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    szName = GetClassStringVars(args->eventName, &bytes, &cName);

    // The Search modifiers
    bool ignoreCase = ((args->bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((args->bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->bindingAttr & BINDER_Public) != 0);

    MethodTable *pParentMT = pEEC->GetMethodTable();

    // check the events to see if we find one that matches...
    ReflectEvent* ev = 0;
    DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pEvents->dwTotal : pEvents->dwEvents;
    for (DWORD i = 0; i < searchSpace; i++) {
        // Check for access to publics, non-publics
        if (COMMember::PublicEvent(&pEvents->events[i])) {
            if (!addPub) continue;
        }
        else {
            if (!addPriv) continue;
            if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
        }

        if (declaredOnly) {
            if (pEvents->events[i].pDeclCls != pEEC)
                 continue;
        }

        // Check fo static instance 
        if (COMMember::StaticEvent(&pEvents->events[i])) {
            if (!addStatic) continue;
        }
        else {
            if (!addInst) continue;
        }

        // Check on the name
        if (ignoreCase) {
            if (_stricmp(pEvents->events[i].szName, szName) != 0)
                continue;
        }
        else {
            if (strcmp(pEvents->events[i].szName, szName) != 0)
                continue;
        }

        // Ignore case can cause Ambiguous situations, we need to check for
        //  these.
        if (ev)
            COMPlusThrow(kAmbiguousMatchException);
        ev = &pEvents->events[i];
        if (!ignoreCase)
            break;

    }

    // if we didn't find an event return null
    if (!ev)
        return 0;

    // Found the first method that matches, so return it
    REFLECTTOKENBASEREF refMethod = (REFLECTTOKENBASEREF) ev->GetEventInfo(pRC);

    // Assign the return value
    *((REFLECTTOKENBASEREF*) &rv) = refMethod;
    return rv;
}

// GetEvents
// This method will return an array of EventInfo for each of the events
//  defined in the class
LPVOID __stdcall COMClass::GetEvents(_GetEventsArgs* args)
{
    REFLECTTOKENBASEREF     refMethod;
    PTRARRAYREF     pRet;
    LPVOID          rv;
    HENUMInternal   hEnum;
    RefSecContext   sCtx;

    THROWSCOMPLUSEXCEPTION();

    // Find the properties
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();

    // Get the events from the class
    ReflectEventList* pEvents = pRC->GetEvents();
    if (pEvents->dwTotal == 0) {
        pRet = (PTRARRAYREF) AllocateObjectArray(0,g_pRefUtil->GetTrueType(RC_Event));
        *((PTRARRAYREF *)&rv) = pRet;
        return rv;
    }

    // The Search modifiers
    bool ignoreCase = ((args->bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((args->bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->bindingAttr & BINDER_Public) != 0);

    DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pEvents->dwTotal : pEvents->dwEvents;

    pRet = (PTRARRAYREF) AllocateObjectArray(searchSpace, g_pRefUtil->GetTrueType(RC_Event));
    GCPROTECT_BEGIN(pRet);

    MethodTable *pParentMT = pEEC->GetMethodTable();

    // Loop through all of the Events and see how many match
    //  the binding flags.
    for (ULONG i = 0, pos = 0; i < searchSpace; i++) {
        // Check for access to publics, non-publics
        if (COMMember::PublicEvent(&pEvents->events[i])) {
            if (!addPub) continue;
        }
        else {
            if (!addPriv) continue;
            if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
        }

        if (declaredOnly) {
            if (pEvents->events[i].pDeclCls != pEEC)
                 continue;
        }

        // Check fo static instance 
        if (COMMember::StaticEvent(&pEvents->events[i])) {
            if (!addStatic) continue;
        }
        else {
            if (!addInst) continue;
        }

        refMethod = (REFLECTTOKENBASEREF) pEvents->events[i].GetEventInfo(pRC);
        pRet->SetAt(pos++, (OBJECTREF) refMethod);
    }

    // Copy to a new array if we didn't fill up the first array
    if (i != pos) {
        PTRARRAYREF retArray = (PTRARRAYREF) AllocateObjectArray(pos, 
            g_pRefUtil->GetTrueType(RC_Event));
        for(i = 0; i < pos; i++)
            retArray->SetAt(i, pRet->GetAt(i));
        pRet = retArray;
    }

    *((PTRARRAYREF *)&rv) = pRet;
    GCPROTECT_END();
    return rv;
}

// GetProperties
// This method will return an array of Properties for each of the
//  properties defined in this class.  An empty array is return if
//  no properties exist.
LPVOID __stdcall COMClass::GetProperties(_GetPropertiesArgs* args)
{
    PTRARRAYREF     pRet;
    LPVOID          rv;
    HENUMInternal   hEnum;
    RefSecContext   sCtx;

    //@TODO:FILTER

    THROWSCOMPLUSEXCEPTION();

    // Find the properties
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();

    // Get the Properties from the Class
    ReflectPropertyList* pProps = pRC->GetProperties();
    if (pProps->dwTotal == 0) {
        pRet = (PTRARRAYREF) AllocateObjectArray(0, g_pRefUtil->GetTrueType(RC_Prop));
        *((PTRARRAYREF *)&rv) = pRet;
        return rv;
    }

    // The Search modifiers
    bool ignoreCase = ((args->bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((args->bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->bindingAttr & BINDER_Public) != 0);

    DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pProps->dwTotal : pProps->dwProps;

    pRet = (PTRARRAYREF) AllocateObjectArray(searchSpace, g_pRefUtil->GetTrueType(RC_Prop));
    GCPROTECT_BEGIN(pRet);

    MethodTable *pParentMT = pEEC->GetMethodTable();

    for (ULONG i = 0, pos = 0; i < searchSpace; i++) {
        // Check for access to publics, non-publics
        if (COMMember::PublicProperty(&pProps->props[i])) {
            if (!addPub) continue;
        }
        else {
            if (!addPriv) continue;
            if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
        }

        if (declaredOnly) {
            if (pProps->props[i].pDeclCls != pEEC)
                 continue;
        }
        // Check for static instance 
        if (COMMember::StaticProperty(&pProps->props[i])) {
            if (!addStatic) continue;
        }
        else {
            if (!addInst) continue;
        }

        OBJECTREF o = (OBJECTREF) pProps->props[i].GetPropertyInfo(pRC);
        pRet->SetAt(pos++, o);
    }

    // Copy to a new array if we didn't fill up the first array
    if (i != pos) {
        PTRARRAYREF retArray = (PTRARRAYREF) AllocateObjectArray(pos, 
            g_pRefUtil->GetTrueType(RC_Prop));
        for(i = 0; i < pos; i++)
            retArray->SetAt(i, pRet->GetAt(i));
        pRet = retArray;
    }

    *((PTRARRAYREF *)&rv) = pRet;
    GCPROTECT_END();
    return rv;
}

void COMClass::GetNameInternal(ReflectClass *pRC, int nameType, CQuickBytes *qb)
{
    LPCUTF8           szcName = NULL;
    LPCUTF8           szToName;
    bool              fNameSpace = (nameType & TYPE_NAMESPACE) ? true : false;
    bool              fAssembly = (nameType & TYPE_ASSEMBLY) ? true : false;
    mdTypeDef         mdEncl;
    IMDInternalImport *pImport;
    bool              fSetName = false;

    THROWSCOMPLUSEXCEPTION();

    szToName = _GetName(pRC, fNameSpace && !pRC->IsNested(), qb);

    pImport = pRC->GetModule()->GetMDImport();

    // Get original element for parameterized type
    EEClass *pTypeClass = pRC->GetTypeHandle().GetClassOrTypeParam();
    _ASSERTE(pTypeClass);
    mdEncl = pTypeClass->GetCl();

    // Only look for nesting chain if this is a nested type.
    DWORD dwAttr;
    pTypeClass->GetMDImport()->GetTypeDefProps(mdEncl, &dwAttr, NULL);
    if (fNameSpace && (IsTdNested(dwAttr)))
    {   // Build the nesting chain.
        while (SUCCEEDED(pImport->GetNestedClassProps(mdEncl, &mdEncl))) {
            CQuickBytes qb2;
            CQuickBytes qb3;
            LPCUTF8 szEnclName;
            LPCUTF8 szEnclNameSpace;
            pImport->GetNameOfTypeDef(mdEncl,
                                      &szEnclName,
                                      &szEnclNameSpace);

            ns::MakePath(qb2, szEnclNameSpace, szEnclName);
            ns::MakeNestedTypeName(qb3, (LPCUTF8) qb2.Ptr(), szToName);
            
            // @todo: this should be a SIZE_T
            int iLen = (int)strlen((LPCUTF8) qb3.Ptr()) + 1;
            if (qb->Alloc(iLen) == NULL)
                COMPlusThrowOM();
            strncpy((LPUTF8) qb->Ptr(), (LPCUTF8) qb3.Ptr(), iLen);
            szToName = (LPCUTF8) qb->Ptr();
            fSetName = true;
        }
    }

    if(fAssembly) {
        CQuickBytes qb2;
        Assembly* pAssembly = pRC->GetTypeHandle().GetAssembly();
        LPCWSTR pAssemblyName;
        if(SUCCEEDED(pAssembly->GetFullName(&pAssemblyName))) {
            #define MAKE_TRANSLATIONFAILED COMPlusThrow(kArgumentException, L"Argument_InvalidAssemblyName");
            MAKE_WIDEPTR_FROMUTF8(wName, szToName);
            ns::MakeAssemblyQualifiedName(qb2, wName, pAssemblyName);
            MAKE_UTF8PTR_FROMWIDE(szQualName, (LPWSTR)qb2.Ptr());
            #undef MAKE_TRANSLATIONFAILED
            // @todo: this should be a SIZE_T
            int iLen = (int)strlen(szQualName) + 1;
            if (qb->Alloc(iLen) == NULL)
                COMPlusThrowOM();
            strncpy((LPUTF8) qb->Ptr(), szQualName, iLen);
            fSetName = true;
        }
    }

    // In some cases above, we have written the Type name into the QuickBytes pointer already.
    // Make sure we don't call qb.Alloc then, which will free that memory, allocate new memory 
    // then try using the freed memory.
    if (!fSetName && qb->Ptr() != (void*)szToName) {
        int iLen = (int)strlen(szToName) + 1;
        if (qb->Alloc(iLen) == NULL)
            COMPlusThrowOM();
        strncpy((LPUTF8) qb->Ptr(), szToName, iLen);
    }
}

LPCUTF8 COMClass::_GetName(ReflectClass* pRC, BOOL fNameSpace, CQuickBytes *qb)
{
    THROWSCOMPLUSEXCEPTION();

    LPCUTF8         szcNameSpace;
    LPCUTF8         szToName;
    LPCUTF8         szcName;

    // Convert the name to a string
    pRC->GetName(&szcName, (fNameSpace) ? &szcNameSpace : NULL);
    if(!szcName) {
        _ASSERTE(!"Unable to get Name of Class");
        FATAL_EE_ERROR();
    }

    // Construct the fully qualified name
    if (fNameSpace && szcNameSpace && *szcNameSpace)
    {
        ns::MakePath(*qb, szcNameSpace, szcName);
        szToName = (LPCUTF8) qb->Ptr();
    }

    //this else part should be removed
    else
    {
        // This is a bit of a hack.  For Arrays we really only have a single
        //  name which is fully qualified.  We need to remove the full qualification
        if (pRC->IsArray() && !fNameSpace) {
            szToName = ns::FindSep(szcName);
            if (szToName)
                ++szToName;
            else
                szToName = szcName;
        }
        else 
            szToName = szcName;
    }

    return szToName;
}

/*
// helper function to get the full name of a nested class
void GetNestedClassMangledName(IMDInternalImport *pImport, 
                               mdTypeDef mdClsToken, 
                               CQuickBytes *qbName, 
                               LPCUTF8* szcNamespace)
{
    mdTypeDef mdEncl;
    LPCUTF8 pClassName;
    if (SUCCEEDED(pImport->GetNestedClassProps(mdClsToken, &mdEncl))) {
        LPCUTF8 pNamespace;
        GetNestedClassMangledName(pImport, mdEncl, qbName, szcNamespace);
        pImport->GetNameOfTypeDef(mdClsToken, &pClassName, &pNamespace);
        size_t size = qbName->Size();
        qbName->Resize(size + 2 + strlen((LPCSTR)pClassName));
        ((LPCSTR)qbName->Ptr())[size] = NESTED_SEPARATOR_CHAR;
        strcpy((LPCSTR)qbName->Ptr() + size + 1, (LPCSTR)pClassName);
    }
    else {
        pImport->GetNameOfTypeDef(mdEncl, &pClassName, szNamespace);
        qbName->Resize(strlen((LPCSTR)pClassName) + 1);
        strcpy((LPCSTR)qbName->Ptr(), (LPCSTR)pClassName);
    }
}
*/

// _GetName
// If the bFullName is true, the fully qualified class name is returned
//  otherwise just the class name is returned.
LPVOID COMClass::_GetName(_GETNAMEARGS* args, int nameType)
{

    LPVOID            rv      = NULL;      // Return value
    STRINGREF         refName;
    CQuickBytes       qb;

    THROWSCOMPLUSEXCEPTION();

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    GetNameInternal(pRC, nameType, &qb);
    refName = COMString::NewString((LPUTF8)qb.Ptr());
    
    *((STRINGREF *)&rv) = refName;
    return rv;
}

// GetClassHandle
// This method with return a unique ID meaningful to the EE and equivalent to
// the result of the ldtoken instruction.
void* __stdcall COMClass::GetClassHandle(_GETCLASSHANDLEARGS* args)
{
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    if (pRC->IsArray()) {
        ReflectArrayClass* pRAC = (ReflectArrayClass*) pRC;
        TypeHandle ret = pRAC->GetTypeHandle();
        return ret.AsPtr();
    }
    if (pRC->IsTypeDesc()) {
        ReflectTypeDescClass* pRTD = (ReflectTypeDescClass*) pRC;
        TypeHandle ret = pRTD->GetTypeHandle();
        return ret.AsPtr();
    }

    return pRC->GetClass()->GetMethodTable();
}

// GetClassFromHandle
// This method with return a unique ID meaningful to the EE and equivalent to
// the result of the ldtoken instruction.
FCIMPL1(Object*, COMClass::GetClassFromHandle, LPVOID handle) {
    Object* retVal;

    if (handle == 0)
        FCThrowArgumentEx(kArgumentException, NULL, L"InvalidOperation_HandleIsNotInitialized");

    //
    // Get the TypeHandle from our handle and convert that to an EEClass.
    //
    TypeHandle typeHnd(handle);
    if (!typeHnd.IsTypeDesc()) {
        EEClass *pClass = typeHnd.GetClass();

        //
        // If we got an EEClass, check to see if we've already allocated 
        // a type object for it.  If we have, then simply return that one
        // and don't build a method frame.
        //
        if (pClass) {
            OBJECTREF o = pClass->GetExistingExposedClassObject();
            if (o != NULL) {
                return (OBJECTREFToObject(o));
            }
        }
    }

    //
    // We haven't already created the type object.  Create the helper 
    // method frame (we're going to be allocating an object) and call
    // the helper to create the object
    //
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    retVal = OBJECTREFToObject(typeHnd.CreateClassObj());
    HELPER_METHOD_FRAME_END();
    return retVal;
}
FCIMPLEND

// This method triggers the class constructor for a give type
FCIMPL1(void, COMClass::RunClassConstructor, LPVOID handle) 
{
    if (handle == NULL)
        FCThrowArgumentVoidEx(kArgumentException, NULL, L"InvalidOperation_HandleIsNotInitialized");

    TypeHandle typeHnd(handle);
    Assembly *pAssem = typeHnd.GetAssembly();
    if (!pAssem->IsDynamic() || pAssem->HasRunAccess()) 
    {
        if (typeHnd.IsUnsharedMT()) 
        {
            MethodTable *pMT = typeHnd.AsMethodTable();
    
            if (pMT->IsClassInited())
                return;
    
            if (pMT->IsShared())
            {
                DomainLocalBlock *pLocalBlock = GetAppDomain()->GetDomainLocalBlock();
    
                if (pLocalBlock->IsClassInitialized(pMT->GetSharedClassIndex()))
                    return;
            }
                        
            OBJECTREF pThrowable = NULL;
            HELPER_METHOD_FRAME_BEGIN_1(pThrowable);
            if (!pMT->CheckRunClassInit(&pThrowable))
            {
                THROWSCOMPLUSEXCEPTION();
                COMPlusThrow(pThrowable);
            }
            HELPER_METHOD_FRAME_END();
        }
    } 
    else 
    {
        HELPER_METHOD_FRAME_BEGIN_0();
        THROWSCOMPLUSEXCEPTION();
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");
        HELPER_METHOD_FRAME_END();
    }
}
FCIMPLEND

INT32  __stdcall COMClass::InternalIsPrimitive(REFLECTCLASSBASEREF args)
{
    ReflectClass* pRC = (ReflectClass*) args->GetData();
    _ASSERTE(pRC);
    CorElementType type = pRC->GetCorElementType();
    return (InvokeUtil::IsPrimitiveType(type)) ? 1 : 0;
}   

// GetProperName 
// This method returns the fully qualified name of any type.  In other
// words, it now does the same thing as GetFullName() below.
LPVOID __stdcall COMClass::GetProperName(_GETNAMEARGS* args)
{
        return _GetName(args, TYPE_NAME | TYPE_NAMESPACE);
}

// GetName 
// This method returns the unqualified name of a primitive as a String
LPVOID __stdcall COMClass::GetName(_GETNAMEARGS* args)
{
        return _GetName(args, TYPE_NAME);
}


// GetFullyName
// This will return the fully qualified name of the class as a String.
LPVOID __stdcall COMClass::GetFullName(_GETNAMEARGS* args)
{
    return _GetName(args, TYPE_NAME | TYPE_NAMESPACE);
}

// GetAssemblyQualifiedyName
// This will return the assembly qualified name of the class as a String.
LPVOID __stdcall COMClass::GetAssemblyQualifiedName(_GETNAMEARGS* args)
{
    return _GetName(args, TYPE_NAME | TYPE_NAMESPACE | TYPE_ASSEMBLY);
}

// GetNameSpace
// This will return the name space of a class as a String.
LPVOID __stdcall COMClass::GetNameSpace(_GETNAMEARGS* args)
{

    LPVOID          rv                          = NULL;      // Return value
    LPCUTF8         szcName;
    LPCUTF8         szcNameSpace;
    STRINGREF       refName = NULL;


    THROWSCOMPLUSEXCEPTION();

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // Convert the name to a string
    pRC->GetName(&szcName, &szcNameSpace);
    if(!szcName) {
        _ASSERTE(!"Unable to get Name of Class");
        FATAL_EE_ERROR();
    }

    if(szcNameSpace && *szcNameSpace) {
        // Create the string object
        refName = COMString::NewString(szcNameSpace);
    }
    else {
        if (pRC->IsNested()) {
            if (pRC->IsArray() || pRC->IsTypeDesc()) {
                EEClass *pTypeClass = pRC->GetTypeHandle().GetClassOrTypeParam();
                _ASSERTE(pTypeClass);
                mdTypeDef mdEncl = pTypeClass->GetCl();
                IMDInternalImport *pImport = pTypeClass->GetMDImport();

                // Only look for nesting chain if this is a nested type.
                DWORD dwAttr = 0;
                pImport->GetTypeDefProps(mdEncl, &dwAttr, NULL);
                if (IsTdNested(dwAttr))
                {   // Get to the outermost class
                    while (SUCCEEDED(pImport->GetNestedClassProps(mdEncl, &mdEncl)));
                    pImport->GetNameOfTypeDef(mdEncl, &szcName, &szcNameSpace);
                }
            }
        }
        else {
            if (pRC->IsArray()) {
                int len = (int)strlen(szcName);
                const char* p = (len == 0) ? szcName : (szcName + len - 1);
                while (p != szcName && *p != '.') p--;
                if (p != szcName) {
                    len = (int)(p - szcName); // @TODO LBS - pointer math
                    char *copy = (char*) _alloca(len + 1);
                    strncpy(copy,szcName,len);
                    copy[len] = 0;
                    szcNameSpace = copy;
                }               
            }
        }
    }
    
    if(szcNameSpace && *szcNameSpace) {
        // Create the string object
        refName = COMString::NewString(szcNameSpace);
    }

    *((STRINGREF *)&rv) = refName;
    return rv;
}

// GetGUID
// This method will return the version-independent GUID for the Class.  This is 
//  a CLSID for a class and an IID for an Interface.
void __stdcall COMClass::GetGUID(_GetGUIDArgs* args)
{


    EEClass*        pVMC;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    pVMC = pRC->GetClass();
    THROWSCOMPLUSEXCEPTION();

    if (args->retRef == NULL)
        COMPlusThrow(kNullReferenceException);


    if (args->refThis->IsComObjectClass()) {
        ComClassFactory* pComClsFac = (ComClassFactory*) pRC->GetCOMObject();
        if (pComClsFac)
            memcpy(args->retRef,&pComClsFac->m_rclsid,sizeof(GUID));
        else
            memset(args->retRef,0,sizeof(GUID));
        return;
    }

    if (pRC->IsArray() || pRC->IsTypeDesc()) {
        memset(args->retRef,0,sizeof(GUID));
        return;
    }

    //@TODO: How do we want to abstract this?
    _ASSERTE(pVMC);
    GUID guid;
    pVMC->GetGuid(&guid, TRUE);
    memcpyNoGCRefs(args->retRef, &guid, sizeof(GUID));
}

// GetAttributeFlags
// Return the attributes that are associated with this Class.
FCIMPL1(INT32, COMClass::GetAttributeFlags, ReflectClassBaseObject* refThis) {
   
    VALIDATEOBJECTREF(refThis);

    THROWSCOMPLUSEXCEPTION();

    DWORD dwAttributes = 0;
    BOOL fComClass = FALSE;

    ReflectClassBaseObject* reflectThis = NULL;
    HELPER_METHOD_FRAME_BEGIN_RET_1(reflectThis);
    reflectThis = refThis;
    
    if (reflectThis == NULL)
       COMPlusThrow(kNullReferenceException, L"NullReference_This");

    fComClass = reflectThis->IsComObjectClass();
    if (!fComClass)
    {        
        ReflectClass* pRC = (ReflectClass*) (reflectThis->GetData());
        _ASSERTE(pRC);

        if (pRC == NULL)
            COMPlusThrow(kNullReferenceException);

        dwAttributes = pRC->GetAttributes();
    }
    HELPER_METHOD_FRAME_END();
    
    if (fComClass)
        return tdPublic;
        
    return dwAttributes;
}
FCIMPLEND

// IsArray
// This method return true if the Class represents an array.
INT32  __stdcall COMClass::IsArray(_IsArrayArgs* args)
{
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);
    INT32 ret = pRC->IsArray();
    return ret;
}

// Invalidate the cached nested type information
INT32  __stdcall COMClass::InvalidateCachedNestedType(_IsArrayArgs* args)
{
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);
    pRC->InvalidateCachedNestedTypes();
    return 0;
}   //InvalidateCachedNestedType

// GetArrayElementType
// This routine will return the base type of a composite type.  
// It returns null if it is a plain type
LPVOID __stdcall COMClass::GetArrayElementType(_GetArrayElementTypeArgs* args)
{

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // If this is not an array class then throw an exception
    if (pRC->IsArray()) {

        // Get the Element type handle and return the Type representing it.
        ReflectArrayClass* pRAC = (ReflectArrayClass*) pRC;
        ArrayTypeDesc* pArrRef= pRAC->GetTypeHandle().AsArray();
        TypeHandle elemType = pRAC->GetElementTypeHandle();
        // We can ignore the possible null return because this will not fail
        return(OBJECTREFToObject(elemType.CreateClassObj()));
    }

    if (pRC->IsTypeDesc()) {
        ReflectTypeDescClass* pRTD = (ReflectTypeDescClass*) pRC;
        TypeDesc* td = pRC->GetTypeHandle().AsTypeDesc();
        TypeHandle th = td->GetTypeParam();
        // We can ignore the possible null return because this will not fail
        return(OBJECTREFToObject(th.CreateClassObj()));
    }

    return 0;
}

// InternalGetArrayRank
// This routine will return the rank of an array assuming the Class represents an array.  
INT32  __stdcall COMClass::InternalGetArrayRank(_InternalGetArrayRankArgs* args)
{
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    _ASSERTE( pRC->IsArray() );
 
    ReflectArrayClass* pRAC = (ReflectArrayClass*) pRC;
    return pRAC->GetTypeHandle().AsArray()->GetRank();
}


//CanCastTo
//Check to see if we can cast from one runtime type to another.
FCIMPL2(INT32, COMClass::CanCastTo, ReflectClassBaseObject* refFrom, ReflectClassBaseObject *refTo) 
{
    VALIDATEOBJECTREF(refFrom);
    VALIDATEOBJECTREF(refTo);

    if (refFrom->GetMethodTable() != g_pRefUtil->GetClass(RC_Class) ||
        refTo->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        FCThrow(kArgumentException);

    // Find the properties
    ReflectClass* pRC = (ReflectClass*) refTo->GetData();
    TypeHandle toTH = pRC->GetTypeHandle();
    pRC = (ReflectClass*) refFrom->GetData();
    TypeHandle fromTH = pRC->GetTypeHandle();
    return fromTH.CanCastTo(toTH) ? 1 : 0;
}
FCIMPLEND

// InvokeDispMethod
// This method will be called on a COM Classic object and simply calls
//  the interop IDispatch method
LPVOID  __stdcall COMClass::InvokeDispMethod(_InvokeDispMethodArgs* args)
{
    _ASSERTE(args->target != NULL);
    _ASSERTE(args->target->GetMethodTable()->IsComObjectType());

    // Unless security is turned off, we need to validate that the calling code
    // has unmanaged code access privilege.
    if (!Security::IsSecurityOff())
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);

    int flags = 0;
    if (args->invokeAttr & BINDER_InvokeMethod)
        flags |= DISPATCH_METHOD;
    if (args->invokeAttr & BINDER_GetProperty)
        flags |= DISPATCH_PROPERTYGET;
    if (args->invokeAttr & BINDER_SetProperty)
        flags = DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF;
    if (args->invokeAttr & BINDER_PutDispProperty)
        flags = DISPATCH_PROPERTYPUT;
    if (args->invokeAttr & BINDER_PutRefDispProperty)
        flags = DISPATCH_PROPERTYPUTREF;
    if (args->invokeAttr & BINDER_CreateInstance)
        flags = DISPATCH_CONSTRUCT;

    LPVOID RetVal = NULL;
    OBJECTREF RetObj = NULL;
    GCPROTECT_BEGIN(RetObj)
    {
        IUInvokeDispMethod((OBJECTREF *)&args->refThis, 
                           &args->target,
                           (OBJECTREF*)&args->name,
                           NULL,
                           (OBJECTREF*)&args->args,
                           (OBJECTREF*)&args->byrefModifiers,
                           (OBJECTREF*)&args->namedParameters,
                           &RetObj,
                           args->lcid, 
                           flags, 
                           args->invokeAttr & BINDER_IgnoreReturn,
                           args->invokeAttr & BINDER_IgnoreCase);

        *((OBJECTREF *)&RetVal) = RetObj;
    }
    GCPROTECT_END();

    return RetVal;
}


// IsPrimitive
// This method return true if the Class represents primitive type
FCIMPL1(INT32, COMClass::IsPrimitive, ReflectClassBaseObject* refThis) {
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);
    CorElementType type = pRC->GetCorElementType();
    if (type == ELEMENT_TYPE_I && !pRC->GetClass()->IsTruePrimitive())
        return 0;
    return (InvokeUtil::IsPrimitiveType(type)) ? 1 : 0;
}
FCIMPLEND

// IsCOMObject
// This method return true if the Class represents COM Classic Object
FCIMPL1(INT32, COMClass::IsCOMObject, ReflectClassBaseObject* refThis) {
    VALIDATEOBJECTREF(refThis);
    return (refThis->IsComWrapperClass()) ? 1 : 0;
}
FCIMPLEND

// IsGenericCOMObject
FCIMPL1(INT32, COMClass::IsGenericCOMObject, ReflectClassBaseObject* refThis) {
    VALIDATEOBJECTREF(refThis);
    BOOL isComObject;
    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL(); // NOPOLL so that we dont need to protect refThis
    isComObject = refThis->IsComObjectClass();
    HELPER_METHOD_FRAME_END_POLL();
    return isComObject;
}
FCIMPLEND

// GetClass
// This is a static method defined on Class that will get a named class.
//  The name of the class is passed in by string.  The class name may be
//  either case sensitive or not.  This currently causes the class to be loaded
//  because it goes through the class loader.

// You get here from Type.GetType(typename)
// ECALL frame is used to find the caller
LPVOID __stdcall COMClass::GetClass1Arg(_GetClass1Args* args)
{
    THROWSCOMPLUSEXCEPTION();

    return GetClassInner(&args->className, false, false, NULL, NULL, true, false);
}

// You get here from Type.GetType(typename, bThowOnError)
// ECALL frame is used to find the caller
LPVOID __stdcall COMClass::GetClass2Args(_GetClass2Args* args)
{
    THROWSCOMPLUSEXCEPTION();

    return GetClassInner(&args->className, args->bThrowOnError,
                         false, NULL, NULL, true, false);
}

// You get here from Type.GetType(typename, bThowOnError, bIgnoreCase)
// ECALL frame is used to find the caller
LPVOID __stdcall COMClass::GetClass3Args(_GetClass3Args* args)
{
    THROWSCOMPLUSEXCEPTION();

    return GetClassInner(&args->className, args->bThrowOnError,
                         args->bIgnoreCase, NULL, NULL, true, false);
}

// Called internally by mscorlib. No security checking performed.
LPVOID __stdcall COMClass::GetClassInternal(_GetClassInternalArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    return GetClassInner(&args->className, args->bThrowOnError,
                         args->bIgnoreCase, NULL, NULL, false, args->bPublicOnly);
}

// You get here if some BCL method calls RuntimeType.GetTypeImpl. In this case we cannot
// use the ECALL frame to find the caller, as it'll point to mscorlib ! In this case we use stackwalk/stackmark 
// to find the caller
LPVOID __stdcall COMClass::GetClass(_GetClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL *fResult = NULL;
    if (*args->pbAssemblyIsLoading) {
        *args->pbAssemblyIsLoading = FALSE;
        fResult = args->pbAssemblyIsLoading;
    }

    return GetClassInner(&args->className, args->bThrowOnError,
                         args->bIgnoreCase, args->stackMark,
                         fResult, true, false);
}

LPVOID COMClass::GetClassInner(STRINGREF *refClassName, 
                               BOOL bThrowOnError, 
                               BOOL bIgnoreCase, 
                               StackCrawlMark *stackMark,
                               BOOL *pbAssemblyIsLoading,
                               BOOL bVerifyAccess,
                               BOOL bPublicOnly)
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF       sRef = *refClassName;
    if (!sRef)
        COMPlusThrowArgumentNull(L"className",L"ArgumentNull_String");

    DWORD           strLen = sRef->GetStringLength() + 1;
    LPUTF8          szFullClassName = (LPUTF8)_alloca(strLen);
    CQuickBytes     bytes;
    DWORD           cClassName;

    // Get the class name in UTF8
    if (!COMString::TryConvertStringDataToUTF8(sRef, szFullClassName, strLen))
        szFullClassName = GetClassStringVars(sRef, &bytes, &cClassName);

    HRESULT         hr;
    LPUTF8          assembly;
    LPUTF8          szNameSpaceSep;
    if (FAILED(hr = AssemblyNative::FindAssemblyName(szFullClassName,
                                                     &assembly,
                                                     &szNameSpaceSep)))
        COMPlusThrowHR(hr);

    EEClass *pCallersClass = NULL;
    Assembly *pCallersAssembly = NULL;
    void *returnIP = NULL;
    BOOL fCheckedPerm = FALSE;


    if (bVerifyAccess || (assembly && *assembly)) {
        // Find the return address. This can be used to find caller's assembly.
        // If we're not checking security, the caller is always mscorlib.
        Frame *pFrame = GetThread()->GetFrame();
        _ASSERTE(pFrame->IsFramedMethodFrame());
        returnIP = pFrame->GetReturnAddress();

        if (!bVerifyAccess)
            fCheckedPerm = TRUE;
    } else {
        pCallersAssembly = SystemDomain::SystemAssembly();
        fCheckedPerm = TRUE;
    }


    LOG((LF_CLASSLOADER, 
         LL_INFO100, 
         "Get class %s through reflection\n", 
         szFullClassName));
    
    Assembly* pAssembly = NULL;
    TypeHandle typeHnd;
    NameHandle typeName;
    char noNameSpace = '\0';
    
    if (szNameSpaceSep) {
        *szNameSpaceSep = '\0';
        typeName.SetName(szFullClassName, szNameSpaceSep+1);
    }
    else
        typeName.SetName(&noNameSpace, szFullClassName);
    
    if(bIgnoreCase)
        typeName.SetCaseInsensitive();
    
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    
    if(assembly && *assembly) {
        
        AssemblySpec spec;
        hr = spec.Init(assembly);
        
        if (SUCCEEDED(hr)) {
            
            pCallersClass = GetCallersClass(stackMark, returnIP);
            pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
            if (pCallersAssembly && (!pCallersAssembly->IsShared()))
                spec.GetCodeBase()->SetParentAssembly(pCallersAssembly->GetFusionAssembly());
            
            hr = spec.LoadAssembly(&pAssembly, &Throwable, false, (pbAssemblyIsLoading != NULL));
            if(SUCCEEDED(hr)) {
                typeHnd = pAssembly->FindNestedTypeHandle(&typeName, &Throwable);
                
                if (typeHnd.IsNull() && (Throwable == NULL)) 
                    // If it wasn't in the available table, maybe it's an internal type
                    typeHnd = pAssembly->GetInternalType(&typeName, bThrowOnError, &Throwable);
            }
            else if (pbAssemblyIsLoading &&
                     (hr == MSEE_E_ASSEMBLYLOADINPROGRESS))
                *pbAssemblyIsLoading = TRUE;
        }
    }
    else {
        // Look for type in caller's assembly
        if (pCallersAssembly == NULL) {
            pCallersClass = GetCallersClass(stackMark, returnIP);
            pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
        }
        if (pCallersAssembly) {
            typeHnd = pCallersAssembly->FindNestedTypeHandle(&typeName, &Throwable);
            if (typeHnd.IsNull() && (Throwable == NULL))
                // If it wasn't in the available table, maybe it's an internal type
                typeHnd = pCallersAssembly->GetInternalType(&typeName, bThrowOnError, &Throwable);
        }
        
        // Look for type in system assembly
        if (typeHnd.IsNull() && (Throwable == NULL) && (pCallersAssembly != SystemDomain::SystemAssembly()))
            typeHnd = SystemDomain::SystemAssembly()->FindNestedTypeHandle(&typeName, &Throwable);
        
        BaseDomain *pDomain = SystemDomain::GetCurrentDomain();
        if (typeHnd.IsNull() &&
            (pDomain != SystemDomain::System())) {
            if (szNameSpaceSep)
                *szNameSpaceSep = NAMESPACE_SEPARATOR_CHAR;
            if ((pAssembly = ((AppDomain*) pDomain)->RaiseTypeResolveEvent(szFullClassName, &Throwable)) != NULL) {
                if (szNameSpaceSep)
                    *szNameSpaceSep = '\0';
                typeHnd = pAssembly->FindNestedTypeHandle(&typeName, &Throwable);
                
                if (typeHnd.IsNull() && (Throwable == NULL)) {
                    // If it wasn't in the available table, maybe it's an internal type
                    typeHnd = pAssembly->GetInternalType(&typeName, bThrowOnError, &Throwable);
                }
                else
                    Throwable = NULL;
            }
        }
        
        if (!typeHnd.IsNull())
            pAssembly = typeHnd.GetAssembly();
    }
    
    if (Throwable != NULL && bThrowOnError)
        COMPlusThrow(Throwable);
    GCPROTECT_END();
    
    BOOL fVisible = TRUE;
    if (!typeHnd.IsNull() && !fCheckedPerm && bVerifyAccess) {

        // verify visibility
        EEClass *pClass = typeHnd.GetClassOrTypeParam();
        
        if (bPublicOnly && !(IsTdPublic(pClass->GetProtection()) || IsTdNestedPublic(pClass->GetProtection())))
            // the user is asking for a public class but the class we have is not public, discard
            fVisible = FALSE;
        else {
            // if the class is a top level public there is no check to perform
            if (!IsTdPublic(pClass->GetProtection())) {
                if (!pCallersAssembly) {
                    pCallersClass = GetCallersClass(stackMark, returnIP);
                    pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
                }
                
                if (pCallersAssembly && // full trust for interop
                    !ClassLoader::CanAccess(pCallersClass,
                                            pCallersAssembly,
                                            pClass,
                                            pClass->GetAssembly(),
                                            pClass->GetAttrClass())) {
                    // This is not legal if the user doesn't have reflection permission
                    if (!AssemblyNative::HaveReflectionPermission(bThrowOnError))
                        fVisible = FALSE;
                }
            }
        }
    }
        
    if ((!typeHnd.IsNull()) && fVisible)
        return(OBJECTREFToObject(typeHnd.CreateClassObj()));

    if (bThrowOnError) {
        Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);
        if (szNameSpaceSep)
            *szNameSpaceSep = NAMESPACE_SEPARATOR_CHAR;

        if (assembly && *assembly) {
            #define MAKE_TRANSLATIONFAILED pwzAssemblyName=L""
            MAKE_WIDEPTR_FROMUTF8_FORPRINT(pwzAssemblyName, assembly);
            #undef MAKE_TRANSLATIONFAILED
            PostTypeLoadException(NULL, szFullClassName, pwzAssemblyName,
                                  NULL, IDS_CLASSLOAD_GENERIC, &Throwable);
        }
        else if (pCallersAssembly ||
                 (pCallersAssembly = GetCallersAssembly(stackMark, returnIP)) != NULL)
            pCallersAssembly->PostTypeLoadException(szFullClassName, 
                                                    IDS_CLASSLOAD_GENERIC,
                                                    &Throwable);
        else {
            WCHAR   wszTemplate[30];
            if (FAILED(LoadStringRC(IDS_EE_NAME_UNKNOWN,
                                    wszTemplate,
                                    sizeof(wszTemplate)/sizeof(wszTemplate[0]),
                                    FALSE)))
                wszTemplate[0] = L'\0';
            PostTypeLoadException(NULL, szFullClassName, wszTemplate,
                                  NULL, IDS_CLASSLOAD_GENERIC, &Throwable);
        }

        COMPlusThrow(Throwable);
        GCPROTECT_END();
    }

    return NULL;
}


// GetClassFromProgID
// This method will return a Class object for a COM Classic object based
//  upon its ProgID.  The COM Classic object is found and a wrapper object created
LPVOID __stdcall COMClass::GetClassFromProgID(_GetClassFromProgIDArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID              rv = NULL;
    REFLECTCLASSBASEREF refClass = NULL;
    
    GCPROTECT_BEGIN(refClass)
    {
        // Make sure a prog id was provided
        if (args->className == NULL)
            COMPlusThrowArgumentNull(L"progID",L"ArgumentNull_String");

        GetRuntimeType();
    
        COMPLUS_TRY
        {
            // NOTE: this call enables GC
            ComClassFactory::GetComClassFromProgID(args->className, args->server, (OBJECTREF*) &refClass);
        }
        COMPLUS_CATCH
        {
            if (args->bThrowOnError)
                COMPlusRareRethrow();
        } 
        COMPLUS_END_CATCH

        // Set the return value
        *((REFLECTCLASSBASEREF *)&rv) = refClass;
    }
    GCPROTECT_END();

    return rv;
}

// GetClassFromCLSID
// This method will return a Class object for a COM Classic object based
//  upon its ProgID.  The COM Classic object is found and a wrapper object created
LPVOID __stdcall COMClass::GetClassFromCLSID(_GetClassFromCLSIDArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID              rv = NULL;
    REFLECTCLASSBASEREF refClass = NULL;
    
    GCPROTECT_BEGIN(refClass)
    {
        GetRuntimeType();
    
        COMPLUS_TRY
        {
            // NOTE: this call enables GC
            ComClassFactory::GetComClassFromCLSID(args->clsid, args->server, (OBJECTREF*) &refClass);
        }
        COMPLUS_CATCH
        {
            if (args->bThrowOnError)
                COMPlusRareRethrow();
        } 
        COMPLUS_END_CATCH

        // Set the return value
        *((REFLECTCLASSBASEREF *)&rv) = refClass;
    }
    GCPROTECT_END();

    return rv;
}

// GetSuperclass
// This method returns the Class Object representing the super class of this
//  Class.  If there is not super class then we return null.
LPVOID __stdcall COMClass::GetSuperclass(_GETSUPERCLASSARGS* args)
{
    THROWSCOMPLUSEXCEPTION();


    // The the EEClass for this class (This must exist)
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    EEClass*    pEEC = pRC->GetClass();
    if (pEEC) {
        if (pEEC->IsInterface())
            return 0;
    }
    TypeHandle typeHnd = pRC->GetTypeHandle();
    if (typeHnd.IsNull())
        return 0;
    TypeHandle parentType = typeHnd.GetParent();

    REFLECTCLASSBASEREF  refClass = 0;
    // We can ignore the Null return because Transparent proxy if final...
    if (!parentType.IsNull()) 
        refClass = (REFLECTCLASSBASEREF) parentType.CreateClassObj();
    
    return OBJECTREFToObject(refClass);
}

// GetInterfaces
// This routine returns a Class[] containing all of the interfaces implemented
//  by this Class.  If the class implements no interfaces an array of length
//  zero is returned.
LPVOID __stdcall COMClass::GetInterfaces(_GetInterfacesArgs* args)
{
    PTRARRAYREF     refArrIFace;
    LPVOID          rv;
    DWORD           i;

    THROWSCOMPLUSEXCEPTION();
    //@TODO: Abstract this away.
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    EEClass*    pVMC = pRC->GetClass();
    if (pVMC == 0) {
        _ASSERTE(pRC->IsTypeDesc());
        refArrIFace = (PTRARRAYREF) AllocateObjectArray(0, 
            g_pRefUtil->GetTrueType(RC_Class));
        *((PTRARRAYREF *)&rv) = refArrIFace;
        _ASSERTE(rv);
        return rv;
    }
    _ASSERTE(pVMC);

    // Allocate the COM+ array
    refArrIFace = (PTRARRAYREF) AllocateObjectArray(
        pVMC->GetNumInterfaces(), g_pRefUtil->GetTrueType(RC_Class));
    GCPROTECT_BEGIN(refArrIFace);

    // Create interface array
    for(i = 0; i < pVMC->GetNumInterfaces(); i++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = pVMC->GetInterfaceMap()[i].m_pMethodTable->GetClass()->GetExposedClassObject();
        refArrIFace->SetAt(i, o);
        _ASSERTE(refArrIFace->m_Array[i]);
    }

    // Set the return value
    *((PTRARRAYREF *)&rv) = refArrIFace;
    GCPROTECT_END();
    _ASSERTE(rv);
    return rv;
}

// GetInterface
//  This method returns the interface based upon the name of the method.
//@TODO: Fully qualified namespaces and ambiguous use of partial qualification
LPVOID __stdcall COMClass::GetInterface(_GetInterfaceArgs* args)
{

    REFLECTCLASSBASEREF  refIFace;
    LPUTF8          pszIFaceName;
    LPUTF8          pszIFaceNameSpace;
    LPCUTF8         pszcCurIFaceName;
    LPCUTF8         pszcCurIFaceNameSpace;
    DWORD           cIFaceName;
    DWORD           dwNumIFaces;
    LPVOID          rv                 = NULL;
    EEClass**       rgpVMCIFaces;
    EEClass*        pVMCCurIFace       = NULL;
    DWORD           i;

    THROWSCOMPLUSEXCEPTION();

    if (args->interfaceName == NULL)
        COMPlusThrow(kNullReferenceException);

    ReflectClass*   pRC = (ReflectClass*) args->refThis->GetData();
    if (pRC->IsTypeDesc()) 
        return NULL;

    EEClass*        pVMC = pRC->GetClass();
    _ASSERTE(pVMC);

    CQuickBytes bytes;

    // Get the class name in UTF8
    pszIFaceNameSpace = GetClassStringVars((STRINGREF) args->interfaceName, 
                                           &bytes, &cIFaceName);

    ns::SplitInline(pszIFaceNameSpace, pszIFaceNameSpace, pszIFaceName);

    // Get the array of interfaces
    dwNumIFaces = ReflectInterfaces::GetMaxCount(pVMC, false);
    
    if(dwNumIFaces)
    {
        rgpVMCIFaces = (EEClass**) _alloca(dwNumIFaces * sizeof(EEClass*));
        dwNumIFaces = ReflectInterfaces::GetInterfaces(pVMC, rgpVMCIFaces, false);
    }
    else
        rgpVMCIFaces = NULL;

    // Look for a matching interface
    for(i = 0; i < dwNumIFaces; i++)
    {
        // Get an interface's EEClass
        pVMCCurIFace = rgpVMCIFaces[i];
        _ASSERTE(pVMCCurIFace);

        //@TODO: we need to verify this still works.
        // Convert the name to a string
        pVMCCurIFace->GetMDImport()->GetNameOfTypeDef(pVMCCurIFace->GetCl(),
            &pszcCurIFaceName, &pszcCurIFaceNameSpace);
        _ASSERTE(pszcCurIFaceName);

        if(pszIFaceNameSpace &&
           strcmp(pszIFaceNameSpace, pszcCurIFaceNameSpace))
            continue;

        // If the names are a match, break
        if(!args->bIgnoreCase)
        {
            if(!strcmp(pszIFaceName, pszcCurIFaceName))
                break;
        }
        else
            if(!_stricmp(pszIFaceName, pszcCurIFaceName))
                break;
    }

    // If we found an interface then lets save it
    if (i != dwNumIFaces)
    {

        refIFace = (REFLECTCLASSBASEREF) pVMCCurIFace->GetExposedClassObject();
        _ASSERTE(refIFace);
        *((REFLECTCLASSBASEREF *)&rv) = refIFace;
    }

    return rv;
}

// GetMembers
// This method returns an array of Members containing all of the members
//  defined for the class.  Members include constructors, events, properties,
//  methods and fields.
LPVOID  __stdcall COMClass::GetMembers(_GetMembersArgs* args)
{
    DWORD           dwMembers;
    DWORD           dwCur;
    PTRARRAYREF     pMembers;
    LPVOID          rv;
    RefSecContext   sCtx;

    THROWSCOMPLUSEXCEPTION();
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    COMMember::GetMemberInfo();
    _ASSERTE(COMMember::m_pMTIMember);

    EEClass* pEEC = pRC->GetClass();
    if (pEEC == NULL){
        *((OBJECTREF*) &rv) = AllocateObjectArray(0, COMMember::m_pMTIMember->m_pEEClass->GetMethodTable());
        return rv;
    }
    
    // The Search modifiers
    bool ignoreCase = ((args->bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((args->bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((args->bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->bindingAttr & BINDER_Public) != 0);
    
    // The member list...
    ReflectMethodList* pMeths = pRC->GetMethods();
    ReflectMethodList* pCons = pRC->GetConstructors();
    ReflectFieldList* pFlds = pRC->GetFields();
    ReflectPropertyList *pProps = pRC->GetProperties();
    ReflectEventList *pEvents = pRC->GetEvents();
    ReflectTypeList* pNests = pRC->GetNestedTypes();

    // We adjust the total number of members.
    dwMembers = pFlds->dwTotal + pMeths->dwTotal + pCons->dwTotal + 
        pProps->dwTotal + pEvents->dwTotal + pNests->dwTypes;

    // Now create an array of IMembers
    pMembers = (PTRARRAYREF) AllocateObjectArray(
        dwMembers, COMMember::m_pMTIMember->m_pEEClass->GetMethodTable());
    GCPROTECT_BEGIN(pMembers);

    MethodTable *pParentMT = pEEC->GetMethodTable();

    dwCur = 0;

    // Fields
    if (pFlds->dwTotal) {
        // Load all those fields into the Allocated object array
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pFlds->dwTotal : pFlds->dwFields;
        for (DWORD i=0;i<searchSpace;i++) {
            // Check for access to publics, non-publics
            if (pFlds->fields[i].pField->IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, pFlds->fields[i].pField->GetFieldProtection(), pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pFlds->fields[i].pField->IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                if (pFlds->fields[i].pField->GetEnclosingClass() != pEEC)
                    continue;
            }
              // Check for access to non-publics
            if (!addPriv && !pFlds->fields[i].pField->IsPublic())
                continue;

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pFlds->fields[i].GetFieldInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    // Methods
    if (pMeths->dwTotal) {
        // Load all those fields into the Allocated object array
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pMeths->dwTotal : pMeths->dwMethods;
        for (DWORD i=0;i<searchSpace;i++) {
            // Check for access to publics, non-publics
            if (pMeths->methods[i].IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, pMeths->methods[i].attrs, pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pMeths->methods[i].IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                if (pMeths->methods[i].pMethod->GetClass() != pEEC)
                    continue;
            }

            // If the method has a linktime security demand attached, check it now.
            if (!InvokeUtil::CheckLinktimeDemand(&sCtx, pMeths->methods[i].pMethod, false))
                continue;

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pMeths->methods[i].GetMethodInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    // Constructors
    if (pCons->dwTotal) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pCons->dwTotal : pCons->dwMethods;
        for (DWORD i=0;i<pCons->dwMethods;i++) {
            // Check for static .cctors vs. instance .ctors
            if (pCons->methods[i].IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            // Check for access to publics, non-publics
            if (pCons->methods[i].IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, pCons->methods[i].attrs, pParentMT, 0)) continue;
            }

            // If the method has a linktime security demand attached, check it now.
            if (!InvokeUtil::CheckLinktimeDemand(&sCtx, pCons->methods[i].pMethod, false))
                continue;

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pCons->methods[i].GetConstructorInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    //Properties
    if (pProps->dwTotal) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pProps->dwTotal : pProps->dwProps;
        for (DWORD i = 0; i < searchSpace; i++) {
            // Check for access to publics, non-publics
            if (COMMember::PublicProperty(&pProps->props[i])) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
            }

            if (declaredOnly) {
                if (pProps->props[i].pDeclCls != pEEC)
                     continue;
            }

            // Check for static instance 
            if (COMMember::StaticProperty(&pProps->props[i])) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pProps->props[i].GetPropertyInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    //Events
    if (pEvents->dwTotal) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pEvents->dwTotal : pEvents->dwEvents;
        for (DWORD i = 0; i < searchSpace; i++) {
            // Check for access to publics, non-publics
            if (COMMember::PublicEvent(&pEvents->events[i])) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
            }

            if (declaredOnly) {
                if (pEvents->events[i].pDeclCls != pEEC)
                     continue;
            }
            // Check for static instance 
            if (COMMember::StaticEvent(&pEvents->events[i])) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pEvents->events[i].GetEventInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    //Nested Types
    if (pNests->dwTypes) {
        for (DWORD i=0;i<pNests->dwTypes;i++) {

            // Check for access to publics, non-publics
            if (IsTdNestedPublic(pNests->types[i]->GetAttrClass())) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
            }
            if (!InvokeUtil::CheckAccessType(&sCtx, pNests->types[i], 0)) continue;

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pNests->types[i]->GetExposedClassObject();
            pMembers->SetAt(dwCur++, o);
        }       
    }

    _ASSERTE(dwCur <= dwMembers);

    if (dwCur != dwMembers) {
        PTRARRAYREF retArray = (PTRARRAYREF) AllocateObjectArray(
            dwCur, COMMember::m_pMTIMember->m_pEEClass->GetMethodTable());

        //@TODO: Use an array copy
        for(DWORD i = 0; i < (int) dwCur; i++)
            retArray->SetAt(i, pMembers->GetAt(i));
        pMembers = retArray;        
    }

    // Assign the return value
    *((PTRARRAYREF*) &rv) = pMembers;
    GCPROTECT_END();
    return rv;
}

/*========================GetSerializationRegistryValues========================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
FCIMPL2(void, COMClass::GetSerializationRegistryValues, BOOL *ignoreBit, BOOL *logNonSerializable) {
    *ignoreBit = (g_pConfig->GetConfigDWORD(SERIALIZATION_BIT_KEY, SERIALIZATION_BIT_ZERO));
    *logNonSerializable = (g_pConfig->GetConfigDWORD(SERIALIZATION_LOG_KEY, SERIALIZATION_BIT_ZERO));
}
FCIMPLEND

/*============================GetSerializableMembers============================
**Action: Creates an array of all non-static fields and properties
**        on a class.  Properties are also excluded if they don't have get and set
**        methods. Transient fields and properties are excluded based on the value 
**        of args->bFilterTransient.  Essentially, transients are exluded for 
**        serialization but not for cloning.
**Returns: An array of all of the members that should be serialized.
**Arguments: args->refClass: The class being serialized
**           args->bFilterTransient: True if transient members should be excluded.
**Exceptions:
==============================================================================*/
LPVOID  __stdcall COMClass::GetSerializableMembers(_GetSerializableMembersArgs* args)
{

    DWORD           dwMembers;
    DWORD           dwCur;
    PTRARRAYREF     pMembers;
    LPVOID          rv;
    mdFieldDef      fieldDef;
    DWORD           dwFlags;

    //All security checks should be handled in managed code.

    THROWSCOMPLUSEXCEPTION();

    if (args->refClass == NULL)
        COMPlusThrow(kNullReferenceException);

    ReflectClass* pRC = (ReflectClass*) args->refClass->GetData();
    _ASSERTE(pRC);

    COMMember::GetMemberInfo();
    _ASSERTE(COMMember::m_pMTIMember);

    ReflectFieldList* pFlds = pRC->GetFields();

    dwMembers = pFlds->dwFields;

    // Now create an array of IMembers
    pMembers = (PTRARRAYREF) AllocateObjectArray(dwMembers, COMMember::m_pMTIMember->m_pEEClass->GetMethodTable());
    GCPROTECT_BEGIN(pMembers);

    dwCur = 0;
    // Fields
    if (pFlds->dwFields) {
        // Load all those fields into the Allocated object array
        for (DWORD i=0;i<pFlds->dwFields;i++) {
            //We don't serialize static fields.
            if (pFlds->fields[i].pField->IsStatic()) {
                continue;
            }

            //Check for the transient (e.g. don't serialize) bit.  
            fieldDef = (pFlds->fields[i].pField->GetMemberDef());
            dwFlags = (pFlds->fields[i].pField->GetMDImport()->GetFieldDefProps(fieldDef));
            if (IsFdNotSerialized(dwFlags)) {
                continue;
            }

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pFlds->fields[i].GetFieldInfo(pRC);
            pMembers->SetAt(dwCur++, o);
        }       
    }

    //We we have extra space in the array, copy before returning.
    if (dwCur != dwMembers) {
        PTRARRAYREF retArray = (PTRARRAYREF) AllocateObjectArray(
            dwCur, COMMember::m_pMTIMember->m_pEEClass->GetMethodTable());

        //@TODO: Use an array copy
        for(DWORD i = 0; i < (int) dwCur; i++)
            retArray->SetAt(i, pMembers->GetAt(i));

        pMembers = retArray;        
    }


    // Assign the return value
    *((PTRARRAYREF*) &rv) = pMembers;
    GCPROTECT_END();
    return rv;
}

// GetMember
// This method will return an array of Members which match the name
//  passed in.  There may be 0 or more matching members.
LPVOID  __stdcall COMClass::GetMember(_GetMemberArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    ReflectField**      rgpFields = NULL;
    ReflectMethod**     rgpMethods = NULL;
    ReflectMethod**     rgpCons = NULL;
    ReflectProperty**   rgpProps = NULL;
    ReflectEvent**      rgpEvents = NULL;
    EEClass**           rgpNests = NULL;

    DWORD           dwNumFields = 0;
    DWORD           dwNumMethods = 0;
    DWORD           dwNumCtors = 0;
    DWORD           dwNumProps = 0;
    DWORD           dwNumEvents = 0;
    DWORD           dwNumNests = 0;

    DWORD           dwNumMembers = 0;

    DWORD           i;
    DWORD           dwCurIndex;
    bool            bIsPrefix       = false;
    PTRARRAYREF     refArrIMembers;
    LPVOID          rv;
    RefSecContext   sCtx;

    if (args->memberName == 0)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();
    MethodTable *pParentMT = NULL;
    if (pEEC) 
        pParentMT = pEEC->GetMethodTable();

    // The Search modifiers
    bool bIgnoreCase = ((args->bindingAttr & BINDER_IgnoreCase) != 0);
    bool declaredOnly = ((args->bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((args->bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((args->bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((args->bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((args->bindingAttr & BINDER_Public) != 0);

    CQuickBytes bytes;
    LPSTR szMemberName;
    DWORD cMemberName;

    // Convert the STRINGREF to UTF8
    szMemberName = GetClassStringVars((STRINGREF) args->memberName, 
                                      &bytes, &cMemberName);

    // Check to see if wzPrefix requires an exact match of method names or is just a prefix
    if(szMemberName[cMemberName-1] == '*') {
        bIsPrefix = true;
        szMemberName[--cMemberName] = '\0';
    }

    // Get the maximums for each member type
    // Fields
    ReflectFieldList* pFlds = NULL;
    if ((args->memberType & MEMTYPE_Field) != 0) {
        pFlds = pRC->GetFields();
        rgpFields = (ReflectField**) _alloca(pFlds->dwTotal * sizeof(ReflectField*));
    }

    // Methods
    ReflectMethodList* pMeths = NULL;
    if ((args->memberType & MEMTYPE_Method) != 0) {
        pMeths = pRC->GetMethods();
        rgpMethods = (ReflectMethod**) _alloca(pMeths->dwTotal * sizeof(ReflectMethod*));
    }
    
    // Properties
    ReflectPropertyList *pProps = NULL;
    if ((args->memberType & MEMTYPE_Property) != 0) {
        pProps = pRC->GetProperties();
        rgpProps = (ReflectProperty**) _alloca(pProps->dwTotal * sizeof (ReflectProperty*));
    }

    // Events
    ReflectEventList *pEvents = NULL;
    if ((args->memberType & MEMTYPE_Event) != 0) {
        pEvents = pRC->GetEvents();
        rgpEvents = (ReflectEvent**) _alloca(pEvents->dwTotal * sizeof (ReflectEvent*));
    }

    // Nested Types
    ReflectTypeList*    pNests = NULL;
    if ((args->memberType & MEMTYPE_NestedType) != 0) {
        pNests = pRC->GetNestedTypes();
        rgpNests = (EEClass**) _alloca(pNests->dwTypes * sizeof (EEClass*));
    }

    // Filter the constructors
    ReflectMethodList* pCons = 0;

    // Check to see if they are looking for the constructors
    // @TODO - Fix this to use TOUPPER and compare!
    if ((args->memberType & MEMTYPE_Constructor) != 0) {
        if((!bIsPrefix && strlen(COR_CTOR_METHOD_NAME) != cMemberName)
           || (!bIgnoreCase && strncmp(COR_CTOR_METHOD_NAME, szMemberName, cMemberName))
           || (bIgnoreCase && _strnicmp(COR_CTOR_METHOD_NAME, szMemberName, cMemberName)))
        {
            pCons = 0;
        }
        else {
            pCons = pRC->GetConstructors();
            DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pCons->dwTotal : pCons->dwMethods;
            rgpCons = (ReflectMethod**) _alloca(searchSpace * sizeof(ReflectMethod*));
            dwNumCtors = 0;
            for (i = 0; i < searchSpace; i++) {
                // Ignore the class constructor  (if one was present)
                if (pCons->methods[i].IsStatic())
                    continue;

                // Check for access to non-publics
                if (pCons->methods[i].IsPublic()) {
                    if (!addPub) continue;
                }
                else {
                    if (!addPriv) continue;
                    if (!InvokeUtil::CheckAccess(&sCtx, pCons->methods[i].attrs, pParentMT, 0)) continue;
                }

                if (declaredOnly) {
                    if (pCons->methods[i].pMethod->GetClass() != pEEC)
                        continue;
                }

                // If the method has a linktime security demand attached, check it now.
                if (!InvokeUtil::CheckLinktimeDemand(&sCtx, pCons->methods[i].pMethod, false))
                    continue;

                rgpCons[dwNumCtors++] = &pCons->methods[i];
            }
        }

        // check for the class initializer  (We can only be doing either
        //  the class initializer or a constructor so we are using the 
        //  same set of variables.
        // @TODO - Fix this to use TOUPPER and compare!
        if((!bIsPrefix && strlen(COR_CCTOR_METHOD_NAME) != cMemberName)
           || (!bIgnoreCase && strncmp(COR_CCTOR_METHOD_NAME, szMemberName, cMemberName))
           || (bIgnoreCase && _strnicmp(COR_CCTOR_METHOD_NAME, szMemberName, cMemberName)))
        {
            pCons = 0;
        }
        else {
            pCons = pRC->GetConstructors();
            DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pCons->dwTotal : pCons->dwMethods;
            rgpCons = (ReflectMethod**) _alloca(searchSpace * sizeof(ReflectMethod*));
            dwNumCtors = 0;
            for (i = 0; i < searchSpace; i++) {
                // Ignore the normal constructors constructor  (if one was present)
                if (!pCons->methods[i].IsStatic())
                    continue;

                // Check for access to non-publics
                if (pCons->methods[i].IsPublic()) {
                    if (!addPub) continue;
                }
                else {
                    if (!addPriv) continue;
                    if (!InvokeUtil::CheckAccess(&sCtx, pCons->methods[i].attrs, pParentMT, 0)) continue;
                }

                if (declaredOnly) {
                    if (pCons->methods[i].pMethod->GetClass() != pEEC)
                        continue;
                }

                // If the method has a linktime security demand attached, check it now.
                if (!InvokeUtil::CheckLinktimeDemand(&sCtx, pCons->methods[i].pMethod, false))
                    continue;

                rgpCons[dwNumCtors++] = &pCons->methods[i];
            }
        }
    }
    else
        dwNumCtors = 0;

    // Filter the fields
    if ((args->memberType & MEMTYPE_Field) != 0) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pFlds->dwTotal : pFlds->dwFields;
        for(i = 0, dwCurIndex = 0; i < searchSpace; i++)
        {
            // Check for access to publics, non-publics
            if (pFlds->fields[i].pField->IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, pFlds->fields[i].pField->GetFieldProtection(), pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pFlds->fields[i].pField->IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                if (pFlds->fields[i].pField->GetEnclosingClass() != pEEC)
                    continue;
            }

            // Get the name of the current field
            LPCUTF8 pszCurFieldName = pFlds->fields[i].pField->GetName();

            // Check to see that the current field matches the name requirements
            if(!bIsPrefix && strlen(pszCurFieldName) != cMemberName)
                continue;

            // Determine if it passes criteria
            if(!bIgnoreCase)
            {
                if(strncmp(pszCurFieldName, szMemberName, cMemberName))
                    continue;
            }
            // @TODO - Fix this to use TOUPPER and compare!
            else {
                if(_strnicmp(pszCurFieldName, szMemberName, cMemberName))
                    continue;
            }

            // Field passed, so save it
            rgpFields[dwCurIndex++] = &pFlds->fields[i];
        }
        dwNumFields = dwCurIndex;
    }
    else 
        dwNumFields = 0;

    // Filter the methods
    if ((args->memberType & MEMTYPE_Method) != 0) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pMeths->dwTotal : pMeths->dwMethods;
        for (i = 0, dwCurIndex = 0; i < searchSpace; i++) {
            // Check for access to publics, non-publics
            if (pMeths->methods[i].IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, pMeths->methods[i].attrs, pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pMeths->methods[i].IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                if (pMeths->methods[i].pMethod->GetClass() != pEEC)
                    continue;
            }

            // Check to see that the current method matches the name requirements
            if(!bIsPrefix && pMeths->methods[i].dwNameCnt != cMemberName)
                continue;

            // Determine if it passes criteria
            if(!bIgnoreCase)
            {
                if(strncmp(pMeths->methods[i].szName, szMemberName, cMemberName))
                    continue;
            }
            // @TODO - Fix this to use TOUPPER and compare!
            else {
                if(_strnicmp(pMeths->methods[i].szName, szMemberName, cMemberName))
                    continue;
            }
        
            // If the method has a linktime security demand attached, check it now.
            if (!InvokeUtil::CheckLinktimeDemand(&sCtx, pMeths->methods[i].pMethod, false))
                continue;

            // Field passed, so save it
            rgpMethods[dwCurIndex++] = &pMeths->methods[i];
        }
        dwNumMethods = dwCurIndex;
    }
    else
        dwNumMethods = 0;

    //Filter the properties
    if ((args->memberType & MEMTYPE_Property) != 0) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pProps->dwTotal : pProps->dwProps;
        for (i = 0, dwCurIndex = 0; i < searchSpace; i++) {
            // Check for access to publics, non-publics
            if (COMMember::PublicProperty(&pProps->props[i])) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
            }

            if (declaredOnly) {
                if (pProps->props[i].pDeclCls != pEEC)
                     continue;
            }
            // Check fo static instance 
            if (COMMember::StaticProperty(&pProps->props[i])) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            // Check to see that the current property matches the name requirements
            DWORD dwNameCnt = (DWORD)strlen(pProps->props[i].szName);
            if(!bIsPrefix && dwNameCnt != cMemberName)
                continue;

            // Determine if it passes criteria
            if(!bIgnoreCase)
            {
                if(strncmp(pProps->props[i].szName, szMemberName, cMemberName))
                    continue;
            }
            // @TODO - Fix this to use TOUPPER and compare!
            else {
                if(_strnicmp(pProps->props[i].szName, szMemberName, cMemberName))
                    continue;
            }

            // Property passed, so save it
            rgpProps[dwCurIndex++] = &pProps->props[i];
        }
        dwNumProps = dwCurIndex;
    }
    else
        dwNumProps = 0;

    //Filter the events
    if ((args->memberType & MEMTYPE_Event) != 0) {
        DWORD searchSpace = ((args->bindingAttr & BINDER_FlattenHierarchy) != 0) ? pEvents->dwTotal : pEvents->dwEvents;
        for (i = 0, dwCurIndex = 0; i < searchSpace; i++) {
            // Check for access to publics, non-publics
            if (COMMember::PublicEvent(&pEvents->events[i])) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (!InvokeUtil::CheckAccess(&sCtx, mdAssem, pParentMT, 0)) continue;
            }

            if (declaredOnly) {
                if (pEvents->events[i].pDeclCls != pEEC)
                     continue;
            }

            // Check fo static instance 
            if (COMMember::StaticEvent(&pEvents->events[i])) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            // Check to see that the current event matches the name requirements
            DWORD dwNameCnt = (DWORD)strlen(pEvents->events[i].szName);
            if(!bIsPrefix && dwNameCnt != cMemberName)
                continue;

            // Determine if it passes criteria
            if(!bIgnoreCase)
            {
                if(strncmp(pEvents->events[i].szName, szMemberName, cMemberName))
                    continue;
            }
            // @TODO - Fix this to use TOUPPER and compare!
            else {
                if(_strnicmp(pEvents->events[i].szName, szMemberName, cMemberName))
                    continue;
            }

            // Property passed, so save it
            rgpEvents[dwCurIndex++] = &pEvents->events[i];
        }
        dwNumEvents = dwCurIndex;
    }
    else
        dwNumEvents = 0;

    // Filter the Nested Classes
    if ((args->memberType & MEMTYPE_NestedType) != 0) {
        LPUTF8          pszNestName;
        LPUTF8          pszNestNameSpace;

        ns::SplitInline(szMemberName, pszNestNameSpace, pszNestName);
        DWORD cNameSpace;
        if (pszNestNameSpace)
            cNameSpace = (DWORD)strlen(pszNestNameSpace);
        else
            cNameSpace = 0;
        DWORD cName = (DWORD)strlen(pszNestName);
        for (i = 0, dwCurIndex = 0; i < pNests->dwTypes; i++) {
            // Check for access to non-publics
            if (!addPriv && !IsTdNestedPublic(pNests->types[i]->GetAttrClass()))
                continue;
            if (!InvokeUtil::CheckAccessType(&sCtx, pNests->types[i], 0)) continue;

            LPCUTF8 szcName;
            LPCUTF8 szcNameSpace;
            REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pNests->types[i]->GetExposedClassObject();
            ReflectClass* thisRC = (ReflectClass*) o->GetData();
            _ASSERTE(thisRC);

            //******************************************************************
            //@todo:  This is wrong, but I'm not sure what is right.  The question
            //  is whether we want to do prefix matching on namespaces for 
            //  nested classes, and if so, how to do that.  This code will 
            //  simply take any nested class whose namespace has the given
            //  namespace as a prefix AND has a name with the given name as
            //  a prefix.
            // Note that this code also assumes that nested classes are not
            //  decorated as Containing$Nested.
            
            thisRC->GetName(&szcName,&szcNameSpace);
            if(pszNestNameSpace) {

                // Check to see that the nested type matches the namespace requirements
                if(strlen(szcNameSpace) != cNameSpace)
                    continue;

                if (!bIgnoreCase) {
                    if (strncmp(pszNestNameSpace, szcNameSpace, cNameSpace))
                        continue;
                }
                else {
                    if (_strnicmp(pszNestNameSpace, szcNameSpace, cNameSpace))
                        continue;
                }
            }

            // Check to see that the nested type matches the name requirements
            if(!bIsPrefix && strlen(szcName) != cName)
                continue;

            // If the names are a match, break
            if (!bIgnoreCase) {
                if (strncmp(pszNestName, szcName, cName))
                    continue;
            }
            else {
                if (_strnicmp(pszNestName, szcName, cName))
                    continue;
            }

            // Nested Type passed, so save it
            rgpNests[dwCurIndex++] = pNests->types[i];
        }
        dwNumNests = dwCurIndex;
    }
    else
        dwNumNests = 0;


    // Get a grand total
    dwNumMembers = dwNumFields + dwNumMethods + dwNumCtors + dwNumProps + dwNumEvents + dwNumNests;

    // Now create an array of proper MemberInfo
    MethodTable *pArrayType = NULL;
    if (args->memberType == MEMTYPE_Method) {
        _ASSERTE(dwNumFields + dwNumCtors + dwNumProps + dwNumEvents + dwNumNests == 0);
        if (!COMMember::m_pMTMethodInfo) {
            COMMember::m_pMTMethodInfo = g_Mscorlib.GetClass(CLASS__METHOD_INFO);
        }
        pArrayType = COMMember::m_pMTMethodInfo;
    }
    else if (args->memberType == MEMTYPE_Field) {
        _ASSERTE(dwNumMethods + dwNumCtors + dwNumProps + dwNumEvents + dwNumNests == 0);
        if (!COMMember::m_pMTFieldInfo) {
            COMMember::m_pMTFieldInfo = g_Mscorlib.GetClass(CLASS__FIELD_INFO);
        }
        pArrayType = COMMember::m_pMTFieldInfo;
    }
    else if (args->memberType == MEMTYPE_Property) {
        _ASSERTE(dwNumFields + dwNumMethods + dwNumCtors + dwNumEvents + dwNumNests == 0);
        if (!COMMember::m_pMTPropertyInfo) {
            COMMember::m_pMTPropertyInfo = g_Mscorlib.GetClass(CLASS__PROPERTY_INFO);
        }
        pArrayType = COMMember::m_pMTPropertyInfo;
    }
    else if (args->memberType == MEMTYPE_Constructor) {
        _ASSERTE(dwNumFields + dwNumMethods + dwNumProps + dwNumEvents + dwNumNests == 0);
        if (!COMMember::m_pMTConstructorInfo) {
            COMMember::m_pMTConstructorInfo = g_Mscorlib.GetClass(CLASS__CONSTRUCTOR_INFO);
        }
        pArrayType = COMMember::m_pMTConstructorInfo;
    }
    else if (args->memberType == MEMTYPE_Event) {
        _ASSERTE(dwNumFields + dwNumMethods + dwNumCtors + dwNumProps + dwNumNests == 0);
        if (!COMMember::m_pMTEventInfo) {
            COMMember::m_pMTEventInfo = g_Mscorlib.GetClass(CLASS__EVENT_INFO);
        }
        pArrayType = COMMember::m_pMTEventInfo;
    }
    else if (args->memberType == MEMTYPE_NestedType) {
        _ASSERTE(dwNumFields + dwNumMethods + dwNumCtors + dwNumProps + dwNumEvents == 0);
        if (!COMMember::m_pMTType) {
            COMMember::m_pMTType = g_Mscorlib.GetClass(CLASS__TYPE);
        }
        pArrayType = COMMember::m_pMTType;
    }
    else if (args->memberType == (MEMTYPE_Constructor | MEMTYPE_Method)) {
        _ASSERTE(dwNumFields + dwNumProps + dwNumEvents + dwNumNests == 0);
        if (!COMMember::m_pMTMethodBase) {
            COMMember::m_pMTMethodBase = g_Mscorlib.GetClass(CLASS__METHOD_BASE);
        }
        pArrayType = COMMember::m_pMTMethodBase;
    }

    COMMember::GetMemberInfo();
    _ASSERTE(COMMember::m_pMTIMember);

    if (pArrayType == NULL)
        pArrayType = COMMember::m_pMTIMember;

    refArrIMembers = (PTRARRAYREF) AllocateObjectArray(dwNumMembers, pArrayType->m_pEEClass->GetMethodTable());
    GCPROTECT_BEGIN(refArrIMembers);

    // NO GC Below here
    // Now create and assign the reflection objects into the array
    for (i = 0, dwCurIndex = 0; i < dwNumFields; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpFields[i]->GetFieldInfo(pRC);
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    for (i = 0; i < dwNumMethods; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpMethods[i]->GetMethodInfo(pRC);
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    for (i = 0; i < dwNumCtors; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpCons[i]->GetConstructorInfo(pRC);
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    for (i = 0; i < dwNumProps; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpProps[i]->GetPropertyInfo(pRC);
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    for (i = 0; i < dwNumEvents; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpEvents[i]->GetEventInfo(pRC);
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    for (i = 0; i < dwNumNests; i++, dwCurIndex++)
    {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) rgpNests[i]->GetExposedClassObject();
        refArrIMembers->SetAt(dwCurIndex, o);
    }

    // Assign the return value
    *((PTRARRAYREF*) &rv) = refArrIMembers;
    GCPROTECT_END();
    return rv;
}

// GetModule
// This will return the module that the class is defined in.
LPVOID __stdcall COMClass::GetModule(_GETMODULEARGS* args)
{
    OBJECTREF   refModule;
    LPVOID      rv;
    Module*     mod;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // Get the module,  This may fail because
    //  there are classes which don't have modules (Like arrays)
    mod = pRC->GetModule();
    if (!mod)
        return 0;

    // Get the exposed Module Object -- We create only one per Module instance.
    refModule = (OBJECTREF) mod->GetExposedModuleObject();
    _ASSERTE(refModule);

    // Assign the return value
    *((OBJECTREF*) &rv) = refModule;

    // Return the object
    return rv;
}

// GetAssembly
// This will return the assembly that the class is defined in.
LPVOID __stdcall COMClass::GetAssembly(_GETASSEMBLYARGS* args)
{
    OBJECTREF   refAssembly;
    LPVOID      rv;
    Module*     mod;
    Assembly*   assem;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    _ASSERTE(pRC);

    // Get the module,  This may fail because
    //  there are classes which don't have modules (Like arrays)
    mod = pRC->GetModule();
    if (!mod)
        return 0;

    // Grab the module's assembly.
    assem = mod->GetAssembly();
    _ASSERTE(assem);

    // Get the exposed Assembly Object.
    refAssembly = assem->GetExposedObject();
    _ASSERTE(refAssembly);

    // Assign the return value
    *((OBJECTREF*) &rv) = refAssembly;

    // Return the object
    return rv;
}

// CreateClassObjFromModule
// This method will create a new Module class given a Module.
HRESULT COMClass::CreateClassObjFromModule(
    Module* pModule,
    REFLECTMODULEBASEREF* prefModule)
{
    HRESULT  hr   = E_FAIL;
    LPVOID   rv   = NULL;

    // This only throws the possible exception raised by the <cinit> on the class
    THROWSCOMPLUSEXCEPTION();

    //if(!m_fIsReflectionInitialized)
    //{
    //  hr = InitializeReflection();
    //  if(FAILED(hr))
    //  {
    //      _ASSERTE(!"InitializeReflection failed in COMClass::SetStandardFilterCriteria.");
    //      return hr;
    //  }
    //}

    // Create the module object
    *prefModule = (REFLECTMODULEBASEREF) g_pRefUtil->CreateReflectClass(RC_Module,0,pModule);
    return S_OK;
}


// CreateClassObjFromDynModule
// This method will create a new ModuleBuilder class given a Module.
HRESULT COMClass::CreateClassObjFromDynamicModule(
    Module* pModule,
    REFLECTMODULEBASEREF* prefModule)
{
    // This only throws the possible exception raised by the <cinit> on the class
    THROWSCOMPLUSEXCEPTION();

    // Create the module object
    *prefModule = (REFLECTMODULEBASEREF) g_pRefUtil->CreateReflectClass(RC_DynamicModule,0,pModule);
    return S_OK;
}

// CheckComWrapperClass
// This method is called to check and see if the passed in ReflectClass*
//  is a ComWrapperClass or not.
BOOL CheckComWrapperClass(void* src)
{
    EEClass* p = ((ReflectClass*) src)->GetClass();
    if (p == 0)
        return 0;
    return p->GetMethodTable()->IsComObjectType();
}

// CheckComObjectClass
// This method is called to check and see if the passed in ReflectClass*
//  is a ComWrapperClass or not.
BOOL CheckComObjectClass(void* src)
{
    _ASSERTE(src != NULL);

    if (((ReflectClass*) src)->IsTypeDesc())
        return 0;

    EEClass* c = NULL;
    EEClass* p = ((ReflectClass*) src)->GetClass();    

    _ASSERTE(p != NULL);

    MethodTable *pComMT = SystemDomain::GetDefaultComObjectNoInit();
    if (pComMT)
        c = pComMT->GetClass();
    return p == c;
}

/*=============================GetUnitializedObject=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID  __stdcall COMClass::GetUninitializedObject(_GetUnitializedObjectArgs* args) 
{

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args->objType);
    
    if (args->objType==NULL) {
        COMPlusThrowArgumentNull(L"type", L"ArgumentNull_Type");
    }

    ReflectClass* pRC = (ReflectClass*) args->objType->GetData();
    _ASSERTE(pRC);
    EEClass *pEEC = pRC->GetClass();
    _ASSERTE(pEEC);
    
    //We don't allow unitialized strings.
    if (pEEC == g_pStringClass->GetClass()) {
        COMPlusThrow(kArgumentException, L"Argument_NoUninitializedStrings");
    }


    // if this is an abstract class or an interface type then we will
    //  fail this
    if (pEEC->IsAbstract())
    {
        COMPlusThrow(kMemberAccessException,L"Acc_CreateAbst");
    }

    OBJECTREF retVal = pEEC->GetMethodTable()->Allocate();     
    
    RETURN(retVal, OBJECTREF);
}

/*=============================GetSafeUnitializedObject=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID  __stdcall COMClass::GetSafeUninitializedObject(_GetUnitializedObjectArgs* args) 
{

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args->objType);
    
    if (args->objType==NULL) {
        COMPlusThrowArgumentNull(L"type", L"ArgumentNull_Type");
    }

    ReflectClass* pRC = (ReflectClass*) args->objType->GetData();
    _ASSERTE(pRC);
    EEClass *pEEC = pRC->GetClass();
    _ASSERTE(pEEC);
    
    //We don't allow unitialized strings.
    if (pEEC == g_pStringClass->GetClass()) {
        COMPlusThrow(kArgumentException, L"Argument_NoUninitializedStrings");
    }


    // if this is an abstract class or an interface type then we will
    //  fail this
    if (pEEC->IsAbstract())
    {
        COMPlusThrow(kMemberAccessException,L"Acc_CreateAbst");
    }

    if (!pEEC->GetAssembly()->AllowUntrustedCaller()) {
        OBJECTREF permSet = NULL;
        Security::GetPermissionInstance(&permSet, SECURITY_FULL_TRUST);        
        COMCodeAccessSecurityEngine::DemandSet(permSet);
    }

    if (pEEC->RequiresLinktimeCheck()) 
    {
        OBJECTREF refClassNonCasDemands = NULL;
        OBJECTREF refClassCasDemands = NULL;      
                        
        refClassCasDemands = pEEC->GetModule()->GetLinktimePermissions(pEEC->GetCl(), &refClassNonCasDemands);

        if (refClassCasDemands != NULL)
            COMCodeAccessSecurityEngine::DemandSet(refClassCasDemands);
    }

    OBJECTREF retVal = pEEC->GetMethodTable()->Allocate();     
    
    RETURN(retVal, OBJECTREF);
}

INT32  __stdcall COMClass::SupportsInterface(_SupportsInterfaceArgs* args) 
{
    THROWSCOMPLUSEXCEPTION();
    if (args->obj == NULL)
        COMPlusThrow(kNullReferenceException);

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    EEClass* pEEC = pRC->GetClass();
    _ASSERTE(pEEC);
    MethodTable* pMT = pEEC->GetMethodTable();

    return args->obj->GetClass()->SupportsInterface(args->obj, pMT);
}


// GetTypeDefToken
// This method returns the typedef token of this EEClass
FCIMPL1(INT32, COMClass::GetTypeDefToken, ReflectClassBaseObject* refThis) 
{
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();
    _ASSERTE(pEEC);
    return pEEC->GetCl();
}
FCIMPLEND

FCIMPL1(INT32, COMClass::IsContextful, ReflectClassBaseObject* refThis) 
{
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();
    BOOL isContextful = FALSE;
    // Some classes do not have an underlying EEClass such as
    // COM classic or pointer classes 
    // We will return false for such classes
    // BUGBUG: Do we support remoting for such classes ?
    if(NULL != pEEC)
    {
        isContextful = pEEC->IsContextful();
    }

    return isContextful;
}
FCIMPLEND

// This will return TRUE is a type has a non-default proxy attribute
// associated with it.
FCIMPL1(INT32, COMClass::HasProxyAttribute, ReflectClassBaseObject* refThis)
{
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();
    BOOL hasProxyAttribute = FALSE;
    // Some classes do not have an underlying EEClass such as
    // COM classic or pointer classes
    // We will return false for such classes
    if(NULL != pEEC)
    {
        hasProxyAttribute = pEEC->HasRemotingProxyAttribute();
    }

    return hasProxyAttribute;
}
FCIMPLEND

FCIMPL1(INT32, COMClass::IsMarshalByRef, ReflectClassBaseObject* refThis) 
{
    VALIDATEOBJECTREF(refThis);

    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    EEClass* pEEC = pRC->GetClass();
    BOOL isMarshalByRef = FALSE;
    // Some classes do not have an underlying EEClass such as
    // COM classic or pointer classes 
    // We will return false for such classes
    // BUGBUG: Do we support remoting for such classes ?
    if(NULL != pEEC)
    {
        isMarshalByRef = pEEC->IsMarshaledByRef();
    }

    return isMarshalByRef;
}
FCIMPLEND

FCIMPL3(void, COMClass::GetInterfaceMap, ReflectClassBaseObject* refThis, InterfaceMapData* data, ReflectClassBaseObject* type)
{
    THROWSCOMPLUSEXCEPTION();
    VALIDATEOBJECTREF(refThis);
    VALIDATEOBJECTREF(type);

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    // Cast to the Type object
    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    if (pRC->IsTypeDesc()) 
        COMPlusThrow(kArgumentException, L"Arg_NotFoundIFace");
    EEClass* pTarget = pRC->GetClass();

    // Cast to the Type object
    ReflectClass* pIRC = (ReflectClass*) type->GetData();
    EEClass* pIface = pIRC->GetClass();

    SetObjectReference((OBJECTREF*) &data->m_targetType, REFLECTCLASSBASEREF(refThis), GetAppDomain());    
    SetObjectReference((OBJECTREF*) &data->m_interfaceType, REFLECTCLASSBASEREF(type), GetAppDomain());
    GCPROTECT_BEGININTERIOR (data);

    ReflectMethodList* pRM = pRC->GetMethods();
    ReflectMethodList* pIRM = pIRC->GetMethods();   // this causes a GC !!!

    _ASSERTE(pIface->IsInterface());
    if (pTarget->IsInterface())
        COMPlusThrow(kArgumentException, L"Argument_InterfaceMap");

    MethodTable *pInterfaceMT = pIface->GetMethodTable();
    MethodDesc *pCCtor = NULL;
    unsigned slotCnt = pInterfaceMT->GetInterfaceMethodSlots();
    unsigned staticSlotCnt = 0;
    for (unsigned i=0;i<slotCnt;i++) {
        // Build the interface array...
        MethodDesc* pCurMethod = pIface->GetUnknownMethodDescForSlot(i);
        if (pCurMethod->IsStatic()) {
            staticSlotCnt++;
        }
    }
    
    InterfaceInfo_t* pII = pTarget->FindInterface(pIface->GetMethodTable());
    if (!pII) 
        COMPlusThrow(kArgumentException, L"Arg_NotFoundIFace");

    SetObjectReference((OBJECTREF*) &data->m_targetMethods, 
        AllocateObjectArray(slotCnt-staticSlotCnt, g_pRefUtil->GetTrueType(RC_Class)), GetAppDomain());

    SetObjectReference((OBJECTREF*) &data->m_interfaceMethods,  
        AllocateObjectArray(slotCnt-staticSlotCnt, g_pRefUtil->GetTrueType(RC_Class)), GetAppDomain());

    for (unsigned i=0;i<slotCnt;i++) {
        // Build the interface array...
        MethodDesc* pCurMethod = pIface->GetUnknownMethodDescForSlot(i);
        if (pCurMethod->IsStatic()) 
            continue;
        ReflectMethod* pRMeth = pIRM->FindMethod(pCurMethod);
        _ASSERTE(pRMeth);

        OBJECTREF o = (OBJECTREF) pRMeth->GetMethodInfo(pIRC);
        data->m_interfaceMethods->SetAt(i, o);

        // Build the type array...
        pCurMethod = pTarget->GetUnknownMethodDescForSlot(i+pII->m_wStartSlot);
        pRMeth = pRM->FindMethod(pCurMethod);
        if (pRMeth) 
            o = (OBJECTREF) pRMeth->GetMethodInfo(pRC);
        else
            o = NULL;
        data->m_targetMethods->SetAt(i, o);
    }

    GCPROTECT_END ();
    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND

// GetNestedType
// This method will search for a nested type based upon the name
FCIMPL3(Object*, COMClass::GetNestedType, ReflectClassBaseObject* pRefThis, StringObject* vStr, INT32 invokeAttr)
{
    THROWSCOMPLUSEXCEPTION();

    Object* rv = 0;
    STRINGREF str(vStr);
    REFLECTCLASSBASEREF refThis(pRefThis);
    HELPER_METHOD_FRAME_BEGIN_RET_2(refThis, str);
    RefSecContext sCtx;

    LPUTF8          pszNestName;
    LPUTF8          pszNestNameSpace;
    if (str == 0)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");

    
    // Get the underlying type
    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    ReflectTypeList* pTypes = pRC->GetNestedTypes();
    if (pTypes->dwTypes != 0)
    {

        CQuickBytes bytes;
        LPSTR szNestName;
        DWORD cNestName;

        //Get the name and split it apart into namespace, name
        szNestName = GetClassStringVars(str, &bytes, &cNestName);

        ns::SplitInline(szNestName, pszNestNameSpace, pszNestName);
        
        // The Search modifiers
        bool ignoreCase = ((invokeAttr & BINDER_IgnoreCase)  != 0);
        bool declaredOnly = ((invokeAttr & BINDER_DeclaredOnly)  != 0);

        // The search filters
        bool addPriv = ((invokeAttr & BINDER_NonPublic) != 0);
        bool addPub = ((invokeAttr & BINDER_Public) != 0);

        EEClass* pThisEEC = pRC->GetClass();

        EEClass* retEEC = 0;
        for (DWORD i=0;i<pTypes->dwTypes;i++) {
            LPCUTF8 szcName;
            LPCUTF8 szcNameSpace;
            REFLECTCLASSBASEREF o;
            o = (REFLECTCLASSBASEREF) pTypes->types[i]->GetExposedClassObject();
            ReflectClass* thisRC = (ReflectClass*) o->GetData();
            _ASSERTE(thisRC);

            // Check for access to non-publics
            if (IsTdNestedPublic(pTypes->types[i]->GetAttrClass())) {
                if (!addPub)
                    continue;
            }
            else {
                if (!addPriv)
                    continue;
            }
            if (!InvokeUtil::CheckAccessType(&sCtx, pTypes->types[i], 0)) continue;

            // Are we only looking at the declared nested classes?
            if (declaredOnly) {
                EEClass* pEEC = pTypes->types[i]->GetEnclosingClass();
                if (pEEC != pThisEEC)
                    continue;
            }

            thisRC->GetName(&szcName,&szcNameSpace);
            if(pszNestNameSpace) {
                if (!ignoreCase) {
                    if (strcmp(pszNestNameSpace, szcNameSpace))
                        continue;
                }
                else {
                    if (_stricmp(pszNestNameSpace, szcNameSpace))
                        continue;
                }
            }

            // If the names are a match, break
            if (!ignoreCase) {
                if(strcmp(pszNestName, szcName))
                    continue;
            }
            else {
                if(_stricmp(pszNestName, szcName))
                    continue;
            }
            if (retEEC)
                COMPlusThrow(kAmbiguousMatchException);
            retEEC = pTypes->types[i];
            if (!ignoreCase)
                break;
        }
        if (retEEC)
            rv = OBJECTREFToObject(retEEC->GetExposedClassObject());
    }
    HELPER_METHOD_FRAME_END();
    return rv;
}
FCIMPLEND

// GetNestedTypes
// This method will return an array of types which are the nested types
//  defined by the type.  If no nested types are defined, a zero length
//  array is returned.
FCIMPL2(Object*, COMClass::GetNestedTypes, ReflectClassBaseObject* vRefThis, INT32 invokeAttr)
{
    Object* rv = 0;
    REFLECTCLASSBASEREF refThis(vRefThis);
    PTRARRAYREF nests((PTRARRAYREF)(size_t)NULL);
    HELPER_METHOD_FRAME_BEGIN_RET_2(refThis, nests);    // Set up a frame
    RefSecContext sCtx;

    // Get the underlying type
    ReflectClass* pRC = (ReflectClass*) refThis->GetData();
    _ASSERTE(pRC);

    // Allow GC Protection so we can 
    ReflectTypeList* pTypes = pRC->GetNestedTypes();
    nests = (PTRARRAYREF) AllocateObjectArray(pTypes->dwTypes, g_pRefUtil->GetTrueType(RC_Class));

    // The Search modifiers
    bool declaredOnly = ((invokeAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addPriv = ((invokeAttr & BINDER_NonPublic) != 0);
    bool addPub = ((invokeAttr & BINDER_Public) != 0);

    EEClass* pThisEEC = pRC->GetClass();
    unsigned int pos = 0;
    for (unsigned int i=0;i<pTypes->dwTypes;i++) {
        if (IsTdNestedPublic(pTypes->types[i]->GetAttrClass())) {
            if (!addPub)
                continue;
        }
        else {
            if (!addPriv)
                continue;
        }
        if (!InvokeUtil::CheckAccessType(&sCtx, pTypes->types[i], 0)) continue;
        if (declaredOnly) {
            EEClass* pEEC = pTypes->types[i]->GetEnclosingClass();
            if (pEEC != pThisEEC)
                continue;
        }
        OBJECTREF o = pTypes->types[i]->GetExposedClassObject();
        nests->SetAt(pos++, o);
    }

    if (pos != pTypes->dwTypes) {
        PTRARRAYREF p = (PTRARRAYREF) AllocateObjectArray(
            pos, g_pRefUtil->GetTrueType(RC_Class));
        for (unsigned int i=0;i<pos;i++)
            p->SetAt(i, nests->GetAt(i));
        nests = p;   
    }

    rv = OBJECTREFToObject(nests);
    HELPER_METHOD_FRAME_END();
    _ASSERTE(rv);
    return rv;
}
FCIMPLEND

FCIMPL2(INT32, COMClass::IsSubClassOf, ReflectClassBaseObject* refThis, ReflectClassBaseObject* refOther);
{
    if (refThis == NULL)
        FCThrow(kNullReferenceException);
    if (refOther == NULL)
        FCThrowArgumentNull(L"c");

    VALIDATEOBJECTREF(refThis);
    VALIDATEOBJECTREF(refOther);

    MethodTable *pType = refThis->GetMethodTable();
    MethodTable *pBaseType = refOther->GetMethodTable();
    if (pType != pBaseType || pType != g_Mscorlib.FetchClass(CLASS__CLASS)) 
        return false;

    ReflectClass *pRCThis = (ReflectClass *)refThis->GetData();
    ReflectClass *pRCOther = (ReflectClass *)refOther->GetData();


    EEClass *pEEThis = pRCThis->GetClass();
    EEClass *pEEOther = pRCOther->GetClass();

    // If these types aren't actually classes, they're not subclasses. 
    if ((!pEEThis) || (!pEEOther))
        return false;

    if (pEEThis == pEEOther)
        // this api explicitly tests for proper subclassness
        return false;

    if (pEEThis == pEEOther)
        return false;

    do 
    {
        if (pEEThis == pEEOther)
            return true;

        pEEThis = pEEThis->GetParentClass();

    } 
    while (pEEThis != NULL);

    return false;
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comclass.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: Daryl Olander (darylo)
// Author: Simon Hall (t-shall)
// Date: March 27, 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMCLASS_H_
#define _COMCLASS_H_

#include "excep.h"
#include "ReflectWrap.h"
#include "COMReflectionCommon.h"
#include "InvokeUtil.h"
#include "fcall.h"

// COMClass
// This is really to root of all reflection.  It represents
//  the Class object.  It also contains other shared resources
//  which are used by reflection and by clients of reflection.
class COMClass
{
public:

    enum NameSpecifier {
        TYPE_NAME = 0x1,
        TYPE_NAMESPACE = 0x2,
        TYPE_ASSEMBLY = 0x4
    } ;

private:

    struct _GetEventArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, eventName);
    };

    struct _GetEventsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr);
    };

    struct _GetPropertiesArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
    };

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } _GETSUPERCLASSARGS;

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } _GETCLASSHANDLEARGS;

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } _GETNAMEARGS;

    struct _GetGUIDArgs{
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(GUID *, retRef);
    } ;

    struct _GetClass1Args {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };
    struct _GetClass2Args {
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };
    struct _GetClass3Args {
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase); 
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };
    struct _GetClassInternalArgs {
        DECLARE_ECALL_I4_ARG(DWORD, bPublicOnly); 
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase); 
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };
    struct _GetClassArgs {
        DECLARE_ECALL_PTR_ARG(BOOL*, pbAssemblyIsLoading);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase); 
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };

    struct _GetInterfaceArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, interfaceName);
    };
    struct _GetInterfacesArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    };
    struct _GetMemberArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
        DECLARE_ECALL_I4_ARG(DWORD, memberType); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, memberName);
    };
    struct _GetMembersArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
    };

    struct _GetSerializableMembersArgs {
        DECLARE_ECALL_I4_ARG(DWORD, bFilterTransient); 
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
    };

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } _GETMODULEARGS;

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } _GETASSEMBLYARGS;

    struct _GetMethodsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
    };
    struct _GetConstructorsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
    };
    struct _GetFieldsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL,  bRequiresAccessCheck); 
        DECLARE_ECALL_I4_ARG(DWORD, bindingAttr); 
    };
    struct _GetAttributeArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };
    struct _GetAttributesArgs       {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    };
    struct _GetContextArgs          {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
    } ;
    struct _SetContextArgs          
    {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(LONG, flags); 
    };
    struct _GetClassFromProgIDArgs {
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, server);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, className);
    };
    struct _GetClassFromCLSIDArgs {
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, server);
        DECLARE_ECALL_OBJECTREF_ARG(GUID, clsid);
    };

    struct _IsArrayArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
    };

    struct _InvokeDispMethodArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, namedParameters);
        DECLARE_ECALL_OBJECTREF_ARG(LCID, lcid);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, byrefModifiers);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, args);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _GetArrayElementTypeArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
    };

    struct _InternalGetArrayRankArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
    };

    struct _GetMemberMethodsArgs    {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_I4_ARG(INT32, argCnt); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, argTypes);
        DECLARE_ECALL_I4_ARG(INT32, callConv); 
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _GetMemberFieldArgs  {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _GetMemberConsArgs   {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_PTR_ARG(INT32 *, isDelegate);
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_I4_ARG(INT32, argCnt); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, argTypes);
        DECLARE_ECALL_I4_ARG(INT32, callConv); 
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
    };

    struct _GetMemberPropertiesArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_I4_ARG(INT32, argCnt); 
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _GetMatchingPropertiesArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, verifyAccess);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, returnType); 
        DECLARE_ECALL_I4_ARG(INT32, argCnt); 
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };

    struct _GetUnitializedObjectArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, objType);
    };

    struct _SupportsInterfaceArgs          {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    };
    
public:

    // Reflection uses a critical section to synchronized
    //  the creation of the base data structures.  This is
    //  initalized during startup.
    static CRITICAL_SECTION m_ReflectCrst;
    static CRITICAL_SECTION *m_pReflectCrst;
	static long m_ReflectCrstInitialized;

    static MethodTable* m_pMTRC_Class;      // reflection class method table
    static FieldDesc*   m_pDescrTypes;      // Array of Class stored inside a DescriptorInfo
    static FieldDesc*   m_pDescrMatchFlag;  // Partial Match Flag
    static FieldDesc*   m_pDescrRetType;    // Return type
    static FieldDesc*   m_pDescrRetModType; // Return Modifier type
    //  static FieldDesc*   m_pDescrCallConv;   // Calling Convention
    static FieldDesc*   m_pDescrAttributes; // Attributes

    // Return a boolean indicating if reflection has been initialized
    //   or not.
    static bool ReflectionInitialized()
    {
        return m_fAreReflectionStructsInitialized;
    }

    static FieldDesc* GetDescriptorObjectField(OBJECTREF desc);
    static FieldDesc* GetDescriptorReturnField(OBJECTREF desc);
    static FieldDesc* GetDescriptorReturnModifierField(OBJECTREF desc);
    //  static FieldDesc* GetDescriptorCallingConventionField(OBJECTREF desc);
    static FieldDesc* GetDescriptorAttributesField(OBJECTREF desc);


    // This method will make sure that reflection has been
    //  initialized.  Consumers of reflection services must call
    //  this before using reflection.
    static void EnsureReflectionInitialized()
    {
        THROWSCOMPLUSEXCEPTION();

        if(!m_fAreReflectionStructsInitialized)
        {
            MinimalReflectionInit();
        }

    }

    static MethodTable *GetRuntimeType();

    // This is called during termination...
#ifdef SHOULD_WE_CLEANUP
    static void Destroy();
#endif /* SHOULD_WE_CLEANUP */

    // IsPrimitive 
    // This method will return a boolean indicating if the type represents
    //  on of the primitive types.
    static FCDECL1(INT32, IsPrimitive, ReflectClassBaseObject* vRefThis);

    // GetAttributeFlags
    // This method will return the Attribute flags for a type.
    static FCDECL1(INT32, GetAttributeFlags, ReflectClassBaseObject* vRefThis);

    // IsCOMObject
    // This method return true if the Class represents COM Classic Object
    static FCDECL1(INT32, IsCOMObject, ReflectClassBaseObject* vRefThis);

    // IsGenericCOMObject
    // This method return true if the Class is a __COMObject
    static FCDECL1(INT32, IsGenericCOMObject, ReflectClassBaseObject* vRefThis);


    static FCDECL1(INT32, GetTypeDefToken, ReflectClassBaseObject* vRefThis);
    static FCDECL1(INT32, IsContextful, ReflectClassBaseObject* vRefThis);
    static FCDECL1(INT32, HasProxyAttribute, ReflectClassBaseObject* vRefThis);
    static FCDECL1(INT32, IsMarshalByRef, ReflectClassBaseObject* vRefThis);

    // GetTHFromObject
    // This method is a static method on type that returns
    //  the Handle (TypeHandle address) for an object.  It does
    //  not create the type handle object
    static FCDECL1(void*, GetTHFromObject, Object* vObject);

    // IsByRefImpl
    // This method will return a boolean indicating if the Type
    //  object is a ByRef
    static FCDECL1(INT32, IsByRefImpl, ReflectClassBaseObject* vObject);

    // IsPointerImpl
    // This method will return a boolean indicating if the Type
    //  object is a ByRef
    static FCDECL1(INT32, IsPointerImpl, ReflectClassBaseObject* vObject);

    // IsNestedTypeImpl
    // Return a boolean indicating if this is a nested type.
    static FCDECL1(INT32, IsNestedTypeImpl, ReflectClassBaseObject* vObject);

    // GetNestedDeclaringType
    // Return the declaring class for a nested type.
    static FCDECL1(Object*, GetNestedDeclaringType, ReflectClassBaseObject* vObject);

    // GetNestedTypes
    // This method will return an array of types which are the nested types
    //  defined by the type.  If no nested types are defined, a zero length
    //  array is returned.
    static FCDECL2(Object*, GetNestedTypes, ReflectClassBaseObject* vRefThis, INT32 invokeAttr);

    // GetNestedType
    // This method will search for a nested type based upon the name
    static FCDECL3(Object*, GetNestedType, ReflectClassBaseObject* vRefThis, StringObject* vStr, INT32 invokeAttr);

    static FCDECL3(void, GetInterfaceMap, ReflectClassBaseObject* vRefThis, InterfaceMapData* data, ReflectClassBaseObject* type);

    // QuickLookupExistingArrayClassObj
    // Lookup an existing Type object that represents an Array.  Arrays are handled
    //  different from base objects.  Arrays are represented by ReflectArrayClass.  The
    //  Class object is stored there.  Will return NULL if the Type hasn't been
    //  created, meaning you should call ArrayTypeDesc::CreateClassObj
    // arrayType -- Pointer to the ArrayTypeDesc representing the Array
    static OBJECTREF QuickLookupExistingArrayClassObj(ArrayTypeDesc* arrayType);

    // GetMethod
    // This method returns an array of MethodInfo object representing all of the methods
    //  defined for this class.
    LPVOID static __stdcall GetMethods(_GetMethodsArgs* args);

    // GetSuperclass
    // This method returns the Class Object representing the super class of this
    //  Class.  If there is not super class then we return null.
    LPVOID static __stdcall GetSuperclass(_GETSUPERCLASSARGS* args);

    // GetClassHandle
    // This method with return a unique ID meaningful to the EE and equivalent to
    // the result of the ldtoken instruction.
    static void* __stdcall GetClassHandle(_GETCLASSHANDLEARGS* args);

    // GetClassFromHandle
    // This method with return a unique ID meaningful to the EE and equivalent to
    // the result of the ldtoken instruction.
    static FCDECL1(Object*, GetClassFromHandle, LPVOID handle);

    // RunClassConstructor triggers the class constructor
    static FCDECL1(void, RunClassConstructor, LPVOID handle);

    // GetName 
    // This method returns the unqualified name of the Class as a String.
    LPVOID static __stdcall GetName(_GETNAMEARGS* args);

    // GetProperName 
    // This method returns the correctly qualified name of the Class as a String.
    LPVOID static __stdcall COMClass::GetProperName(_GETNAMEARGS* args);

    // GetFullName
    // This will return the fully qualified name of the class as a String.
    LPVOID static __stdcall GetFullName(_GETNAMEARGS* args);

    // GetAssemblyQualifiedName
    // This will return the Assembly Qualified name of the class as a String.
    LPVOID static __stdcall GetAssemblyQualifiedName(_GETNAMEARGS* args);

    // GetNameSpace
    // This will return the name space of a class as a String.
    LPVOID static __stdcall GetNameSpace(_GETNAMEARGS* args);

    // GetGUID
    // This method will return the version-independent GUID for the Class.  This is 
    //  a CLSID for a class and an IID for an Interface.
    void static __stdcall GetGUID(_GetGUIDArgs* args);

    // GetClass
    // This is a static method defined on Class that will get a named class.
    //  The name of the class is passed in by string.  The class name may be
    //  either case sensitive or not.  This currently causes the class to be loaded
    //  because it goes through the class loader.
    LPVOID static __stdcall GetClass1Arg(_GetClass1Args* args);
    LPVOID static __stdcall GetClass2Args(_GetClass2Args* args);
    LPVOID static __stdcall GetClass3Args(_GetClass3Args* args);
    LPVOID static __stdcall GetClassInternal(_GetClassInternalArgs* args);
    LPVOID static __stdcall GetClass(_GetClassArgs* args);
    LPVOID static GetClassInner(STRINGREF *refClassName, 
                                BOOL bThrowOnError, 
                                BOOL bIgnoreCase, 
                                StackCrawlMark *stackMark,
                                BOOL *pbAssemblyIsLoading,
                                BOOL bVerifyAccess,
                                BOOL bPublicOnly);

    // GetClassFromProgID
    // This method will return a Class object for a COM Classic object based
    //  upon its ProgID.  The COM Classic object is found and a wrapper object created
    LPVOID static __stdcall GetClassFromProgID(_GetClassFromProgIDArgs* args);

    // GetClassFromCLSID
    // This method will return a Class object for a COM Classic object based
    //  upon its CLSID.  The COM Classic object is found and a wrapper object created
    LPVOID static __stdcall GetClassFromCLSID(_GetClassFromCLSIDArgs* args);

    // GetConstructors
    // This method will return an array of all the constructors for an object.
    LPVOID static __stdcall GetConstructors(_GetConstructorsArgs* args);

    // GetField
    // This method will return the specified field
    struct _GetFieldArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(DWORD, fBindAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, fieldName);
    };
    static LPVOID __stdcall GetField(_GetFieldArgs* args);

    // GetFields
    // This method will return a FieldInfo array of all of the
    //  fields defined for this Class
    static LPVOID __stdcall GetFields(_GetFieldsArgs* args);

    // GetEvent
    // This method will return the specified event based upon
    //  the name
    static LPVOID __stdcall GetEvent(_GetEventArgs* args);

    // GetEvents
    // This method will return an array of EventInfo for each of the events
    //  defined in the class
    static LPVOID __stdcall GetEvents(_GetEventsArgs* args);

    // GetProperties
    // This method will return an array of Properties for each of the
    //  properties defined in this class.  An empty array is return if
    //  no properties exist.
    static LPVOID __stdcall GetProperties(_GetPropertiesArgs* args);

    // GetInterface
    //  This method returns the interface based upon the name of the method.
    static LPVOID __stdcall GetInterface(_GetInterfaceArgs* args);

    // GetInterfaces
    // This routine returns a Class[] containing all of the interfaces implemented
    //  by this Class.  If the class implements no interfaces an array of length
    //  zero is returned.
    static LPVOID  __stdcall GetInterfaces(_GetInterfacesArgs* args);

    // GetMember
    // This method will return an array of Members which match the name
    //  passed in.  There may be 0 or more matching members.
    static LPVOID  __stdcall GetMember(_GetMemberArgs* args);

    // GetMembers
    // This method returns an array of Members containing all of the members
    //  defined for the class.  Members include constructors, events, properties,
    //  methods and fields.
    static LPVOID  __stdcall GetMembers(_GetMembersArgs* args);

    // GetSerializableMembers
    // Creates an array of all non-static fields and properties
    // on a class.  Properties are also excluded if they don't have get and set
    // methods. Transient fields and properties are excluded based on the value 
    // of args->bFilterTransient.  Essentially, transients are exluded for 
    // serialization but not for cloning.
    static LPVOID __stdcall GetSerializableMembers(_GetSerializableMembersArgs *args);

    static FCDECL2(void, GetSerializationRegistryValues, BOOL *checkBit, BOOL *logNonSerializable);

    // IsArray
    // This method return true if the Class represents an array.
    static INT32  __stdcall IsArray(_IsArrayArgs* args);
    static INT32  __stdcall InvalidateCachedNestedType(_IsArrayArgs* args);

    // GetArrayElementType
    // This routine will return the base type of an array assuming
    //  the Class represents an array.  A NotSupported exception is
    //  thrown if the class is not an array.
    static LPVOID __stdcall GetArrayElementType(_GetArrayElementTypeArgs* args);

    // InternalGetArrayRank
    // This routine will return the rank of an array assuming the Class represents an array.  
    static INT32 __stdcall InternalGetArrayRank(_InternalGetArrayRankArgs* args);

    // InvokeDispMethod
    // This method will be called on a COM Classic object and simply calls
    //  the interop IDispathc method
    static LPVOID  __stdcall InvokeDispMethod(_InvokeDispMethodArgs* args);

    // GetContextFlags
    // @TODO context cwb: temporary until tools generate context metadata
    static LONG    __stdcall GetContextFlags(_GetContextArgs* args);

    // SetContextFlags
    // @TODO context cwb: temporary until tools generate context metadata
    static void    __stdcall SetContextFlags(_SetContextArgs* args);

    // GetModule
    // This will return the module that the class is defined in.
    LPVOID static __stdcall GetModule(_GETMODULEARGS* args);

    // GetAssembly
    // This will return the assembly that the class is defined in.
    LPVOID static __stdcall GetAssembly(_GETASSEMBLYARGS* args);

    // CreateClassObjFromModule
    // This method will create a new Module class given a Module.
    static HRESULT CreateClassObjFromModule(Module* pModule,REFLECTMODULEBASEREF* prefModule);

    // CreateClassObjFromDynamicModule
    // This method will create a new ModuleBuilder class given a Module.
    static HRESULT CreateClassObjFromDynamicModule(Module* pModule,REFLECTMODULEBASEREF* prefModule);

    static FCDECL5(Object*,GetMethodFromCache, ReflectClassBaseObject* refThis, StringObject* name, INT32 invokeAttr, INT32 argCnt, PtrArray* args);
    static FCDECL6(void,COMClass::AddMethodToCache, ReflectClassBaseObject* refThis, StringObject* name, INT32 invokeAttr, INT32 argCnt, PtrArray* args, Object* invokeMethod);
    
    // GetMemberMethods
    // This method will return all of the members methods which match the 
    //  specified attributes flag...
    static LPVOID __stdcall GetMemberMethods(_GetMemberMethodsArgs* args);

    // GetMemberCons
    // This method returns all of the constructors that have a set number
    //  of methods.
    static LPVOID __stdcall GetMemberCons(_GetMemberConsArgs* args);

    // GetMemberField
    // This method returns all of the fields which match the specified
    //  name.
    static LPVOID __stdcall GetMemberField(_GetMemberFieldArgs* args);

    // GetMemberProperties
    // This method returns all of the properties that have a set number
    //  of arguments.  The methods will be either get or set methods depending
    //  upon the invokeAttr flag.
    static LPVOID __stdcall GetMemberProperties(_GetMemberPropertiesArgs* args);

    // GetMatchingProperties
    // This basically does a matching based upon the properties abstract 
    //  signature.
    static LPVOID __stdcall GetMatchingProperties(_GetMatchingPropertiesArgs* args);

    //GetUnitializedObject
    //This creates an instance of an object upon which no constructor has been run.
    //@ToDo JROXE: What are the security implications on this?
    static LPVOID __stdcall GetUninitializedObject(_GetUnitializedObjectArgs* args);

    //GetUnitializedObject
    //This creates an instance of an object upon which no constructor has been run.    
    static LPVOID __stdcall GetSafeUninitializedObject(_GetUnitializedObjectArgs* args);

    //CanCastTo
    //Check to see if we can cast from one runtime type to another.
    static FCDECL2(INT32, CanCastTo, ReflectClassBaseObject* vFrom, ReflectClassBaseObject* vTo);

    //CanCastTo
    //Check to see if we can cast from one runtime type to another.
    static INT32 __stdcall SupportsInterface(_SupportsInterfaceArgs* args);

    // MatchField
    // This will check to see if there is a match on the field base upon name
    static LPVOID __stdcall MatchField(FieldDesc* pCurField,DWORD cFieldName,
        LPUTF8 szFieldName,ReflectClass* pRC,int bindingAttr);

    // Check if argument is a parent of "this"
    static FCDECL2(INT32, IsSubClassOf, ReflectClassBaseObject* vThis, ReflectClassBaseObject* vOther);

    static void GetNameInternal(ReflectClass *pRC, int nameType, CQuickBytes *qb);

private:
    // InitializeReflection
	static void InitializeReflectCrst();

    // This method will initalize reflection.
    static void MinimalReflectionInit();

    // This flag indicates if reflection has been initialized or not
    static bool m_fAreReflectionStructsInitialized;

    // _GetName
    // If the bFullName is true, teh fully qualified class name is return
    //  otherwise just the class name is returned.
    static LPVOID _GetName(_GETNAMEARGS* args, int nameType);
    static LPCUTF8 _GetName(ReflectClass* pRC, BOOL fNameSpace, CQuickBytes *qb);


    // If you are tempted to use this, use TypeHandle::CreateClassObj instead!!
    // pVMCClass -- the EEClass we are creating the object for.
    // pRefClass -- A pointer to a pointer which we will return the newly created object
    static void COMClass::CreateClassObjFromEEClass(EEClass* pVMCClass, REFLECTCLASSBASEREF* pRefClass);

    // Internal helper function for GetProperName
    static INT32  __stdcall InternalIsPrimitive(REFLECTCLASSBASEREF args);

        // Needed so it can get at above method
    friend OBJECTREF EEClass::GetExposedClassObject();


    //
    // This is a temporary member until 3/15/2000.  Only if this member is set to 1
    // will we check the serialization bit to see if a class is serializable.
    //
    static DWORD m_checkSerializationBit;
    static void  GetSerializationBitValue();
};

#endif //_COMCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcodeaccesssecurityengine.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMCodeAccessSecurityEngine.h
**
** Author: Paul Kromann (paulkr)
**
** Purpose:
**
** Date:  March 21, 1998
**
===========================================================*/
#ifndef __COMCodeAccessSecurityEngine_h__
#define __COMCodeAccessSecurityEngine_h__

#include "common.h"

#include "object.h"
#include "util.hpp"
#include "fcall.h"
#include "PerfCounters.h"
#include "security.h"

//-----------------------------------------------------------
// The COMCodeAccessSecurityEngine implements all the native methods
// for the interpreted System/Security/SecurityEngine.
//-----------------------------------------------------------
class COMCodeAccessSecurityEngine
{
public:
    //-----------------------------------------------------------
    // Argument declarations for native methods.
    //-----------------------------------------------------------
    
    typedef struct _InitSecurityEngineArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, This);
    } InitSecurityEngineArgs;
    
    
    typedef struct _CheckArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, This);
        DECLARE_ECALL_I4_ARG(INT32, unrestrictedOverride);
        DECLARE_ECALL_I4_ARG(INT32, checkFrames);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, perm);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, permToken);
    } CheckArgs;

    typedef struct _CheckSetArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, This);
        DECLARE_ECALL_I4_ARG(INT32, unrestrictedOverride);
        DECLARE_ECALL_I4_ARG(INT32, checkFrames);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, permSet);
    } CheckSetArgs;

    typedef struct _ZoneAndOriginArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, This);
        DECLARE_ECALL_I4_ARG(INT32, checkFrames);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_PTR_ARG(OBJECTREF, originList);
        DECLARE_ECALL_PTR_ARG(OBJECTREF, zoneList);
    } ZoneAndOriginArgs;

    typedef struct _CheckNReturnSOArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, create);
        DECLARE_ECALL_I4_ARG(INT32, unrestrictedOverride);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, perm);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, permToken);
    } CheckNReturnSOArgs;

    typedef struct _GetPermissionsArg
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, This);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, ppDenied);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pClass);
    } GetPermissionsArg;
    
    typedef struct _GetGrantedPermissionSetArg
    {
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, ppDenied);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, ppGranted);
        DECLARE_ECALL_PTR_ARG(void*, pSecDesc);
    } GetGrantedPermissionSetArg;
    
    typedef struct _GetCompressedStackArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
    } GetCompressedStackArgs;

    typedef struct _GetDelayedCompressedStackArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
    } GetDelayedCompressedStackArgs;
    
    typedef struct _GetSecurityObjectForFrameArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, create);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
    } GetSecurityObjectForFrameArgs;

public:
    // Initialize the security engine. This is called when a SecurityEngine
    // object is created, indicating that code-access security is to be
    // enforced. This should be called only once.
    static void     __stdcall InitSecurityEngine(const InitSecurityEngineArgs *);

    static void CheckSetHelper(OBJECTREF *prefDemand,
                               OBJECTREF *prefGrant,
                               OBJECTREF *prefDenied,
                               AppDomain *pGrantDomain);

	static BOOL		PreCheck(OBJECTREF demand, MethodDesc *plsMethod, DWORD whatPermission = DEFAULT_FLAG);

    // Standard code-access Permission check/demand
    static void __stdcall Check(const CheckArgs *);

    // EE version of Demand(). Takes care of the fully trusted case, then defers to the managed version
    static void	Demand(OBJECTREF demand);

    // Special case of Demand for unmanaged code access. Does some things possible only for this case
    static void	SpecialDemand(DWORD whatPermission);

    static void __stdcall CheckSet(const CheckSetArgs *);

    static void __stdcall GetZoneAndOrigin(const ZoneAndOriginArgs *);

    // EE version of DemandSet(). Takes care of the fully trusted case, then defers to the managed version
    static void	DemandSet(OBJECTREF demand);


	// Do a CheckImmediate, and return the SecurityObject for the first frame
    static LPVOID   __stdcall CheckNReturnSO(const CheckNReturnSOArgs *);

    // Linktime check implementation for code-access permissions
    static void	LinktimeCheck(AssemblySecurityDescriptor *pSecDesc, OBJECTREF refDemands);

    // private helper for getting a security object
    static LPVOID   __stdcall GetSecurityObjectForFrame(const GetSecurityObjectForFrameArgs *);

    static LPVOID   __stdcall GetPermissionsP(const GetPermissionsArg *);
    static void   __stdcall GetGrantedPermissionSet(const GetGrantedPermissionSetArg *);

    static LPVOID   __stdcall EcallGetCompressedStack(const GetCompressedStackArgs *);
    static LPVOID   __stdcall EcallGetDelayedCompressedStack(const GetDelayedCompressedStackArgs *);
    static CompressedStack*  GetCompressedStack( StackCrawlMark* stackMark = NULL );
    static OBJECTREF GetCompressedStackWorker(void *pData, BOOL createList);

    static VOID UpdateOverridesCountInner(StackCrawlMark *stackMark);

    FORCEINLINE static VOID IncrementSecurityPerfCounter()
    {
        COUNTER_ONLY(GetPrivatePerfCounters().m_Security.cTotalRTChecks++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_Security.cTotalRTChecks++);
    }

#ifdef FCALLAVAILABLE
    static FCDECL1(VOID, UpdateOverridesCount, StackCrawlMark *stackMark);
    static FCDECL2(INT32, GetResult, DWORD whatPermission, DWORD *timeStamp);
    static FCDECL2(VOID, SetResult, DWORD whatPermission, DWORD timeStamp);
    static FCDECL1(VOID, FcallReleaseDelayedCompressedStack, CompressedStack *compressedStack);
#endif

    static void CleanupSEData();

protected:

    //-----------------------------------------------------------
    // Cached class and method pointers.
    //-----------------------------------------------------------
    typedef struct _SEData
    {
        BOOL		fInitialized;
        MethodTable    *pSecurityEngine;
        MethodTable    *pSecurityRuntime;
        MethodTable    *pPermListSet;
        MethodDesc     *pMethCheckHelper;
        MethodDesc     *pMethFrameDescHelper;
        MethodDesc     *pMethLazyCheckSetHelper;
        MethodDesc     *pMethCheckSetHelper;
        MethodDesc     *pMethFrameDescSetHelper;
        MethodDesc     *pMethStackCompressHelper;
        MethodDesc     *pMethPermListSetInit;
        MethodDesc     *pMethAppendStack;
        MethodDesc     *pMethOverridesHelper;
        MethodDesc     *pMethPLSDemand;
        MethodDesc     *pMethPLSDemandSet;
        MetaSig        *pSigPLSDemand;
        MetaSig        *pSigPLSDemandSet;
        FieldDesc      *pFSDnormalPermSet;
    } SEData;

    static void InitSEData();
    static CRITICAL_SECTION s_csLock;
    static LONG s_nInitLock;
    static BOOL s_fLockReady;

public:
	static SEData s_seData;

};


#endif /* __COMCodeAccessSecurityEngine_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comconnectionpoints.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: ComConnectionPoints.h
//
// ===========================================================================
// Declaration of the classes used to expose connection points to COM.
// ===========================================================================

#pragma once

#include "vars.hpp"
#include "ComCallWrapper.h"
#include "COMDelegate.h"

//------------------------------------------------------------------------------------------
//      Definition of helper class used to expose connection points
//------------------------------------------------------------------------------------------

// Structure containing information regarding the methods that make up an event.
struct EventMethodInfo
{
    MethodDesc *m_pEventMethod;
    MethodDesc *m_pAddMethod;
    MethodDesc *m_pRemoveMethod;
};

// Structure passed out as a cookie when Advise is called.
struct ConnectionCookie
{
    ConnectionCookie(OBJECTHANDLE hndEventProvObj)
    : m_hndEventProvObj(hndEventProvObj)
    {
        _ASSERTE(hndEventProvObj);
    }

    ~ConnectionCookie()
    {
        DestroyHandle(m_hndEventProvObj);
    }

    static ConnectionCookie* CreateConnectionCookie(OBJECTHANDLE hndEventProvObj)
    {
        return new(throws) ConnectionCookie(hndEventProvObj);
    }

    SLink           m_Link;
    OBJECTHANDLE    m_hndEventProvObj;
};

// List of connection cookies.
typedef SList<ConnectionCookie, offsetof(ConnectionCookie, m_Link), true> CONNECTIONCOOKIELIST;

// ConnectionPoint class. This class implements IConnectionPoint and does the mapping 
// from a CP handler to a TCE provider.
class ConnectionPoint : public IConnectionPoint 
{
public:
    ConnectionPoint( ComCallWrapper *pWrap, MethodTable *pEventMT );
    ~ConnectionPoint();

    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    HRESULT __stdcall GetConnectionInterface( IID *pIID );
    HRESULT __stdcall GetConnectionPointContainer( IConnectionPointContainer **ppCPC );
    HRESULT __stdcall Advise( IUnknown *pUnk, DWORD *pdwCookie );
    HRESULT __stdcall Unadvise( DWORD dwCookie );
    HRESULT __stdcall EnumConnections( IEnumConnections **ppEnum );

    REFIID GetIID()
    {
        return m_rConnectionIID;
    }

    CONNECTIONCOOKIELIST *GetCookieList()
    {
        return &m_ConnectionList;
    }

    void EnterLock();
    void LeaveLock();

private:   
    void SetupEventMethods();

    MethodDesc *FindProviderMethodDesc( MethodDesc *pEventMethodDesc, EnumEventMethods MethodType );
    void InvokeProviderMethod( OBJECTREF pProvider, OBJECTREF pSubscriber, MethodDesc *pProvMethodDesc, MethodDesc *pEventMethodDesc );

    ComCallWrapper                  *m_pOwnerWrap;
    GUID                            m_rConnectionIID;
    MethodTable                     *m_pTCEProviderMT;
    MethodTable                     *m_pEventItfMT;
    Crst                            m_Lock;
    CONNECTIONCOOKIELIST            m_ConnectionList;

    EventMethodInfo                 *m_apEventMethods;
    int                             m_NumEventMethods;

    ULONG                           m_cbRefCount;
};

// Enumeration of connection points.
class ConnectionPointEnum : IEnumConnectionPoints
{
public:
    ConnectionPointEnum(ComCallWrapper *pOwnerWrap, CQuickArray<ConnectionPoint*> *pCPList);
    ~ConnectionPointEnum();

    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    HRESULT __stdcall Next(ULONG cConnections, IConnectionPoint **ppCP, ULONG *pcFetched);   
    HRESULT __stdcall Skip(ULONG cConnections);    
    HRESULT __stdcall Reset();    
    HRESULT __stdcall Clone(IEnumConnectionPoints **ppEnum);

private:
    ComCallWrapper                  *m_pOwnerWrap;
    CQuickArray<ConnectionPoint*>   *m_pCPList;
    UINT                            m_CurrPos;
    ULONG                           m_cbRefCount;
};

// Enumeration of connections.
class ConnectionEnum : IEnumConnections
{
public:
    ConnectionEnum(ConnectionPoint *pConnectionPoint);
    ~ConnectionEnum();

    HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);
    ULONG __stdcall AddRef();
    ULONG __stdcall Release();

    HRESULT __stdcall Next(ULONG cConnections, CONNECTDATA* rgcd, ULONG *pcFetched);       
    HRESULT __stdcall Skip(ULONG cConnections);
    HRESULT __stdcall Reset();
    HRESULT __stdcall Clone(IEnumConnections **ppEnum);

private:
    ConnectionPoint                 *m_pConnectionPoint;
    ConnectionCookie                *m_CurrCookie;
    ULONG                           m_cbRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcryptography.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:       COMCryptography.cpp
//  
//  Contents:   Native method implementations and helper code for
//              supporting CAPI based operations on X509 signatures
//              for use by the PublisherPermission in the CodeIdentity
//              permissions family.
//
//  Classes and   
//  Methods:    COMCryptography
//               |
//               +--_GetBytes
//               +--_GetNonZeroBytes
//
//  History:    08/01/1999  JimSch Created
//
//---------------------------------------------------------------------------


#include "common.h"
#include "object.h"
#include "excep.h"
#include "utilcode.h"
#include "field.h"
#include "COMString.h"
#include "COMCryptography.h"
#include "gcscan.h"
#include "CorPermE.h"

#define     DSS_MAGIC           0x31535344
#define     DSS_PRIVATE_MAGIC   0x32535344
#define     DSS_PUB_MAGIC_VER3  0x33535344
#define     DSS_PRIV_MAGIC_VER3 0x34535344
#define     RSA_PUB_MAGIC       0x31415352
#define     RSA_PRIV_MAGIC      0x32415352

#define FORMAT_MESSAGE_BUFFER_LENGTH 1024

#define CRYPT_MALLOC( X ) new(nothrow) BYTE[X]
#define CRYPT_FREE( X ) delete [] X; X = NULL
 
#define HR_GETLASTERROR HRESULT_FROM_WIN32(::GetLastError())                       

// These flags match those defined for the CspProviderFlags enum in 
// src/bcl/system/security/cryptography/CryptoAPITransform.cs

#define CSP_PROVIDER_FLAGS_USE_MACHINE_KEYSTORE 0x0001
#define CSP_PROVIDER_FLAGS_USE_DEFAULT_KEY_CONTAINER 0x0002

typedef struct  {
    BLOBHEADER          blob;
    union {
        DSSPRIVKEY_VER3         dss_priv_v3;
        DSSPUBKEY_VER3          dss_pub_v3;
        DSSPUBKEY               dss_v2;
        RSAPUBKEY               rsa;
    };
} KEY_HEADER;

//
//  The following data is used in caching the names and instances of
//      default providers to be used
//

#define MAX_CACHE_DEFAULT_PROVIDERS 20
LPWSTR      RgpwszDefaultProviders[MAX_CACHE_DEFAULT_PROVIDERS];
WCHAR       RgwchKeyName[] = L"Software\\Microsoft\\Cryptography\\"
                        L"Defaults\\Provider Types\\Type 000";
const int       TypePosition = (sizeof(RgwchKeyName)/sizeof(WCHAR)) - 4;
const WCHAR     RgwchName[] = L"Name";

HCRYPTPROV      RghprovCache[MAX_CACHE_DEFAULT_PROVIDERS];
static inline void memrev(LPBYTE pb, DWORD cb);

//////////////////////////// UTILITY FUNCTIONS ///////////////////////////////

BYTE rgbPrivKey[] =
{
0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
0x3F, 0x8C, 0x4A, 0xD0,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x64, 0xD5, 0xAA, 0xB1,
0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
0xB1, 0x74, 0x5B, 0x60,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

BYTE rgbSymKey[] = 
{
0x01, 0x02, 0x00, 0x00, 0x02, 0x66, 0x00, 0x00,
0x00, 0xA4, 0x00, 0x00, 0xAD, 0x89, 0x5D, 0xDA,
0x82, 0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x02, 0x00
};

BYTE rgbPubKey[] = {
    0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
    0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xab, 0xef, 0xfa, 0xc6,
    0x7d, 0xe8, 0xde, 0xfb, 0x68, 0x38, 0x09, 0x92,
    0xd9, 0x42, 0x7e, 0x6b, 0x89, 0x9e, 0x21, 0xd7,
    0x52, 0x1c, 0x99, 0x3c, 0x17, 0x48, 0x4e, 0x3a,
    0x44, 0x02, 0xf2, 0xfa, 0x74, 0x57, 0xda, 0xe4,
    0xd3, 0xc0, 0x35, 0x67, 0xfa, 0x6e, 0xdf, 0x78,
    0x4c, 0x75, 0x35, 0x1c, 0xa0, 0x74, 0x49, 0xe3,
    0x20, 0x13, 0x71, 0x35, 0x65, 0xdf, 0x12, 0x20,
    0xf5, 0xf5, 0xf5, 0xc1
};

//==========================================================================
// Throw a runtime exception based on the last Win32 error (GetLastError())
//==========================================================================
VOID COMPlusThrowCrypto(HRESULT hr)
{
    THROWSCOMPLUSEXCEPTION();

    // before we do anything else...
    WCHAR   wszBuff[FORMAT_MESSAGE_BUFFER_LENGTH];
    WCHAR  *wszFinal = wszBuff;

    DWORD res = WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL         /*ignored msg source*/,
                                 hr,
                                 0            /*pick appropriate languageId*/,
                                 wszFinal,
                                 FORMAT_MESSAGE_BUFFER_LENGTH-1,
                                 0            /*arguments*/);
    if (res == 0) 
        COMPlusThrow(kCryptographicException, IDS_EE_CRYPTO_UNKNOWN_ERROR);

    // Either way, we now have the formatted string from the system.
    COMPlusThrowNonLocalized(kCryptographicException, wszFinal);
}

//
// WARNING: This function side-effects its first argument (hProv)
// MSProviderCryptImportKey does an "exponent-of-one" import of specified
// symmetric key material into a CSP.  However, it clobbers any exchange key pair
// already in hProv.
//

BOOL MSProviderCryptImportKey(HCRYPTPROV hProv, LPBYTE rgbSymKey, DWORD cbSymKey,
                              DWORD dwFlags, HCRYPTKEY * phkey)
{
    BOOL fSuccess = FALSE;
    HCRYPTKEY hPrivKey = 0;

    if (!CryptImportKey( hProv, rgbPrivKey, sizeof(rgbPrivKey), 0,
                         0, &hPrivKey )) {
        goto Ret;
    }
    
    if (!CryptImportKey( hProv, rgbSymKey, cbSymKey, hPrivKey, dwFlags, phkey )) {
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (hPrivKey)
        CryptDestroyKey( hPrivKey );

    return fSuccess;
}

//
// WARNING: This function side-effects its third argument (hProv)
// because it calls MSProviderCryptImportKey
//

HRESULT LoadKey(LPBYTE rgbKeyMaterial, DWORD cbKeyMaterial, HCRYPTPROV hprov,
                int kt, DWORD dwFlags, HCRYPTKEY * phkey)
{
    HRESULT                     hr = S_OK;
    DWORD                       i;
    LPBYTE                      pb;
    BLOBHEADER *                pbhdr;
    LPSTR                       pszProvider = NULL;
    BYTE                        rgb[sizeof(rgbSymKey)];

    //    case MLALG_RC2_128:
    //        dwFlags = 128 << 16;
    //    if (kt == CALG_RC2) {
    //        dwFlags |= (cbKeyMaterial * 8) << 16;
    //    }

    if (kt == CALG_RC2) {
      dwFlags |= CRYPT_NO_SALT;
    }
    
    // Do this check here as a sanity check to avoid buffer overruns
    if (cbKeyMaterial + sizeof(ALG_ID) + sizeof(BLOBHEADER) >= sizeof(rgbSymKey)) {
        hr = E_FAIL;
        goto exit;
    }
    
    memcpy(rgb, rgbSymKey, sizeof(rgbSymKey));

    pbhdr = (BLOBHEADER *) rgb;
    pbhdr->aiKeyAlg = kt;
    pb = &rgb[sizeof(*pbhdr)];
    *((ALG_ID *) pb) = CALG_RSA_KEYX;

    pb += sizeof(ALG_ID);
        
    for (i=0; i<cbKeyMaterial; i++) {
        pb[cbKeyMaterial-i-1] = rgbKeyMaterial[i];
    }
    pb[cbKeyMaterial] = 0;

    if (!MSProviderCryptImportKey(hprov, rgb, sizeof(rgb), dwFlags, phkey)) {
        hr = E_FAIL;
        goto exit;
    }

exit:
    return hr;
}


//
// WARNING: This function side-effects its first argument (hProv)
//

HRESULT UnloadKey(HCRYPTPROV hprov, HCRYPTKEY hkey, LPBYTE * ppb, DWORD * pcb)
{
    DWORD       cbOut;
    HRESULT     hr = S_OK;
    HCRYPTKEY   hPubKey = NULL;
    DWORD       i;
    LPBYTE      pbOut = NULL;
    LPBYTE      pb2;
    
    if (!CryptImportKey(hprov, rgbPubKey, sizeof(rgbPubKey), 0, 0, &hPubKey)) {
        hr = HR_GETLASTERROR;
        goto Ret;
    }

    if (!CryptExportKey(hkey, hPubKey, SIMPLEBLOB, 0, NULL, &cbOut)) {
        hr = HR_GETLASTERROR;
        goto Ret;
    }

    pbOut = (LPBYTE) CRYPT_MALLOC(cbOut);
    if (pbOut == NULL) {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    
    if (!CryptExportKey(hkey, hPubKey, SIMPLEBLOB, 0, pbOut, &cbOut)) {
        hr = HR_GETLASTERROR;
        goto Ret;
    }

    //  Get size of the item

    pb2 = pbOut + sizeof(BLOBHEADER) + sizeof(DWORD);
    for (i=cbOut - sizeof(BLOBHEADER) - sizeof(DWORD) - 2; i>0; i--) {
        if (pb2[i] == 0) {
            break;
        }
    }

    //  Now allocate the return buffer

    *ppb = (LPBYTE) CRYPT_MALLOC(i);
    if (*ppb == NULL) {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    
    memcpy(*ppb, pb2, i);
    memrev(*ppb, i);
    *pcb = i;

Ret:
    if (hPubKey != NULL) {
        CryptDestroyKey(hPubKey);
    }
    if (pbOut != NULL) {
        CRYPT_FREE(pbOut);
    }
    return hr;
}

/***    GetDefaultProvider
 *
 *  Description:
 *      Find the default provider name to be used in the case that we
 *      were not actually passed in a provider name.  The main purpose
 *      of this code is really to deal with the enhanched/default provider
 *      problems given to us by the CAPI team.
 *
 *  Returns:
 *      name of the provider to be used.
 */

 LPWSTR GetDefaultProvider(DWORD dwType)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD       cbData;
    HKEY        hkey = 0;
    LONG        l;
    LPWSTR      pwsz = NULL;
    DWORD       dwRegKeyType;

    //
    //  We can't deal with providers whos types are too large.
    //
    //  They are uninteresting to the core of changing default names anyway.
    //

    if (dwType >= MAX_CACHE_DEFAULT_PROVIDERS) {
        return NULL;
    }

    //
    //  If we have already gotten a name for this provider type, then
    //  just return it.
    //
    
    if (RgpwszDefaultProviders[dwType] != NULL) {
        return RgpwszDefaultProviders[dwType];
    }

    //
    //  Fix up the key name based on the provider type and then get the
    //  key.
    //
    
    RgwchKeyName[TypePosition] = (WCHAR) ('0' + (dwType/100));
    RgwchKeyName[TypePosition+1] = (WCHAR) ('0' + (dwType/10) % 10);
    RgwchKeyName[TypePosition+2] = (WCHAR) ('0' + (dwType % 10));
    
    l = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, RgwchKeyName, 0,
                     KEY_QUERY_VALUE, &hkey);
    if (l != ERROR_SUCCESS) {
        goto err;
    }

    //
    // Determine the length default name, allocate a buffer and retrieve it.
    //

    l = WszRegQueryValueEx(hkey, RgwchName, NULL, &dwRegKeyType, NULL, &cbData);
    if ((l != ERROR_SUCCESS) || (dwRegKeyType != REG_SZ)) {
        goto err;
    }

    pwsz = (LPWSTR) CRYPT_MALLOC(cbData);
    if (pwsz == NULL) {
        RegCloseKey(hkey);
        COMPlusThrowOM();
    }
    l = WszRegQueryValueEx(hkey, RgwchName, NULL, &dwRegKeyType, (LPBYTE) pwsz, &cbData);
    if (l != ERROR_SUCCESS) {
        CRYPT_FREE(pwsz);
        pwsz = NULL;
        goto err;
    }

    if (hkey != 0) {
        RegCloseKey(hkey);
        hkey = 0;
    }

    //
    //  If this is the base RSA provider, see if we can use the enhanced
    //  provider instead.  If so then change to use the enhanced provider name
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if ((dwType == PROV_RSA_FULL) && (wcscmp(pwsz, MS_DEF_PROV_W) == 0)) {
        HCRYPTPROV      hprov = 0;
        if (WszCryptAcquireContext(&hprov, NULL, MS_ENHANCED_PROV_W,
                                   dwType, CRYPT_VERIFYCONTEXT)) {
            CRYPT_FREE(pwsz);
            pwsz = (LPWSTR) CRYPT_MALLOC((wcslen(MS_ENHANCED_PROV_W)+1)*sizeof(WCHAR));
            if (pwsz == NULL) {
                COMPlusThrowOM();
            }
            wcscpy(pwsz,MS_ENHANCED_PROV_W);
            RghprovCache[dwType] = hprov;
        }
    }

    //
    //  If this is the base DSS/DH provider, see if we can use the enhanced
    //  provider instead.  If so then change to use the enhanced provider name
    //

    else if ((dwType == PROV_DSS_DH) &&
             (wcscmp(pwsz, MS_DEF_DSS_DH_PROV_W) == 0)) {
        HCRYPTPROV      hprov = 0;
        if (WszCryptAcquireContext(&hprov, NULL, MS_ENH_DSS_DH_PROV_W,
                                   dwType, CRYPT_VERIFYCONTEXT)) {
            CRYPT_FREE(pwsz);
            pwsz = (LPWSTR) CRYPT_MALLOC((wcslen(MS_ENH_DSS_DH_PROV_W)+1)*sizeof(WCHAR));
            if (pwsz == NULL) {
                COMPlusThrowOM();
            }
            wcscpy(pwsz,MS_ENH_DSS_DH_PROV_W);
            RghprovCache[dwType] = hprov;
        }
    }

    END_ENSURE_PREEMPTIVE_GC();

    RgpwszDefaultProviders[dwType] = pwsz;

err:
    if (hkey != 0) RegCloseKey(hkey);
    return pwsz;
}

/***    memrev
 *
 */

inline void memrev(LPBYTE pb, DWORD cb)
{
    BYTE    b;
    DWORD   i;
    LPBYTE  pbEnd = pb+cb-1;
    
    for (i=0; i<cb/2; i++, pb++, pbEnd--) {
        b = *pb;
        *pb = *pbEnd;
        *pbEnd = b;
    }
}

/****   OpenCSP
 *
 *  Description:
 *      OpenCSP performs the core work of openning and creating CSPs and
 *      containers in CSPs.
 *
 *  Parameters:
 *      pSafeThis - is a reference to a CSP_Parameters object.  This object
 *              contains all of the relevant items to open a CSP
 *      dwFlags - Flags to pass into CryptAcquireContext with the following
 *              additional rules:
 *              CRYPT_VERIFYCONTEXT will be changed to 0 if a container is set
 *      phprov - returns the newly openned provider
 *
 *  Returns:
 *      a Windows error code.
 */

int COMCryptography::OpenCSP(OBJECTREF * pSafeThis, DWORD dwFlags,
                             HCRYPTPROV * phprov)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               dwType;
    DWORD               dwCspProviderFlags;
    HRESULT             hr = S_OK;
    OBJECTREF           objref;
    EEClass *           pClass;
    FieldDesc *         pFD;
    LPWSTR              pwsz = NULL;
    LPWSTR              pwszProvider = NULL;
    LPWSTR              pwszContainer = NULL;
    STRINGREF           strContainer;
    STRINGREF           strProvider;
    STRINGREF           str;

    CQuickBytes qbProvider;
    CQuickBytes qbContainer;

    pClass = (*pSafeThis)->GetClass();
    if (pClass == NULL) {
        _ASSERTE(!"Cannot find class");
        COMPlusThrow(kArgumentNullException, L"Arg_NullReferenceException");
    }

    //
    //  Look for the provider type
    //
    
    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__PROVIDER_TYPE);
    dwType = pFD->GetValue32(*pSafeThis);

    //
    //  Look for the provider name
    //
    
    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__PROVIDER_NAME);

    objref = pFD->GetRefValue(*pSafeThis);
    strProvider = ObjectToSTRINGREF(*(StringObject **) &objref);
    if (strProvider != NULL) {
        pwsz = strProvider->GetBuffer();
        if ((pwsz != NULL) && (*pwsz != 0)) {
            int length = strProvider->GetStringLength();
            pwszProvider = (LPWSTR) qbProvider.Alloc((1+length)*sizeof(WCHAR));
            memcpy (pwszProvider, pwsz, length*sizeof(WCHAR));
            pwszProvider[length] = L'\0';
        }
        else {            
            pwszProvider = GetDefaultProvider(dwType);
            
            str = COMString::NewString(pwszProvider);
            pFD->SetRefValue(*pSafeThis, (OBJECTREF)str);
        }
    } else {
        pwszProvider = GetDefaultProvider(dwType);

        str = COMString::NewString(pwszProvider);
        pFD->SetRefValue(*pSafeThis, (OBJECTREF)str);
    }

    // look to see if the user specified that we should pass
    // CRYPT_MACHINE_KEYSET to CAPI to use machine key storage instead
    // of user key storage

    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__FLAGS);
    dwCspProviderFlags = pFD->GetValue32(*pSafeThis);
    if (dwCspProviderFlags & CSP_PROVIDER_FLAGS_USE_MACHINE_KEYSTORE) {
        dwFlags |= CRYPT_MACHINE_KEYSET;
    }

    // If the user specified CSP_PROVIDER_FLAGS_USE_DEFAULT_KEY_CONTAINER,
    // then ignore the container name and hand back the default container

    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__KEY_CONTAINER_NAME);
    if (!(dwCspProviderFlags & CSP_PROVIDER_FLAGS_USE_DEFAULT_KEY_CONTAINER)) {
        //  Look for container name
        objref = pFD->GetRefValue(*pSafeThis);
        strContainer = ObjectToSTRINGREF(*(StringObject **) &objref);
        if (strContainer != NULL) {
            pwsz = strContainer->GetBuffer();
            if ((pwsz != NULL) && (*pwsz != 0)) {
                int length = strContainer->GetStringLength();
                pwszContainer = (LPWSTR) qbContainer.Alloc((1+length)*sizeof(WCHAR));
                memcpy (pwszContainer, pwsz, length*sizeof(WCHAR));
                pwszContainer[length] = L'\0';
                if (dwFlags & CRYPT_VERIFYCONTEXT) {
                    dwFlags &= ~CRYPT_VERIFYCONTEXT;
                }
            }
        }
    }

    //
    //  Go ahead and try to open the CSP.  If we fail, make sure the CSP
    //    returned is 0 as that is going to be the error check in the caller.
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!WszCryptAcquireContext(phprov, pwszContainer, pwszProvider,
                                dwType, dwFlags)){
        hr = HR_GETLASTERROR;
    }
    END_ENSURE_PREEMPTIVE_GC();

    return hr;
}



///////////////////////////  FCALL FUNCTIONS /////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     _AcquireCSP( . . . . )
//  
//  Synopsis:   Native method openning a CSP
//
//  Arguments:  [args] --  A __AcquireCSP structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        Provider information object reference
//                        A provider type.
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

int  __stdcall
COMCryptography::_AcquireCSP(__AcquireCSP *args)
{
    HRESULT             hr;
    THROWSCOMPLUSEXCEPTION();

    //
    //  We want to just open this CSP.  Passing in verify context will
    //     open it and, if a container is give, mapped to open the container.
    //
    HCRYPTPROV hprov = 0;
    hr = OpenCSP(&(args->cspParameters), CRYPT_VERIFYCONTEXT, &hprov);
    *(INT_PTR*)(args->phCSP) = hprov;
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     _SearchForAlgorithm( . . . . )
//  
//  Synopsis:   Method for determining whether a CSP supports a particular
//              algorithm and (optionally) a key size of that algorithm
//
//  Arguments:  [args] --  A __SearchForAlgorithm structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A provider handler.
//                        An algorithm type (e.g. CALG_DES)
//                        A key length (0 == don't care)
//
//  Returns:    HRESULT code.
//
//  History:    5/11/2000, bal
// 
//---------------------------------------------------------------------------

int  __stdcall
COMCryptography::_SearchForAlgorithm(__SearchForAlgorithm *args)
{
    HRESULT hr;
    BYTE *pbData = NULL;
    DWORD cbData;
    int dwFlags = CRYPT_FIRST;
    PROV_ENUMALGS_EX *provdata;
    ALG_ID provAlgID;
    DWORD provMinLength;
    DWORD provMaxLength;

    THROWSCOMPLUSEXCEPTION();


    BEGIN_ENSURE_PREEMPTIVE_GC();

    // First, we have to get the max size of the PP
    if (!CryptGetProvParam((HCRYPTPROV)args->hProv, PP_ENUMALGS_EX, NULL, &cbData, dwFlags)) {
        hr = HR_GETLASTERROR;
        goto Exit;
    }
    // Allocate pbData
    pbData = (BYTE *) CRYPT_MALLOC(cbData*sizeof(BYTE));
    if (pbData == NULL) {
        COMPlusThrowOM();
    }
    while(CryptGetProvParam((HCRYPTPROV)args->hProv, PP_ENUMALGS_EX, pbData, &cbData, dwFlags)) {       
        dwFlags=0;  // so we don't use CRYPT_FIRST more than once
        provdata = (PROV_ENUMALGS_EX *) pbData;
        provAlgID = provdata->aiAlgid;
        provMinLength = provdata->dwMinLen;
        provMaxLength = provdata->dwMaxLen;

        // OK, now check to see if we have an alg match
        if ((ALG_ID) args->algID == provAlgID) {
            // OK, see if we have a keylength match, or if we don't care
            if (((DWORD) args->keyLength == 0) || 
                (((DWORD) args->keyLength >= provMinLength) && 
                 ((DWORD) args->keyLength <= provMaxLength))) {
                hr = S_OK;
                goto Exit;
            }
        } // keep looping
    }
    // fell through 
    hr = S_FALSE;
Exit:
    END_ENSURE_PREEMPTIVE_GC();

    if (pbData)
        CRYPT_FREE(pbData);
    return (hr);
}

//+--------------------------------------------------------------------------
//
//  Member:     _CreateCSP( . . . . )
//  
//  Synopsis:   Native method to create a new CSP container
//
//  Arguments:  [args] --  A __AcquireCSP structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        Provider information object reference
//                        A provider type.
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

int __stdcall
COMCryptography::_CreateCSP(__AcquireCSP *args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT             hr = S_OK;
    OBJECTREF objref = NULL;
    FieldDesc *pFD, *pFD2;
    LPWSTR              pwsz = NULL;
    STRINGREF strContainer = NULL;
    STRINGREF newString = NULL;
    DWORD               dwCspProviderFlags;

    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__KEY_CONTAINER_NAME);
    objref = pFD->GetRefValue(args->cspParameters);
    strContainer = ObjectToSTRINGREF(*(StringObject **) &objref);
    if (strContainer != NULL) {
        pwsz = strContainer->GetBuffer();
        if ((pwsz != NULL) && (*pwsz == 0)) {
            pwsz = NULL;
        }
    }

    pFD2 = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__FLAGS);
    dwCspProviderFlags = pFD2->GetValue32(args->cspParameters);

    // If the user specified CSP_PROVIDER_FLAGS_USE_DEFAULT_KEY_CONTAINER,
    // then ignore the container name, don't generate a new one

    if ((pwsz == NULL) && !(dwCspProviderFlags & CSP_PROVIDER_FLAGS_USE_DEFAULT_KEY_CONTAINER)) {
        GUID            guid;
        WCHAR           rgwch[50] = L"CLR";

        if (CoCreateGuid(&guid) != S_OK) {
            _ASSERTE(!"CoCreateGUID failed");
            COMPlusThrowWin32();
        }
        if (GuidToLPWSTR(guid, &rgwch[3], 45) == 0) {
            _ASSERTE(!"GuidToLPWSTR failed");
            COMPlusThrowWin32();
        }
        
        newString = COMString::NewString(rgwch);
        
        pFD->SetRefValue(args->cspParameters, (OBJECTREF) newString);
    }
    else {
        HCRYPTPROV hcryptprov = 0;
        hr = OpenCSP(&(args->cspParameters), 0, &hcryptprov);
        *(INT_PTR*)(args->phCSP) = hcryptprov;
        if (hr == S_OK) {
            return(hr);
        }
    }

    HCRYPTPROV hcryptprov = 0;
    hr = OpenCSP(&(args->cspParameters), CRYPT_NEWKEYSET, &hcryptprov);
    *(INT_PTR*)(args->phCSP) = hcryptprov;
    return hr;
}

INT_PTR __stdcall
COMCryptography::_CreateHash(__CreateHash * args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    HCRYPTHASH hHash = 0;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptCreateHash((HCRYPTPROV) args->hCSP, args->dwHashType, NULL, 0, &hHash)) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        COMPlusThrowCrypto(hr);
    }
    
    return (INT_PTR) hHash;
}

LPVOID __stdcall
COMCryptography::_DecryptData(__EncryptData * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb = 0;
    DWORD               cb2;
    LPBYTE              pb;
    U1ARRAYREF          rgbOut;

    cb2 = args->cb;
    // Do this check here as a sanity check. Also, this will catch bugs in CryptoAPITransform
    if (args->ib < 0 || cb2 < 0 || (args->ib + cb2) < 0 || (args->ib + cb2) > args->data->GetNumComponents())
        COMPlusThrowCrypto(NTE_BAD_DATA);

    pb = (LPBYTE) CRYPT_MALLOC(cb2);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    
    memcpy(pb, args->ib + (LPBYTE) args->data->GetDirectPointerToNonObjectElements(), cb2);

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptDecrypt((HCRYPTPROV) args->hKey, NULL, args->fLast, 0, pb, &cb2)) {
        CRYPT_FREE(pb);
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }
    
    END_ENSURE_PREEMPTIVE_GC();
    
    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb2);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb2);

    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}

////    COMCryptography::_DecryptKey
//
//  Description:
//      This function is used to remove Asymmetric encryption from a blob
//      of data.  The result is then exported and returned if possible.
//  

LPVOID __stdcall
COMCryptography::_DecryptKey(__EncryptKey * args)
{
    THROWSCOMPLUSEXCEPTION();

    BLOBHEADER * blob = NULL;
    DWORD       cb;
    DWORD       cbKey = args->rgbKey->GetNumComponents();
    HCRYPTKEY   hKey = 0;
    HCRYPTKEY   hkeypub = NULL;
    HRESULT     hr = S_OK;
    LPBYTE      pb = NULL;
    LPBYTE      pbKey = (LPBYTE) args->rgbKey->GetDirectPointerToNonObjectElements();
    U1ARRAYREF  rgbOut;
    LPBYTE      pbRealKeypair = NULL;
    DWORD       cbRealKeypair;
    DWORD       dwBlobType = PRIVATEKEYBLOB;

    //
    // Need to build up the entire mess into what CSPs will accept.
    //

    blob = (BLOBHEADER *) CRYPT_MALLOC(cbKey + sizeof(BLOBHEADER) + sizeof(DWORD));

    if (blob == NULL)
        COMPlusThrow(kOutOfMemoryException);

    blob->bType = SIMPLEBLOB;
    blob->bVersion = CUR_BLOB_VERSION;
    blob->reserved = 0;
    blob->aiKeyAlg = CALG_3DES;
    *((ALG_ID *) &blob[1]) = CALG_RSA_KEYX;
    memcpy(((LPBYTE) &blob[1] + sizeof(DWORD)), pbKey, cbKey);
    memrev(((LPBYTE) &blob[1]) + sizeof(DWORD), cbKey);


    //
    //  Start by decrypting the data blob if possible
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptImportKey((HCRYPTPROV)args->hCSP, (LPBYTE) blob,
                        cbKey + sizeof(BLOBHEADER) + sizeof(DWORD),
                        (HCRYPTKEY)args->hkeyPub, CRYPT_EXPORTABLE, &hKey)) {
        blob->aiKeyAlg = CALG_RC2;
        if (!CryptImportKey((HCRYPTPROV)args->hCSP, (LPBYTE) blob,
                            cbKey + sizeof(BLOBHEADER) + sizeof(DWORD),
                            (HCRYPTKEY)args->hkeyPub, CRYPT_EXPORTABLE, &hKey)) {
            hr = HR_GETLASTERROR;
            CRYPT_FREE(blob);
            COMPlusThrowCrypto(hr);             
        }
    }

    // UnloadKey will side-effect and change the public/private key pair, so we better 
    // save it off to the side first so we can restore it later.
    // Note that this requires that the key we generated be exportable, but that's
    // true for these classes in general.
    // Note that we don't know if the key container has only a public key or a public/private key pair, so 
    // we try to get the private first, and if that fails fall back to the public only.

    // First, get the length of the PRIVATEKEYBLOB
    if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, NULL, &cbRealKeypair)) {
        hr = HR_GETLASTERROR;
        // if we got an NTE_BAD_KEY_STATE, try public only
        if (hr != NTE_BAD_KEY_STATE) {
            CRYPT_FREE(blob);
            CryptDestroyKey(hKey);
            COMPlusThrowCrypto(hr);
        }
        dwBlobType = PUBLICKEYBLOB;
        if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, NULL, &cbRealKeypair)) {
            hr = HR_GETLASTERROR;
            CRYPT_FREE(blob);
            CryptDestroyKey(hKey);
            COMPlusThrowCrypto(hr);
        }
    }
    // Alloc the space
    pbRealKeypair = (LPBYTE) CRYPT_MALLOC(cbRealKeypair);
    if (pbRealKeypair == NULL) {
        CRYPT_FREE(blob);
        CryptDestroyKey(hKey);
        COMPlusThrowOM();
    }
    // Export it for real
    if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, pbRealKeypair, &cbRealKeypair)) {
        hr = HR_GETLASTERROR;
        CRYPT_FREE(blob);
        CRYPT_FREE(pbRealKeypair);
        CryptDestroyKey(hKey);
        COMPlusThrowCrypto(hr);
    }

    //
    //  Saved away, so now lets upload the key if we can
    //

    hr = UnloadKey((HCRYPTPROV)args->hCSP, hKey, &pb, &cb);
    if (FAILED(hr)) {
        CRYPT_FREE(blob);
        CRYPT_FREE(pbRealKeypair);
        CryptDestroyKey(hKey);
        COMPlusThrowCrypto(hr);
    }

    // Now, import the saved PRIVATEKEYBLOB back into the CSP
    if (!CryptImportKey((HCRYPTPROV)args->hCSP, pbRealKeypair, cbRealKeypair, 0, CRYPT_EXPORTABLE, &hkeypub)) {
        hr = HR_GETLASTERROR;
        CryptDestroyKey(hKey);
        CRYPT_FREE(pb);
        CRYPT_FREE(blob);
        CRYPT_FREE(pbRealKeypair);
        COMPlusThrowCrypto(hr);
    }

    END_ENSURE_PREEMPTIVE_GC();

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb);

    CRYPT_FREE(blob);
    CRYPT_FREE(pb);
    CRYPT_FREE(pbRealKeypair);
    CryptDestroyKey(hKey);
    CryptDestroyKey(hkeypub);
    RETURN (rgbOut, U1ARRAYREF);
}

// This next routine performs direct decryption with an RSA private key
// of an arbitrary session key using PKCS#1 v2 padding.  (See the Remark
// in MSDN's page on CryptDecrypt in the Platform SDK
// We require that the caller confirm that the size of the data to be 
// decrypted is the size of the public modulus (zero-padded as necessary)
// This function can only be called on a Win2K box with the RSA Enhanced
// Provider installed


LPVOID __stdcall
COMCryptography::_DecryptPKWin2KEnh(__EncryptPKWin2KEnh * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb;
    LPBYTE              pb;
    DWORD               cOut = 0;
    U1ARRAYREF          rgbOut;
    HRESULT             hr = S_OK;
    DWORD               dwFlags = (args->fOAEP == FALSE ? 0 : CRYPT_OAEP);

    // First compute the size of the return buffer
    cb = args->rgbKey->GetNumComponents();
    // since pb is the in/out buffer it has to be the max of cb & cOut in size
    // change cOut appropriately
    pb = (LPBYTE) CRYPT_MALLOC(cb);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    memcpy(pb, (LPBYTE)args->rgbKey->GetDirectPointerToNonObjectElements(), cb);
    // have to make this little endian for CAPI
    memrev(pb, cb);

    // Do the decrypt
    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!CryptDecrypt((HCRYPTKEY)args->hKey, NULL, TRUE , dwFlags, pb, &cb)) {
        hr = HR_GETLASTERROR;
    }
    END_ENSURE_PREEMPTIVE_GC();
        
    if (FAILED(hr)) {
        CRYPT_FREE(pb);
        if (dwFlags == CRYPT_OAEP) {
            if (hr == NTE_BAD_FLAGS) {
                COMPlusThrow(kCryptographicException, L"Cryptography_OAEP_WhistlerEnhOnly");
            } else {
                // Throw a generic exception if using OAEP to protect against chosen cipher text attacks
                COMPlusThrow(kCryptographicException, L"Cryptography_OAEPDecoding");        
            }
        } else  COMPlusThrowCrypto(hr);
    }

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb);
    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}


LPVOID __stdcall
COMCryptography::_EncryptData(__EncryptData * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb = 0;
    DWORD               cb2;
    LPBYTE              pb;
    U1ARRAYREF          rgbOut;

    cb2 = args->cb;
    cb = cb2 + 8;
    // Do this check here as a sanity check. Also, this will catch bugs in CryptoAPITransform
    if (args->ib < 0 || cb2 < 0 || (args->ib + cb2) < 0 || (args->ib + cb2) > args->data->GetNumComponents())
        COMPlusThrowCrypto(NTE_BAD_DATA);

    pb = (LPBYTE) CRYPT_MALLOC(cb);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    
    memcpy(pb, args->ib + (LPBYTE) args->data->GetDirectPointerToNonObjectElements(), cb2);

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptEncrypt((HCRYPTKEY)args->hKey, NULL, args->fLast, 0, pb, &cb2, cb)) {
        CRYPT_FREE(pb);
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }
    
    END_ENSURE_PREEMPTIVE_GC();

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb2);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb2);

    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}

LPVOID __stdcall
COMCryptography::_EncryptKey(__EncryptKey * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD       algid = CALG_RC2;
    DWORD       cb2;
    DWORD       cbKey = args->rgbKey->GetNumComponents();
    DWORD       cbOut;
    HCRYPTKEY   hkey = NULL;
    HCRYPTKEY   hkeypub = NULL;
    HRESULT     hr = S_OK;
    LPBYTE      pbKey = (LPBYTE) args->rgbKey->GetDirectPointerToNonObjectElements();
    LPBYTE      pbOut = NULL;
    U1ARRAYREF  rgbOut;
    LPBYTE      pbRealKeypair = NULL;
    DWORD       cbRealKeypair;
    DWORD       dwBlobType = PRIVATEKEYBLOB;

    //
    // Start by importing the data in as an RC2 key
    //

    if (cbKey == (192/8)) {
        algid = CALG_3DES;      // 192 bits is size of 3DES key
    }
    else if ((cbKey < (40/8)) || (cbKey > (128/8)+1)) {
        COMPlusThrow(kCryptographicException, IDS_EE_CRYPTO_ILLEGAL_KEY_SIZE);
    }

    CQuickBytes qb;
    LPBYTE buffer = (LPBYTE)qb.Alloc(cbKey * sizeof (BYTE));
    memcpyNoGCRefs (buffer, pbKey, cbKey * sizeof (BYTE));

    // LoadKey will side-effect and change the public/private key pair, so we better 
    // save it off to the side first so we can restore it later.
    // Note that this requires that the key we generated be exportable, but that's
    // true for these classes in general.
    // Note that we don't know if the key container has only a public key or a public/private key pair, so 
    // we try to get the private first, and if that fails fall back to the public only.

    BEGIN_ENSURE_PREEMPTIVE_GC();

    // First, get the length of the PRIVATEKEYBLOB
    if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, NULL, &cbRealKeypair)) {
        hr = HR_GETLASTERROR;
        // if we got an NTE_BAD_KEY_STATE, try public only
        if (hr != NTE_BAD_KEY_STATE) COMPlusThrowCrypto(hr);
        dwBlobType = PUBLICKEYBLOB;
        if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, NULL, &cbRealKeypair)) {
            hr = HR_GETLASTERROR;
            COMPlusThrowCrypto(hr);
        }
    }
    // Alloc the space
    pbRealKeypair = (LPBYTE) CRYPT_MALLOC(cbRealKeypair);
    if (pbRealKeypair == NULL) {
        COMPlusThrowOM();
    }
    // Export it for real
    if (!CryptExportKey((HCRYPTKEY)args->hkeyPub, 0, dwBlobType, 0, pbRealKeypair, &cbRealKeypair)) {
        hr = HR_GETLASTERROR;
        CRYPT_FREE(pbRealKeypair);
        COMPlusThrowCrypto(hr);
    }
    // OK, we saved it away, go load the symmetric
    
    hr = LoadKey(buffer, cbKey, (HCRYPTPROV)args->hCSP, algid, CRYPT_EXPORTABLE, &hkey);
    if (FAILED(hr)) {
        CRYPT_FREE(pbRealKeypair);
        COMPlusThrowCrypto(hr);
    }

    // Now, import the saved PRIVATEKEYBLOB back into the CSP
    if (!CryptImportKey((HCRYPTPROV)args->hCSP, pbRealKeypair, cbRealKeypair, 0, CRYPT_EXPORTABLE, &hkeypub)) {
        hr = HR_GETLASTERROR;
        CryptDestroyKey(hkey);
        CRYPT_FREE(pbRealKeypair);
        COMPlusThrowCrypto(hr);
    }

    //
    //  Try and export it, just to get the correct size
    //

    if (!CryptExportKey(hkey, hkeypub, SIMPLEBLOB, 0,
                        NULL, &cbOut)) {
        hr = HR_GETLASTERROR;
        CryptDestroyKey(hkey);
        CRYPT_FREE(pbRealKeypair);
        CryptDestroyKey(hkeypub);
        COMPlusThrowCrypto(hr);
    }

    //
    //  Allocate memory to hold the answer
    //

    pbOut = (LPBYTE) CRYPT_MALLOC(cbOut);
    if (pbOut == NULL) {
        CryptDestroyKey(hkey);
        CryptDestroyKey(hkeypub);
        CRYPT_FREE(pbRealKeypair);
        COMPlusThrowOM();
    }

    //
    //  Now export the answer for real
    //
    
    if (!CryptExportKey(hkey, hkeypub, SIMPLEBLOB, 0,
                        pbOut, &cbOut)) {
        hr = HR_GETLASTERROR;
        CryptDestroyKey(hkey);
        CryptDestroyKey(hkeypub);
        CRYPT_FREE(pbRealKeypair);
        CRYPT_FREE(pbOut);
        COMPlusThrowCrypto(hr);
    }

    END_ENSURE_PREEMPTIVE_GC();

    //
    //  Now compute size without the wrapper information
    //

    cb2 = cbOut - (sizeof(BLOBHEADER) + sizeof(ALG_ID));
    memrev(pbOut+sizeof(BLOBHEADER)+sizeof(ALG_ID), cb2);
    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb2);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(),
                   pbOut+sizeof(BLOBHEADER)+sizeof(ALG_ID), cb2);

    CRYPT_FREE(pbOut);
    CRYPT_FREE(pbRealKeypair);
    CryptDestroyKey(hkey);
    CryptDestroyKey(hkeypub);
    RETURN (rgbOut, U1ARRAYREF);
}

// This next routine performs direct encryption with an RSA public key
// of an arbitrary session key using PKCS#1 v2 padding.  (See the Remark
// in MSDN's page on CryptEncrypt in the Platform SDK
// We require that the caller confirm that the size of the data to be 
// encrypted is at most 11 bytes less than the size of the public modulus.
// This function can only be called on a Win2K box with the RSA Enhanced
// Provider installed

LPVOID __stdcall
COMCryptography::_EncryptPKWin2KEnh(__EncryptPKWin2KEnh * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb;
    LPBYTE              pb;
    DWORD               cOut = 0;
    U1ARRAYREF          rgbOut;
    HRESULT             hr = S_OK;
    DWORD               dwFlags = (args->fOAEP == FALSE ? 0 : CRYPT_OAEP);
    
    // First compute the size of the return buffer
    cb = args->rgbKey->GetNumComponents();
    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!CryptEncrypt((HCRYPTKEY)args->hKey, NULL, TRUE , dwFlags, NULL, &cOut, cb)) {
        hr = HR_GETLASTERROR;
    }
    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        // Bad flags means OAEP is not supported on this platform
        if (dwFlags == CRYPT_OAEP && hr == NTE_BAD_FLAGS) {
            COMPlusThrow(kCryptographicException, L"Cryptography_OAEP_WhistlerEnhOnly");        
        } else  COMPlusThrowCrypto(hr);
    }

    // since pb is the in/out buffer it has to be the max of cb & cOut in size
    // change cOut appropriatelu
    if (cOut < cb) cOut = cb;
    pb = (LPBYTE) CRYPT_MALLOC(cOut);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    memcpy(pb, (LPBYTE)args->rgbKey->GetDirectPointerToNonObjectElements(), cb);

    // Now encrypt for real
    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!CryptEncrypt((HCRYPTKEY)args->hKey, NULL, TRUE, dwFlags, pb, &cb, cOut)) {
        hr = HR_GETLASTERROR;
    }
    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        CRYPT_FREE(pb);
        // Bad flags means OAEP is not supported on this platform
        if (dwFlags == CRYPT_OAEP && hr == NTE_BAD_FLAGS) {
            COMPlusThrow(kCryptographicException, L"Cryptography_OAEP_WhistlerEnhOnly");            
        } else  COMPlusThrowCrypto(hr);
    }
    // reverse from little-endian
    memrev(pb, cb);

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb);
    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}

LPVOID __stdcall
COMCryptography::_EndHash(__EndHash * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb;
    DWORD               cbHash;
    LPBYTE              pb = NULL;
    U1ARRAYREF          rgbOut;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    cb = 0;
    if (!CryptGetHashParam((HCRYPTHASH)args->hHash, HP_HASHVAL, NULL, &cbHash, 0)) {
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }

    pb = (LPBYTE) CRYPT_MALLOC(cbHash);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    
    if (!CryptGetHashParam((HCRYPTHASH)args->hHash, HP_HASHVAL, pb, &cbHash, 0)) {
        CRYPT_FREE(pb);
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }

    END_ENSURE_PREEMPTIVE_GC();

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHash);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cbHash);

    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _ExportKey( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to create a new bulk key
//                      with a specific key value and type.
//
//  Arguments:  [args] --  A __ExportKey structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        Pointer to the key object
//                        Type of object to be exported
//                        Handle of key to export (CSP is implied)
//
//  Returns:    The object containing the key
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

int __stdcall
COMCryptography::_ExportKey(__ExportKey * args)
{
    THROWSCOMPLUSEXCEPTION();

    ALG_ID              calg;
    DWORD               cb;
    DWORD               dwFlags = 0;
    BOOL                f;
    HRESULT             hr = S_OK;
    LPBYTE              pb = NULL;
    BLOBHEADER *        pblob;
    EEClass *           pClass;
    LPBYTE              pbX;
    DWORD               cbKey = 0;
    DWORD               cbMalloced = 0;
    KEY_HEADER *        pKeyInfo;
    struct __LocalGCR {
        RSA_CSP_Object *    rsaKey;
        DSA_CSP_Object *    dsaKey;
    } _gcr;

    _gcr.rsaKey = NULL;
    _gcr.dsaKey = NULL;
    pClass = args->theKey->GetClass();
    if (pClass == NULL) {
        _ASSERTE(!"Cannot find class");
        COMPlusThrow(kArgumentNullException, L"Arg_NullReferenceException");
    }

    //
    //  calgKey
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();

    cb = sizeof(calg);
    if (CryptGetKeyParam((HCRYPTKEY)args->hKey, KP_ALGID, (LPBYTE) &calg, &cb, 0)) {
        //
        //  We need to add the VER3 handle for DH and DSS keys so that we can
        //      get the fullest possible amount of information.
        //
        
        if (calg == CALG_DSS_SIGN) {
            dwFlags |= CRYPT_BLOB_VER3;
        }
    }
    
retry:
    f = CryptExportKey((HCRYPTKEY)args->hKey, NULL, args->dwBlobType, dwFlags, NULL, &cb);
    if (!f) {
        if (dwFlags & CRYPT_BLOB_VER3) {
            dwFlags &= ~(CRYPT_BLOB_VER3);
            goto retry;
        } 
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) return hr;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    pb = (LPBYTE) CRYPT_MALLOC(cb);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    cbMalloced = cb;

    if (!CryptExportKey((HCRYPTKEY)args->hKey, NULL, args->dwBlobType, dwFlags, pb, &cb)) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    GCPROTECT_BEGIN(_gcr);

    if (FAILED(hr)) goto Exit;

    pblob = (BLOBHEADER *) pb;

    switch (pblob->aiKeyAlg) {
    case CALG_RSA_KEYX:
    case CALG_RSA_SIGN:
        //CheckFieldLayout(args->theKey, "d", &gsig_rgb, RSA_CSP_Object, m_d, "RSA_CSP_Object managed class is the wrong size");
        VALIDATEOBJECTREF(args->theKey);
        _gcr.rsaKey = (RSA_CSP_Object*) (Object*) OBJECTREFToObject(args->theKey);

        if (args->dwBlobType == PUBLICKEYBLOB) {
            pKeyInfo = (KEY_HEADER *) pb;
            cb = (pKeyInfo->rsa.bitlen/8);
            
            pbX = pb + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);

            //  Exponent

            _gcr.rsaKey->m_Exponent = pKeyInfo->rsa.pubexp;

            // Modulus

            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_Modulus,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_Modulus->GetDirectPointerToNonObjectElements(),
                           pbX, cb);
            pbX += cb;
        }
        else if (args->dwBlobType == PRIVATEKEYBLOB) {
            pKeyInfo = (KEY_HEADER *) pb;
            cb = (pKeyInfo->rsa.bitlen/8);
            DWORD cbHalfModulus = cb/2;
            
            pbX = pb + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);

            _ASSERTE((cb % 2 == 0) && "Modulus is an odd number of bytes in length!");

            //  Exponent

            _gcr.rsaKey->m_Exponent = pKeyInfo->rsa.pubexp;

            // Modulus

            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_Modulus,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_Modulus->GetDirectPointerToNonObjectElements(),
                           pbX, cb);
            pbX += cb;

            // P
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_P,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHalfModulus),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_P->GetDirectPointerToNonObjectElements(),
                           pbX, cbHalfModulus);
            pbX += cbHalfModulus;

            // Q
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_Q,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHalfModulus),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_Q->GetDirectPointerToNonObjectElements(),
                           pbX, cbHalfModulus);
            pbX += cbHalfModulus;

            // dp
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_dp,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHalfModulus),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_dp->GetDirectPointerToNonObjectElements(),
                           pbX, cbHalfModulus);
            pbX += cbHalfModulus;

            // dq
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_dq,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHalfModulus),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_dq->GetDirectPointerToNonObjectElements(),
                           pbX, cbHalfModulus);
            pbX += cbHalfModulus;

            // InvQ
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_InverseQ,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbHalfModulus),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_InverseQ->GetDirectPointerToNonObjectElements(),
                           pbX, cbHalfModulus);
            pbX += cbHalfModulus;
            
            // d
            SetObjectReference((OBJECTREF *) &_gcr.rsaKey->m_d,
                               AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb),
                               _gcr.rsaKey->GetAppDomain());
            memcpyNoGCRefs(_gcr.rsaKey->m_d->GetDirectPointerToNonObjectElements(),
                           pbX, cb);
            pbX += cb;
        }
        else {
            hr = E_FAIL;
            goto Exit;
        }
        break;

    case CALG_DSS_SIGN:
        _gcr.dsaKey = (DSA_CSP_Object*) (Object*) OBJECTREFToObject(args->theKey);
        // we have to switch on whether the blob is v3 or not, because we have different
        // info avaialable if it is...
        if (pblob->bVersion > 0x2) {
            if (args->dwBlobType == PUBLICKEYBLOB) {
                int cbP, cbQ, cbJ;
                DSSPUBKEY_VER3 *   pdss;
            
                pdss = (DSSPUBKEY_VER3 *) (pb + sizeof(BLOBHEADER));
                cbP = (pdss->bitlenP+7)/8;
                cbQ = (pdss->bitlenQ+7)/8;
                pbX = pb + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY_VER3);

                // P
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_P, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_P->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                //  Q
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Q, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbQ), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Q->GetDirectPointerToNonObjectElements(), pbX, cbQ);
                pbX += cbQ;

                //  G
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_G, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_G->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                //  J
                if (pdss->bitlenJ > 0) {
                    cbJ = (pdss->bitlenJ+7)/8;
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_J, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbJ), _gcr.dsaKey->GetAppDomain());
                        memcpyNoGCRefs(_gcr.dsaKey->m_J->GetDirectPointerToNonObjectElements(), pbX, cbJ);
                        pbX += cbJ;
                }
                
                //  Y
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Y, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Y->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                if (pdss->DSSSeed.counter != 0xFFFFFFFF) {
                    //  seed
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_seed, AllocatePrimitiveArray(ELEMENT_TYPE_U1, 20), _gcr.dsaKey->GetAppDomain());
                    memcpyNoGCRefs(_gcr.dsaKey->m_seed->GetDirectPointerToNonObjectElements(), pdss->DSSSeed.seed, 20);
                    //            pdss->DSSSeed.c
                    _gcr.dsaKey->m_counter = pdss->DSSSeed.counter;
                }
            }
            else {
                int                 cbP, cbQ, cbJ, cbX;
                DSSPRIVKEY_VER3 *   pdss;
            
                pdss = (DSSPRIVKEY_VER3 *) (pb + sizeof(BLOBHEADER));
                cbP = (pdss->bitlenP+7)/8;
                cbQ = (pdss->bitlenQ+7)/8;
                pbX = pb + sizeof(BLOBHEADER) + sizeof(DSSPRIVKEY_VER3);

                // P
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_P, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_P->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                //  Q
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Q, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbQ), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Q->GetDirectPointerToNonObjectElements(), pbX, cbQ);
                pbX += cbQ;

                //  G
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_G, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_G->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                //  J
                if (pdss->bitlenJ > 0) {
                    cbJ = (pdss->bitlenJ+7)/8;
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_J, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbJ), _gcr.dsaKey->GetAppDomain());
                    memcpyNoGCRefs(_gcr.dsaKey->m_J->GetDirectPointerToNonObjectElements(), pbX, cbJ);
                    pbX += cbJ;
                }
                
                //  Y
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Y, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Y->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                //  X
                cbX = (pdss->bitlenX+7)/8;
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_X, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbX), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_X->GetDirectPointerToNonObjectElements(), pbX, cbX);
                pbX += cbX;

                if (pdss->DSSSeed.counter != 0xFFFFFFFF) {
                    //  seed
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_seed, AllocatePrimitiveArray(ELEMENT_TYPE_U1, 20), _gcr.dsaKey->GetAppDomain());
                    memcpyNoGCRefs(_gcr.dsaKey->m_seed->GetDirectPointerToNonObjectElements(), pdss->DSSSeed.seed, 20);
                    //            pdss->DSSSeed.c
                    _gcr.dsaKey->m_counter = pdss->DSSSeed.counter;
                }
            }
        } else {
            // old-style blobs
            if (args->dwBlobType == PUBLICKEYBLOB) {
                int                 cbP, cbQ;
                DSSPUBKEY *   pdss;
                DSSSEED * pseedstruct;
            
                pdss = (DSSPUBKEY *) (pb + sizeof(BLOBHEADER));
                cbP = (pdss->bitlen+7)/8; // bitlen is size of modulus
                cbQ = 20; // Q is always 20 bytes in length
                pbX = pb + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

                // P
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_P, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_P->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                // Q
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Q, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbQ), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Q->GetDirectPointerToNonObjectElements(), pbX, cbQ);
                pbX += cbQ;

                // G
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_G, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_G->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                // Y
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Y, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Y->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                pseedstruct = (DSSSEED *) pbX;
                if (pseedstruct->counter > 0) {
                    //  seed & counter
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_seed, AllocatePrimitiveArray(ELEMENT_TYPE_U1, 20), _gcr.dsaKey->GetAppDomain());
                    // seed is always 20 bytes
                    memcpyNoGCRefs(_gcr.dsaKey->m_seed->GetDirectPointerToNonObjectElements(), pseedstruct->seed, 20);
                    pbX += 20;

                    //            pdss->DSSSeed.c
                    _gcr.dsaKey->m_counter = pseedstruct->counter;
                    pbX += sizeof(DWORD);
                }
            }
            else {
                int                 cbP, cbQ, cbX;
                DSSPUBKEY *   pdss;
                DSSSEED * pseedstruct;
            
                pdss = (DSSPUBKEY *) (pb + sizeof(BLOBHEADER));
                cbP = (pdss->bitlen+7)/8; //bitlen is size of modulus
                cbQ = 20; // Q is always 20 bytes in length
                pbX = pb + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

                // P
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_P, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_P->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                // Q
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Q, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbQ), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Q->GetDirectPointerToNonObjectElements(), pbX, cbQ);
                pbX += cbQ;

                // G
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_G, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_G->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;

                // X
                cbX = 20; // X must be 20 bytes in length
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_X, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbX), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_X->GetDirectPointerToNonObjectElements(), pbX, cbX);
                pbX += cbX;

                pseedstruct = (DSSSEED *) pbX;
                if (pseedstruct->counter > 0) {
                    //  seed
                    SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_seed, AllocatePrimitiveArray(ELEMENT_TYPE_U1, 20), _gcr.dsaKey->GetAppDomain());
                    memcpyNoGCRefs(_gcr.dsaKey->m_seed->GetDirectPointerToNonObjectElements(), pseedstruct->seed, 20);
                    pbX += 20;
                    //            pdss->DSSSeed.c
                    _gcr.dsaKey->m_counter = pseedstruct->counter;
                    pbX += sizeof(DWORD);
                }

                // Add this sanity check here to avoid reading from the heap
                cbKey = (DWORD)(pbX - pb);
                if (cbKey > cbMalloced) {
                    hr = E_FAIL;
                    goto Exit;
                }

                // OK, we have one more thing to do.  Because old DSS shared the DSSPUBKEY struct for both public and private keys,
                // when we have a private key blob we get X but not Y.  TO get Y, we have to do another export asking for a public key blob

                f = CryptExportKey((HCRYPTKEY)args->hKey, NULL, PUBLICKEYBLOB, dwFlags, NULL, &cb);
                if (!f) {
                    hr = HR_GETLASTERROR;
                    goto Exit;
                }

                if (pb) CRYPT_FREE(pb);
                pb = (LPBYTE) CRYPT_MALLOC(cb);
                if (pb == NULL) {
                    COMPlusThrowOM();
                }
                cbMalloced = cb;
    
                f = CryptExportKey((HCRYPTKEY)args->hKey, NULL, PUBLICKEYBLOB, dwFlags, pb, &cb);
                if (!f) {
                    hr = HR_GETLASTERROR;
                    goto Exit;
                }

                // shik over header, DSSPUBKEY, P, Q and G.  Y is of size cbP
                pbX = pb + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY) + cbP + cbQ + cbP;
                SetObjectReference((OBJECTREF *) &_gcr.dsaKey->m_Y, AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbP), _gcr.dsaKey->GetAppDomain());
                memcpyNoGCRefs(_gcr.dsaKey->m_Y->GetDirectPointerToNonObjectElements(), pbX, cbP);
                pbX += cbP;
            }
        }
        break;

    default:
        hr = E_FAIL;
        goto Exit;
    }

    // Add this sanity check here to avoid reading from the heap
    cbKey = (DWORD)(pbX - pb);
    if (cbKey > cbMalloced) {
        hr = E_FAIL;
        goto Exit;
    }

    hr = S_OK;

Exit:

    GCPROTECT_END();
    if (pb != NULL)             CRYPT_FREE(pb);
    return(hr);

}


//+--------------------------------------------------------------------------
//
//  Member:     _FreeCSP( . . . . )
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __FreeCSP structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A long containing handle of a csp
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

#if defined(FCALLAVAILABLE) && 0

FCIMPL1(VOID, COMCryptography::_FreeCSP, INT_PTR hCSP)
{
    CryptReleaseContext(hCSP, 0);
}
FCIMPLEND

#else // !FCALLAVAILABLE

void __stdcall COMCryptography::_FreeCSP(__FreeCSP *args)
{
    THROWSCOMPLUSEXCEPTION();

    CryptReleaseContext((HCRYPTPROV) args->hCSP, 0);
    return;
}
#endif // FCALLAVAILABLE

void __stdcall COMCryptography::_FreeHKey(__FreeHKey *args)
{
    THROWSCOMPLUSEXCEPTION();

    CryptDestroyKey((HCRYPTKEY) args->hKey);
    return;
}

void __stdcall
COMCryptography::_FreeHash(__FreeHash *args)
{
    THROWSCOMPLUSEXCEPTION();

    CryptDestroyHash((HCRYPTHASH) args->hHash);
    return;
}

int __stdcall
COMCryptography::_DuplicateKey(__DuplicateKey *args)
{
    HRESULT hr = S_OK;
    THROWSCOMPLUSEXCEPTION();

    HCRYPTPROV hNewCSP = 0;
    //hr = CryptDuplicateKey((HCRYPTPROV) args->hCSP, NULL, 0, &hNewCSP);
    *(INT_PTR*) (args->hNewCSP) = hNewCSP;

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     _DeleteKeyContainer
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __DeleteKeyContainer structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A long containing handle of a csp
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

int __stdcall
COMCryptography::_DeleteKeyContainer(__DeleteKeyContainer *args)
{
    THROWSCOMPLUSEXCEPTION();
    

    OBJECTREF           cspParameters;
    DWORD               dwType;
    DWORD               dwCspProviderFlags;
    HRESULT             hr = S_OK;
    OBJECTREF           objref;
    EEClass *           pClass;
    FieldDesc *         pFD;
    LPWSTR              pwsz;
    LPWSTR              pwszProvider = NULL;
    LPWSTR              pwszContainer = NULL;
    STRINGREF           strContainer;
    STRINGREF           strProvider;
    DWORD               dwFlags = 0;
    HCRYPTPROV          hProv;

    CQuickBytes qbProvider;
    CQuickBytes qbContainer;

    // we're deleteing

    dwFlags |= CRYPT_DELETEKEYSET;
    hProv = args->hCSP;

    cspParameters = args->cspParameters;
    pClass = cspParameters->GetClass();
    if (pClass == NULL) {
        _ASSERTE(!"Cannot find class");
        COMPlusThrow(kArgumentNullException, L"Arg_NullReferenceException");
    }

    //
    //  Look for the provider type
    //
    
    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__PROVIDER_TYPE);
    dwType = pFD->GetValue32(cspParameters);

    //
    //  Look for the provider name
    //
    
    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__PROVIDER_NAME);
    objref = pFD->GetRefValue(cspParameters);
    strProvider = ObjectToSTRINGREF(*(StringObject **) &objref);
    pwsz = strProvider->GetBuffer();
    if ((pwsz != NULL) && (*pwsz != 0)) {
        int length = strProvider->GetStringLength();
        pwszProvider = (LPWSTR) qbProvider.Alloc((1+length)*sizeof(WCHAR));
        memcpy (pwszProvider, pwsz, length*sizeof(WCHAR));
        pwszProvider[length] = L'\0';
    }
    
    // look to see if the user specified that we should pass
    // CRYPT_MACHINE_KEYSET to CAPI to use machine key storage instead
    // of user key storage

    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__FLAGS);
    dwCspProviderFlags = pFD->GetValue32(cspParameters);
    if (dwCspProviderFlags & CSP_PROVIDER_FLAGS_USE_MACHINE_KEYSTORE) {
        dwFlags |= CRYPT_MACHINE_KEYSET;
    }

    pFD = g_Mscorlib.GetField(FIELD__CSP_PARAMETERS__KEY_CONTAINER_NAME);
    objref = pFD->GetRefValue(cspParameters);
    strContainer = ObjectToSTRINGREF(*(StringObject **) &objref);
    pwsz = strContainer->GetBuffer();
    if ((pwsz != NULL) && (*pwsz != 0)) {
        int length = strContainer->GetStringLength();
        pwszContainer = (LPWSTR) qbContainer.Alloc((1+length)*sizeof(WCHAR));
        memcpy (pwszContainer, pwsz, length*sizeof(WCHAR));
        pwszContainer[length] = L'\0';
    }

    //
    //  Go ahead and try to open the CSP.  If we fail, make sure the CSP
    //    returned is 0 as that is going to be the error check in the caller.
    //

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!WszCryptAcquireContext(&hProv, pwszContainer, pwszProvider,
                                dwType, dwFlags)){
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     _GenerateKey( . . . . )
//  
//  Synopsis:   Native method for creation of a key in a CSP
//
//  Arguments:  [args] --  A __GenerateKey structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A CSP handle
//                        A Crypto Algorithm ID
//                        A set of flags (top 16-bits == key size)
//
//  Returns:    Handle of generation key
//
//  History:    09/29/99
// 
//---------------------------------------------------------------------------

INT_PTR __stdcall
COMCryptography::_GenerateKey(__GenerateKey * args)
{
    HRESULT             hr = S_OK;
    HCRYPTKEY           hkey = 0;

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptGenKey((HCRYPTPROV)args->hCSP, args->calg, args->dwFlags | CRYPT_EXPORTABLE,
        &hkey)) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        COMPlusThrowCrypto(hr);
    }    

    return (INT_PTR) hkey;
}

//+--------------------------------------------------------------------------
//
//  Member:     _GetBytes( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to get random bytes.
//
//  Arguments:  [args] --  A __GetBytes structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array to return the random data in
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
void __stdcall
COMCryptography::_GetBytes(__GetBytes *args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD       cb = args->data->GetNumComponents();
    HRESULT     hr = S_OK;

    CQuickBytes qb;
    BYTE *buffer = (BYTE *)qb.Alloc(cb*sizeof(unsigned char));

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptGenRandom((HCRYPTPROV)args->hCSP, cb, buffer )) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        COMPlusThrowCrypto(hr);
    }

    unsigned char * ptr = args->data->GetDirectPointerToNonObjectElements();
    memcpyNoGCRefs (ptr, buffer, cb);
    
    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     _GetKeyParameter( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to get key parameters
//
//  Arguments:  [args] --  A __GetKeyParameter structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        The parameter to be retrieved
//                        The key to be queried
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
LPVOID __stdcall
COMCryptography::_GetKeyParameter(__GetKeyParameter *args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb = 0;
    LPBYTE              pb;
    U1ARRAYREF          rgbOut;
    
    //  Find out the size of the data to be returned
    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!CryptGetKeyParam((HCRYPTKEY)args->hKey, args->dwKeyParam, NULL, &cb, 0)) {
        _ASSERTE(!"Bad query key parameter");
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }
    pb = (LPBYTE) CRYPT_MALLOC(cb);
    if (pb == NULL) {
        COMPlusThrowOM();
    }
    if (!CryptGetKeyParam((HCRYPTKEY)args->hKey, args->dwKeyParam, pb, &cb, 0)) {
        _ASSERTE(!"Bad query key parameter");
        CRYPT_FREE(pb);
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }
    END_ENSURE_PREEMPTIVE_GC();

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), pb, cb);
    CRYPT_FREE(pb);
    RETURN (rgbOut, U1ARRAYREF);
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _GetNonZeroBytes( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to get random bytes.
//
//  Arguments:  [args] --  A __GetBytes structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array to return the random data in
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
void __stdcall
COMCryptography::_GetNonZeroBytes(__GetBytes *args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD       cb = args->data->GetNumComponents();
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    DWORD       j;
    LPBYTE      pb = (LPBYTE) CRYPT_MALLOC(cb);
    if (pb == NULL) {
       COMPlusThrowOM();
    }

    Thread *pThread = GetThread();
    _ASSERTE (pThread->PreemptiveGCDisabled());

    while (i < cb) {
        pThread->EnablePreemptiveGC();
        if (!CryptGenRandom((HCRYPTPROV)args->hCSP, cb, pb)) {
            hr = HR_GETLASTERROR;
        }
        pThread->DisablePreemptiveGC();
        if (FAILED(hr)) {
            CRYPT_FREE(pb);
            COMPlusThrowCrypto(hr);
        }

        LPBYTE      pbOut = (LPBYTE) args->data->GetDirectPointerToNonObjectElements();
        for (j=0; (i<cb) && (j<cb); j++) {
            if (pb[j] != 0) {
                pbOut[i++] = pb[j];
            }
        }
    }

    CRYPT_FREE(pb);
    return;
}

void __stdcall
COMCryptography::_HashData(__HashData *args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    LPBYTE      pb = (unsigned char *) args->data->GetDirectPointerToNonObjectElements();
    DWORD       cb = args->cbSize;

    // Do this check here as a sanity check.
    if (args->ibStart < 0 || args->cbSize < 0 || (args->ibStart + cb) < 0 || (args->ibStart + cb) > args->data->GetNumComponents())
        COMPlusThrowCrypto(NTE_BAD_DATA);

    CQuickBytes qb;
    LPBYTE buffer = (LPBYTE)qb.Alloc(cb);
    memcpy (buffer, pb+args->ibStart, cb);

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptHashData((HCRYPTHASH)args->hHash, buffer, cb, 0)) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        COMPlusThrowCrypto(hr);
    }

    return;
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _GetNonZeroBytes( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to get random bytes.
//
//  Arguments:  [args] --  A __GetBytes structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array to return the random data in
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
int __stdcall
COMCryptography::_GetUserKey(__GetUserKey *args)
{
    HCRYPTKEY           hKey = 0;
    HRESULT             hr;

    THROWSCOMPLUSEXCEPTION();

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (CryptGetUserKey((HCRYPTPROV)args->hCSP, args->dwKeySpec, &hKey)) {
        *(INT_PTR*)(args->phKey) = (INT_PTR) hKey;
        hr = S_OK;
    }
    else {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _ImportBulkKey( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to create a new bulk key
//                      with a specific key value and type.
//
//  Arguments:  [args] --  A __GetBytes structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        An optional byte array containing the IV to use
//                        An optional byte array containing the Key to use
//                        The CALG of the algorithm
//                        The CSP to create the key in
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

//
// WARNING: This function side-effects args->hCSP
//

INT_PTR __stdcall
COMCryptography::_ImportBulkKey(__ImportBulkKey * args)
{
    HCRYPTKEY           hKey = 0;
    DWORD   cbKey = args->rgbKey->GetNumComponents();
    BOOL    isNull = (args->rgbKey == NULL);

    //
    //  If we don't have a key, then we just create the key from thin air
    //
    
    CQuickBytes qb;
    LPBYTE buffer = (LPBYTE) qb.Alloc (cbKey * sizeof (BYTE));
    
    LPBYTE  pbKey = (LPBYTE) args->rgbKey->GetDirectPointerToNonObjectElements();
    memcpyNoGCRefs (buffer, pbKey, cbKey);

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (isNull) {
        if (!CryptGenKey((HCRYPTPROV)args->hCSP, args->calg, CRYPT_EXPORTABLE, &hKey)) {
            hKey = 0;
        }
    }
    else {
        if (FAILED(LoadKey(buffer, cbKey, (HCRYPTPROV)args->hCSP, args->calg,
                     CRYPT_EXPORTABLE, &hKey))) {
            hKey = 0;
        }
    }
        
    END_ENSURE_PREEMPTIVE_GC();
        
    return (INT_PTR) hKey;
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _ImportKey( . . . . )
//  
//  Synopsis:   Native method for calling a CSP to create a new bulk key
//                      with a specific key value and type.
//
//  Arguments:  [args] --  A __ImportKey structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A reference to the key
//                        The CALG of the algorithm
//                        The CSP to create the key in
//
//  Returns:    HRESULT code.
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

INT_PTR __stdcall
COMCryptography:: _ImportKey(__ImportKey * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb;
    HRESULT             hr = S_OK;
    BOOL                fPrivate = FALSE;
    DWORD               cbKey = 0;
    DWORD               dwFlags = 0;
    HCRYPTKEY           hKey = 0;
    LPBYTE              pbKey = NULL;
    LPBYTE              pbX;
    KEY_HEADER*         pKeyInfo;
    
    switch (args->calg) {
    case CALG_DSS_SIGN: {
        // first we need to determine if we're running on Win2K, WinME or later, 
        // because the V3 blobs are only supported on W2K or WinME.
        OSVERSIONINFO osvi;
        BOOL bWin2KOrLater;
        BOOL bWinMeOrLater;
        BOOL bWin2KWinMeOrLater;
        
        DWORD                     cbP;
        DWORD                     cbQ;
        DWORD                     cbX = 0;
        DSA_CSP_Object *        dssKey;

        VALIDATEOBJECTREF(args->refKey);
        dssKey = (DSA_CSP_Object*) (Object*) OBJECTREFToObject(args->refKey);

        // Validate the DSA structure first
        // P, Q and G are required. Q is a 160 bit divisor of P-1 and G is an element of Z_p
        if (dssKey->m_P == NULL || dssKey->m_Q == NULL || dssKey->m_Q->GetNumComponents() != 20)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        cbP = dssKey->m_P->GetNumComponents();
        cbQ = dssKey->m_Q->GetNumComponents();
        if (dssKey->m_G == NULL || dssKey->m_G->GetNumComponents() != cbP)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        // If J is present, it should be less than the size of P: J = (P-1) / Q
        // This is only a sanity check. Not doing it here is not really an issue as CAPI will fail.
        if (dssKey->m_J != NULL && dssKey->m_J->GetNumComponents() >= cbP)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        // Y is present for V3 DSA key blobs, Y = g^j mod P
        if (dssKey->m_Y != NULL && dssKey->m_Y->GetNumComponents() != cbP)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        // The seed is allways a 20 byte array
        if (dssKey->m_seed != NULL && dssKey->m_seed->GetNumComponents() != 20)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        // The private key is less than q-1
        if (dssKey->m_X != NULL && dssKey->m_X->GetNumComponents() != 20) 
            COMPlusThrowCrypto(NTE_BAD_DATA);

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!WszGetVersionEx(&osvi)) {
            _ASSERTE(!"GetVersionEx failed");
            COMPlusThrowWin32();            
        }
        
        bWin2KOrLater = ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && ((osvi.dwMajorVersion >= 5)));
        bWinMeOrLater = ((osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && ((osvi.dwMinorVersion >= 90)));
        bWin2KWinMeOrLater = (bWin2KOrLater == TRUE) || (bWinMeOrLater == TRUE);

        if (bWin2KWinMeOrLater) {
            //  Compute size of data to include
            cbKey = 3*cbP + cbQ + sizeof(KEY_HEADER) + sizeof(DSSSEED);
            if (dssKey->m_X != 0) {
                cbX = dssKey->m_X->GetNumComponents();
                cbKey += cbX;
            } 
            if (dssKey->m_J != NULL) {
                cbKey += dssKey->m_J->GetNumComponents();
            }
            pbKey = (LPBYTE) CRYPT_MALLOC(cbKey);
            if (pbKey == NULL) {
                COMPlusThrowOM();
            }
        
            //  Public or Private import?
        
            pKeyInfo = (KEY_HEADER *) pbKey;
            pKeyInfo->blob.bType = PUBLICKEYBLOB;
            pKeyInfo->blob.bVersion = CUR_BLOB_VERSION;
            pKeyInfo->blob.reserved = 0;
            pKeyInfo->blob.aiKeyAlg = args->calg;

            if (cbX != 0) {
                pKeyInfo->blob.bType = PRIVATEKEYBLOB;
                fPrivate = TRUE;
            }

            //
            //  If y is present and this is a private key, or
            //  If y and J are present and this is a public key,
            //      this should be a v3 blob
            //
            //  make the assumption that if the item is present, there are bytes
        
            if (((dssKey->m_Y != NULL) && fPrivate) ||
                ((dssKey->m_Y != NULL) && (dssKey->m_J != NULL))) {
                pKeyInfo->blob.bVersion = 0x3;
            }

            pbX = pbKey + sizeof(pKeyInfo->blob);
            if (pKeyInfo->blob.bVersion == 0x3) {
                if (fPrivate) {
                    pbX += sizeof(pKeyInfo->dss_priv_v3);
                    pKeyInfo->dss_priv_v3.bitlenP = cbP*8;
                    pKeyInfo->dss_priv_v3.bitlenQ = cbQ*8;
                    pKeyInfo->dss_priv_v3.bitlenJ = 0;
                    pKeyInfo->dss_priv_v3.bitlenX = cbX*8;
                    pKeyInfo->dss_priv_v3.magic = DSS_PRIV_MAGIC_VER3;
                }
                else {
                    pbX += sizeof(pKeyInfo->dss_pub_v3);
                    pKeyInfo->dss_pub_v3.bitlenP = cbP*8;
                    pKeyInfo->dss_pub_v3.bitlenQ = cbQ*8;
                    pKeyInfo->dss_priv_v3.bitlenJ = 0;
                    pKeyInfo->dss_priv_v3.magic = DSS_PUB_MAGIC_VER3;
                }
            }
            else {
                if (fPrivate) {
                    pKeyInfo->dss_v2.magic = DSS_PRIVATE_MAGIC;
                }
                else {
                    pKeyInfo->dss_v2.magic = DSS_MAGIC;
                }
                pKeyInfo->dss_v2.bitlen = cbP*8;
                pbX += sizeof(pKeyInfo->dss_v2);
            }

            // P
            memcpy(pbX, dssKey->m_P->GetDirectPointerToNonObjectElements(), cbP);
            pbX += cbP;
        
            // Q
            memcpy(pbX, dssKey->m_Q->GetDirectPointerToNonObjectElements(), cbQ);
            pbX += cbQ;

            // G
            memcpy(pbX, dssKey->m_G->GetDirectPointerToNonObjectElements(), cbP);
            pbX += cbP;

            if (pKeyInfo->blob.bVersion == 0x3) {
                // J -- if present then bVersion == 3;
                if (dssKey->m_J != NULL) {
                    cb = dssKey->m_J->GetNumComponents();
                    pKeyInfo->dss_priv_v3.bitlenJ = cb*8;
                    memcpy(pbX, dssKey->m_J->GetDirectPointerToNonObjectElements(), cb);
                    pbX += cb;
                }
            }

            if (!fPrivate || (pKeyInfo->blob.bVersion == 0x3)) {
                // Y -- if present then bVersion == 3;
                if (dssKey->m_Y != NULL) {
                    memcpy(pbX, dssKey->m_Y->GetDirectPointerToNonObjectElements(), cbP);
                    pbX += cbP;
                }
            }
        
            // X -- if present then private
            if (fPrivate) {
                memcpy(pbX, dssKey->m_X->GetDirectPointerToNonObjectElements(), cbX);
                pbX += cbX;
            }

            if ((dssKey->m_seed == NULL) || (dssKey->m_seed->GetNumComponents() == 0)){
                // No seed present, so set them to zero
                if (pKeyInfo->blob.bVersion == 0x3) {
                    if (fPrivate) {
                        memset(&pKeyInfo->dss_priv_v3.DSSSeed, 0xFFFFFFFF, sizeof(DSSSEED));
                    }
                    else {
                        memset(&pKeyInfo->dss_pub_v3.DSSSeed, 0xFFFFFFFF, sizeof(DSSSEED));
                    }
                }
                else {
                    memset(pbX, 0xFFFFFFFF, sizeof(DSSSEED));
                    pbX += sizeof(DSSSEED);
                }
            } else {
                if (pKeyInfo->blob.bVersion == 0x3) {
                    if (fPrivate) {
                        pKeyInfo->dss_priv_v3.DSSSeed.counter = dssKey->m_counter;
                        memcpy(pKeyInfo->dss_priv_v3.DSSSeed.seed, dssKey->m_seed->GetDirectPointerToNonObjectElements(), 20);
                    } else {
                        pKeyInfo->dss_pub_v3.DSSSeed.counter = dssKey->m_counter;
                        memcpy(pKeyInfo->dss_pub_v3.DSSSeed.seed, dssKey->m_seed->GetDirectPointerToNonObjectElements(), 20);
                    }
                } else {
                    memcpy(pbX,&dssKey->m_counter, sizeof(DWORD));
                    pbX += sizeof(DWORD);
                    // now the seed
                    memcpy(pbX, dssKey->m_seed->GetDirectPointerToNonObjectElements(), 20);
                    pbX += 20;
                }           
            }

            cbKey = (DWORD)(pbX - pbKey);
        } else {
            // must use old blobs
            //  Compute size of data to include
            cbKey = sizeof(KEY_HEADER) + sizeof(DSSSEED) + 2*cbP + 20; // one cbP for P, one for G and 20 bytes for Q
            if (dssKey->m_X != 0) {
                cbX = dssKey->m_X->GetNumComponents();
                cbKey += cbX; // cbX is always 20 bytes
            } else {
                cbKey += cbP; // add cbP bytes for Y
            }
            pbKey = (LPBYTE) CRYPT_MALLOC(cbKey);
            if (pbKey == NULL) {
                COMPlusThrowOM();
            }
        
            //  Public or Private import?
        
            pKeyInfo = (KEY_HEADER *) pbKey;
            pKeyInfo->blob.bType = PUBLICKEYBLOB;
            pKeyInfo->blob.bVersion = CUR_BLOB_VERSION;
            pKeyInfo->blob.reserved = 0;
            pKeyInfo->blob.aiKeyAlg = args->calg;

            if (cbX != 0) {
                pKeyInfo->blob.bType = PRIVATEKEYBLOB;
                fPrivate = TRUE;
            }

            pbX = pbKey + sizeof(pKeyInfo->blob);
            if (fPrivate) {
                pKeyInfo->dss_v2.magic = DSS_PRIVATE_MAGIC;
            }
            else {
                pKeyInfo->dss_v2.magic = DSS_MAGIC;
            }
            pKeyInfo->dss_v2.bitlen = cbP*8;
            cbQ = 20;
            pbX += sizeof(pKeyInfo->dss_v2);

            // P
            memcpy(pbX, dssKey->m_P->GetDirectPointerToNonObjectElements(), cbP);
            pbX += cbP;
        
            // Q
            memcpy(pbX, dssKey->m_Q->GetDirectPointerToNonObjectElements(), cbQ);
            pbX += cbQ;

            // G
            memcpy(pbX, dssKey->m_G->GetDirectPointerToNonObjectElements(), cbP);
            pbX += cbP;

            if (!fPrivate) {
                // Y -- if present then bVersion == 3;
                memcpy(pbX, dssKey->m_Y->GetDirectPointerToNonObjectElements(), cbP);
                pbX += cbP;
            } else {
                // X -- if present then private
                memcpy(pbX, dssKey->m_X->GetDirectPointerToNonObjectElements(), cbX);
                pbX += cbX;
            }

            if ((dssKey->m_seed == NULL) || (dssKey->m_seed->GetNumComponents() == 0)){
                // No seed present, so set them to zero
                memset(pbX, 0xFFFFFFFF, sizeof(DSSSEED));
                pbX += sizeof(DSSSEED);
            } else {
                memcpy(pbX,&dssKey->m_counter, sizeof(DWORD));
                pbX += sizeof(DWORD);
                // now the seed
                memcpy(pbX, dssKey->m_seed->GetDirectPointerToNonObjectElements(), 20);
                pbX += 20;
            }
            cbKey = (DWORD)(pbX - pbKey);
        }
        break;
        }

    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX: {
        RSA_CSP_Object *        rsaKey;
        
        //
        //  Validate the layout and assign the key structure into the local variable
        //      with the correct layout
        //
        
        //      CheckFieldLayout(args->refKey, "d", &gsig_rgb, RSA_CSP_Object, m_d, "RSA_CSP_Object managed class is the wrong size");

        VALIDATEOBJECTREF(args->refKey);

        rsaKey = (RSA_CSP_Object*) (Object*) OBJECTREFToObject(args->refKey);

        // Validate the RSA structure first
        if (rsaKey->m_Modulus == NULL)
            COMPlusThrowCrypto(NTE_BAD_DATA);
        cb = rsaKey->m_Modulus->GetNumComponents();
        DWORD cbHalfModulus = cb/2;
        // We assume that if P != null, then so are Q, DP, DQ, InverseQ and D
        if (rsaKey->m_P != NULL) {
            if (rsaKey->m_P->GetNumComponents() != cbHalfModulus)
                COMPlusThrowCrypto(NTE_BAD_DATA);
            if (rsaKey->m_Q == NULL || rsaKey->m_Q->GetNumComponents() != cbHalfModulus) 
                COMPlusThrowCrypto(NTE_BAD_DATA);
            if (rsaKey->m_dp == NULL || rsaKey->m_dp->GetNumComponents() != cbHalfModulus) 
                COMPlusThrowCrypto(NTE_BAD_DATA);
            if (rsaKey->m_dq == NULL || rsaKey->m_dq->GetNumComponents() != cbHalfModulus) 
                COMPlusThrowCrypto(NTE_BAD_DATA);
            if (rsaKey->m_InverseQ == NULL || rsaKey->m_InverseQ->GetNumComponents() != cbHalfModulus) 
                COMPlusThrowCrypto(NTE_BAD_DATA);
            if (rsaKey->m_d == NULL || rsaKey->m_d->GetNumComponents() != cb) 
                COMPlusThrowCrypto(NTE_BAD_DATA);                
        }

        //  Compute the size of the data to include
        pbKey = (LPBYTE) CRYPT_MALLOC(cb*5 + sizeof(KEY_HEADER));
        if (pbKey == NULL) {
            COMPlusThrowOM();
        }

        //  Public or private import?

        pKeyInfo = (KEY_HEADER *) pbKey;
        pKeyInfo->blob.bType = PUBLICKEYBLOB;   // will change to PRIVATEKEYBLOB if necessary
        pKeyInfo->blob.bVersion = CUR_BLOB_VERSION;
        pKeyInfo->blob.reserved = 0;
        pKeyInfo->blob.aiKeyAlg = args->calg;

        pKeyInfo->rsa.magic = RSA_PUB_MAGIC; // will change to RSA_PRIV_MAGIC below if necesary
        pKeyInfo->rsa.bitlen = cb*8;
        pKeyInfo->rsa.pubexp = rsaKey->m_Exponent;
        pbX = pbKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);

        //  Copy over the modulus -- put in for both public & private

        memcpy(pbX, rsaKey->m_Modulus->GetDirectPointerToNonObjectElements(), cb);
        pbX += cb;

        //
        //  See if we are doing private keys.
        //

        if ((rsaKey->m_P != 0) && (rsaKey->m_P->GetNumComponents() != 0)) {
            pKeyInfo->blob.bType = PRIVATEKEYBLOB;
            pKeyInfo->rsa.magic = RSA_PRIV_MAGIC;
            fPrivate = TRUE;

            // Copy over P
            
            memcpy(pbX, rsaKey->m_P->GetDirectPointerToNonObjectElements(), cbHalfModulus);
            pbX += cbHalfModulus;

            // Copy over Q
            
            memcpy(pbX, rsaKey->m_Q->GetDirectPointerToNonObjectElements(), cbHalfModulus);
            pbX += cbHalfModulus;

            // Copy over dp
            
            memcpy(pbX, rsaKey->m_dp->GetDirectPointerToNonObjectElements(), cbHalfModulus);
            pbX += cbHalfModulus;

            // Copy over dq
            
            memcpy(pbX, rsaKey->m_dq->GetDirectPointerToNonObjectElements(), cbHalfModulus);
            pbX += cbHalfModulus;
            
            // Copy over InvQ
            
            memcpy(pbX, rsaKey->m_InverseQ->GetDirectPointerToNonObjectElements(), cbHalfModulus);
            pbX += cbHalfModulus;

            // Copy over d
            
            memcpy(pbX, rsaKey->m_d->GetDirectPointerToNonObjectElements(), cb);
            pbX += cb;
        }
        cbKey = (DWORD)(pbX - pbKey);
        break;
        }

    default:
        COMPlusThrow(kCryptographicException, IDS_EE_CRYPTO_UNKNOWN_OPERATION);
    }

    if (fPrivate) {
        dwFlags |= CRYPT_EXPORTABLE;
    }

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptImportKey((HCRYPTPROV)args->hCSP, pbKey, cbKey, NULL, dwFlags, &hKey)) {
        hr = HR_GETLASTERROR;
    }

    END_ENSURE_PREEMPTIVE_GC();

    if (pbKey != NULL) {
        CRYPT_FREE(pbKey);
    }

    if (FAILED(hr)) {
        COMPlusThrowCrypto(hr);
    }

    return (INT_PTR) hKey;
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _SetKeyParamDw( . . . . )
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __SetKeyParamDw structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A DWORD containing the value
//                        The parameter to be set (KP_*)
//                        The handle of the key object
//
//  Returns:    void
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
void __stdcall
COMCryptography::_SetKeyParamDw(__SetKeyParamDw * args)
{
    THROWSCOMPLUSEXCEPTION();

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptSetKeyParam((HCRYPTKEY)args->hKey, args->param,
                          (LPBYTE) &args->dwValue, 0)) {
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }

    END_ENSURE_PREEMPTIVE_GC();

    return;
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _SetKeyParamRgb( . . . . )
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __SetKeyParamRgb structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array containing the value
//                        The parameter to be set (KP_*)
//                        The handle of the key object
//
//  Returns:    void
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
void __stdcall
COMCryptography::_SetKeyParamRgb(__SetKeyParamRgb * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD       cb = args->rgb->GetNumComponents();
    LPBYTE      pb = (LPBYTE) args->rgb->GetDirectPointerToNonObjectElements();

    CQuickBytes qb;
    LPBYTE buffer = (LPBYTE) qb.Alloc(cb * sizeof (BYTE));
    memcpyNoGCRefs (buffer, pb, cb*sizeof (BYTE));

    BEGIN_ENSURE_PREEMPTIVE_GC();

    if (!CryptSetKeyParam((HCRYPTKEY)args->hKey, args->param, buffer, 0)) {
        COMPlusThrowCrypto(HR_GETLASTERROR);
    }

    END_ENSURE_PREEMPTIVE_GC();

    return;
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _SignValue( . . . . )
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __SignValue structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array containing the hash
//                        The CALG of the algorithm
//                        The CSP to create the key in
//
//  Returns:    buffer containing the signature
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------
LPVOID __stdcall
COMCryptography::_SignValue(__SignValue * args)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD               cb;
    BOOL                f;
    HRESULT             hr = S_OK;
    HCRYPTHASH          hHash = 0;
    LPBYTE              pb = (LPBYTE) args->rgb->GetDirectPointerToNonObjectElements();
    U1ARRAYREF          rgbSignature = NULL;
    //    WCHAR               rgwch[30];
        
    //
    //  Take the hash value and create a hash object in the correct CSP.
    //
                  
    cb = args->rgb->GetNumComponents();
    CQuickBytes qb;
    LPBYTE buffer = (LPBYTE) qb.Alloc(cb * sizeof(BYTE));
    memcpyNoGCRefs (buffer, pb, cb * sizeof(BYTE));

    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    f = CryptCreateHash((HCRYPTPROV)args->hCSP, args->calg, NULL, 0, &hHash);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    //
    //  Set the hash to the passed in hash value.  Assume that the hash buffer is
    //  long enough -- or it will be protected by advapi.
    //
    
    f = CryptSetHashParam(hHash, HP_HASHVAL, buffer, 0);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    //
    //  Find out how long the signature is going to be
    //

    cb = 0;
    f = CryptSignHashA(hHash, args->dwKeySpec, NULL, args->dwFlags, NULL, &cb);
    if (!f || cb == 0) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    END_ENSURE_PREEMPTIVE_GC();

    //
    // Allocate the buffer to hold the signature
    //

    LPBYTE buffer2 = (LPBYTE) qb.Alloc(cb * sizeof(BYTE));

    BEGIN_ENSURE_PREEMPTIVE_GC();    
    //
    //  Now do the actual signature into the return buffer
    //

    f = CryptSignHashA(hHash, args->dwKeySpec, NULL, 0, buffer2, &cb);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    END_ENSURE_PREEMPTIVE_GC();    

    rgbSignature = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    if (rgbSignature == NULL) {
        goto OOM;
    }
    memcpyNoGCRefs(rgbSignature->GetDirectPointerToNonObjectElements(), buffer, cb * sizeof(BYTE));

    // Note: I'm making the implicit assumption below that
    // CryptDestroyHash never loads a module.

    if (hHash != 0)     CryptDestroyHash(hHash);
    RETURN (rgbSignature, U1ARRAYREF);

CryptError:
    if (hHash != 0)     CryptDestroyHash(hHash);
    COMPlusThrowCrypto(hr);

OOM:
    if (hHash != 0)     CryptDestroyHash(hHash);
    COMPlusThrowOM();
    return NULL; // satisfies "not all control paths returning a value error"
}

//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     _VerifySign( . . . . )
//  
//  Synopsis:   
//
//  Arguments:  [args] --  A __VerifySign structure.
//                     CONTAINS:
//                        A 'this' reference.
//                        A byte array containing the signature to verify
//                        A byte array containing the hash to verify
//                        The CALG of the algorithm
//                        The handle of the key to be used in verifying
//                        The CSP to create the hash in
//
//  Returns:    HRESULT code.
//                      - S_OK - Signature verifies
//                      - S_FALSE - Signature fails verification
//                      - negative - Other error
//
//  History:    09/01/99
// 
//---------------------------------------------------------------------------

int __stdcall
COMCryptography::_VerifySign(__VerifySign * args)
{
    DWORD       cbSignature = args->rgbSignature->GetNumComponents();
    BOOL        f;
    HRESULT     hr = S_OK;
    HCRYPTHASH  hHash = 0;
    LPBYTE      pbHash = (LPBYTE) args->rgbHash->GetDirectPointerToNonObjectElements();
    LPBYTE      pbSignature = (LPBYTE) args->rgbSignature->GetDirectPointerToNonObjectElements();


    //
    //  Take the hash value and create a hash object in the correct CSP.
    //
    
    CQuickBytes qbHash;
    CQuickBytes qbSignature;
    DWORD cbHash = args->rgbHash->GetNumComponents();
    LPBYTE bufferHash = (LPBYTE) qbHash.Alloc(cbHash * sizeof (BYTE));
    memcpyNoGCRefs (bufferHash, pbHash, cbHash*sizeof(BYTE));
    LPBYTE bufferSignature = (LPBYTE) qbSignature.Alloc(cbSignature * sizeof(BYTE));
    memcpyNoGCRefs (bufferSignature, pbSignature, cbSignature * sizeof(BYTE));

    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    f = CryptCreateHash((HCRYPTPROV)args->hCSP, args->calg, NULL, 0, &hHash);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto exit;
    }

    //
    //  Set the hash to the passed in hash value.  Assume that the hash buffer is
    //  long enough -- or it will be protected by advapi.
    //
    
    f = CryptSetHashParam(hHash, HP_HASHVAL, bufferHash, 0);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto exit;
    }

    //
    //  Now see if the signature verifies.  A specific error code is returned if
    //  the signature fails validation -- remap that error a new return code.
    //

    f = CryptVerifySignatureA((HCRYPTPROV) hHash, bufferSignature, cbSignature,
                              (HCRYPTPROV) args->hKey, NULL, args->dwFlags);
    if (!f) {
        hr = HR_GETLASTERROR;
        if (hr == NTE_BAD_SIGNATURE) {
            hr = S_FALSE;
        }
        else if ((hr & 0x80000000) == 0) {
            hr |= 0x80000000;
        }
    }
    else {
        hr = S_OK;
    }

exit:
    if (hHash != 0)             CryptDestroyHash(hHash);

    END_ENSURE_PREEMPTIVE_GC();
    return hr;
}

LPVOID __stdcall 
COMCryptography::_CryptDeriveKey(__CryptDeriveKey * args) {
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    BOOL        f;
    HCRYPTHASH  hHash = 0;
    HCRYPTKEY   hKey = 0;
    U1ARRAYREF  rgbOut;

    LPBYTE      pbPwd = (LPBYTE) args->rgbPwd->GetDirectPointerToNonObjectElements();    
    CQuickBytes qbPwd;
    CQuickBytes qb;
    DWORD cbPwd = args->rgbPwd->GetNumComponents();
    LPBYTE bufferPwd = (LPBYTE) qbPwd.Alloc(cbPwd * sizeof (BYTE));
    memcpyNoGCRefs (bufferPwd, pbPwd, cbPwd*sizeof(BYTE));

    LPBYTE rgbKey = NULL;
    DWORD cb = 0;
    DWORD cbIV = 0;


    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    f = CryptCreateHash((HCRYPTPROV)args->hCSP, args->calgHash, NULL, 0, &hHash);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    // Hash the password string
    f = CryptHashData(hHash, bufferPwd, cbPwd, 0);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    // Create a block cipher session key based on the hash of the password
    f = CryptDeriveKey((HCRYPTPROV)args->hCSP, args->calg, hHash, args->dwFlags | CRYPT_EXPORTABLE, &hKey);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }

    hr = UnloadKey((HCRYPTPROV)args->hCSP, hKey, &rgbKey, &cb);
    if (FAILED(hr)) goto CryptError;

    // Get the length of the IV
    cbIV = 0;
    f = CryptGetKeyParam(hKey, KP_IV, NULL, &cbIV, 0);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }
    
    END_ENSURE_PREEMPTIVE_GC();

    // Now allocate space for the IV vector
    BYTE * pbIV = (BYTE*) CRYPT_MALLOC(cbIV*sizeof(byte));
    if (pbIV == NULL) {
        goto OOM;
    }

    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    f = CryptGetKeyParam(hKey, KP_IV, pbIV, &cbIV, 0);
    if (!f) {
        hr = HR_GETLASTERROR;
        goto CryptError;
    }
        
    END_ENSURE_PREEMPTIVE_GC();

    byte * ptr = args->rgbIV->GetDirectPointerToNonObjectElements();
    // Sanity check to enforce the check in managed side
    if (cbIV > args->rgbIV->GetNumComponents())
        cbIV = args->rgbIV->GetNumComponents();
    memcpyNoGCRefs (ptr, pbIV, cbIV);
    if (pbIV)  CRYPT_FREE(pbIV);

    rgbOut = (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1, cb);
    if (rgbOut == NULL) {
        goto OOM;
    }
    memcpyNoGCRefs(rgbOut->GetDirectPointerToNonObjectElements(), rgbKey, cb * sizeof(BYTE));

    if (hHash != 0) CryptDestroyHash(hHash);
    if (hKey != 0)  CryptDestroyKey(hKey);
    // CRYPT_FREE the key
    CRYPT_FREE(rgbKey);
    RETURN (rgbOut, U1ARRAYREF);

CryptError:
    // CRYPT_FREE the key
    if (rgbKey) CRYPT_FREE(rgbKey);
    if (hHash != 0)  CryptDestroyHash(hHash);
    if (hKey != 0)  CryptDestroyKey(hKey);
    COMPlusThrowCrypto(hr);

OOM:
    // CRYPT_FREE the key
    if (rgbKey) CRYPT_FREE(rgbKey);
    if (hHash != 0)  CryptDestroyHash(hHash);
    if (hKey != 0)  CryptDestroyKey(hKey);
    COMPlusThrowOM();
    return NULL;
}

///////////////////////////////////////////////////

#ifdef SHOULD_WE_CLEANUP
void COMCryptography::Terminate()
{
    int         i;

    for (i=0; i<MAX_CACHE_DEFAULT_PROVIDERS; i++) {
        if (RgpwszDefaultProviders[i] != NULL) {
            CRYPT_FREE(RgpwszDefaultProviders[i]);
            RgpwszDefaultProviders[i] = NULL;
        }
        if (RghprovCache[i] != 0) {
            CryptReleaseContext(RghprovCache[i], 0);
            RghprovCache[i] = 0;
        }
    }
    
    return;
}
#endif /* SHOULD_WE_CLEANUP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comconnectionpoints.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: ComConnectionPoints.h
//
// ===========================================================================
// Implementation of the classes used to expose connection points to COM.
// ===========================================================================

#include "common.h"
#include "ComConnectionPoints.h"
#include "ComCallWrapper.h"


//------------------------------------------------------------------------------------------
//      Implementation of helper class used to expose connection points
//------------------------------------------------------------------------------------------

ConnectionPoint::ConnectionPoint(ComCallWrapper *pWrap, MethodTable *pEventMT)
: m_pOwnerWrap(pWrap)
, m_pTCEProviderMT(ComCallWrapper::GetSimpleWrapper(pWrap)->m_pClass->GetMethodTable())
, m_pEventItfMT(pEventMT)
, m_Lock("Interop", CrstInterop, FALSE, FALSE)
, m_cbRefCount(0)
, m_apEventMethods(NULL)
, m_NumEventMethods(0)
{
    // Retrieve the connection IID.
    pEventMT->GetClass()->GetGuid(&m_rConnectionIID, TRUE);   

    // Set up the event methods.
    SetupEventMethods();
}

ConnectionPoint::~ConnectionPoint()
{
    if (m_apEventMethods)
        delete []m_apEventMethods;
}

HRESULT __stdcall ConnectionPoint::QueryInterface(REFIID riid, void** ppv)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!ppv)
        return E_POINTER;

    if (riid == IID_IConnectionPoint)
    {
        *ppv = static_cast<IConnectionPoint*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else 
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall ConnectionPoint::AddRef()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // The connection point objects share the ComCallWrapper's ref count.
    return ComCallWrapper::AddRef(m_pOwnerWrap);
}

ULONG __stdcall ConnectionPoint::Release()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // The connection point objects share the ComCallWrapper's ref count.
    return ComCallWrapper::Release(m_pOwnerWrap);
}

HRESULT __stdcall ConnectionPoint::GetConnectionInterface(IID *pIID)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!pIID)
        return E_POINTER;

    *pIID = m_rConnectionIID;
    return S_OK;
}

HRESULT __stdcall ConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!ppCPC)
        return E_POINTER;

    // Retrieve the IConnectionPointContainer from the owner wrapper.
    *ppCPC = (IConnectionPointContainer*)
        ComCallWrapper::GetComIPfromWrapper(m_pOwnerWrap, IID_IConnectionPointContainer, NULL, FALSE);
    _ASSERTE(*ppCPC);
    return S_OK;
}

struct Advise_Args {
    ConnectionPoint *pThis;
    IUnknown *pUnk;
    DWORD *pdwCookie;
    HRESULT *hr;
};

void Advise_Wrapper(Advise_Args *pArgs)
{
    *(pArgs->hr) = pArgs->pThis->Advise(pArgs->pUnk, pArgs->pdwCookie);
}

HRESULT __stdcall ConnectionPoint::Advise(IUnknown *pUnk, DWORD *pdwCookie)
{
    ULONG cbRef;
    HRESULT hr = S_OK;
    IUnknown *pEventItf = NULL;

    if (!pUnk || !pdwCookie)
        return E_POINTER;    

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL) 
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Make sure we have a pointer to the interface and not to another IUnknown.
    hr = SafeQueryInterface(pUnk, m_rConnectionIID, &pEventItf );
    LogInteropQI(pUnk, m_rConnectionIID, hr, "ICP:Advise");

    if (FAILED(hr) || !pEventItf) 
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        if (m_pOwnerWrap->NeedToSwitchDomains(pThread, TRUE))
        {
            // call ourselves again through DoCallBack with a domain transition
            Advise_Args args = {this, pUnk, pdwCookie, &hr};
            pThread->DoADCallBack(m_pOwnerWrap->GetObjectContext(pThread), Advise_Wrapper, &args);
        }
        else
        {
            COMOBJECTREF pEventItfObj = NULL;
            OBJECTREF pTCEProviderObj = NULL;

            GCPROTECT_BEGIN(pEventItfObj)
            GCPROTECT_BEGIN(pTCEProviderObj)
            {
                // Create a COM+ object ref to wrap the event interface.               
                pEventItfObj = (COMOBJECTREF)GetObjectRefFromComIP(pUnk, NULL);
                IfNullThrow(pEventItfObj);

                // Get the TCE provider COM+ object from the wrapper
                pTCEProviderObj = m_pOwnerWrap->GetObjectRef();

                for (int cEventMethod = 0; cEventMethod < m_NumEventMethods; cEventMethod++)
                {
                    // If the managed object supports the event that call the AddEventX method.
                    if (m_apEventMethods[cEventMethod].m_pEventMethod)
                    {
                        InvokeProviderMethod( pTCEProviderObj, (OBJECTREF) pEventItfObj, m_apEventMethods[cEventMethod].m_pAddMethod, m_apEventMethods[cEventMethod].m_pEventMethod );
                    }
                }

                // Allocate the object handle and the connection cookie.
                OBJECTHANDLE phndEventItfObj = GetAppDomain()->CreateHandle((OBJECTREF)pEventItfObj);
                ConnectionCookie* pConCookie = ConnectionCookie::CreateConnectionCookie(phndEventItfObj);

                // Add the connection cookie to the list.
                EnterLock();
                m_ConnectionList.InsertHead(pConCookie);
                LeaveLock();

                // Everything went ok so hand back the cookie.
                *pdwCookie = (DWORD)(size_t)pConCookie; // @TODO WIN64 - pointer truncation
            }
            GCPROTECT_END();
            GCPROTECT_END();
        }
    }
    COMPLUS_CATCH
    {
        *pdwCookie = 0;
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    // Release the event interface now that we either failed the Advise call or
    // have an OBJECTREF that holds on to it.
    cbRef = SafeRelease( pEventItf );
    LogInteropRelease(pEventItf, cbRef, "Event::Advise");

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

struct Unadvise_Args {
    ConnectionPoint *pThis;
    DWORD dwCookie;
    HRESULT *hr;
};

void Unadvise_Wrapper(Unadvise_Args *pArgs)
{
    *(pArgs->hr) = pArgs->pThis->Unadvise(pArgs->dwCookie);
}

HRESULT __stdcall ConnectionPoint::Unadvise(DWORD dwCookie)
{
    HRESULT hr = S_OK;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        if (m_pOwnerWrap->NeedToSwitchDomains(pThread, TRUE))
        {
            // call ourselves again through DoCallBack with a domain transition
            Unadvise_Args args = {this, dwCookie, &hr};
            pThread->DoADCallBack(m_pOwnerWrap->GetObjectContext(pThread), Unadvise_Wrapper, &args);
        }
        else
        {
            COMOBJECTREF pEventItfObj = NULL;
            OBJECTREF pTCEProviderObj = NULL;

            GCPROTECT_BEGIN(pEventItfObj)
            GCPROTECT_BEGIN(pTCEProviderObj)
            {
                // The cookie is actually a connection cookie.
                ConnectionCookie *pConCookie = (ConnectionCookie*)(size_t) dwCookie; // @TODO WIN64 - conversion from 'DWORD' to 'ConnectionCookie*' of greater size

                // Retrieve the COM+ object from the cookie which in fact is the object handle.
                pEventItfObj = (COMOBJECTREF) ObjectFromHandle(pConCookie->m_hndEventProvObj); 
                if (!pEventItfObj)
                    COMPlusThrowHR(E_INVALIDARG);

                // Get the object from the wrapper
                pTCEProviderObj = m_pOwnerWrap->GetObjectRef();

                for (int cEventMethod = 0; cEventMethod < m_NumEventMethods; cEventMethod++)
                {
                    // If the managed object supports the event that call the RemoveEventX method.
                    if (m_apEventMethods[cEventMethod].m_pEventMethod)
                    {
                        InvokeProviderMethod(pTCEProviderObj, (OBJECTREF) pEventItfObj, m_apEventMethods[cEventMethod].m_pRemoveMethod, m_apEventMethods[cEventMethod].m_pEventMethod);
                    }
                }

                // Remove the connection cookie from the list.
                EnterLock();
                m_ConnectionList.FindAndRemove(pConCookie);
                LeaveLock();

                // Delete the connection cookie.
                delete pConCookie;
            }
            GCPROTECT_END();
            GCPROTECT_END();
        }
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return hr;
}

HRESULT __stdcall ConnectionPoint::EnumConnections(IEnumConnections **ppEnum)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!ppEnum)
        return E_POINTER;

    ConnectionEnum *pConEnum = new(nothrow) ConnectionEnum(this);
    if (!pConEnum)
        return E_OUTOFMEMORY;
    
    // Retrieve the IEnumConnections interface. This cannot fail.
    HRESULT hr = pConEnum->QueryInterface(IID_IEnumConnections, (void**)ppEnum);
    _ASSERTE(hr == S_OK);

    return hr;
}

void ConnectionPoint::EnterLock()
{
    BEGIN_ENSURE_PREEMPTIVE_GC();
    m_Lock.Enter();
    END_ENSURE_PREEMPTIVE_GC();
}

void ConnectionPoint::LeaveLock()
{
    m_Lock.Leave();
}

void ConnectionPoint::SetupEventMethods()
{
    THROWSCOMPLUSEXCEPTION();

    // Remember the number of not supported events.
    int cNonSupportedEvents = 0;

    // Retrieve the total number of event methods present on the source interface.
    int cMaxNumEventMethods = m_pEventItfMT->GetTotalSlots();

    // If there are no methods then there is nothing to do.
    if (cMaxNumEventMethods == 0)
        return;

    // Allocate the event method tables.
    m_apEventMethods = new(throws) EventMethodInfo[cMaxNumEventMethods];

    // Find all the real event methods needed to be able to advise on the current connection point.
    m_NumEventMethods = 0;
    for (int cEventMethod = 0; cEventMethod < cMaxNumEventMethods; cEventMethod++)
    {
        // Retrieve the method descriptor for the current method on the event interface.
        MethodDesc *pEventMethodDesc = m_pEventItfMT->m_pEEClass->GetUnknownMethodDescForSlot(cEventMethod);
        if (!pEventMethodDesc)
            continue;

        // Store the event method on the source interface.
        m_apEventMethods[m_NumEventMethods].m_pEventMethod = pEventMethodDesc;

        // Retrieve and store the add and remove methods for the event.
        m_apEventMethods[m_NumEventMethods].m_pAddMethod = FindProviderMethodDesc(pEventMethodDesc,EventAdd );
        m_apEventMethods[m_NumEventMethods].m_pRemoveMethod = FindProviderMethodDesc(pEventMethodDesc,EventRemove );

        // Make sure we have found both the add and the remove methods.
        if (!m_apEventMethods[m_NumEventMethods].m_pAddMethod || !m_apEventMethods[m_NumEventMethods].m_pRemoveMethod)
        {
            cNonSupportedEvents++;
            continue;
        }

        // Increment the real number of event methods on the source interface.
        m_NumEventMethods++;
    }

    // If the interface has methods and the object does not support any then we 
    // fail the connection.
    if ((m_NumEventMethods == 0) && (cNonSupportedEvents > 0))
        COMPlusThrowHR(CONNECT_E_NOCONNECTION);
}

MethodDesc *ConnectionPoint::FindProviderMethodDesc( MethodDesc *pEventMethodDesc, EnumEventMethods Method )
{
    _ASSERTE(Method == EventAdd || Method == EventRemove);
    _ASSERTE(pEventMethodDesc);

    // Retrieve the event method.
    MethodDesc *pProvMethodDesc = 
        m_pTCEProviderMT->GetClass()->FindEventMethod(pEventMethodDesc->GetName(), Method, FALSE);
    if (!pProvMethodDesc)
        return NULL;

    // Validate that the signature of the delegate is the expected signature.
    MetaSig Sig(pProvMethodDesc->GetSig(), pProvMethodDesc->GetModule());
    if (Sig.NextArg() != ELEMENT_TYPE_CLASS)
        return NULL;

    TypeHandle DelegateType = Sig.GetTypeHandle();
    if (DelegateType.IsNull())
        return NULL;

    PCCOR_SIGNATURE pEventMethSig;
    DWORD cEventMethSig;
    pEventMethodDesc->GetSig(&pEventMethSig, &cEventMethSig);
    MethodDesc *pInvokeMD = DelegateType.GetClass()->FindMethod(
        "Invoke", 
        pEventMethSig, 
        cEventMethSig, 
        pEventMethodDesc->GetModule(),
        mdTokenNil);
    if (!pInvokeMD)
        return NULL;

    // The requested method exists and has the appropriate signature.
    return pProvMethodDesc;
}

void ConnectionPoint::InvokeProviderMethod( OBJECTREF pProvider, OBJECTREF pSubscriber, MethodDesc *pProvMethodDesc, MethodDesc *pEventMethodDesc )
{
    THROWSCOMPLUSEXCEPTION();    // AllocateObject throws.

    GCPROTECT_BEGIN (pSubscriber);
    GCPROTECT_BEGIN (pProvider);

    // Create a method signature to extract the type of the delegate.
    MetaSig MethodSig( pProvMethodDesc->GetSig(), pProvMethodDesc->GetModule() );
    _ASSERTE( 1 == MethodSig.NumFixedArgs() );

    // Go to the first argument.
    CorElementType ArgType = MethodSig.NextArg();
    _ASSERTE( ELEMENT_TYPE_CLASS == ArgType );

    // Retrieve the EE class representing the argument.
    EEClass *pDelegateCls = MethodSig.GetTypeHandle().GetClass();

    // Allocate an object based on the method table of the delegate class.
    OBJECTREF pDelegate = AllocateObject( pDelegateCls->GetMethodTable() );
    GCPROTECT_BEGIN( pDelegate );

    // Fill in the structure passed to DelegateConstruct.
    COMDelegate::_DelegateConstructArgs ConstructArgs;
    ConstructArgs.refThis = (REFLECTBASEREF) pDelegate;
    GCPROTECT_BEGIN (ConstructArgs.refThis);

    // GetUnsafeAddrofCode is OK here because the method will always be on an
    // RCW which are agile.
    ConstructArgs.method = (SLOT)pEventMethodDesc->GetUnsafeAddrofCode();
    ConstructArgs.target = pSubscriber;

    // Initialize the delegate using the arguments structure.
    COMDelegate::DelegateConstruct( &ConstructArgs );
    GCPROTECT_END ();

    // Do the actual invocation of the method method.
    INT64 Args[2] = { ObjToInt64( pProvider ), ObjToInt64( pDelegate ) };
    pProvMethodDesc->Call( Args );

    GCPROTECT_END();
    GCPROTECT_END ();
    GCPROTECT_END ();
}

ConnectionPointEnum::ConnectionPointEnum(ComCallWrapper *pOwnerWrap, CQuickArray<ConnectionPoint*> *pCPList)
: m_pOwnerWrap(pOwnerWrap)
, m_pCPList(pCPList)
, m_CurrPos(0)
, m_cbRefCount(0)
{
    ComCallWrapper::AddRef(m_pOwnerWrap);
}

ConnectionPointEnum::~ConnectionPointEnum()
{
    if (m_pOwnerWrap)
        ComCallWrapper::Release( m_pOwnerWrap );
}

HRESULT __stdcall ConnectionPointEnum::QueryInterface(REFIID riid, void** ppv)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!ppv)
        return E_POINTER;

    if (riid == IID_IEnumConnectionPoints)
    {
        *ppv = static_cast<IEnumConnectionPoints*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else 
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall ConnectionPointEnum::AddRef()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LONG i = FastInterlockIncrement((LONG*)&m_cbRefCount );
    return i;
}

ULONG __stdcall ConnectionPointEnum::Release()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LONG i = FastInterlockDecrement((LONG*)&m_cbRefCount );
    _ASSERTE(i >=0);
    if (i == 0)
    {
        delete this;
    }
    return i;
}

HRESULT __stdcall ConnectionPointEnum::Next(ULONG cConnections, IConnectionPoint **ppCP, ULONG *pcFetched)
{
    UINT cFetched;

    for (cFetched = 0; cFetched < cConnections && m_CurrPos < m_pCPList->Size(); cFetched++, m_CurrPos++)
    {
        ppCP[cFetched] = (*m_pCPList)[m_CurrPos];
        ppCP[cFetched]->AddRef();
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return cFetched == cConnections ? S_OK : S_FALSE;
}

HRESULT __stdcall ConnectionPointEnum::Skip(ULONG cConnections)
{
    if(m_CurrPos + cConnections <= m_pCPList->Size())
    {
        // There are enough connection points left in the list to allow
        // us to skip the required number.
        m_CurrPos += cConnections;
        return S_OK;
    }
    else
    {
        // There aren't enough connection points left so set the current
        // position to the end of the list and return S_FALSE to indicate
        // we couldn't skip the requested number.
        m_CurrPos = (UINT)m_pCPList->Size();
        return S_FALSE;
    }
}

HRESULT __stdcall ConnectionPointEnum::Reset()
{
    m_CurrPos = 0;
    return S_OK;
}

HRESULT __stdcall ConnectionPointEnum::Clone(IEnumConnectionPoints **ppEnum)
{
    ConnectionPointEnum *pCPEnum = new(nothrow) ConnectionPointEnum(m_pOwnerWrap, m_pCPList);
    if (!pCPEnum)
        return E_OUTOFMEMORY;

    return pCPEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
}

ConnectionEnum::ConnectionEnum(ConnectionPoint *pConnectionPoint)
: m_pConnectionPoint(pConnectionPoint)
, m_CurrCookie(pConnectionPoint->GetCookieList()->GetHead())
, m_cbRefCount(0)
{
    m_pConnectionPoint->AddRef();
}

ConnectionEnum::~ConnectionEnum()
{
    if (m_pConnectionPoint)
        m_pConnectionPoint->Release();
}

HRESULT __stdcall ConnectionEnum::QueryInterface(REFIID riid, void** ppv)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (!ppv)
        return E_POINTER;

    if (riid == IID_IEnumConnections)
    {
        *ppv = static_cast<IEnumConnections*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else 
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall ConnectionEnum::AddRef()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LONG i = FastInterlockIncrement((LONG*)&m_cbRefCount);
    return i;
}

ULONG __stdcall ConnectionEnum::Release()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LONG i = FastInterlockDecrement((LONG*)&m_cbRefCount);
    _ASSERTE(i >=0);
    if (i == 0)
    {
        delete this;
    }
    return i;
}

HRESULT __stdcall ConnectionEnum::Next(ULONG cConnections, CONNECTDATA* rgcd, ULONG *pcFetched)
{
    HRESULT hr = S_FALSE;
    UINT cFetched;
    CONNECTIONCOOKIELIST *pConnectionList = m_pConnectionPoint->GetCookieList();

    // Set up a managed thread object.
    Thread *pThread = SetupThread();
    _ASSERTE(pThread);

    // Acquire the connection point's lock before we start traversing the connection list.
    m_pConnectionPoint->EnterLock();    

    // Switch to cooperative GC mode before we manipulate OBJCETREF's.
    pThread->DisablePreemptiveGC();

    for (cFetched = 0; cFetched < cConnections && m_CurrCookie; cFetched++)
    {
        rgcd[cFetched].dwCookie = (DWORD)(size_t)m_CurrCookie;
        rgcd[cFetched].pUnk = GetComIPFromObjectRef((OBJECTREF*)m_CurrCookie->m_hndEventProvObj, ComIpType_Unknown, NULL);
    }    

    // Switch back to preemptive GC before we go back out to COM.
    pThread->EnablePreemptiveGC();

    // Leave the lock now that we are done traversing the list.
    m_pConnectionPoint->LeaveLock();

    // Set the count of fetched connections if the caller desires it.
    if (pcFetched)
        *pcFetched = cFetched;

    return cFetched == cConnections ? S_OK : S_FALSE;
}

HRESULT __stdcall ConnectionEnum::Skip(ULONG cConnections)
{
    HRESULT hr = S_FALSE;
    CONNECTIONCOOKIELIST *pConnectionList = m_pConnectionPoint->GetCookieList();

    // Acquire the connection point's lock before we start traversing the connection list.
    m_pConnectionPoint->EnterLock();    

    // Try and skip the requested number of connections.
    while (m_CurrCookie && cConnections)
    {
        m_CurrCookie = pConnectionList->GetNext(m_CurrCookie);
        cConnections--;
    }

    // Leave the lock now that we are done traversing the list.
    m_pConnectionPoint->LeaveLock();

    // Check to see if we succeeded.
    return cConnections == 0 ? S_OK : S_FALSE;
}

HRESULT __stdcall ConnectionEnum::Reset()
{
    // Set the current cookie back to the head of the list. We must acquire the
    // connection point lock before we touch the list.
    m_pConnectionPoint->EnterLock();    
    m_CurrCookie = m_pConnectionPoint->GetCookieList()->GetHead();
    m_pConnectionPoint->LeaveLock();

    return S_OK;
}

HRESULT __stdcall ConnectionEnum::Clone(IEnumConnections **ppEnum)
{
    ConnectionEnum *pConEnum = new(nothrow) ConnectionEnum(m_pConnectionPoint);
    if (!pConEnum)
        return E_OUTOFMEMORY;

    return pConEnum->QueryInterface(IID_IEnumConnections, (void**)ppEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcodeaccesssecurityengine.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMCodeAccessSecurityEngine.cpp
**
** Author: Paul Kromann (paulkr)
**
** Purpose:
**
** Date:  March 21, 1998
**
===========================================================*/
#include "common.h"

#include "object.h"
#include "excep.h"
#include "vars.hpp"
#include "COMCodeAccessSecurityEngine.h"
#include "COMSecurityRuntime.h"
#include "security.h"
#include "gcscan.h"
#include "PerfCounters.h"
#include "AppDomainHelper.h"
#include "field.h"
#include "EEConfig.h"

COUNTER_ONLY(PERF_COUNTER_TIMER_PRECISION g_TotalTimeInSecurityRuntimeChecks = 0);
COUNTER_ONLY(PERF_COUNTER_TIMER_PRECISION g_LastTimeInSecurityRuntimeChecks = 0);
COUNTER_ONLY(UINT32 g_SecurityChecksIterations=0);

typedef void (*PfnCheckGrants)(OBJECTREF, OBJECTREF, VOID *, AppDomain *);
typedef BOOL (*PfnCheckFrameData)(OBJECTREF, VOID *, AppDomain *);
typedef BOOL (*PfnCheckThread)(OBJECTREF, VOID *, AppDomain *);

typedef struct _CheckWalkHeader
{
    SecWalkPrologData   prologData            ;
    Assembly *          pPrevAssembly         ;
    AppDomain *         pPrevAppDomain        ;
    PfnCheckGrants      pfnCheckGrants        ;
    PfnCheckFrameData   pfnCheckFrameData     ;
    PfnCheckThread      pfnCheckThread        ;
    BOOL                bUnrestrictedOverride ;
} CheckWalkHeader;

//-----------------------------------------------------------
// Stack walk callback data structure.
//-----------------------------------------------------------
typedef struct _CasCheckWalkData
{
    CheckWalkHeader header;
    MarshalCache    objects;
} CasCheckWalkData;

//-----------------------------------------------------------
// Stack walk callback data structures for checking sets.
//-----------------------------------------------------------
typedef struct _CheckSetWalkData
{
    CheckWalkHeader header;
    MarshalCache    objects;
} CheckSetWalkData;

//-----------------------------------------------------------
// Stack walk callback data structure. (Special Case - CheckImmediate and return SO)
//-----------------------------------------------------------
typedef struct _CasCheckNReturnSOWalkData
{
    CheckWalkHeader header;
    MarshalCache    objects;
    MethodDesc*     pFunction;
    OBJECTREF*      pSecurityObject;
    AppDomain*      pSecurityObjectDomain;
} CasCheckNReturnSOWalkData;


//-----------------------------------------------------------+
// Helper used to check a demand set against a provided grant
// and possibly denied set. Grant and denied set might be from
// another domain.
//-----------------------------------------------------------+
void COMCodeAccessSecurityEngine::CheckSetHelper(OBJECTREF *prefDemand,
                                                 OBJECTREF *prefGrant,
                                                 OBJECTREF *prefDenied,
                                                 AppDomain *pGrantDomain)
{
    COMCodeAccessSecurityEngine::InitSEData();

    // We might need to marshal the grant and denied sets into the current
    // domain.
    if (pGrantDomain != GetAppDomain())
    {
        *prefGrant = AppDomainHelper::CrossContextCopyFrom(pGrantDomain, prefGrant);
        if (*prefDenied != NULL)
            *prefDenied = AppDomainHelper::CrossContextCopyFrom(pGrantDomain, prefDenied);
    }

    INT64 args[] = {
        ObjToInt64(*prefDemand),
        ObjToInt64(*prefDenied),
        ObjToInt64(*prefGrant)
    };
    
    s_seData.pMethCheckSetHelper->Call(args, METHOD__SECURITY_ENGINE__CHECK_SET_HELPER);
}


//-----------------------------------------------------------+
// C H E C K   P E R M I S S I O N
//-----------------------------------------------------------+

static
void CheckGrants(OBJECTREF refGrants, OBJECTREF refDenied, VOID* pData, AppDomain *pDomain)
{
    CasCheckWalkData *pCBdata = (CasCheckWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    struct _gc {
        OBJECTREF orGranted;
        OBJECTREF orDenied;
        OBJECTREF orDemand;
        OBJECTREF orToken;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orGranted = refGrants;
    gc.orDenied = refDenied;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObjects(pDomain, &gc.orToken);

    INT64 helperArgs[4];

    helperArgs[3] = ObjToInt64(gc.orGranted);
    helperArgs[2] = ObjToInt64(gc.orDenied);
    helperArgs[1] = ObjToInt64(gc.orDemand);
    helperArgs[0] = ObjToInt64(gc.orToken);

    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    BOOL inProgress = pThread->IsSecurityStackwalkInProgess();

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress(FALSE);

    COMCodeAccessSecurityEngine::s_seData.pMethCheckHelper->Call(&(helperArgs[0]), 
                                                                 METHOD__SECURITY_ENGINE__CHECK_HELPER);

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress(TRUE);

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();
}

static 
void CheckSetAgainstGrants(OBJECTREF refGrants, OBJECTREF refDenied, VOID* pData, AppDomain *pDomain)
{
    CheckSetWalkData *pCBdata = (CheckSetWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    struct _gc {
        OBJECTREF orGranted;
        OBJECTREF orDenied;
        OBJECTREF orDemand;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orGranted = refGrants;
    gc.orDenied = refDenied;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObject(pDomain);

    INT64 helperArgs[3];
    helperArgs[2] = ObjToInt64(gc.orGranted);
    helperArgs[1] = ObjToInt64(gc.orDenied);
    helperArgs[0] = ObjToInt64(gc.orDemand);
    
    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    BOOL inProgress = pThread->IsSecurityStackwalkInProgess();

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( FALSE );

    COMCodeAccessSecurityEngine::s_seData.pMethCheckSetHelper->Call(&(helperArgs[0]),
                                                                    METHOD__SECURITY_ENGINE__CHECK_SET_HELPER);

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( TRUE );

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();
}


static
void GetZoneAndOriginGrants(OBJECTREF refGrants, OBJECTREF refDenied, VOID* pData, AppDomain *pDomain)
{
    CasCheckWalkData *pCBdata = (CasCheckWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    struct _gc {
        OBJECTREF orGranted;
        OBJECTREF orDenied;
        OBJECTREF orZoneList;
        OBJECTREF orOriginList;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orGranted = refGrants;
    gc.orDenied = refDenied;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orZoneList = pCBdata->objects.GetObjects(pDomain, &gc.orOriginList);

    INT64 helperArgs[4];

    helperArgs[3] = ObjToInt64(gc.orGranted);
    helperArgs[2] = ObjToInt64(gc.orDenied);
    helperArgs[1] = ObjToInt64(gc.orZoneList);
    helperArgs[0] = ObjToInt64(gc.orOriginList);

    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    BOOL inProgress = pThread->IsSecurityStackwalkInProgess();

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress(FALSE);

    MethodDesc *pDemand = g_Mscorlib.GetMethod( METHOD__SECURITY_ENGINE__GET_ZONE_AND_ORIGIN_HELPER );
    _ASSERTE( pDemand != NULL && "Method above is expected to exist in mscorlib" );

    pDemand->Call(&(helperArgs[0]), METHOD__SECURITY_ENGINE__GET_ZONE_AND_ORIGIN_HELPER);

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress(TRUE);

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();
}


static
BOOL CheckFrameData(OBJECTREF refFrameData, VOID* pData, AppDomain *pDomain)
{
    CasCheckWalkData *pCBdata = (CasCheckWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    INT32 ret;

    struct _gc {
        OBJECTREF orFrameData;
        OBJECTREF orDemand;
        OBJECTREF orToken;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orFrameData = refFrameData;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObjects(pDomain, &gc.orToken);

    INT64 helperArgs[3];

    // Collect all the info in an argument array and pass off the logic
    // to an interpreted helper.
    helperArgs[2] = ObjToInt64(gc.orFrameData);
    helperArgs[1] = ObjToInt64(gc.orDemand);
    helperArgs[0] = ObjToInt64(gc.orToken);
    
    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    ret = (INT32)COMCodeAccessSecurityEngine::s_seData.pMethFrameDescHelper->Call(&(helperArgs[0]),
                                                                                  METHOD__SECURITY_RUNTIME__FRAME_DESC_HELPER);

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();

    return (ret != 0);
}

static
BOOL CheckSetAgainstFrameData(OBJECTREF refFrameData, VOID* pData, AppDomain *pDomain)
{
    CheckSetWalkData *pCBdata = (CheckSetWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    INT32 ret;

    struct _gc {
        OBJECTREF orFrameData;
        OBJECTREF orDemand;
        OBJECTREF orPermSetOut;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orFrameData = refFrameData;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObject(pDomain);

    INT64 helperArgs[3];

    // Collect all the info in an argument array and pass off the logic
    // to an interpreted helper.
    helperArgs[2] = ObjToInt64(gc.orFrameData);
    helperArgs[1] = ObjToInt64(gc.orDemand);
    helperArgs[0] = (INT64) &gc.orPermSetOut;
    
    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    ret = (INT32)COMCodeAccessSecurityEngine::s_seData.pMethFrameDescSetHelper->Call(&(helperArgs[0]),
                                                                                     METHOD__SECURITY_RUNTIME__FRAME_DESC_SET_HELPER);

    if (gc.orPermSetOut != NULL) {
        // Update the cached object.
        pCBdata->objects.UpdateObject(pDomain, gc.orPermSetOut);
    }

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();

    return (ret != 0);
}

static
BOOL CheckThread(OBJECTREF refSecurityStack, VOID *pData, AppDomain *pDomain)
{
    CasCheckWalkData *pCBdata = (CasCheckWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    INT32 ret;

    struct _gc {
        OBJECTREF orStack;
        OBJECTREF orDemand;
        OBJECTREF orToken;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orStack = refSecurityStack;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObjects(pDomain, &gc.orToken);

    MethodDesc *pDemand;
    if (gc.orToken == NULL)
        pDemand = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CHECK_DEMAND);
    else
        pDemand = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CHECK_DEMAND_TOKEN);

    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    BOOL inProgress = pThread->IsSecurityStackwalkInProgess();

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( FALSE );

    INT64 ilargs[3];
    if (gc.orToken == NULL)
    {
        ilargs[0] = ObjToInt64(gc.orStack);
        ilargs[1] = ObjToInt64(gc.orDemand);
        ret = (INT32)pDemand->Call(ilargs, METHOD__PERMISSION_LIST_SET__CHECK_DEMAND);
    }
    else
    {
        ilargs[0] = ObjToInt64(gc.orStack);
        ilargs[2] = ObjToInt64(gc.orDemand);
        ilargs[1] = ObjToInt64(gc.orToken);
        ret = (INT32)pDemand->Call(ilargs, METHOD__PERMISSION_LIST_SET__CHECK_DEMAND_TOKEN);
    }

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( TRUE );

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();

    return (ret != 0);
}

static
BOOL CheckSetAgainstThread(OBJECTREF refSecurityStack, VOID *pData, AppDomain *pDomain)
{
    CheckSetWalkData *pCBdata = (CheckSetWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    INT32 ret;

    struct _gc {
        OBJECTREF orStack;
        OBJECTREF orDemand;
        OBJECTREF orPermSetOut;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orStack = refSecurityStack;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orDemand = pCBdata->objects.GetObject(pDomain);

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CHECK_SET_DEMAND);

    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    INT64 ilargs[3];
    ilargs[0] = ObjToInt64(gc.orStack);
    ilargs[2] = ObjToInt64(gc.orDemand);
    ilargs[1] = (INT64)&gc.orPermSetOut;
    ret = (INT32)pMD->Call(ilargs, METHOD__PERMISSION_LIST_SET__CHECK_SET_DEMAND);

    if (gc.orPermSetOut != NULL) {
        // Update the cached object.
        pCBdata->objects.UpdateObject(pDomain, gc.orPermSetOut);
    }

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();
    
    return (ret != 0);
}


static
BOOL GetZoneAndOriginThread(OBJECTREF refSecurityStack, VOID *pData, AppDomain *pDomain)
{
    CasCheckWalkData *pCBdata = (CasCheckWalkData*)pData;

    Thread *pThread = GetThread();
    AppDomain *pCurDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    struct _gc {
        OBJECTREF orStack;
        OBJECTREF orZoneList;
        OBJECTREF orOriginList;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.orStack = refSecurityStack;

    GCPROTECT_BEGIN(gc);

    // Fetch input objects that might originate from a different appdomain,
    // marshalling if necessary.
    gc.orZoneList = pCBdata->objects.GetObjects(pDomain, &gc.orOriginList);

    MethodDesc *pDemand = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__GET_ZONE_AND_ORIGIN);
    _ASSERTE( pDemand != NULL && "Method above is expected to exist in mscorlib." );

    // Switch into the destination context if necessary.
    if (pCurDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    BOOL inProgress = pThread->IsSecurityStackwalkInProgess();

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( FALSE );

    INT64 ilargs[3];
    ilargs[0] = ObjToInt64(gc.orStack);
    ilargs[1] = ObjToInt64(gc.orOriginList);
    ilargs[2] = ObjToInt64(gc.orZoneList);
    pDemand->Call(ilargs, METHOD__PERMISSION_LIST_SET__GET_ZONE_AND_ORIGIN);

    if (inProgress)
        pThread->SetSecurityStackwalkInProgress( TRUE );

    if (pCurDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    GCPROTECT_END();

    return TRUE;
}



//-----------------------------------------------------------
// CodeAccessCheckStackWalkCB
//
// Invoked for each frame in the security check.
//-----------------------------------------------------------
static
StackWalkAction CodeAccessCheckStackWalkCB(CrawlFrame* pCf, VOID* pData)
{
    CheckWalkHeader *pCBdata = (CheckWalkHeader*)pData;
    
    DBG_TRACE_METHOD(pCf);

    MethodDesc * pFunc = pCf->GetFunction();
    _ASSERTE(pFunc != NULL); // we requested functions only!

    StackWalkAction action ;
    if (Security::SecWalkCommonProlog (&(pCBdata->prologData), pFunc, &action, pCf))
        return action ;

    //
    // Now check the current frame!
    //

    DBG_TRACE_STACKWALK("        Checking granted permissions for current method...\n", true);
    
    // Reached here imples we walked atleast a single frame.
    COUNTER_ONLY(GetPrivatePerfCounters().m_Security.stackWalkDepth++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Security.stackWalkDepth++);

    // Get the current app domain.
    AppDomain *pAppDomain = pCf->GetAppDomain();

    // Get the current assembly
    Assembly *pAssem = pFunc->GetModule()->GetAssembly();

    // Keep track of the last module checked. If we have just checked the
    // permissions on the module, we don't need to do it again.
    if (pAssem != pCBdata->pPrevAssembly)
    {
        DBG_TRACE_STACKWALK("            Checking grants for current assembly.\n", true);

        // Get the security descriptor for the current assembly and pass it to
        // the interpreted helper.
        AssemblySecurityDescriptor * pSecDesc = pAssem->GetSecurityDescriptor(pAppDomain);
        _ASSERTE(pSecDesc != NULL);

        // We have to check the permissions if we are not fully trusted or
        // we cannot be overrided by full trust.  Plus we always skip checks
        // on system classes.
        if ((!pSecDesc->IsFullyTrusted() || !pCBdata->bUnrestrictedOverride) && !pSecDesc->GetProperties( CORSEC_SYSTEM_CLASSES ))
        {
            if (pCBdata->pfnCheckGrants != NULL)
            {
                OBJECTREF orDenied;
                OBJECTREF orGranted = pSecDesc->GetGrantedPermissionSet(&orDenied);
                pCBdata->pfnCheckGrants(orGranted, orDenied, pData, pAppDomain);
            }
        }

        pCBdata->pPrevAssembly = pAssem;
    }
    else
    {
        DBG_TRACE_STACKWALK("            Current assembly same as previous. Skipping check.\n", true);
    }

    // Check AppDomain when we cross over to a new AppDomain.
    if (pAppDomain != pCBdata->pPrevAppDomain)
    {
        if (pCBdata->pPrevAppDomain != NULL)
        {
            // We have not checked the previous AppDomain. Check it now.
            SecurityDescriptor *pSecDesc = 
                pCBdata->pPrevAppDomain->GetSecurityDescriptor();

            if (pSecDesc)
            {
                DBG_TRACE_STACKWALK("            Checking appdomain...\n", true);

                // Note: the order of these calls is important since you have to have done a
                // GetEvidence() on the security descriptor before you check for the
                // CORSEC_DEFAULT_APPDOMAIN property.  IsFullyTrusted calls Resolve so
                // we're all good.
                if ((!pSecDesc->IsFullyTrusted() || !pCBdata->bUnrestrictedOverride) && (!pSecDesc->GetProperties( CORSEC_DEFAULT_APPDOMAIN )))
                {
                    if (pCBdata->pfnCheckGrants != NULL)
                    {
                        OBJECTREF orDenied;
                        OBJECTREF orGranted = pSecDesc->GetGrantedPermissionSet(&orDenied);
                        pCBdata->pfnCheckGrants(orGranted, orDenied, pData, pCBdata->pPrevAppDomain);
                    }
                }
            }
            else
            {
                DBG_TRACE_STACKWALK("            Skipping appdomain...\n", true);
            }
        }

        // At the end of the stack walk, do a check on the grants of
        // the pPrevAppDomain by the stackwalk caller if needed.
        pCBdata->pPrevAppDomain = pAppDomain;
    }

    // Passed initial check. See if there is security info on this frame.
    OBJECTREF *pFrameObjectSlot = pCf->GetAddrOfSecurityObject();
    if (pFrameObjectSlot != NULL && *pFrameObjectSlot != NULL)
    {
        DBG_TRACE_STACKWALK("        + Frame-specific security info found. Checking...\n", false);

        if (pCBdata->pfnCheckFrameData!= NULL && !pCBdata->pfnCheckFrameData(*pFrameObjectSlot, pData, pAppDomain))
        {
            DBG_TRACE_STACKWALK("            Halting stackwalk for assert.\n", false);
            pCBdata->prologData.dwFlags |= CORSEC_STACKWALK_HALTED;
            return SWA_ABORT;
        }
    }

    DBG_TRACE_STACKWALK("        Check passes for this method.\n", true);

    // Passed all the checks, so continue.
    return SWA_CONTINUE;
}


static
void StandardCodeAccessCheck(VOID *pData)
{
    THROWSCOMPLUSEXCEPTION();

    if (Security::IsSecurityOff())
    {
        return;
    }

    CheckWalkHeader *pHeader = (CheckWalkHeader*)pData;

    // Get the current thread.
    Thread *pThread = GetThread();
    _ASSERTE(pThread != NULL);

    // Don't allow recursive security stackwalks. Note that this implies that
    // *no* untrusted code must ever be called during a security stackwalk.
    if (pThread->IsSecurityStackwalkInProgess())
        return;

    // NOTE: Initialize the stack depth. Note that if more that one thread tries
    // to perform stackwalk then these counters gets stomped upon. 
    COUNTER_ONLY(GetPrivatePerfCounters().m_Security.stackWalkDepth = 0);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Security.stackWalkDepth = 0);

    // Walk the thread.
    COMPLUS_TRY
    {
        pThread->SetSecurityStackwalkInProgress(TRUE);

        DBG_TRACE_STACKWALK("Code-access security check invoked.\n", false);
        StackWalkFunctions(pThread, CodeAccessCheckStackWalkCB, pData);
        DBG_TRACE_STACKWALK("\tCode-access stackwalk completed.\n", false);

        // If the flag is set that the stackwalk was halted, then don't
        // check the compressed stack on the thread. Also, if the caller
        // specified a check count that exactly matches the count of the frames
        // on the stack, then the flag won't get a chance to be set, so
        // also check that the checkCount is not zero before checking the thread.
        // NOTE: This extra check suggests that we can get rid of the flag and
        //       just overload the cCheck variable to indicate whether we need
        //       to check the thread or not.

        if (((pHeader->prologData.dwFlags & CORSEC_STACKWALK_HALTED) == 0) && 
            (pHeader->prologData.cCheck != 0))
        {
            CompressedStack* compressedStack = pThread->GetDelayedInheritedSecurityStack();
            if (compressedStack != NULL && (!compressedStack->LazyIsFullyTrusted() || !pHeader->bUnrestrictedOverride))
            {
                OBJECTREF orSecurityStack = pThread->GetInheritedSecurityStack();
                if (orSecurityStack != NULL)
                {
                    DBG_TRACE_STACKWALK("\tChecking compressed stack on current thread...\n", false);
                    if (pHeader->pfnCheckThread != NULL && !pHeader->pfnCheckThread(orSecurityStack, pData, GetAppDomain()))
                    {
                        DBG_TRACE_STACKWALK("            Halting stackwalk for assert.\n", false);
                        pHeader->prologData.dwFlags |= CORSEC_STACKWALK_HALTED;
                    }
                }
            }
        }

        // check the last app domain.
        if (((pHeader->prologData.dwFlags & CORSEC_STACKWALK_HALTED) == 0) &&
            (pHeader->prologData.cCheck != 0))
        {
            // We have not checked the previous AppDomain. Check it now.
            AppDomain *pAppDomain = pHeader->pPrevAppDomain != NULL ?
                pHeader->pPrevAppDomain : SystemDomain::GetCurrentDomain();
            SecurityDescriptor *pSecDesc = pAppDomain->GetSecurityDescriptor();
        
            if (pSecDesc != NULL)
            {
                // Note: the order of these calls is important since you have to have done a
                // GetEvidence() on the security descriptor before you check for the
                // CORSEC_DEFAULT_APPDOMAIN property.  IsFullyTrusted calls Resolve so
                // we're all good.
                if ((!pSecDesc->IsFullyTrusted() || !pHeader->bUnrestrictedOverride) && (!pSecDesc->GetProperties( CORSEC_DEFAULT_APPDOMAIN )))
                {
                    DBG_TRACE_STACKWALK("\tChecking appdomain...\n", true);
                    OBJECTREF orDenied;
                    OBJECTREF orGranted = pSecDesc->GetGrantedPermissionSet(&orDenied);
                    pHeader->pfnCheckGrants(orGranted, orDenied, pData, pAppDomain);
                    DBG_TRACE_STACKWALK("\tappdomain check passed.\n", true);
                }
            }
            else
            {
                DBG_TRACE_STACKWALK("\tSkipping appdomain check.\n", true);
            }
        }
        else
        {
            DBG_TRACE_STACKWALK("\tSkipping appdomain check.\n", true);
        }

        pThread->SetSecurityStackwalkInProgress(FALSE);
    }
    COMPLUS_CATCH
    {
        // We catch exceptions and rethrow like this to ensure that we've
        // established an exception handler on the fs:[0] chain (managed
        // exception handlers won't do this). This in turn guarantees that
        // managed exception filters in any of our callers won't be found,
        // otherwise they could get to execute untrusted code with security
        // turned off.
        pThread->SetSecurityStackwalkInProgress(FALSE);
        COMPlusRareRethrow();
    }
    COMPLUS_END_CATCH

    DBG_TRACE_STACKWALK("Code-access check passed.\n", false);
}

//-----------------------------------------------------------
// Native implementation for code-access security check.
// Checks that callers on the stack have the permission
// specified in the arguments or checks for unrestricted
// access if the permission is null.
//-----------------------------------------------------------
void __stdcall 
COMCodeAccessSecurityEngine::Check(const CheckArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args->perm != NULL);

    // An argument exception is thrown by the SecurityManager wrapper to ensure this case.
    _ASSERTE(args->checkFrames >= -1);

#if defined(ENABLE_PERF_COUNTERS)
    // Perf Counter "%Time in Runtime check" support
    PERF_COUNTER_TIMER_PRECISION _startPerfCounterTimer = GET_CYCLE_COUNT();
#endif

    // Initialize callback data.
    CasCheckWalkData walkData;
    walkData.header.prologData.dwFlags    = args->checkFrames == 1 ? CORSEC_SKIP_INTERNAL_FRAMES : 0;
    walkData.header.prologData.bFirstFrame = TRUE;
    walkData.header.prologData.pStackMark = args->stackMark;
    walkData.header.prologData.bFoundCaller = FALSE;
    walkData.header.prologData.cCheck     = args->checkFrames;
    walkData.header.prologData.bSkippingRemoting = FALSE;
    walkData.header.pPrevAssembly         = NULL;
    walkData.header.pPrevAppDomain        = NULL;
    walkData.header.pfnCheckGrants        = CheckGrants;
    walkData.header.pfnCheckFrameData     = CheckFrameData;
    walkData.header.pfnCheckThread        = CheckThread;
    walkData.header.bUnrestrictedOverride = args->unrestrictedOverride; 
    walkData.objects.SetObjects(args->perm, args->permToken);

    // Protect the object references in the callback data.
    GCPROTECT_BEGIN(walkData.objects.m_sGC);

    StandardCodeAccessCheck(&walkData);

    GCPROTECT_END();

#if defined(ENABLE_PERF_COUNTERS)
    // Accumulate the counter
    PERF_COUNTER_TIMER_PRECISION _stopPerfCounterTimer = GET_CYCLE_COUNT();
    g_TotalTimeInSecurityRuntimeChecks += _stopPerfCounterTimer - _startPerfCounterTimer;

    // Report the accumulated counter only after NUM_OF_TERATIONS
    if (g_SecurityChecksIterations++ > PERF_COUNTER_NUM_OF_ITERATIONS)
    {
        GetGlobalPerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetPrivatePerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetGlobalPerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        GetPrivatePerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        
        g_TotalTimeInSecurityRuntimeChecks = 0;
        g_LastTimeInSecurityRuntimeChecks = _stopPerfCounterTimer;
        g_SecurityChecksIterations = 0;
    }
#endif // #if defined(ENABLE_PERF_COUNTERS)

}



void __stdcall
COMCodeAccessSecurityEngine::CheckSet(const CheckSetArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args->permSet != NULL);
    _ASSERTE(args->checkFrames >= -1);

#if defined(ENABLE_PERF_COUNTERS)
    // Perf Counter "%Time in Runtime check" support
    PERF_COUNTER_TIMER_PRECISION _startPerfCounterTimer = GET_CYCLE_COUNT();
#endif

    // Initialize callback data.
    CheckSetWalkData walkData;
    walkData.header.prologData.dwFlags    = args->checkFrames == 1 ? CORSEC_SKIP_INTERNAL_FRAMES : 0;
    walkData.header.prologData.bFirstFrame = TRUE;
    walkData.header.prologData.pStackMark = args->stackMark;
    walkData.header.prologData.bFoundCaller = FALSE;
    walkData.header.prologData.cCheck     = args->checkFrames;
    walkData.header.prologData.bSkippingRemoting = FALSE;
    walkData.header.pPrevAssembly         = NULL;
    walkData.header.pPrevAppDomain        = NULL;
    walkData.header.pfnCheckGrants        = CheckSetAgainstGrants;
    walkData.header.pfnCheckFrameData     = CheckSetAgainstFrameData;
    walkData.header.pfnCheckThread        = CheckSetAgainstThread;
    walkData.header.bUnrestrictedOverride = args->unrestrictedOverride;
    walkData.objects.SetObject(args->permSet);

    // Protect the object references in the callback data.
    GCPROTECT_BEGIN(walkData.objects.m_sGC);

    COMCodeAccessSecurityEngine::InitSEData();

    StandardCodeAccessCheck(&walkData);

    GCPROTECT_END();

#if defined(ENABLE_PERF_COUNTERS)
    // Accumulate the counter
    PERF_COUNTER_TIMER_PRECISION _stopPerfCounterTimer = GET_CYCLE_COUNT();
    g_TotalTimeInSecurityRuntimeChecks += _stopPerfCounterTimer - _startPerfCounterTimer;

    // Report the accumulated counter only after NUM_OF_TERATIONS
    if (g_SecurityChecksIterations++ > PERF_COUNTER_NUM_OF_ITERATIONS)
    {
        GetGlobalPerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetPrivatePerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetGlobalPerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        GetPrivatePerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        
        g_TotalTimeInSecurityRuntimeChecks = 0;
        g_LastTimeInSecurityRuntimeChecks = _stopPerfCounterTimer;
        g_SecurityChecksIterations = 0;
    }
#endif // #if defined(ENABLE_PERF_COUNTERS)

}


void __stdcall 
COMCodeAccessSecurityEngine::GetZoneAndOrigin(const ZoneAndOriginArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    // Initialize callback data.
    CasCheckWalkData walkData;
    walkData.header.prologData.dwFlags    = args->checkFrames == 1 ? CORSEC_SKIP_INTERNAL_FRAMES : 0;
    walkData.header.prologData.pStackMark = args->stackMark;
    walkData.header.prologData.bFoundCaller = FALSE;
    walkData.header.prologData.cCheck     = args->checkFrames;
    walkData.header.prologData.bSkippingRemoting = FALSE;
    walkData.header.pPrevAssembly         = NULL;
    walkData.header.pPrevAppDomain        = NULL;
    walkData.header.pfnCheckGrants        = GetZoneAndOriginGrants;
    walkData.header.pfnCheckFrameData     = NULL;
    walkData.header.pfnCheckThread        = GetZoneAndOriginThread;
    walkData.header.bUnrestrictedOverride = FALSE; 
    walkData.objects.SetObjects(args->zoneList, args->originList);

    GCPROTECT_BEGIN(walkData.objects.m_sGC);

    StandardCodeAccessCheck(&walkData);

    GCPROTECT_END();
}



//-----------------------------------------------------------
// CheckNReturnSOStackWalkCB
//
// CheckImmediate and return FrameSecurityObject if any
//-----------------------------------------------------------
static
StackWalkAction CheckNReturnSOStackWalkCB(CrawlFrame* pCf, VOID* pData)
{
    CasCheckNReturnSOWalkData *pCBdata = (CasCheckNReturnSOWalkData*)pData;
    
    DBG_TRACE_METHOD(pCf);

    MethodDesc * pFunc = pCf->GetFunction();
    _ASSERTE(pFunc != NULL); // we requested functions only!

    StackWalkAction action ;
    if (Security::SecWalkCommonProlog (&(pCBdata->header.prologData), pFunc, &action, pCf))
        return action ;

    //
    // Now check the current frame!
    //

    DBG_TRACE_STACKWALK("        Checking granted permissions for current method...\n", true);
    
    // Reached here imples we walked atleast a single frame.
    COUNTER_ONLY(GetPrivatePerfCounters().m_Security.stackWalkDepth++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Security.stackWalkDepth++);

    DBG_TRACE_STACKWALK("            Checking grants for current assembly.\n", true);

    // Get the security descriptor for the current assembly and pass it to
    // the interpreted helper.
    // Get the current assembly
    Assembly *pAssem = pFunc->GetModule()->GetAssembly();
    AppDomain *pAppDomain = pCf->GetAppDomain();
    AssemblySecurityDescriptor * pSecDesc = pAssem->GetSecurityDescriptor(pAppDomain);
    _ASSERTE(pSecDesc != NULL);

    if ((!pSecDesc->IsFullyTrusted() || !pCBdata->header.bUnrestrictedOverride) && !pSecDesc->GetProperties( CORSEC_SYSTEM_CLASSES ))
    {
        OBJECTREF orDenied;
        OBJECTREF orGranted = pSecDesc->GetGrantedPermissionSet(&orDenied);
        pCBdata->header.pfnCheckGrants(orGranted, orDenied, pData, pAppDomain);
    }

    // Passed initial check. See if there is security info on this frame.
    pCBdata->pSecurityObject = pCf->GetAddrOfSecurityObject();
    pCBdata->pSecurityObjectDomain = pAppDomain;
        
    DBG_TRACE_STACKWALK("        Check Immediate passes for this method.\n", true);

    // Passed all the checks, so continue.
    return SWA_ABORT;
}

LPVOID __stdcall 
COMCodeAccessSecurityEngine::CheckNReturnSO(const CheckNReturnSOArgs * args)
{
    if (Security::IsSecurityOff())
    {
        return NULL;
    }

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE((args->permToken != NULL) && (args->perm != NULL));

    // Track perfmon counters. Runtime security checkes.
    IncrementSecurityPerfCounter();

#if defined(ENABLE_PERF_COUNTERS)
    // Perf Counter "%Time in Runtime check" support
    PERF_COUNTER_TIMER_PRECISION _startPerfCounterTimer = GET_CYCLE_COUNT();
#endif

    // Initialize callback data.
    CasCheckNReturnSOWalkData walkData;
    walkData.header.prologData.dwFlags    = 0;
    walkData.header.prologData.bFirstFrame = TRUE;
    walkData.header.prologData.pStackMark = args->stackMark;
    walkData.header.prologData.bFoundCaller = FALSE;
    walkData.header.prologData.cCheck     = 1;
    walkData.header.prologData.bSkippingRemoting = FALSE;
    walkData.header.pPrevAssembly         = NULL;
    walkData.header.pPrevAppDomain        = NULL;
    walkData.header.pfnCheckGrants        = CheckGrants;
    walkData.header.pfnCheckFrameData     = CheckFrameData;
    walkData.header.pfnCheckThread        = CheckThread;
    walkData.header.bUnrestrictedOverride = args->unrestrictedOverride;
    walkData.objects.SetObjects(args->perm, args->permToken);
    walkData.pSecurityObject = NULL;

    // Protect the object references in the callback data.
    GCPROTECT_BEGIN(walkData.objects.m_sGC);

    // Get the current thread.
    Thread *pThread = GetThread();
    _ASSERTE(pThread != NULL);
    
    // NOTE: Initialize the stack depth. Note that if more that one thread tries
    // to perform stackwalk then these counters gets stomped upon. 
    COUNTER_ONLY(GetPrivatePerfCounters().m_Security.stackWalkDepth = 0);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Security.stackWalkDepth = 0);

    // Walk the thread.
    DBG_TRACE_STACKWALK("Code-access security check immediate invoked.\n", false);
    StackWalkFunctions(pThread, CheckNReturnSOStackWalkCB, &walkData);

    DBG_TRACE_STACKWALK("\tCode-access stackwalk completed.\n", false);

    GCPROTECT_END();

#if defined(ENABLE_PERF_COUNTERS)
    // Accumulate the counter
    PERF_COUNTER_TIMER_PRECISION _stopPerfCounterTimer = GET_CYCLE_COUNT();
    g_TotalTimeInSecurityRuntimeChecks += _stopPerfCounterTimer - _startPerfCounterTimer;

    // Report the accumulated counter only after NUM_OF_TERATIONS
    if (g_SecurityChecksIterations++ > PERF_COUNTER_NUM_OF_ITERATIONS)
    {
        GetGlobalPerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetPrivatePerfCounters().m_Security.timeRTchecks = g_TotalTimeInSecurityRuntimeChecks;
        GetGlobalPerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        GetPrivatePerfCounters().m_Security.timeRTchecksBase = (_stopPerfCounterTimer - g_LastTimeInSecurityRuntimeChecks);
        
        g_TotalTimeInSecurityRuntimeChecks = 0;
        g_LastTimeInSecurityRuntimeChecks = _stopPerfCounterTimer;
        g_SecurityChecksIterations = 0;
    }
#endif // #if defined(ENABLE_PERF_COUNTERS)

    if (walkData.pSecurityObject == NULL)
        return NULL;

    // Is security object frame in a different context?
    Thread *pThread = GetThread();
    bool fSwitchContext = walkData.pSecurityObjectDomain != pThread->GetDomain();

    if (args->create && *walkData.pSecurityObject == NULL)
    {
        ContextTransitionFrame frame;

        // If necessary, shift to correct context to allocate security object.
        if (fSwitchContext)
            pThread->EnterContextRestricted(walkData.pSecurityObjectDomain->GetDefaultContext(), &frame, TRUE);

        *walkData.pSecurityObject = AllocateObject(COMSecurityRuntime::s_srData.pFrameSecurityDescriptor);

        if (fSwitchContext)
            pThread->ReturnToContext(&frame, TRUE);
    }

    // If we found or created a security object in a different context, make a
    // copy in the current context.
    LPVOID rv;
    if (fSwitchContext && *walkData.pSecurityObject != NULL)
        *((OBJECTREF*)&rv) = AppDomainHelper::CrossContextCopyFrom(walkData.pSecurityObjectDomain, 
                                                                   walkData.pSecurityObject);
    else
        *((OBJECTREF*)&rv) = *walkData.pSecurityObject;

    return rv;
}

//-----------------------------------------------------------+
// UPDATE COUNT OF SECURITY OVERRIDES ON THE CALL STACK
//-----------------------------------------------------------+
typedef struct _UpdateOverridesCountData
{
    StackCrawlMark *stackMark;
    INT32           numOverrides;
    BOOL            foundCaller;
} UpdateOverridesCountData;

static 
StackWalkAction UpdateOverridesCountCB(CrawlFrame* pCf, void *pData)
{
    DBG_TRACE_METHOD(pCf);

    UpdateOverridesCountData *pCBdata = static_cast<UpdateOverridesCountData *>(pData);

    // First check if the walk has skipped the required frames. The check
    // here is between the address of a local variable (the stack mark) and a
    // pointer to the EIP for a frame (which is actually the pointer to the
    // return address to the function from the previous frame). So we'll
    // actually notice which frame the stack mark was in one frame later. This
    // is fine for our purposes since we're always looking for the frame of the
    // caller (or the caller's caller) of the method that actually created the
    // stack mark.
    _ASSERTE((pCBdata->stackMark == NULL) || (*pCBdata->stackMark == LookForMyCaller) || (*pCBdata->stackMark == LookForMyCallersCaller));
    if ((pCBdata->stackMark != NULL) &&
        ((size_t)pCf->GetRegisterSet()->pPC) < (size_t)pCBdata->stackMark)
        return SWA_CONTINUE;

    // If we're looking for the caller's caller, skip the frame after the stack
    // mark as well.
    if ((pCBdata->stackMark != NULL) &&
        (*pCBdata->stackMark == LookForMyCallersCaller) &&
        !pCBdata->foundCaller)
    {
        pCBdata->foundCaller = TRUE;
        return SWA_CONTINUE;
    }

    // Get the security object for this function...
    OBJECTREF* pRefSecDesc = pCf->GetAddrOfSecurityObject();

    if (pRefSecDesc == NULL || *pRefSecDesc == NULL)
    {
        DBG_TRACE_STACKWALK("       No SecurityDescriptor on this frame. Skipping.\n", true);
        return SWA_CONTINUE;
    }

    // NOTE: Even if the current frame is in a different app domain than is
    // currently active, we make the following call without switching context.
    // We can do this because we know the call is to an internal helper that
    // won't squirrel away references to the foreign object.
    INT64 ilargs[1] = { ObjToInt64(*pRefSecDesc) };
    INT32 ret = (INT32)COMCodeAccessSecurityEngine::s_seData.pMethOverridesHelper->Call(&(ilargs[0]),
                                                                                        METHOD__SECURITY_RUNTIME__OVERRIDES_HELPER);
    
    if (ret > 0)
    {
        DBG_TRACE_STACKWALK("       SecurityDescriptor with overrides FOUND.\n", false);
        pCBdata->numOverrides += ret;
        return SWA_CONTINUE;
    }
    DBG_TRACE_STACKWALK("       SecurityDescriptor with no override found.\n", false);
    return SWA_CONTINUE;
}

#ifdef FCALLAVAILABLE   // else what ??
FCIMPL1(VOID, COMCodeAccessSecurityEngine::UpdateOverridesCount, StackCrawlMark *stackMark) 
{
    HELPER_METHOD_FRAME_BEGIN_0();

    UpdateOverridesCountInner(stackMark);

    HELPER_METHOD_FRAME_END();
}
FCIMPLEND

VOID COMCodeAccessSecurityEngine::UpdateOverridesCountInner(StackCrawlMark *stackMark)
{
    if (Security::IsSecurityOff())
    {
        return;
    }

    THROWSCOMPLUSEXCEPTION();

    //
    // Initialize the callback data on the stack...        
    //

    UpdateOverridesCountData walkData;
    
    // Skip frames for the security APIs (whatever is specified in the argument).
    walkData.stackMark = stackMark; 
    walkData.numOverrides = 0;
    walkData.foundCaller = FALSE;

    // Get the current thread that we're to walk.
    Thread * t = GetThread();

    //
    // Begin the stack walk...
    //
    DBG_TRACE_STACKWALK(" Update Overrides Count invoked .\n", false);
    StackWalkFunctions(t, UpdateOverridesCountCB, &walkData);

    CompressedStack* stack = t->GetDelayedInheritedSecurityStack();

    if (stack != NULL)
    {
        walkData.numOverrides += stack->GetOverridesCount();
    }

    t->SetOverridesCount(walkData.numOverrides);
}

FCIMPL1(VOID, COMCodeAccessSecurityEngine::FcallReleaseDelayedCompressedStack, CompressedStack *compressedStack) 
{
    _ASSERTE( Security::IsSecurityOn() && "This function should only be called with security on" );
    _ASSERTE( compressedStack != NULL && "Yo, don't pass null" );
    compressedStack->Release();
}
FCIMPLEND


#endif
 
// Return value -
// TRUE - PreCheck passes. No need for stackwalk
// FALSE - Do a stackwalk
BOOL
COMCodeAccessSecurityEngine::PreCheck(OBJECTREF demand, MethodDesc *plsMethod, DWORD whatPermission)
{

    LPVOID      pDomainListSet;
    DWORD       dStatus = NEED_STACKWALK;
    BOOL        retVal;
    
    // Track perfmon counters. Runtime security checks.
    IncrementSecurityPerfCounter();

    int ts = ApplicationSecurityDescriptor::GetAppwideTimeStamp();

    GCPROTECT_BEGIN(demand);
    pDomainListSet = ApplicationSecurityDescriptor::GetDomainPermissionListSetInner(&dStatus, demand, plsMethod);

    if (dStatus == NEED_UPDATED_PLS)
    {
        pDomainListSet = ApplicationSecurityDescriptor::UpdateDomainPermissionListSetInner(&dStatus);
    }

    switch(dStatus)
    {
    case OVERRIDES_FOUND:
        // pDomainListSet could get shifted due to GC, but we dont care as we wont be using it now
        UpdateOverridesCountInner(0);
        retVal = FALSE;
        break;

    case FULLY_TRUSTED: 
        ApplicationSecurityDescriptor::SetStatusOf(EVERYONE_FULLY_TRUSTED, ts);
 
    case CONTINUE:
        {
            BOOL retCode = FALSE;
            OBJECTREF refDomainPLS = ObjectToOBJECTREF((Object *)pDomainListSet);
            INT64 arg[2] = { ObjToInt64(refDomainPLS), ObjToInt64(demand)};

            MetaSig *pSig = (plsMethod == s_seData.pMethPLSDemand ? s_seData.pSigPLSDemand : s_seData.pSigPLSDemandSet);
            if (pSig->NeedsSigWalk())
                pSig->ForceSigWalk(false);
            MetaSig sSig(pSig);

            COMPLUS_TRY 
            {
                retCode = (BOOL)plsMethod->Call(&arg[0], &sSig);
            }
            COMPLUS_CATCH
            {
                retCode = FALSE;
                // An exception is okay. It just means the short-path didnt work, need to do stackwalk
            } 
            COMPLUS_END_CATCH

            retVal = retCode;
            break;
        }

    case DEMAND_PASSES:
        retVal = TRUE;
        break;

    default:
        retVal = FALSE;
        break;
    }

    GCPROTECT_END();

    return retVal;

}

//-----------------------------------------------------------+
// Unmanaged version of CodeAccessSecurityEngine.Demand() in BCL
// Any change there may have to be propagated here
// This call has to be virtual, unlike DemandSet
//-----------------------------------------------------------+
void
COMCodeAccessSecurityEngine::Demand(OBJECTREF demand)
{
    if (Security::IsSecurityOff())
        return;

    THROWSCOMPLUSEXCEPTION();
    
    GCPROTECT_BEGIN(demand);
    if (!PreCheck(demand, s_seData.pMethPLSDemand))
    {
        CheckArgs args;
        args.checkFrames = -1;  // Check all frames
        args.stackMark = NULL;      // Skip no frames
        args.perm = demand;
        args.permToken = NULL;
        args.unrestrictedOverride = FALSE;
        Check(&args);
    }
    GCPROTECT_END();

}

//-----------------------------------------------------------+
// Special case of Demand(). This remembers the result of the 
// previous demand, and reuses it if new assemblies have not
// been added since then
//-----------------------------------------------------------+
void
COMCodeAccessSecurityEngine::SpecialDemand(DWORD whatPermission)
{
    if (Security::IsSecurityOff())
        return;

    THROWSCOMPLUSEXCEPTION();

    int ts = ApplicationSecurityDescriptor::GetAppwideTimeStamp();

    // Do I know the result from last time ?
    if ((ApplicationSecurityDescriptor::CheckStatusOf(EVERYONE_FULLY_TRUSTED)  || ApplicationSecurityDescriptor::CheckStatusOf(whatPermission)) && GetThread()->GetOverridesCount() == 0)
    {
        // Track perfmon counters. Runtime security checks.
        IncrementSecurityPerfCounter();
        return;
    }

    OBJECTREF demand = NULL;
    GCPROTECT_BEGIN(demand);

    Security::GetPermissionInstance(&demand, whatPermission);
    _ASSERTE(demand != NULL);

    COMCodeAccessSecurityEngine::InitSEData();

    if (PreCheck(demand, s_seData.pMethPLSDemand, whatPermission))
    {
        ApplicationSecurityDescriptor::SetStatusOf(whatPermission, ts);
    }
    else
    {
        CheckArgs args;
        args.checkFrames = -1;  // Check all the frames
        args.stackMark = NULL;      // Skip no frames
        args.perm = demand;
        args.permToken = NULL;
        args.unrestrictedOverride = TRUE;
        Check(&args);
    }
    GCPROTECT_END();
}

FCIMPL2(INT32, COMCodeAccessSecurityEngine::GetResult, DWORD whatPermission, DWORD *timeStamp) 
{

    *timeStamp = ApplicationSecurityDescriptor::GetAppwideTimeStamp();

    // Do I know the result from last time ?
    if (ApplicationSecurityDescriptor::CheckStatusOf(whatPermission) && GetThread()->GetOverridesCount() == 0)
    {
        // Track perfmon counters. Runtime security checks.
        IncrementSecurityPerfCounter();
        return TRUE;
    }

    return FALSE;

}
FCIMPLEND

FCIMPL2(VOID, COMCodeAccessSecurityEngine::SetResult, DWORD whatPermission, DWORD timeStamp) 
{
    ApplicationSecurityDescriptor::SetStatusOf(whatPermission, timeStamp);
}
FCIMPLEND

//-----------------------------------------------------------+
// Unmanaged version of PermissionSet.DemandSet() in BCL
// Any change there may have to be propagated here
//-----------------------------------------------------------+
void
COMCodeAccessSecurityEngine::DemandSet(OBJECTREF demand)
{
    if (Security::IsSecurityOff())
        return;

    BOOL done = FALSE;

    GCPROTECT_BEGIN( demand );

    InitSEData();

    BOOL canUnrestrictedOverride = s_seData.pFSDnormalPermSet->GetRefValue( demand ) == NULL;

    if (canUnrestrictedOverride && ApplicationSecurityDescriptor::CheckStatusOf(EVERYONE_FULLY_TRUSTED) && GetThread()->GetOverridesCount() == 0) 
        done = TRUE;

    if (!done && !PreCheck(demand, s_seData.pMethPLSDemandSet))
    {
        CheckSetArgs args;
        args.This = NULL;   // never used
        args.checkFrames = -1;  // Check all frames
        args.stackMark = NULL;      // Skip no frames
        args.permSet = demand;
        args.unrestrictedOverride = canUnrestrictedOverride;
        CheckSet(&args);
    }
    GCPROTECT_END();
}


//-----------------------------------------------------------+
// L I N K T I M E   C H E C K
//-----------------------------------------------------------+
void  
COMCodeAccessSecurityEngine::LinktimeCheck(AssemblySecurityDescriptor *pSecDesc, OBJECTREF refDemands)
{
    if (Security::IsSecurityOff())
        return;

    GCPROTECT_BEGIN(refDemands);

    InitSEData();

    if (pSecDesc->IsFullyTrusted( TRUE ))
    {
        INT64 ilargs[2];
        ilargs[1] = ObjToInt64(refDemands);
        ilargs[0] = (INT64)pSecDesc;

        s_seData.pMethLazyCheckSetHelper->Call(ilargs, METHOD__SECURITY_ENGINE__LAZY_CHECK_SET_HELPER);
    }
    else
    {
        INT64 ilargs[3];
        OBJECTREF orDenied;
        ilargs[2] = ObjToInt64(pSecDesc->GetGrantedPermissionSet(&orDenied));
        ilargs[1] = ObjToInt64(orDenied);
        ilargs[0] = ObjToInt64(refDemands);
        
        s_seData.pMethCheckSetHelper->Call(ilargs, METHOD__SECURITY_ENGINE__CHECK_SET_HELPER);
    }

    GCPROTECT_END();
}


//-----------------------------------------------------------+
// S T A C K   C O M P R E S S I O N
//-----------------------------------------------------------+

//-----------------------------------------------------------
// Stack walk callback data structure for stack compress.
//-----------------------------------------------------------
typedef struct _StackCompressData
{
    CompressedStack*    compressedStack;
    StackCrawlMark *    stackMark;
    DWORD               dwFlags;
    Assembly *          prevAssembly; // Previously checked assembly.
    AppDomain *         prevAppDomain;
} StackCompressData;

static
StackWalkAction CompressStackCB(CrawlFrame* pCf, void *pData)
{
    StackCompressData *pCBdata = (StackCompressData*)pData;

    // First check if the walk has skipped the required frames. The check
    // here is between the address of a local variable (the stack mark) and a
    // pointer to the EIP for a frame (which is actually the pointer to the
    // return address to the function from the previous frame). So we'll
    // actually notice which frame the stack mark was in one frame later. This
    // is fine for our purposes since we're always looking for the frame of the
    // caller of the method that actually created the stack mark. 
    _ASSERTE((pCBdata->stackMark == NULL) || (*pCBdata->stackMark == LookForMyCaller));
    if ((pCBdata->stackMark != NULL) &&
        ((size_t)pCf->GetRegisterSet()->pPC) < (size_t)pCBdata->stackMark)
        return SWA_CONTINUE;

    // Get the security object for this function...
    OBJECTREF* pRefSecDesc = pCf->GetAddrOfSecurityObject();

    MethodDesc * pFunc = pCf->GetFunction();
    _ASSERTE(pFunc != NULL); // we requested methods!

    Module * pModule = pFunc->GetModule();
    _ASSERTE(pModule != NULL);

    Assembly * pAssem = pModule->GetAssembly();
    _ASSERTE(pAssem != NULL);

    AppDomain *pAppDomain = pCf->GetAppDomain();

    // Keep track of the last assembly checked. If we have just checked the
    // permissions on the assembly, we don't need to do it again.
    if (pAssem != pCBdata->prevAssembly)
    {
        pCBdata->prevAssembly = pAssem;

        // Get the security descriptor for the current assembly in the correct
        // appdomain context.
        SharedSecurityDescriptor * pSecDesc = pAssem->GetSharedSecurityDescriptor();
        _ASSERTE(pSecDesc != NULL);

        pCBdata->compressedStack->AddEntry( pSecDesc, ESharedSecurityDescriptor );
    }

    BOOL appDomainTransition = FALSE;

    // Check AppDomain when we cross over to a new AppDomain.
    if (pAppDomain != pCBdata->prevAppDomain)
    {
        if (pCBdata->prevAppDomain != NULL)
        {
            // We have not checked the previous AppDomain. Check it now.
            SecurityDescriptor *pSecDesc = 
                pCBdata->prevAppDomain->GetSecurityDescriptor();

            _ASSERTE( pSecDesc != NULL );

            pCBdata->compressedStack->AddEntry( pSecDesc, EApplicationSecurityDescriptor );
            appDomainTransition = TRUE;
        }

        // At the end of the stack walk, do a check on the grants of
        // the pPrevAppDomain by the stackwalk caller if needed.
        pCBdata->prevAppDomain = pAppDomain;
    }

    if (pRefSecDesc != NULL && *pRefSecDesc != NULL)
    {
        pCBdata->compressedStack->AddEntry( (void*)pRefSecDesc, pAppDomain, EFrameSecurityDescriptor );
    }

    if (appDomainTransition)
        pCBdata->compressedStack->AddEntry( pAppDomain, EAppDomainTransition );


    return SWA_CONTINUE;

}


LPVOID __stdcall COMCodeAccessSecurityEngine::EcallGetCompressedStack(const GetCompressedStackArgs *args)
{
    if (Security::IsSecurityOff())
    {
        return NULL;
    }

    THROWSCOMPLUSEXCEPTION();

    LPVOID rv;

    //
    // Initialize the callback data on the stack...        
    //

    StackCompressData walkData;
    
    walkData.compressedStack = new (nothrow) CompressedStack();

    if (walkData.compressedStack == NULL)
        COMPlusThrow( kOutOfMemoryException );

    walkData.dwFlags = 0;

    // Set previous module to 'none'
    walkData.prevAssembly = NULL;

    // Set previous module to 'none'
    walkData.prevAppDomain = NULL;

    // Skip frames for the security APIs.
    walkData.stackMark = args->stackMark;
    
    // Set return value.
    *((OBJECTREF*) &rv) = GetCompressedStackWorker(&walkData, TRUE);

    walkData.compressedStack->Release();

    return rv;        
}

LPVOID __stdcall COMCodeAccessSecurityEngine::EcallGetDelayedCompressedStack(const GetDelayedCompressedStackArgs *args)
{
    return GetCompressedStack( args->stackMark );
}

CompressedStack* __stdcall COMCodeAccessSecurityEngine::GetCompressedStack( StackCrawlMark* stackMark )
{
    if (Security::IsSecurityOff())
    {
        return NULL;
    }

    THROWSCOMPLUSEXCEPTION();

    //
    // Initialize the callback data on the stack...        
    //

    StackCompressData walkData;
    
    walkData.compressedStack = new (nothrow) CompressedStack();

    if (walkData.compressedStack == NULL)
        COMPlusThrow( kOutOfMemoryException );

    walkData.dwFlags = 0;

    // Set previous module to 'none'
    walkData.prevAssembly = NULL;

    // Set previous module to 'none'
    walkData.prevAppDomain = NULL;

    walkData.stackMark = stackMark;

    GetCompressedStackWorker(&walkData, FALSE);

    return walkData.compressedStack;        
}


OBJECTREF COMCodeAccessSecurityEngine::GetCompressedStackWorker(void *pData, BOOL returnList)
{
    StackCompressData *pWalkData = (StackCompressData*)pData;

    THROWSCOMPLUSEXCEPTION();

    // Get the current thread that we're to walk.
    Thread * t = GetThread();

    pWalkData->compressedStack->CarryOverSecurityInfo( t );
    pWalkData->compressedStack->SetPLSOptimizationState( t->GetPLSOptimizationState() );

    OBJECTREF retval = NULL;

    _ASSERTE( t != NULL );

    EE_TRY_FOR_FINALLY
    {
        t->SetSecurityStackwalkInProgress(TRUE);

        pWalkData->compressedStack->AddEntry( GetAppDomain(), EAppDomainTransition );

        //
        // Begin the stack walk...
        //
        StackWalkFunctions(t, CompressStackCB, pWalkData);

        // We have not checked the previous AppDomain. Check it now.
        AppDomain *pAppDomain = pWalkData->prevAppDomain != NULL ?
            pWalkData->prevAppDomain : SystemDomain::GetCurrentDomain();
        SecurityDescriptor *pSecDesc = pAppDomain->GetSecurityDescriptor();

        _ASSERTE( pSecDesc != NULL );

        pWalkData->compressedStack->AddEntry( pSecDesc, EApplicationSecurityDescriptor );

        CompressedStack* refCompressedStack = t->GetDelayedInheritedSecurityStack();
        if (refCompressedStack != NULL)
        {
            pWalkData->compressedStack->AddEntry( (void*)refCompressedStack, pAppDomain, ECompressedStack );
        }
        
        if (returnList)
            retval = pWalkData->compressedStack->GetPermissionListSet();
    }
    EE_FINALLY
    {
        t->SetSecurityStackwalkInProgress(FALSE);
    }
    EE_END_FINALLY

    return retval;      
}


//-----------------------------------------------------------+
// I N I T I A L I Z A T I O N
//-----------------------------------------------------------+

COMCodeAccessSecurityEngine::SEData COMCodeAccessSecurityEngine::s_seData;

CRITICAL_SECTION COMCodeAccessSecurityEngine::s_csLock;

LONG COMCodeAccessSecurityEngine::s_nInitLock=0;
BOOL COMCodeAccessSecurityEngine::s_fLockReady=FALSE;

void COMCodeAccessSecurityEngine::InitSEData()
{
    THROWSCOMPLUSEXCEPTION();

    // If this is the first time through, we need to get our Critical Section
    // initialized
    while (!s_fLockReady)
    {
        if (InterlockedExchange(&s_nInitLock, 1) == 0) 
        {
            InitializeCriticalSection(&s_csLock);
            s_fLockReady = TRUE;
        }
        else
            Sleep(1);
    }


    if (!s_seData.fInitialized)
    {
    // We only want 1 thread at a time running through this initialization code
	
	Thread* pThread = GetThread();
	pThread->EnablePreemptiveGC();
    EnterCriticalSection(&s_csLock);
	pThread->DisablePreemptiveGC();

    if (!s_seData.fInitialized)
    {
        s_seData.pSecurityEngine = g_Mscorlib.GetClass(CLASS__SECURITY_ENGINE);
        s_seData.pMethCheckHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__CHECK_HELPER);
        s_seData.pMethCheckSetHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__CHECK_SET_HELPER);
        s_seData.pMethLazyCheckSetHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__LAZY_CHECK_SET_HELPER);
        s_seData.pMethStackCompressHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER);

        s_seData.pSecurityRuntime = g_Mscorlib.GetClass(CLASS__SECURITY_RUNTIME);
        s_seData.pMethFrameDescHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_RUNTIME__FRAME_DESC_HELPER);
        s_seData.pMethFrameDescSetHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_RUNTIME__FRAME_DESC_SET_HELPER);
        s_seData.pMethOverridesHelper = g_Mscorlib.GetMethod(METHOD__SECURITY_RUNTIME__OVERRIDES_HELPER);
        
        s_seData.pPermListSet = g_Mscorlib.GetClass(CLASS__PERMISSION_LIST_SET);
        s_seData.pMethPermListSetInit = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CTOR);
        s_seData.pMethAppendStack = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__APPEND_STACK);

        s_seData.pMethPLSDemand = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CHECK_DEMAND_NO_THROW);
        s_seData.pMethPLSDemandSet = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CHECK_SET_DEMAND_NO_THROW);

        LPHARDCODEDMETASIG hcms;

        hcms = g_Mscorlib.GetMethodSig(METHOD__PERMISSION_LIST_SET__CHECK_DEMAND_NO_THROW);
        s_seData.pSigPLSDemand = new MetaSig(hcms->GetBinarySig(), 
                                             SystemDomain::SystemModule());
        _ASSERTE(s_seData.pSigPLSDemand && "Could not find signature for method PermissionListSet::CheckDemand");

        hcms = g_Mscorlib.GetMethodSig(METHOD__PERMISSION_LIST_SET__CHECK_SET_DEMAND_NO_THROW);
        s_seData.pSigPLSDemandSet = new MetaSig(hcms->GetBinarySig(), 
                                                SystemDomain::SystemModule());
        _ASSERTE(s_seData.pSigPLSDemandSet && "Could not find signature for method PermissionListSet::CheckDemandSet");

        s_seData.pFSDnormalPermSet = g_Mscorlib.GetField(FIELD__PERMISSION_SET__NORMAL_PERM_SET);
        _ASSERTE(s_seData.pFSDnormalPermSet && "Could not find field PermissionSet::m_normalPermSet");

        s_seData.fInitialized = TRUE;
    }

    LeaveCriticalSection(&s_csLock);
    }

}

void COMCodeAccessSecurityEngine::CleanupSEData()
{
    if (s_seData.fInitialized)
    {
        delete s_seData.pSigPLSDemand;
        s_seData.pSigPLSDemand = NULL;
        delete s_seData.pSigPLSDemandSet;
        s_seData.pSigPLSDemandSet = NULL;

        s_seData.fInitialized = FALSE;
    }
}

//-----------------------------------------------------------
// Initialization of native security runtime.
// Called when SecurityEngine is constructed.
//-----------------------------------------------------------
void __stdcall COMCodeAccessSecurityEngine::InitSecurityEngine(const InitSecurityEngineArgs *)
{
    InitSEData();
}

//-----------------------------------------------------------
// Warning!! This is passing out a reference to the permissions
// for the assembly. It must be deep copied before passing it out
//-----------------------------------------------------------
LPVOID __stdcall COMCodeAccessSecurityEngine::GetPermissionsP(const GetPermissionsArg *args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv;

    // An exception is thrown by the SecurityManager wrapper to ensure this case.
    _ASSERTE(args->pClass != NULL);

    OBJECTREF or = args->pClass;
    EEClass* pClass = or->GetClass();
    _ASSERTE(pClass);
    _ASSERTE(pClass->GetModule());

    AssemblySecurityDescriptor * pSecDesc = pClass->GetModule()->GetSecurityDescriptor();
    _ASSERTE(pSecDesc != NULL);


    // Return the token that belongs to the Permission just asserted.
    OBJECTREF token = pSecDesc->GetGrantedPermissionSet(args->ppDenied);
    *((OBJECTREF*) &rv) = token;
    return rv;
}

//-----------------------------------------------------------
// Warning!! This is passing out a reference to the permissions
// for the assembly. It must be deep copied before passing it out
//-----------------------------------------------------------

void __stdcall COMCodeAccessSecurityEngine::GetGrantedPermissionSet(const GetGrantedPermissionSetArg *args)
{
    THROWSCOMPLUSEXCEPTION();

    AssemblySecurityDescriptor * pSecDesc = (AssemblySecurityDescriptor*) args->pSecDesc;
    _ASSERTE(pSecDesc != NULL);

    OBJECTREF token = pSecDesc->GetGrantedPermissionSet(args->ppDenied);
    *((OBJECTREF*)args->ppGranted) = token;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcurrency.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMCurrency.h"
#include "COMString.h"

void COMCurrency::InitSingle(const InitSingleArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    HRESULT hr = VarCyFromR4(args->value, args->_this);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==NOERROR);
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::InitDouble(const InitDoubleArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    HRESULT hr = VarCyFromR8(args->value, args->_this);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==NOERROR);
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::InitString(InitStringArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    VARIANT var;
    NUMPARSE numprs;
    BYTE digits[30];
    numprs.cDig = 30;
    numprs.dwInFlags = NUMPRS_LEADING_WHITE | NUMPRS_TRAILING_WHITE |
        NUMPRS_LEADING_MINUS | NUMPRS_DECIMAL;
	HRESULT hr = VarParseNumFromStr(args->value->GetBuffer(), 0x0409, 
		LOCALE_NOUSEROVERRIDE, &numprs, digits);
    if (SUCCEEDED(hr)) {
        if (args->value->GetBuffer()[numprs.cchUsed] == 0) {
            hr = VarNumFromParseNum(&numprs, digits, VTBIT_CY, &var);
            if (SUCCEEDED(hr)) {
                *args->_this = var.cyVal;
                return;
            }
        }
    }
	if (hr==DISP_E_TYPEMISMATCH)
		COMPlusThrow(kFormatException, L"Format_CurrencyBad");
	else if (hr==DISP_E_OVERFLOW)
		COMPlusThrow(kOverflowException, L"Overflow_Currency");
	else {
		_ASSERTE(hr==NOERROR);
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::Add(const ArithOpArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
	HRESULT hr = VarCyAdd(args->c1, args->c2, args->result);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==NOERROR);
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::Floor(const FloorArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
	_ASSERTE(args->result);
	HRESULT hr = VarCyInt(args->c, args->result);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==NOERROR);
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::Multiply(const ArithOpArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
	_ASSERTE(args->result);
    HRESULT hr = VarCyMul(args->c1, args->c2, args->result);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
		COMPlusThrowHR(hr);
    }
#endif // !PLATFORM_CE
}

void COMCurrency::Round(const RoundArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    _ASSERTE(args->result);
    if (args->result == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
    if (args->decimals < 0 || args->decimals > 4)
        COMPlusThrowArgumentOutOfRange(L"digits", L"ArgumentOutOfRange_CurrencyRound");

    HRESULT hr = VarCyRound(args->c, args->decimals, args->result);
    if (FAILED(hr)) {
        if (hr==E_INVALIDARG)
            COMPlusThrow(kArgumentException, L"Argument_InvalidValue");
        if (hr==DISP_E_OVERFLOW)
            COMPlusThrow(kOverflowException, L"Overflow_Currency");
        _ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
        COMPlusThrowHR(hr);
    }
#endif // !PLATFORM_CE
}

void COMCurrency::Subtract(const ArithOpArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
	_ASSERTE(args->result);
    HRESULT hr = VarCySub(args->c1, args->c2, args->result);
	if (FAILED(hr)) {
		if (hr==DISP_E_OVERFLOW)
			COMPlusThrow(kOverflowException, L"Overflow_Currency");
		_ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
		COMPlusThrowHR(hr);
	}
#endif // !PLATFORM_CE
}

void COMCurrency::ToDecimal(const ToDecimalArgs * args) {
    THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    _ASSERTE(args->result);
    HRESULT hr = VarDecFromCy(args->c, args->result);
    if (FAILED(hr)) {
        _ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
        COMPlusThrowHR(hr);
    }

    DecimalCanonicalize(args->result);
    args->result->wReserved = 0;
#endif // !PLATFORM_CE
}

double COMCurrency::ToDouble(const ToXXXArgs * args) {
	THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return -1;  // Compiler appeasement
#else // !PLATFORM_CE
    double result;
    HRESULT hr = VarR8FromCy(args->c, &result);
	if (FAILED(hr)) {
		_ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
		COMPlusThrowHR(hr);
	}
    return result;
#endif // !PLATFORM_CE
}

float COMCurrency::ToSingle(const ToXXXArgs * args) {
	THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return -1;  // Compiler appeasement
#else // !PLATFORM_CE
    float result;
    HRESULT hr = VarR4FromCy(args->c, &result);
	if (FAILED(hr)) {
		_ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
		COMPlusThrowHR(hr);
	}
    return result;
#endif // !PLATFORM_CE
}

LPVOID COMCurrency::ToString(const ToXXXArgs * args) {
	THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler appeasement
#else // !PLATFORM_CE
    BSTR bstr;
    STRINGREF result;
    HRESULT hr = VarBstrFromCy(args->c, 0, 0, &bstr);
	if (FAILED(hr)) {
		if (hr==E_OUTOFMEMORY)
			COMPlusThrowOM();
		_ASSERTE(hr==S_OK);  // Didn't expect to get here.  Update code for this HR.
		COMPlusThrowHR(hr);
	}
    result = COMString::NewString(bstr, SysStringLen(bstr));
    SysFreeString(bstr);
	RETURN(result, STRINGREF);
#endif // !PLATFORM_CE
}

void COMCurrency::Truncate(const TruncateArgs * args) {
	THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
	COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
	_ASSERTE(args->result);
    VarCyFix(args->c, args->result);
	// VarCyFix can't return anything other than NOERROR
	// currently in OleAut.
#endif // !PLATFORM_CE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcurrency.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMCURRENCY_H_
#define _COMCURRENCY_H_

#include <oleauto.h>

#pragma pack(push)
#pragma pack(1)

class COMCurrency {
public:
    struct InitSingleArgs {
        DECLARE_ECALL_PTR_ARG(CY *, _this);
        DECLARE_ECALL_R4_ARG(R4, value);
    };

    struct InitDoubleArgs {
        DECLARE_ECALL_PTR_ARG(CY *, _this);
        DECLARE_ECALL_R8_ARG(R8, value);
    };

    struct InitStringArgs {
        DECLARE_ECALL_PTR_ARG(CY *, _this);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    };

    struct ArithOpArgs {
        DECLARE_ECALL_DEFAULT_ARG(CY, c2);
        DECLARE_ECALL_DEFAULT_ARG(CY, c1);
        DECLARE_ECALL_PTR_ARG(CY *, result);
    };

    struct FloorArgs {
        DECLARE_ECALL_DEFAULT_ARG(CY, c);
        DECLARE_ECALL_PTR_ARG(CY *, result);
    };

    struct RoundArgs {
        DECLARE_ECALL_I4_ARG(I4, decimals);
        DECLARE_ECALL_DEFAULT_ARG(CY, c);
        DECLARE_ECALL_PTR_ARG(CY *, result);
    };

    struct ToDecimalArgs {
        DECLARE_ECALL_DEFAULT_ARG(CY, c);
        DECLARE_ECALL_PTR_ARG(DECIMAL *, result);
    };

    struct ToXXXArgs {
        DECLARE_ECALL_DEFAULT_ARG(CY, c);
    };

    struct TruncateArgs {
        DECLARE_ECALL_DEFAULT_ARG(CY, c);
        DECLARE_ECALL_PTR_ARG(CY *, result);
    };

    static void __stdcall InitSingle(const InitSingleArgs *);
    static void __stdcall InitDouble(const InitDoubleArgs *);
    static void __stdcall InitString(InitStringArgs *);
    static void __stdcall Add(const ArithOpArgs *);
    static void __stdcall Floor(const FloorArgs *);
    static void __stdcall Multiply(const ArithOpArgs *);
    static void __stdcall Round(const RoundArgs *);
    static void __stdcall Subtract(const ArithOpArgs *);
    static void __stdcall ToDecimal(const ToDecimalArgs *);
    static double __stdcall ToDouble(const ToXXXArgs *);
    static float __stdcall ToSingle(const ToXXXArgs *);
	static LPVOID __stdcall ToString(const ToXXXArgs *);
    static void __stdcall Truncate(const TruncateArgs *);
};

#pragma pack(pop)

#endif _COMCURRENCY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comcryptography.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//
//  File:
//  
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//---------------------------------------------------------------------------

#pragma once
// @TODO: we shouldn't have this whole file #ifdefed out
#include <wincrypt.h>
#include "fcall.h"


class DSA_CSP_Object : public Object
{
public:
    U1ARRAYREF   m_P;            // ubyte[]
    U1ARRAYREF   m_Q;            // ubyte[]
    U1ARRAYREF   m_G;            // ubyte[]
    U1ARRAYREF   m_Y;            // ubyte[] - optional
    U1ARRAYREF   m_X;            // ubyte[] - optional - private key
    U1ARRAYREF   m_J;            // ubyte[] - optional
    U1ARRAYREF   m_seed;         // ubyte[] - optional - paired with counter
    int   m_counter;      // ubyte[] - optional
};

class RSA_CSP_Object : public Object
{
public:
    U1ARRAYREF   m_Modulus;     // ubyte[]
    U1ARRAYREF   m_P;           // ubyte[] - optional
    U1ARRAYREF   m_Q;           // ubyte[] - optional
    U1ARRAYREF   m_dp;          // ubyte[] - optional
    U1ARRAYREF   m_dq;          // ubyte[] - optional
    U1ARRAYREF   m_InverseQ;    // ubyte[] - optional
    U1ARRAYREF   m_d;           // ubyte[] - optional
    int          m_Exponent;    // int
};

#ifdef _DEBUG
typedef REF<DSA_CSP_Object> DSA_CSPREF;
typedef REF<RSA_CSP_Object> RSAKeyREF;
#else  // !_DEBUG
typedef DSA_CSP_Object * DSA_CSPREF;
typedef RSA_CSP_Object * RSAKeyREF;
#endif // _DEBUG

class COMCryptography
{
    struct __AcquireCSP {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_PTR_ARG(INT_PTR, phCSP);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, cspParameters);
    };

    struct __SearchForAlgorithm {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis); 
        DECLARE_ECALL_I4_ARG(INT32, keyLength);
        DECLARE_ECALL_I4_ARG(INT32, algID);
        DECLARE_ECALL_I4_ARG(INT_PTR, hProv);
    };

    struct __CreateHash {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwHashType);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __CryptDeriveKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbIV);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbPwd);
        DECLARE_ECALL_I4_ARG(INT32, calgHash);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __DuplicateKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT_PTR, hNewCSP);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __EncryptData {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, fLast);
        DECLARE_ECALL_I4_ARG(INT32, cb);
        DECLARE_ECALL_I4_ARG(INT32, ib);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, data);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __EncryptKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbKey);
        DECLARE_ECALL_I4_ARG(INT_PTR, hkeyPub);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __EncryptPKWin2KEnh {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, fOAEP);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbKey);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __EndHash {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT_PTR, hHash);
    };

    struct __ExportKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, theKey);
        DECLARE_ECALL_I4_ARG(INT32, dwBlobType);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

#if !defined(FCALLAVAILABLE) || 1
    struct __FreeCSP {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };
#endif // !FCALLAVAILABLE

    struct __FreeHKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __FreeHash {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT_PTR, hHash);
    };

    struct __DeleteKeyContainer {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_PTR_ARG(INT_PTR, hCSP);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, cspParameters);
    };

    struct __GenerateKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };
    
    struct __GetBytes {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, data);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __GetKeyParameter {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwKeyParam);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __GetUserKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_PTR_ARG(INT_PTR*, phKey);
        DECLARE_ECALL_I4_ARG(INT32, dwKeySpec);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __HashData {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, cbSize);
        DECLARE_ECALL_I4_ARG(INT32, ibStart);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, data);
        DECLARE_ECALL_I4_ARG(INT_PTR, hHash);
    };

    struct __ImportBulkKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbKey);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __ImportKey {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refKey);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __SetKeyParamDw {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwValue);
        DECLARE_ECALL_I4_ARG(INT32, param);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __SetKeyParamRgb {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgb);
        DECLARE_ECALL_I4_ARG(INT32, param);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
    };

    struct __SignValue {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgb);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT32, dwKeySpec);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

    struct __VerifySign {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, dwFlags);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbSignature);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, rgbHash);
        DECLARE_ECALL_I4_ARG(INT32, calg);
        DECLARE_ECALL_I4_ARG(INT_PTR, hKey);
        DECLARE_ECALL_I4_ARG(INT_PTR, hCSP);
    };

public:
    static int     __stdcall _AcquireCSP(__AcquireCSP *);
    static int     __stdcall _CreateCSP(__AcquireCSP *);
    static INT_PTR __stdcall _CreateHash(__CreateHash *);
    static LPVOID  __stdcall _CryptDeriveKey(__CryptDeriveKey *);
    static LPVOID  __stdcall _DecryptData(__EncryptData *);
    static LPVOID  __stdcall _DecryptKey(__EncryptKey *);
    static LPVOID  __stdcall _DecryptPKWin2KEnh(__EncryptPKWin2KEnh *);
    static int     __stdcall _DeleteKeyContainer(__DeleteKeyContainer *);
    static int     __stdcall _DuplicateKey(__DuplicateKey *);
    static LPVOID  __stdcall _EncryptData(__EncryptData *);
    static LPVOID  __stdcall _EncryptKey(__EncryptKey *);
    static LPVOID  __stdcall _EncryptPKWin2KEnh(__EncryptPKWin2KEnh *);
    static LPVOID  __stdcall _EndHash(__EndHash *);
    static int     __stdcall _ExportKey(__ExportKey *);
    static void    __stdcall _FreeCSP(__FreeCSP *);
    static void    __stdcall _FreeHKey(__FreeHKey *);
    static void    __stdcall _FreeHash(__FreeHash *);
    static INT_PTR __stdcall _GenerateKey(__GenerateKey *);
    static void    __stdcall _GetBytes(__GetBytes *);
    static LPVOID  __stdcall _GetKeyParameter(__GetKeyParameter *);
    static void    __stdcall _GetNonZeroBytes(__GetBytes *);
    static int     __stdcall _GetUserKey(__GetUserKey *);
    static void    __stdcall _HashData(__HashData *);
    static INT_PTR __stdcall _ImportBulkKey(__ImportBulkKey *);
    static INT_PTR __stdcall _ImportKey(__ImportKey *);
    static int     __stdcall _SearchForAlgorithm(__SearchForAlgorithm *);
    static void    __stdcall _SetKeyParamDw(__SetKeyParamDw *);
    static void    __stdcall _SetKeyParamRgb(__SetKeyParamRgb *);
    static LPVOID  __stdcall _SignValue(__SignValue *);
    static int     __stdcall _VerifySign(__VerifySign *);

#ifdef SHOULD_WE_CLEANUP
    static void         Terminate(void);
#endif /* SHOULD_WE_CLEANUP */

private:
    static int COMCryptography::OpenCSP(OBJECTREF * pSafeThis, DWORD dwFlags,
                                        HCRYPTPROV * phprov);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdecimal.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMDecimal.h"
#include "COMString.h"

FCIMPL2 (void, COMDecimal::InitSingle, DECIMAL *_this, R4 value)
{
    if (VarDecFromR4(value, _this) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    _this->wReserved = 0;
}
FCIMPLEND

FCIMPL2 (void, COMDecimal::InitDouble, DECIMAL *_this, R8 value)
{
    if (VarDecFromR8(value, _this) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    _this->wReserved = 0;
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Add, DECIMAL *result, DECIMAL d2, DECIMAL d1)
{
    if (VarDecAdd(&d1, &d2, result) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL2 (INT32, COMDecimal::Compare, DECIMAL d1, DECIMAL d2)
{
    return VarDecCmp(&d2, &d1) - 1;
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Divide, DECIMAL *result, DECIMAL d2, DECIMAL d1)
{
    HRESULT hr = VarDecDiv(&d1, &d2, result);
    if (hr < 0) {
        if (hr == DISP_E_DIVBYZERO) FCThrowVoid(kDivideByZeroException);
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    }
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL2 (void, COMDecimal::Floor, DECIMAL *result, DECIMAL d)
{
    HRESULT hr = VarDecInt(&d, result);
    // VarDecInt can't overflow, as of source for OleAut32 build 4265.
    // It only returns NOERROR
    _ASSERTE(hr==NOERROR);
}
FCIMPLEND

FCIMPL1 (INT32, COMDecimal::GetHashCode, DECIMAL *d)
{
    double dbl;
    VarR8FromDec(d, &dbl);
    return ((int *)&dbl)[0] ^ ((int *)&dbl)[1];
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Remainder, DECIMAL *result, DECIMAL d2, DECIMAL d1)
{
    // OleAut doesn't provide a VarDecMod.
    // Formula:  d1 - (RoundTowardsZero(d1 / d2) * d2)
	DECIMAL tmp;
	// This piece of code is to work around the fact that Dividing a decimal with 28 digits number by decimal which causes
	// causes the result to be 28 digits, can cause to be incorrectly rounded up.
	// eg. Decimal.MaxValue / 2 * Decimal.MaxValue will overflow since the division by 2 was rounded instead of being truncked.
	// In the operation x % y the sign of y does not matter. Result will have the sign of x.
	if (d1.sign == 0) {
		d2.sign = 0;
		if (VarDecCmp(&d1,&d2) < 1) {
			*result = d1;
			return;
		}
	} else {
		d2.sign = 0x80; // Set the sign bit to negative
		if (VarDecCmp(&d1,&d2) > 1) {
			*result = d1;
			return;
		}
	}

	VarDecSub(&d1, &d2, &tmp);

	d1 = tmp;
	HRESULT hr = VarDecDiv(&d1, &d2, &tmp);
    if (hr < 0) {
        if (hr == DISP_E_DIVBYZERO) FCThrowVoid(kDivideByZeroException);
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    }
    // VarDecFix rounds towards 0.
    hr = VarDecFix(&tmp, result);
    if (FAILED(hr)) {
        _ASSERTE(!"VarDecFix failed in Decimal::Mod");
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    }

    hr = VarDecMul(&d2, result, &tmp);
    if (FAILED(hr)) {
        _ASSERTE(!"VarDecMul failed in Decimal::Mod");
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    }

    hr = VarDecSub(&d1, &tmp, result);
    if (FAILED(hr)) {
        _ASSERTE(!"VarDecSub failed in Decimal::Mod");
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    }
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Multiply, DECIMAL *result, DECIMAL d2, DECIMAL d1)
{
    if (VarDecMul(&d1, &d2, result) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Round, DECIMAL *result, DECIMAL d, INT32 decimals)
{
    if (decimals < 0 || decimals > 28)
        FCThrowArgumentOutOfRangeVoid(L"decimals", L"ArgumentOutOfRange_DecimalRound");
    if (VarDecRound(&d, decimals, result) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL3 (void, COMDecimal::Subtract, DECIMAL *result, DECIMAL d2, DECIMAL d1)
{
    if (VarDecSub(&d1, &d2, result) < 0)
        FCThrowResVoid(kOverflowException, L"Overflow_Decimal");
    result->wReserved = 0;
}
FCIMPLEND

FCIMPL2 (void, COMDecimal::ToCurrency, CY *result, DECIMAL d)
{
    HRESULT hr;
    if ((hr = VarCyFromDec(&d, result)) < 0) {
        _ASSERTE(hr != E_INVALIDARG);
        FCThrowResVoid(kOverflowException, L"Overflow_Currency");
    }
}
FCIMPLEND

FCIMPL1 (double, COMDecimal::ToDouble, DECIMAL d)
{
    double result;
    VarR8FromDec(&d, &result);
    return result;
}
FCIMPLEND

FCIMPL1 (float, COMDecimal::ToSingle, DECIMAL d)
{
    float result;
    VarR4FromDec(&d, &result);
    return result;
}
FCIMPLEND

LPVOID COMDecimal::ToString(ToStringArgs * args) {
    BSTR bstr;
    STRINGREF result;
    VarBstrFromDec(&args->d, 0, 0, &bstr);
    result = COMString::NewString(bstr, SysStringLen(bstr));
    SysFreeString(bstr);
    RETURN(result, STRINGREF);
}

FCIMPL2 (void, COMDecimal::Truncate, DECIMAL *result, DECIMAL d)
{
    VarDecFix(&d, result);
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdecimal.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMDECIMAL_H_
#define _COMDECIMAL_H_

#include <oleauto.h>

#pragma pack(push)
#pragma pack(1)

class COMDecimal {
public:
    struct ToStringArgs {
        DECLARE_ECALL_DEFAULT_ARG(DECIMAL, d);
    };

    static FCDECL2 (void, InitSingle, DECIMAL *_this, R4 value);
    static FCDECL2 (void, InitDouble, DECIMAL *_this, R8 value);
    static FCDECL3 (void, Add, DECIMAL *result, DECIMAL d2, DECIMAL d1);
    static FCDECL2 (INT32, Compare, DECIMAL d1, DECIMAL d2);
    static FCDECL3 (void, Divide, DECIMAL *result, DECIMAL d2, DECIMAL d1);
    static FCDECL2 (void, Floor, DECIMAL *result, DECIMAL d);
    static FCDECL1 (INT32, GetHashCode, DECIMAL *d);
    static FCDECL3 (void, Remainder, DECIMAL *result, DECIMAL d2, DECIMAL d1);
    static FCDECL3 (void, Multiply, DECIMAL *result, DECIMAL d2, DECIMAL d1);
    static FCDECL3 (void, Round, DECIMAL *result, DECIMAL d, INT32 decimals);
    static FCDECL3 (void, Subtract, DECIMAL *result, DECIMAL d2, DECIMAL d1);
    static FCDECL2 (void, ToCurrency, CY *result, DECIMAL d);
    static FCDECL1 (double, ToDouble, DECIMAL d);
    static FCDECL1 (float, ToSingle, DECIMAL d);
    static LPVOID __stdcall ToString(ToStringArgs *);
    static FCDECL2 (void, Truncate, DECIMAL *result, DECIMAL d);
};

#pragma pack(pop)

#endif _COMDECIMAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdatetime.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMDateTime.h"

const INT64 COMDateTime::TicksPerMillisecond = 10000;
const INT64 COMDateTime::TicksPerSecond = TicksPerMillisecond * 1000;
const INT64 COMDateTime::TicksPerMinute = TicksPerSecond * 60;
const INT64 COMDateTime::TicksPerHour = TicksPerMinute * 60;
const INT64 COMDateTime::TicksPerDay = TicksPerHour * 24;

const INT64 COMDateTime::MillisPerSecond = 1000;
const INT64 COMDateTime::MillisPerDay = MillisPerSecond * 60 * 60 * 24;

const int COMDateTime::DaysPer4Years = 365 * 4 + 1;
const int COMDateTime::DaysPer100Years = DaysPer4Years * 25 - 1;
const int COMDateTime::DaysPer400Years = DaysPer100Years * 4 + 1;
// Number of days from 1/1/0001 to 1/1/10000
const int COMDateTime::DaysTo10000 = DaysPer400Years * 25 - 366;

const int COMDateTime::DaysTo1899 = DaysPer400Years * 4 + DaysPer100Years * 3 - 367;

const INT64 COMDateTime::DoubleDateOffset = DaysTo1899 * TicksPerDay;
// OA Min Date is Jan 1, 100 AD.  This is after converting to ticks.
const INT64 COMDateTime::OADateMinAsTicks = (DaysPer100Years - 365) * TicksPerDay;
// All OA dates must be greater than (not >=) OADateMinAsDouble
const double COMDateTime::OADateMinAsDouble = -657435.0;
// All OA dates must be less than (not <=) OADateMaxAsDouble
const double COMDateTime::OADateMaxAsDouble = 2958466.0;

const INT64 COMDateTime::MaxTicks = DaysTo10000 * TicksPerDay;
const INT64 COMDateTime::MaxMillis = DaysTo10000 * MillisPerDay;

FCIMPL0(INT64, COMDateTime::FCGetSystemFileTime) {
//      SYSTEMTIME st;
//      INT64 result;
//      GetLocalTime(&st);
//      SystemTimeToFileTime(&st, (FILETIME *)&result);
//      return result;

    //This simply becomes GetSystemTime when we convert to being based on UTC.
    INT64   time;
#ifdef PLATFORM_CE
	SYSTEMTIME systime;
	GetSystemTime(&systime);
	SystemTimeToFileTime(&systime, (FILETIME *) &time);
#else // !PLATFORM_CE
    GetSystemTimeAsFileTime((FILETIME *) &time);
#endif // PLATFORM_CE

    VERIFY(FileTimeToLocalFileTime((FILETIME *) &time, (FILETIME *) &time));

    FC_GC_POLL_RET();
    return time;
}
FCIMPLEND

// This function is duplicated in DateTime.cool
INT64 COMDateTime::DoubleDateToTicks(const double d)
{
	THROWSCOMPLUSEXCEPTION();
	// Make sure this date is a valid OleAut date.  This is the check from the internal
	// OleAut macro IsValidDate, found in oledisp.h.  Eventually at least the 64 bit
	// build of oleaut will define these gregorian max and min values as public constants.
	if (d >= OADateMaxAsDouble || d <= OADateMinAsDouble)
		COMPlusThrow(kArgumentException, L"Arg_OleAutDateInvalid");

	INT64 millis = (INT64)(d * MillisPerDay + (d >= 0? 0.5: -0.5));
	if (millis < 0) millis -= (millis % MillisPerDay) * 2;
    // There are cases when we are very close to -1 and 1 in which case millis%MillisPerDay is 0 since we have exactly one day due to rounding issues.
    millis += DoubleDateOffset / TicksPerMillisecond;

    if (millis < 0 || millis >= MaxMillis) {
        COMPlusThrow(kArgumentException, L"Arg_OleAutDateScale");  // Cannot be equal to MaxMillis.
	}
	return millis * TicksPerMillisecond;
}

// This function is duplicated in DateTime.cool
double COMDateTime::TicksToDoubleDate(INT64 ticks)
{
	THROWSCOMPLUSEXCEPTION();
	// OleAut will eventually have #defines to the effect of
	// OA_DATE_MIN_GRE (Gregorian min double date value).  Once Bill Evans
	// puts these into OleAut32 and we use those headers to build the runtime,
	// use those numbers here.

	// Ugly hack to handle uninitialized DateTime objects in COM+.
	// See explanation in DateTime.cool's TicksToOADate function.

	if (ticks == 0)
		return 0.0;  // OA's 0 date (12/30/1899).

	if (ticks < OADateMinAsTicks) {
        //We've special-cased day 0 (01/01/0001 in the Gregorian Calendar) such that that
        //date can be used to represent a DateTime the contains only a time.  OA uses
        //day 0 (12/30/1899) for the same purpose, so we'll do a mapping from our day 0
        //to their day 0.
        if (ticks < TicksPerDay) {
            ticks+=DoubleDateOffset;
        } else {
            COMPlusThrow(kOverflowException, L"Arg_OleAutDateInvalid");
        }
    }

	INT64 millis = (ticks  - DoubleDateOffset) / TicksPerMillisecond;
	if (millis < 0) {
		INT64 frac = millis % MillisPerDay;
		if (frac != 0) millis -= (MillisPerDay + frac) * 2;
	}
	double d = (double)millis / MillisPerDay;
	// Make sure this date is a valid OleAut date.  This is the check from the internal
	// OleAut macro IsValidDate, found in oledisp.h.  Eventually at least the 64 bit
	// build of oleaut will define these gregorian max and min values as public constants.
	_ASSERTE(d < OADateMaxAsDouble && d > OADateMinAsDouble);
	return d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdatetime.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMDATETIME_H_
#define _COMDATETIME_H_

#include <oleauto.h>
#include "fcall.h"

#pragma pack(push)
#pragma pack(1)

class COMDateTime {
    static const INT64 TicksPerMillisecond;
    static const INT64 TicksPerSecond;
    static const INT64 TicksPerMinute;
    static const INT64 TicksPerHour;
    static const INT64 TicksPerDay;

    static const INT64 MillisPerSecond;
	static const INT64 MillisPerDay;

    static const int DaysPer4Years;
    static const int DaysPer100Years;
    static const int DaysPer400Years;
    // Number of days from 1/1/0001 to 1/1/10000
    static const int DaysTo10000;

	static const int DaysTo1899;

	static const INT64 DoubleDateOffset;
	static const INT64 OADateMinAsTicks;  // in ticks
	static const double OADateMinAsDouble;
	static const double OADateMaxAsDouble;

	static const INT64 MaxTicks;
	static const INT64 MaxMillis;

public:
    static FCDECL0(INT64, FCGetSystemFileTime);

	// Native util functions for other classes.
	static INT64 DoubleDateToTicks(const double d);  // From OleAut Date
	static double TicksToDoubleDate(const INT64 ticks);
};

#pragma pack(pop)

#endif _COMDATETIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdelegate.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module contains the implementation of the native methods for the
//  Delegate class.
//
// Author: Daryl Olander
// Date: June 1998
////////////////////////////////////////////////////////////////////////////////
#include "common.h"
#include "COMDelegate.h"
#include "COMClass.h"
#include "InvokeUtil.h"
#include "COMMember.h"
#include "excep.h"
#include "class.h"
#include "field.h"
#include "utsem.h"
#include "nexport.h"
#include "ndirect.h"
#include "remoting.h"
#include "jumptargettable.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif //CUSTOMER_CHECKED_BUILD

FieldDesc*  COMDelegate::m_pORField = 0;    // Object reference field...
FieldDesc*  COMDelegate::m_pFPField = 0;    // Function Pointer Address field...
FieldDesc*  COMDelegate::m_pFPAuxField = 0; // Aux Function Pointer field
FieldDesc*  COMDelegate::m_pPRField = 0;    // Prev delegate field (Multicast)
FieldDesc*  COMDelegate::m_pMethInfoField = 0;  // Method Info
FieldDesc*  COMDelegate::m_ppNextField = 0;  // pNext info
ShuffleThunkCache *COMDelegate::m_pShuffleThunkCache = NULL; 
ArgBasedStubCache *COMDelegate::m_pMulticastStubCache = NULL;

MethodTable* COMDelegate::s_pIAsyncResult = 0;
MethodTable* COMDelegate::s_pAsyncCallback = 0;

VOID GenerateShuffleArray(PCCOR_SIGNATURE pSig,
                          Module*         pModule,
                          ShuffleEntry   *pShuffleEntryArray);

class ShuffleThunkCache : public MLStubCache
{
    private:
        //---------------------------------------------------------
        // Compile a static delegate shufflethunk. Always returns
        // STANDALONE since we don't interpret these things.
        //---------------------------------------------------------
        virtual MLStubCompilationMode CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *pstublinker,
                                                    void *callerContext)
        {
            MLStubCompilationMode ret = INTERPRETED;
            COMPLUS_TRY
            {

                ((CPUSTUBLINKER*)pstublinker)->EmitShuffleThunk((ShuffleEntry*)pRawMLStub);
                ret = STANDALONE;
            }
            COMPLUS_CATCH
            {
                // In case of an error, we'll just leave the mode as "INTERPRETED."
                // and let the caller of Canonicalize() treat that as an error.
            }
            COMPLUS_END_CATCH
            return ret;
        }

        //---------------------------------------------------------
        // Tells the MLStubCache the length of a ShuffleEntryArray.
        //---------------------------------------------------------
        virtual UINT Length(const BYTE *pRawMLStub)
        {
            ShuffleEntry *pse = (ShuffleEntry*)pRawMLStub;
            while (pse->srcofs != pse->SENTINEL)
            {
                pse++;
            }
            return sizeof(ShuffleEntry) * (UINT)(1 + (pse - (ShuffleEntry*)pRawMLStub));
        }


};



// One time init.
BOOL COMDelegate::Init()
{
    if (NULL == (m_pShuffleThunkCache = new ShuffleThunkCache()))
    {
        return FALSE;
    }
    if (NULL == (m_pMulticastStubCache = new ArgBasedStubCache()))
    {
        return FALSE;
    }

    return TRUE;
}

// Termination
#ifdef SHOULD_WE_CLEANUP
void COMDelegate::Terminate()
{
    delete m_pMulticastStubCache;
    delete m_pShuffleThunkCache;
}
#endif /* SHOULD_WE_CLEANUP */

void COMDelegate::InitFields()
{
    if (m_pORField == NULL)
    {
        m_pORField = g_Mscorlib.GetField(FIELD__DELEGATE__TARGET);
        m_pFPField = g_Mscorlib.GetField(FIELD__DELEGATE__METHOD_PTR);
        m_pFPAuxField = g_Mscorlib.GetField(FIELD__DELEGATE__METHOD_PTR_AUX);
        m_pPRField = g_Mscorlib.GetField(FIELD__MULTICAST_DELEGATE__NEXT);
        m_ppNextField = g_Mscorlib.GetField(FIELD__MULTICAST_DELEGATE__NEXT);
        m_pMethInfoField = g_Mscorlib.GetField(FIELD__DELEGATE__METHOD);
    }
}

// InternalCreate
// Internal Create is called from the constructor.  It does the internal
//  initialization of the Delegate.
void __stdcall COMDelegate::InternalCreate(_InternalCreateArgs* args)
{
    
    WCHAR* method;
    EEClass* pVMC;
    EEClass* pDelEEC;
    MethodDesc* pMeth;

    THROWSCOMPLUSEXCEPTION();
    COMClass::EnsureReflectionInitialized();
    InitFields();

    method = args->methodName->GetBuffer();

    // get the signature of the 
    pDelEEC = args->refThis->GetClass();
    MethodDesc* pInvokeMeth = FindDelegateInvokeMethod(pDelEEC);

    pVMC = args->target->GetTrueClass();
    _ASSERTE(pVMC);

    // Convert the signature and find it for this object  
    // We don't throw exceptions from this block because of the CQuickBytes
    //  has a destructor.

    // Convert the method name to UTF8
    // Allocate a buffer twice the size of the length
    WCHAR* wzStr = args->methodName->GetBuffer();
    int len = args->methodName->GetStringLength();
    _ASSERTE(wzStr);
    _ASSERTE(len >= 0);

    int cStr = len * 3;
    LPUTF8 szNameStr = (LPUTF8) _alloca((cStr+1) * sizeof(char));
    cStr = WszWideCharToMultiByte(CP_UTF8, 0, wzStr, len, szNameStr, cStr, NULL, NULL);
    szNameStr[cStr] = 0;

    // Convert the signatures and find the method.
    PCCOR_SIGNATURE pSignature; // The signature of the found method
    DWORD cSignature;
    if(pInvokeMeth) {
        pInvokeMeth->GetSig(&pSignature,&cSignature);
        pMeth = pVMC->FindMethod(szNameStr, pSignature, cSignature,pInvokeMeth->GetModule(), 
                                 mdTokenNil, NULL, !args->ignoreCase);
    }
    else
        pMeth = NULL;

    // The method wasn't found or is a static method we need to throw an exception
    if (!pMeth || pMeth->IsStatic())
        COMPlusThrow(kArgumentException,L"Arg_DlgtTargMeth");

    RefSecContext sCtx;
    sCtx.SetClassOfInstance(pVMC);
    InvokeUtil::CheckAccess(&sCtx,
                            pMeth->GetAttrs(),
                            pMeth->GetMethodTable(),
                            REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_MEMBERACCESS);
    InvokeUtil::CheckLinktimeDemand(&sCtx,
                                    pMeth,
                                    true);

    m_pORField->SetRefValue((OBJECTREF)args->refThis, args->target);

    if (pMeth->IsVirtual())
        m_pFPField->SetValuePtr((OBJECTREF)args->refThis, (void*)pMeth->GetAddrofCode(args->target));
    else
        m_pFPField->SetValuePtr((OBJECTREF)args->refThis, (void*)pMeth->GetAddrofCodeNonVirtual()); 
}

// InternalCreateStatic
// Internal Create is called from the constructor. The method must
//  be a static method.
void __stdcall COMDelegate::InternalCreateStatic(_InternalCreateStaticArgs* args)
{
    WCHAR* method;
    EEClass* pDelEEC;
    EEClass* pEEC;

    THROWSCOMPLUSEXCEPTION();
    COMClass::EnsureReflectionInitialized();
    InitFields();

    method = args->methodName->GetBuffer();


    // get the signature of the 
    pDelEEC = args->refThis->GetClass();
    MethodDesc* pInvokeMeth = FindDelegateInvokeMethod(pDelEEC);
    _ASSERTE(pInvokeMeth);

    ReflectClass* pRC = (ReflectClass*) args->target->GetData();
    _ASSERTE(pRC);

    // Convert the method name to UTF8
    // Allocate a buffer twice the size of the length
    WCHAR* wzStr = args->methodName->GetBuffer();
    int len = args->methodName->GetStringLength();
    _ASSERTE(wzStr);
    _ASSERTE(len >= 0);

    int cStr = len * 3;
    LPUTF8 szNameStr = (LPUTF8) _alloca((cStr+1) * sizeof(char));
    cStr = WszWideCharToMultiByte(CP_UTF8, 0, wzStr, len, szNameStr, cStr, NULL, NULL);
    szNameStr[cStr] = 0;

    // Convert the signatures and find the method.
    PCCOR_SIGNATURE pInvokeSignature; // The signature of the found method
    DWORD cSignature;
    pInvokeMeth->GetSig(&pInvokeSignature,&cSignature);

    // Invoke has the HASTHIS bit set, we have to unset it 
    PCOR_SIGNATURE pSignature = (PCOR_SIGNATURE) _alloca(cSignature);
    memcpy(pSignature, pInvokeSignature, cSignature);
    *pSignature &= ~IMAGE_CEE_CS_CALLCONV_HASTHIS;  // This is a static delegate, 


    pEEC = pRC->GetClass();
    MethodDesc* pMeth = pEEC->FindMethod(szNameStr, pSignature, cSignature, 
                                         pInvokeMeth->GetModule(), mdTokenNil);
    if (!pMeth || !pMeth->IsStatic())
        COMPlusThrow(kArgumentException,L"Arg_DlgtTargMeth");

    RefSecContext sCtx;
    InvokeUtil::CheckAccess(&sCtx,
                            pMeth->GetAttrs(),
                            pMeth->GetMethodTable(),
                            REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_MEMBERACCESS);
    InvokeUtil::CheckLinktimeDemand(&sCtx,
                                    pMeth,
                                    true);

    m_pORField->SetRefValue((OBJECTREF)args->refThis, (OBJECTREF)args->refThis);
    m_pFPAuxField->SetValuePtr((OBJECTREF)args->refThis, pMeth->GetPreStubAddr());


    DelegateEEClass *pDelCls = (DelegateEEClass*) pDelEEC;
    Stub *pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
    if (!pShuffleThunk) {
        MethodDesc *pInvokeMethod = pDelCls->m_pInvokeMethod;
        UINT allocsize = sizeof(ShuffleEntry) * (3+pInvokeMethod->SizeOfVirtualFixedArgStack()/STACK_ELEM_SIZE); 

#ifndef _DEBUG
        // This allocsize prediction is easy to break, so in retail, add
        // some fudge to be safe.
        allocsize += 3*sizeof(ShuffleEntry);
#endif

        ShuffleEntry *pShuffleEntryArray = (ShuffleEntry*)_alloca(allocsize);

#ifdef _DEBUG
        FillMemory(pShuffleEntryArray, allocsize, 0xcc);
#endif
        GenerateShuffleArray(pInvokeMethod->GetSig(), 
                             pInvokeMethod->GetModule(), 
                             pShuffleEntryArray);
        MLStubCache::MLStubCompilationMode mode;
        pShuffleThunk = m_pShuffleThunkCache->Canonicalize((const BYTE *)pShuffleEntryArray, &mode);
        if (!pShuffleThunk || mode != MLStubCache::STANDALONE) {
            COMPlusThrowOM();
        }
        if (VipInterlockedCompareExchange( (void*volatile*) &(pDelCls->m_pStaticShuffleThunk),
                                            pShuffleThunk,
                                            NULL ) != NULL) {
            pShuffleThunk->DecRef();
            pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
        }
    }


    m_pFPField->SetValuePtr((OBJECTREF)args->refThis,(void*)(pShuffleThunk->GetEntryPoint()));
}


// FindDelegateInvokeMethod
//
// Finds the compiler-generated "Invoke" method for delegates. pcls
// must be derived from the "Delegate" class.
//
// @todo: static delegates are not supported by classlibs yet but will be.
// this code will need to be updated when that happens.
MethodDesc * COMDelegate::FindDelegateInvokeMethod(EEClass *pcls)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pcls->IsAnyDelegateClass())
        return NULL;

    DelegateEEClass *pDcls = (DelegateEEClass *) pcls;

    if (pDcls->m_pInvokeMethod == NULL) {
        COMPlusThrowNonLocalized(kMissingMethodException, L"Invoke");
        return NULL;
    }
    else
        return pDcls->m_pInvokeMethod;
}



// Marshals a delegate to a unmanaged callback.
LPVOID COMDelegate::ConvertToCallback(OBJECTREF pDelegate)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pDelegate) {
        return NULL;
    } else {

        LPVOID pCode;
        GCPROTECT_BEGIN(pDelegate);

        _ASSERTE(4 == sizeof(UMEntryThunk*));

        UMEntryThunk *pUMEntryThunk = NULL;
        SyncBlock *pSyncBlock = pDelegate->GetSyncBlockSpecial();
        if (pSyncBlock != NULL)
            pUMEntryThunk = (UMEntryThunk*)pSyncBlock->GetUMEntryThunk();
        if (!pUMEntryThunk) {

            MethodDesc *pMeth = GetMethodDesc(pDelegate);

            DelegateEEClass *pcls = (DelegateEEClass*)(pDelegate->GetClass());
            UMThunkMarshInfo *pUMThunkMarshInfo = pcls->m_pUMThunkMarshInfo;
            MethodDesc *pInvokeMeth = FindDelegateInvokeMethod(pcls);

            if (!pUMThunkMarshInfo) {
                pUMThunkMarshInfo = new UMThunkMarshInfo();
                if (!pUMThunkMarshInfo) {
                    COMPlusThrowOM();
                }

                PCCOR_SIGNATURE pSig;
                DWORD cSig;
                pInvokeMeth->GetSig(&pSig, &cSig);

                CorPinvokeMap unmanagedCallConv = MetaSig::GetUnmanagedCallingConvention(pInvokeMeth->GetModule(), pSig, cSig);
                if (unmanagedCallConv == (CorPinvokeMap)0 || unmanagedCallConv == (CorPinvokeMap)pmCallConvWinapi)
                {
                    unmanagedCallConv = pInvokeMeth->IsVarArg() ? pmCallConvCdecl : pmCallConvStdcall;
                }

                pUMThunkMarshInfo->CompleteInit(pSig, cSig, pInvokeMeth->GetModule(), pInvokeMeth->IsStatic(), nltAnsi, unmanagedCallConv, pInvokeMeth->GetMemberDef());            


                if (VipInterlockedCompareExchange( (void*volatile*) &(pcls->m_pUMThunkMarshInfo),
                                                   pUMThunkMarshInfo,
                                                   NULL ) != NULL) {
                    delete pUMThunkMarshInfo;
                    pUMThunkMarshInfo = pcls->m_pUMThunkMarshInfo;
                }
            }

            _ASSERTE(pUMThunkMarshInfo != NULL);
            _ASSERTE(pUMThunkMarshInfo == pcls->m_pUMThunkMarshInfo);


            pUMEntryThunk = UMEntryThunk::CreateUMEntryThunk();
            if (!pUMEntryThunk) {
                COMPlusThrowOM();
            }//@todo: IMMEDIATELY Leaks.
            OBJECTHANDLE objhnd = NULL;
            BOOL fSuccess = FALSE;
            EE_TRY_FOR_FINALLY {
                if (pInvokeMeth->GetClass()->IsDelegateClass()) {

                    
                    // singlecast delegate: just go straight to target method
                    if (NULL == (objhnd = GetAppDomain()->CreateLongWeakHandle(m_pORField->GetRefValue(pDelegate)))) {
                        COMPlusThrowOM();
                    }
                    if (pMeth->IsIL() &&
                        !(pMeth->IsStatic()) &&
                        pMeth->IsJitted()) {
                        // MethodDesc is passed in for profiling to know the method desc of target
                        pUMEntryThunk->CompleteInit(NULL, objhnd,    
                                                    pUMThunkMarshInfo, pMeth,
                                                    GetAppDomain()->GetId());
                    } else {
                        // Pass in NULL as last parameter to indicate no associated MethodDesc
                        pUMEntryThunk->CompleteInit((const BYTE *)(m_pFPField->GetValuePtr(pDelegate)),
                                                    objhnd, pUMThunkMarshInfo, NULL,
                                                    GetAppDomain()->GetId());
                    }
                } else {
                    // multicast. go thru Invoke
                    if (NULL == (objhnd = GetAppDomain()->CreateLongWeakHandle(pDelegate))) {
                        COMPlusThrowOM();
                    }
                    // MethodDesc is passed in for profiling to know the method desc of target
                    pUMEntryThunk->CompleteInit((const BYTE *)(pInvokeMeth->GetPreStubAddr()), objhnd,
                                                pUMThunkMarshInfo, pInvokeMeth,
                                                GetAppDomain()->GetId());
                }
                                fSuccess = TRUE;
            } EE_FINALLY {
                if (!fSuccess && objhnd != NULL) {
                    DestroyLongWeakHandle(objhnd);
                }
            } EE_END_FINALLY
            
            if (!pSyncBlock->SetUMEntryThunk(pUMEntryThunk)) {
                UMEntryThunk::FreeUMEntryThunk(pUMEntryThunk);
                pUMEntryThunk = (UMEntryThunk*)pSyncBlock->GetUMEntryThunk();
            }

            _ASSERTE(pUMEntryThunk != NULL);
            _ASSERTE(pUMEntryThunk == (UMEntryThunk*)(UMEntryThunk*)pSyncBlock->GetUMEntryThunk()); 

        }
        pCode = (LPVOID)pUMEntryThunk->GetCode();
        GCPROTECT_END();
        return pCode;
    }
}



// Marshals an unmanaged callback to Delegate
OBJECTREF COMDelegate::ConvertToDelegate(LPVOID pCallback)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pCallback) {
        return NULL;
    } else {

#ifdef _X86_
        if (*((BYTE*)pCallback) != 0xb8 ||
            ( ((size_t)pCallback) & 3) != 2) {

#ifdef CUSTOMER_CHECKED_BUILD
            CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
            if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_FunctionPtr))
            {
                pCdh->LogInfo(L"Marshaling function pointers as delegates is currently not supported.", CustomerCheckedBuildProbe_FunctionPtr);
            }
#endif // CUSTOMER_CHECKED_BUILD

            COMPlusThrow(kArgumentException, IDS_EE_NOTADELEGATE);
        }
#endif
        UMEntryThunk *pUMEntryThunk = *(UMEntryThunk**)( 1 + (BYTE*)pCallback ); 
        return ObjectFromHandle(pUMEntryThunk->GetObjectHandle());


    }
}



// This is the single constructor for all Delegates.  The compiler
//  doesn't provide an implementation of the Delegate constructor.  We
//  provide that implementation through an ECall call to this method.


CPUSTUBLINKER* GenerateStubLinker()
{
        return new CPUSTUBLINKER;
}// GenerateStubLinker

void FreeStubLinker(CPUSTUBLINKER* csl)
{
    delete csl;
}// FreeStubLinker
void __stdcall COMDelegate::DelegateConstruct(_DelegateConstructArgs* args)
{

    THROWSCOMPLUSEXCEPTION();

    InitFields();

    // From VB, programmers could feed garbage data to DelegateConstruct().
    // It's difficult to validate a method code pointer, but at least we'll
    // try to catch the easy garbage.
    __try {
        BYTE probe = *((BYTE*)(args->method));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        COMPlusThrowArgumentNull(L"method",L"Arg_ArgumentOutOfRangeException");
    }
    _ASSERTE(args->refThis);
    _ASSERTE(args->method);
    
    MethodTable *pMT = NULL;
    MethodTable *pRealMT = NULL;

    if (args->target != NULL)
    {
        pMT = args->target->GetMethodTable();
        pRealMT = pMT->AdjustForThunking(args->target);
    }

    MethodDesc *pMeth = Entry2MethodDesc((BYTE*)args->method, pRealMT);

    //
    // If target is a contextful class, then it must be a proxy
    //    
    _ASSERTE((NULL == pMT) || pMT->IsTransparentProxyType() || !pRealMT->IsContextful());

    EEClass* pDel = args->refThis->GetClass();
    // Make sure we call the <cinit>
    OBJECTREF Throwable;
    if (!pDel->DoRunClassInit(&Throwable)) {
        COMPlusThrow(Throwable);
    }

    _ASSERTE(pMeth);

#ifdef _DEBUG
    // Assert that everything is cool...This is not some bogus
    //  address...Very unlikely that the code below would work
    //  for a random address in memory....
    MethodTable* p = pMeth->GetMethodTable();
    _ASSERTE(p);
    EEClass* cls = pMeth->GetClass();
    _ASSERTE(cls);
    _ASSERTE(cls == p->GetClass());
#endif

    // Static method.
    if (!args->target || pMeth->IsStatic()) {

        // if this is a not a static method throw...
        if (!pMeth->IsStatic())
            COMPlusThrow(kNullReferenceException,L"Arg_DlgtTargMeth");


        m_pORField->SetRefValue((OBJECTREF)args->refThis, (OBJECTREF)args->refThis);
#ifdef _IA64_
        m_pFPAuxField->SetValue64((OBJECTREF)args->refThis,(size_t)pMeth->GetPreStubAddr());
#else // !_IA64_
        m_pFPAuxField->SetValue32((OBJECTREF)args->refThis,(DWORD)(size_t)pMeth->GetPreStubAddr());
#endif // _IA64_


        DelegateEEClass *pDelCls = (DelegateEEClass*)(args->refThis->GetClass());
        Stub *pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
        if (!pShuffleThunk) {
            MethodDesc *pInvokeMethod = pDelCls->m_pInvokeMethod;
            UINT allocsize = sizeof(ShuffleEntry) * (3+pInvokeMethod->SizeOfVirtualFixedArgStack()/STACK_ELEM_SIZE); 

#ifndef _DEBUG
            // This allocsize prediction is easy to break, so in retail, add
            // some fudge to be safe.
            allocsize += 3*sizeof(ShuffleEntry);
#endif

            ShuffleEntry *pShuffleEntryArray = (ShuffleEntry*)_alloca(allocsize);
#ifdef _DEBUG
            FillMemory(pShuffleEntryArray, allocsize, 0xcc);
#endif
            GenerateShuffleArray(pInvokeMethod->GetSig(), 
                                 pInvokeMethod->GetModule(), 
                                 pShuffleEntryArray);
            MLStubCache::MLStubCompilationMode mode;
            pShuffleThunk = m_pShuffleThunkCache->Canonicalize((const BYTE *)pShuffleEntryArray, &mode);
            if (!pShuffleThunk || mode != MLStubCache::STANDALONE) {
                COMPlusThrowOM();
            }
            if (VipInterlockedCompareExchange( (void*volatile*) &(pDelCls->m_pStaticShuffleThunk),
                                                pShuffleThunk,
                                                NULL ) != NULL) {
                pShuffleThunk->DecRef();
                pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
            }
        }


        m_pFPField->SetValuePtr((OBJECTREF)args->refThis, (void*)pShuffleThunk->GetEntryPoint());

    } else {
        EEClass* pTarg = args->target->GetClass();
        EEClass* pMethClass = pMeth->GetClass();

        if (!pMT->IsThunking())
        {
            if (pMethClass != pTarg) {
                //They cast to an interface before creating the delegate, so we now need 
                //to figure out where this actually lives before we continue.
                //@perf:  Grovelling with a signature is really slow.  Speed this up.
                if (pMethClass->IsInterface())  {
                    // No need to resolve the interface based method desc to a class based
                    // one for COM objects because we invoke directly thru the interface MT.
                    if (!pTarg->GetMethodTable()->IsComObjectType())
                        {
                        DWORD cSig=1024;
                        PCCOR_SIGNATURE sig = (PCCOR_SIGNATURE)_alloca(cSig);
                        pMeth->GetSig(&sig, &cSig);
                        pMeth = pTarg->FindMethod(pMeth->GetName(),
                                                  sig, cSig,
                                                  pMeth->GetModule(), 
                                                  mdTokenNil);
                    }
                }
            }

            // Use the Unboxing stub for value class methods, since the value
            // class is constructed using the boxed instance.
    
            if (pTarg->IsValueClass() && !pMeth->IsUnboxingStub())
            {
                // If these are Object/ValueType.ToString().. etc,
                // don't need an unboxing Stub.

                if ((pMethClass != g_pValueTypeClass->GetClass()) 
                    && (pMethClass != g_pObjectClass->GetClass()))
                {
                    MethodDesc* pBak = pMeth;
                    pMeth = pTarg->GetUnboxingMethodDescForValueClassMethod(pMeth);

                    if (pMeth == NULL) 
                    {

                        CPUSTUBLINKER *slUnBox = GenerateStubLinker();
                        slUnBox->EmitUnboxMethodStub(pBak);
                        // <TODO> Figure out how we can cache and reuse this stub</TODO>
                        Stub *sUnBox = slUnBox->Link(pBak->GetClass()->GetClassLoader()->GetStubHeap());
                        args->method = (BYTE*)sUnBox->GetEntryPoint();
                        FreeStubLinker(slUnBox);
                    }
                }
            }

            if (pMeth != NULL)
            {
                // Set the target address of this subclass
                args->method = (byte *)(pMeth->GetUnsafeAddrofCode());
            }
        }

        m_pORField->SetRefValue((OBJECTREF)args->refThis, args->target);
#ifdef _IA64_
        m_pFPField->SetValue64((OBJECTREF)args->refThis,(size_t)(args->method));
#else // !_IA64_
        m_pFPField->SetValue32((OBJECTREF)args->refThis,(DWORD)(size_t)args->method);
#endif // _IA64_
        }        
    }


// This method will validate that the target method for a delegate
//  and the delegate's invoke method have compatible signatures....
bool COMDelegate::ValidateDelegateTarget(MethodDesc* pMeth,EEClass* pDel)
{
    return true;
}
// GetMethodPtr
// Returns the FieldDesc* for the MethodPtr field
FieldDesc* COMDelegate::GetMethodPtr()
{
    if (!m_pFPField)
        InitFields();
    return m_pFPField;
}


MethodDesc *COMDelegate::GetMethodDesc(OBJECTREF orDelegate)
{
    // First, check for a static delegate
    void *code = (void *) m_pFPAuxField->GetValuePtr((OBJECTREF)orDelegate);
    if (code == NULL)
    {
        // Must be a normal delegate
        code = (void *) m_pFPField->GetValuePtr((OBJECTREF)orDelegate);

        // Weird case - need to check for a prejit vtable fixup stub.
        // @nice - could put this logic in GetUnkMethodDescForSlotAddress, but we 
        // would need a method table ptr & it's static
        if (StubManager::IsStub((const BYTE *)code))
    {
            OBJECTREF orThis = m_pORField->GetRefValue(orDelegate);
            MethodDesc *pMD = StubManager::MethodDescFromEntry((const BYTE *) code, 
                                                               orThis->GetTrueMethodTable());
            if (pMD != NULL)
                return pMD;
    }
}

    return EEClass::GetUnknownMethodDescForSlotAddress((SLOT)code);
}

// GetMethodPtrAux
// Returns the FieldDesc* for the MethodPtrAux field
FieldDesc* COMDelegate::GetMethodPtrAux()
{
    if (!m_pFPAuxField)
        InitFields();

    _ASSERTE(m_pFPAuxField);
    return m_pFPAuxField;
}

// GetOR
// Returns the FieldDesc* for the Object reference field
FieldDesc* COMDelegate::GetOR()
{
    if (!m_pORField)
        InitFields();

    _ASSERTE(m_pORField);
    return m_pORField;
}

// GetpNext
// Returns the FieldDesc* for the pNext field
FieldDesc* COMDelegate::GetpNext()
{
    if (!m_ppNextField)
        InitFields();

    _ASSERTE(m_ppNextField);
    return m_ppNextField;
}

// Decides if pcls derives from Delegate.
BOOL COMDelegate::IsDelegate(EEClass *pcls)
{
    return pcls->IsAnyDelegateExact() || pcls->IsAnyDelegateClass();
}

VOID GenerateShuffleArray(PCCOR_SIGNATURE pSig,
                          Module*         pModule,
                          ShuffleEntry   *pShuffleEntryArray)
{
    THROWSCOMPLUSEXCEPTION();

    // Must create independent msigs to prevent the argiterators from
    // interfering with other.
    MetaSig msig1(pSig, pModule);
    MetaSig msig2(pSig, pModule);

    ArgIterator    aisrc(NULL, &msig1, FALSE);
    ArgIterator    aidst(NULL, &msig2, TRUE);

    UINT stacksizedelta = MetaSig::SizeOfActualFixedArgStack(pModule, pSig, FALSE) -
                          MetaSig::SizeOfActualFixedArgStack(pModule, pSig, TRUE);


    UINT srcregofs,dstregofs;
    INT  srcofs,   dstofs;
    UINT cbSize;
    BYTE typ;

        if (msig1.HasRetBuffArg())
        {
                int offsetIntoArgumentRegisters;
                int numRegisterUsed = 1;
                // the first register is used for 'this'
                if (IsArgumentInRegister(&numRegisterUsed, ELEMENT_TYPE_PTR, 4, FALSE,
                        msig1.GetCallingConvention(), &offsetIntoArgumentRegisters))
                        pShuffleEntryArray->srcofs = ShuffleEntry::REGMASK | offsetIntoArgumentRegisters;
                else
                        _ASSERTE (!"ret buff arg has to be in a register");

                numRegisterUsed = 0;
                if (IsArgumentInRegister(&numRegisterUsed, ELEMENT_TYPE_PTR, 4, FALSE,
                        msig2.GetCallingConvention(), &offsetIntoArgumentRegisters))
                        pShuffleEntryArray->dstofs = ShuffleEntry::REGMASK | offsetIntoArgumentRegisters;
                else
                        _ASSERTE (!"ret buff arg has to be in a register");

                pShuffleEntryArray ++;
        }

    while (0 != (srcofs = aisrc.GetNextOffset(&typ, &cbSize, &srcregofs)))
    {
        dstofs = aidst.GetNextOffset(&typ, &cbSize, &dstregofs) + stacksizedelta;

        cbSize = StackElemSize(cbSize);

        srcofs -= FramedMethodFrame::GetOffsetOfReturnAddress();
        dstofs -= FramedMethodFrame::GetOffsetOfReturnAddress();

        
        while (cbSize)
        {
            if (srcregofs == (UINT)(-1))
            {
                pShuffleEntryArray->srcofs = srcofs;
            }
            else
            {
                pShuffleEntryArray->srcofs = ShuffleEntry::REGMASK | srcregofs;
            }
            if (dstregofs == (UINT)(-1))
            {
                pShuffleEntryArray->dstofs = dstofs;
            }
            else
            {
                pShuffleEntryArray->dstofs = ShuffleEntry::REGMASK | dstregofs;
            }
            srcofs += STACK_ELEM_SIZE;
            dstofs += STACK_ELEM_SIZE;

            if (pShuffleEntryArray->srcofs != pShuffleEntryArray->dstofs)
            {
                pShuffleEntryArray++;
            }
            cbSize -= STACK_ELEM_SIZE;
        }
    }

    // Emit code to move the return address
    pShuffleEntryArray->srcofs = 0;     // retaddress is assumed to be at esp
    pShuffleEntryArray->dstofs = stacksizedelta;

    pShuffleEntryArray++;

    pShuffleEntryArray->srcofs = ShuffleEntry::SENTINEL;
    pShuffleEntryArray->dstofs = (UINT16)stacksizedelta;


}

// Get the cpu stub for a delegate invoke.
Stub *COMDelegate::GetInvokeMethodStub(CPUSTUBLINKER *psl, EEImplMethodDesc* pMD)
{
    THROWSCOMPLUSEXCEPTION();

    DelegateEEClass *pClass = (DelegateEEClass*) pMD->GetClass();

    if (pMD == pClass->m_pInvokeMethod)
    {
        // Validate the invoke method, which at the moment just means checking the calling convention

        if (*pMD->GetSig() != (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_DEFAULT))
            COMPlusThrow(kInvalidProgramException);

        // skip down to code for invoke
    }
    else if (pMD == pClass->m_pBeginInvokeMethod)
    {
        if (!InitializeRemoting())
        {
            _ASSERTE(!"Remoting initialization failure.");
        }
        if (!ValidateBeginInvoke(pClass))           
            COMPlusThrow(kInvalidProgramException);

        Stub *ret = TheDelegateStub();
        ret->IncRef();
        return ret;
    }
    else if (pMD == pClass->m_pEndInvokeMethod)
    {
        if (!InitializeRemoting())
        {
            _ASSERTE(!"Remoting initialization failure.");
        }
        if (!ValidateEndInvoke(pClass))         
            COMPlusThrow(kInvalidProgramException);
        Stub *ret = TheDelegateStub();   
        ret->IncRef();
        return ret;
    }
    else
    {
        _ASSERTE(!"Bad Delegate layout");
        COMPlusThrow(kExecutionEngineException);
    }

    _ASSERTE(pMD->GetClass()->IsAnyDelegateClass());

    UINT numStackBytes = pMD->SizeOfActualFixedArgStack();
    _ASSERTE(!(numStackBytes & 3));
    UINT hash = numStackBytes;

    // check if the function is returning a float, in which case the stub has to take
    // care of popping the floating point stack except for the last invocation
    MetaSig sig(pMD->GetSig(), pMD->GetModule());
    BOOL bReturnFloat = CorTypeInfo::IsFloat(sig.GetReturnType());

    if (pMD->GetClass()->IsSingleDelegateClass())
    {
        hash |= 1;
    }
    else
    {
        if (bReturnFloat) 
        {
            hash |= 2;
        }
    }


    Stub *pStub = m_pMulticastStubCache->GetStub(hash);
    if (pStub) {
        return pStub;
    } else {
        LOG((LF_CORDB,LL_INFO10000, "COMD::GIMS making a multicast delegate\n"));

        psl->EmitMulticastInvoke(numStackBytes, pMD->GetClass()->IsDelegateClass(), bReturnFloat);

        UINT cbSize;
        Stub *pCandidate = psl->Link(SystemDomain::System()->GetStubHeap(), &cbSize, TRUE);

        Stub *pWinner = m_pMulticastStubCache->AttemptToSetStub(hash,pCandidate);
        pCandidate->DecRef();
        if (!pWinner) {
            COMPlusThrowOM();
        }
    
        LOG((LF_CORDB,LL_INFO10000, "Putting a MC stub at 0x%x (code:0x%x)\n",
            pWinner, (BYTE*)pWinner+sizeof(Stub)));

        return pWinner;
    }

}

LPVOID __stdcall COMDelegate::InternalAlloc(_InternalAllocArgs* args)
{
    ReflectClass* pRC = (ReflectClass*) args->target->GetData();
    _ASSERTE(pRC);
    EEClass* pEEC = pRC->GetClass();
    OBJECTREF obj = pEEC->GetMethodTable()->Allocate();
    LPVOID  rv; 
    *((OBJECTREF*) &rv) = obj;
    return rv;
}

// InternalCreateMethod
// This method will create initalize a delegate based upon a MethodInfo
//      for a static method.
void __stdcall COMDelegate::InternalCreateMethod(_InternalCreateMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
        // Intialize reflection
    COMClass::EnsureReflectionInitialized();
    InitFields();

    ReflectMethod* pRMTarget = (ReflectMethod*) args->targetMethod->GetData();
    _ASSERTE(pRMTarget);
    MethodDesc* pTarget = pRMTarget->pMethod;
    PCCOR_SIGNATURE pTSig;
    DWORD TSigCnt;
    pTarget->GetSig(&pTSig,&TSigCnt);
    
    ReflectMethod* pRMInvoke = (ReflectMethod*) args->invokeMeth->GetData();
    _ASSERTE(pRMInvoke);
    MethodDesc* pInvoke = pRMInvoke->pMethod;
    PCCOR_SIGNATURE pISig;
    DWORD ISigCnt;
    pInvoke->GetSig(&pISig,&ISigCnt);

    // the target method must be static, validated in Managed.
    _ASSERTE(pTarget->IsStatic());

    // Validate that the signature of the Invoke method and the 
    //      target method are exactly the same, except for the staticness.
    // (The Invoke method on Delegate is always non-static since it needs
    //  the this pointer for the Delegate (not the this pointer for the target), 
    //  so we must make the sig non-static before comparing sigs.)
    PCOR_SIGNATURE tmpSig = (PCOR_SIGNATURE) _alloca(ISigCnt);
    memcpy(tmpSig, pISig, ISigCnt);
    *((byte*)tmpSig) &= ~IMAGE_CEE_CS_CALLCONV_HASTHIS;

    if (MetaSig::CompareMethodSigs(pTSig,TSigCnt,pTarget->GetModule(),
        tmpSig,ISigCnt,pInvoke->GetModule()) == 0) {
        COMPlusThrow(kArgumentException,L"Arg_DlgtTargMeth");
    }

    EEClass* pDelEEC = args->refThis->GetClass();

    RefSecContext sCtx;
    InvokeUtil::CheckAccess(&sCtx,
                            pTarget->GetAttrs(),
                            pTarget->GetMethodTable(),
                            REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_MEMBERACCESS);
    InvokeUtil::CheckLinktimeDemand(&sCtx,
                                    pTarget,
                                    true);
    GetMethodPtrAux();

    m_pORField->SetRefValue((OBJECTREF)args->refThis, (OBJECTREF)args->refThis);
    m_pFPAuxField->SetValuePtr((OBJECTREF)args->refThis, pTarget->GetPreStubAddr());

    DelegateEEClass *pDelCls = (DelegateEEClass*) pDelEEC;
    Stub *pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
    if (!pShuffleThunk) {
        MethodDesc *pInvokeMethod = pDelCls->m_pInvokeMethod;
        UINT allocsize = sizeof(ShuffleEntry) * (3+pInvokeMethod->SizeOfVirtualFixedArgStack()/STACK_ELEM_SIZE); 

#ifndef _DEBUG
        // This allocsize prediction is easy to break, so in retail, add
        // some fudge to be safe.
        allocsize += 3*sizeof(ShuffleEntry);
#endif

        ShuffleEntry *pShuffleEntryArray = (ShuffleEntry*)_alloca(allocsize);
#ifdef _DEBUG
        FillMemory(pShuffleEntryArray, allocsize, 0xcc);
#endif
        GenerateShuffleArray(pInvokeMethod->GetSig(), 
                             pInvokeMethod->GetModule(), 
                             pShuffleEntryArray);
        MLStubCache::MLStubCompilationMode mode;
        pShuffleThunk = m_pShuffleThunkCache->Canonicalize((const BYTE *)pShuffleEntryArray, &mode);
        if (!pShuffleThunk || mode != MLStubCache::STANDALONE) {
            COMPlusThrowOM();
        }
        if (VipInterlockedCompareExchange( (void*volatile*) &(pDelCls->m_pStaticShuffleThunk),
                                            pShuffleThunk,
                                            NULL ) != NULL) {
            pShuffleThunk->DecRef();
            pShuffleThunk = pDelCls->m_pStaticShuffleThunk;
        }
    }


    m_pFPField->SetValuePtr((OBJECTREF)args->refThis, (void*)pShuffleThunk->GetEntryPoint());

    // Now set the MethodInfo in the delegate itself and we are done.    
    m_pMethInfoField->SetRefValue((OBJECTREF)args->refThis, (OBJECTREF)args->targetMethod);
}

// InternalGetMethodInfo
// This method will get the MethodInfo for a delegate
LPVOID __stdcall COMDelegate::InternalFindMethodInfo(_InternalFindMethodInfoArgs* args)
{
    MethodDesc *pMD = GetMethodDesc((OBJECTREF) args->refThis);

    REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) pMD->GetClass()->GetExposedClassObject();
    LPVOID rt = NULL;
    GCPROTECT_BEGIN(pRefClass);
    ReflectMethod* pRM= ((ReflectClass*) pRefClass->GetData())->FindReflectMethod(pMD);
    OBJECTREF objMeth = (OBJECTREF) pRM->GetMethodInfo((ReflectClass*) pRefClass->GetData());
    rt = (LPVOID) OBJECTREFToObject(objMeth);
    GCPROTECT_END();
    return rt;
}

/*
    Does a static validation of parameters passed into a delegate constructor.

    Params:
    pFtn  : MethodDesc of the function pointer used to create the delegate
    pDlgt : The delegate type
    pInst : Type of the instance, from which pFtn is obtained. Ignored if pFtn 
            is static.

    Validates the following conditions:
    1.  If the function is not static, pInst should be equal to the type where 
        pFtn is defined or pInst should be a parent of pFtn's type.
    2.  The signature of the function should be compatible with the signature
        of the Invoke method of the delegate type.

 */
/* static */
BOOL COMDelegate::ValidateCtor(MethodDesc *pFtn, EEClass *pDlgt, EEClass *pInst)
{
    _ASSERTE(pFtn);
    _ASSERTE(pDlgt);

    /* Abstract is ok, since the only way to get a ftn of a an abstract method
       is via ldvirtftn, and we don't allow instantiation of abstract types.
       ldftn on abstract types is illegal.
    if (pFtn->IsAbstract())
        return FALSE;       // Cannot use an abstact method
    */
    if (!pFtn->IsStatic())
    {
        if (pInst == NULL)
            goto skip_inst_check;   // Instance missing, this will result in a 
                                    // NullReferenceException at runtime on Invoke().

        EEClass *pClsOfFtn = pFtn->GetClass();

        if (pClsOfFtn != pInst)
        {
            // If class of method is an interface, verify that
            // the interface is implemented by this instance.
            if (pClsOfFtn->IsInterface())
            {
                MethodTable *pMTOfFtn;
                InterfaceInfo_t *pImpl;

                pMTOfFtn = pClsOfFtn->GetMethodTable();
                pImpl = pInst->GetInterfaceMap();

                for (int i = 0; i < pInst->GetNumInterfaces(); i++)
                {
                    if (pImpl[i].m_pMethodTable == pMTOfFtn)
                        goto skip_inst_check;
                }
            }

            // Type of pFtn should be Equal or a parent type of pInst

            EEClass *pObj = pInst;

            do {
                pObj = pObj->GetParentClass();
            } while (pObj && (pObj != pClsOfFtn));

            if (pObj == NULL)
                return FALSE;   // Function pointer is not that of the instance
        }
    }

skip_inst_check:
    // Check the number and type of arguments

    MethodDesc *pDlgtInvoke;        // The Invoke() method of the delegate
    Module *pModDlgt, *pModFtn;     // Module where the signature is present
    PCCOR_SIGNATURE pSigDlgt, pSigFtn, pEndSigDlgt, pEndSigFtn; // Signature
    DWORD cSigDlgt, cSigFtn;        // Length of the signature
    DWORD nArgs;                    // Number of arguments

    pDlgtInvoke = COMDelegate::FindDelegateInvokeMethod(pDlgt);

    if (pDlgtInvoke->IsStatic())
        return FALSE;               // Invoke cannot be Static.

    pDlgtInvoke->GetSig(&pSigDlgt, &cSigDlgt);
    pFtn->GetSig(&pSigFtn, &cSigFtn);

    pModDlgt = pDlgtInvoke->GetModule();
    pModFtn = pFtn->GetModule();

    if ((*pSigDlgt & IMAGE_CEE_CS_CALLCONV_MASK) != 
        (*pSigFtn & IMAGE_CEE_CS_CALLCONV_MASK))
        return FALSE; // calling convention mismatch

    // The function pointer should never be a vararg
    if ((*pSigFtn & IMAGE_CEE_CS_CALLCONV_MASK) == IMAGE_CEE_CS_CALLCONV_VARARG)
        return FALSE; // Vararg function pointer

    // Check the number of arguments
    pSigDlgt++; pSigFtn++;

    pEndSigDlgt = pSigDlgt + cSigDlgt;
    pEndSigFtn = pSigFtn + cSigFtn;

    nArgs = CorSigUncompressData(pSigDlgt);

    if (CorSigUncompressData(pSigFtn) != nArgs)
        return FALSE;   // number of arguments don't match

    // do return type as well
    for (DWORD i = 0; i<=nArgs; i++)
    {
        if (MetaSig::CompareElementType(pSigDlgt, pSigFtn,
                pEndSigDlgt, pEndSigFtn, pModDlgt, pModFtn) == FALSE)
            return FALSE; // Argument types don't match
    }

    return TRUE;
}

BOOL COMDelegate::ValidateBeginInvoke(DelegateEEClass* pClass)
{
    _ASSERTE(pClass->m_pBeginInvokeMethod);
    if (pClass->m_pInvokeMethod == NULL) 
        return FALSE;

    MetaSig beginInvokeSig(pClass->m_pBeginInvokeMethod->GetSig(), pClass->GetModule());
    MetaSig invokeSig(pClass->m_pInvokeMethod->GetSig(), pClass->GetModule());

    if (beginInvokeSig.GetCallingConventionInfo() != (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_DEFAULT))
        return FALSE;

    if (beginInvokeSig.NumFixedArgs() != invokeSig.NumFixedArgs() + 2)
        return FALSE;

    if (s_pIAsyncResult == 0) {
        s_pIAsyncResult = g_Mscorlib.FetchClass(CLASS__IASYNCRESULT);
        if (s_pIAsyncResult == 0)
            return FALSE;
    }

    OBJECTREF throwable = NULL; 
    bool result = FALSE;
    GCPROTECT_BEGIN(throwable);
    if (beginInvokeSig.GetRetTypeHandle(&throwable) != TypeHandle(s_pIAsyncResult) || throwable != NULL)
        goto exit;

    while(invokeSig.NextArg() != ELEMENT_TYPE_END) {
        beginInvokeSig.NextArg();
        if (beginInvokeSig.GetTypeHandle(&throwable) != invokeSig.GetTypeHandle(&throwable) || throwable != NULL)
            goto exit;
    }

    if (s_pAsyncCallback == 0) {
        s_pAsyncCallback = g_Mscorlib.FetchClass(CLASS__ASYNCCALLBACK);
        if (s_pAsyncCallback == 0)
            goto exit;
    }

    beginInvokeSig.NextArg();
    if (beginInvokeSig.GetTypeHandle(&throwable)!= TypeHandle(s_pAsyncCallback) || throwable != NULL)
        goto exit;

    beginInvokeSig.NextArg();
    if (beginInvokeSig.GetTypeHandle(&throwable)!= TypeHandle(g_pObjectClass) || throwable != NULL)
        goto exit;

    _ASSERTE(beginInvokeSig.NextArg() == ELEMENT_TYPE_END);

    result = TRUE;
exit:
    GCPROTECT_END();
    return result;
}

BOOL COMDelegate::ValidateEndInvoke(DelegateEEClass* pClass)
{
    _ASSERTE(pClass->m_pEndInvokeMethod);
    if (pClass->m_pInvokeMethod == NULL) 
        return FALSE;

    MetaSig endInvokeSig(pClass->m_pEndInvokeMethod->GetSig(), pClass->GetModule());
    MetaSig invokeSig(pClass->m_pInvokeMethod->GetSig(), pClass->GetModule());

    if (endInvokeSig.GetCallingConventionInfo() != (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_DEFAULT))
        return FALSE;

    OBJECTREF throwable = NULL;
    bool result = FALSE;
    GCPROTECT_BEGIN(throwable);
    if (endInvokeSig.GetRetTypeHandle(&throwable) != invokeSig.GetRetTypeHandle(&throwable) || throwable != NULL)
        goto exit;

    CorElementType type;
    while((type = invokeSig.NextArg()) != ELEMENT_TYPE_END) {
        if (type == ELEMENT_TYPE_BYREF) {
            endInvokeSig.NextArg();
            if (endInvokeSig.GetTypeHandle(&throwable) != invokeSig.GetTypeHandle(&throwable) || throwable != NULL)
                goto exit;
        }
    }

    if (s_pIAsyncResult == 0) {
        s_pIAsyncResult = g_Mscorlib.FetchClass(CLASS__IASYNCRESULT);
        if (s_pIAsyncResult == 0)
            goto exit;
    }

    if (endInvokeSig.NextArg() == ELEMENT_TYPE_END)
        goto exit;

    if (endInvokeSig.GetTypeHandle(&throwable) != TypeHandle(s_pIAsyncResult) || throwable != NULL)
        goto exit;

    if (endInvokeSig.NextArg() != ELEMENT_TYPE_END)
        goto exit;

    result = TRUE;
exit:
    GCPROTECT_END();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdelegate.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This module contains the native methods for the delegate class
//
// Author: Daryl Olander
// Date: June 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMDELEGATE_H_
#define _COMDELEGATE_H_

class Stub;
class EEClass;
class ShuffleThunkCache;

#include "cgensys.h"
#include "nexport.h"
#include "COMVariant.h"
#include "mlcache.h"

// This class represents the native methods for the Delegate class
class COMDelegate
{
private:
        struct _InternalCreateArgs      {
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
                DECLARE_ECALL_I1_ARG(bool, ignoreCase);
                DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, methodName);
                DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
        };
        struct _InternalCreateStaticArgs        {
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
                DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, methodName);
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, target);
        };
        struct _InternalCreateMethodArgs        {
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, targetMethod);
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, invokeMeth);
        };
        struct _InternalFindMethodInfoArgs      {
                DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
        };
        struct _InternalFinalizeArgs    {
                DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis); 
        };

        // This method will validate that the target method for a delegate
        //      and the delegate's invoke method have compatible signatures....
        static bool ValidateDelegateTarget(MethodDesc* pMeth,EEClass* pDel);

    friend VOID CPUSTUBLINKER::EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat);
    friend VOID CPUSTUBLINKER::EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray);
    friend BOOL StubLinkStubManager::TraceManager(Thread *thread, 
                                                  TraceDestination *trace,
                                                  CONTEXT *pContext, 
                                                  BYTE **pRetAddr);
    friend BOOL StubLinkStubManager::IsStaticDelegate(BYTE *pbDel);
    friend BYTE **StubLinkStubManager::GetStaticDelegateRealDest(BYTE *pbDel);
    friend BYTE **StubLinkStubManager::GetSingleDelegateRealDest(BYTE *pbDel);
    friend BOOL MulticastFrame::TraceFrame(Thread *thread, BOOL fromPatch, 
                                TraceDestination *trace, REGDISPLAY *regs);

    static FieldDesc* m_pORField;       // Object reference field...
    static FieldDesc* m_pFPField;   // Function Pointer Address field...
    static FieldDesc* m_pPRField;   // _prev field (MulticastDelegate)
    static FieldDesc* m_pFPAuxField; // aux field for statics
    static FieldDesc* m_pMethInfoField;     // Method Info
    static FieldDesc* m_ppNextField;     // Method Info


    static ArgBasedStubCache *m_pMulticastStubCache;

	static MethodTable* s_pIAsyncResult;	// points to System.IAsyncResult's method table
	static MethodTable* s_pAsyncCallback;	// points to System.AsyncCallBack's method table

public:
    static ShuffleThunkCache *m_pShuffleThunkCache; 

    // One time init.
    static BOOL Init();

    // Termination
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    // Initialize fields
    static void InitFields();

    struct _DelegateConstructArgs   {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
#ifdef _IA64_
        DECLARE_ECALL_I8_ARG(SLOT, method);
#else // !_IA64_
        DECLARE_ECALL_I4_ARG(SLOT, method);
#endif // _IA64_
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
    };
    static void __stdcall DelegateConstruct(_DelegateConstructArgs*);


    struct _InternalAllocArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, target);
    };
    static LPVOID __stdcall InternalAlloc(_InternalAllocArgs* args);



    // InternalCreate
    // Internal Create is called from the constructor.  It does the internal
    //      initialization of the Delegate.
    static void __stdcall InternalCreate(_InternalCreateArgs*);

    // InternalCreateStatic
    // Internal Create is called from the constructor. The method must
    //      be a static method.
    static void __stdcall InternalCreateStatic(_InternalCreateStaticArgs*);

    // InternalCreateMethod
    // This method will create initalize a delegate based upon a MethodInfo
    //      for a static method.
    static void __stdcall InternalCreateMethod(_InternalCreateMethodArgs*);

    // InternalFindMethodInfo
    // This gets the MethodInfo for a delegate, creating it if necessary
    static LPVOID __stdcall InternalFindMethodInfo(_InternalFindMethodInfoArgs*);

   // Finalize
    // Called as part of gc finalization. Clean up the associated NExport thunk
    // if any.
    static void __stdcall Finalize(_InternalFinalizeArgs*);

    // Marshals a delegate to a unmanaged callback.
    static LPVOID ConvertToCallback(OBJECTREF pDelegate);

    // Marshals an unmanaged callback to Delegate
    static OBJECTREF ConvertToDelegate(LPVOID pCallback);

    // Decides if pcls derives from Delegate.
    static BOOL IsDelegate(EEClass *pcls);

    // GetMethodPtr
    // Returns the FieldDesc* for the MethodPtr field
    static FieldDesc* GetMethodPtr();

    // GetMethodAuxPtr
    // Returns the FieldDesc* for the MethodPtrAux field
    static FieldDesc* GetMethodPtrAux();

    // GetOR
    // Returns the FieldDesc* for the Object reference field
    static FieldDesc* GetOR();

    // GetDelegateThunkInfo
    // Returns the DelegateThunkInfo field
    static FieldDesc* GetDelegateThunkInfo();
    
    // GetpNext
    // Returns the pNext field
    static FieldDesc* GetpNext();

    // Get the cpu stub for a delegate invoke.
    static Stub *GetInvokeMethodStub(CPUSTUBLINKER *psl, EEImplMethodDesc* pMD);

    static MethodDesc * __fastcall GetMethodDesc(OBJECTREF obj);

    static MethodDesc * FindDelegateInvokeMethod(EEClass *pcls);

    // Method to do static validation of delegate .ctor
    static BOOL ValidateCtor(MethodDesc *pFtn, EEClass *pDlgt, EEClass *pInst);
private:
	static BOOL ValidateBeginInvoke(DelegateEEClass* pClass);		// make certain the BeginInvoke method is consistant with the Invoke Method
	static BOOL ValidateEndInvoke(DelegateEEClass* pClass);		// make certain the EndInvoke method is consistant with the Invoke Method
};


// Want no unused bits in ShuffleEntry since unused bits can make
// equivalent ShuffleEntry arrays look unequivalent and deoptimize our
// hashing.
#pragma pack(push, 1)

// To handle a call to a static delegate, we create an array of ShuffleEntry
// structures. Each entry instructs the shuffler to move a chunk of bytes.
// The size of the chunk is StackElemSize (typically a DWORD): long arguments
// have to be expressed as multiple ShuffleEntry's.
//
// The ShuffleEntry array serves two purposes:
//
//  1. A platform-indepedent blueprint for creating the platform-specific
//     shuffle thunk.
//  2. A hash key for finding the shared shuffle thunk for a particular
//     signature.
struct ShuffleEntry
{
    enum {
        REGMASK  = 0x8000,
        OFSMASK  = 0x7fff,
        SENTINEL = 0xffff,
    };

    // Special values:
    //  -1       - indicates end of shuffle array: stacksizedelta
    //             == difference in stack size between virtual and static sigs.
    //  high bit - indicates a register argument: mask it off and
    //             the result is an offset into ArgumentRegisters.
    UINT16    srcofs;
    union {
        UINT16    dstofs;           //if srcofs != SENTINEL
        UINT16    stacksizedelta;   //if dstofs == SENTINEL
    };
};


#pragma pack(pop)

#endif  // _COMDELEGATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdynamic.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// COMDynamic.h
//  This module defines the native methods that are used for Dynamic IL generation  
//
// Author: Daryl Olander
// Date: November 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "Field.h"
#include "COMDynamic.h"
#include "COMModule.h"
#include "ReflectClassWriter.h"
#include "CorError.h"
#include "ICeeFileGen.h"
#include <UtilCode.h>
#include "COMString.h"
#include "COMDateTime.h"  // DateTime <-> OleAut date conversions
#include "StrongName.h"
#include "CeeFileGenWriter.h"
#include "COMClass.h"


//This structure is used in CWSetMethodIL to walk the exceptions.
//It maps to M/R/Reflection/__ExceptionInstance.class
//DO NOT MOVE ANY OF THE FIELDS WITHOUT SPEAKING WITH JROXE
#pragma pack(push)
#pragma pack(1)
typedef struct {
    INT32 m_exceptionType;
    INT32 m_start;
    INT32 m_end;
	INT32 m_filterOffset;
    INT32 m_handle;
    INT32 m_handleEnd;
    INT32 m_type;
} ExceptionInstance;
#pragma pack(pop)


//*************************************************************
// 
// Defining a type into metadata of this dynamic module
//
//*************************************************************
void __stdcall COMDynamicWrite::CWCreateClass(_CWCreateClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT             hr;
    DWORD               attrsFlagI = 0; 
    mdTypeRef           parentClassRefE = mdTypeRefNil; 
    mdTypeRef           *crImplements;
    mdTypeDef           classE; 
    RefClassWriter*     pRCW;   
    DWORD               numInterfaces;
    GUID *              pGuid=NULL;
    REFLECTMODULEBASEREF pReflect;

    _ASSERTE(args->module);
    // Get the module for the creator of the ClassWriter
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule); 

    pRCW = GetReflectionModule(pModule)->GetClassWriter();
    _ASSERTE(pRCW);

    // Set up the Interfaces
    if (args->interfaces!=NULL) {
        unsigned        i = 0;
        crImplements = (mdTypeRef *)_alloca(32 * sizeof(mdTypeRef));
        numInterfaces = args->interfaces->GetNumComponents();
        int *pImplements = (int *)args->interfaces->GetDataPtr();
        for (i=0; i<(INT32)numInterfaces; i++) {
            crImplements[i] = pImplements[i];
        }
        crImplements[i]=mdTypeRefNil;
    } else {
        crImplements=NULL;
    }

    //We know that this space has been allocated because value types cannot be null.
    //If both halves of the guid are 0, we were handed the empty guid and so should
    //pass null to DefineTypeDef.
    //
    if (((INT64 *)(&args->guid))[0]!=0 && ((INT64 *)(&args->guid))[1]!=0) {
        pGuid = &args->guid;
    }

    if (RidFromToken(args->tkEnclosingType))
    {
        // defining nested type
        hr = pRCW->GetEmitter()->DefineNestedType(args->strFullName->GetBuffer(), 
                                               args->attr, 
                                               args->parent == 0 ? mdTypeRefNil : args->parent, 
                                               crImplements,  
                                               args->tkEnclosingType,
                                               &classE);
    }
    else
    {
        // top level type
        hr = pRCW->GetEmitter()->DefineTypeDef(args->strFullName->GetBuffer(), 
                                               args->attr, 
                                               args->parent == 0 ? mdTypeRefNil : args->parent, 
                                               crImplements,  
                                               &classE);
    }

    if (hr == META_S_DUPLICATE) 
    {
        COMPlusThrow(kArgumentException, L"Argument_DuplicateTypeName");
    } 

    if (FAILED(hr)) {
        _ASSERTE(!"DefineTypeDef Failed");
        COMPlusThrowHR(hr);    
    }

    *(args->retRef)=(INT32)classE;
}

// CWSetParentType
// ClassWriter.InternalSetParentType -- This function will reset the parent class in metadata
void __stdcall COMDynamicWrite::CWSetParentType(_CWSetParentTypeArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    HRESULT hr;   

    RefClassWriter* pRCW;   

    REFLECTMODULEBASEREF      pReflect;
    pReflect = (REFLECTMODULEBASEREF) args->refThis;

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Define the Method    
    IfFailGo( pRCW->GetEmitHelper()->SetTypeParent(args->tdType, args->tkParent) );
ErrExit:
    if (FAILED(hr)) {   
        _ASSERTE(!"DefineMethod Failed on Method"); 
        COMPlusThrowHR(hr);    
    }   

}

// CWAddInterfaceImpl
// ClassWriter.InternalAddInterfaceImpl -- This function will add another interface impl
void __stdcall COMDynamicWrite::CWAddInterfaceImpl(_CWAddInterfaceImplArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    HRESULT hr;   

    RefClassWriter* pRCW;   

    REFLECTMODULEBASEREF      pReflect;
    pReflect = (REFLECTMODULEBASEREF) args->refThis;

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    IfFailGo( pRCW->GetEmitHelper()->AddInterfaceImpl(args->tdType, args->tkInterface) );
ErrExit:
    if (FAILED(hr)) {   
        _ASSERTE(!"DefineMethod Failed on Method"); 
        COMPlusThrowHR(hr);    
    }   

}


// CWCreateMethod
// ClassWriter.CreateMethod -- This function will create a method within the class
void __stdcall COMDynamicWrite::CWCreateMethod(_CWCreateMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();   
    HRESULT hr; 
    mdMethodDef memberE; 
    UINT32 attributes;
    PCCOR_SIGNATURE pcSig;
    

    _ASSERTE(args->name);   
    RefClassWriter* pRCW;   

    REFLECTMODULEBASEREF      pReflect;
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    _ASSERTE(args->signature);
    //Ask module for our signature.
    pcSig = (PCCOR_SIGNATURE)args->signature->GetDataPtr();

    //Get the attributes
    attributes = args->attributes;

    // Define the Method    
    IfFailGo( pRCW->GetEmitter()->DefineMethod(args->handle,	    //ParentTypeDef
                                          args->name->GetBuffer(),	//Name of Member
                                          attributes,				//Member Attributes (public, etc);
                                          pcSig,					//Blob value of a COM+ signature
                                          args->sigLength,			//Size of the signature blob
                                          0,						//Code RVA
                                          miIL | miManaged,			//Implementation Flags is default to managed IL
                                          &memberE) );				//[OUT]methodToken

    // Return the token via the hidden param. 
    *(args->retRef)=(INT32)memberE;   

ErrExit:
    if (FAILED(hr)) 
    {   
        _ASSERTE(!"DefineMethod Failed on Method"); 
        COMPlusThrowHR(hr);
    }   

}


/*================================CWCreateField=================================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
mdFieldDef __stdcall COMDynamicWrite::CWCreateField(_cwCreateFieldArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    mdFieldDef FieldDef;
    HRESULT                     hr;
    PCCOR_SIGNATURE pcSig;
    RefClassWriter* pRCW;   

    _ASSERTE(args);
    _ASSERTE(args->signature);

    //Verify the arguments that we can.
    if (args->name==NULL) {
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
    }

    // Get the RefClassWriter
    REFLECTMODULEBASEREF      pReflect;
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter();
    _ASSERTE(pRCW);

    //Ask module for our signature.
    pcSig = (PCCOR_SIGNATURE)args->signature->GetDataPtr();

    //Emit the field.
    IfFailGo( pRCW->GetEmitter()->DefineField(args->handle, 
                                         args->name->GetBuffer(), args->attr, pcSig,
                                         args->sigLength, ELEMENT_TYPE_VOID, NULL, -1, &FieldDef) );


ErrExit:
    if (FAILED(hr)) 
    {
        _ASSERTE(!"DefineField Failed");
        COMPlusThrowHR(hr);
    }    
    return FieldDef;
}


// CWSetMethodIL
// ClassWriter.InternalSetMethodIL -- This function will create a method within the class
void __stdcall COMDynamicWrite::CWSetMethodIL(_CWSetMethodILArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr;
    HCEESECTION         ilSection;
    INT32               *piRelocs;
    INT32               relocCount=0;
    mdSignature         pmLocalSigToken;

    // Get the RefClassWriter   
    RefClassWriter*     pRCW;   

    REFLECTMODULEBASEREF pReflect;
    
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter();
    _ASSERTE(pRCW);
    _ASSERTE(args->localSig);

    PCCOR_SIGNATURE pcSig = (PCCOR_SIGNATURE)args->localSig->GetDataPtr();
	_ASSERTE(*pcSig == IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);

    if (args->sigLength==2 && pcSig[0]==0 && pcSig[1]==0) 
    { 
		
		//This is an empty local variable sig
        pmLocalSigToken=0;
    } 
    else 
    {
        if (FAILED(hr = pRCW->GetEmitter()->GetTokenFromSig( pcSig, args->sigLength, &pmLocalSigToken))) 
        {

            COMPlusThrowHR(hr);    
        }
    }

    COR_ILMETHOD_FAT fatHeader; 

    // set fatHeader.Flags to CorILMethod_InitLocals if user wants to zero init the stack frame.
    //
    fatHeader.Flags              = args->isInitLocal ? CorILMethod_InitLocals : 0;   
    fatHeader.MaxStack           = args->maxStackSize;
    fatHeader.LocalVarSigTok     = pmLocalSigToken;
    fatHeader.CodeSize           = (args->body!=NULL)?args->body->GetNumComponents():0;  
    bool moreSections            = (args->numExceptions != 0);    

    unsigned codeSizeAligned     = fatHeader.CodeSize;  
    if (moreSections)   
        codeSizeAligned          = (codeSizeAligned + 3) & ~3;    // to insure EH section aligned 
    unsigned headerSize          = COR_ILMETHOD::Size(&fatHeader, args->numExceptions != 0);    

    //Create the exception handlers.
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses = args->numExceptions <= 0 ? NULL :
        (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)_alloca(sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)*args->numExceptions);   

    if (args->numExceptions > 0) 
    {
        _ASSERTE(args->exceptions); 
        _ASSERTE((INT32)args->exceptions->GetNumComponents() == args->numExceptions);

        // TODO, if ExceptionInstance was IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT, then this    
        // copy would not be needed 
        ExceptionInstance *exceptions = (ExceptionInstance *)args->exceptions->GetDataPtr();
        for (unsigned int i = 0; i < args->numExceptions; i++) 
        {
            clauses[i].Flags         = (CorExceptionFlag)(exceptions[i].m_type | COR_ILEXCEPTION_CLAUSE_OFFSETLEN);
            clauses[i].TryOffset     = exceptions[i].m_start;
            clauses[i].TryLength     = exceptions[i].m_end - exceptions[i].m_start;			
            clauses[i].HandlerOffset = exceptions[i].m_handle;
            clauses[i].HandlerLength = exceptions[i].m_handleEnd - exceptions[i].m_handle;
			if (exceptions[i].m_type == COR_ILEXCEPTION_CLAUSE_FILTER)
			{
				clauses[i].FilterOffset  = exceptions[i].m_filterOffset;
			}
			else if (exceptions[i].m_type!=COR_ILEXCEPTION_CLAUSE_FINALLY) 
            { 
                clauses[i].ClassToken = exceptions[i].m_exceptionType;
            } 
            else 
            {
                clauses[i].ClassToken = mdTypeRefNil;
            }
        }
    }
    
    unsigned ehSize          = COR_ILMETHOD_SECT_EH::Size(args->numExceptions, clauses);    
    unsigned totalSize       = + headerSize + codeSizeAligned + ehSize; 
    ICeeGen* pGen = pRCW->GetCeeGen();
    BYTE* buf = NULL;
    ULONG methodRVA;
    pGen->AllocateMethodBuffer(totalSize, &buf, &methodRVA);    
    if (buf == NULL)
        COMPlusThrowOM();
        
    _ASSERTE(buf != NULL);
    _ASSERTE((((size_t) buf) & 3) == 0);   // header is dword aligned  

    BYTE* endbuf = &buf[totalSize]; 

    // Emit the header  
    buf += COR_ILMETHOD::Emit(headerSize, &fatHeader, moreSections, buf);   

    //Emit the code    
    //The fatHeader.CodeSize is a hack to see if we have an interface or an
    //abstract method.  Force enough verification in native to ensure that
    //this is true.
    if (fatHeader.CodeSize!=0) {
        memcpy(buf,args->body->GetDataPtr(), fatHeader.CodeSize);
     }
    buf += codeSizeAligned;
        
    // Emit the eh  
    ULONG* ehTypeOffsets = 0;
    if (ehSize > 0) {
        // Allocate space for the the offsets to the TypeTokens in the Exception headers
        // in the IL stream.
        ehTypeOffsets = (ULONG *)_alloca(sizeof(ULONG) * args->numExceptions);
        // Emit the eh.  This will update the array ehTypeOffsets with offsets
        // to Exception type tokens.  The offsets are with reference to the
        // beginning of eh section.
        buf += COR_ILMETHOD_SECT_EH::Emit(ehSize, args->numExceptions, clauses,
                                          false, buf, ehTypeOffsets);
    }   
    _ASSERTE(buf == endbuf);    

    //Get the IL Section.
    if (FAILED(pGen->GetIlSection(&ilSection))) {
        _ASSERTE(!"Unable to get the .il Section.");
        FATAL_EE_ERROR();
    }

    // Token Fixup data...
    ULONG ilOffset = methodRVA + headerSize;

    //Add all of the relocs based on the info which I saved from ILGenerator.
    //Add the RVA Fixups
    if (args->rvaFixups!=NULL) {
        relocCount = args->rvaFixups->GetNumComponents();
        piRelocs = (INT32 *)args->rvaFixups->GetDataPtr();
        for (int i=0; i<relocCount; i++) {
            if (FAILED(pGen->AddSectionReloc(ilSection, piRelocs[i] + ilOffset, ilSection,srRelocAbsolute))) {
                _ASSERTE(!"Unable to add RVA Reloc.");
                FATAL_EE_ERROR();
            }
        }
    }

    if (args->tokenFixups!=NULL) {
        //Add the Token Fixups
        relocCount = args->tokenFixups->GetNumComponents();
        piRelocs = (INT32 *)args->tokenFixups->GetDataPtr();
        for (int i=0; i<relocCount; i++) {
            if (FAILED(pGen->AddSectionReloc(ilSection, piRelocs[i] + ilOffset, ilSection,srRelocMapToken))) {
                _ASSERTE(!"Unable to add Token Reloc.");
                FATAL_EE_ERROR();
            }
        }
    }

    if (ehTypeOffsets) {
        // Add token fixups for exception type tokens.
        for (unsigned int i=0; i < args->numExceptions; i++) {
            if (ehTypeOffsets[i] != -1) {
                if (FAILED(pGen->AddSectionReloc(
                            ilSection,
                            ehTypeOffsets[i] + codeSizeAligned + ilOffset,
                            ilSection,srRelocMapToken))) {
                    _ASSERTE(!"Unable to add Exception Type Token Reloc.");
                    FATAL_EE_ERROR();
                }
            }
        }
    }

    
    //nasty interface hack.  What does this mean for abstract methods?
    if (fatHeader.CodeSize!=0) {
        DWORD       dwImplFlags;
        //Set the RVA of the method.
        pRCW->GetMDImport()->GetMethodImplProps( args->handle, NULL, &dwImplFlags );
        dwImplFlags |= miManaged | miIL;
        hr = pRCW->GetEmitter()->SetMethodProps(args->handle, -1, methodRVA, dwImplFlags);
        if (FAILED(hr)) {
            _ASSERTE(!"SetMethodProps Failed on Method");
            FATAL_EE_ERROR();
        }
    }
}

// CWTermCreateClass
// ClassWriter.TermCreateClass --
LPVOID __stdcall COMDynamicWrite::CWTermCreateClass(_CWTermCreateClassArgs* args)
{
    RefClassWriter*         pRCW;   
    REFLECTMODULEBASEREF    pReflect;
    OBJECTREF               Throwable = NULL;
    OBJECTREF               ret = NULL;
    UINT                    resId = IDS_CLASSLOAD_GENERIC;
 
    THROWSCOMPLUSEXCEPTION();
    
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    // Use the same service, regardless of whether we are generating a normal
    // class, or the special class for the module that holds global functions
    // & methods.
    GetReflectionModule(pModule)->AddClass(args->handle); 

    GCPROTECT_BEGIN(Throwable);
    
    // manually load the class if it is not the global type
    if (!IsNilToken(args->handle))
    {
        TypeHandle typeHnd;
        
        BEGIN_ENSURE_PREEMPTIVE_GC();
        typeHnd = pModule->GetClassLoader()->LoadTypeHandle(pModule, args->handle, &Throwable);
        END_ENSURE_PREEMPTIVE_GC();

        if (typeHnd.IsNull() ||
            (Throwable != NULL) ||
            (typeHnd.GetModule() != pModule))
        {
            // error handling code
            if (Throwable == NULL)
                pModule->GetAssembly()->PostTypeLoadException(pRCW->GetMDImport(), args->handle, resId, &Throwable);

            COMPlusThrow(Throwable);
        }

        ret = typeHnd.CreateClassObj();
    }
    GCPROTECT_END();
    return (ret!=NULL) ? OBJECTREFToObject(ret) : NULL;
}


/*============================InternalSetPInvokeData============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::InternalSetPInvokeData(_internalSetPInvokeDataArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    RefClassWriter      *pRCW;   
    DWORD               dwMappingFlags = 0;
    ULONG               ulImport = 0;
    mdModuleRef         mrImportDll = mdTokenNil;
    HRESULT             hr;

    _ASSERTE(args);
    _ASSERTE(args->dllName);

    Module* pModule = (Module *)args->module->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    IfFailGo(pRCW->GetEmitter()->DefineModuleRef(args->dllName->GetBufferNullable(), &mrImportDll));
    dwMappingFlags = args->linkType | args->linkFlags;
    IfFailGo(pRCW->GetEmitter()->DefinePinvokeMap(
        args->token,                        // the method token 
        dwMappingFlags,                     // the mapping flags
        args->functionName->GetBuffer(),    // function name
        mrImportDll));

    pRCW->GetEmitter()->SetMethodProps(args->token, -1, 0x0, miIL);
ErrExit:
    if (FAILED(hr))
    {
        COMPlusThrowHR(hr);    
    }
}
    

/*============================CWDefineProperty============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWDefineProperty(_CWDefinePropertyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    mdProperty		pr; 
    PCCOR_SIGNATURE pcSig;
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    _ASSERTE((args->signature != NULL) && (args->name!= NULL));

    //Ask module for our signature.
    pcSig = (PCCOR_SIGNATURE)args->signature->GetDataPtr();

    // Define the Property
    hr = pRCW->GetEmitter()->DefineProperty(
			args->handle,					// ParentTypeDef
            args->name->GetBuffer(),		// Name of Member
            args->attr,						// property Attributes (prDefaultProperty, etc);
            pcSig,							// Blob value of a COM+ signature
            args->sigLength,				// Size of the signature blob
			ELEMENT_TYPE_VOID,				// don't specify the default value
            0,								// no default value
            -1,                             // optional length
			mdMethodDefNil,					// no setter
			mdMethodDefNil,					// no getter
			NULL,							// no other methods
			&pr);

    if (FAILED(hr)) {   
        _ASSERTE(!"DefineProperty Failed on Property"); 
        COMPlusThrowHR(hr);    
    }   


    // Return the token via the hidden param. 
    *(args->retRef)=(INT32)pr;   
}



/*============================CWDefineEvent============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWDefineEvent(_CWDefineEventArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    mdProperty		ev; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;


    _ASSERTE(args->name);   

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Define the Event
    hr = pRCW->GetEmitHelper()->DefineEventHelper(
			args->handle,					// ParentTypeDef
            args->name->GetBuffer(),		// Name of Member
            args->attr,						// property Attributes (prDefaultProperty, etc);
			args->eventtype,				// the event type. Can be TypeDef or TypeRef
			&ev);

    if (FAILED(hr)) 
    {   
        _ASSERTE(!"DefineEvent Failed on Event"); 
        COMPlusThrowHR(hr);    
    }   


    // Return the token via the hidden param. 
    *(args->retRef)=(INT32)ev;   
}





/*============================CWDefineMethodSemantics============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWDefineMethodSemantics(_CWDefineMethodSemanticsArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    

    // Define the MethodSemantics
    hr = pRCW->GetEmitHelper()->DefineMethodSemanticsHelper(
			args->association,
			args->attr,
			args->method);
    if (FAILED(hr)) 
    {   
        _ASSERTE(!"DefineMethodSemantics Failed on "); 
        COMPlusThrowHR(hr);    
    }   
}


/*============================CWSetMethodImpl============================
** To set a Method's Implementation flags
==============================================================================*/
void COMDynamicWrite::CWSetMethodImpl(_CWSetMethodImplArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Set the methodimpl flags
    hr = pRCW->GetEmitter()->SetMethodImplFlags(
			args->tkMethod,
			args->attr);				// change the impl flags
    if (FAILED(hr)) {   
        _ASSERTE(!"SetMethodImplFlags Failed"); 
        COMPlusThrowHR(hr);    
    }   
}


/*============================CWDefineMethodImpl============================
** Define a MethodImpl record
==============================================================================*/
void COMDynamicWrite::CWDefineMethodImpl(_CWDefineMethodImplArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Set the methodimpl flags
    hr = pRCW->GetEmitter()->DefineMethodImpl(
			args->tkType,
            args->tkBody,
			args->tkDecl);  				// change the impl flags
    if (FAILED(hr)) {   
        _ASSERTE(!"DefineMethodImpl Failed"); 
        COMPlusThrowHR(hr);    
    }   
}


/*============================CWGetTokenFromSig============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
int COMDynamicWrite::CWGetTokenFromSig(_CWGetTokenFromSigArgs* args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    mdSignature		sig; 
    PCCOR_SIGNATURE pcSig;
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    _ASSERTE(args->signature);

    // get the signature
    pcSig = (PCCOR_SIGNATURE)args->signature->GetDataPtr();

    // Define the signature
    hr = pRCW->GetEmitter()->GetTokenFromSig(
            pcSig,							// Signature blob
            args->sigLength,				// blob length
			&sig);							// returned token

    if (FAILED(hr)) {   
        _ASSERTE(!"GetTokenFromSig Failed"); 
        COMPlusThrowHR(hr);    
    }   


    // Return the token via the hidden param. 
    return  (INT32)sig;   
}



/*============================CWSetParamInfo============================
**Action: Helper to set parameter information
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
int COMDynamicWrite::CWSetParamInfo(_CWSetParamInfoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;
    WCHAR*          wzParamName = args->strParamName->GetBufferNullable();  
    mdParamDef      pd;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Set the methodimpl flags
    hr = pRCW->GetEmitter()->DefineParam(
			args->tkMethod,
			args->iSequence,            // sequence of the parameter
            wzParamName, 
			args->iAttributes,			// change the impl flags
            ELEMENT_TYPE_VOID,
            0,
            -1,
            &pd);
    if (FAILED(hr)) {   
        _ASSERTE(!"DefineParam Failed on "); 
        COMPlusThrowHR(hr);    
    }   
    return (INT32)pd;   
}	// COMDynamicWrite::CWSetParamInfo



/*============================CWSetMarshal============================
**Action: Helper to set marshal information
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWSetMarshal(_CWSetMarshalArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    PCCOR_SIGNATURE pcMarshal;
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    _ASSERTE(args->ubMarshal);

    // get the signature
    pcMarshal = (PCCOR_SIGNATURE)args->ubMarshal->GetDataPtr();

    // Define the signature
    hr = pRCW->GetEmitter()->SetFieldMarshal(
            args->tk,
            pcMarshal,  					// marshal blob
            args->cbMarshal);				// blob length

    if (FAILED(hr)) {   
        _ASSERTE(!"Set FieldMarshal is failing"); 
        COMPlusThrowHR(hr);    
    }   
}	// COMDynamicWrite::CWSetMarshal



/*============================CWSetConstantValue============================
**Action: Helper to set constant value to field or parameter
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWSetConstantValue(_CWSetConstantValueArgs *args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    REFLECTMODULEBASEREF	pReflect; 
    RefClassWriter* pRCW;   
	Module			*pModule;
    DWORD           dwCPlusTypeFlag = 0;
    void            *pValue = NULL;
    OBJECTREF       obj;
    INT64           data;
    int             strLen;


    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    switch (args->varValue.GetType())
    {
        case CV_BOOLEAN:
        case CV_I1:
        case CV_U1:
        case CV_I2:
        case CV_U2:
        case CV_I4:
        case CV_U4:
        case CV_I8:
        case CV_U8:
        case CV_R4: 
        case CV_R8:
            dwCPlusTypeFlag = args->varValue.GetType(); 
            pValue = args->varValue.GetData();
            break;

        case CV_DATETIME:
            // This will get us the tick counts for the datetime
            data = args->varValue.GetDataAsInt64();

            //date is a I8 representation
            dwCPlusTypeFlag = ELEMENT_TYPE_I8;
            pValue = &data;
            break;

        case CV_CURRENCY:
            // currency is a I8 representation
            dwCPlusTypeFlag = ELEMENT_TYPE_I8;
            pValue = args->varValue.GetData();
            break;

        case CV_CHAR:
            // map to ELEMENT_TYPE_CHAR
            pValue = args->varValue.GetData();
            dwCPlusTypeFlag = ELEMENT_TYPE_CHAR;
            break;

        case CV_STRING:
		    if (args->varValue.GetObjRef() == NULL) 
            {
                pValue = NULL;
		    }
            else
            {
                RefInterpretGetStringValuesDangerousForGC((STRINGREF) (args->varValue.GetObjRef()), (WCHAR **)&pValue, &strLen);
            }
            dwCPlusTypeFlag = ELEMENT_TYPE_STRING;
            break;

        case CV_DECIMAL:
            // Decimal is 12 bytes. Don't know how to represent this
        case CV_OBJECT:
            // for DECIMAL and Object, we only support NULL default value.
            // This is a constraint from MetaData.
            //
            obj = args->varValue.GetObjRef();
            if ((obj!=NULL) && (obj->GetData()))
            {
                // can only accept the NULL object
                COMPlusThrow(kArgumentException, L"Argument_BadConstantValue");    
            }

            // fail through

        case CV_NULL:
            dwCPlusTypeFlag = ELEMENT_TYPE_CLASS;
            pValue = NULL;
            break;

        case CV_ENUM:
            // always map the enum value to a I4 value
            dwCPlusTypeFlag = ELEMENT_TYPE_I4;
            pValue = args->varValue.GetData();
            break;

        case VT_EMPTY:
            dwCPlusTypeFlag = ELEMENT_TYPE_CLASS;
            pValue = NULL;
            break;

        default:
        case CV_TIMESPAN:
            _ASSERTE(!"Not valid type!");

            // cannot specify default value
            COMPlusThrow(kArgumentException, L"Argument_BadConstantValue");    
            break;
    }

    if (TypeFromToken(args->tk) == mdtFieldDef)
    {
        hr = pRCW->GetEmitter()->SetFieldProps( 
            args->tk,                   // [IN] The FieldDef.
            ULONG_MAX,                  // [IN] Field attributes.
            dwCPlusTypeFlag,            // [IN] Flag for the value type, selected ELEMENT_TYPE_*
            pValue,                     // [IN] Constant value.
            -1);                        // [IN] Optional length.
    }
    else if (TypeFromToken(args->tk) == mdtProperty)
    {
        hr = pRCW->GetEmitter()->SetPropertyProps( 
            args->tk,                   // [IN] The PropertyDef.
            ULONG_MAX,                  // [IN] Property attributes.
            dwCPlusTypeFlag,            // [IN] Flag for the value type, selected ELEMENT_TYPE_*
            pValue,                     // [IN] Constant value.
            -1,                         // [IN] Optional length.
            mdMethodDefNil,             // [IN] Getter method.
            mdMethodDefNil,             // [IN] Setter method.
            NULL);                      // [IN] Other methods.
    }
    else
    {
        hr = pRCW->GetEmitter()->SetParamProps( 
            args->tk,                   // [IN] The ParamDef.
            NULL,
            ULONG_MAX,                  // [IN] Parameter attributes.
            dwCPlusTypeFlag,            // [IN] Flag for the value type, selected ELEMENT_TYPE_*
            pValue,                     // [IN] Constant value.
            -1);                        // [IN] Optional length.
    }
    if (FAILED(hr)) {   
        _ASSERTE(!"Set default value is failing"); 
        COMPlusThrow(kArgumentException, L"Argument_BadConstantValue");    
    }   
}	// COMDynamicWrite::CWSetConstantValue


/*============================CWSetFieldLayoutOffset============================
**Action: set fieldlayout of a field
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWSetFieldLayoutOffset(_CWSetFieldLayoutOffsetArgs* args) 
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;

    _ASSERTE(RidFromToken(args->tkField) != mdTokenNil);

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Set the field layout
    hr = pRCW->GetEmitHelper()->SetFieldLayoutHelper(
			args->tkField,					// field 
            args->iOffset);  				// layout offset

    if (FAILED(hr)) {   
        _ASSERTE(!"SetFieldLayoutHelper failed");
        COMPlusThrowHR(hr);    
    }   
}


/*============================CWSetClassLayout============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::CWSetClassLayout(_CWSetClassLayoutArgs* args)
{
    THROWSCOMPLUSEXCEPTION();   

    HRESULT			hr; 
    RefClassWriter* pRCW;   
    REFLECTMODULEBASEREF	pReflect; 
	Module			*pModule;


    _ASSERTE(args->handle);

    // Get the RefClassWriter   
    pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    
	pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    // Define the packing size and total size of a class
    hr = pRCW->GetEmitter()->SetClassLayout(
			args->handle,					// Typedef
            args->iPackSize,				// packing size
            NULL,							// no field layout 
			args->iTotalSize);				// total size for the type

    if (FAILED(hr)) {   
        _ASSERTE(!"SetClassLayout failed");
        COMPlusThrowHR(hr);    
    }   
}

/*===============================UpdateMethodRVAs===============================
**Action: Update the RVAs in all of the methods associated with a particular typedef
**        to prior to emitting them to a PE.
**Returns: Void
**Arguments:
**Exceptions:
==============================================================================*/
void COMDynamicWrite::UpdateMethodRVAs(IMetaDataEmit *pEmitNew,
								  IMetaDataImport *pImportNew,
                                  ICeeFileGen *pCeeFileGen, 
                                  HCEEFILE ceeFile, 
                                  mdTypeDef td,
                                  HCEESECTION sdataSection)
{
    THROWSCOMPLUSEXCEPTION();

    HCORENUM    hEnum=0;
    ULONG       methRVA;
    ULONG       newMethRVA;
    ULONG       sdataSectionRVA = 0;
    mdMethodDef md;
    mdFieldDef  fd;
    ULONG       count;
    DWORD       dwFlags=0;
    DWORD       implFlags=0;
    HRESULT     hr;

    // Look at the typedef flags.  Skip tdimport classes.
    if (!IsNilToken(td))
    {
        IfFailGo(pImportNew->GetTypeDefProps(td, 0,0,0, &dwFlags, 0));
        if (IsTdImport(dwFlags))
            goto ErrExit;
    }
    
    //Get an enumerator and use it to walk all of the methods defined by td.
    while ((hr = pImportNew->EnumMethods(
		&hEnum, 
		td, 
		&md, 
		1, 
		&count)) == S_OK) {
        
		IfFailGo( pImportNew->GetMethodProps(
			md, 
			NULL, 
			NULL,			// don't get method name
			0, 
			NULL, 
			&dwFlags, 
			NULL, 
			NULL, 
			&methRVA, 
			&implFlags) );

        // If this method isn't implemented here, don't bother correcting it's RVA
        // Otherwise, get the correct RVA from our ICeeFileGen and put it back into our local
        // copy of the metadata
		//
        if ( IsMdAbstract(dwFlags) || IsMdPinvokeImpl(dwFlags) ||
			 IsMiNative(implFlags) || IsMiRuntime(implFlags) ||
			 IsMiForwardRef(implFlags))
		{
            continue;
		}
            
        IfFailGo( pCeeFileGen->GetMethodRVA(ceeFile, methRVA, &newMethRVA) );
        IfFailGo( pEmitNew->SetRVA(md, newMethRVA) );
    }
        
    if (hEnum) {
        pImportNew->CloseEnum( hEnum);
    }
    hEnum = 0;

    // Walk through all of the Field belongs to this TypeDef. If field is marked as fdHasFieldRVA, we need to update the
    // RVA value.
    while ((hr = pImportNew->EnumFields(
		&hEnum, 
		td, 
		&fd, 
		1, 
		&count)) == S_OK) {
        
		IfFailGo( pImportNew->GetFieldProps(
			fd, 
			NULL,           // don't need the parent class
			NULL,			// don't get method name
			0, 
			NULL, 
			&dwFlags,       // field flags
			NULL,           // don't need the signature
			NULL, 
			NULL,           // don't need the constant value
            0,
			NULL) );

        if ( IsFdHasFieldRVA(dwFlags) )
        {            
            if (sdataSectionRVA == 0)
            {
                IfFailGo( pCeeFileGen->GetSectionCreate (ceeFile, ".sdata", sdReadWrite, &(sdataSection)) );
                IfFailGo( pCeeFileGen->GetSectionRVA(sdataSection, &sdataSectionRVA) );
            }

            IfFailGo( pImportNew->GetRVA(fd, &methRVA, NULL) );
            newMethRVA = methRVA + sdataSectionRVA;
            IfFailGo( pEmitNew->SetFieldRVA(fd, newMethRVA) );
        }
    }
        
    if (hEnum) {
        pImportNew->CloseEnum( hEnum);
    }
    hEnum = 0;

ErrExit:
    if (FAILED(hr)) {   
        _ASSERTE(!"UpdateRVA failed");
        COMPlusThrowHR(hr);    
    }   
}

void __stdcall COMDynamicWrite::CWInternalCreateCustomAttribute(_CWInternalCreateCustomAttributeArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

	HRESULT hr;
	mdCustomAttribute retToken;

    // Get the RefClassWriter   
    REFLECTMODULEBASEREF	pReflect = (REFLECTMODULEBASEREF) args->module;
    _ASSERTE(pReflect);
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    RefClassWriter* pRCW = GetReflectionModule(pModule)->GetClassWriter();
	_ASSERTE(pRCW);

    if (args->toDisk && pRCW->GetOnDiskEmitter())
    {
        hr = pRCW->GetOnDiskEmitter()->DefineCustomAttribute(
			    args->token,
                args->conTok,
                args->blob->GetDataPtr(),
			    args->blob->GetNumComponents(),
                &retToken);	
    }
    else
    {
        hr = pRCW->GetEmitter()->DefineCustomAttribute(
			    args->token,
                args->conTok,
                args->blob->GetDataPtr(),
			    args->blob->GetNumComponents(),
                &retToken);	
    }

    if (FAILED(hr))
    {
        // See if the metadata engine gave us any error information.
        IErrorInfo *pIErrInfo;
        if (GetErrorInfo(0, &pIErrInfo) == S_OK)
        {
            BSTR bstrMessage = NULL;
            if (SUCCEEDED(pIErrInfo->GetDescription(&bstrMessage)) && bstrMessage != NULL)
            {
                LPWSTR wszMessage = (LPWSTR)_alloca(*((DWORD*)bstrMessage - 1) + sizeof(WCHAR));
                wcscpy(wszMessage, (LPWSTR)bstrMessage);
                SysFreeString(bstrMessage);
                pIErrInfo->Release();
                COMPlusThrow(kArgumentException, IDS_EE_INVALID_CA_EX, wszMessage);
            }
            pIErrInfo->Release();
        }
        COMPlusThrow(kArgumentException, IDS_EE_INVALID_CA);
    }
}



//=============================PreSavePEFile=====================================*/
// PreSave the PEFile
//==============================================================================*/
void __stdcall COMDynamicWrite::PreSavePEFile(_PreSavePEFileArgs *args)
{
#ifdef PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    RefClassWriter	*pRCW;   
    ICeeGen			*pICG;
    HCEEFILE		ceeFile=NULL;
    ICeeFileGen		*pCeeFileGen;
    HRESULT			hr=S_OK;
	IMetaDataDispenserEx *pDisp = NULL;
    IMetaDataEmit	*pEmitNew = NULL;
    IMetaDataEmit   *pEmit = NULL;
	IMetaDataImport *pImport = NULL;
    DWORD			implFlags=0;
    HRESULT			hrReturn=S_OK;
    IUnknown        *pUnknown = NULL;
    IMapToken       *pIMapToken = NULL;
    REFLECTMODULEBASEREF pReflect;
    VARIANT         varOption;
    ISymUnmanagedWriter *pWriter = NULL;
    CSymMapToken    *pSymMapToken = NULL;
    CQuickArray<WCHAR> cqModuleName;
    ULONG           cchName;

    //Get the information for the Module and get the ICeeGen from it. 
    pReflect = (REFLECTMODULEBASEREF) args->refThis;    

    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    pICG = pRCW->GetCeeGen(); //This method is actually misnamed. It returns an ICeeGen.
    _ASSERTE(pICG);

    IfFailGo ( pRCW->EnsureCeeFileGenCreated() );

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    // We should not have the on disk emitter yet
    if (pRCW->GetOnDiskEmitter() != NULL)
        pRCW->SetOnDiskEmitter(NULL);

    // Get the dispenser.
    if (FAILED(MetaDataGetDispenser(CLSID_CorMetaDataDispenser,IID_IMetaDataDispenserEx,(void**)&pDisp))) {
        _ASSERTE(!"Unable to get dispenser.");
        FATAL_EE_ERROR();
    }

    //Get the emitter and the importer 
	pImport = pRCW->GetImporter();
	pEmit = pRCW->GetEmitter();
    _ASSERTE(pEmit && pImport);

    // Set the option on the dispenser turn on duplicate check for TypeDef and moduleRef
    varOption.vt = VT_UI4;
    varOption.lVal = MDDupDefault | MDDupTypeDef | MDDupModuleRef | MDDupExportedType | MDDupAssemblyRef;
    IfFailGo( pDisp->SetOption(MetaDataCheckDuplicatesFor, &varOption) );

    varOption.vt = VT_UI4;
    varOption.lVal = MDRefToDefNone;
    IfFailGo( pDisp->SetOption(MetaDataRefToDefCheck, &varOption) );

    //Define an empty scope
	IfFailGo( pDisp->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit, (IUnknown**)&pEmitNew));

    // bug fix: 14721
    // Token can move upon merge. Get the IMapToken from the CeeFileGen that is created for save
    // and pass it to merge to receive token movement notification.
    // Note that this is not a long term fix. We are relying on the fact that those tokens embedded
    // in PE cannot move after the merge. These tokens are TypeDef, TypeRef, MethodDef, FieldDef, MemberRef,
    // TypeSpec, UserString. If this is no longer true, we can break!
    //
    // Note that we don't need to release pIMapToken because it is not AddRef'ed in the GetIMapTokenIfaceEx.
    //
    IfFailGo( pCeeFileGen->GetIMapTokenIfaceEx(ceeFile, pEmit, &pUnknown));

    IfFailGo( pUnknown->QueryInterface(IID_IMapToken, (void **) &pIMapToken));

    // get the unmanaged writer.
    pWriter = GetReflectionModule(pModule)->GetISymUnmanagedWriter();
    pSymMapToken = new CSymMapToken(pWriter, pIMapToken);
    if (!pSymMapToken)
        IfFailGo(E_OUTOFMEMORY);


    //Merge the old tokens into the new (empty) scope
    //This is a copy.
    IfFailGo( pEmitNew->Merge(pImport, pSymMapToken, NULL));
    IfFailGo( pEmitNew->MergeEnd());

    // Update the Module name in the new scope.
    IfFailGo(pImport->GetScopeProps(0, 0, &cchName, 0));
    IfFailGo(cqModuleName.ReSize(cchName));
    IfFailGo(pImport->GetScopeProps(cqModuleName.Ptr(), cchName, &cchName, 0));
    IfFailGo(pEmitNew->SetModuleProps(cqModuleName.Ptr()));

    // cache the pEmitNew to RCW!!
    pRCW->SetOnDiskEmitter(pEmitNew);

ErrExit:
    //Release the interfaces.  This should free some of the associated resources.
	if (pEmitNew)
		pEmitNew->Release();
	if (pDisp)
		pDisp->Release();
   
    if (pIMapToken)
        pIMapToken->Release();

    if (pSymMapToken)
        pSymMapToken->Release();

    if (FAILED(hr)) 
    {
        COMPlusThrowHR(hr);
    }
#endif // !PLATFORM_CE
}

//=============================SavePEFile=====================================*/
// Save the PEFile to disk
//==============================================================================*/
void __stdcall COMDynamicWrite::SavePEFile(_SavePEFileArgs *args) {

#ifdef PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    RefClassWriter	*pRCW;   
    ICeeGen			*pICG;
    HCEEFILE		ceeFile=NULL;
    ICeeFileGen		*pCeeFileGen;
    HRESULT			hr=S_OK;
    HCORENUM		hTypeDefs=0;
    mdTypeDef		td;
    ULONG			count;
    IMetaDataEmit	*pEmitNew = 0;
	IMetaDataImport *pImportNew = 0;
    DWORD			implFlags=0;
    HRESULT			hrReturn=S_OK;
    IUnknown        *pUnknown = NULL;
    REFLECTMODULEBASEREF pReflect;
    Assembly        *pAssembly;
    ULONG           newMethRVA;
	DWORD           metaDataSize;	
	BYTE            *metaData;
	ULONG           metaDataOffset;
    HCEESECTION     pILSection;
    ISymUnmanagedWriter *pWriter = NULL;


    if (args->peName==NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
    if (args->peName->GetStringLength()==0)
        COMPlusThrow(kFormatException, L"Format_StringZeroLength");

    //Get the information for the Module and get the ICeeGen from it. 
    pReflect = (REFLECTMODULEBASEREF) args->refThis;
    
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pAssembly = pModule->GetAssembly();
    _ASSERTE( pAssembly );

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    pICG = pRCW->GetCeeGen(); //This method is actually misnamed. It returns an ICeeGen.
    _ASSERTE(pICG);

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    pEmitNew = pRCW->GetOnDiskEmitter();
    _ASSERTE(pEmitNew);

    //Get the emitter and the importer 

    if (pAssembly->IsDynamic() && args->isManifestFile)
    {
        // manifest is stored in this file

        // Allocate space for a strong name signature if an originator was supplied
        // (this doesn't strong name the assembly, but it makes it possible to do so
        // as a post processing step).
        if (pAssembly->IsStrongNamed())
            IfFailGo(pAssembly->AllocateStrongNameSignature(pCeeFileGen, ceeFile));
    }

    //Set the Output FileName
    IfFailGo( pCeeFileGen->SetOutputFileName(ceeFile, args->peName->GetBuffer()) );
    
    //Set the Entry Point or throw the dll switch if we're creating a dll.
    if (args->entryPoint!=0) 
    {
		IfFailGo( pCeeFileGen->SetEntryPoint(ceeFile, args->entryPoint) );
    }

    switch (args->fileKind)
	{
		case Dll:
		{
			IfFailGo( pCeeFileGen->SetDllSwitch(ceeFile, true) );
			break;
		}
		case WindowApplication:
		{
			// window application. Set the SubSystem
			IfFailGo( pCeeFileGen->SetSubsystem(ceeFile, IMAGE_SUBSYSTEM_WINDOWS_GUI, CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION, CEE_IMAGE_SUBSYSTEM_MINOR_VERSION) );
			break;
		}
		case ConsoleApplication:
		{
			// Console application. Set the SubSystem
			IfFailGo( pCeeFileGen->SetSubsystem(ceeFile, IMAGE_SUBSYSTEM_WINDOWS_CUI, CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION, CEE_IMAGE_SUBSYSTEM_MINOR_VERSION) );
			break;
		}
		default:
		{
			_ASSERTE("Unknown file kind!");
			break;
		}
	}

    IfFailGo( pCeeFileGen->GetIlSection(ceeFile, &pILSection) );
	IfFailGo( pEmitNew->GetSaveSize(cssAccurate, &metaDataSize) );
	IfFailGo( pCeeFileGen->GetSectionBlock(pILSection, metaDataSize, sizeof(DWORD), (void**) &metaData) );
	IfFailGo( pCeeFileGen->GetSectionDataLen(pILSection, &metaDataOffset) );
	metaDataOffset -= metaDataSize;

    // get the unmanaged writer.
    pWriter = GetReflectionModule(pModule)->GetISymUnmanagedWriter();
    IfFailGo( EmitDebugInfoBegin(pModule, pCeeFileGen, ceeFile, pILSection, args->peName->GetBuffer(), pWriter) );

    if (pAssembly->IsDynamic() && pRCW->m_ulResourceSize)
    {
        // There are manifest in this file

        IfFailGo( pCeeFileGen->GetMethodRVA(ceeFile, 0, &newMethRVA) );            

		// Point to manifest resource
		IfFailGo( pCeeFileGen->SetManifestEntry( ceeFile, pRCW->m_ulResourceSize, newMethRVA ) );
    }

	IfFailGo( pCeeFileGen->LinkCeeFile(ceeFile) );

    // Get the import interface from the new Emit interface.
    IfFailGo( pEmitNew->QueryInterface(IID_IMetaDataImport, (void **)&pImportNew));


    //Enumerate the TypeDefs and update method RVAs.
    while ((hr = pImportNew->EnumTypeDefs( &hTypeDefs, &td, 1, &count)) == S_OK) 
    {
        UpdateMethodRVAs(pEmitNew, pImportNew, pCeeFileGen, ceeFile, td, ((ReflectionModule*) pModule)->m_sdataSection);
    }

    if (hTypeDefs) 
    {
        pImportNew->CloseEnum(hTypeDefs);
    }
    hTypeDefs=0;
    
    //Update Global Methods.
    UpdateMethodRVAs(pEmitNew, pImportNew, pCeeFileGen, ceeFile, 0, ((ReflectionModule*) pModule)->m_sdataSection);
    

    //Emit the MetaData 
    // IfFailGo( pCeeFileGen->EmitMetaDataEx(ceeFile, pEmitNew));
    IfFailGo( pCeeFileGen->EmitMetaDataAt(ceeFile, pEmitNew, pILSection, metaDataOffset, metaData, metaDataSize) );

    // finish the debugging info emitting after the metadata save so that token remap will be caught correctly
    IfFailGo( EmitDebugInfoEnd(pModule, pCeeFileGen, ceeFile, pILSection, args->peName->GetBuffer(), pWriter) );

    //Generate the CeeFile
    IfFailGo(pCeeFileGen->GenerateCeeFile(ceeFile) );

    // Strong name sign the resulting assembly if required.
    if (pAssembly->IsDynamic() && args->isManifestFile && pAssembly->IsStrongNamed())
        IfFailGo(pAssembly->SignWithStrongName(args->peName->GetBuffer()));

ErrExit:

    pRCW->SetOnDiskEmitter(NULL);

    //Release the interfaces.  This should free some of the associated resources.
	if (pImportNew)
		pImportNew->Release();

    //Release our interfaces if we allocated them to begin with
    pRCW->DestroyCeeFileGen();

    //Check all file IO errors. If so, throw IOException. Otherwise, just throw the hr.
    if (FAILED(hr)) 
    {
        pAssembly->CleanupStrongNameSignature();
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            SCODE       scode = HRESULT_CODE(hr);
            WCHAR       wzErrorInfo[MAX_PATH];
            WszFormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                0, 
                hr,
                0,
                wzErrorInfo,
                MAX_PATH,
                0);
            if (IsWin32IOError(scode))
            {
                COMPlusThrowHR(COR_E_IO, wzErrorInfo);
            }
            else
            {
                COMPlusThrowHR(hr, wzErrorInfo);
            }
        }
        COMPlusThrowHR(hr);
    }
#endif // !PLATFORM_CE
}

//=============================EmitDebugInfoBegin============================*/
// Phase 1 of emit debugging directory and symbol file.
//===========================================================================*/
HRESULT COMDynamicWrite::EmitDebugInfoBegin(Module *pModule,
                                       ICeeFileGen *pCeeFileGen,
                                       HCEEFILE ceeFile,
                                       HCEESECTION pILSection,
                                       WCHAR *filename,
                                       ISymUnmanagedWriter *pWriter)
{
    HRESULT hr = S_OK;  






    // If we were emitting symbols for this dynamic module, go ahead
    // and fill out the debug directory and save off the symbols now.
    if (pWriter != NULL)
    {
        IMAGE_DEBUG_DIRECTORY  debugDirIDD;
        DWORD                  debugDirDataSize;
        BYTE                  *debugDirData;

        // Grab the debug info.
        IfFailGo(pWriter->GetDebugInfo(NULL, 0, &debugDirDataSize, NULL));

            
        // Is there any debug info to emit?
        if (debugDirDataSize > 0)
        {
            // Make some room for the data.
            debugDirData = (BYTE*)_alloca(debugDirDataSize);

            // Actually get the data now.
            IfFailGo(pWriter->GetDebugInfo(&debugDirIDD,
                                             debugDirDataSize,
                                             NULL,
                                             debugDirData));


            // Grab the timestamp of the PE file.
            time_t fileTimeStamp;


            IfFailGo(pCeeFileGen->GetFileTimeStamp(ceeFile, &fileTimeStamp));


            // Fill in the directory entry.
            debugDirIDD.TimeDateStamp = fileTimeStamp;
            debugDirIDD.AddressOfRawData = 0;

            // Grab memory in the section for our stuff.
            HCEESECTION sec = pILSection;
            BYTE *de;

            IfFailGo(pCeeFileGen->GetSectionBlock(sec,
                                                    sizeof(debugDirIDD) +
                                                    debugDirDataSize,
                                                    4,
                                                    (void**) &de) );


            // Where did we get that memory?
            ULONG deOffset;
            IfFailGo(pCeeFileGen->GetSectionDataLen(sec, &deOffset));


            deOffset -= (sizeof(debugDirIDD) + debugDirDataSize);

            // Setup a reloc so that the address of the raw data is
            // setup correctly.
            debugDirIDD.PointerToRawData = deOffset + sizeof(debugDirIDD);
                    
            IfFailGo(pCeeFileGen->AddSectionReloc(
                                          sec,
                                          deOffset +
                                          offsetof(IMAGE_DEBUG_DIRECTORY, PointerToRawData),
                                          sec, srRelocFilePos));


                    
            // Emit the directory entry.
            IfFailGo(pCeeFileGen->SetDirectoryEntry(
                                          ceeFile,
                                          sec,
                                          IMAGE_DIRECTORY_ENTRY_DEBUG,
                                          sizeof(debugDirIDD),
                                          deOffset));


            // Copy the debug directory into the section.
            memcpy(de, &debugDirIDD, sizeof(debugDirIDD));
            memcpy(de + sizeof(debugDirIDD), debugDirData, debugDirDataSize);

        }
    }
ErrExit:
    return hr;
}


//=============================EmitDebugInfoEnd==============================*/
// Phase 2 of emit debugging directory and symbol file.
//===========================================================================*/
HRESULT COMDynamicWrite::EmitDebugInfoEnd(Module *pModule,
                                       ICeeFileGen *pCeeFileGen,
                                       HCEEFILE ceeFile,
                                       HCEESECTION pILSection,
                                       WCHAR *filename,
                                       ISymUnmanagedWriter *pWriter)
{
    HRESULT hr = S_OK;
    
    CGrowableStream *pStream = NULL;

    // If we were emitting symbols for this dynamic module, go ahead
    // and fill out the debug directory and save off the symbols now.
    if (pWriter != NULL)
    {
        // Now go ahead and save off the symbol file and release the
        // writer.
        IfFailGo( pWriter->Close() );




        // How big of a stream to we have now?
        pStream = pModule->GetInMemorySymbolStream();
        _ASSERTE(pStream != NULL);

		STATSTG SizeData = {0};
        DWORD streamSize = 0;

		IfFailGo(pStream->Stat(&SizeData, STATFLAG_NONAME));

        streamSize = SizeData.cbSize.LowPart;

        if (SizeData.cbSize.HighPart > 0)
        {
            IfFailGo( E_OUTOFMEMORY );

        }

        SIZE_T fnLen = wcslen(filename);
        WCHAR *dot = wcsrchr(filename, L'.');
        SIZE_T dotOffset = dot - filename;

        if (dot && (fnLen - dotOffset >= 4))
        {
            WCHAR *fn = (WCHAR*)_alloca((fnLen + 1) * sizeof(WCHAR));
            wcscpy(fn, filename);

            fn[dotOffset + 1] = L'p';
            fn[dotOffset + 2] = L'd';
            fn[dotOffset + 3] = L'b';
            fn[dotOffset + 4] = L'\0';

            HANDLE pdbFile = WszCreateFile(fn,
                                           GENERIC_WRITE,
                                           0,
                                           NULL,
                                           CREATE_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);

            if (pdbFile != INVALID_HANDLE_VALUE)
            {
                DWORD dummy;
                BOOL succ = WriteFile(pdbFile,
                                      pStream->GetBuffer(),
                                      streamSize,
                                      &dummy, NULL);

                if (!succ)
                {
                    DWORD dwLastError = GetLastError();
                    CloseHandle(pdbFile);
                    IfFailGo( HRESULT_FROM_WIN32(dwLastError) );
                }

                CloseHandle(pdbFile);
            }
            else
            {
                IfFailGo( HRESULT_FROM_WIN32(GetLastError()) );

            }
        }
        else
        {
            IfFailGo( E_INVALIDARG );

        }
    }

ErrExit:
    // No one else will ever need this writer again...
    GetReflectionModule(pModule)->SetISymUnmanagedWriter(NULL);
//    GetReflectionModule(pModule)->SetSymbolStream(NULL);

    return hr;
}

//==============================================================================
// Define external file for native resource.
//==============================================================================
void __stdcall COMDynamicWrite::DefineNativeResourceFile(_DefineNativeResourceFileArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    HRESULT			hr;
    REFLECTMODULEBASEREF pReflect;
    RefClassWriter	*pRCW;   
    HCEEFILE		ceeFile=NULL;
    ICeeFileGen		*pCeeFileGen;
    
	_ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Get the ICeeFileGen*
    pReflect = (REFLECTMODULEBASEREF) args->refThis;
    
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    IfFailGo( pRCW->EnsureCeeFileGenCreated() );

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    // Set the resource file name.
    IfFailGo( pCeeFileGen->SetResourceFileName(ceeFile, args->resourceFileName->GetBuffer()) );

ErrExit:
    if (FAILED(hr)) 
    {
        COMPlusThrowHR(hr);
    }
} // void __stdcall COMDynamicWrite::DefineNativeResourceFile()

//==============================================================================
// Define array of bytes for native resource.
//==============================================================================
void __stdcall COMDynamicWrite::DefineNativeResourceBytes(_DefineNativeResourceBytesArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    HRESULT			hr;
    REFLECTMODULEBASEREF pReflect;
    RefClassWriter	*pRCW;   
    HCEEFILE		ceeFile=NULL;
	HCEESECTION     ceeSection=NULL;
    ICeeFileGen		*pCeeFileGen;
	BYTE			*pbResource;
	ULONG			cbResource;
	void			*pvResource;
    
	_ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Get the ICeeFileGen*
    pReflect = (REFLECTMODULEBASEREF) args->refThis;
    
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    // Set the resource stream.
    pbResource = args->resourceBytes->GetDataPtr();
	cbResource = args->resourceBytes->GetNumComponents();
    IfFailGo( pCeeFileGen->GetSectionCreate(ceeFile, ".rsrc", sdReadOnly, &ceeSection) );
	IfFailGo( pCeeFileGen->GetSectionBlock(ceeSection, cbResource, 1, &pvResource) );
	memcpy(pvResource, pbResource, cbResource);

ErrExit:
    if (FAILED(hr)) 
    {
        COMPlusThrowHR(hr);
    }
} // void __stdcall COMDynamicWrite::DefineNativeResourceBytes()



//=============================SetResourceCounts=====================================*/
// ecall for setting the number of embedded resources to be stored in this module
//==============================================================================*/
void __stdcall COMDynamicWrite::SetResourceCounts(_setResourceCountArgs *args) 
{
#ifdef PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    REFLECTMODULEBASEREF pReflect;
    RefClassWriter	*pRCW;   

    //Get the information for the Module and get the ICeeGen from it. 
    pReflect = (REFLECTMODULEBASEREF) args->refThis;
    
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);
    
#endif // !PLATFORM_CE
}

//=============================AddResource=====================================*/
// ecall for adding embedded resource to this module
//==============================================================================*/
void __stdcall COMDynamicWrite::AddResource(_addResourceArgs *args) 
{
#ifdef PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
#else // !PLATFORM_CE
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    REFLECTMODULEBASEREF pReflect;
    RefClassWriter	*pRCW;   
    ICeeGen			*pICG;
    HCEEFILE		ceeFile=NULL;
    ICeeFileGen		*pCeeFileGen;
    HRESULT			hr=S_OK;
    HCEESECTION     hSection;
    ULONG           ulOffset;
    BYTE            *pbBuffer;
    IMetaDataAssemblyEmit *pAssemEmitter = NULL;
    Assembly        *pAssembly;
    mdManifestResource mr;
    mdFile          tkFile;
	IMetaDataEmit	*pOnDiskEmit;
	IMetaDataAssemblyEmit *pOnDiskAssemblyEmit = NULL;

    //Get the information for the Module and get the ICeeGen from it. 
    pReflect = (REFLECTMODULEBASEREF) args->refThis;
    
    Module* pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);

    pRCW = GetReflectionModule(pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    pICG = pRCW->GetCeeGen(); //This method is actually misnamed. It returns an ICeeGen.
    _ASSERTE(pICG);

    pAssembly = pModule->GetAssembly();
    _ASSERTE( pAssembly && pAssembly->IsDynamic() );

    IfFailGo( pRCW->EnsureCeeFileGenCreated() );

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    pOnDiskEmit = pRCW->GetOnDiskEmitter();

    // First, put it into .rdata section. The only reason that we choose .rdata section at
    // this moment is because this is the first section on the PE file. We don't need to deal with
    // reloc. Actually, I don't know how to deal with the reloc with CeeFileGen given that the reloc
    // position is not in the same file!

    // Get the .rdata section
    IfFailGo( pCeeFileGen->GetRdataSection(ceeFile, &hSection) );

    // the current section data length is the RVA
    IfFailGo( pCeeFileGen->GetSectionDataLen(hSection, &ulOffset) );

    // Allocate a block of space fromt he .rdata section
	IfFailGo( pCeeFileGen->GetSectionBlock(
        hSection,           // from .rdata section
        args->iByteCount + sizeof(DWORD),   // number of bytes that we need
        1,                  // alignment
        (void**) &pbBuffer) ); 

    // now copy over the resource
	memcpy( pbBuffer, &args->iByteCount, sizeof(DWORD) );
    memcpy( pbBuffer + sizeof(DWORD), args->byteRes->GetDataPtr(), args->iByteCount );

	// track the total resource size so far. The size is actually the offset into the section
    // after writing the resource out
    pCeeFileGen->GetSectionDataLen(hSection, &pRCW->m_ulResourceSize);
    tkFile = RidFromToken(args->tkFile) ? args->tkFile : mdFileNil;
	if (tkFile != mdFileNil)
	{
		IfFailGo( pOnDiskEmit->QueryInterface(IID_IMetaDataAssemblyEmit, (void **) &pOnDiskAssemblyEmit) );
		
		// The resource is stored in a file other than the manifest file
		IfFailGo(pOnDiskAssemblyEmit->DefineManifestResource(
			args->strName->GetBuffer(),
			mdFileNil,              // implementation -- should be file token of this module in the manifest
			ulOffset,               // offset to this file -- need to be adjusted upon save
			args->iAttribute,       // resource flag
			&mr));                  // manifest resource token
	}

    // Add an entry into the ManifestResource table for this resource
    // The RVA is ulOffset
    pAssemEmitter = pAssembly->GetOnDiskMDAssemblyEmitter();
    IfFailGo(pAssemEmitter->DefineManifestResource(
        args->strName->GetBuffer(),
        tkFile,                 // implementation -- should be file token of this module in the manifest
        ulOffset,               // offset to this file -- need to be adjusted upon save
        args->iAttribute,       // resource flag
        &mr));                  // manifest resource token

    pRCW->m_tkFile = tkFile;

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();
	if (pOnDiskAssemblyEmit)
		pOnDiskAssemblyEmit->Release();
    if (FAILED(hr)) 
    {
        COMPlusThrowHR(hr);
    }
#endif // !PLATFORM_CE
}

//============================AddDeclarativeSecurity============================*/
// Add a declarative security serialized blob and a security action code to a
// given parent (class or method).
//==============================================================================*/
void __stdcall COMDynamicWrite::CWAddDeclarativeSecurity(_CWAddDeclarativeSecurityArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT                 hr;
    RefClassWriter*         pRCW;   
    REFLECTMODULEBASEREF    pReflect;
    Module*                 pModule;
    mdPermission            tkPermission;
    void const*             pData;
    DWORD                   cbData;

    pReflect = (REFLECTMODULEBASEREF) args->module;
    pModule = (Module*) pReflect->GetData();
    pRCW = GetReflectionModule(pModule)->GetClassWriter();

    if (args->blob != NULL) {
        pData = args->blob->GetDataPtr();
        cbData = args->blob->GetNumComponents();
    } else {
        pData = NULL;
        cbData = 0;
    }

    IfFailGo( pRCW->GetEmitHelper()->AddDeclarativeSecurityHelper(args->tk,
                                                             args->action,
                                                             pData,
                                                             cbData,
                                                             &tkPermission) );
ErrExit:
    if (FAILED(hr)) 
    {
        _ASSERTE(!"AddDeclarativeSecurity failed");
        COMPlusThrowHR(hr);
    }
    else if (hr == META_S_DUPLICATE)
    {
        COMPlusThrow(kInvalidOperationException, IDS_EE_DUPLICATE_DECLSEC);
    }
}


CSymMapToken::CSymMapToken(ISymUnmanagedWriter *pWriter, IMapToken *pMapToken)
{
	m_cRef = 1;
    m_pWriter = pWriter;
    m_pMapToken = pMapToken;
    if (m_pWriter)
        m_pWriter->AddRef();
    if (m_pMapToken)
        m_pMapToken->AddRef();
} // CSymMapToken::CSymMapToken()



//*********************************************************************
//
// CSymMapToken's destructor
//
//*********************************************************************
CSymMapToken::~CSymMapToken()
{
	if (m_pWriter)
        m_pWriter->Release();
    if (m_pMapToken)
        m_pMapToken->Release();
}	// CSymMapToken::~CMapToken()


ULONG CSymMapToken::AddRef()
{
	return (InterlockedIncrement((long *) &m_cRef));
}	// CSymMapToken::AddRef()



ULONG CSymMapToken::Release()
{
	ULONG	cRef = InterlockedDecrement((long *) &m_cRef);
	if (!cRef)
		delete this;
	return (cRef);
}	// CSymMapToken::Release()


HRESULT CSymMapToken::QueryInterface(REFIID riid, void **ppUnk)
{
	*ppUnk = 0;

	if (riid == IID_IMapToken)
		*ppUnk = (IUnknown *) (IMapToken *) this;
	else
		return (E_NOINTERFACE);
	AddRef();
	return (S_OK);
}	// CSymMapToken::QueryInterface



//*********************************************************************
//
// catching the token mapping
//
//*********************************************************************
HRESULT	CSymMapToken::Map(
	mdToken		tkFrom, 
	mdToken		tkTo)
{
    HRESULT         hr = NOERROR;
    if (m_pWriter)
        IfFailGo( m_pWriter->RemapToken(tkFrom, tkTo) );
    if (m_pMapToken)
        IfFailGo( m_pMapToken->Map(tkFrom, tkTo) );
ErrExit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comdynamic.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// COMDynamic.h
//  This module defines the native methods that are used for Dynamic IL generation  
//
// Author: Daryl Olander
// Date: November 1998
////////////////////////////////////////////////////////////////////////////////
#ifndef _COMDYNAMIC_H_
#define _COMDYNAMIC_H_

#include "COMClass.h"
#include "ICeeFileGen.h"
#include "DbgInterface.h"
#include "COMVariant.h"

extern HRESULT _GetCeeGen(REFIID riid, void** ppv);

inline CorModule* allocateReflectionModule()
{
    CorModule *pReflectionModule;   
    HRESULT hr = _GetCeeGen(IID_ICorReflectionModule, (void **)&pReflectionModule);   
    if (FAILED(hr)) 
        return NULL;    
    return pReflectionModule; 
}

typedef enum PEFileKinds {
    Dll = 0x1,
    ConsoleApplication = 0x2,
    WindowApplication = 0x3,
} PEFileKinds;

// COMDynamicWrite
// This class defines all the methods that implement the dynamic IL creation process
//  inside reflection.  
class COMDynamicWrite
{
private:

    static void UpdateMethodRVAs(IMetaDataEmit*, IMetaDataImport*, ICeeFileGen *, HCEEFILE, mdTypeDef td, HCEESECTION sdataSection);

public:

    // create a dynamic module with a given name. Note that we don't set the name of the dynamic module here.
    // The name of the dynamic module is set in the managed world
    //
    static InMemoryModule* CreateDynamicModule(Assembly* pContainingAssembly,
                                       STRINGREF &filename)
    {
        HRESULT     hr = NOERROR;
        THROWSCOMPLUSEXCEPTION();   

        _ASSERTE(pContainingAssembly);
        
        CorModule *pWrite;

        // allocate the dynamic module
        pWrite = allocateReflectionModule();  
        if (!pWrite) COMPlusThrowOM();
        
        // intiailize the dynamic module
        hr = pWrite->Initialize(CORMODULE_NEW, IID_ICeeGen, IID_IMetaDataEmit);
        if (FAILED(hr)) 
        {
            pWrite->Release();  
            COMPlusThrowOM(); 
        }            

        // Set the name for the debugger.
        if ((filename != NULL) &&
            (filename->GetStringLength() > 0))
        {
            ReflectionModule *rm = pWrite->GetModule()->GetReflectionModule();
            rm->SetFileName(filename->GetBuffer());
        }

        // link the dynamic module into the containing assembly
        hr = pContainingAssembly->AddModule(pWrite->GetModule(), mdFileNil, false);
        if (FAILED(hr))
        {
            pWrite->Release();
            COMPlusThrowOM();
        }
        InMemoryModule *retMod = pWrite->GetModule();
        pWrite->Release();
        return retMod;
    }   

    
    // the module that it pass in is already the reflection module
    static ReflectionModule* GetReflectionModule(Module* pModule) 
    {    
        THROWSCOMPLUSEXCEPTION();   
        // _ASSERTE(pModule->ModuleType() == IID_ICorReflectionModule);
        return reinterpret_cast<ReflectionModule *>(pModule); 
    }   

    // CWCreateClass    
    // ClassWriter.InternalDefineClass -- This function will create the class's metadata definition  
    struct _CWCreateClassArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);    
        DECLARE_ECALL_I4_ARG(INT32, tkEnclosingType); 
        DECLARE_ECALL_OBJECTREF_ARG(GUID, guid);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
        DECLARE_ECALL_I4_ARG(UINT32, attr); 
        DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, interfaces);
        DECLARE_ECALL_I4_ARG(UINT32, parent); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strFullName);   
        DECLARE_ECALL_OBJECTREF_ARG(UINT32 *, retRef);
    };  
    static void __stdcall CWCreateClass(_CWCreateClassArgs* args);


    // CWSetParentType    
    // ClassWriter.InternalSetParentType -- This function will reset the parent class in metadata
    struct _CWSetParentTypeArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);    
        DECLARE_ECALL_I4_ARG(UINT32, tkParent); 
        DECLARE_ECALL_I4_ARG(UINT32, tdType); 
    };  
    static void __stdcall CWSetParentType(_CWSetParentTypeArgs* args);

    // CWAddInterfaceImpl    
    // ClassWriter.InternalAddInterfaceImpl -- This function will add another interface impl
    struct _CWAddInterfaceImplArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);    
        DECLARE_ECALL_I4_ARG(UINT32, tkInterface); 
        DECLARE_ECALL_I4_ARG(UINT32, tdType); 
    };  
    static void __stdcall CWAddInterfaceImpl(_CWAddInterfaceImplArgs* args);

    // CWCreateMethod   
    // ClassWriter.InternalDefineMethod -- This function will create a method within the class  
    struct _CWCreateMethodArgs {    
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
        DECLARE_ECALL_I4_ARG(UINT32, attributes);
        DECLARE_ECALL_I4_ARG(UINT32, sigLength);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);   
        DECLARE_ECALL_I4_ARG(UINT32, handle); 
        DECLARE_ECALL_OBJECTREF_ARG(UINT32 *, retRef);
    };  
    static void __stdcall CWCreateMethod(_CWCreateMethodArgs* args);

    // CWSetMethodIL    
    // ClassWriter.InternalSetMethodIL -- This function will create a method within the class   
    struct _CWSetMethodILArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
        DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, rvaFixups);
        DECLARE_ECALL_OBJECTREF_ARG(I4ARRAYREF, tokenFixups);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, exceptions);
        DECLARE_ECALL_I4_ARG(UINT32, numExceptions); 
        DECLARE_ECALL_I4_ARG(UINT32, maxStackSize);
        DECLARE_ECALL_I4_ARG(UINT32, sigLength);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, localSig); 
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, body);
        DECLARE_ECALL_I4_ARG(UINT32, isInitLocal); 
        DECLARE_ECALL_I4_ARG(UINT32, handle); 
    };  
    static void __stdcall CWSetMethodIL(_CWSetMethodILArgs* args);

    // CWTermCreateClass    
    // ClassWriter.TermCreateClass --   
    struct _CWTermCreateClassArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);    
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
        DECLARE_ECALL_I4_ARG(UINT32, handle); 
    };  
    LPVOID static __stdcall CWTermCreateClass(_CWTermCreateClassArgs* args);  

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
        DECLARE_ECALL_I4_ARG(UINT32, attr); 
        DECLARE_ECALL_I4_ARG(UINT32, sigLength);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
        DECLARE_ECALL_I4_ARG(UINT32, handle); 
    } _cwCreateFieldArgs;
    static mdFieldDef __stdcall COMDynamicWrite::CWCreateField(_cwCreateFieldArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
    } _PreSavePEFileArgs;
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(UINT32, isManifestFile);
        DECLARE_ECALL_I4_ARG(UINT32, fileKind);
        DECLARE_ECALL_I4_ARG(UINT32, entryPoint);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, peName);
    } _SavePEFileArgs;
    static void __stdcall COMDynamicWrite::PreSavePEFile(_PreSavePEFileArgs *args);
    static void __stdcall COMDynamicWrite::SavePEFile(_SavePEFileArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, resourceFileName);
    } _DefineNativeResourceFileArgs;
    static void __stdcall COMDynamicWrite::DefineNativeResourceFile(_DefineNativeResourceFileArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, resourceBytes);
    } _DefineNativeResourceBytesArgs;
    static void __stdcall COMDynamicWrite::DefineNativeResourceBytes(_DefineNativeResourceBytesArgs *args);

    // not an ecall!
    static HRESULT COMDynamicWrite::EmitDebugInfoBegin(
        Module *pModule,
        ICeeFileGen *pCeeFileGen,
        HCEEFILE ceeFile,
        HCEESECTION pILSection,
        WCHAR *filename,
        ISymUnmanagedWriter *pWriter);

    // not an ecall!
    static HRESULT COMDynamicWrite::EmitDebugInfoEnd(
        Module *pModule,
        ICeeFileGen *pCeeFileGen,
        HCEEFILE ceeFile,
        HCEESECTION pILSection,
        WCHAR *filename,
        ISymUnmanagedWriter *pWriter);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(UINT32, iCount);
    } _setResourceCountArgs;
    static void __stdcall COMDynamicWrite::SetResourceCounts(_setResourceCountArgs *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refThis);
        DECLARE_ECALL_I4_ARG(UINT32, iAttribute);
        DECLARE_ECALL_I4_ARG(UINT32, tkFile);
        DECLARE_ECALL_I4_ARG(UINT32, iByteCount);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, byteRes); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strName);
    } _addResourceArgs;
    static void __stdcall COMDynamicWrite::AddResource(_addResourceArgs *args);

    typedef struct {
        DECLARE_ECALL_I4_ARG(UINT32, linkFlags);
        DECLARE_ECALL_I4_ARG(UINT32, linkType);
        DECLARE_ECALL_I4_ARG(UINT32, token);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, functionName);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, dllName);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
    } _internalSetPInvokeDataArgs;
    static void __stdcall COMDynamicWrite::InternalSetPInvokeData(_internalSetPInvokeDataArgs *args);

    // DefineProperty's argument
    struct _CWDefinePropertyArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, tkNotifyChanged);              // NotifyChanged
        DECLARE_ECALL_I4_ARG(UINT32, tkNotifyChanging);             // NotifyChanging
        DECLARE_ECALL_I4_ARG(UINT32, sigLength);                    // property signature length
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature);         // property siganture
        DECLARE_ECALL_I4_ARG(UINT32, attr);                         // property flags
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);               // property name
        DECLARE_ECALL_I4_ARG(UINT32, handle);                       // type that will contain this property
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
        DECLARE_ECALL_OBJECTREF_ARG(UINT32 *, retRef);              // return PropertyToken here
    };  
    static void __stdcall CWDefineProperty(_CWDefinePropertyArgs* args);

    // @todo: add a new function to set default value

    // DefineEvent's argument
    struct _CWDefineEventArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, eventtype);
        DECLARE_ECALL_I4_ARG(UINT32, attr);                         // event flags
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);               // event name
        DECLARE_ECALL_I4_ARG(UINT32, handle);                       // type that will contain this event
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
        DECLARE_ECALL_OBJECTREF_ARG(UINT32 *, retRef);              // return PropertyToken here
    };  
    static void __stdcall CWDefineEvent(_CWDefineEventArgs* args);

    // functions to set Setter, Getter, Reset, TestDefault, and other methods
    struct _CWDefineMethodSemanticsArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, method);                       // Method to associate with parent tk
        DECLARE_ECALL_I4_ARG(UINT32, attr);                         // MethodSemantics
        DECLARE_ECALL_I4_ARG(UINT32, association);                  // Parent tokens. It can be property or event
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWDefineMethodSemantics(_CWDefineMethodSemanticsArgs* args);

    // functions to set method's implementation flag
    struct _CWSetMethodImplArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, attr);                         // MethodImpl flags
        DECLARE_ECALL_I4_ARG(UINT32, tkMethod);                     // method token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWSetMethodImpl(_CWSetMethodImplArgs* args);

    // functions to create MethodImpl record
    struct _CWDefineMethodImplArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, tkDecl);                       // MethodImpl flags
        DECLARE_ECALL_I4_ARG(UINT32, tkBody);                       // MethodImpl flags
        DECLARE_ECALL_I4_ARG(UINT32, tkType);                       // method token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWDefineMethodImpl(_CWDefineMethodImplArgs* args);



    // GetTokenFromSig's argument
    struct _CWGetTokenFromSigArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, sigLength);                    // property signature length
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature);         // property siganture
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static int __stdcall CWGetTokenFromSig(_CWGetTokenFromSigArgs* args);

    // Set Field offset
    struct _CWSetFieldLayoutOffsetArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, iOffset);                      // MethodSemantics
        DECLARE_ECALL_I4_ARG(UINT32, tkField);                      // Parent tokens. It can be property or event
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWSetFieldLayoutOffset(_CWSetFieldLayoutOffsetArgs* args);

    // Set classlayout info
    struct _CWSetClassLayoutArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, iTotalSize);                   // Size of type
        DECLARE_ECALL_I4_ARG(UINT32, iPackSize);                    // packing size
        DECLARE_ECALL_I4_ARG(UINT32, handle);                       // type that will contain this layout info
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWSetClassLayout(_CWSetClassLayoutArgs* args);

    // Set a custom attribute
    struct _CWInternalCreateCustomAttributeArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, toDisk);                       // emit CA to on disk metadata
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, blob);              // customattribute blob
        DECLARE_ECALL_I4_ARG(UINT32, conTok);                       // The constructor token
        DECLARE_ECALL_I4_ARG(UINT32, token);                        // Token to apply the custom attribute to
    };  
    static void __stdcall CWInternalCreateCustomAttribute(_CWInternalCreateCustomAttributeArgs* args);

    // functions to set ParamInfo
    struct _CWSetParamInfoArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strParamName);       // parameter name, can be NULL
        DECLARE_ECALL_I4_ARG(UINT32, iAttributes);                  // parameter attributes
        DECLARE_ECALL_I4_ARG(UINT32, iSequence);                    // sequence of the parameter
        DECLARE_ECALL_I4_ARG(UINT32, tkMethod);                     // method token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static int __stdcall CWSetParamInfo(_CWSetParamInfoArgs* args);

    // functions to set FieldMarshal
    struct _CWSetMarshalArgs { 
        DECLARE_ECALL_I4_ARG(UINT32, cbMarshal);                    // number of bytes in Marshal info
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, ubMarshal);         // Marshal info in bytes
        DECLARE_ECALL_I4_ARG(UINT32, tk);                           // field or param token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWSetMarshal(_CWSetMarshalArgs* args);

    // functions to set default value
    struct _CWSetConstantValueArgs { 
        DECLARE_ECALL_OBJECTREF_ARG(VariantData, varValue);         // constant value
        DECLARE_ECALL_I4_ARG(UINT32, tk);                           // field or param token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };  
    static void __stdcall CWSetConstantValue(_CWSetConstantValueArgs* args);

    // functions to add declarative security
    struct _CWAddDeclarativeSecurityArgs {
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, blob);              // permission set blob
        DECLARE_ECALL_I4_ARG(DWORD, action);                        // security action
        DECLARE_ECALL_I4_ARG(UINT32, tk);                           // class or method token
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);  // dynamic module
    };
    static void __stdcall CWAddDeclarativeSecurity(_CWAddDeclarativeSecurityArgs* args);
};



//*********************************************************************
//
// This CSymMapToken class implemented the IMapToken. It is used in catching
// token remap information from Merge and send the notifcation to CeeFileGen
// and SymbolWriter
//
//*********************************************************************
class CSymMapToken : public IMapToken
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, PVOID *pp);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Map(mdToken tkImp, mdToken tkEmit);
    CSymMapToken(ISymUnmanagedWriter *pWriter, IMapToken *pMapToken);
    ~CSymMapToken();
private:
    ULONG       m_cRef;
    ISymUnmanagedWriter *m_pWriter;
    IMapToken   *m_pMapToken;
};

#endif  // _COMDYNAMIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comevent.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMEvent.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.ManualResetEvent and System.AutoResetEvent
**
** Date:  August, 1999
** 
===========================================================*/

#ifndef _COMEVENT_H
#define _COMEVENT_H
#include "COMWaitHandle.h"

class ManualResetEventNative;
class AutoResetEventNative;

typedef ManualResetEventNative* MANUAL_RESET_EVENT_REF;

class ManualResetEventNative :public WaitHandleNative
{
    struct CreateEventArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, initialState);
    };
    struct SetEventArgs
    {
        DECLARE_ECALL_I4_ARG(LPVOID, eventHandle);
    };

public:
    static HANDLE __stdcall CorCreateManualResetEvent(CreateEventArgs*);
    static BOOL   __stdcall CorSetEvent(SetEventArgs*);
    static BOOL   __stdcall CorResetEvent(SetEventArgs*);




};

typedef AutoResetEventNative* AUTO_RESET_EVENT_REF;

class AutoResetEventNative : public WaitHandleNative
{

    struct CreateEventArgs
    {
        DECLARE_ECALL_I4_ARG(INT32, initialState);
    };
    struct SetEventArgs
    {
        DECLARE_ECALL_I4_ARG(LPVOID, eventHandle);
    };

public:
    static HANDLE __stdcall CorCreateAutoResetEvent(CreateEventArgs*);
    static BOOL   __stdcall CorSetEvent(SetEventArgs*);
    static BOOL   __stdcall CorResetEvent(SetEventArgs*);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comhash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:          COMHash.h
//
//   Author:        Gregory Fee 
//
//   Purpose:       unmanaged code for managed class System.Security.Policy.Hash
//
//   Date created : February 18, 2000
//
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMHash_H_
#define _COMHash_H_

class COMHash
{
public:

	typedef struct {
	    DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, assembly );
	} _AssemblyInfo;
	
	static LPVOID __stdcall GetRawData( _AssemblyInfo* );	

};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cominterfacemarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "vars.hpp"
#include "excep.h"
#include "stdinterfaces.h"
#include "InteropUtil.h"
#include "ComCallWrapper.h"
#include "ComPlusWrapper.h"
#include "COMInterfaceMarshaler.h"
#include "InteropConverter.h"
#include "remoting.h"
#include "appdomainhelper.h"
#include "notifyexternals.h"


//--------------------------------------------------------------------------------
// COMInterfaceMarshaler::COMInterfaceMarshaler()
// ctor
//--------------------------------------------------------------------------------
COMInterfaceMarshaler::COMInterfaceMarshaler()
{   
    m_pWrapperCache = ComPlusWrapperCache::GetComPlusWrapperCache();
    _ASSERTE(m_pWrapperCache != NULL);
    
    m_pUnknown = NULL;
    m_pIdentity = NULL;
    m_pIManaged = NULL;
	m_pCtxCookie = NULL;
    m_pClassMT = NULL;
    
    m_fFlagsInited = FALSE;
    m_fIsRemote = FALSE;
    m_fIsComProxy = FALSE;
    
    m_pComCallWrapper = NULL;
    m_dwServerDomainId = NULL;
    
    m_bstrProcessGUID = NULL;
}

//--------------------------------------------------------------------------------
// COMInterfaceMarshaler::~COMInterfaceMarshaler()
// dtor
//--------------------------------------------------------------------------------
COMInterfaceMarshaler::~COMInterfaceMarshaler()
{
    if (m_bstrProcessGUID != NULL)
    {
        SysFreeString(m_bstrProcessGUID);
        m_bstrProcessGUID = NULL;
    }
    if (m_pIManaged)
    {
        SafeRelease(m_pIManaged);
        m_pIManaged = NULL;
    }
}

//--------------------------------------------------------------------------------
// VOID COMInterfaceMarshaler::Init(IUnknown* pUnk, MethodTable* pClassMT)
// init
//--------------------------------------------------------------------------------
VOID COMInterfaceMarshaler::Init(IUnknown* pUnk, MethodTable* pClassMT)
{
    _ASSERTE(pUnk != NULL);
    _ASSERTE(m_pClassMT == NULL && m_pUnknown == NULL && m_pIdentity == NULL);

    // NOTE ** this struct is temporary,
    // so NO ADDREF of the COM Interface pointers
    m_pUnknown = pUnk;
    // for now use the IUnknown as the Identity
    m_pIdentity = pUnk;
	
    m_pClassMT = pClassMT;
}

//--------------------------------------------------------------------------------
// VOID COMInterfaceMarshaler::InitializeFlags()
//--------------------------------------------------------------------------------
VOID COMInterfaceMarshaler::InitializeFlags()
{
    THROWSCOMPLUSEXCEPTION();
    //m_fIsComProxy = IsComProxy(pUnk);
    _ASSERTE(m_fFlagsInited == FALSE);
    
    _ASSERTE(m_pIManaged == NULL);
    HRESULT hr = SafeQueryInterface(m_pUnknown, IID_IManagedObject, (IUnknown**)&m_pIManaged);
    LogInteropQI(m_pUnknown, IID_IManagedObject, hr, "QI for IManagedObject");

    if (hr == S_OK)
    {
        _ASSERTE(m_pIManaged);
        

        // gossa disable preemptive GC before calling out...
        Thread* pThread = GetThread();
        int fGC = pThread->PreemptiveGCDisabled();
        
        if (fGC)
            pThread->EnablePreemptiveGC();

        
        HRESULT hr2 = m_pIManaged->GetObjectIdentity(&m_bstrProcessGUID, (int*)&m_dwServerDomainId, 
                                    (int *)&m_pComCallWrapper);

        if(fGC)
            pThread->DisablePreemptiveGC();

        // if hr2 != S_OK then we throw an exception
        // coz GetProcessID shouldn't fail.. 
        // one reason where it fails is JIT Activation of the object
        // failed
        if (hr2 == S_OK)
        {
            _ASSERTE(m_bstrProcessGUID != NULL);
            // compare the strings to check if this is in-proc
            m_fIsRemote = (wcscmp((WCHAR *)m_bstrProcessGUID, GetProcessGUID()) != 0);
        }
        else
        if (FAILED(hr2))
        {
            // throw HRESULT
            COMPlusThrowHR(hr2);
        } 
    }

    m_fFlagsInited = TRUE;
}

//--------------------------------------------------------------------------------
// COMInterfaceMarshaler::COMInterfaceMarshaler(ComPlusWrapper* pCache)
// VOID COMInterfaceMarshaler::InitializeObjectClass()
//--------------------------------------------------------------------------------
VOID COMInterfaceMarshaler::InitializeObjectClass()
{
    // we don't want to QI for IProvideClassInfo for a remote managed component
    if (m_pClassMT == NULL && !m_fIsRemote)
    {
        
        // @TODO(DM): Do we really need to be this forgiving ? We should
        //            look into letting the type load exceptions percolate 
        //            up to the user instead of swallowing them and using __ComObject.
        COMPLUS_TRY
        {
            m_pClassMT = GetClassFromIProvideClassInfo(m_pUnknown);
        }
        COMPLUS_CATCH
        {
        }
        COMPLUS_END_CATCH
    }
    if (m_pClassMT == NULL)
        m_pClassMT = SystemDomain::GetDefaultComObject();       
}

//--------------------------------------------------------------------
// OBJECTREF COMInterfaceMarshaler::HandleInProcManagedComponents()
//--------------------------------------------------------------------
OBJECTREF COMInterfaceMarshaler::HandleInProcManagedComponent()
{
    THROWSCOMPLUSEXCEPTION();
	_ASSERTE(m_fIsRemote == FALSE);
	Thread* pThread = GetThread();
	_ASSERTE(pThread);

    AppDomain* pCurrDomain = pThread->GetDomain();

	if (! SystemDomain::System()->GetAppDomainAtId(m_dwServerDomainId))
    {
        // throw HRESULT
        COMPlusThrowHR(COR_E_APPDOMAINUNLOADED);
    }

    OBJECTREF oref = NULL;
    if (m_dwServerDomainId == pCurrDomain->GetId())
    {
        oref = m_pComCallWrapper->GetObjectRef();
        
       	#ifdef _DEBUG
			oref = NULL;
		#endif
		// the above call does a SafeAddRef/GetGIPCookie which enables GC
		// so grab the object again from the pWrap
		oref = m_pComCallWrapper->GetObjectRef();	
    }
    else
    {
        // probably we can cache the object on a per App domain bases
        // using CCW as the key
        // @TODO:rajak
        OBJECTREF pwrap = NULL;
        GCPROTECT_BEGIN(pwrap);
        pwrap = m_pComCallWrapper->GetObjectRefRareRaw();
        oref = AppDomainHelper::CrossContextCopyFrom(m_dwServerDomainId,
                                                     &pwrap);
        GCPROTECT_END();
    }

    // check if this object requires some special handling of 
    // IUnknown proxy we have
    
    return oref;
}


//--------------------------------------------------------------------
// OBJECTREF COMInterfaceMarshaler::GetObjectForRemoteManagedComponent()
// setup managed proxy to remote object
//--------------------------------------------------------------------
OBJECTREF COMInterfaceMarshaler::GetObjectForRemoteManagedComponent()
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(m_fIsRemote == TRUE);
    _ASSERTE(m_pIManaged != NULL);    
    OBJECTREF oref2 = NULL;
    OBJECTREF oref = NULL;

    GCPROTECT_BEGIN(oref)
    {
        BSTR bstr;
        HRESULT hr;

        BEGIN_ENSURE_PREEMPTIVE_GC();
        
        hr = m_pIManaged->GetSerializedBuffer(&bstr);

        END_ENSURE_PREEMPTIVE_GC();

        if (hr == S_OK)
        {
            _ASSERTE(bstr != NULL);

            // this could throw an exception
            // also this would free up the BSTR that we pass in
            oref = ConvertBSTRToObject(bstr);
            
            if (oref != NULL)
            {
                // setup a COM call wrapper
                ComCallWrapper* pComCallWrap = ComCallWrapper::InlineGetWrapper(&oref);
                _ASSERTE(pComCallWrap != NULL);
                // InlineGetWrapper AddRef's the wrapper
                ComCallWrapper::Release(pComCallWrap);

                #if 0
                // check to see if we need a complus wrapper
                ComPlusWrapper* pWrap = NULL;
                // we have a remoted object
                // check if it is not a marshal byref, i.e. it was fully serialized
                // and brought back here
                if (oref->GetClass()->IsMarshaledByRef() && 
                    CRemotingServices::IsProxyToRemoteObject(oref))
                {
                    // setup a compluswrapper
                    pWrap = ComPlusWrapperCache::GetComPlusWrapperCache()->SetupComPlusWrapperForRemoteObject(m_pUnknown, oref);
                }
                #endif
                
                // GCPROTECT_END will trash the oref
                oref2 = oref;
            }
        }
        else
        {
            COMPlusThrowHR(hr);
        }
    }   
    GCPROTECT_END();    

    return oref2;
}


//--------------------------------------------------------------------------------
// VOID EnsureCOMInterfacesSupported(OBJECTREF oref, MethodTable* m_pClassMT)
// Make sure the oref supports all the COM interfaces in the class
VOID EnsureCOMInterfacesSupported(OBJECTREF oref, MethodTable* m_pClassMT)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(m_pClassMT->IsComObjectType());

    // Make sure the COM object supports all the COM imported interfaces that the new 
    // wrapper class implements.
    int NumInterfaces = m_pClassMT->GetNumInterfaces();
    for (int cItf = 0; cItf < NumInterfaces; cItf++)
    {
        MethodTable *pItfMT = m_pClassMT->GetInterfaceMap()[cItf].m_pMethodTable;
        EEClass* pObjClass = oref->GetClass();
        if (pItfMT->GetClass()->IsComImport())
        {
            if (!pObjClass->SupportsInterface(oref, pItfMT))
                COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_COMOBJECT);
        }
    }
}

//--------------------------------------------------------------------------------
// OBJECTREF COMInterfaceMarshaler::CreateObjectRef(OBJECTREF owner, BOOL fDuplicate)
//  THROWSCOMPLUSEXCEPTION
//--------------------------------------------------------------------------------
OBJECTREF COMInterfaceMarshaler::CreateObjectRef(OBJECTREF owner, BOOL fDuplicate)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(m_pClassMT != NULL);
    _ASSERTE(m_pClassMT->IsComObjectType());    
    
    ComPlusWrapper* pWrap = ComPlusWrapperCache::CreateComPlusWrapper(m_pUnknown, m_pIdentity);
    if (fDuplicate)
    {
       // let us fix the identity to be the wrapper, 
       // so looking up this IUnknown won't return this wrapper
       // this would allow users to call WrapIUnknownWithCOMObject to
       // to create duplicate wrappers
        pWrap->m_pIdentity = pWrap;
        m_pIdentity = (IUnknown*)pWrap;
    }

    if (pWrap == NULL)
    {       
        return NULL;
    }

    OBJECTREF oref = NULL;
    OBJECTREF cref = NULL;
    GCPROTECT_BEGIN(cref)
    {
        // instantiate an instance of m_pClassMT
        cref = ComObject::CreateComObjectRef(m_pClassMT);
        // store the wrapper in the COMObject, for fast access
        // without going to the sync block
        ((COMOBJECTREF)cref)->Init(pWrap);

        // if the passed in owner is null, let us use the cref as the 
        // owner
        if (owner == NULL)
        {
            owner = cref;
        }
        // wire up the instance with the compluswrapper
        // and insert into wrapper cache hash table
        if (cref != NULL)
        {
            // init the wrapper, 
            if (!pWrap->Init((OBJECTREF)owner))
            {
                // failed to Init
                pWrap->CleanupRelease();
                pWrap = NULL;
                cref = NULL; // null out the object we are returning
            }
            else
            {
                // If the class is an extensible RCW and it has a default constructor, then call it.
                if (m_pClassMT->IsExtensibleRCW())
                {
                    MethodDesc *pCtorMD = m_pClassMT->GetClass()->FindConstructor(&gsig_IM_RetVoid);
                    if (pCtorMD)
                    {
                        INT64 CtorArgs[] = { 
                            ObjToInt64(cref)
                        };
                        pCtorMD->Call(CtorArgs);
                    }
                }

               
                
                // see if somebody beat us to it.. 
                ComPlusWrapper *pWrap2 = m_pWrapperCache->FindOrInsertWrapper(m_pIdentity, pWrap);
                if (pWrap2 != pWrap)                    
                {                           
                    // somebody beats us in creating a wrapper
                    // grab the new object
                    cref = (OBJECTREF)pWrap2->GetExposedObject();
                }
                _ASSERTE(cref != NULL);
                
            }
        }
        
        #ifdef _DEBUG   
        if (cref != NULL && m_pClassMT != NULL && m_pClassMT->IsComObjectType())
        {       
            // make sure this object supports all the COM Interfaces in the class
            EnsureCOMInterfacesSupported(cref, m_pClassMT);
        } 
        #endif
        // move the cref to oref, GCPROTECT_END will trash cref
        oref = cref;
    }
    GCPROTECT_END();    

    return oref;
}

// OBJECTREF COMInterfaceMarshaler::HandleTPComponents()
//  THROWSCOMPLUSEXCEPTION
//--------------------------------------------------------------------------------

OBJECTREF COMInterfaceMarshaler::HandleTPComponents()
{
    THROWSCOMPLUSEXCEPTION();
    TRIGGERSGC();
    
    _ASSERTE(m_pIManaged != NULL);
    OBJECTREF oref = NULL;
     
    if(m_fIsRemote  || m_pComCallWrapper->IsObjectTP())
    {
        if (!m_fIsRemote)
        {
            oref = HandleInProcManagedComponent();
    		
        }
        else
        {            
    	    if (m_pClassMT != NULL && !m_pClassMT->IsComObjectType())
    	    {
    	        // if the user wants explicit calls,
    	        // we better serialize/deserialize
    	        oref = GetObjectForRemoteManagedComponent();
    	    }
    	    else // try/catch
    	    {
    		    // let us see if we can serialize/deserialize the remote object
    		    COMPLUS_TRY
    		    {
    			    oref = GetObjectForRemoteManagedComponent();
    			}
    			COMPLUS_CATCH
    			{
    			    // nope let us create a _ComObject
    			    oref = NULL;
    			}
    			COMPLUS_END_CATCH
    	    }    	        
        }            
                
        if (oref != NULL)
        {
            OBJECTREF realProxy = ObjectToOBJECTREF(CRemotingServices::GetRealProxy(OBJECTREFToObject(oref)));
            if(realProxy != NULL)
            {
                OBJECTREF oref2 = NULL;
                // call setIUnknown on real proxy    
                GCPROTECT_BEGIN(oref)
                {
                    HRESULT hr = CRemotingServices::CallSetDCOMProxy(realProxy, m_pUnknown);
                    // ignore the HRESULT
                    oref2 = oref;
                }
                GCPROTECT_END();
                return oref2;
            }                    
            else
            {
                return oref;
            }
        }
    }

    return NULL;
}

//--------------------------------------------------------------------------------
// OBJECTREF COMInterfaceMarshaler::FindOrCreateObjectRef()
// Find the wrapper for this COM IP, might have to create one if not found.
// It will return null for out-of memory scenarios.  It also notices if we have
// an IP that is cunningly disguised as an unmanaged object, sitting on top of a
// managed object.
//*** NOTE: make sure to pass the identity unknown to this function
// and the passed in IUnknown shouldn't be AddRef'ed
//--------------------------------------------------------------------

OBJECTREF COMInterfaceMarshaler::FindOrCreateObjectRef()
{   
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(GetThread()->PreemptiveGCDisabled());
    
    OBJECTREF oref = NULL;   
    
    // (I)
    // Initial check in our cache
    ComPlusWrapper* pWrap = m_pWrapperCache->FindWrapperInCache(m_pIdentity);
    if (pWrap != NULL)
    {
        // protect the exposed object and release the pUnk
        oref = (OBJECTREF)pWrap->GetExposedObject();
        _ASSERTE(oref != NULL);
        return oref;
    }       

    // (II)
    // Initialize all our flags
    // this should setup all the info we need
    InitializeFlags();
	//(III)
	// check for IManaged interface
	if (m_pIManaged)
	{
	    oref = HandleTPComponents();
	    if (oref != NULL)
	        return oref;
    }	
    
    // (III)
    // okay let us create a wrapper and an instance for this IUnknown
    
    // (A)
    // Find a suitable class to instantiate the instance
    InitializeObjectClass();

    oref = CreateObjectRef(NULL, FALSE);
    return oref;
}

//--------------------------------------------------------------------------------
// helper to wrap an IUnknown with COM object and have the hash table
// point to the owner
//--------------------------------------------------------------------------------
OBJECTREF COMInterfaceMarshaler::FindOrWrapWithComObject(OBJECTREF owner)
{   
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(GetThread()->PreemptiveGCDisabled());
    
    OBJECTREF oref = NULL;   
    
    // (I)
    // Initial check in our cache
    /*ComPlusWrapper* pWrap = m_pWrapperCache->FindWrapperInCache(m_pIdentity);
    if (pWrap != NULL)
    {
        // protect the exposed object and release the pUnk
        oref = (OBJECTREF)pWrap->GetExposedObject();
        _ASSERTE(oref != NULL);
        return oref;
    }*/              
    
    oref = CreateObjectRef(owner, TRUE);
    return oref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comevent.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMEvent.cpp
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.ManualResetEvent and System.AutoResetEvent
**
** Date:  August, 1999
**
===========================================================*/
#include "common.h"
#include "object.h"
#include "field.h"
#include "ReflectWrap.h"
#include "excep.h"
#include "COMEvent.h"

HANDLE __stdcall ManualResetEventNative::CorCreateManualResetEvent(CreateEventArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs);
    HANDLE eventHandle =  WszCreateEvent(NULL, // security attributes
                                         TRUE, // manual event
                                         pArgs->initialState,
                                         NULL); // no name
    if (eventHandle == NULL)
    {
        COMPlusThrowWin32();
    }
    return eventHandle;
}

BOOL __stdcall ManualResetEventNative::CorSetEvent(SetEventArgs* pArgs)
{
    _ASSERTE(pArgs);
    _ASSERTE(pArgs->eventHandle);
    return  SetEvent((HANDLE) (pArgs->eventHandle));
}

BOOL __stdcall ManualResetEventNative::CorResetEvent(SetEventArgs* pArgs)
{
    _ASSERTE(pArgs);
    _ASSERTE(pArgs->eventHandle);
    return  ResetEvent((HANDLE) (pArgs->eventHandle));
}

/***************************************************************************************/
HANDLE __stdcall AutoResetEventNative::CorCreateAutoResetEvent(CreateEventArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs);
    HANDLE eventHandle =  WszCreateEvent(NULL, // security attributes
                                         FALSE, // manual event
                                         pArgs->initialState,
                                         NULL); // no name
    if (eventHandle == NULL)
    {
        COMPlusThrowWin32();
    }
    return eventHandle;
}

BOOL __stdcall AutoResetEventNative::CorSetEvent(SetEventArgs* pArgs)
{
    _ASSERTE(pArgs);
    _ASSERTE(pArgs->eventHandle);
    return  SetEvent((HANDLE) (pArgs->eventHandle));
}

BOOL __stdcall AutoResetEventNative::CorResetEvent(SetEventArgs* pArgs)
{
    _ASSERTE(pArgs);
    _ASSERTE(pArgs->eventHandle);
    return  ResetEvent((HANDLE) (pArgs->eventHandle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comhash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
//
//   File:          COMHash.cpp
//
//   Author:        Gregory Fee 
//
//   Purpose:       unmanaged code for managed class System.Security.Policy.Hash
//
//   Date created : February 18, 2000
//
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "excep.h"
#include "CorPerm.h"
#include "CorPermE.h"
#include "COMStringCommon.h"    // RETURN() macro
#include "COMString.h"
#include "COMHash.h"
#include "assembly.hpp"
#include "appdomain.hpp"
#include "assemblyfilehash.h"

LPVOID COMHash::GetRawData( _AssemblyInfo* args )
{
#ifdef PLATFORM_CE
    RETURN( NULL, U1ARRAYREF );
#else // !PLATFORM_CE
    PEFile *pFile;
    U1ARRAYREF retval = NULL;
    PBYTE memLoc;
    DWORD memSize;

    // Create object used to hash the object
    AssemblyFileHash assemblyFileHash;

    if ((args->assembly == NULL) ||
        (!args->assembly->GetAssembly()))
        goto CLEANUP;

    // Grab the PEFile for the manifest module and get a handle
    // to the same file.
    pFile = args->assembly->GetAssembly()->GetManifestFile();

    if (pFile == NULL)
        goto CLEANUP;

    if (pFile->GetFileName() == NULL)
        goto CLEANUP;


    if(FAILED(assemblyFileHash.SetFileName(pFile->GetFileName())))
        goto CLEANUP;

    if(FAILED(assemblyFileHash.GenerateDigest()))
        goto CLEANUP;
    
    memSize = assemblyFileHash.MemorySize();
    retval = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, memSize);

    if (retval == NULL)
        goto CLEANUP;

    // Create a managed array of the proper size.

    memLoc = (PBYTE)retval->GetDirectPointerToNonObjectElements();

#ifdef _DEBUG
    memset( memLoc, 0, memSize);
#endif

    if(FAILED(assemblyFileHash.CopyData(memLoc, memSize)))
        goto CLEANUP;
    
 CLEANUP:
    RETURN( retval, U1ARRAYREF );
#endif // !PLATFORM_CE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cominterfacemarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_COMInterfaceMarshaler_
#define _H_COMInterfaceMarshaler_

//--------------------------------------------------------------------------------
//	class ComInterfaceMarshaler
//--------------------------------------------------------------------------------
class COMInterfaceMarshaler
{
	// initialization info
	ComPlusWrapperCache*	m_pWrapperCache;

	IUnknown* 		m_pUnknown;		// NOT AddRef'ed
	IUnknown* 		m_pIdentity; // NOT AddRef'ed	

	LPVOID			m_pCtxCookie;

	// inited and computed if inited value is NULL
	MethodTable*	m_pClassMT;  

	// computed info
	IManagedObject*	m_pIManaged; // AddRef'ed
	
	BOOL			m_fFlagsInited;
	BOOL			m_fIsComProxy;			
	BOOL			m_fIsRemote;	

	// for TPs
	DWORD		    m_dwServerDomainId;
	ComCallWrapper*	m_pComCallWrapper;
	BSTR			m_bstrProcessGUID;

public:

	COMInterfaceMarshaler();
	virtual ~COMInterfaceMarshaler();
	
	VOID Init(IUnknown* pUnk, MethodTable* pClassMT);

	VOID InitializeFlags();	
	
	VOID InitializeObjectClass();

	OBJECTREF FindOrCreateObjectRef();	

	// helper to wrap an IUnknown with COM object and have the hash table
	// point to the owner
	OBJECTREF FindOrWrapWithComObject(OBJECTREF owner);

private:

	OBJECTREF HandleInProcManagedComponent();
	OBJECTREF HandleTPComponents();	
	OBJECTREF GetObjectForRemoteManagedComponent();
	OBJECTREF CreateObjectRef(OBJECTREF owner, BOOL fDuplicate);

};


#endif // #ifndef _H_COMInterfaceMarshaler_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comisolatedstorage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class: COMIsolatedStorage
 *
 * Author: Shajan Dasan
 *
 * Purpose: Implementation of IsolatedStorage
 *
 * Date:  Feb 14, 2000
 *
 ===========================================================*/

#pragma once

class AccountingInfoStore;

// Dependency in managed : System.IO.IsolatedStorage.IsolatedStorage.cs
#define ISS_ROAMING_STORE   0x08
#define ISS_MACHINE_STORE   0x10

class COMIsolatedStorage
{
public:

	static LPVOID __stdcall GetCaller(LPVOID);

#ifndef UNDER_CE

    static void ThrowISS(HRESULT hr);

private:

    static StackWalkAction StackWalkCallBack(CrawlFrame* pCf, PVOID ppv);

#endif // UNDER_CE

};

class COMIsolatedStorageFile
{
public:

	typedef struct {
	    DECLARE_ECALL_I4_ARG(DWORD, dwFlags);
	} _GetRootDir;

    static LPVOID __stdcall GetRootDir(_GetRootDir*);

	typedef struct {
	    DECLARE_ECALL_PTR_ARG(LPVOID, handle);
	} _GetUsage;

    static UINT64 __stdcall GetUsage(_GetUsage*);

	typedef struct {
	    DECLARE_ECALL_I1_ARG(bool,      fFree);
	    DECLARE_ECALL_PTR_ARG(UINT64 *, pqwReserve);
	    DECLARE_ECALL_PTR_ARG(UINT64 *, pqwQuota);
	    DECLARE_ECALL_PTR_ARG(LPVOID,   handle);
	} _Reserve;

    static void __stdcall Reserve(_Reserve*);

	typedef struct {
	    DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, syncName);
	    DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, fileName);
	} _Open;

    static LPVOID __stdcall Open(_Open*);

	typedef struct {
	    DECLARE_ECALL_PTR_ARG(LPVOID, handle);
	} _Close;

    static void __stdcall Close(_Close*);

	typedef struct {
	    DECLARE_ECALL_I1_ARG(bool,    fLock);
	    DECLARE_ECALL_PTR_ARG(LPVOID, handle);
	} _Lock;

    static void __stdcall Lock(_Lock*);

#ifndef UNDER_CE

private:

    static void GetRootDirInternal(DWORD dwFlags,WCHAR *path, DWORD cPath);
    static void CreateDirectoryIfNotPresent(WCHAR *path);

#endif // UNDER_CE
};

// --- [ Structure of data that gets persisted on disk ] -------------(Begin)

// non-standard extension: 0-length arrays in struct
#pragma warning(disable:4200)
#pragma pack(push, 1)

typedef unsigned __int64 QWORD;

#ifdef UNDER_CE
typedef WORD  ISS_USAGE;
#else
typedef QWORD ISS_USAGE;
#endif  // UNDER_CE

// Accounting Information
typedef struct
{
    ISS_USAGE   cUsage;           // The amount of resource used

#ifndef UNDER_CE
    QWORD       qwReserved[7];    // For future use, set to 0
#endif

} ISS_RECORD;

#pragma pack(pop)
#pragma warning(default:4200)

// --- [ Structure of data that gets persisted on disk ] ---------------(End)

#ifndef UNDER_CE

class AccountingInfo
{
public:

    // The file name is used to open / create the file.
    // A synchronization object will also be created using the sync name

    AccountingInfo(WCHAR *wszFileName, WCHAR *wszSyncName);

    // Init should be called before Reserve / GetUsage is called.

    HRESULT Init();             // Creates the file if necessary

    // Reserves space (Increments qwQuota)
    // This method is synchrinized. If quota + request > limit, method fails

    HRESULT Reserve(
        ISS_USAGE   cLimit,     // The max allowed
        ISS_USAGE   cRequest,   // amount of space (request / free)
        BOOL        fFree);     // TRUE will free, FALSE will reserve

    // Method is not synchronized. So the information may not be current.
    // This implies "Pass if (Request + GetUsage() < Limit)" is an Error!
    // Use Reserve() method instead.

    HRESULT GetUsage(
        ISS_USAGE   *pcUsage);  // [out] The amount of space / resource used

    // Frees cached pointers, Closes handles

    ~AccountingInfo();          

    HRESULT Lock();     // Machine wide Lock
    void    Unlock();   // Unlock the store

private:

    HRESULT Map();      // Maps the store file into memory
    void    Unmap();    // Unmaps the store file from memory
    void    Close();    // Close the store file, and file mapping

private:

    WCHAR          *m_wszFileName;  // The file name
    HANDLE          m_hFile;        // File handle for the file
    HANDLE          m_hMapping;     // File mapping for the memory mapped file

    // members used for synchronization 
    WCHAR          *m_wszName;      // The name of the mutex object
    HANDLE          m_hLock;        // Handle to the Mutex object
#ifdef _DEBUG
    DWORD           m_dwNumLocks;   // The number of locks owned by this object
#endif

    union {
        PBYTE       m_pData;        // The start of file stream
        ISS_RECORD *m_pISSRecord;
    };
};

#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commethodrental.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: Mei-Chin Tsai
// Date: May 6, 1999
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMMETHODRENTAL_H_
#define _COMMETHODRENTAL_H_

#include "excep.h"
#include "ReflectWrap.h"
#include "COMReflectionCommon.h"
#include "fcall.h"

// COMMethodRental
// This class implements SwapMethodBody for our MethodRenting story
class COMMethodRental
{
public:

    // COMMethodRental    
    struct _SwapMethodBodyArgs { 
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
		DECLARE_ECALL_I4_ARG(INT32, flags);
		DECLARE_ECALL_I4_ARG(INT32, iSize);
        DECLARE_ECALL_I4_ARG(LPVOID, rgMethod);
        DECLARE_ECALL_I4_ARG(INT32, tkMethod);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, cls);
    };
	
    // COMMethodRental.SwapMethodBody -- this function will swap an existing method body with
	// a new method body
	//
    static void __stdcall SwapMethodBody(_SwapMethodBodyArgs* args);
};

#endif //_COMMETHODRENTAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commethodrental.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// Author: meichint 
// Date: May, 1999
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "ComMethodRental.h"
#include "CorRegPriv.h"
#include "CorError.h"

Stub *MakeJitWorker(MethodDesc *pMD, COR_ILMETHOD_DECODER* ILHeader, BOOL fSecurity, BOOL fGenerateUpdateableStub, MethodTable *pDispatchingMT, OBJECTREF *pThrowable);
void InterLockedReplacePrestub(MethodDesc* pMD, Stub* pStub);


// SwapMethodBody
// This method will take the rgMethod as the new function body for a given method. 
//
void COMMethodRental::SwapMethodBody(_SwapMethodBodyArgs* args)
{
    EEClass*    eeClass;
	BYTE		*pNewCode		= NULL;
	MethodDesc	*pMethodDesc;
	InMemoryModule *module;
    ICeeGen*	pGen;
    ULONG		methodRVA;
	MethodTable	*pMethodTable;
    HRESULT     hr;

    THROWSCOMPLUSEXCEPTION();

	if ( args->cls == NULL)
    {
        COMPlusThrowArgumentNull(L"cls");
    }

	eeClass	= ((ReflectClass *) args->cls->GetData())->GetClass();
	module = (InMemoryModule *) eeClass->GetModule();
    pGen = module->GetCeeGen();

	Assembly* caller = SystemDomain::GetCallersAssembly( args->stackMark );

	_ASSERTE( caller != NULL && "Unable to get calling assembly" );
	_ASSERTE( module->GetCreatingAssembly() != NULL && "InMemoryModule must have a creating assembly to be used with method rental" );

	if (module->GetCreatingAssembly() != caller)
	{
		COMPlusThrow(kSecurityException);
	}

	// Find the methoddesc given the method token
	pMethodDesc = eeClass->FindMethod(args->tkMethod);
	if (pMethodDesc == NULL)
	{
        COMPlusThrowArgumentException(L"methodtoken", NULL);
	}
    if (pMethodDesc->GetMethodTable()->GetClass() != eeClass)
    {
        COMPlusThrowArgumentException(L"methodtoken", L"Argument_TypeDoesNotContainMethod");
    }
    hr = pGen->AllocateMethodBuffer(args->iSize, &pNewCode, &methodRVA);    
    if (FAILED(hr))
        COMPlusThrowHR(hr);

	if (pNewCode == NULL)
	{
        COMPlusThrowOM();
	}

	// @todo: meichint
	// if method desc is pointing to the post-jitted native code block,
	// we want to recycle this code block

	// @todo: SEH handling. Will we need to support a method that can throw exception
	// If not, add an assertion to make sure that there is no SEH contains in the method header.

	// @todo: figure out a way not to copy the code block.

	// @todo: add link time security check. This function can be executed only if fully trusted.

	// copy the new function body to the buffer
    memcpy(pNewCode, (void *) args->rgMethod, args->iSize);

	// make the descr to point to the new code
	// For in-memory module, it is the blob offset that is stored in the method desc
	pMethodDesc->SetRVA(methodRVA);

    DWORD attrs = pMethodDesc->GetAttrs();
	// do the back patching if it is on vtable
    if (
        (!IsMdRTSpecialName(attrs)) &&
        (!IsMdStatic(attrs)) &&
        (!IsMdPrivate(attrs)) &&
        (!IsMdFinal(attrs)) &&
        !pMethodDesc->GetClass()->IsValueClass())
	{
		pMethodTable = eeClass->GetMethodTable();
		(pMethodTable->GetVtable())[(pMethodDesc)->GetSlot()] = (SLOT)pMethodDesc->GetPreStubAddr();
	}


    if (args->flags)
    {
        // JITImmediate
        OBJECTREF     pThrowable = NULL;
        Stub *pStub = NULL;
#if _DEBUG
    	COR_ILMETHOD* ilHeader = pMethodDesc->GetILHeader();
        _ASSERTE(((BYTE *)ilHeader) == pNewCode);
#endif
    	COR_ILMETHOD_DECODER header((COR_ILMETHOD *)pNewCode, pMethodDesc->GetMDImport()); 

        // minimum validation on the correctness of method header
        if (header.GetCode() == NULL)
            COMPlusThrowHR(VLDTR_E_MD_BADHEADER);

        GCPROTECT_BEGIN(pThrowable);
        pStub = MakeJitWorker(pMethodDesc, &header, FALSE, FALSE, NULL, &pThrowable);
        if (!pStub)
            COMPlusThrow(pThrowable);

        GCPROTECT_END();
    }

    // add feature::
	// If SQL is generating class with inheritance hierarchy, we may need to
	// check the whole vtable to find duplicate entries.

}	// COMMethodRental::SwapMethodBody
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\common.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commember.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This Module contains routines that expose properties of Member (Classes, Constructors
//  Interfaces and Fields)
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"

#include "COMMember.h"
#include "SigFormat.h"
#include "COMVariant.h"
#include "COMString.h"
#include "Method.hpp"
#include "threads.h"
#include "excep.h"
#include "CorError.h"
#include "ComPlusWrapper.h"
#include "security.h"
#include "ExpandSig.h"
#include "remoting.h"
#include "classnames.h"
#include "fcall.h"
#include "DbgInterface.h"
#include "eeconfig.h"
#include "COMCodeAccessSecurityEngine.h"

// Static Fields
MethodTable* COMMember::m_pMTParameter = 0;
MethodTable* COMMember::m_pMTIMember = 0;
MethodTable* COMMember::m_pMTFieldInfo = 0;
MethodTable* COMMember::m_pMTPropertyInfo = 0;
MethodTable* COMMember::m_pMTEventInfo = 0;
MethodTable* COMMember::m_pMTType = 0;
MethodTable* COMMember::m_pMTMethodInfo = 0;
MethodTable* COMMember::m_pMTConstructorInfo = 0;
MethodTable* COMMember::m_pMTMethodBase = 0;

// This is the global access to the InvokeUtil class
InvokeUtil* COMMember::g_pInvokeUtil = 0;

// NOTE: These are defined in CallingConventions.cool.
#define CALLCONV_Standard       0x0001
#define CALLCONV_VarArgs        0x0002
#define CALLCONV_Any            CALLCONV_Standard | CALLCONV_VarArgs
#define CALLCONV_HasThis        0x0020
#define CALLCONV_ExplicitThis   0x0040


// GetFieldInfoToString
// This method will return the string representation of the information in FieldInfo
LPVOID __stdcall COMMember::GetFieldInfoToString(_GetNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv = 0;
    STRINGREF       refSig;
    FieldDesc*      pField;

    // Get the field descr
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    pField = pRF->pField;
    _ASSERTE(pField);

    // Put into a basic block so SigFormat is destroyed before the throw
    {
        FieldSigFormat sigFmt(pField);
        refSig = sigFmt.GetString();
    }
    if (!refSig) {
        _ASSERTE(!"Unable to Create String");
        FATAL_EE_ERROR();
    }
    _ASSERTE(refSig);

    *((STRINGREF *)&rv) = refSig;
    return rv;}

// GetMethodInfoToString
// This method will return the string representation of the information in MethodInfo
LPVOID __stdcall COMMember::GetMethodInfoToString(_GetNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;
    STRINGREF       refSig;
    MethodDesc*     pMeth;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    pMeth = pRM->pMethod;
    if (!pMeth) {
        _ASSERTE(!"MethodDesc Not Found");
        FATAL_EE_ERROR();
    }

        // Put into a basic block so SigFormat is destroyed before the throw
    {
        SigFormat sigFmt(pMeth, pRM->typeHnd);
        refSig = sigFmt.GetString();
    }
    if (!refSig) {
        _ASSERTE(!"Unable to Create String");
        FATAL_EE_ERROR();
    }
    _ASSERTE(refSig);

    *((STRINGREF *)&rv) = refSig;
    return rv;

}

// GetPropInfoToString
// This method will return the string representation of the information in PropInfo
LPVOID __stdcall COMMember::GetPropInfoToString(_GetTokenNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    STRINGREF       refSig;
    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    _ASSERTE(pRC);
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();

    if (!pProp) {
        _ASSERTE(!"Reflect Property Not Found");
        FATAL_EE_ERROR();
    }

    // Put into a basic block so SigFormat is destroyed before the throw
    {
        PropertySigFormat sigFmt(*(MetaSig *)pProp->pSignature,pProp->szName);
        refSig = sigFmt.GetString();
    }
    if (!refSig) {
        _ASSERTE(!"Unable to Create String");
        FATAL_EE_ERROR();
    }
    _ASSERTE(refSig);

    *((STRINGREF *)&rv) = refSig;
    return rv;
}


// GetEventInfoToString
// This method will return the string representation of the information in EventInfo
LPVOID __stdcall COMMember::GetEventInfoToString(_GetNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv = 0;
    STRINGREF       refString;

    // Get the event descr
    ReflectEvent* pRE = (ReflectEvent*) args->refThis->GetData();

    // Locate the signature of the Add method.
    ExpandSig *pSig = pRE->pAdd->GetSig();
    void *pEnum;

    // The first parameter to Add will be the type of the event (a delegate).
    pSig->Reset(&pEnum);
    TypeHandle th = pSig->NextArgExpanded(&pEnum);
    EEClass *pClass = th.GetClass();
    _ASSERTE(pClass);
    _ASSERTE(pClass->IsDelegateClass() || pClass->IsMultiDelegateClass());

    DefineFullyQualifiedNameForClass();
    LPUTF8 szClass = GetFullyQualifiedNameForClass(pClass);

    // Allocate a temporary buffer for the formatted string.
    size_t uLength = strlen(szClass) + 1 + strlen(pRE->szName) + 1;
    LPUTF8 szToString = (LPUTF8)_alloca(uLength);
    sprintf(szToString, "%s %s", szClass, pRE->szName);

    refString = COMString::NewString(szToString);
    if (!refString) {
        _ASSERTE(!"Unable to Create String");
        FATAL_EE_ERROR();
    }
    _ASSERTE(refString);

    *((STRINGREF *)&rv) = refString;
    return rv;
}


// GetMethodName
// This method will return the name of a Method
LPVOID __stdcall COMMember::GetMethodName(_GetNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv                          = NULL;      // Return value
    STRINGREF       refName;
    MethodDesc*     pMeth;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    if (!pRM)
        COMPlusThrow(kNullReferenceException);
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    // Convert the name to a managed string
    refName = COMString::NewString(pMeth->GetName());
    _ASSERTE(refName);

    *((STRINGREF*) &rv) = refName;
    return rv;
}

// GetEventName
// This method will return the name of a Event
LPVOID __stdcall COMMember::GetEventName(_GetTokenNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    STRINGREF       refName;
    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    _ASSERTE(pRC);

    ReflectEvent* pEvent = (ReflectEvent*) args->refThis->GetData();

    // Convert the name to a managed string
    refName = COMString::NewString(pEvent->szName);
    _ASSERTE(refName);

    *((STRINGREF*) &rv) = refName;
    return rv;
}

// GetPropName
// This method will return the name of a Property
LPVOID __stdcall COMMember::GetPropName(_GetTokenNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    STRINGREF       refName;
    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    _ASSERTE(pRC);
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();

    // Convert the name to a managed string
    refName = COMString::NewString(pProp->szName);
    _ASSERTE(refName);

    *((STRINGREF*) &rv) = refName;
    return rv;
}

// GetPropType
// This method will return type of a property
LPVOID __stdcall COMMember::GetPropType(_GetTokenNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    _ASSERTE(pRC);
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    TypeHandle t = pProp->pSignature->GetReturnTypeHandle();
    // Ignore Return because noting has a transparent proxy property
    OBJECTREF o = t.CreateClassObj();

    *((OBJECTREF*) &rv) = o;
    return rv;
}

// GetReturnType
// This method checks gets the signature for a method and returns
//  a class which represents the return type of that class.
LPVOID __stdcall COMMember::GetReturnType(_GetReturnTypeArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle typeHnd;

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    MethodDesc* pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    TypeHandle varTypes;
    if (pRM->typeHnd.IsArray()) 
        varTypes = pRM->typeHnd.AsTypeDesc()->GetTypeParam();
    
    PCCOR_SIGNATURE pSignature; // The signature of the found method
    DWORD       cSignature;
    pMeth->GetSig(&pSignature,&cSignature);
    MetaSig sig(pSignature, pMeth->GetModule());

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    typeHnd = sig.GetReturnProps().GetTypeHandle(sig.GetModule(), &Throwable, FALSE, FALSE, &varTypes);

    if (typeHnd.IsNull()) {
        if (Throwable == NULL)
            COMPlusThrow(kTypeLoadException);
        COMPlusThrow(Throwable);
    }
    GCPROTECT_END();

    // ignore because transparent proxy is not a return type
    OBJECTREF ret = typeHnd.CreateClassObj();
    return(OBJECTREFToObject(ret));
}

/*=============================================================================
** GetParameterTypes
**
** This routine returns an array of Parameters
**
** args->refThis: this Field object reference
**/
LPVOID __stdcall COMMember::GetParameterTypes(_GetParmTypeArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    void*           vp;
    PTRARRAYREF par = g_pInvokeUtil->CreateParameterArray(&args->refThis);
    *((PTRARRAYREF*) &vp) = par;

    return vp;
}

/*=============================================================================
** GetFieldName
**
** The name of this field is returned
**
** args->refThis: this Field object reference
**/
LPVOID __stdcall COMMember::GetFieldName(_GetNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv        = NULL;      // Return value
    STRINGREF       refName;
    FieldDesc*      pField;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    pField = pRF->pField;
    _ASSERTE(pField);

    // Convert the name to a managed string
    refName = COMString::NewString(pField->GetName());
    _ASSERTE(refName);

    *((STRINGREF*) &rv) = refName;
    return rv;
}

/*=============================================================================
** GetDeclaringClass
**
** Returns the class which declared this member. This may be a
** parent of the Class that get(Member)() was called on.  Members are always
** associated with a Class.  You cannot invoke a method/ctor from one class on
** another class even if they have the same signatures.  It is possible to do
** this with Delegates.
**
** args->refThis: this object reference
**/
LPVOID __stdcall COMMember::GetDeclaringClass(_GetDeclaringClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Assign the return value
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();

    _ASSERTE(pRM);

    // return NULL for global member
    if (pRM->pMethod->GetClass()->GetCl() != COR_GLOBAL_PARENT_TOKEN)
        return(OBJECTREFToObject(pRM->typeHnd.CreateClassObj()));
    else
        return NULL;
}

// And the field version of the same thing...
LPVOID __stdcall COMMember::GetFieldDeclaringClass(_GetDeclaringClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID            rv;
    FieldDesc*  pField;
    EEClass*    pVMC;

    // Assign the return value
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    pField = pRF->pField;
    pVMC = pField->GetEnclosingClass();
    _ASSERTE(pVMC);

    // return NULL for global field
    if (pVMC->GetCl() == COR_GLOBAL_PARENT_TOKEN)
        *((REFLECTBASEREF*) &rv) = (REFLECTBASEREF) (size_t)NULL;
    else
        *((REFLECTBASEREF*) &rv) = (REFLECTBASEREF) pVMC->GetExposedClassObject();
    return rv;
}

// GetEventDeclaringClass
// This is the event based version
LPVOID __stdcall COMMember::GetEventDeclaringClass(_GetEventDeclaringClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID            rv;
    ReflectEvent* pEvent = (ReflectEvent*) args->refThis->GetData();
    *((REFLECTBASEREF*) &rv) = (REFLECTBASEREF) pEvent->pDeclCls->GetExposedClassObject();
    return rv;
}

// GetPropDeclaringClass
// This method returns the declaring class for the property
LPVOID __stdcall COMMember::GetPropDeclaringClass(_GetDeclaringClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID            rv;
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    *((REFLECTBASEREF*) &rv) = (REFLECTBASEREF) pProp->pDeclCls->GetExposedClassObject();
    return rv;
}

// GetReflectedClass
// This method will return the Reflected class for all REFLECTBASEREF types.
LPVOID __stdcall COMMember::GetReflectedClass(_GetReflectedClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID            rv = 0;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();

    // Global functions will return a null class.
    if (pRC!=NULL)
        if (args->returnGlobalClass || pRC->GetClass()->GetCl() != COR_GLOBAL_PARENT_TOKEN)
            *((REFLECTBASEREF*) &rv) = (REFLECTBASEREF) pRC->GetClassObject();
    return rv;
}

/*=============================================================================
** GetFieldSignature
**
** Returns the signature of the field.
**
** args->refThis: this object reference
**/
LPVOID __stdcall COMMember::GetFieldSignature(_GETSIGNATUREARGS* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv = 0;
    STRINGREF       refSig;
    FieldDesc*      pField;

    // Get the field descr
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    pField = pRF->pField;
    _ASSERTE(pField);

    // Put into a basic block so SigFormat is destroyed before the throw
    {
        FieldSigFormat sigFmt(pField);
        refSig = sigFmt.GetString();
    }
    if (!refSig) {
        _ASSERTE(!"Unable to Create String");
        FATAL_EE_ERROR();
    }
    _ASSERTE(refSig);

    *((STRINGREF *)&rv) = refSig;
    return rv;
}

// GetAttributeFlags
// This method will return the attribute flag for an Member.  The 
//  attribute flag is defined in the meta data.
INT32 __stdcall COMMember::GetAttributeFlags(_GetAttributeFlagsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    void*     p;
    DWORD   attr = 0;
    EEClass* vm;
    mdToken mb;

    // Get the method Descr  (this should not fail)
    p = args->refThis->GetData();
    MethodTable* thisClass = args->refThis->GetMethodTable();
    if (thisClass == g_pRefUtil->GetClass(RC_Method) || 
        thisClass == g_pRefUtil->GetClass(RC_Ctor)) {
        MethodDesc* pMeth = ((ReflectMethod*) p)->pMethod;
        mb = pMeth->GetMemberDef();
        vm = pMeth->GetClass();
        _ASSERTE(TypeFromToken(mb) == mdtMethodDef);
        attr = pMeth->GetAttrs();
    }
    else if (thisClass == g_pRefUtil->GetClass(RC_Field)) {
        FieldDesc* pFld = ((ReflectField*) p)->pField;
        mb = pFld->GetMemberDef();
        vm = pFld->GetEnclosingClass();
        attr = vm->GetMDImport()->GetFieldDefProps(mb);
    }
    else {
        _ASSERTE(!"Illegal Object call to GetAttributeFlags");
        FATAL_EE_ERROR();
    }

    return (INT32) attr;
}

// GetCallingConvention
// Return the calling convention
INT32 __stdcall COMMember::GetCallingConvention(_GetCallingConventionArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
        //@TODO: Move this into ReflectMethod...
    if (!pRM->pSignature) {
        PCCOR_SIGNATURE pSignature;     // The signature of the found method
        DWORD       cSignature;
        pRM->pMethod->GetSig(&pSignature,&cSignature);
        pRM->pSignature = ExpandSig::GetReflectSig(pSignature,
                                pRM->pMethod->GetModule());
    }
    BYTE callConv = pRM->pSignature->GetCallingConventionInfo();

    // NOTE: These are defined in CallingConventions.cool.
    INT32 retCall;
    if ((callConv & IMAGE_CEE_CS_CALLCONV_MASK) == IMAGE_CEE_CS_CALLCONV_VARARG)
        retCall = CALLCONV_VarArgs;
    else
        retCall = CALLCONV_Standard;

    if ((callConv & IMAGE_CEE_CS_CALLCONV_HASTHIS) != 0)
        retCall |= CALLCONV_HasThis;
    if ((callConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS) != 0)
        retCall |= CALLCONV_ExplicitThis;
    return retCall;
}

// GetMethodImplFlags
// Return the method impl flags
INT32 __stdcall COMMember::GetMethodImplFlags(_GetMethodImplFlagsArgs* args)
{
    void*     p;
    mdToken mb;
    ULONG   RVA;
    DWORD   ImplFlags;

    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    p = args->refThis->GetData();
    EEClass* thisClass = args->refThis->GetClass();
    MethodDesc* pMeth = ((ReflectMethod*) p)->pMethod;
    Module* pModule = pMeth->GetModule();
    mb = pMeth->GetMemberDef();

    pModule->GetMDImport()->GetMethodImplProps(mb, &RVA, &ImplFlags);
    return ImplFlags;
}


// GetEventAttributeFlags
// This method will return the attribute flag for an Event. 
//  The attribute flag is defined in the meta data.
INT32 __stdcall COMMember::GetEventAttributeFlags(_GetTokenAttributeFlagsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectEvent* pEvents = (ReflectEvent*) args->refThis->GetData();
    return pEvents->attr;
}

// GetPropAttributeFlags
// This method will return the attribute flag for the property. 
//  The attribute flag is defined in the meta data.
INT32 __stdcall COMMember::GetPropAttributeFlags(_GetTokenAttributeFlagsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    return pProp->attr;
}

void COMMember::CanAccess(
            MethodDesc* pMeth, RefSecContext *pSCtx, 
            bool checkSkipVer, bool verifyAccess, 
            bool thisIsImposedSecurity, bool knowForSureImposedSecurityState)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!thisIsImposedSecurity  || knowForSureImposedSecurityState);

    BOOL fRet = FALSE;
    BOOL isEveryoneFullyTrusted = FALSE;

    if (thisIsImposedSecurity || !knowForSureImposedSecurityState)
    {
        isEveryoneFullyTrusted = ApplicationSecurityDescriptor::
                                        AllDomainsOnStackFullyTrusted();

        // If all assemblies in the domain are fully trusted then we are not 
        // going to do any security checks anyway..
        if (thisIsImposedSecurity && isEveryoneFullyTrusted)
            return;
    }

    struct _gc
    {
        OBJECTREF refClassNonCasDemands;
        OBJECTREF refClassCasDemands;
        OBJECTREF refMethodNonCasDemands;
        OBJECTREF refMethodCasDemands;
        OBJECTREF refThrowable;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    if (pMeth->RequiresLinktimeCheck())
    {
        // Fetch link demand sets from all the places in metadata where we might
        // find them (class and method). These might be split into CAS and non-CAS
        // sets as well.
        Security::RetrieveLinktimeDemands(pMeth,
                                          &gc.refClassCasDemands,
                                          &gc.refClassNonCasDemands,
                                          &gc.refMethodCasDemands,
                                          &gc.refMethodNonCasDemands);

        if (gc.refClassCasDemands == NULL && gc.refClassNonCasDemands == NULL &&
            gc.refMethodCasDemands == NULL && gc.refMethodNonCasDemands == NULL &&
            isEveryoneFullyTrusted)
        {
            // All code access security demands will pass anyway.
            fRet = TRUE;
            goto Exit1;
        }
    }

    if (verifyAccess)
        InvokeUtil::CheckAccess(pSCtx,
                                pMeth->GetAttrs(),
                                pMeth->GetMethodTable(),
                                REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_MEMBERACCESS);

    // @todo: rudim: re-instate this code once invoke is called correctly again.
    //InvokeUtil::CheckLinktimeDemand(pSCtx, pMeth, true);
    if (pMeth->RequiresLinktimeCheck()) {

            
        // The following logic turns link demands on the target method into full
        // stack walks in order to close security holes in poorly written
        // reflection users.

        _ASSERTE(pMeth);
        _ASSERTE(pSCtx);

        if (pSCtx->GetCallerMethod())
        { 
            // Check for untrusted caller
            // It is possible that wrappers like VBHelper libraries that are
            // fully trusted, make calls to public methods that do not have
            // safe for Untrusted caller custom attribute set.
            // Like all other link demand that gets transformed to a full stack 
            // walk for reflection, calls to public methods also gets 
            // converted to full stack walk

            if (!Security::DoUntrustedCallerChecks(
                pSCtx->GetCallerMethod()->GetAssembly(), pMeth,
                &gc.refThrowable, TRUE))
                COMPlusThrow(gc.refThrowable);
        }

        if (gc.refClassCasDemands != NULL)
            COMCodeAccessSecurityEngine::DemandSet(gc.refClassCasDemands);

        if (gc.refMethodCasDemands != NULL)
            COMCodeAccessSecurityEngine::DemandSet(gc.refMethodCasDemands);

        // Non-CAS demands are not applied against a grant
        // set, they're standalone.
        if (gc.refClassNonCasDemands != NULL)
            Security::CheckNonCasDemand(&gc.refClassNonCasDemands);

        if (gc.refMethodNonCasDemands != NULL)
            Security::CheckNonCasDemand(&gc.refMethodNonCasDemands);

        // We perform automatic linktime checks for UnmanagedCode in three cases:
        //   o  P/Invoke calls.
        //   o  Calls through an interface that have a suppress runtime check
        //      attribute on them (these are almost certainly interop calls).
        //   o  Interop calls made through method impls.
        if (pMeth->IsNDirect() ||
            (pMeth->GetClass()->IsInterface() &&
             pMeth->GetClass()->GetMDImport()->GetCustomAttributeByName(pMeth->GetClass()->GetCl(),
                                                                        COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                                        NULL,
                                                                        NULL) == S_OK) ||
            (pMeth->IsComPlusCall() && !pMeth->IsInterface()))
            COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);
    }

Exit1:;

    GCPROTECT_END();

    if (!fRet)
    {
    // @todo: rudim: this one too
    //if (checkSkipVer && !Security::CanSkipVerification(pSCtx->GetCallerMethod()->GetModule()))
        //Security::ThrowSecurityException(g_SecurityPermissionClassName, SPFLAGSSKIPVERIFICATION);
        if (checkSkipVer)
            COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);
    }
}


void COMMember::CanAccessField(ReflectField* pRF, RefSecContext *pCtx)
{
    THROWSCOMPLUSEXCEPTION();

    // Check whether the field itself is well formed, i.e. if the field type is
    // accessible to the field's enclosing type. If not, we'll throw a field
    // access exception to stop the field being used.
    EEClass *pEnclosingClass = pRF->pField->GetEnclosingClass();

    EEClass *pFieldClass = GetUnderlyingClass(&pRF->thField);
    if (pFieldClass && !ClassLoader::CanAccessClass(pEnclosingClass,
                                                    pEnclosingClass->GetAssembly(),
                                                    pFieldClass,
                                                    pFieldClass->GetAssembly()))
        COMPlusThrow(kFieldAccessException);

    // Perform the normal access check (caller vs field).
    if (!pRF->pField->IsPublic() || !pRF->pField->GetEnclosingClass()->IsExternallyVisible())
        InvokeUtil::CheckAccess(pCtx,
                                pRF->dwAttr,
                                pRF->pField->GetMethodTableOfEnclosingClass(),
                                REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_FIELDACCESS);
}

// For a given type handle, return the EEClass which should be checked for
// accessibility to that type. Return NULL if the type is always accessible.
EEClass *COMMember::GetUnderlyingClass(TypeHandle *pTH)
{
    EEClass *pRetClass = NULL;

    if (pTH->IsTypeDesc()) {
        // Need to special case non-simple types.
        TypeDesc *pTypeDesc = pTH->AsTypeDesc();
        switch (pTypeDesc->GetNormCorElementType()) {
        case ELEMENT_TYPE_PTR:
        case ELEMENT_TYPE_BYREF:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_SZARRAY:
            // Parameterized types with a single base type. Check access to that
            // type.
            if (pTypeDesc->GetMethodTable())
                pRetClass = pTypeDesc->GetMethodTable()->GetClass();
            else {
                TypeHandle hArgType = pTypeDesc->GetTypeParam();
                pRetClass = GetUnderlyingClass(&hArgType);
            }
            break;
        case ELEMENT_TYPE_FNPTR:
            // No access restrictions on function pointers.
            break;
        default:
            _ASSERTE(!"@todo: Need to deal with new parameterized types as they are added.");
        }
    } else
        pRetClass = pTH->AsClass();

    return pRetClass;
}


// Hack to require full trust for some methods that perform stack walks and
// therefore could cause a problem if called through reflection indirected
// through a trusted wrapper.  
bool IsDangerousMethod(MethodDesc *pMD)
{
    static MethodTable *s_pTypeAppDomain = NULL;
    static MethodTable *s_pTypeAssembly = NULL;
    static MethodTable *s_pTypeAssemblyBuilder = NULL;
    static MethodTable *s_pTypeMethodRental = NULL;
    static MethodTable *s_pTypeIsolatedStorageFile = NULL;
    static MethodTable *s_pTypeMethodBase = NULL;
    static MethodTable *s_pTypeRuntimeMethodInfo = NULL;
    static MethodTable *s_pTypeConstructorInfo = NULL;
    static MethodTable *s_pTypeRuntimeConstructorInfo = NULL;
    static MethodTable *s_pTypeType = NULL;
    static MethodTable *s_pTypeRuntimeType = NULL;
    static MethodTable *s_pTypeFieldInfo = NULL;
    static MethodTable *s_pTypeRuntimeFieldInfo = NULL;
    static MethodTable *s_pTypeEventInfo = NULL;
    static MethodTable *s_pTypeRuntimeEventInfo = NULL;
    static MethodTable *s_pTypePropertyInfo = NULL;
    static MethodTable *s_pTypeRuntimePropertyInfo = NULL;
    static MethodTable *s_pTypeResourceManager = NULL;
    static MethodTable *s_pTypeActivator = NULL;

    // One time only initialization. Check relies on write ordering.
    if (s_pTypeActivator == NULL) {
        s_pTypeAppDomain = g_Mscorlib.FetchClass(CLASS__APP_DOMAIN);
        s_pTypeAssembly = g_Mscorlib.FetchClass(CLASS__ASSEMBLY);
        s_pTypeAssemblyBuilder = g_Mscorlib.FetchClass(CLASS__ASSEMBLY_BUILDER);
        s_pTypeMethodRental = g_Mscorlib.FetchClass(CLASS__METHOD_RENTAL);
        s_pTypeIsolatedStorageFile = g_Mscorlib.FetchClass(CLASS__ISS_STORE_FILE);
        s_pTypeMethodBase = g_Mscorlib.FetchClass(CLASS__METHOD_BASE);
        s_pTypeRuntimeMethodInfo = g_Mscorlib.FetchClass(CLASS__METHOD);
        s_pTypeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR_INFO);
        s_pTypeRuntimeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR);
        s_pTypeType = g_Mscorlib.FetchClass(CLASS__TYPE);
        s_pTypeRuntimeType = g_Mscorlib.FetchClass(CLASS__CLASS);
        s_pTypeFieldInfo = g_Mscorlib.FetchClass(CLASS__FIELD_INFO);
        s_pTypeRuntimeFieldInfo = g_Mscorlib.FetchClass(CLASS__FIELD);
        s_pTypeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT_INFO);
        s_pTypeRuntimeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT);
        s_pTypePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY_INFO);
        s_pTypeRuntimePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY);
        s_pTypeResourceManager = g_Mscorlib.FetchClass(CLASS__RESOURCE_MANAGER);
        s_pTypeActivator = g_Mscorlib.FetchClass(CLASS__ACTIVATOR);
    }
    _ASSERTE(s_pTypeAppDomain &&
             s_pTypeAssembly &&
             s_pTypeAssemblyBuilder &&
             s_pTypeMethodRental &&
             s_pTypeIsolatedStorageFile &&
             s_pTypeMethodBase &&
             s_pTypeRuntimeMethodInfo &&
             s_pTypeConstructorInfo &&
             s_pTypeRuntimeConstructorInfo &&
             s_pTypeType &&
             s_pTypeRuntimeType &&
             s_pTypeFieldInfo &&
             s_pTypeRuntimeFieldInfo &&
             s_pTypeEventInfo &&
             s_pTypeRuntimeEventInfo &&
             s_pTypePropertyInfo &&
             s_pTypeRuntimePropertyInfo &&
             s_pTypeResourceManager &&
             s_pTypeActivator);

    MethodTable *pMT = pMD->GetMethodTable();

    return pMT == s_pTypeAppDomain ||
           pMT == s_pTypeAssembly ||
           pMT == s_pTypeAssemblyBuilder ||
           pMT == s_pTypeMethodRental ||
           pMT == s_pTypeIsolatedStorageFile ||
           pMT == s_pTypeMethodBase ||
           pMT == s_pTypeRuntimeMethodInfo ||
           pMT == s_pTypeConstructorInfo ||
           pMT == s_pTypeRuntimeConstructorInfo ||
           pMT == s_pTypeType ||
           pMT == s_pTypeRuntimeType ||
           pMT == s_pTypeFieldInfo ||
           pMT == s_pTypeRuntimeFieldInfo ||
           pMT == s_pTypeEventInfo ||
           pMT == s_pTypeRuntimeEventInfo ||
           pMT == s_pTypePropertyInfo ||
           pMT == s_pTypeRuntimePropertyInfo ||
           pMT == s_pTypeResourceManager ||
           pMT == s_pTypeActivator ||
           pMT->GetClass()->IsAnyDelegateClass() ||
           pMT->GetClass()->IsAnyDelegateExact();
}


/*=============================================================================
** InvokeMethod
**
** This routine will invoke the method on an object.  It will verify that
**  the arguments passed are correct
**
** args->refThis: this object reference
**/
LPVOID __stdcall COMMember::InvokeMethod(_InvokeMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv = 0;
    MethodDesc*     pMeth;
    UINT            argCnt;
    EEClass*        eeClass;
    int             thisPtr;
    INT64           ret = 0;
    EEClass*        pEECValue = 0;
    void*           pRetValueClass = 0;

    // Setup the Method
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    _ASSERTE(pRM);
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);
    TypeHandle methodTH;
    if (pRM->typeHnd.IsArray()) 
        methodTH = pRM->typeHnd;
    eeClass = pMeth->GetClass();
    //WARNING: for array this is not the "real" class but rather the element type. However that is what we need to
    //         do the checks later on. 

    _ASSERTE(eeClass);

    DWORD attr = pRM->attrs;
    ExpandSig* mSig = pRM->GetSig();

    if (mSig->IsVarArg()) 
        COMPlusThrow(kNotSupportedException, IDS_EE_VARARG_NOT_SUPPORTED);

    // Get the number of args on this element
    argCnt = (int) mSig->NumFixedArgs();
    thisPtr = (IsMdStatic(attr)) ? 0 : 1;

    _ASSERTE(!(IsMdStatic(attr) && IsMdVirtual(attr)) && "A method can't be static and virtual.  How did this happen?");

    DWORD dwFlags = pRM->dwFlags;
    if (!(dwFlags & RM_ATTR_INITTED))
    {
        // First work with the local, to prevent race conditions

        // Is this a call to a potentially dangerous method? (If so, we're going
        // to demand additional permission).
        if (IsDangerousMethod(pMeth))
            dwFlags |= RM_ATTR_RISKY_METHOD;

        // Is something attempting to invoke a .ctor directly?
        if (pMeth->IsCtor())
            dwFlags |= RM_ATTR_IS_CTOR;

        // Is a security check required ?
        if (!IsMdPublic(attr) || pMeth->RequiresLinktimeCheck() || !eeClass->IsExternallyVisible() || dwFlags & RM_ATTR_IS_CTOR || args->caller != NULL)
        {
            dwFlags |= RM_ATTR_NEED_SECURITY;
            if (pMeth->RequiresLinktimeCheck())
            {
                 // Check if we are imposing a security check on the caller though the callee didnt ask for it
                 // DONT USE THE GC REFS OTHER THAN FOR TESTING NULL !!!!!
                 OBJECTREF refClassCasDemands = NULL, refClassNonCasDemands = NULL, refMethodCasDemands = NULL, refMethodNonCasDemands = NULL;
                 Security::RetrieveLinktimeDemands(pMeth, &refClassCasDemands, &refClassNonCasDemands, &refMethodCasDemands, &refMethodNonCasDemands);
                 if (refClassCasDemands == NULL && refClassNonCasDemands == NULL && refMethodCasDemands == NULL && refMethodNonCasDemands == NULL)
                     dwFlags |= RM_ATTR_SECURITY_IMPOSED;

            }
        }

        // Do we need to get prestub address to find target ?
        if ((pMeth->IsComPlusCall() && args->target != NULL 
             && (args->target->GetMethodTable()->IsComObjectType()
                 || args->target->GetMethodTable()->IsTransparentProxyType()
                 || args->target->GetMethodTable()->IsCtxProxyType()))
            || pMeth->IsECall() || pMeth->IsIntercepted() || pMeth->IsRemotingIntercepted())
            dwFlags |= RM_ATTR_NEED_PRESTUB;

        if (pMeth->IsEnCMethod() && !pMeth->IsVirtual()) {
            dwFlags |= RM_ATTR_NEED_PRESTUB;
        }

        // Is this a virtual method ?
        if (pMeth->DontVirtualize() || pMeth->GetClass()->IsValueClass())
            dwFlags |= RM_ATTR_DONT_VIRTUALIZE;

        dwFlags |= RM_ATTR_INITTED;
        pRM->dwFlags = dwFlags;
    }

    // Check whether we're allowed to call certain dangerous methods.
    if (dwFlags & RM_ATTR_RISKY_METHOD)
        COMCodeAccessSecurityEngine::SpecialDemand(REFLECTION_MEMBER_ACCESS);

    // Make sure we're not invoking on a save-only dynamic assembly
    // Check reflected class
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    if (pRC)
    {
        Assembly *pAssem = pRC->GetClass()->GetAssembly();
        if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
            COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");
    }

    // Check declaring class
    Assembly *pAssem = eeClass->GetAssembly();
    if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
    {
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");
    }

    TypeHandle targetTH;
    EEClass* targetClass = NULL;
    if (args->target != NULL) 
    {
        TypeHandle targetHandle = args->target->GetTypeHandle();
        if (targetHandle.IsArray()) 
            targetTH = targetHandle; 
        targetClass = args->target->GetTrueClass();;
    }

    VerifyType(&args->target, eeClass, targetClass, thisPtr, &pMeth, methodTH, targetTH);

    // Verify that the method isn't one of the special security methods that
    // alter the caller's stack (to add or detect a security frame object).
    // These must be early bound to work (since the direct caller is
    // reflection).
    if (IsMdRequireSecObject(attr))
    {
        COMPlusThrow(kArgumentException, L"Arg_InvalidSecurityInvoke");
    }

    // Verify that we have been provided the proper number of args
    if (!args->objs) {
        if (argCnt > 0) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }
    else {
        if (args->objs->GetNumComponents() != argCnt) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }

    // this security context will be used in cast checking as well
    RefSecContext sCtx;

    // Validate the method can be called by this caller
    

    if (dwFlags & RM_ATTR_NEED_SECURITY) 
    {
        DebuggerSecurityCodeMarkFrame __dbgSecFrame;
        
        if (args->caller == NULL) {
            if (args->target != NULL) {
                if (!args->target->GetTypeHandle().IsTypeDesc())
                    sCtx.SetClassOfInstance(targetClass);
            }

            CanAccess(pMeth, &sCtx, (dwFlags & RM_ATTR_IS_CTOR) != 0, args->verifyAccess != 0, (dwFlags & RM_ATTR_SECURITY_IMPOSED) != 0, TRUE);
        }
        else
        {
            // Calling assembly passed in explicitly.

            // Access check first.
            if (!pMeth->GetClass()->IsExternallyVisible() || !pMeth->IsPublic())
            {
                DWORD dwAttrs = pMeth->GetAttrs();
                if ((!IsMdAssem(dwAttrs) && !IsMdFamORAssem(dwAttrs)) ||
                    (args->caller->GetAssembly() != pMeth->GetAssembly()))
                    
                    COMCodeAccessSecurityEngine::SpecialDemand(REFLECTION_MEMBER_ACCESS);
            }

            // Now check for security link time demands.
            if (pMeth->RequiresLinktimeCheck())
            {
                OBJECTREF refThrowable = NULL;
                GCPROTECT_BEGIN(refThrowable);
                if (!Security::LinktimeCheckMethod(args->caller->GetAssembly(), pMeth, &refThrowable))
                    COMPlusThrow(refThrowable);
                GCPROTECT_END();
            }
        }
        
        __dbgSecFrame.Pop();
    }
    
    // We need to Prevent GC after we begin to build the stack. Validate the
    // arguments first.
    bool fDefaultBinding = (args->attrs & BINDER_ExactBinding) || args->binder == NULL || args->isBinderDefault;
    void* pEnum;

    // Walk all of the args and allow the binder to change them
    mSig->Reset(&pEnum);
    for (int i=0;i< (int) argCnt;i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);

        // Check the caller has access to the arg type.
        EEClass *pArgClass = GetUnderlyingClass(&th);
        if (pArgClass && !pArgClass->IsExternallyVisible())
            InvokeUtil::CheckAccessType(&sCtx, pArgClass, REFSEC_THROW_MEMBERACCESS);

        // Finished with this arg if we're using default binding.
        if (fDefaultBinding)
            continue;

        // If we are the universal null then we can continue..
        if (args->objs->m_Array[i] == 0)
            continue;

        DebuggerSecurityCodeMarkFrame __dbgSecFrame;
        
        // if the src cannot be cast to the dest type then 
        //  call the change type to let them fix it.
        TypeHandle srcTh = (args->objs->m_Array[i])->GetTypeHandle();
        if (!srcTh.CanCastTo(th)) {
            OBJECTREF or = g_pInvokeUtil->ChangeType(args->binder,args->objs->m_Array[i],th,args->locale);
            args->objs->SetAt(i, or);
        }
        
        __dbgSecFrame.Pop();
    }

    // Establish the enumerator through the signature
    mSig->Reset(&pEnum);

#ifndef _X86_

    // Build the arguments.  This is built as a single array of arguments
    //  the this pointer is first All of the rest of the args are placed in reverse order
    UINT    nStackBytes = mSig->SizeOfVirtualFixedArgStack(IsMdStatic(attr));

    UINT total_alloc = nStackBytes ;
    
    BYTE * pTmpPtr = (BYTE*) _alloca(total_alloc);

    BYTE *  pNewArgs = (BYTE *) pTmpPtr;

    BYTE *  pDst= pNewArgs;
    
    // Move to the last position in the stack
    pDst += nStackBytes;
    if (mSig->IsRetBuffArg()) {
        // if we have the magic Value Class return, we need to allocate that class
        //  and place a pointer to it on the class stack.
        pEECValue = mSig->GetReturnClass();
        _ASSERTE(pEECValue->IsValueClass());
        pRetValueClass = _alloca(pEECValue->GetAlignedNumInstanceFieldBytes());
        memset(pRetValueClass,0,pEECValue->GetAlignedNumInstanceFieldBytes());
        UINT cbSize = mSig->GetStackElemSize(ELEMENT_TYPE_BYREF,pEECValue);
        pDst -= cbSize;
        *((void**) pDst) = pRetValueClass;
    }

    for (int i = 0; i < (int)argCnt; i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);
        // This routine will verify that all types are correct.
        g_pInvokeUtil->CheckArg(th, &(args->objs->m_Array[i]), &sCtx);
    }

#ifdef STRESS_HEAP
    if (g_pConfig->GetGCStressLevel() != 0)
        g_pGCHeap->StressHeap();
#endif
    
    // NO GC AFTER THIS POINT
    // actually this statement is not completely accurate. If an exception occurs a gc may happen
    // but we are going to dump the stack anyway and we do not need to protect anything.
    // But if anywhere between here and the method invocation we enter preemptive mode the stack
    // we are about to setup (pDst in the loop) may contain references to random parts of memory
    
    // copy args
    mSig->Reset(&pEnum);
    for (int i = 0; i < (int)argCnt; i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);
        UINT cbSize = mSig->GetStackElemSize(th);
        pDst -= cbSize;
        g_pInvokeUtil->CopyArg(th, &(args->objs->m_Array[i]), pDst);
    }
    // Copy "this" pointer
    if (thisPtr) {
        //WARNING: because eeClass is not the real class for arrays and because array are reference types 
        //         we need to do the extra check if the eeClass happens to be a value type
        if (!eeClass->IsValueClass() || targetTH.IsArray())
            *(OBJECTREF *) pNewArgs = args->target;
        else {
            if (pMeth->IsVirtual())
                *(OBJECTREF *) pNewArgs = args->target;
            else
                *((void**) pNewArgs) = args->target->UnBox();
        }
    }

    // Call the method
    COMPLUS_TRY {
        MetaSig threadSafeSig(*mSig);
        if (pMeth->IsInterface()) {
            // This should only happen for interop.
            _ASSERTE(args->target->GetTrueClass()->GetMethodTable()->IsComObjectType());
            ret = pMeth->CallOnInterface(pNewArgs,&threadSafeSig); //, attr);
        } else
            ret = pMeth->Call(pNewArgs,&threadSafeSig); //, attr);
    } COMPLUS_CATCH {
        // If we get here we need to throw an TargetInvocationException
        OBJECTREF ppException = GETTHROWABLE();
        _ASSERTE(ppException);
        GCPROTECT_BEGIN(ppException);
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
        COMPlusThrow(except);
        GCPROTECT_END();
    } COMPLUS_END_CATCH

#else // i.e, if _X86_

    UINT   nActualStackBytes = mSig->SizeOfActualFixedArgStack(IsMdStatic(attr));

    // Create a fake FramedMethodFrame on the stack.
    LPBYTE pAlloc = (LPBYTE)_alloca(FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + nActualStackBytes);

    LPBYTE pFrameBase = pAlloc + FramedMethodFrame::GetNegSpaceSize();

    // Get starting points for arguments
    int stackVarOfs = sizeof(FramedMethodFrame) + nActualStackBytes;
    int regVarOfs   = FramedMethodFrame::GetOffsetOfArgumentRegisters();

    for (int i=0;i< (int) argCnt;i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);
        // This routine will verify that all types are correct.
        g_pInvokeUtil->CheckArg(th, &(args->objs->m_Array[i]), &sCtx);
    }
    
    OBJECTREF objRet = NULL;
    GCPROTECT_BEGIN(objRet);

    int numRegistersUsed = 0;
    int retBuffOfs;
    
    // Take care of any return arguments
    if (mSig->IsRetBuffArg()) {
        // if we have the magic Value Class return, we need to allocate that class
        //  and place a pointer to it on the class stack.
        pEECValue = mSig->GetReturnClass();
        _ASSERTE(pEECValue->IsValueClass());
        MethodTable * mt = pEECValue->GetMethodTable();
        objRet = AllocateObject(mt);

        // Find the offset of return argument (plagiarised from ArgIterator::GetRetBuffArgOffset)
        retBuffOfs = regVarOfs + (NUM_ARGUMENT_REGISTERS - 1)* sizeof(void*);
        if (thisPtr) {
            retBuffOfs -= sizeof(void*);
        }

        numRegistersUsed++;
    }


#ifdef STRESS_HEAP
    if (g_pConfig->GetGCStressLevel() != 0)
        g_pGCHeap->StressHeap();
#endif
    
    // Some other stuff needed to lay the arguments
    BYTE callingconvention = mSig->GetCallingConvention();
    int offsetIntoArgumentRegisters = 0;

    // NO GC AFTER THIS POINT 
    // actually this statement is not completely accurate. If an exception occurs a gc may happen
    // but we are going to dump the stack anyway and we do not need to protect anything.
    // But if anywhere between here and the method invocation we enter preemptive mode the stack
    // we are about to setup (pDest in the loop) may contain references to random parts of memory

    // Copy "this" pointer
    int    thisOfs = FramedMethodFrame::GetOffsetOfThis();
    if (thisPtr) {

        void *pTempThis = NULL;
        //WARNING: because eeClass is not the real class for arrays and because array are reference types 
        //         we need to do the extra check if the eeClass happens to be a value type
        if (!eeClass->IsValueClass() || targetTH.IsArray())
        {
            pTempThis = OBJECTREFToObject(args->target);

#if CHECK_APP_DOMAIN_LEAKS
            if (g_pConfig->AppDomainLeaks())
                if (pTempThis != NULL)
                {
                    if (!((Object *)pTempThis)->AssignAppDomain(GetAppDomain()))
                        _ASSERTE(!"Attempt to call method on object in wrong domain");
                }
#endif

        }
        else 
        {
            if (pMeth->IsVirtual())
                pTempThis = OBJECTREFToObject(args->target);
            else
                pTempThis = args->target->UnBox();
        }
        *((void**)(pFrameBase + thisOfs)) = pTempThis;

        // Make the increment to number of registers used
        numRegistersUsed++;
    }

    // Now copy the arguments
    BYTE *pDest;
    BOOL isSigInitted = mSig->AreOffsetsInitted();

    mSig->Reset(&pEnum);
    for (int i = 0 ; i < (int) argCnt ; i++) {

        TypeHandle th = mSig->NextArgExpanded(&pEnum);

        short ofs, frameOffset;
        UINT structSize = 0;
        BYTE type;

        if (isSigInitted)
        {
            mSig->GetInfoForArg(i, &ofs, (short *)&structSize, &type);
            if (ofs != -1)
            {
                frameOffset = regVarOfs + ofs;
            }
            else
            {
                stackVarOfs -= StackElemSize(structSize);
                frameOffset = stackVarOfs;
            }
        }
        else
        {
            UINT cbSize = mSig->GetElemSizes(th, &structSize);

            BYTE typ = th.GetNormCorElementType();

            if (IsArgumentInRegister(&numRegistersUsed, typ, structSize, FALSE, callingconvention, &offsetIntoArgumentRegisters)) {
                frameOffset = regVarOfs + offsetIntoArgumentRegisters;
            } else {
                stackVarOfs -= StackElemSize(structSize);
                frameOffset = stackVarOfs;
            }
        }

#ifdef _DEBUG
        if ((thisPtr &&
            (frameOffset == thisOfs ||
             (frameOffset == thisOfs-4 && StackElemSize(structSize) == 8)))
            || (thisPtr && frameOffset < 0 && StackElemSize(structSize) > 4)
            || (!thisPtr && frameOffset < 0 && StackElemSize(structSize) > 8))
            _ASSERTE(!"This can not happen! The stack for enregistered args is trashed! Possibly a race condition in MetaSig::ForceSigWalk.");
#endif

        pDest = pFrameBase + frameOffset;

        g_pInvokeUtil->CopyArg(th, &(args->objs->m_Array[i]), pDest);
    }

    // Find the target
    const BYTE *pTarget = NULL;
    if (dwFlags & RM_ATTR_NEED_PRESTUB) {
        if (dwFlags & RM_ATTR_DONT_VIRTUALIZE) 
            pTarget = pMeth->GetPreStubAddr();
        else {

            MethodDesc *pDerivedMeth = NULL;
            if (targetClass)
            {
                if ((pMeth->IsComPlusCall() && targetClass->GetMethodTable()->IsExtensibleRCW()) ||
                     pMeth->IsECall() || pMeth->IsIntercepted())
                {
                    // It's an invocation over a managed class that derives from a com import
                    // or an intercepted or ECall method so we need to get the derived implementation if any.
                    if (pMeth->GetMethodTable()->IsInterface())
                        pDerivedMeth = args->target->GetMethodTable()->GetMethodDescForInterfaceMethod(pMeth);
                    else 
                        pDerivedMeth = targetClass->GetMethodDescForSlot(pMeth->GetSlot());
                }
            }
            
            // we have something else to look at in the derived class
            if (pDerivedMeth) {
                if (pDerivedMeth->IsComPlusCall() || pDerivedMeth->IsECall() || pDerivedMeth->IsIntercepted()) {
                    pTarget = pDerivedMeth->GetPreStubAddr();
                } else {
                    pTarget = pDerivedMeth->GetAddrofCode(args->target);
                }
            }
            else
                pTarget = pMeth->GetPreStubAddr();
        }
    } else {
        if (dwFlags & RM_ATTR_DONT_VIRTUALIZE) {
            pTarget = pMeth->GetAddrofCode();
        } else {
            pTarget = pMeth->GetAddrofCode(args->target);
        }
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pTarget);
#endif // DEBUGGING_SUPPORTED

    // Now call the target..
    COMPLUS_TRY
    {
        INSTALL_COMPLUS_EXCEPTION_HANDLER();
        
        if (mSig->IsRetBuffArg()) {
            _ASSERTE(objRet);
            *((void**)(pFrameBase + retBuffOfs)) = objRet->UnBox();
        }

        ret = CallDescrWorker(pFrameBase + sizeof(FramedMethodFrame) + nActualStackBytes,
                                 nActualStackBytes / STACK_ELEM_SIZE,
                                 (ArgumentRegisters*)(pFrameBase + regVarOfs),
                                 (LPVOID)pTarget);
        UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    } COMPLUS_CATCH {
        // If we get here we need to throw an TargetInvocationException
        OBJECTREF ppException = GETTHROWABLE();
        _ASSERTE(ppException);
        GCPROTECT_BEGIN(ppException);
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
        COMPlusThrow(except);
        GCPROTECT_END();
    } COMPLUS_END_CATCH

    getFPReturn(mSig->GetFPReturnSize(), ret);

#endif

    GCPROTECT_END();

    if (!pEECValue) {
        TypeHandle th = mSig->GetReturnTypeHandle();
        objRet =  g_pInvokeUtil->CreateObject(th,ret);
    }
  
    *((OBJECTREF *)&rv) = objRet;
    
    return rv;
}

// This method will verify the type relationship between the target and
//      the eeClass of the method we are trying to invoke.  It checks that for 
//      non static method, target is provided.  It also verifies that the target is
//      a subclass or implements the interface that this MethodInfo represents.  
//  We may update the MethodDesc in the case were we need to lookup the real
//      method implemented on the object for an interface.
void COMMember::VerifyType(OBJECTREF *target, 
                           EEClass* eeClass, 
                           EEClass* targetClass, 
                           int thisPtr, 
                           MethodDesc** ppMeth, 
                           TypeHandle typeTH, 
                           TypeHandle targetTH)
{
    THROWSCOMPLUSEXCEPTION();

    // Make sure that the eeClass is defined if there is a this pointer.
    _ASSERTE(thisPtr == 0 || eeClass != 0);

    // Verify Static/Object relationship
    if (!*target) {
        if (thisPtr == 1) {
            // Non-static without a target...
            COMPlusThrow(kTargetException,L"RFLCT.Targ_StatMethReqTarg");
        }
        return;
    }

    //  validate the class/method relationship
    if (thisPtr && (targetClass != eeClass || typeTH != targetTH)) {

        BOOL bCastOK = false;
        if((*target)->GetClass()->IsThunking())
        {
            // This could be a proxy and we may not have refined it to a type
            // it actually supports.
            bCastOK = CRemotingServices::CheckCast(*target, eeClass);
        }

        if (!bCastOK)
        {
            // If this is an interface we need to find the real method
            if (eeClass->IsInterface()) {
                DWORD slot = 0;
                InterfaceInfo_t* pIFace = targetClass->FindInterface(eeClass->GetMethodTable());
                if (!pIFace) {
                    if (!targetClass->GetMethodTable()->IsComObjectType() ||
                        !ComObject::SupportsInterface(*target, eeClass->GetMethodTable()))
                    { 
                        // Interface not found for the object
                        COMPlusThrow(kTargetException,L"RFLCT.Targ_IFaceNotFound");
                    }
                }
                else
                {
                    slot = (*ppMeth)->GetSlot() + pIFace->m_wStartSlot;
                    MethodDesc* newMeth = targetClass->GetMethodDescForSlot(slot);          
                    _ASSERTE(newMeth != NULL);
                    *ppMeth = newMeth;
                }
            }
            else {
                // check the array case 
                if (!targetTH.IsNull()) {
                    // recevier is an array
                    if (targetTH == typeTH ||
                        eeClass == g_Mscorlib.GetClass(CLASS__ARRAY)->GetClass() ||
                        eeClass == g_Mscorlib.GetClass(CLASS__OBJECT)->GetClass()) 
                        return;
                    else
                        COMPlusThrow(kTargetException,L"RFLCT.Targ_ITargMismatch");
                }
                else if (!typeTH.IsNull())
                    COMPlusThrow(kTargetException,L"RFLCT.Targ_ITargMismatch");

                while (targetClass && targetClass != eeClass)
                    targetClass = targetClass->GetParentClass();

                if (!targetClass) {

                    // The class defined for this method is not a super class of the
                    //  target object
                    COMPlusThrow(kTargetException,L"RFLCT.Targ_ITargMismatch");
                }
            }
        }
    }
    return;
}


// This is an internal helper function to TypedReference class. 
// We already have verified that the types are compatable. Assing the object in args
// to the typed reference
void __stdcall COMMember::ObjectToTypedReference(_ObjectToTypedReferenceArgs* args)
{
    g_pInvokeUtil->CreateTypedReference((InvokeUtil::_ObjectToTypedReferenceArgs *)(args));  
}

// This is an internal helper function to TypedReference class. 
// It extracts the object from the typed reference.
LPVOID __stdcall COMMember::TypedReferenceToObject(_TypedReferenceToObjectArgs* args)
{
    LPVOID          rv;
    OBJECTREF       Obj = NULL;

    THROWSCOMPLUSEXCEPTION();

    if (args->typedReference.type.IsNull())
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Type");
    
    GCPROTECT_BEGIN(Obj) {   
        void* p = args->typedReference.data;
        EEClass* pClass = args->typedReference.type.GetClass();

        if (pClass->IsValueClass()) {
            Obj = pClass->GetMethodTable()->Box(p, FALSE);
        }
        else {
            Obj = ObjectToOBJECTREF(*((Object**)p));
        }

        *((OBJECTREF *)&rv) = Obj;
    }
    GCPROTECT_END();

    return rv;
}

// InvokeCons
//
// This routine will invoke the constructor for a class.  It will verify that
//  the arguments passed are correct
//
LPVOID __stdcall COMMember::InvokeCons(_InvokeConsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    MethodDesc*     pMeth;
    UINT            argCnt;
    EEClass*        eeClass;
    INT64           ret = 0;
    LPVOID          rv;
    OBJECTREF       o = 0;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);
    eeClass = pMeth->GetClass();
    _ASSERTE(eeClass);

    if (pMeth->IsStatic()) {
        COMPlusThrow(kMemberAccessException,L"Acc_NotClassInit");
    }

    // if this is an abstract class then we will
    //  fail this
    if (eeClass->IsAbstract()) 
    {
        if (eeClass->IsInterface())
            COMPlusThrow(kMemberAccessException,L"Acc_CreateInterface");
        else
            COMPlusThrow(kMemberAccessException,L"Acc_CreateAbst");
    }

    if (eeClass->ContainsStackPtr()) 
        COMPlusThrow(kNotSupportedException, L"NotSupported_ContainsStackPtr");

    if (!pRM->pSignature) {
        PCCOR_SIGNATURE pSignature;     // The signature of the found method
        DWORD       cSignature;
        pRM->pMethod->GetSig(&pSignature,&cSignature);
        pRM->pSignature = ExpandSig::GetReflectSig(pSignature,
                                                   pRM->pMethod->GetModule());
    }
    ExpandSig* mSig = pRM->pSignature;

    if (mSig->IsVarArg()) 
        COMPlusThrow(kNotSupportedException, IDS_EE_VARARG_NOT_SUPPORTED);

    // Get the number of args on this element
    //  For a constructor there is always one arg which is the this pointer
    argCnt = (int) mSig->NumFixedArgs();

    ////////////////////////////////////////////////////////////
    // Validate the call
    // - Verify the number of args

    // Verify that we have been provided the proper number of
    //  args
    if (!args->objs) {
        if (argCnt > 0) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }
    else {
        if (args->objs->GetNumComponents() != argCnt) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }

    // Make sure we're not invoking on a save-only dynamic assembly
    // Check reflected class
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    if (pRC)
    {
        Assembly *pAssem = pRC->GetClass()->GetAssembly();
        if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
        {
            COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");
        }
    }

    // Check declaring class
    Assembly *pAssem = eeClass->GetAssembly();
    if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
    {
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");
    }

    // this security context will be used in cast checking as well
    RefSecContext sCtx;

    // Validate the method can be called by this caller
    DWORD attr = pMeth->GetAttrs();
    if (!IsMdPublic(attr) || pMeth->RequiresLinktimeCheck() || !eeClass->IsExternallyVisible())
        CanAccess(pMeth, &sCtx);

    // Validate access to non-public types in the signature.
    void* pEnum;
    mSig->Reset(&pEnum);
    for (int i=0;i< (int) argCnt;i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);

        // Check the caller has access to the arg type.
        EEClass *pArgClass = GetUnderlyingClass(&th);
        if (pArgClass && !pArgClass->IsExternallyVisible())
            InvokeUtil::CheckAccessType(&sCtx, pArgClass, REFSEC_THROW_MEMBERACCESS);
    }

    /// Validation is done
    /////////////////////////////////////////////////////////////////////

    // Build the Args...This is in [0]
    //  All of the rest of the args are placed in reverse order
    //  into the arg array.

    // Make sure we call the <cinit>
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    if (!eeClass->DoRunClassInit(&Throwable)) {

        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&Throwable);
        COMPlusThrow(except);
    }
    GCPROTECT_END();

    // If we are invoking a constructor on an array then we must
    //  handle this specially.  String objects allocate themselves
    //  so they are a special case.
    if (eeClass != g_pStringClass->GetClass()) {
        if (eeClass->IsArrayClass()) {
            return InvokeArrayCons((ReflectArrayClass*) args->refThis->GetReflClass(),
                pMeth,&args->objs,argCnt);
        }
        else if (CRemotingServices::IsRemoteActivationRequired(eeClass))
        {
            o = CRemotingServices::CreateProxyOrObject(eeClass->GetMethodTable());
        }
        else
        {
            o = AllocateObject(eeClass->GetMethodTable());
        }
    }
    else 
        o = 0;

    GCPROTECT_BEGIN(o);

    // Make sure we allocated the callArgs.  We must have
    //  at least one because of the this pointer
    BYTE *  pNewArgs = 0;
    UINT    nStackBytes = mSig->SizeOfVirtualFixedArgStack(pMeth->IsStatic());
    pNewArgs = (BYTE *) _alloca(nStackBytes);
    BYTE *  pDst= pNewArgs;

    mSig->Reset(&pEnum);

    pDst += nStackBytes;

    for (int i = 0; i < (int)argCnt; i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);
        // This routine will verify that all types are correct.
        g_pInvokeUtil->CheckArg(th, &(args->objs->m_Array[i]), &sCtx);
    }
    
#ifdef STRESS_HEAP
    if (g_pConfig->GetGCStressLevel() != 0)
        g_pGCHeap->StressHeap();
#endif
    
    // NO GC AFTER THIS POINT
    // actually this statement is not completely accurate. If an exception occurs a gc may happen
    // but we are going to dump the stack anyway and we do not need to protect anything.
    // But if anywhere between here and the method invocation we enter preemptive mode the stack
    // we are about to setup (pDst in the loop) may contain references to random parts of memory

    // copy args
    mSig->Reset(&pEnum);
    for (int i = 0; i < (int)argCnt; i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);

        UINT cbSize = mSig->GetStackElemSize(th);
        pDst -= cbSize;

        g_pInvokeUtil->CopyArg(th, &(args->objs->m_Array[i]), pDst);
    }
    // Copy "this" pointer
    if (eeClass->IsValueClass()) 
        *(void**) pNewArgs = o->UnBox();
    else
        *(OBJECTREF *) pNewArgs = o;

    // Call the method
    // Constructors always return null....
    COMPLUS_TRY {
        MetaSig threadSafeSig(*mSig);
        ret = pMeth->Call(pNewArgs,&threadSafeSig);
    } COMPLUS_CATCH {
        // If we get here we need to throw an TargetInvocationException
        OBJECTREF ppException = GETTHROWABLE();
        _ASSERTE(ppException);
        GCPROTECT_BEGIN(ppException);
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
        COMPlusThrow(except);
        GCPROTECT_END();
    } COMPLUS_END_CATCH
    // We have a special case for Strings...The object
    //  is returned...
    if (eeClass == g_pStringClass->GetClass()) {
        o = Int64ToObj(ret);
    }

    *((OBJECTREF *)&rv) = o;
    GCPROTECT_END();        // object o
    return rv;
}


// SerializationInvoke
void COMMember::SerializationInvoke(_SerializationInvokeArgs *args) {

    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    MethodDesc*     pMeth;
    EEClass*        eeClass;
    INT64           ret;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);
    eeClass = pMeth->GetClass();
    _ASSERTE(eeClass);

    if (!pRM->pSignature) {
        PCCOR_SIGNATURE pSignature;     // The signature of the found method
        DWORD       cSignature;
        pRM->pMethod->GetSig(&pSignature,&cSignature);
        pRM->pSignature = ExpandSig::GetReflectSig(pSignature,
                                                   pRM->pMethod->GetModule());
    }
    ExpandSig* mSig = pRM->pSignature;

    // Build the Args...This is in [0]
    //  All of the rest of the args are placed in reverse order
    //  into the arg array.

    // Make sure we call the <cinit>
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    if (!eeClass->DoRunClassInit(&Throwable)) {
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&Throwable);
        COMPlusThrow(except);
    }
    GCPROTECT_END();

    _ASSERTE(!(eeClass->IsArrayClass()));
    _ASSERTE(eeClass!=g_pStringClass->GetClass());

    struct NewArgs {
        OBJECTREF   thisPointer;
        OBJECTREF   additionalContext;
        INT32       contextStates;
        OBJECTREF   serializationInfo;
    } newArgs;

    // make sure method has correct size sig
    _ASSERTE(mSig->SizeOfVirtualFixedArgStack(false/*IsStatic*/) == sizeof(newArgs));

    // NO GC AFTER THIS POINT

    // Copy "this" pointer
    if (eeClass->IsValueClass()) 
        *(void**)&(newArgs.thisPointer) = args->target->UnBox();
    else
        newArgs.thisPointer = args->target;
    
    //
    // Copy the arguments in reverse order, context and then the SerializationInfo.
    //
    newArgs.additionalContext = args->context.additionalContext;
    newArgs.contextStates = args->context.contextStates;
    newArgs.serializationInfo = args->serializationInfo;

    // Call the method
    // Constructors always return null....
    COMPLUS_TRY {
        MetaSig threadSafeSig(*mSig);
        ret = pMeth->Call((BYTE*)&newArgs,&threadSafeSig);
    } COMPLUS_CATCH {
        // If we get here we need to throw an TargetInvocationException
        OBJECTREF ppException = GETTHROWABLE();
        _ASSERTE(ppException);
        GCPROTECT_BEGIN(ppException);
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
        COMPlusThrow(except);
        GCPROTECT_END();
    } COMPLUS_END_CATCH
}


// InvokeArrayCons
// This method will return a new Array Object from the constructor.

LPVOID COMMember::InvokeArrayCons(ReflectArrayClass* pRC,
                MethodDesc* pMeth,PTRARRAYREF* objs,int argCnt)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv = 0;
    DWORD i;

    ArrayTypeDesc* arrayDesc = pRC->GetTypeHandle().AsArray();

    // If we're trying to create an array of pointers or function pointers,
    // check that the caller has skip verification permission.
    CorElementType et = arrayDesc->GetElementTypeHandle().GetNormCorElementType();
    if (et == ELEMENT_TYPE_PTR || et == ELEMENT_TYPE_FNPTR)
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);

    // Validate the argCnt an the Rank. Also allow nested SZARRAY's.
    _ASSERTE(argCnt == (int) arrayDesc->GetRank() || argCnt == (int) arrayDesc->GetRank() * 2 ||
             arrayDesc->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY);

    // Validate all of the parameters.  These all typed as integers
    int* indexes = (int*) _alloca(sizeof(int) * argCnt);
    ZeroMemory(indexes,sizeof(int) * argCnt);
    for (i=0;i<(DWORD)argCnt;i++) {
        if (!(*objs)->m_Array[i])
            COMPlusThrowArgumentException(L"parameters", L"Arg_NullIndex");
        MethodTable* pMT = ((*objs)->m_Array[i])->GetMethodTable();
        CorElementType oType = pMT->GetNormCorElementType();
        if (!InvokeUtil::IsPrimitiveType(oType) || !InvokeUtil::CanPrimitiveWiden(ELEMENT_TYPE_I4,oType))
            COMPlusThrow(kArgumentException,L"Arg_PrimWiden");
        memcpy(&indexes[i],(*objs)->m_Array[i]->UnBox(),pMT->GetClass()->GetNumInstanceFieldBytes());
    }

    // We are allocating some type of general array
    DWORD rank = arrayDesc->GetRank();
    DWORD boundsSize;
    DWORD* bounds;
    if (arrayDesc->GetNormCorElementType() == ELEMENT_TYPE_ARRAY) {
        boundsSize = rank*2;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));

        if (argCnt == (int) rank) {
            int j;
            for (i=0,j=0;i<(int)rank;i++,j+=2) {
                bounds[j] = 0;
                DWORD d = indexes[i];
                bounds[j+1] = d;
            }
        }
        else {
            for (i=0;i<(DWORD)argCnt;) {
                DWORD d = indexes[i];
                bounds[i++] = d;
                d = indexes[i];
                bounds[i] = d + bounds[i-1];
                i++;
            }
        }
    }
    else {
        _ASSERTE(arrayDesc->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY);
        boundsSize = argCnt;
        bounds = (DWORD*) _alloca(boundsSize * sizeof(DWORD));
        for (i = 0; i < (DWORD)argCnt; i++) {
            bounds[i] = indexes[i];
        }
    }

    PTRARRAYREF pRet = (PTRARRAYREF) AllocateArrayEx(TypeHandle(arrayDesc), bounds, boundsSize);
    *((PTRARRAYREF *)&rv) = pRet;
    return rv;
}

// CreateInstance
// This routine will create an instance of a Class by invoking the null constructor
//  if a null constructor is present.  
// Return LPVOID  (System.Object.)
// Args: _CreateInstanceArgs
// 
LPVOID __stdcall COMMember::CreateInstance(_CreateInstanceArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    EEClass* pVMC;
    MethodDesc* pMeth;
    LPVOID rv;

    // Get the EEClass and Vtable associated with args->refThis
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetData();
    pVMC = pRC->GetClass();
    if (pVMC == 0)
        COMPlusThrow(kMissingMethodException,L"Arg_NoDefCTor");

    Assembly *pAssem = pRC->GetClass()->GetAssembly();
    if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");

    // If this is __ComObject then create the underlying COM object.
    if (args->refThis->IsComObjectClass())
    {
        if (pRC->GetCOMObject())
        {
            // Check for the required permissions (SecurityPermission.UnmanagedCode),
            // since arbitrary unmanaged code in the class factory will execute below).
            COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);

            // create an instance of the Com Object
            *((OBJECTREF *)&rv) = ComClassFactory::CreateInstance(pRC->GetCOMObject(), pVMC);
            return rv;
        }
        else // The __ComObject is invalid.
            COMPlusThrow(kInvalidComObjectException, IDS_EE_NO_BACKING_CLASS_FACTORY);
    }

    // If we are creating a COM object which has backing metadata we still
    // need to ensure that the caller has unmanaged code access permission.
    if (pVMC->GetMethodTable()->IsComObjectType())
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);

    // if this is an abstract class then we will fail this
    if (pVMC->IsAbstract()) 
    {
        if (pVMC->IsInterface())
            COMPlusThrow(kMemberAccessException,L"Acc_CreateInterface");
        else
            COMPlusThrow(kMemberAccessException,L"Acc_CreateAbst");
    }

    if (pVMC->ContainsStackPtr()) 
        COMPlusThrow(kNotSupportedException, L"NotSupported_ContainsStackPtr");

    if (!pVMC->GetMethodTable()->HasDefaultConstructor()) {
    // We didn't find the parameterless constructor,
    //  if this is a Value class we can simply allocate one and return it

        if (pVMC->IsValueClass()) {
            OBJECTREF o = pVMC->GetMethodTable()->Allocate();
            *((OBJECTREF *)&rv) = o;
            return rv;
        }
        COMPlusThrow(kMissingMethodException,L"Arg_NoDefCTor");
    }

    pMeth = pVMC->GetMethodTable()->GetDefaultConstructor();

    MetaSig sig(pMeth->GetSig(),pMeth->GetModule());

    // Validate the method can be called by this caller
    DWORD attr = pMeth->GetAttrs();

    if (!IsMdPublic(attr) && args->publicOnly)
        COMPlusThrow(kMissingMethodException,L"Arg_NoDefCTor");

    // this security context will be used in cast checking as well
    RefSecContext sCtx;

    if (!IsMdPublic(attr) || pMeth->RequiresLinktimeCheck() || !pVMC->IsExternallyVisible()) 
        CanAccess(pMeth, &sCtx);

    // call the <cinit> 
    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    if (!pVMC->DoRunClassInit(&Throwable)) {
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&Throwable);
        COMPlusThrow(except);
    }
    GCPROTECT_END();

    // We've got the class, lets allocate it and call the constructor
    if (pVMC->IsThunking())
        COMPlusThrow(kMissingMethodException,L"NotSupported_Constructor");
    OBJECTREF o;
         
    if (CRemotingServices::IsRemoteActivationRequired(pVMC))
        o = CRemotingServices::CreateProxyOrObject(pVMC->GetMethodTable());
    else
        o = AllocateObject(pVMC->GetMethodTable());

    GCPROTECT_BEGIN(o)
    {
    // Copy "this" pointer
    UINT    nStackBytes = sig.SizeOfVirtualFixedArgStack(0);
    BYTE*   pNewArgs = (BYTE *) _alloca(nStackBytes);
    BYTE*   pDst= pNewArgs;
    if (pVMC->IsValueClass()) 
        *(void**) pDst = o->UnBox();
    else
        *(OBJECTREF *) pDst = o;

    // Call the method
        COMPLUS_TRY {
            pMeth->Call(pNewArgs, &sig);
        } COMPLUS_CATCH {
            // If we get here we need to throw an TargetInvocationException
            OBJECTREF ppException = GETTHROWABLE();
            _ASSERTE(ppException);
            GCPROTECT_BEGIN(ppException);
            OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
            COMPlusThrow(except);
            GCPROTECT_END();
        } COMPLUS_END_CATCH

    *((OBJECTREF *)&rv) = o;
    }
    GCPROTECT_END();

    return rv;
}

// Init the ReflectField cached info, if not done already
VOID COMMember::InitReflectField(FieldDesc *pField, ReflectField *pRF)
{
    if (pRF->type == ELEMENT_TYPE_END)
    {
        CorElementType t;
        // Get the type of the field
        pRF->thField = g_pInvokeUtil->GetFieldTypeHandle(pField, &t);
        // Field attributes
        pRF->dwAttr = pField->GetAttributes();
        //Do this last to prevent race conditions
        pRF->type = t;
    }
}

// FieldGet
// This method will get the value associated with an object
LPVOID __stdcall COMMember::FieldGet(_FieldGetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    FieldDesc*  pField;
    EEClass*    eeClass;
    LPVOID      rv = 0;

    // Get the field and EEClass from the Object
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    pField = pRF->pField;
    _ASSERTE(pField);
    eeClass = pField->GetEnclosingClass();
    _ASSERTE(eeClass);

    Assembly *pAssem = eeClass->GetAssembly();
    if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");

    // Validate the call
    g_pInvokeUtil->ValidateObjectTarget(pField, eeClass, &args->target);

    // See if cached field information is available
    InitReflectField(pField, pRF);

    // Verify the callee/caller access
    if (args->requiresAccessCheck) {
        RefSecContext sCtx;
        if (args->target != NULL && !pField->IsStatic()) {
            if (!args->target->GetTypeHandle().IsTypeDesc()) {
                sCtx.SetClassOfInstance(args->target->GetClass());
            }
        }
        CanAccessField(pRF, &sCtx);
    }

    // There can be no GC after thing until the Object is returned.
    INT64 value;
    value = g_pInvokeUtil->GetFieldValue(pRF->type,pRF->thField,pField,&args->target);
    if (pRF->type == ELEMENT_TYPE_VALUETYPE ||
        pRF->type == ELEMENT_TYPE_PTR) {
        OBJECTREF obj = Int64ToObj(value);
        *((OBJECTREF *)&rv) = obj;
    }
    else {
        OBJECTREF obj = g_pInvokeUtil->CreateObject(pRF->thField,value);
        *((OBJECTREF *)&rv) = obj;
    }
    return rv;
}

LPVOID __stdcall COMMember::DirectFieldGet(_DirectFieldGetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID rv = 0;

    // Get the field and EEClass from the Object
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    FieldDesc* pField = pRF->pField;
    _ASSERTE(pField);

    // Find the Object and its type
    EEClass* targetEEC = args->target.type.GetClass();
    if (pField->IsStatic() || !targetEEC->IsValueClass()) {
        return DirectObjectFieldGet(pField,args);
    }

    // See if cached field information is available
    InitReflectField(pField, pRF);

    EEClass* fldEEC = pField->GetEnclosingClass();
    _ASSERTE(fldEEC);

    // Validate that the target type can be cast to the type that owns this field info.
    if (!TypeHandle(targetEEC).CanCastTo(TypeHandle(fldEEC)))
        COMPlusThrowArgumentException(L"obj", NULL);

    // Verify the callee/caller access
    if (args->requiresAccessCheck) {
        RefSecContext sCtx;
        sCtx.SetClassOfInstance(targetEEC);
        CanAccessField(pRF, &sCtx);
    }

    INT64 value = -1;

    // This is a hack because from the previous case we may end up with an
    //  Enum.  We want to process it here.
    // Get the value from the field
    void* p;
    switch (pRF->type) {
    case ELEMENT_TYPE_VOID:
        _ASSERTE(!"Void used as Field Type!");
        COMPlusThrow(kInvalidProgramException);

    case ELEMENT_TYPE_BOOLEAN:  // boolean
    case ELEMENT_TYPE_I1:       // byte
    case ELEMENT_TYPE_U1:       // unsigned byte
        p = ((BYTE*) args->target.data) + pField->GetOffset();
        *(UINT8*) &value = *(UINT8*) p;
        break;

    case ELEMENT_TYPE_I2:       // short
    case ELEMENT_TYPE_U2:       // unsigned short
    case ELEMENT_TYPE_CHAR:     // char
        p = ((BYTE*) args->target.data) + pField->GetOffset();
        *(UINT16*) &value = *(UINT16*) p;
        break;

    case ELEMENT_TYPE_I4:       // int
    case ELEMENT_TYPE_U4:       // unsigned int
    IN_WIN32(case ELEMENT_TYPE_I:)
    IN_WIN32(case ELEMENT_TYPE_U:)
    case ELEMENT_TYPE_R4:       // float
        p = ((BYTE*) args->target.data) + pField->GetOffset();
        *(UINT32*) &value = *(UINT32*) p;
        break;

    IN_WIN64(case ELEMENT_TYPE_I:)
    IN_WIN64(case ELEMENT_TYPE_U:)
    case ELEMENT_TYPE_I8:       // long
    case ELEMENT_TYPE_U8:       // unsigned long
    case ELEMENT_TYPE_R8:       // double
        p = ((BYTE*) args->target.data) + pField->GetOffset();
        value = *(INT64*) p;
        break;

    //@TODO: This is a separate case because I suspect this is the
    //  wrong thing todo.  There should be a GetValueOR because the pointer
    //  size may change (32-64)
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_SZARRAY:          // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:            // general array
        {
            p = ((BYTE*) args->target.data) + pField->GetOffset();
            OBJECTREF or = ObjectToOBJECTREF(*(Object**) p);
            *((OBJECTREF *)&rv) = or;
            return rv;
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
        {
            // Allocate an object to return...
            _ASSERTE(pRF->thField.IsUnsharedMT());
            OBJECTREF obj = AllocateObject(pRF->thField.AsMethodTable());

            // copy the field to the unboxed object.
            p = ((BYTE*) args->target.data) + pField->GetOffset();
            CopyValueClass(obj->UnBox(), p, pRF->thField.AsMethodTable(), obj->GetAppDomain());
            *((OBJECTREF *)&rv) = obj;
            return rv;
        }
        break;

    // This is not 64 bit complient....
    case ELEMENT_TYPE_PTR:
        {
            p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(UINT32*) &value = *(UINT32*) p;

            g_pInvokeUtil->InitPointers();
            OBJECTREF obj = AllocateObject(g_pInvokeUtil->_ptr.AsMethodTable());
            GCPROTECT_BEGIN(obj);
            // Ignore null return
            OBJECTREF typeOR = pRF->thField.CreateClassObj();
            g_pInvokeUtil->_ptrType->SetRefValue(obj,typeOR);
            g_pInvokeUtil->_ptrValue->SetValue32(obj,(int) value);
            *((OBJECTREF *)&rv) = obj;
            GCPROTECT_END();
            return rv;
        }
        break;

    default:
        _ASSERTE(!"Unknown Type");
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }

    OBJECTREF obj = g_pInvokeUtil->CreateObject(pRF->thField,value);
    *((OBJECTREF *)&rv) = obj;
    return rv;
}


// FieldSet
// This method will set the field of an associated object
void __stdcall COMMember::FieldSet(_FieldSetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    TypeHandle  th;
    HRESULT     hr;

    // Get the field and EEClass from the Object
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    FieldDesc*  pField = pRF->pField;
    _ASSERTE(pField);
    EEClass* eeClass = pField->GetEnclosingClass();
    _ASSERTE(eeClass);

    Assembly *pAssem = eeClass->GetAssembly();
    if (pAssem->IsDynamic() && !pAssem->HasRunAccess())
        COMPlusThrow(kNotSupportedException, L"NotSupported_DynamicAssemblyNoRunAccess");

    // Validate the target/fld type relationship
    g_pInvokeUtil->ValidateObjectTarget(pField,eeClass,&args->target);

    // See if cached field information is available
    InitReflectField(pField, pRF);

    RefSecContext sCtx;

    // Verify that the value passed can be widened into the target
    hr = g_pInvokeUtil->ValidField(pRF->thField, &args->value, &sCtx);
    if (FAILED(hr)) {
        // Call change type so we can attempt this again...
        if (!(args->attrs & BINDER_ExactBinding) && args->binder != NULL && !args->isBinderDefault) {

            args->value = g_pInvokeUtil->ChangeType(args->binder,args->value,pRF->thField,args->locale);

            // See if the results are now legal...
            hr = g_pInvokeUtil->ValidField(pRF->thField,&args->value, &sCtx);
            if (FAILED(hr)) {
                if (hr == E_INVALIDARG) {
                    COMPlusThrow(kArgumentException,L"Arg_ObjObj");
                }
                // this is really an impossible condition
                COMPlusThrow(kNotSupportedException);
            }

        }
        else {
            // Not a value field for the passed argument.
            if (hr == E_INVALIDARG) {
                COMPlusThrow(kArgumentException,L"Arg_ObjObj");
            }
            // this is really an impossible condition
            COMPlusThrow(kNotSupportedException);
        }
    }   
    
    // Verify that this is not a Final Field
    if (args->requiresAccessCheck) {
        if (IsFdInitOnly(pRF->dwAttr)) {
            COMPLUS_TRY {
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SERIALIZATION);
            } COMPLUS_CATCH {
                COMPlusThrow(kFieldAccessException, L"Acc_ReadOnly");
            } COMPLUS_END_CATCH
        }
        if (IsFdHasFieldRVA(pRF->dwAttr)) {
            COMPLUS_TRY {
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);
            } COMPLUS_CATCH {
                COMPlusThrow(kFieldAccessException, L"Acc_RvaStatic");
            } COMPLUS_END_CATCH
        }
        if (IsFdLiteral(pRF->dwAttr)) 
            COMPlusThrow(kFieldAccessException,L"Acc_ReadOnly");
    }

    // Verify the callee/caller access
    if (args->requiresAccessCheck) {
        if (args->target != NULL && !pField->IsStatic()) {
            if (!args->target->GetTypeHandle().IsTypeDesc()) {
                sCtx.SetClassOfInstance(args->target->GetClass());
            }
        }
        CanAccessField(pRF, &sCtx);
    }

    g_pInvokeUtil->SetValidField(pRF->type,pRF->thField,pField,&args->target,&args->value);
}

// DirectFieldSet
// This method will set the field (defined by the this) on the object
//  which was passed by a TypedReference.
void __stdcall COMMember::DirectFieldSet(_DirectFieldSetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Get the field and EEClass from the Object
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    FieldDesc* pField = pRF->pField;
    _ASSERTE(pField);

    // Find the Object and its type
    EEClass* targetEEC = args->target.type.GetClass();
    if (pField->IsStatic() || !targetEEC->IsValueClass()) {
        DirectObjectFieldSet(pField,args);
        return ;
    }

    EEClass* fldEEC = pField->GetEnclosingClass();
    _ASSERTE(fldEEC);

    // Validate that the target type can be cast to the type that owns this field info.
    if (!TypeHandle(targetEEC).CanCastTo(TypeHandle(fldEEC)))
        COMPlusThrowArgumentException(L"obj", NULL);

    // We dont verify that the user has access because
    //  we assume that access is granted because its 
    //  a TypeReference.

    // See if cached field information is available
    InitReflectField(pField, pRF);

    RefSecContext sCtx;

    // Verify that the value passed can be widened into the target
    HRESULT hr = g_pInvokeUtil->ValidField(pRF->thField,&args->value, &sCtx);
    // Not a value field for the passed argument.
    if (FAILED(hr)) {
        if (hr == E_INVALIDARG) {
            COMPlusThrow(kArgumentException,L"Arg_ObjObj");
        }
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }

    // Verify that this is not a Final Field
    if (args->requiresAccessCheck) {
        if (IsFdInitOnly(pRF->dwAttr)) {
            COMPLUS_TRY {
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SERIALIZATION);
            } COMPLUS_CATCH {
                COMPlusThrow(kFieldAccessException, L"Acc_ReadOnly");
            } COMPLUS_END_CATCH
        }
        if (IsFdHasFieldRVA(pRF->dwAttr)) {
            COMPLUS_TRY {
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);
            } COMPLUS_CATCH {
                COMPlusThrow(kFieldAccessException, L"Acc_RvaStatic"); 
            } COMPLUS_END_CATCH
        }
        if (IsFdLiteral(pRF->dwAttr)) 
            COMPlusThrow(kFieldAccessException,L"Acc_ReadOnly");
    }
    
    // Verify the callee/caller access
    if (args->requiresAccessCheck) {
        sCtx.SetClassOfInstance(targetEEC);
        CanAccessField(pRF, &sCtx);
    }

    // Set the field
    INT64 value;
    switch (pRF->type) {
    case ELEMENT_TYPE_VOID:
        _ASSERTE(!"Void used as Field Type!");
        COMPlusThrow(kInvalidProgramException);

    case ELEMENT_TYPE_BOOLEAN:  // boolean
    case ELEMENT_TYPE_I1:       // byte
    case ELEMENT_TYPE_U1:       // unsigned byte
        {
            value = 0;
            if (args->value != 0) {
                MethodTable* p = args->value->GetMethodTable();
                CorElementType oType = p->GetNormCorElementType();
                g_pInvokeUtil->CreatePrimitiveValue(pRF->type,oType,args->value,&value);
            }

            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(UINT8*) p = *(UINT8*) &value;
        }
        break;

    case ELEMENT_TYPE_I2:       // short
    case ELEMENT_TYPE_U2:       // unsigned short
    case ELEMENT_TYPE_CHAR:     // char
        {
            value = 0;
            if (args->value != 0) {
                MethodTable* p = args->value->GetMethodTable();
                CorElementType oType = p->GetNormCorElementType();
                g_pInvokeUtil->CreatePrimitiveValue(pRF->type,oType,args->value,&value);
            }

            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(UINT16*) p = *(UINT16*) &value;
        }
        break;

    case ELEMENT_TYPE_PTR:      // pointers
        _ASSERTE(!g_pInvokeUtil->_ptr.IsNull());
        if (args->value != 0) {
            value = 0;
            if (args->value->GetTypeHandle() == g_pInvokeUtil->_ptr) {
                value = (size_t) g_pInvokeUtil->GetPointerValue(&args->value);
                void* p = ((BYTE*) args->target.data) + pField->GetOffset();
                *(size_t*) p = (size_t) value;
                break;
            }
        }
        // drop through
    case ELEMENT_TYPE_FNPTR:
        {
            value = 0;
            if (args->value != 0) {
                MethodTable* p = args->value->GetMethodTable();
                CorElementType oType = p->GetNormCorElementType();
                g_pInvokeUtil->CreatePrimitiveValue(oType, oType, args->value, &value);
            }
            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(size_t*) p = (size_t) value;
        }
        break;

    case ELEMENT_TYPE_I4:       // int
    case ELEMENT_TYPE_U4:       // unsigned int
    case ELEMENT_TYPE_R4:       // float
    IN_WIN32(case ELEMENT_TYPE_I:)
    IN_WIN32(case ELEMENT_TYPE_U:)
        {
            value = 0;
            if (args->value != 0) {
                MethodTable* p = args->value->GetMethodTable();
                CorElementType oType = p->GetNormCorElementType();
                g_pInvokeUtil->CreatePrimitiveValue(pRF->type,oType,args->value,&value);
            }
            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(UINT32*) p = *(UINT32*) &value;
        }
        break;

    case ELEMENT_TYPE_I8:       // long
    case ELEMENT_TYPE_U8:       // unsigned long
    case ELEMENT_TYPE_R8:       // double
    IN_WIN64(case ELEMENT_TYPE_I:)
    IN_WIN64(case ELEMENT_TYPE_U:)
        {
            value = 0;
            if (args->value != 0) {
                MethodTable* p = args->value->GetMethodTable();
                CorElementType oType = p->GetNormCorElementType();
                g_pInvokeUtil->CreatePrimitiveValue(pRF->type,oType,args->value,&value);
            }

            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            *(INT64*) p = *(INT64*) &value;
        }
        break;

    case ELEMENT_TYPE_SZARRAY:          // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:            // General Array
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
        {
            void* p = ((BYTE*) args->target.data) + pField->GetOffset();
            SetObjectReferenceUnchecked((OBJECTREF*) p, args->value);
        }
        break;

    case ELEMENT_TYPE_VALUETYPE:
        {
            _ASSERTE(pRF->thField.IsUnsharedMT());
            MethodTable* pMT = pRF->thField.AsMethodTable();
            EEClass* pEEC = pMT->GetClass();
            void* p = ((BYTE*) args->target.data) + pField->GetOffset();

            // If we have a null value then we must create an empty field
            if (args->value == 0) {
                InitValueClass(p, pEEC->GetMethodTable());
                return;
            }
            // Value classes require createing a boxed version of the field and then
            //  copying from the source...
           CopyValueClassUnchecked(p, args->value->UnBox(), pEEC->GetMethodTable());
        }
        break;

    default:
        _ASSERTE(!"Unknown Type");
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }
}

// DirectObjectFieldGet
// When the TypedReference points to a object we call this method to
//  get the field value
LPVOID COMMember::DirectObjectFieldGet(FieldDesc* pField,_DirectFieldGetArgs* args)
{
    LPVOID rv;
    EEClass* eeClass = pField->GetEnclosingClass();
    _ASSERTE(eeClass);

    OBJECTREF or = NULL;
    GCPROTECT_BEGIN(or);
    if (!pField->IsStatic()) {
        or = ObjectToOBJECTREF(*((Object**)args->target.data));
    }

    // Validate the call
    g_pInvokeUtil->ValidateObjectTarget(pField,eeClass,&or);

    // Get the type of the field
    CorElementType type;
    TypeHandle th = g_pInvokeUtil->GetFieldTypeHandle(pField,&type);

    // There can be no GC after thing until the Object is returned.
    INT64 value;
    value = g_pInvokeUtil->GetFieldValue(type,th,pField,&or);
    if (type == ELEMENT_TYPE_VALUETYPE) {
        OBJECTREF obj = Int64ToObj(value);
        *((OBJECTREF *)&rv) = obj;
    }
    else {
        OBJECTREF obj = g_pInvokeUtil->CreateObject(th,value);
        *((OBJECTREF *)&rv) = obj;
    }
    GCPROTECT_END();
    return rv;
}

// DirectObjectFieldSet
// When the TypedReference points to a object we call this method to
//  set the field value
void COMMember::DirectObjectFieldSet(FieldDesc* pField,_DirectFieldSetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    EEClass* eeClass = pField->GetEnclosingClass();
    _ASSERTE(eeClass);

    OBJECTREF or = NULL;
    GCPROTECT_BEGIN(or);
    if (!pField->IsStatic()) {
        or = ObjectToOBJECTREF(*((Object**)args->target.data));
    }
    // Validate the target/fld type relationship
    g_pInvokeUtil->ValidateObjectTarget(pField,eeClass,&or);

    // Verify that the value passed can be widened into the target
    CorElementType type;
    TypeHandle th = g_pInvokeUtil->GetFieldTypeHandle(pField,&type);

    RefSecContext sCtx;

    HRESULT hr = g_pInvokeUtil->ValidField(th, &args->value, &sCtx);
    if (FAILED(hr)) {
        if (hr == E_INVALIDARG) {
            COMPlusThrow(kArgumentException,L"Arg_ObjObj");
        }
        // this is really an impossible condition
        COMPlusThrow(kNotSupportedException);
    }

    // Verify that this is not a Final Field
    DWORD attr = pField->GetAttributes();
    if (IsFdInitOnly(attr) || IsFdLiteral(attr)) {
        COMPlusThrow(kFieldAccessException,L"Acc_ReadOnly");
    }

    if (IsFdHasFieldRVA(attr)) {
        COMPLUS_TRY {
            COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_SKIP_VER);
        } COMPLUS_CATCH {
            COMPlusThrow(kFieldAccessException, L"Acc_ReadOnly");       // @TODO make a real error message
        } COMPLUS_END_CATCH
    }

    // Verify the callee/caller access
    if (!pField->IsPublic() && args->requiresAccessCheck) {
        if (or != NULL) 
            if (!or->GetTypeHandle().IsTypeDesc())
                sCtx.SetClassOfInstance(or->GetClass());
        
        InvokeUtil::CheckAccess(&sCtx,
                                pField->GetAttributes(),
                                pField->GetMethodTableOfEnclosingClass(),
                                REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_FIELDACCESS);
    }
    else if (!eeClass->IsExternallyVisible()) {
        if (or != NULL) 
            if (!or->GetTypeHandle().IsTypeDesc())
                sCtx.SetClassOfInstance(or->GetClass());
        
        InvokeUtil::CheckAccess(&sCtx,
                                pField->GetAttributes(),
                                pField->GetMethodTableOfEnclosingClass(),
                                REFSEC_CHECK_MEMBERACCESS|REFSEC_THROW_FIELDACCESS);
    }

    g_pInvokeUtil->SetValidField(type,th,pField,&or,&args->value);
    GCPROTECT_END();
}

// MakeTypedReference
// This method will take an object, an array of FieldInfo's and create
//  at TypedReference for it (Assuming its valid).  This will throw a
//  MissingMemberException.  Outside of the first object, all the other
//  fields must be ValueTypes.
void __stdcall COMMember::MakeTypedReference(_MakeTypedReferenceArgs* args)
{
    REFLECTBASEREF fld;
    THROWSCOMPLUSEXCEPTION();
    DWORD offset = 0;

    // Verify that the object is of the proper type...
    TypeHandle typeHnd = args->target->GetTypeHandle();
    DWORD cnt = args->flds->GetNumComponents();
    for (DWORD i=0;i<cnt;i++) {
        fld = (REFLECTBASEREF) args->flds->m_Array[i];
        if (fld == 0)
            COMPlusThrowArgumentNull(L"className",L"ArgumentNull_ArrayValue");

        // Get the field for this...
        ReflectField* pRF = (ReflectField*) fld->GetData();
        FieldDesc* pField = pRF->pField;

        // Verify that the enclosing class for the field
        //  and the class are the same.  If not this is an exception
        EEClass* p = pField->GetEnclosingClass();
        if (typeHnd.GetClass() != p)
            COMPlusThrow(kMissingMemberException,L"MissingMemberTypeRef");

        typeHnd = pField->LoadType();
        if (i<cnt-1) {
            if (!typeHnd.GetClass()->IsValueClass())
                COMPlusThrow(kMissingMemberException,L"MissingMemberNestErr");
        }
        offset += pField->GetOffset();
    }

        // Fields already are prohibted from having ArgIterator and RuntimeArgumentHandles
    _ASSERTE(!typeHnd.GetClass()->ContainsStackPtr());

    // Create the ByRef
    args->value->data = ((BYTE *)(args->target->GetAddress() + offset)) + sizeof(Object);
    args->value->type = typeHnd;
}

// Equals
// This method will verify that two methods are equal....
INT32 __stdcall COMMember::Equals(_EqualsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    if (!args->obj)
        return 0;
    if (args->refThis->GetClass() != args->obj->GetClass())
        return 0;
    REFLECTBASEREF rb = (REFLECTBASEREF) args->obj;
    if (args->refThis->GetData() != rb->GetData() ||
        args->refThis->GetReflClass() != rb->GetReflClass())
        return 0;
    return 1;
}

/*
// Equals
// This method will verify that two methods are equal....
INT32 __stdcall COMMember::TokenEquals(_TokenEqualsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    if (!args->obj)
        return 0;
    if (args->refThis->GetClass() != args->obj->GetClass())
        return 0;

    // Check that the token is the same...
    REFLECTTOKENBASEREF rb = (REFLECTTOKENBASEREF) args->obj;
    if (args->refThis->GetToken() != rb->GetToken())
        return 0;
    return 1;
}
*/

// PropertyEquals
// Return true if the properties are the same...
INT32 __stdcall COMMember::PropertyEquals(_PropertyEqualsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    if (!args->obj)
        return 0;
    if (args->refThis->GetClass() != args->obj->GetClass())
        return 0;

    REFLECTTOKENBASEREF obj = (REFLECTTOKENBASEREF) args->obj;
    if (args->refThis->GetData() != obj->GetData())
        return 0;
    return 1;
}

// GetAddMethod
// This will return the Add method for an Event
LPVOID __stdcall COMMember::GetAddMethod(_GetAddMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectEvent* pEvent = (ReflectEvent*) args->refThis->GetData();
    if (!pEvent->pAdd) 
        return 0;
    if (!args->bNonPublic && !pEvent->pAdd->IsPublic())
        return 0;

    RefSecContext sCtx;

    if (!pEvent->pAdd->IsPublic())
        InvokeUtil::CheckAccess(&sCtx,
                                pEvent->pAdd->attrs,
                                pEvent->pAdd->pMethod->GetMethodTable(),
                                REFSEC_THROW_SECURITY);

    InvokeUtil::CheckLinktimeDemand(&sCtx, pEvent->pAdd->pMethod, true);

    // Find the method...
    REFLECTBASEREF refMethod = pEvent->pAdd->GetMethodInfo(pRC);
    *((REFLECTBASEREF*) &rv) = refMethod;
    return rv;
}

// GetRemoveMethod
// This method return the unsync method on an event
LPVOID __stdcall COMMember::GetRemoveMethod(_GetRemoveMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectEvent* pEvent = (ReflectEvent*) args->refThis->GetData();
    if (!pEvent->pRemove) 
        return 0;
    if (!args->bNonPublic && !pEvent->pRemove->IsPublic())
        return 0;

    RefSecContext sCtx;

    if (!pEvent->pRemove->IsPublic())
        InvokeUtil::CheckAccess(&sCtx,
                                pEvent->pRemove->attrs,
                                pEvent->pRemove->pMethod->GetMethodTable(),
                                REFSEC_THROW_SECURITY);

    InvokeUtil::CheckLinktimeDemand(&sCtx, pEvent->pRemove->pMethod, true);

    // Find the method...
    REFLECTBASEREF refMethod = pEvent->pRemove->GetMethodInfo(pRC);
    *((REFLECTBASEREF*) &rv) = refMethod;
    return rv;
}

// GetRemoveMethod
// This method return the unsync method on an event
LPVOID __stdcall COMMember::GetRaiseMethod(_GetRaiseMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectEvent* pEvent = (ReflectEvent*) args->refThis->GetData();
    if (!pEvent->pFire) 
        return 0;
    if (!args->bNonPublic && !pEvent->pFire->IsPublic())
        return 0;

    RefSecContext sCtx;

    if (!pEvent->pFire->IsPublic())
        InvokeUtil::CheckAccess(&sCtx,
                                pEvent->pFire->attrs,
                                pEvent->pFire->pMethod->GetMethodTable(),
                                REFSEC_THROW_SECURITY);

    InvokeUtil::CheckLinktimeDemand(&sCtx, pEvent->pFire->pMethod, true);

    // Find the method...
    REFLECTBASEREF refMethod = pEvent->pFire->GetMethodInfo(pRC);
    *((REFLECTBASEREF*) &rv) = refMethod;
    return rv;
}

// GetGetAccessors
// This method will return an array of the Get Accessors.  If there
//  are no GetAccessors then we will return an empty array
LPVOID __stdcall COMMember::GetAccessors(_GetAccessorsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;

    // There are three accessors

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();

    // check how many others
    int accCnt = 2;
    if (pProp->pOthers) {
        PropertyOtherList *item = pProp->pOthers;
        while (item) {
            accCnt++;
            item = item->pNext;
        }
    }
    ReflectMethod **pgRM = (ReflectMethod**)_alloca(sizeof(ReflectMethod*) * accCnt);
    memset(pgRM, 0, sizeof(ReflectMethod*) * accCnt);

    RefSecContext sCtx;
    MethodTable *pMT = pRC->GetClass()->GetMethodTable();

    accCnt = 0;
    if (args->bNonPublic) {
        if (pProp->pSetter &&
            InvokeUtil::CheckAccess(&sCtx, pProp->pSetter->attrs, pMT, 0) &&
            InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pSetter->pMethod, false))
            pgRM[accCnt++] = pProp->pSetter;
        if (pProp->pGetter &&
            InvokeUtil::CheckAccess(&sCtx, pProp->pGetter->attrs, pMT, 0) &&
            InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pGetter->pMethod, false))
            pgRM[accCnt++] = pProp->pGetter;
        if (pProp->pOthers) {
            PropertyOtherList *item = pProp->pOthers;
            while (item) {
                if (InvokeUtil::CheckAccess(&sCtx, item->pMethod->attrs, pMT, 0) &&
                    InvokeUtil::CheckLinktimeDemand(&sCtx, item->pMethod->pMethod, false))
                    pgRM[accCnt++] = item->pMethod;
                item = item->pNext;
            }
        }
    }
    else {
        if (pProp->pSetter &&
            IsMdPublic(pProp->pSetter->attrs) &&
            InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pSetter->pMethod, false))
            pgRM[accCnt++] = pProp->pSetter;
        if (pProp->pGetter &&
            IsMdPublic(pProp->pGetter->attrs) &&
            InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pGetter->pMethod, false))
            pgRM[accCnt++] = pProp->pGetter;
        if (pProp->pOthers) {
            PropertyOtherList *item = pProp->pOthers;
            while (item) {
                if (IsMdPublic(item->pMethod->attrs) &&
                    InvokeUtil::CheckLinktimeDemand(&sCtx, item->pMethod->pMethod, false)) 
                    pgRM[accCnt++] = item->pMethod;
                item = item->pNext;
            }
        }
    }


    PTRARRAYREF pRet = (PTRARRAYREF) AllocateObjectArray(accCnt, g_pRefUtil->GetTrueType(RC_Method));
    GCPROTECT_BEGIN(pRet);
    for (int i=0;i<accCnt;i++) {
        REFLECTBASEREF refMethod = pgRM[i]->GetMethodInfo(pRC);
        pRet->SetAt(i, (OBJECTREF) refMethod);
    }

    *((PTRARRAYREF *)&rv) = pRet;
    GCPROTECT_END();
    return rv;
}

// InternalSetter
// This method will return the Set Accessor method on a property
LPVOID __stdcall COMMember::InternalSetter(_GetInternalSetterArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    if (!pProp->pSetter) 
        return 0;
    if (!args->bNonPublic && !pProp->pSetter->IsPublic())
        return 0;

    RefSecContext sCtx;

    if (!pProp->pSetter->IsPublic() && args->bVerifyAccess)
        InvokeUtil::CheckAccess(&sCtx,
                                pProp->pSetter->attrs,
                                pProp->pSetter->pMethod->GetMethodTable(),
                                REFSEC_THROW_SECURITY);

    // If the method has a linktime security demand attached, check it now.
    InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pSetter->pMethod, true);

    // Find the method...
    REFLECTBASEREF refMethod = pProp->pSetter->GetMethodInfo(pRC);
    *((REFLECTBASEREF*) &rv) = refMethod;
    return rv;
}

// InternalGetter
// This method will return the Get Accessor method on a property
LPVOID __stdcall COMMember::InternalGetter(_GetInternalGetterArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID          rv;
    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    if (!pProp->pGetter) 
        return 0;
    if (!args->bNonPublic && !pProp->pGetter->IsPublic())
        return 0;

    RefSecContext sCtx;

    if (!pProp->pGetter->IsPublic() && args->bVerifyAccess)
        InvokeUtil::CheckAccess(&sCtx,
                                pProp->pGetter->attrs,
                                pProp->pGetter->pMethod->GetMethodTable(),
                                REFSEC_THROW_SECURITY);

    // If the method has a linktime security demand attached, check it now.
    InvokeUtil::CheckLinktimeDemand(&sCtx, pProp->pGetter->pMethod, true);

    REFLECTBASEREF refMethod = pProp->pGetter->GetMethodInfo(pRC);
    *((REFLECTBASEREF*) &rv) = refMethod;
    return rv;
}

// PublicProperty
// This method will check to see if the passed property has any
//  public accessors (Making it publically exposed.)
bool COMMember::PublicProperty(ReflectProperty* pProp)
{
    _ASSERTE(pProp);

    if (pProp->pSetter && IsMdPublic(pProp->pSetter->attrs))
        return true;
    if (pProp->pGetter && IsMdPublic(pProp->pGetter->attrs))
        return true;
    return false;
}

// StaticProperty
// This method will check to see if any of the accessor are static
//  which will make it a static property
bool COMMember::StaticProperty(ReflectProperty* pProp)
{
    _ASSERTE(pProp);

    if (pProp->pSetter && IsMdStatic(pProp->pSetter->attrs))
        return true;
    if (pProp->pGetter && IsMdStatic(pProp->pGetter->attrs))
        return true;
    return false;
}

// PublicEvent
// This method looks at each of the event accessors, if any
//  are public then the event is considered public
bool COMMember::PublicEvent(ReflectEvent* pEvent)
{
    _ASSERTE(pEvent);

    if (pEvent->pAdd && IsMdPublic(pEvent->pAdd->attrs))
        return true;
    if (pEvent->pRemove && IsMdPublic(pEvent->pRemove->attrs))
        return true;
    if (pEvent->pFire && IsMdPublic(pEvent->pFire->attrs))
        return true;
    return false;
}

// StaticEvent
// This method will check to see if any of the accessor are static
//  which will make it a static event
bool COMMember::StaticEvent(ReflectEvent* pEvent)
{
    _ASSERTE(pEvent);

    if (pEvent->pAdd && IsMdStatic(pEvent->pAdd->attrs))
        return true;
    if (pEvent->pRemove && IsMdStatic(pEvent->pRemove->attrs))
        return true;
    if (pEvent->pFire && IsMdStatic(pEvent->pFire->attrs))
        return true;
    return false;
}

// IsReadOnly
// This method will return a boolean value indicating if the Property is
//  a ReadOnly property.  This is defined by the lack of a Set Accessor method.
//@TODO: Should we cache this?
INT32 __stdcall COMMember::CanRead(_GetPropBoolArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    return (pProp->pGetter) ? 1 : 0;
}

// IsWriteOnly
// This method will return a boolean value indicating if the Property is
//  a WriteOnly property.  This is defined by the lack of a Get Accessor method.
//@TODO: Should we cache this?
INT32 __stdcall COMMember::CanWrite(_GetPropBoolArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    ReflectClass* pRC = (ReflectClass*) args->refThis->GetReflClass();
    ReflectProperty* pProp = (ReflectProperty*) args->refThis->GetData();
    return (pProp->pSetter) ? 1 : 0;
}

// InternalGetCurrentMethod
// Return the MethodInfo that represents the current method (two above this one)
LPVOID __stdcall COMMember::InternalGetCurrentMethod(_InternalGetCurrentMethodArgs* args)
{
    SkipStruct skip;
    skip.pStackMark = args->stackMark;
    skip.pMeth = 0;
    StackWalkFunctions(GetThread(), SkipMethods, &skip);
    if (skip.pMeth == 0)
        return 0;

    OBJECTREF o = COMMember::g_pInvokeUtil->GetMethodInfo(skip.pMeth);
    LPVOID          rv;
    *((OBJECTREF*) &rv) = o;
    return rv;
}

// This method is called by the GetMethod function and will crawl backward
//  up the stack for integer methods.
StackWalkAction COMMember::SkipMethods(CrawlFrame* frame, VOID* data)
{
    SkipStruct* pSkip = (SkipStruct*) data;

    //@TODO: Are frames always FramedMethodFrame?
    //       Not at all (FPG)
    MethodDesc *pFunc = frame->GetFunction();

    /* We asked to be called back only for functions */
    _ASSERTE(pFunc);

    // The check here is between the address of a local variable
    // (the stack mark) and a pointer to the EIP for a frame
    // (which is actually the pointer to the return address to the
    // function from the previous frame). So we'll actually notice
    // which frame the stack mark was in one frame later. This is
    // fine since we only implement LookForMyCaller.
    _ASSERTE(*pSkip->pStackMark == LookForMyCaller);
    if ((size_t)frame->GetRegisterSet()->pPC < (size_t)pSkip->pStackMark)
        return SWA_CONTINUE;

    pSkip->pMeth = pFunc;
    return SWA_ABORT;
}

// GetFieldType
// This method will return a Class object which represents the
//  type of the field.
LPVOID __stdcall COMMember::GetFieldType(_GetFieldTypeArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    PCCOR_SIGNATURE pSig;
    DWORD           cSig;
    TypeHandle      typeHnd;

    // Get the field
    ReflectField* pRF = (ReflectField*) args->refThis->GetData();
    FieldDesc* pFld = pRF->pField;
    _ASSERTE(pFld);

    // Get the signature
    pFld->GetSig(&pSig, &cSig);
    FieldSig sig(pSig, pFld->GetModule());

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    typeHnd = sig.GetTypeHandle(&throwable);
    if (typeHnd.IsNull())
        COMPlusThrow(throwable);
    GCPROTECT_END();

    // Ignore null return
    OBJECTREF ret = typeHnd.CreateClassObj();
    return(OBJECTREFToObject(ret));
}

// GetBaseDefinition
// Return the MethodInfo that represents the first definition of this
//  virtual method.
LPVOID __stdcall COMMember::GetBaseDefinition(_GetBaseDefinitionArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    MethodDesc*     pMeth;
    WORD            slot;
    EEClass*        pEEC;
    LPVOID          rv;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    slot = pMeth->GetSlot();
    pEEC = pMeth->GetClass();

    // If this is an interface then this is the base definition...
    if (pEEC->IsInterface()) {
        *((REFLECTBASEREF*) &rv) = args->refThis;
        return rv;
    }

    // If this isn't in the VTable then it must be the real implementation...
    if (slot > pEEC->GetNumVtableSlots()) {
        *((REFLECTBASEREF*) &rv) = args->refThis;
        return rv;
    }

    // Find the first definition of this in the hierarchy....
    pEEC = pEEC->GetParentClass();
    while (pEEC) {
        WORD vtCnt = pEEC->GetNumVtableSlots();
        if (vtCnt <= slot)
            break;
        pMeth = pEEC->GetMethodDescForSlot(slot);
        pEEC = pMeth->GetClass();
        if (!pEEC)
            break;
        pEEC = pEEC->GetParentClass();
    }

    // Find the Object so we can get its version of the MethodInfo...
    _ASSERTE(pMeth);
    OBJECTREF o = g_pInvokeUtil->GetMethodInfo(pMeth);
    *((OBJECTREF*) &rv) = o;
    return rv;
}

// GetParentDefinition
// Return the MethodInfo that represents the previous definition of this
//  virtual method in the inheritance chain.
LPVOID __stdcall COMMember::GetParentDefinition(_GetParentDefinitionArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refThis == NULL) 
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    MethodDesc*     pMeth;
    WORD            slot;
    EEClass*        pEEC;
    LPVOID          rv;

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    slot = pMeth->GetSlot();
    pEEC = pMeth->GetClass();

    // If this is an interface then there is no Parent Definition.
    // Get a null back serves as a terminal condition.
    if (pEEC->IsInterface()) {
        return NULL;
    }

    // Find the parents definition of this in the hierarchy....
    pEEC = pEEC->GetParentClass();
    if (!pEEC)
        return NULL;

    WORD vtCnt = pEEC->GetNumVtableSlots();     
    if (vtCnt <= slot) // If this isn't in the VTable then it must be the real implementation...
        return NULL;
    pMeth = pEEC->GetMethodDescForSlot(slot);
    
    // Find the Object so we can get its version of the MethodInfo...
    _ASSERTE(pMeth);
    OBJECTREF o = g_pInvokeUtil->GetMethodInfo(pMeth);
    *((OBJECTREF*) &rv) = o;
    return rv;
}

// GetTypeHandleImpl
// This method will return the MethodTypeHandle for a MethodInfo object
FCIMPL1(void*, COMMember::GetMethodHandleImpl, ReflectBaseObject* method) {
    VALIDATEOBJECTREF(method);

    ReflectMethod* pRM = (ReflectMethod*) method->GetData();
    _ASSERTE(pRM->pMethod);
    return pRM->pMethod;
}
FCIMPLEND

// GetMethodFromHandleImp
// This is a static method which will return a MethodInfo object based
//  upon the passed in Handle.
FCIMPL1(Object*, COMMember::GetMethodFromHandleImp, LPVOID handle) {

    OBJECTREF objMeth;
    MethodDesc* pMeth = (MethodDesc*) handle;
    if (pMeth == 0)
        FCThrowArgumentEx(kArgumentException, NULL, L"InvalidOperation_HandleIsNotInitialized");

    HELPER_METHOD_FRAME_BEGIN_RET_0();
    REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) pMeth->GetClass()->GetExposedClassObject();

    if (pMeth->IsCtor() || pMeth->IsStaticInitMethod()) {
        ReflectMethod* pRM = ((ReflectClass*) pRefClass->GetData())->FindReflectConstructor(pMeth);
        objMeth = (OBJECTREF) pRM->GetConstructorInfo((ReflectClass*) pRefClass->GetData());
    }
    else {
        ReflectMethod* pRM = ((ReflectClass*) pRefClass->GetData())->FindReflectMethod(pMeth);
        objMeth = (OBJECTREF) pRM->GetMethodInfo((ReflectClass*) pRefClass->GetData());
    }
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(objMeth);
}
FCIMPLEND

FCIMPL1(size_t, COMMember::GetFunctionPointer, size_t pMethodDesc) {
    MethodDesc *pMD = (MethodDesc*)pMethodDesc;
    if (pMD)
        return (size_t)pMD->GetPreStubAddr();
    return 0;
}
FCIMPLEND

// GetFieldHandleImpl
// This method will return the RuntimeFieldHandle for a FieldInfo object
FCIMPL1(void*, COMMember::GetFieldHandleImpl, ReflectBaseObject* field) {
    VALIDATEOBJECTREF(field);

    ReflectField* pRF = (ReflectField*) field->GetData();
    _ASSERTE(pRF->pField);
    
    return pRF->pField;
}
FCIMPLEND

// GetFieldFromHandleImp
// This is a static method which will return a FieldInfo object based
//  upon the passed in Handle.
FCIMPL1(Object*, COMMember::GetFieldFromHandleImp, LPVOID handle) {

    OBJECTREF objMeth;
    FieldDesc* pField = (FieldDesc*) handle;
    if (pField == 0)
        FCThrowArgumentEx(kArgumentException, NULL, L"InvalidOperation_HandleIsNotInitialized");
    
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    REFLECTCLASSBASEREF pRefClass = (REFLECTCLASSBASEREF) pField->GetEnclosingClass()->GetExposedClassObject();

    ReflectField* pRF = ((ReflectClass*) pRefClass->GetData())->FindReflectField(pField);
    objMeth = (OBJECTREF) pRF->GetFieldInfo((ReflectClass*) pRefClass->GetData());
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(objMeth);
}
FCIMPLEND

// DBCanConvertPrimitive
// This method checks to see of the source class can be widdened
//  to the target class.  This is a private routine so no error checking is
//  done.
FCIMPL2(INT32, COMMember::DBCanConvertPrimitive, ReflectClassBaseObject* source, ReflectClassBaseObject* target) {
    VALIDATEOBJECTREF(source);
    VALIDATEOBJECTREF(target);

    ReflectClass* pSRC = (ReflectClass*) source->GetData();
    _ASSERTE(pSRC);
    ReflectClass* pTRG = (ReflectClass*) target->GetData();
    _ASSERTE(pTRG);
    CorElementType tSRC = pSRC->GetCorElementType();
    CorElementType tTRG = pTRG->GetCorElementType();

    INT32 ret = InvokeUtil::IsPrimitiveType(tTRG) && InvokeUtil::CanPrimitiveWiden(tTRG,tSRC);
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND
// DBCanConvertObjectPrimitive
// This method returns a boolean indicating if the source object can be 
//  converted to the target primitive.
FCIMPL2(INT32, COMMember::DBCanConvertObjectPrimitive, Object* sourceObj, ReflectClassBaseObject* target) {
    VALIDATEOBJECTREF(sourceObj);
    VALIDATEOBJECTREF(target);

    if (sourceObj == 0)
        return 1;
    MethodTable* pMT = sourceObj->GetMethodTable();
    CorElementType tSRC = pMT->GetNormCorElementType();

    ReflectClass* pTRG = (ReflectClass*) target->GetData();
    _ASSERTE(pTRG);
    CorElementType tTRG = pTRG->GetCorElementType();
    INT32 ret = InvokeUtil::IsPrimitiveType(tTRG) && InvokeUtil::CanPrimitiveWiden(tTRG,tSRC);
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND

FCIMPL1(Object *, COMMember::InternalGetEnumUnderlyingType, ReflectClassBaseObject *target)
{
    VALIDATEOBJECTREF(target);

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();

    if (!th.IsEnum())
        FCThrowArgument(NULL, NULL);
    OBJECTREF result = NULL;

    HELPER_METHOD_FRAME_BEGIN_RET_0();
    EEClass *pClass = g_Mscorlib.FetchElementType(th.AsMethodTable()->GetNormCorElementType())->GetClass();

    result = pClass->GetExistingExposedClassObject();

    if (result == NULL)
    {
        result = pClass->GetExposedClassObject();
    }
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(result);
} 
FCIMPLEND

FCIMPL1(Object *, COMMember::InternalGetEnumValue, Object *pRefThis)
{
    VALIDATEOBJECTREF(pRefThis);

    if (pRefThis == NULL)
        FCThrowArgumentNull(NULL);

    OBJECTREF result = NULL;

    HELPER_METHOD_FRAME_BEGIN_RET_1(pRefThis);

    MethodTable *pMT = g_Mscorlib.FetchElementType(pRefThis->GetTrueMethodTable()->GetNormCorElementType());
    result = AllocateObject(pMT);

    CopyValueClass(result->UnBox(), pRefThis->UnBox(), pMT, GetAppDomain());
    
    HELPER_METHOD_FRAME_END();

    return OBJECTREFToObject(result);
}
FCIMPLEND

FCIMPL3(void, COMMember::InternalGetEnumValues, 
        ReflectClassBaseObject *target, Object **pReturnValues, Object **pReturnNames)
{
    VALIDATEOBJECTREF(target);

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    
    THROWSCOMPLUSEXCEPTION();

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();

    if (!th.IsEnum())
        COMPlusThrow(kArgumentException, L"Arg_MustBeEnum");

    EnumEEClass *pClass = (EnumEEClass*) th.AsClass();

    HRESULT hr = pClass->BuildEnumTables();
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    DWORD cFields = pClass->GetEnumCount();
    
    struct gc {
        I8ARRAYREF values;
        PTRARRAYREF names;
    } gc;
    gc.values = NULL;
    gc.names = NULL;
    GCPROTECT_BEGIN(gc);

    gc.values = (I8ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U8, cFields);

    CorElementType type = pClass->GetMethodTable()->GetNormCorElementType();
    INT64 *pToValues = gc.values->GetDirectPointerToNonObjectElements();

    for (DWORD i=0;i<cFields;i++)
    {
        switch (type)
        {
        case ELEMENT_TYPE_I1:
            pToValues[i] = (SBYTE) pClass->GetEnumByteValues()[i];
            break;

        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_BOOLEAN:
            pToValues[i] = pClass->GetEnumByteValues()[i];
            break;
    
        case ELEMENT_TYPE_I2:
            pToValues[i] = (SHORT) pClass->GetEnumShortValues()[i];
            break;

        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:
            pToValues[i] = pClass->GetEnumShortValues()[i];
            break;
    
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_I:
            pToValues[i] = (INT) pClass->GetEnumIntValues()[i];
            break;

        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_U:
            pToValues[i] = pClass->GetEnumIntValues()[i];
            break;

        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
            pToValues[i] = pClass->GetEnumLongValues()[i];
            break;
        }
    }
    
    gc.names = (PTRARRAYREF) AllocateObjectArray(cFields, g_pStringClass);
    
    LPCUTF8 *pNames = pClass->GetEnumNames();
    for (i=0;i<cFields;i++)
    {
        STRINGREF str = COMString::NewString(pNames[i]);
        gc.names->SetAt(i, str);
    }
    
    *pReturnValues = OBJECTREFToObject(gc.values);
    *pReturnNames = OBJECTREFToObject(gc.names);

    GCPROTECT_END();
    
    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND
        

// InternalBoxEnumI4
// This method will create an Enum object and place the value inside
//  it and return it.  The Type has been validated before calling.
FCIMPL2(Object*, COMMember::InternalBoxEnumI4, ReflectClassBaseObject* target, INT32 value) 
{
    VALIDATEOBJECTREF(target);
    OBJECTREF ret;

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    ret = AllocateObject(th.AsMethodTable());
    CopyValueClass(ret->UnBox(), &value, th.AsMethodTable(), ret->GetAppDomain());
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(ret);
}
FCIMPLEND

// InternalBoxEnumU4
// This method will create an Enum object and place the value inside
//  it and return it.  The Type has been validated before calling.
FCIMPL2(Object*, COMMember::InternalBoxEnumU4, ReflectClassBaseObject* target, UINT32 value) 
{
    VALIDATEOBJECTREF(target);
    OBJECTREF ret;

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    ret = AllocateObject(th.AsMethodTable());
    CopyValueClass(ret->UnBox(), &value, th.AsMethodTable(), ret->GetAppDomain());
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(ret);
}
FCIMPLEND

// InternalBoxEnumI8
// This method will create an Enum object and place the value inside
//  it and return it.  The Type has been validated before calling.
FCIMPL2(Object*, COMMember::InternalBoxEnumI8, ReflectClassBaseObject* target, INT64 value) 
{
    VALIDATEOBJECTREF(target);
    OBJECTREF ret;

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    ret = AllocateObject(th.AsMethodTable());
    CopyValueClass(ret->UnBox(), &value, th.AsMethodTable(), ret->GetAppDomain());
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(ret);
}
FCIMPLEND

// InternalBoxEnumU8
// This method will create an Enum object and place the value inside
//  it and return it.  The Type has been validated before calling.
FCIMPL2(Object*, COMMember::InternalBoxEnumU8, ReflectClassBaseObject* target, UINT64 value) 
{
    VALIDATEOBJECTREF(target);
    OBJECTREF ret;

    ReflectClass* pSRC = (ReflectClass*) target->GetData();
    _ASSERTE(pSRC);
    TypeHandle th = pSRC->GetTypeHandle();
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    ret = AllocateObject(th.AsMethodTable());
    CopyValueClass(ret->UnBox(), &value, th.AsMethodTable(), ret->GetAppDomain());
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(ret);
}
FCIMPLEND

INT32 __stdcall COMMember::IsOverloaded(_IsOverloadedArgs* args)
{
    ReflectClass* pRC = (ReflectClass *)args->refThis->GetReflClass();
    _ASSERTE(pRC);

    ReflectMethodList* pMeths = NULL;

    ReflectMethod *pRM = (ReflectMethod *)args->refThis->GetData();
    MethodDesc *pMeth = pRM->pMethod;
    LPCUTF8 szMethName = pMeth->GetName();

    int matchingMethods = 0;
    // See if this is a ctor
    if (IsMdInstanceInitializer(pRM->attrs, szMethName))
    {
        pMeths = pRC->GetConstructors();

        matchingMethods = pMeths->dwMethods;
    }
    else if (IsMdClassConstructor(pRM->attrs, szMethName))
    {
        // You can never overload a class constructor!
        matchingMethods = 0;
    }
    else
    {
        _ASSERTE(!IsMdRTSpecialName(pRM->attrs));

        pMeths = pRC->GetMethods();

        ReflectMethod *p = pMeths->hash.Get(szMethName);

        while (p)
        {
            if (!strcmp(p->szName, szMethName))
            {
                matchingMethods++;
                if (matchingMethods > 1)
                    return true;
            }

            p = p->pNext;

        }
    }
    if (matchingMethods > 1)
        return true;
    else
        return false;
}

INT32 __stdcall COMMember::HasLinktimeDemand(_HasLinktimeDemandArgs* args)
{
    ReflectMethod* pRM = (ReflectMethod*)args->refThis->GetData();
    return pRM->pMethod->RequiresLinktimeCheck();
}


/*
void __stdcall COMMember::InternalDirectInvoke(_InternalDirectInvokeArgs* args)
{
    HRESULT         hr;
    MethodDesc*     pMeth;
    int             argCnt;
    int             thisPtr;
    EEClass*        eeClass;
        TypedByRef              byref;
    INT64           ret = 0;
    EEClass*        pEECValue = 0;
    bool            IsValueClass = false;

    THROWSCOMPLUSEXCEPTION();
    ReflectMethod* pRM = (ReflectMethod*) args->refThis->GetData();
    _ASSERTE(pRM);
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);
    eeClass = pMeth->GetClass();
    _ASSERTE(eeClass);

    DWORD attr = pRM->attrs;
    ExpandSig* mSig = pRM->GetSig();

    // Get the number of args on this element
    argCnt = (int) mSig->NumFixedArgs();
    thisPtr = (IsMdStatic(attr)) ? 0 : 1;

    VerifyType(&args->target,eeClass,thisPtr,&pMeth);
    if (args->target != NULL)
        IsValueClass = (args->target->GetTrueClass()->IsValueClass()) ? true : false;

    // Verify that we have been provided the proper number of args
    if (args->varArgs.RemainingArgs == 0) {
        if (argCnt > 0) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }
    else {
        if (args->varArgs.RemainingArgs != argCnt) {
            // The wrong number of arguments were passed
            COMPlusThrow(kTargetParameterCountException,L"Arg_ParmCnt");
        }
    }

    // this security context will be used in cast checking as well
    RefSecContext sCtx;

    // Validate the method can be called by this caller
    if (!IsMdPublic(attr) || pMeth->RequiresLinktimeCheck())
        CanAccess(pMeth, &sCtx);

    // We need to Prevent GC after we begin to build the stack.  If we are doing 
    //  default binding, we can proceed.  Otherwise we need to validate all of the arguments
    //  and then proceed.
    if (!(args->attrs & BINDER_ExactBinding) && args->binder != NULL && !args->isBinderDefault) {
    }

    // Build the arguments.  This is built as a single array of arguments
    //  the this pointer is first All of the rest of the args are placed in reverse order
    BYTE *  pNewArgs = 0;
    UINT    nStackBytes = mSig->SizeOfVirtualFixedArgStack(IsMdStatic(attr));
    pNewArgs = (BYTE *) _alloca(nStackBytes);
    BYTE *  pDst= pNewArgs;
    void*   pRetValueClass = 0;

    // Allocate a stack of objects
    OBJECTREF* pObjs = (OBJECTREF*) _alloca(sizeof(OBJECTREF) * argCnt);
    memset(pObjs,0,sizeof(OBJECTREF) * argCnt);
    GCPROTECT_ARRAY_BEGIN(*pObjs,argCnt);

        // Allocate the call stack
    void** pDstTarg = (void**) _alloca(sizeof(void*) * argCnt);
    memset(pDstTarg,0,sizeof(void*) * argCnt);

        // Establish the enumerator through the signature
    void* pEnum;
    mSig->Reset(&pEnum);

        // Move to the last position in the stack
    pDst += nStackBytes;

    if (mSig->IsRetBuffArg()) {
        pEECValue = mSig->GetReturnClass();
        _ASSERTE(pEECValue->IsValueClass());
        pRetValueClass = _alloca(pEECValue->GetAlignedNumInstanceFieldBytes());
        memset(pRetValueClass,0,pEECValue->GetAlignedNumInstanceFieldBytes());
        UINT cbSize = mSig->GetStackElemSize(ELEMENT_TYPE_BYREF,pEECValue);
        pDst -= cbSize;
        *((void**) pDst) = pRetValueClass;
    }

        // copy the varArgs.
        VARARGS                 newVarArgs = args->varArgs;

        // copy the primitives....
    for (int i=0;i< (int) argCnt;i++) {
        TypeHandle th = mSig->NextArgExpanded(&pEnum);
                COMVarArgs::GetNextArgHelper(&newVarArgs, &byref); 

        UINT cbSize = mSig->GetStackElemSize(th);
        pDst -= cbSize;

        // This routine will verify that all types are correct.
        //@TODO: What are we going to do about the copy of value classes
        //  containing ORs?
        g_pInvokeUtil->CreateArg(th,&byref,pDst,pObjs,pDstTarg,i,cbSize,&sCtx);
    }

    // NO GC AFTER THIS POINT UNTIL AFTER THE CALL....
    // Copy "this" pointer
    if (thisPtr)
        *(OBJECTREF *) pNewArgs = args->target;

    // Copy the OBJRECTREF args
    for (i=0;i<(int)argCnt;i++) {
        if (pDstTarg[i] != 0) 
            *((OBJECTREF*) pDstTarg[i]) = pObjs[i];
    }

    // Call the method
    COMPLUS_TRY {
        MetaSig threadSafeSig(*mSig);
        ret = pMeth->Call(pNewArgs,&threadSafeSig);
    } COMPLUS_CATCH {
        // If we get here we need to throw an TargetInvocationException
        OBJECTREF ppException = GETTHROWABLE();
        _ASSERTE(ppException);
        GCPROTECT_BEGIN(ppException);
        OBJECTREF except = g_pInvokeUtil->CreateTargetExcept(&ppException);
        COMPlusThrow(except);
        GCPROTECT_END();
    } COMPLUS_END_CATCH

    // Now we need to create the return type.
    if (pEECValue) {
        _ASSERTE(pRetValueClass);
        if (pEECValue != COMVariant::s_pVariantClass) {
            OBJECTREF retO = pEECValue->GetMethodTable()->Box(pRetValueClass);
            COMVariant::NewVariant(args->retRef,&retO);
        }
        else {
            CopyValueClass(args->retRef,pRetValueClass,COMVariant::s_pVariantClass->GetMethodTable());
        }
    }
    else {
        TypeHandle th = mSig->GetReturnTypeHandle();
        hr = g_pInvokeUtil->CreateObject(th,ret,args->retRef);
        if (FAILED(hr)) {
            FATAL_EE_ERROR();
        }
    }

    GCPROTECT_END();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commember.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// COMMember.h
//  This module defines the native reflection routines used by Method, Field and Constructor
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMMEMBER_H_
#define _COMMEMBER_H_

#include "COMClass.h"
#include "InvokeUtil.h"
#include "ReflectUtil.h"
#include "COMString.h"
#include "COMVarArgs.h"
#include "fcall.h"

// NOTE: The following constants are defined in BindingFlags.cool
#define BINDER_IgnoreCase           0x01 
#define BINDER_DeclaredOnly         0x02
#define BINDER_Instance             0x04
#define BINDER_Static               0x08
#define BINDER_Public               0x10
#define BINDER_NonPublic            0x20
#define BINDER_FlattenHierarchy     0x40

#define BINDER_InvokeMethod         0x00100
#define BINDER_CreateInstance       0x00200
#define BINDER_GetField             0x00400
#define BINDER_SetField             0x00800
#define BINDER_GetProperty          0x01000
#define BINDER_SetProperty          0x02000
#define BINDER_PutDispProperty      0x04000
#define BINDER_PutRefDispProperty   0x08000

#define BINDER_ExactBinding         0x010000
#define BINDER_SuppressChangeType   0x020000
#define BINDER_OptionalParamBinding 0x040000

#define BINDER_IgnoreReturn         0x1000000

#define BINDER_DefaultLookup        (BINDER_Instance | BINDER_Static | BINDER_Public)
#define BINDER_AllLookup            (BINDER_Instance | BINDER_Static | BINDER_Public | BINDER_Instance)

// The following values define the MemberTypes constants.  These are defined in 
//  Reflection/MemberTypes.cool
#define MEMTYPE_Constructor         0x01    
#define MEMTYPE_Event               0x02
#define MEMTYPE_Field               0x04
#define MEMTYPE_Method              0x08
#define MEMTYPE_Property            0x10
#define MEMTYPE_TypeInfo            0x20
#define MEMTYPE_Custom              0x40
#define MEMTYPE_NestedType          0x80

// The following value class represents a ParameterModifier.  This is defined in the
//  reflection package
#pragma pack(push)
#pragma pack(1)

// These are the constants 
#define PM_None             0x00
#define PM_ByRef            0x01
#define PM_Volatile         0x02
#define PM_CustomRequired   0x04

#pragma pack(pop)


class COMMember
{
public:
    struct _InvokeMethodArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(BOOL, verifyAccess);
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, caller);
        DECLARE_ECALL_I4_ARG(BOOL, isBinderDefault);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, locale);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, objs);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, binder);
        DECLARE_ECALL_I4_ARG(INT32, attrs); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
    };

private:
    struct _GetNameArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _GetTokenNameArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };

    struct _GetDeclaringClassArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _GetEventDeclaringClassArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };


    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    } _GETSIGNATUREARGS;

    struct _GetAttributeFlagsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _GetMethodImplFlagsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _GetCallingConventionArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    struct _GetTokenAttributeFlagsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };

    struct _InternalDirectInvokeArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
        DECLARE_ECALL_OBJECTREF_ARG(VARARGS, varArgs);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, locale);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, binder);
        DECLARE_ECALL_I4_ARG(INT32, attrs); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
        DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);      // Return reference
    };

    struct _InvokeConsArgs          {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
        DECLARE_ECALL_I4_ARG(BOOL, isBinderDefault); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, locale);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, objs);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, binder);
        DECLARE_ECALL_I4_ARG(INT32, attrs); 
    };

    struct StreamingContextData {
        OBJECTREF additionalContext;
        INT32     contextStates;
    };
    struct _SerializationInvokeArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(StreamingContextData, context);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, serializationInfo);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
    };

    struct _GetParmTypeArgs         {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _GetReturnTypeArgs       {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    struct _FieldGetArgs            {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL, requiresAccessCheck);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
    };
    struct _FieldSetArgs            {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL, isBinderDefault); 
        DECLARE_ECALL_I4_ARG(BOOL, requiresAccessCheck);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, locale);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, binder);
        DECLARE_ECALL_I4_ARG(INT32, attrs); 
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, value);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
    };
    struct _GetReflectedClassArgs   {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL, returnGlobalClass);
    };
    struct _GetAttributeArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    } ;
    struct _GetAttributesArgs       {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    //struct _GetExceptionsArgs     {
    //  DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    //};
    struct _CreateInstanceArgs      {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(BOOL, publicOnly);
    };

    struct _EqualsArgs              {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    };
    /*
    struct _TokenEqualsArgs         {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    };
    */
    struct _PropertyEqualsArgs          {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
    };

    struct _GetAddMethodArgs        {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetRemoveMethodArgs     {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetRaiseMethodArgs      {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetAccessorsArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetInternalGetterArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bVerifyAccess); 
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetInternalSetterArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bVerifyAccess); 
        DECLARE_ECALL_I4_ARG(DWORD, bNonPublic); 
    };

    struct _GetPropEventArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };

    struct _GetPropBoolArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };

    struct _GetFieldTypeArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTTOKENBASEREF, refThis);
    };

    struct _GetBaseDefinitionArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    struct _GetParentDefinitionArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    struct _IsOverloadedArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    struct _HasLinktimeDemandArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };

    struct _InternalGetCurrentMethodArgs {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
    };

    struct _ObjectToTypedReferenceArgs {
        DECLARE_ECALL_OBJECTREF_ARG(TypeHandle, th);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj);
        DECLARE_ECALL_PTR_ARG(TypedByRef, typedReference); 
    };

	struct _TypedReferenceToObjectArgs {
        DECLARE_ECALL_PTR_ARG(TypedByRef, typedReference); 
    };   

    // This method is called by the GetMethod function and will crawl backward
    //  up the stack for integer methods.
    static StackWalkAction SkipMethods(CrawlFrame*, VOID*);

    // InvokeArrayCons
    // This method will return a new Array Object from the constructor.
    static LPVOID InvokeArrayCons(ReflectArrayClass* pRC,MethodDesc* pMeth,
        PTRARRAYREF* objs,int argCnt);

    // The following structure is provided to the stack skip function.  It will
    //  skip cSkip methods and the return the next MethodDesc*.
    struct SkipStruct {
        StackCrawlMark* pStackMark;
        MethodDesc*     pMeth;
    };

    static EEClass* _DelegateClass;
    static EEClass* _MulticastDelegateClass;

    // This method will verify the type relationship between the target and
    //  the eeClass of the method we are trying to invoke.  It checks that for 
    //  non static method, target is provided.  It also verifies that the target is
    //  a subclass or implements the interface that this MethodInfo represents.  
    //  We may update the MethodDesc in the case were we need to lookup the real
    //  method implemented on the object for an interface.
    static void VerifyType(OBJECTREF *target,EEClass* eeClass, EEClass* trueClass,int thisPtr,MethodDesc** ppMeth, TypeHandle typeTH, TypeHandle targetTH);

public:
    // These are the base method tables for the basic Reflection
    //  types
    static MethodTable* m_pMTIMember;
    static MethodTable* m_pMTFieldInfo;
    static MethodTable* m_pMTPropertyInfo;
    static MethodTable* m_pMTEventInfo;
    static MethodTable* m_pMTType;
    static MethodTable* m_pMTMethodInfo;
    static MethodTable* m_pMTConstructorInfo;
    static MethodTable* m_pMTMethodBase;
    static MethodTable* m_pMTParameter;

    static MethodTable *GetParameterInfo()
    {
        if (m_pMTParameter)
            return m_pMTParameter;
    
        m_pMTParameter = g_Mscorlib.FetchClass(CLASS__PARAMETER);
        return m_pMTParameter;
    }

    static MethodTable *GetMemberInfo()
    {
        if (m_pMTIMember)
            return m_pMTIMember;
    
        m_pMTIMember = g_Mscorlib.FetchClass(CLASS__MEMBER);
        return m_pMTIMember;
    }

    // This is the Global InvokeUtil class
    static InvokeUtil*  g_pInvokeUtil;

    // DBCanConvertPrimitive
    // This method returns a boolean indicting if the source primitive can be
    //  converted to the target
    static FCDECL2(INT32, DBCanConvertPrimitive, ReflectClassBaseObject* vSource, ReflectClassBaseObject* vTarget);

    // DBCanConvertObjectPrimitive
    // This method returns a boolean indicating if the source object can be 
    //  converted to the target primitive.
    static FCDECL2(INT32, DBCanConvertObjectPrimitive, Object* vSourceObj, ReflectClassBaseObject* vTarget);

    // DirectFieldGet
    // This is a field set method that has a TypeReference that points to the data
    struct _DirectFieldGetArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL, requiresAccessCheck);
        DECLARE_ECALL_OBJECTREF_ARG(TypedByRef, target);
    };
    static LPVOID __stdcall DirectFieldGet(_DirectFieldGetArgs* args);

    // DirectFieldSet
    // This is a field set method that has a TypeReference that points to the data
    struct _DirectFieldSetArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(BOOL, requiresAccessCheck);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, value);
        DECLARE_ECALL_OBJECTREF_ARG(TypedByRef, target);
    };
    static void __stdcall DirectFieldSet(_DirectFieldSetArgs* args);

    // MakeTypedReference
    // This method will take an object, an array of FieldInfo's and create
    //  at TypedReference for it (Assuming its valid).  This will throw a
    //  MissingMemberException
    struct _MakeTypedReferenceArgs {
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, flds);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, target);
        DECLARE_ECALL_PTR_ARG(TypedByRef*, value); 
    };
    static void __stdcall MakeTypedReference(_MakeTypedReferenceArgs* args);

    // DirectObjectFieldSet
    // When the TypedReference points to a object we call this method to
    //  set the field value
    static void __stdcall DirectObjectFieldSet(FieldDesc* pField,_DirectFieldSetArgs* args);

    // DirectObjectFieldGet
    // When the TypedReference points to a object we call this method to
    //  get the field value
    static LPVOID DirectObjectFieldGet(FieldDesc* pField,_DirectFieldGetArgs* args);

    // GetFieldInfoToString
    // This method will return the string representation of the information in FieldInfo.
    static LPVOID __stdcall GetFieldInfoToString(_GetNameArgs* args);

    // GetMethodInfoToString
    // This method will return the string representation of the information in MethodInfo.
    static LPVOID __stdcall GetMethodInfoToString(_GetNameArgs* args);

    // GetPropInfoToString
    // This method will return the string representation of the information in PropInfo.
    static LPVOID __stdcall GetPropInfoToString(_GetTokenNameArgs* args);

    // GetEventInfoToString
    // This method will return the string representation of the information in EventInfo.
    static LPVOID __stdcall GetEventInfoToString(_GetNameArgs* args);


    // GetMethodName
    // This method will return the name of a Method
    static LPVOID __stdcall GetMethodName(_GetNameArgs* args);

    // GetEventName
    // This method will return the name of a Event
    static LPVOID __stdcall GetEventName(_GetTokenNameArgs* args);

    // GetPropName
    // This method will return the name of a Property
    static LPVOID __stdcall GetPropName(_GetTokenNameArgs* args);

    // GetPropType
    // This method will return the Type of a Property
    static LPVOID __stdcall GetPropType(_GetTokenNameArgs* args);

    // GetTypeHandleImpl
    // This method will return the RuntimeMethodHandle for a MethodInfo object. 
    static FCDECL1(void*, GetMethodHandleImpl, ReflectBaseObject* pRefThis);

    // GetMethodFromHandleImp
    // This is a static method which will return a MethodInfo object based
    //  upon the passed in Handle.
    static FCDECL1(Object*, GetMethodFromHandleImp, LPVOID handle);

    static FCDECL1(size_t, GetFunctionPointer, size_t pMethodDesc);
    // GetFieldHandleImpl
    // This method will return the RuntimeFieldHandle for a FieldInfo object
    static FCDECL1(void*, GetFieldHandleImpl, ReflectBaseObject* pRefThis);

    // GetFieldFromHandleImp
    // This is a static method which will return a FieldInfo object based
    //  upon the passed in Handle.
    static FCDECL1(Object*, GetFieldFromHandleImp, LPVOID handle);

    // InternalGetEnumUnderlyingType
    // This method returns the defined values & names for an enum class.
    static FCDECL1(Object *, InternalGetEnumUnderlyingType, ReflectClassBaseObject *target); 

    // InternalGetEnumValue
    // This method returns the defined values & names for an enum class.
    static FCDECL1(Object *, InternalGetEnumValue, Object *pRefThis); 

    // InternalGetEnumValues
    // This method returns the defined values & names for an enum class.
    static FCDECL3(void, InternalGetEnumValues, ReflectClassBaseObject *target, 
                   Object **pReturnValues, Object **pReturnNames);

    // InternalBoxEnumI4
    // This method will create an Enum object and place the value inside
    //  it and return it.  The Type has been validated before calling.
    static FCDECL2(Object*, InternalBoxEnumI4, ReflectClassBaseObject* pEnumType, INT32 value);

    // InternalBoxEnumU4
    // This method will create an Enum object and place the value inside
    //  it and return it.  The Type has been validated before calling.
    static FCDECL2(Object*, InternalBoxEnumU4, ReflectClassBaseObject* pEnumType, UINT32 value);

    // InternalBoxEnumU4
    // This method will create an Enum object and place the value inside
    //  it and return it.  The Type has been validated before calling.
    static FCDECL2(Object*, InternalBoxEnumI8, ReflectClassBaseObject* pEnumType, INT64 value);

    // InternalBoxEnumU4
    // This method will create an Enum object and place the value inside
    //  it and return it.  The Type has been validated before calling.
    static FCDECL2(Object*, InternalBoxEnumU8, ReflectClassBaseObject* pEnumType, UINT64 value);

    /*=============================================================================
    ** GetReturnType
    **
    ** Get the class representing the return type for a method
    **
    ** args->refThis: this Method object reference
    **/
    /*OBJECTREF*/
    LPVOID static __stdcall GetReturnType(_GetReturnTypeArgs*);

    /*=============================================================================
    ** GetParameterTypes
    **
    ** This routine returns an array of Parameters
    **
    ** args->refThis: this Field object reference
    **/
    /*PTRARRAYREF String*/ LPVOID static __stdcall GetParameterTypes(_GetParmTypeArgs* args);

    /*=============================================================================
    ** GetFieldName
    **
    ** The name of this field is returned
    **
    ** args->refThis: this Field object reference
    **/
    /*STRINGREF String*/ LPVOID static __stdcall GetFieldName(_GetNameArgs* args);

    /*=============================================================================
    ** GetDeclaringClass
    **
    ** Returns the class which declared this method or constructor. This may be a
    ** parent of the Class that getMethod() was called on.  Methods are always
    ** associated with a Class.  You cannot invoke a method from one class on
    ** another class even if they have the same signatures.  It is possible to do
    ** this with Delegates.
    **
    ** args->refThis: this object reference
    **/
    static LPVOID __stdcall GetDeclaringClass(_GetDeclaringClassArgs* args);

    // This is the field based version
    static LPVOID __stdcall GetFieldDeclaringClass(_GetDeclaringClassArgs* args);

    // This is the Property based version
    static LPVOID __stdcall GetPropDeclaringClass(_GetDeclaringClassArgs* args);

    // This is the event based version
    static LPVOID __stdcall GetEventDeclaringClass(_GetEventDeclaringClassArgs* args);

    /*=============================================================================
    ** GetReflectedClass
    **
    ** This method returns the class from which this method was reflected.
    **
    ** args->refThis: this object reference
    **/
    /*Class*/ 
    LPVOID static __stdcall GetReflectedClass(_GetReflectedClassArgs* args);

    /*=============================================================================
    ** GetFieldSignature
    **
    ** Returns the signature of the field.
    **
    ** args->refThis: this object reference
    **/
    /*STRINGREF*/ LPVOID static __stdcall GetFieldSignature(_GETSIGNATUREARGS* args);

    // GetAttributeFlags
    // This method will return the attribute flag for a Member.  The 
    //  attribute flag is defined in the meta data.
    static INT32 __stdcall GetAttributeFlags(_GetAttributeFlagsArgs* args);

    // GetCallingConvention
    // Return the calling convention
    static INT32 __stdcall GetCallingConvention(_GetCallingConventionArgs* args);

    // GetMethodImplFlags
    // Return the method impl flags
    static INT32 __stdcall GetMethodImplFlags(_GetMethodImplFlagsArgs* args);

    // GetEventAttributeFlags
    // This method will return the attribute flag for an Event. 
    //  The attribute flag is defined in the meta data.
    static INT32 __stdcall GetEventAttributeFlags(_GetTokenAttributeFlagsArgs* args);

    // GetEventAttributeFlags
    // This method will return the attribute flag for an Event. 
    //  The attribute flag is defined in the meta data.
    static INT32 __stdcall GetPropAttributeFlags(_GetTokenAttributeFlagsArgs* args);

    /*=============================================================================
    ** InvokeBinderMethod
    **
    ** This routine will invoke the method on an object.  It will verify that
    **  the arguments passed are correct
    **
    ** args->refThis: this object reference
    **/
    static LPVOID __stdcall InvokeMethod(_InvokeMethodArgs* args);
    //static void __stdcall InternalDirectInvoke(_InternalDirectInvokeArgs* args);

    // InvokeCons
    // This routine will invoke the constructor for a class.  It will verify that
    //  the arguments passed are correct
    static LPVOID  __stdcall InvokeCons(_InvokeConsArgs* args);


    // SerializationInvoke
    // This routine will call the constructor for a class that implements ISerializable.  It knows
    // the arguments that it's receiving so does less error checking.
    static void __stdcall SerializationInvoke(_SerializationInvokeArgs *args);

    // CreateInstance
    // This routine will create an instance of a Class by invoking the null constructor
    //  if a null constructor is present.  
    // Return LPVOID  (System.Object.)
    // Args: _CreateInstanceArgs
    static LPVOID __stdcall CreateInstance(_CreateInstanceArgs*);


    // FieldGet
    // This method will get the value associated with an object
    static LPVOID __stdcall FieldGet(_FieldGetArgs* args);

    // FieldSet
    // This method will set the field of an associated object
    static void __stdcall FieldSet(_FieldSetArgs* args);

	// ObjectToTypedReference
	// This is an internal helper function to TypedReference class. 
	// We already have verified that the types are compatable. Assing the object in args
	// to the typed reference
	static void __stdcall ObjectToTypedReference(_ObjectToTypedReferenceArgs* args);

    // This is an internal helper function to TypedReference class. 
    // It extracts the object from the typed reference.
    static LPVOID __stdcall TypedReferenceToObject(_TypedReferenceToObjectArgs* args);

    // GetExceptions
    // This method will return all of the exceptions which have been declared
    //  for a method or constructor
    //static LPVOID __stdcall GetExceptions(_GetExceptionsArgs* args);

    // Equals
    // This method will verify that two methods are equal....
    static INT32 __stdcall Equals(_EqualsArgs* args);

    // Equals
    // This method will verify that two methods are equal....
    //static INT32 __stdcall TokenEquals(_TokenEqualsArgs* args);
    // Equals
    // This method will verify that two methods are equal....
    static INT32 __stdcall PropertyEquals(_PropertyEqualsArgs* args);

    // CreateReflectionArgs
    // This method creates the global g_pInvokeUtil pointer.
    static void CreateReflectionArgs() {
        if (!g_pInvokeUtil)
            g_pInvokeUtil = new InvokeUtil(); 
    }

    // GetAddMethod
    // This will return the Add method for an Event
    static LPVOID __stdcall GetAddMethod(_GetAddMethodArgs* args);

    // GetRemoveMethod
    // This method return the unsync method on an event
    static LPVOID __stdcall GetRemoveMethod(_GetRemoveMethodArgs* args);

    // GetRemoveMethod
    // This method return the unsync method on an event
    static LPVOID __stdcall GetRaiseMethod(_GetRaiseMethodArgs* args);

    // GetGetAccessors
    // This method will return an array of the Get Accessors.  If there
    //  are no GetAccessors then we will return an empty array
    static LPVOID __stdcall GetAccessors(_GetAccessorsArgs* args);

    // InternalSetter
    // This method will return the Set Accessor method on a property
    static LPVOID __stdcall InternalSetter(_GetInternalSetterArgs* args);

    // InternalGetter
    // This method will return the Get Accessor method on a property
    static LPVOID __stdcall InternalGetter(_GetInternalGetterArgs* args);

    // CanRead
    // This method will return a boolean value indicating if the Property is
    //  a can be read from.
    static INT32 __stdcall CanRead(_GetPropBoolArgs* args);

    // CanWrite
    // This method will return a boolean value indicating if the Property is
    //  a can be written to.
    static INT32 __stdcall CanWrite(_GetPropBoolArgs* args);

    // GetFieldType
    // This method will return a Class object which represents the
    //  type of the field.
    static LPVOID __stdcall GetFieldType(_GetFieldTypeArgs* args);

    // GetBaseDefinition
    // Return the MethodInfo that represents the first definition of this
    //  virtual method.
    static LPVOID __stdcall GetBaseDefinition(_GetBaseDefinitionArgs* args);

    // GetParentDefinition
    // Return the MethodInfo that represents the previous definition of this
    //  virtual method in the hierarchy, or NULL if none.
    static LPVOID __stdcall GetParentDefinition(_GetParentDefinitionArgs* args);

    // InternalGetCurrentMethod
    // Return the MethodInfo that represents the current method (two above this one)
    static LPVOID __stdcall InternalGetCurrentMethod(_InternalGetCurrentMethodArgs* args);

    // PublicProperty
    // This method will check to see if the passed property has any
    //  public accessors (Making it publically exposed.)
    static bool PublicProperty(ReflectProperty* pProp);

    // StaticProperty
    // This method will check to see if the passed property has any
    //  static methods as accessors.
    static bool StaticProperty(ReflectProperty* pProp);

    // PublicEvent
    // This method looks at each of the event accessors, if any
    //  are public then the event is considered public
    static bool PublicEvent(ReflectEvent* pEvent);

    // StaticEvent
    // This method will check to see if any of the accessor are static
    //  which will make it a static event
    static bool StaticEvent(ReflectEvent* pEvent);

    // FindAccessor
    // This method will find the specified property accessor
    //  pEEC - the class representing the object with the property
    //  tk - the token of the property
    //  type - the type of accessor method 
    static mdMethodDef FindAccessor(IMDInternalImport *pInternalImport,mdToken tk,
        CorMethodSemanticsAttr type,bool bNonPublic);

    static void CanAccess(MethodDesc* pMeth, RefSecContext *pSCtx, 
            bool checkSkipVer = false, bool verifyAccess = true, 
            bool isThisImposedSecurity = false, 
            bool knowForSureImposedSecurityState = false);

    static void CanAccessField(ReflectField* pRF, RefSecContext *pCtx);
    static EEClass *GetUnderlyingClass(TypeHandle *pTH);

    // DBCanConvertPrimitive

    // Terminate
    // This method will cleanup reflection in general.
#ifdef SHOULD_WE_CLEANUP
    static void Terminate()
    { 
        delete g_pInvokeUtil;
        ReflectUtil::Destroy();
        COMClass::Destroy();
    }
#endif /* SHOULD_WE_CLEANUP */

    // Init cache related to field
    static VOID InitReflectField(FieldDesc *pField, ReflectField *pRF);

    static INT32 __stdcall IsOverloaded(_IsOverloadedArgs* args);

    static INT32 __stdcall HasLinktimeDemand(_HasLinktimeDemandArgs* args);
};

#endif // _COMMETHODBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comisolatedstorage.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Class: COMIsolatedStorage
 *
 * Author: Shajan Dasan
 *
 * Purpose: Implementation of IsolatedStorage
 *
 * Date:  Feb 14, 2000
 *
 ===========================================================*/

#include "common.h"
#include "excep.h"
#include "eeconfig.h"
#include "COMString.h"
#include "COMStringCommon.h"    // RETURN()  macro
#include "COMIsolatedStorage.h"

#define IS_ROAMING(x)   ((x) & ISS_ROAMING_STORE)

#define LOCK(p)    hr = (p)->Lock(); if (SUCCEEDED(hr)) { __try {
#define UNLOCK(p)  } __finally { (p)->Unlock(); } }

void COMIsolatedStorage::ThrowISS(HRESULT hr)
{
    static MethodTable * pMT = NULL;

    if (pMT == NULL)
        pMT = g_Mscorlib.GetClass(CLASS__ISSEXCEPTION);

    _ASSERTE(pMT && "Unable to load the throwable class !");

    if ((hr >= ISS_E_ISOSTORE_START) && (hr <= ISS_E_ISOSTORE_END))
    {
        switch (hr)
        {
        case ISS_E_ISOSTORE :
        case ISS_E_OPEN_STORE_FILE :
        case ISS_E_OPEN_FILE_MAPPING :
        case ISS_E_MAP_VIEW_OF_FILE :
        case ISS_E_GET_FILE_SIZE :
        case ISS_E_CREATE_MUTEX :
        case ISS_E_LOCK_FAILED :
        case ISS_E_FILE_WRITE :
        case ISS_E_SET_FILE_POINTER :
        case ISS_E_CREATE_DIR :
            ThrowUsingResourceAndWin32(pMT, hr);
            break;

        case ISS_E_CORRUPTED_STORE_FILE :
        case ISS_E_STORE_VERSION :
        case ISS_E_FILE_NOT_MAPPED :
        case ISS_E_BLOCK_SIZE_TOO_SMALL :
        case ISS_E_ALLOC_TOO_LARGE :
        case ISS_E_USAGE_WILL_EXCEED_QUOTA :
        case ISS_E_TABLE_ROW_NOT_FOUND :
        case ISS_E_DEPRECATE :
        case ISS_E_CALLER :
        case ISS_E_PATH_LENGTH :
        case ISS_E_MACHINE :
        case ISS_E_STORE_NOT_OPEN :
            ThrowUsingResource(pMT, hr);
            break;

        default :
            _ASSERTE(!"Unknown hr");
        }

    }

    ThrowUsingMT(pMT);
}

StackWalkAction COMIsolatedStorage::StackWalkCallBack(
        CrawlFrame* pCf, PVOID ppv)
{
    static MethodTable *s_pIsoStore = NULL;
        if (s_pIsoStore == NULL)
            s_pIsoStore = g_Mscorlib.GetClass(CLASS__ISS_STORE);

    static MethodTable *s_pIsoStoreFile = NULL;
        if (s_pIsoStoreFile == NULL)
            s_pIsoStoreFile = g_Mscorlib.GetClass(CLASS__ISS_STORE_FILE);

    static MethodTable *s_pIsoStoreFileStream = NULL;
        if (s_pIsoStoreFileStream == NULL)
            s_pIsoStoreFileStream = g_Mscorlib.GetClass(CLASS__ISS_STORE_FILE_STREAM);

    // Get the function descriptor for this frame...
    MethodDesc *pMeth = pCf->GetFunction();
    MethodTable *pMT = pMeth->GetMethodTable();

    // Skip the Isolated Store and all it's sub classes..
    // @Todo : This will work for now, but need to walk up to the base class
    // @Todo : Work out the JIT inlining issiues

    if ((pMT == s_pIsoStore)     || 
        (pMT == s_pIsoStoreFile) || 
        (pMT == s_pIsoStoreFileStream))
    {
        LOG((LF_STORE, LL_INFO10000, "StackWalk Continue %s\n", 
            pMeth->m_pszDebugMethodName));
        return SWA_CONTINUE;
    }

    *(PVOID *)ppv = pMeth->GetModule()->GetAssembly();

    return SWA_ABORT;
}

LPVOID __stdcall COMIsolatedStorage::GetCaller(LPVOID)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly *pAssem = NULL;

    if (StackWalkFunctions(GetThread(), StackWalkCallBack, (VOID*)&pAssem)
        == SWA_FAILED)
    {
        FATAL_EE_ERROR();
    }

    if (pAssem == NULL)
        ThrowISS(ISS_E_CALLER);

#ifdef _DEBUG
    CHAR *pName= NULL;
    pAssem->GetName((const char **)&pName);
    LOG((LF_STORE, LL_INFO10000, "StackWalk Found %s\n", pName));
#endif

    RETURN((pAssem->GetExposedObject()), OBJECTREF);
}

UINT64 __stdcall COMIsolatedStorageFile::GetUsage(_GetUsage* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr      = S_OK;
    UINT64  qwUsage = 0;
    AccountingInfo  *pAI; 

    pAI = (AccountingInfo*) pArgs->handle;

    if (pAI == NULL)
        COMIsolatedStorage::ThrowISS(ISS_E_STORE_NOT_OPEN);

    hr = pAI->GetUsage(&qwUsage);

    if (FAILED(hr))
        COMIsolatedStorage::ThrowISS(hr);

    return qwUsage;
}

void __stdcall COMIsolatedStorageFile::Close(_Close* pArgs)
{
    AccountingInfo *pAI;

    pAI = (AccountingInfo*) pArgs->handle;

    if (pAI != NULL)
        delete pAI;
}

void __stdcall COMIsolatedStorageFile::Lock(_Lock* pArgs)
{
    AccountingInfo *pAI;

    pAI = (AccountingInfo*) pArgs->handle;

    _ASSERTE(pAI);

    if (pArgs->fLock)
        pAI->Lock();
    else
        pAI->Unlock();
}

LPVOID __stdcall COMIsolatedStorageFile::Open(_Open* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr;
    AccountingInfo *pAI;

    pAI = new AccountingInfo(pArgs->fileName->GetBuffer(), 
                pArgs->syncName->GetBuffer());

    if (pAI == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pAI->Init();

Exit:

    if (FAILED(hr))
        COMIsolatedStorage::ThrowISS(hr);

    return pAI;
}

void __stdcall COMIsolatedStorageFile::Reserve(_Reserve* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr;
    AccountingInfo  *pAI;

    pAI = (AccountingInfo*) pArgs->handle;

    if (pAI == NULL)
        COMIsolatedStorage::ThrowISS(ISS_E_STORE_NOT_OPEN);

    hr = pAI->Reserve(*(pArgs->pqwQuota), *(pArgs->pqwReserve), pArgs->fFree);

    if (FAILED(hr))
    {
#ifdef _DEBUG
        if (pArgs->fFree) {
            LOG((LF_STORE, LL_INFO10000, "free 0x%x failed\n", 
                (long)(*(pArgs->pqwReserve))));
        } else {
            LOG((LF_STORE, LL_INFO10000, "reserve 0x%x failed\n", 
                (long)(*(pArgs->pqwReserve))));
        }
#endif
        COMIsolatedStorage::ThrowISS(hr);
    }

#ifdef _DEBUG
    if (pArgs->fFree) {
        LOG((LF_STORE, LL_INFO10000, "free 0x%x\n", 
            (long)(*(pArgs->pqwReserve))));
    } else {
        LOG((LF_STORE, LL_INFO10000, "reserve 0x%x\n", 
            (long)(*(pArgs->pqwReserve))));
    }
#endif
}

LPVOID __stdcall COMIsolatedStorageFile::GetRootDir(_GetRootDir* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    WCHAR path[MAX_PATH + 1];

    _ASSERTE((pArgs->dwFlags & ISS_MACHINE_STORE) == 0);

    GetRootDirInternal(pArgs->dwFlags, path, MAX_PATH + 1);

    STRINGREF sref = NULL;

    sref = COMString::NewString(path);

    RETURN(sref, STRINGREF);
}

// Throws on error
void COMIsolatedStorageFile::CreateDirectoryIfNotPresent(WCHAR *path)
{
    THROWSCOMPLUSEXCEPTION();

    LONG  lresult;

    // Check if the directory is already present
    lresult = WszGetFileAttributes(path);

    if (lresult == -1)
    {
        if (!WszCreateDirectory(path, NULL) &&
            !(WszGetFileAttributes(path) & FILE_ATTRIBUTE_DIRECTORY))
            COMPlusThrowWin32();
    }
    else if ((lresult & FILE_ATTRIBUTE_DIRECTORY) == 0)
    {
        COMIsolatedStorage::ThrowISS(ISS_E_CREATE_DIR);
    }
}

// Synchronized by the managed caller
const WCHAR* g_relativePath[] = {
    L"\\IsolatedStorage"
};

#define nRelativePathLen       (  \
    sizeof("\\IsolatedStorage") + 1)

#define nSubDirs (sizeof(g_relativePath)/sizeof(g_relativePath[0]))

void COMIsolatedStorageFile::GetRootDirInternal(
        DWORD dwFlags, WCHAR *path, DWORD cPath)
{
    _ASSERTE((dwFlags & ISS_MACHINE_STORE) == 0);

    THROWSCOMPLUSEXCEPTION();

    ULONG len;

    _ASSERTE(cPath > 1);
    _ASSERTE(cPath <= MAX_PATH + 1);

    --cPath;    // To be safe.
    path[cPath] = 0;

    // Get roaming or local App Data locations
    if (!GetUserDir(path, cPath, IS_ROAMING(dwFlags))) 
        COMIsolatedStorage::ThrowISS(ISS_E_CREATE_DIR);

    len = (ULONG)wcslen(path);

    if ((len + nRelativePathLen + 1) > cPath)
        COMIsolatedStorage::ThrowISS(ISS_E_PATH_LENGTH);

    CreateDirectoryIfNotPresent(path);

    // Create the store directory if necessary
    for (int i=0; i<nSubDirs; ++i)
    {
        wcscat(path, g_relativePath[i]);
        CreateDirectoryIfNotPresent(path);
    }

    wcscat(path, L"\\");
}

#ifndef UNDER_CE

static BOOL IsWin2K() 
{
    if (GetVersion() >= 0x80000000)
        return FALSE;

    OSVERSIONINFOEX osvi;
    BOOL bOsVersionInfoEx;
    
    // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
    // which is supported on Windows 2000.
    //
    // If that fails, try using the OSVERSIONINFO structure.
    
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    
    if ((bOsVersionInfoEx = WszGetVersionEx((OSVERSIONINFO *) &osvi)) == FALSE)
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
        
        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (!WszGetVersionEx((OSVERSIONINFO *) &osvi)) 
            return FALSE;  // This will work on W2K.
    }

    return ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (osvi.dwMajorVersion >= 5));
}

static BOOL NeedGlobalObject()
{
    // Make a Call only once per process.

    static BOOL fInited = FALSE;
    static fIsTermServicesInstalled;

    if (!fInited)
    {
        fIsTermServicesInstalled =  IsWin2K();
        fInited = TRUE;
    }
         /* && IsTerminalServicesInstalled()); */ 

    return fIsTermServicesInstalled;
}

/* 
static BOOL IsTerminalServicesInstalled()
{
    _ASSERTE(IsWin2K());

    OSVERSIONINFOEX osvi;
    DWORDLONG dwlConditionMask = 0;
    
    // Initialize the OSVERSIONINFOEX structure.
    
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.wSuiteMask = VER_SUITE_TERMINAL;
    
    // Initialize the condition mask.
    
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_AND);
    
    // Perform the test.
    // This API is available only on W2K !
    return VerifyVersionInfo(&osvi, VER_SUITENAME, dwlConditionMask);
}
*/
#else
#define NeedGlobalObject() FALSE
#endif // UNDER_CE

#define SZ_GLOBAL "Global\\"
#define WSZ_GLOBAL L"Global\\"

#define SIGNIFICANT_CHARS 80

//--------------------------------------------------------------------------
// The file name is used to open / create the file.
// A synchronization object will also be created using this name
// with '\' replaced by '-'
//--------------------------------------------------------------------------
AccountingInfo::AccountingInfo(WCHAR *wszFileName, WCHAR *wszSyncName) :
        m_hFile(INVALID_HANDLE_VALUE),
        m_hMapping(NULL),
        m_hLock(NULL),
        m_pData(NULL)
{
#ifdef _DEBUG
    m_dwNumLocks = 0;
#endif

    static WCHAR* g_wszGlobal = WSZ_GLOBAL;

    int buffLen;
    BOOL fGlobal;

    buffLen = (int)wcslen(wszFileName) + 1;

    m_wszFileName = new WCHAR[buffLen];

    if (m_wszFileName == NULL)
    {
        m_wszName = NULL;
        return; // In the Init method, check for NULL, to detect failure
    }

    // String length is known, using a memcpy here is faster, however, this 
    // makes the code here and below less readable, this is not a very frequent 
    // operation. No real perf gain here. Same comment applies to the strcpy
    // following this.

    wcscpy(m_wszFileName, wszFileName);

    _ASSERTE(((int)wcslen(m_wszFileName) + 1) <= buffLen);

    // Allocate the Mutex name
    buffLen = (int)wcslen(wszSyncName) + 1;

    // Use "Global\" prefix for Win2K server running Terminal Server.
    // If TermServer is not running, the Global\ prefix is ignored.

    fGlobal = NeedGlobalObject();

    if (fGlobal)
        buffLen += sizeof(SZ_GLOBAL);

    m_wszName = new WCHAR[buffLen];

    if (m_wszName == NULL)
    {
        delete [] m_wszFileName;
        m_wszFileName = NULL;
        return; // The Init() method will catch this failure.
    }

    if (fGlobal)
    {
        wcscpy(m_wszName, g_wszGlobal);
        wcscat(m_wszName, wszSyncName);
    }
    else
    {
        wcscpy(m_wszName, wszSyncName);
    }

    _ASSERTE(((int)wcslen(m_wszName) + 1) <= buffLen);
}

//--------------------------------------------------------------------------
// Frees memory, and open handles
//--------------------------------------------------------------------------
AccountingInfo::~AccountingInfo()
{
    if (m_pData)
        UnmapViewOfFile(m_pData);

    if (m_hMapping != NULL)
        CloseHandle(m_hMapping);

    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    if (m_hLock != NULL)
        CloseHandle(m_hLock);

    if (m_wszFileName)
        delete [] m_wszFileName;

    if (m_wszName)
        delete [] m_wszName;

    _ASSERTE(m_dwNumLocks == 0);
}

//--------------------------------------------------------------------------
// Init should be called before Reserve / GetUsage is called.
// Creates the file if necessary
//--------------------------------------------------------------------------
HRESULT AccountingInfo::Init()            
{
    // Check if the ctor failed

    if (m_wszFileName == NULL)
        return E_OUTOFMEMORY;

    // Init was called multiple times on this object without calling Close

    _ASSERTE(m_hLock == NULL);

    // Create the synchronization object

    m_hLock = WszCreateMutex(NULL, FALSE /* Initially not owned */, m_wszName);

    if (m_hLock == NULL)
        return ISS_E_CREATE_MUTEX;

    // Init was called multiple times on this object without calling Close

    _ASSERTE(m_hFile == INVALID_HANDLE_VALUE);

    // Create the File if not present

    m_hFile = WszCreateFile(
        m_wszFileName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (m_hFile == INVALID_HANDLE_VALUE)
        return ISS_E_OPEN_STORE_FILE;

    // If this file was created for the first time, then create the accounting
    // record and set to zero
    HRESULT hr = S_OK;

    LOCK(this)
    {
        DWORD   dwLow = 0, dwHigh = 0;    // For checking file size
        QWORD   qwSize;
    
        dwLow = ::GetFileSize(m_hFile, &dwHigh);
    
        if ((dwLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
        {
            hr = ISS_E_GET_FILE_SIZE;
            goto Exit;
        }
    
        qwSize = ((QWORD)dwHigh << 32) | dwLow;
    
        if (qwSize < sizeof(ISS_RECORD)) 
        {
            PBYTE pb;
            DWORD dwWrite;
    
            // Need to create the initial file
            pb = new BYTE[sizeof(ISS_RECORD)];
    
            if (pb == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
    
            memset(pb, 0, sizeof(ISS_RECORD));
    
            dwWrite = 0;
    
            if ((WriteFile(m_hFile, pb, sizeof(ISS_RECORD), &dwWrite, NULL)
                == 0) || (dwWrite != sizeof(ISS_RECORD)))
            {
                hr = ISS_E_FILE_WRITE;
            }
    
            delete [] pb;
        }
    }
Exit:;
    UNLOCK(this)

    return hr;
}

//--------------------------------------------------------------------------
// Reserves space (Increments qwQuota)
// This method is synchrinized. If quota + request > limit, method fails
//--------------------------------------------------------------------------
HRESULT AccountingInfo::Reserve(
            ISS_USAGE   cLimit,     // The max allowed
            ISS_USAGE   cRequest,   // amount of space (request / free)
            BOOL        fFree)      // TRUE will free, FALSE will reserve
{
    HRESULT hr = S_OK;

    LOCK(this)
    {
        hr = Map();
    
        if (FAILED(hr))
            goto Exit;

        if (fFree)
        {
            if (m_pISSRecord->cUsage > cRequest)
                m_pISSRecord->cUsage -= cRequest;
            else
                m_pISSRecord->cUsage = 0;
    }
    else
    {
            if ((m_pISSRecord->cUsage + cRequest) > cLimit)
                hr = ISS_E_USAGE_WILL_EXCEED_QUOTA;
            else
                // Safe to increment quota.
                m_pISSRecord->cUsage += cRequest;
        }

        Unmap();
    }
Exit:;
    UNLOCK(this)

    return hr;
}

//--------------------------------------------------------------------------
// Method is not synchronized. So the information may not be current.
// This implies "Pass if (Request + GetUsage() < Limit)" is an Error!
// Use Reserve() method instead.
//--------------------------------------------------------------------------
HRESULT AccountingInfo::GetUsage(ISS_USAGE *pcUsage)  // pcUsage - [out] 
{
    HRESULT hr = S_OK;

    LOCK(this)
    {
        hr = Map();

        if (FAILED(hr))
            goto Exit;

        *pcUsage = m_pISSRecord->cUsage;

        Unmap();
    }
Exit:;
    UNLOCK(this)

    return hr;
}

//--------------------------------------------------------------------------
// Maps the store file into memory
//--------------------------------------------------------------------------
HRESULT AccountingInfo::Map()
{
    // Mapping will fail if filesize is 0
    if (m_hMapping == NULL)
    {
        m_hMapping = WszCreateFileMapping(
            m_hFile,
            NULL,
            PAGE_READWRITE,
            0,
            0,
            NULL);

        if (m_hMapping == NULL)
            return ISS_E_OPEN_FILE_MAPPING;
    }

    _ASSERTE(m_pData == NULL);

    m_pData = (PBYTE) MapViewOfFile(
        m_hMapping,
        FILE_MAP_WRITE,
        0,
        0,
        0);

    if (m_pData == NULL)
        return ISS_E_MAP_VIEW_OF_FILE;

    return S_OK;
}

//--------------------------------------------------------------------------
// Unmaps the store file from memory
//--------------------------------------------------------------------------
void AccountingInfo::Unmap()
{
    if (m_pData)
    {
        UnmapViewOfFile(m_pData);
        m_pData = NULL;
    }
}

//--------------------------------------------------------------------------
// Close the store file, and file mapping
//--------------------------------------------------------------------------
void AccountingInfo::Close()
{
    Unmap();

    if (m_hMapping != NULL)
{
        CloseHandle(m_hMapping);
        m_hMapping = NULL;
    }

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }

    if (m_hLock != NULL)
    {
        CloseHandle(m_hLock);
        m_hLock = NULL;
    }

#ifdef _DEBUG
    _ASSERTE(m_dwNumLocks == 0);
#endif
    }

//--------------------------------------------------------------------------
// Machine wide Lock
//--------------------------------------------------------------------------
HRESULT AccountingInfo::Lock()
{
    // Lock is intented to be used for inter process/thread synchronization.

#ifdef _DEBUG
    _ASSERTE(m_hLock);

    LOG((LF_STORE, LL_INFO10000, "Lock %S, thread 0x%x start..\n", 
            m_wszName, GetCurrentThreadId()));
#endif

    DWORD dwRet;
    BEGIN_ENSURE_PREEMPTIVE_GC();
    dwRet = WaitForSingleObject(m_hLock, INFINITE);
    END_ENSURE_PREEMPTIVE_GC();

#ifdef _DEBUG
    InterlockedIncrement((LPLONG)&m_dwNumLocks);

    switch (dwRet)
    {
    case WAIT_OBJECT_0:
        LOG((LF_STORE, LL_INFO10000, "Loc %S, thread 0x%x - WAIT_OBJECT_0\n", 
            m_wszName, GetCurrentThreadId()));
        break;

    case WAIT_ABANDONED:
        LOG((LF_STORE, LL_INFO10000, "Loc %S, thread 0x%x - WAIT_ABANDONED\n", 
            m_wszName, GetCurrentThreadId()));
        break;

    case WAIT_FAILED:
        LOG((LF_STORE, LL_INFO10000, "Loc %S, thread 0x%x - WAIT_FAILED\n", 
            m_wszName, GetCurrentThreadId()));
        break;

    case WAIT_TIMEOUT:
        LOG((LF_STORE, LL_INFO10000, "Loc %S, thread 0x%x - WAIT_TIMEOUT\n", 
            m_wszName, GetCurrentThreadId()));
        break;

    default:
        LOG((LF_STORE, LL_INFO10000, "Loc %S, thread 0x%x - 0x%x\n", 
            m_wszName, GetCurrentThreadId(), dwRet));
        break;
    }

#endif

    if ((dwRet == WAIT_OBJECT_0) || (dwRet == WAIT_ABANDONED))
        return S_OK;

    return ISS_E_LOCK_FAILED;
}

//--------------------------------------------------------------------------
// Unlock the store
//--------------------------------------------------------------------------
void AccountingInfo::Unlock()
{
#ifdef _DEBUG
    _ASSERTE(m_hLock);
    _ASSERTE(m_dwNumLocks >= 1);

    LOG((LF_STORE, LL_INFO10000, "UnLoc %S, thread 0x%x\n", 
        m_wszName, GetCurrentThreadId()));
#endif
    
    ReleaseMutex(m_hLock);

#ifdef _DEBUG
    InterlockedDecrement((LPLONG)&m_dwNumLocks);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commodule.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "COMClass.h"
#include "COMModule.h"
#include "COMMember.h"
#include "COMDynamic.h"
#include "COMClass.h"
#include "ReflectClassWriter.h"
#include "class.h"
#include "corpolicy.h"
#include "security.h"
#include "gcscan.h"
#include "CeeSectionString.h"
#include "COMVariant.h"
#include <cor.h>
#include "ReflectUtil.h"

#define STATE_EMPTY 0
#define STATE_ARRAY 1

//SIG_* are defined in DescriptorInfo.cool and must be kept in sync.
#define SIG_BYREF        0x0001
#define SIG_DEFAULTVALUE 0x0002
#define SIG_IN           0x0004
#define SIG_INOUT        0x0008
#define SIG_STANDARD     0x0001
#define SIG_VARARGS      0x0002

// This function will help clean up after a ISymUnmanagedWriter (if it can't
// clean up on it's own
void CleanUpAfterISymUnmanagedWriter(void * data)
{
    CGrowableStream * s = (CGrowableStream*)data;
    s->Release();
}// CleanUpAfterISymUnmanagedWriter
    

inline Module *COMModule::ValidateThisRef(REFLECTMODULEBASEREF pThis)
{
    THROWSCOMPLUSEXCEPTION();

    if (pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Module* pModule = (Module*) pThis->GetData();
    _ASSERTE(pModule);  
    return pModule;
}    

//****************************************
// This function creates a dynamic module underneath the current assembly.
//****************************************
LPVOID __stdcall COMModule::DefineDynamicModule(_DefineDynamicModuleArgs* args)
{
    THROWSCOMPLUSEXCEPTION();   

    Assembly        *pAssembly;
    LPVOID          rv; 
    InMemoryModule *mod;
    OBJECTREF       refModule;

    _ASSERTE(args->containingAssembly);
    pAssembly = args->containingAssembly->GetAssembly();
    _ASSERTE(pAssembly);

    // We should never get a dynamic module for the system domain
    _ASSERTE(pAssembly->Parent() != SystemDomain::System());

    // always create a dynamic module. Note that the name conflict
    // checking is done in managed side.
    mod = COMDynamicWrite::CreateDynamicModule(pAssembly,
                                               args->filename);

    mod->SetCreatingAssembly( SystemDomain::GetCallersAssembly( args->stackMark ) );

    // get the corresponding managed ModuleBuilder class
    refModule = (OBJECTREF) mod->GetExposedModuleBuilderObject();  
    _ASSERTE(refModule);    

    // If we need to emit symbol info, we setup the proper symbol
    // writer for this module now.
    if (args->emitSymbolInfo)
    {
        WCHAR *filename = NULL;
        
        if ((args->filename != NULL) &&
            (args->filename->GetStringLength() > 0))
            filename = args->filename->GetBuffer();
        
        _ASSERTE(mod->IsReflection());
        ReflectionModule *rm = mod->GetReflectionModule();
        
        // Create a stream for the symbols to be emitted into. This
        // lives on the Module for the life of the Module.
        CGrowableStream *pStream = new CGrowableStream();
        //pStream->AddRef(); // The Module will keep a copy for it's own use.
        mod->SetInMemorySymbolStream(pStream);

        // Create an ISymUnmanagedWriter and initialize it with the
        // stream and the proper file name. This symbol writer will be
        // replaced with new ones periodically as the symbols get
        // retrieved by the debugger.
        ISymUnmanagedWriter *pWriter;
        
        HRESULT hr = FakeCoCreateInstance(CLSID_CorSymWriter_SxS,
                                          IID_ISymUnmanagedWriter,
                                          (void**)&pWriter);
        if (SUCCEEDED(hr))
        {
            // The other reference is given to the Sym Writer
            // But, the writer takes it's own reference.
            hr = pWriter->Initialize(mod->GetEmitter(),
                                     filename,
                                     (IStream*)pStream,
                                     TRUE);

            if (SUCCEEDED(hr))
            {
                // Send along some cleanup information
                HelpForInterfaceCleanup *hlp = new HelpForInterfaceCleanup;
                hlp->pData = pStream;
                hlp->pFunction = CleanUpAfterISymUnmanagedWriter;
            
                rm->SetISymUnmanagedWriter(pWriter, hlp);

                // Remember the address of where we've got our
                // ISymUnmanagedWriter stored so we can pass it over
                // to the managed symbol writer object that most of
                // reflection emit will use to write symbols.
                REFLECTMODULEBASEREF ro = (REFLECTMODULEBASEREF)refModule;
                ro->SetInternalSymWriter(rm->GetISymUnmanagedWriterAddr());
            }
        }
        else
        {
            COMPlusThrowHR(hr);
        }
    }
    
    // Assign the return value  
    *((OBJECTREF*) &rv) = refModule;    

    // Return the object    
    return rv;  
}


// IsDynamic
// This method will return a boolean value indicating if the Module
//  supports Dynamic IL.    
INT32 __stdcall COMModule::IsDynamic(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    return (pModule->IsReflection()) ? 1 : 0;  
}

// GetCaller
LPVOID __stdcall COMModule::GetCaller(_GetCallerArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
    
    LPVOID      rv = NULL;

    // Assign the return value

    Module* pModule = SystemDomain::GetCallersModule(args->stackMark);
    if(pModule != NULL) {
        OBJECTREF refModule = (OBJECTREF) pModule->GetExposedModuleObject();
        *((OBJECTREF*) &rv) = refModule;
    }
    // Return the object
    return rv;
}


//**************************************************
// LoadInMemoryTypeByName
// Explicitly loading an in memory type
// @todo: this function is not dealing with nested type correctly yet.
// We will need to parse the full name by finding "+" for enclosing type, etc.
//**************************************************
LPVOID __stdcall COMModule::LoadInMemoryTypeByName(_LoadInMemoryTypeByNameArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF       Throwable = NULL;
    OBJECTREF       ret = NULL;
    TypeHandle      typeHnd;
    UINT            resId = IDS_CLASSLOAD_GENERIC;
    IMetaDataImport *pImport = NULL;
    Module          *pThisModule = NULL;
    RefClassWriter  *pRCW;
    mdTypeDef       td;
    LPCWSTR         wzFullName;
    HRESULT         hr = S_OK;
    
    GCPROTECT_BEGIN(Throwable);

    Module* pThisModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (!pThisModule->IsReflection())
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");

    pRCW = ((ReflectionModule*) pThisModule)->GetClassWriter();
    _ASSERTE(pRCW);

    // it is ok to use public import API because this is a dynamic module anyway. We are also receiving Unicode full name as
    // parameter.
    pImport = pRCW->GetImporter();

    wzFullName = args->strFullName->GetBuffer();
    if (wzFullName == NULL)
        IfFailGo( E_FAIL );

    // look up the handle
    IfFailGo( pImport->FindTypeDefByName(wzFullName, mdTokenNil, &td) );     

    BEGIN_ENSURE_PREEMPTIVE_GC();
    typeHnd = pThisModule->GetClassLoader()->LoadTypeHandle(pThisModule, td, &Throwable);
    END_ENSURE_PREEMPTIVE_GC();

    if (typeHnd.IsNull() ||
        (Throwable != NULL) ||
        (typeHnd.GetModule() != pThisModule))
        goto ErrExit;
    ret = typeHnd.CreateClassObj();
ErrExit:
    if (FAILED(hr) && (hr != CLDB_E_RECORD_NOTFOUND))
        COMPlusThrowHR(hr);

    if (ret == NULL) 
    {
        if (Throwable == NULL)
        {
            CQuickBytes bytes;
            LPSTR szClassName;
            DWORD cClassName;

            // Get the UTF8 version of args->refClassName
            szClassName = GetClassStringVars((STRINGREF) args->strFullName, &bytes, 
                                             &cClassName, true);
            pThisModule->GetAssembly()->PostTypeLoadException(szClassName, resId, &Throwable);
        }
        COMPlusThrow(Throwable);
    }

    GCPROTECT_END();
    return OBJECTREFToObject(ret);

}

//**************************************************
// GetClassToken
// This function will return the type token given full qual name. If the type
// is defined locally, we will return the TypeDef token. Or we will return a TypeRef token 
// with proper resolution scope calculated.
//**************************************************
mdTypeRef __stdcall COMModule::GetClassToken(_GetClassTokenArgs* args) 
{
    THROWSCOMPLUSEXCEPTION();

    RefClassWriter      *pRCW;
    mdTypeRef           tr = 0;
    HRESULT             hr;
    mdToken             tkResolution = mdTokenNil;
    Module              *pRefedModule;
    Assembly            *pThisAssembly;
    Assembly            *pRefedAssembly;
    IMetaDataEmit       *pEmit;
    IMetaDataImport     *pImport;
    IMetaDataAssemblyEmit *pAssemblyEmit = NULL;

    Module* pThisModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (!pThisModule->IsReflection())
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");

    pRCW = ((ReflectionModule*) pThisModule)->GetClassWriter();
    _ASSERTE(pRCW);

    pEmit = pRCW->GetEmitter(); 
    pImport = pRCW->GetImporter();

    if (args->strFullName == NULL) {
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
    }    

    _ASSERTE(args->refedModule);

    pRefedModule = (Module*) args->refedModule->GetData();
    _ASSERTE(pRefedModule);

    pThisAssembly = pThisModule->GetClassLoader()->GetAssembly();
    pRefedAssembly = pRefedModule->GetClassLoader()->GetAssembly();
    if (pThisModule == pRefedModule)
    {
        // referenced type is from the same module so we must be able to find a TypeDef.
        hr = pImport->FindTypeDefByName(
            args->strFullName->GetBuffer(),       
            RidFromToken(args->tkResolution) ? args->tkResolution : mdTypeDefNil,  
            &tr); 

        // We should not fail in find the TypeDef. If we do, something is wrong in our managed code.
        _ASSERTE(SUCCEEDED(hr));
        goto ErrExit;
    }

    if (RidFromToken(args->tkResolution))
    {
        // reference to nested type
        tkResolution = args->tkResolution;
    }
    else
    {
        // reference to top level type
        if ( pThisAssembly != pRefedAssembly )
        {
            // Generate AssemblyRef
            IfFailGo( pEmit->QueryInterface(IID_IMetaDataAssemblyEmit, (void **) &pAssemblyEmit) );
            tkResolution = pThisAssembly->AddAssemblyRef(pRefedAssembly, pAssemblyEmit);

            // Don't cache the assembly if it's Save-only
            if( pRefedAssembly->HasRunAccess() &&
                !pThisModule->StoreAssemblyRef(tkResolution, pRefedAssembly) )
            {
                IfFailGo(E_OUTOFMEMORY);
            }
        }
        else
        {
            _ASSERTE(pThisModule != pRefedModule);
            // Generate ModuleRef
            if (args->strRefedModuleFileName != NULL)
            {
                IfFailGo(pEmit->DefineModuleRef(args->strRefedModuleFileName->GetBuffer(), &tkResolution));
            }
            else
            {
                _ASSERTE(!"E_NYI!");
                COMPlusThrow(kInvalidOperationException, L"InvalidOperation_MetaDataError");    
            }
        }
    }

    IfFailGo( pEmit->DefineTypeRefByName(tkResolution, args->strFullName->GetBuffer(), &tr) );  
ErrExit:
    if (pAssemblyEmit)
        pAssemblyEmit->Release();
    if (FAILED(hr))
    {
        // failed in defining PInvokeMethod
        if (hr == E_OUTOFMEMORY)
            COMPlusThrowOM();
        else
            COMPlusThrowHR(hr);    
    }
    return tr;
}


/*=============================GetArrayMethodToken==============================
**Action:
**Returns:
**Arguments: REFLECTMODULEBASEREF refThis
**           U1ARRAYREF     sig
**           STRINGREF      methodName
**           int            tkTypeSpec
**Exceptions:
==============================================================================*/
void __stdcall COMModule::GetArrayMethodToken(_getArrayMethodTokenArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    RefClassWriter* pRCW;   
    PCCOR_SIGNATURE pvSig;
    LPCWSTR         methName;
    mdMemberRef memberRefE; 
    HRESULT hr;

    if (!args->methodName)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
    if (!args->tkTypeSpec) 
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Type");

    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    //Get the signature.  Because we generated it with a call to GetSignature, it's already in the current scope.
    pvSig = (PCCOR_SIGNATURE)args->signature->GetDataPtr();
    
    methName = args->methodName->GetBuffer();

    hr = pRCW->GetEmitter()->DefineMemberRef(args->tkTypeSpec, methName, pvSig, args->sigLength, &memberRefE); 
    if (FAILED(hr)) 
    {
        _ASSERTE(!"Failed on DefineMemberRef");
        COMPlusThrowHR(hr);    
    }
    *(args->retRef)=(INT32)memberRefE;
}


//******************************************************************************
//
// GetMemberRefToken
// This function will return a MemberRef token given a MethodDef token and the module where the MethodDef/FieldDef is defined.
//
//******************************************************************************
INT32 __stdcall COMModule::GetMemberRefToken(_GetMemberRefTokenArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr; 
    RefClassWriter  *pRCW;   
    WCHAR           *szName; 
    ULONG           nameSize;    
    ULONG           actNameSize = 0;    
    ULONG           cbComSig;   
    PCCOR_SIGNATURE pvComSig;
    mdMemberRef     memberRefE = 0; 
    CQuickBytes     qbNewSig; 
    ULONG           cbNewSig;   
    LPCUTF8         szNameTmp;
    Module          *pRefedModule;
    CQuickBytes     qbName;
    Assembly        *pRefedAssembly;
    Assembly        *pRefingAssembly;
    IMetaDataAssemblyEmit *pAssemblyEmit = NULL;
    mdTypeRef       tr;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE( pRCW ); 

    pRefedModule = (Module *) args->refedModule->GetData();
    _ASSERTE( pRefedModule );
    
    if (TypeFromToken(args->token) == mdtMethodDef)
    {
        szNameTmp = pRefedModule->GetMDImport()->GetNameOfMethodDef(args->token);
        pvComSig = pRefedModule->GetMDImport()->GetSigOfMethodDef(
            args->token,
            &cbComSig);
    }
    else
    {
        szNameTmp = pRefedModule->GetMDImport()->GetNameOfFieldDef(args->token);
        pvComSig = pRefedModule->GetMDImport()->GetSigOfFieldDef(
            args->token,
            &cbComSig);
    }

    // translate the name to unicode string
    nameSize = (ULONG)strlen(szNameTmp);
    IfFailGo( qbName.ReSize((nameSize + 1) * sizeof(WCHAR)) );
    szName = (WCHAR *) qbName.Ptr();
    actNameSize = ::WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szNameTmp, -1, szName, nameSize + 1);

    // The unicode translation function cannot fail!!
    if(actNameSize==0)
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    // Translate the method sig into this scope 
    //
    pRefedAssembly = pRefedModule->GetAssembly();
    pRefingAssembly = pModule->GetAssembly();
    IfFailGo( pRefingAssembly->GetSecurityModule()->GetEmitter()->QueryInterface(IID_IMetaDataAssemblyEmit, (void **) &pAssemblyEmit) );

    IfFailGo( pRefedModule->GetMDImport()->TranslateSigWithScope(
        pRefedAssembly->GetManifestImport(), 
        NULL, 0,        // hash value
        pvComSig, 
        cbComSig, 
        pAssemblyEmit,  // Emit assembly scope.
        pRCW->GetEmitter(), 
        &qbNewSig, 
        &cbNewSig) );  

    if (TypeFromToken(args->tr) == mdtTypeDef)
    {
        // define a TypeRef using the TypeDef
        IfFailGo(DefineTypeRefHelper(pRCW->GetEmitter(), args->tr, &tr));
    }
    else 
        tr = args->tr;

    // Define the memberRef
    IfFailGo( pRCW->GetEmitter()->DefineMemberRef(tr, szName, (PCCOR_SIGNATURE) qbNewSig.Ptr(), cbNewSig, &memberRefE) ); 

ErrExit:
    if (pAssemblyEmit)
        pAssemblyEmit->Release();

    if (FAILED(hr))
    {
        _ASSERTE(!"GetMemberRefToken failed!"); 
        COMPlusThrowHR(hr);    
    }
    // assign output parameter
    return (INT32)memberRefE;
}


//******************************************************************************
//
// Return a TypeRef token given a TypeDef token from the same emit scope
//
//******************************************************************************
HRESULT COMModule::DefineTypeRefHelper(
    IMetaDataEmit       *pEmit,         // given emit scope
    mdTypeDef           td,             // given typedef in the emit scope
    mdTypeRef           *ptr)           // return typeref
{
    IMetaDataImport     *pImport = NULL;
    WCHAR               szTypeDef[MAX_CLASSNAME_LENGTH + 1];
    mdToken             rs;             // resolution scope
    DWORD               dwFlags;
    HRESULT             hr;

    IfFailGo( pEmit->QueryInterface(IID_IMetaDataImport, (void **)&pImport) );
    IfFailGo( pImport->GetTypeDefProps(td, szTypeDef, MAX_CLASSNAME_LENGTH, NULL, &dwFlags, NULL) );
    if ( IsTdNested(dwFlags) )
    {
        mdToken         tdNested;
        IfFailGo( pImport->GetNestedClassProps(td, &tdNested) );
        IfFailGo( DefineTypeRefHelper( pEmit, tdNested, &rs) );
    }
    else
        rs = TokenFromRid( 1, mdtModule );

    IfFailGo( pEmit->DefineTypeRefByName( rs, szTypeDef, ptr) );

ErrExit:
    if (pImport)
        pImport->Release();
    return hr;
}   // DefineTypeRefHelper


//******************************************************************************
//
// Return a MemberRef token given a RuntimeMethodInfo
//
//******************************************************************************
INT32 __stdcall COMModule::GetMemberRefTokenOfMethodInfo(_GetMemberRefTokenOfMethodInfoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr; 
    RefClassWriter  *pRCW;   
    ReflectMethod   *pRM;    
    MethodDesc      *pMeth;  
    WCHAR           *szName; 
    ULONG           nameSize;    
    ULONG           actNameSize = 0;    
    ULONG           cbComSig;   
    PCCOR_SIGNATURE pvComSig;
    mdMemberRef     memberRefE = 0; 
    CQuickBytes     qbNewSig; 
    ULONG           cbNewSig;   
    LPCUTF8         szNameTmp;
    CQuickBytes     qbName;
    Assembly        *pRefedAssembly;
    Assembly        *pRefingAssembly;
    IMetaDataAssemblyEmit *pAssemblyEmit = NULL;

    if (!args->method)  
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    // refing module
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    pRM = (ReflectMethod*) args->method->GetData(); 
    _ASSERTE(pRM);  
    pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    // Otherwise, we want to return memberref token.
    if (pMeth->IsArray())
    {    
        _ASSERTE(!"Should not have come here!");
        COMPlusThrow(kNotSupportedException);    
    }
    if (pMeth->GetClass())
    {
        if (pMeth->GetClass()->GetModule() == pModule)
        {
            // If the passed in method is defined in the same module, just return the MethodDef token           
            return (INT32)pMeth->GetMemberDef();
        }
    }

    szNameTmp = pMeth->GetMDImport()->GetNameOfMethodDef(pMeth->GetMemberDef());
    pvComSig = pMeth->GetMDImport()->GetSigOfMethodDef(
        pMeth->GetMemberDef(),
        &cbComSig);

    // Translate the method sig into this scope 
    pRefedAssembly = pMeth->GetModule()->GetAssembly();
    pRefingAssembly = pModule->GetAssembly();
    IfFailGo( pRefingAssembly->GetSecurityModule()->GetEmitter()->QueryInterface(IID_IMetaDataAssemblyEmit, (void **) &pAssemblyEmit) );

    IfFailGo( pMeth->GetMDImport()->TranslateSigWithScope(
        pRefedAssembly->GetManifestImport(), 
        NULL, 0,        // hash blob value
        pvComSig, 
        cbComSig, 
        pAssemblyEmit,  // Emit assembly scope.
        pRCW->GetEmitter(), 
        &qbNewSig, 
        &cbNewSig) );  

    // translate the name to unicode string
    nameSize = (ULONG)strlen(szNameTmp);
    IfFailGo( qbName.ReSize((nameSize + 1) * sizeof(WCHAR)) );
    szName = (WCHAR *) qbName.Ptr();
    actNameSize = ::WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szNameTmp, -1, szName, nameSize + 1);

    // The unicode translation function cannot fail!!
    if(actNameSize==0)
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    // Define the memberRef
    IfFailGo( pRCW->GetEmitter()->DefineMemberRef(args->tr, szName, (PCCOR_SIGNATURE) qbNewSig.Ptr(), cbNewSig, &memberRefE) ); 

ErrExit:
    if (pAssemblyEmit)
        pAssemblyEmit->Release();

    if (FAILED(hr))
    {
        _ASSERTE(!"GetMemberRefTokenOfMethodInfo Failed!"); 
        COMPlusThrowHR(hr);    
    }

    // assign output parameter
    return (INT32)memberRefE;

}


//******************************************************************************
//
// Return a MemberRef token given a RuntimeFieldInfo
//
//******************************************************************************
mdMemberRef __stdcall COMModule::GetMemberRefTokenOfFieldInfo(_GetMemberRefTokenOfFieldInfoArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr; 
    WCHAR           *szName; 
    ULONG           nameSize;    
    FieldDesc       *pField;
    RefClassWriter* pRCW;   
    ULONG           actNameSize = 0;    
    ULONG           cbComSig;   
    PCCOR_SIGNATURE pvComSig;
    mdMemberRef     memberRefE = 0; 
    LPCUTF8         szNameTmp;
    CQuickBytes     qbNewSig;
    ULONG           cbNewSig;   
    CQuickBytes     qbName;
    Assembly        *pRefedAssembly;
    Assembly        *pRefingAssembly;
    IMetaDataAssemblyEmit *pAssemblyEmit = NULL;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);
    ReflectField* pRF = (ReflectField*) args->field->GetData();
    pField = pRF->pField; 
    _ASSERTE(pField);

    if (TypeFromToken(args->tr) == mdtTypeDef)
    {
        // If the passed in method is defined in the same module, just return the FieldDef token           
        return (INT32)pField->GetMemberDef();
    }

    // get the field name and sig
    szNameTmp = pField->GetMDImport()->GetNameOfFieldDef(pField->GetMemberDef());
    pvComSig = pField->GetMDImport()->GetSigOfFieldDef(pField->GetMemberDef(), &cbComSig);

    // translate the name to unicode string
    nameSize = (ULONG)strlen(szNameTmp);
    IfFailGo( qbName.ReSize((nameSize + 1) * sizeof(WCHAR)) );
    szName = (WCHAR *) qbName.Ptr();
    actNameSize = ::WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szNameTmp, -1, szName, nameSize + 1);
    
    // The unicode translation function cannot fail!!
    if(actNameSize==0)
        return HRESULT_FROM_WIN32(GetLastError());

    pRefedAssembly = pField->GetModule()->GetAssembly();
    pRefingAssembly = pModule->GetAssembly();
    IfFailGo( pRefingAssembly->GetSecurityModule()->GetEmitter()->QueryInterface(IID_IMetaDataAssemblyEmit, (void **) &pAssemblyEmit) );

    // Translate the field signature this scope  
    IfFailGo( pField->GetMDImport()->TranslateSigWithScope(
        pRefedAssembly->GetManifestImport(), 
        NULL, 0,            // hash value
        pvComSig, 
        cbComSig, 
        pAssemblyEmit,      // Emit assembly scope.
        pRCW->GetEmitter(), 
        &qbNewSig, 
        &cbNewSig) );  

    _ASSERTE(!pField->GetMethodTableOfEnclosingClass()->HasSharedMethodTable());

    IfFailGo( pRCW->GetEmitter()->DefineMemberRef(args->tr, szName, (PCCOR_SIGNATURE) qbNewSig.Ptr(), cbNewSig, &memberRefE) ); 

ErrExit:
    if (pAssemblyEmit)
        pAssemblyEmit->Release();

    if (FAILED(hr))
    {
        _ASSERTE(!"GetMemberRefTokenOfFieldInfo Failed on Field"); 
        COMPlusThrowHR(hr);    
    }
    return memberRefE;  
}


//******************************************************************************
//
// Return a MemberRef token given a Signature
//
//******************************************************************************
int __stdcall COMModule::GetMemberRefTokenFromSignature(_GetMemberRefTokenFromSignatureArgs * args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr; 
    RefClassWriter* pRCW;   
    mdMemberRef     memberRefE; 

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW);

    IfFailGo( pRCW->GetEmitter()->DefineMemberRef(args->tr, 
                                                  args->strMemberName->GetBuffer(), 
                                                  (PCCOR_SIGNATURE) args->signature->GetDataPtr(), 
                                                  args->sigLength, 
                                                  &memberRefE) ); 

ErrExit:
    if (FAILED(hr))
    {
        _ASSERTE(!"GetMemberRefTokenOfFieldInfo Failed on Field"); 
        COMPlusThrowHR(hr);    
    }
    return memberRefE;  
}

//******************************************************************************
//
// SetFieldRVAContent
// This function is used to set the FieldRVA with the content data
//
//******************************************************************************
void __stdcall COMModule::SetFieldRVAContent(_SetFieldRVAContentArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    RefClassWriter      *pRCW;   
    ICeeGen             *pGen;
    HRESULT             hr;
    DWORD               dwRVA;
    void                *pvBlob;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    pGen = pRCW->GetCeeGen();

    // Create the .sdata section if not created
    if (((ReflectionModule*) pModule)->m_sdataSection == 0)
        IfFailGo( pGen->GetSectionCreate (".sdata", sdReadWrite, &((ReflectionModule*) pModule)->m_sdataSection) );

    // Get the size of current .sdata section. This will be the RVA for this field within the section
    IfFailGo( pGen->GetSectionDataLen(((ReflectionModule*) pModule)->m_sdataSection, &dwRVA) );
    dwRVA = (dwRVA + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1);         

    // allocate the space in .sdata section
    IfFailGo( pGen->GetSectionBlock(((ReflectionModule*) pModule)->m_sdataSection, args->length, sizeof(DWORD), (void**) &pvBlob) );

    // copy over the initialized data if specified
    if (args->content != NULL)
        memcpy(pvBlob, args->content->GetDataPtr(), args->length);

    // set FieldRVA into metadata. Note that this is not final RVA in the image if save to disk. We will do another round of fix up upon save.
    IfFailGo( pRCW->GetEmitter()->SetFieldRVA(args->tkField, dwRVA) );

ErrExit:
    if (FAILED(hr))
    {
        // failed in Setting ResolutionScope
        COMPlusThrowHR(hr);
    }
   
}   //SetFieldRVAContent


//******************************************************************************
//
// GetStringConstant
// If this is a dynamic module, this routine will define a new 
//  string constant or return the token of an existing constant.    
//
//******************************************************************************
mdString __stdcall COMModule::GetStringConstant(_GetStringConstantArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    RefClassWriter* pRCW;   
    mdString strRef;   
    HRESULT hr;

    // If they didn't pass a String throw...    
    if (!args->strValue)    
        COMPlusThrow(kArgumentNullException,L"ArgumentNull_String");

    // Verify that the module is a dynamic module...    
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 
    
    hr = pRCW->GetEmitter()->DefineUserString(args->strValue->GetBuffer(), 
            args->strValue->GetStringLength(), &strRef);
    if (FAILED(hr)) {   
        _ASSERTE(!"Unknown failure in DefineUserString");    
        COMPlusThrowHR(hr);    
    }   
    return strRef;  
}


/*=============================SetModuleProps==============================
// SetModuleProps
==============================================================================*/
void __stdcall COMModule::SetModuleProps(_setModulePropsArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    RefClassWriter      *pRCW;
    HRESULT             hr;
    IMetaDataEmit       *pEmit;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (!pModule->IsReflection())
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter();
    _ASSERTE(pRCW);

    pEmit = pRCW->GetEmitter(); 

    IfFailGo( pEmit->SetModuleProps(args->strModuleName->GetBuffer()) );

ErrExit:
    if (FAILED(hr))
    {
        // failed in Setting ResolutionScope
        COMPlusThrowHR(hr);    
    }
}   // SetModuleProps


//***********************************************************
// Helper function to form array in signature. Call within unmanaged code only.
//***********************************************************
unsigned COMModule::GetSigForTypeHandle(TypeHandle typeHnd, PCOR_SIGNATURE sigBuff, unsigned buffLen, IMetaDataEmit* emit, IMDInternalImport *pInternalImport, int baseToken) 
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    unsigned i = 0;
    CorElementType type = typeHnd.GetSigCorElementType();
    if (i < buffLen)
        sigBuff[i] = type;
    i++;

    _ASSERTE(type != ELEMENT_TYPE_OBJECT && type != ELEMENT_TYPE_STRING);

    if (CorTypeInfo::IsPrimitiveType(type))
        return(i);
    else if (type == ELEMENT_TYPE_VALUETYPE || type == ELEMENT_TYPE_CLASS) {
        if (i + 4 > buffLen)
            return(i + 4);
        _ASSERTE(baseToken);
        i += CorSigCompressToken(baseToken, &sigBuff[i]);
        return(i);
    }

        // Only parameterized types from here on out.  
    i += GetSigForTypeHandle(typeHnd.AsTypeDesc()->GetTypeParam(), &sigBuff[i], buffLen - i, emit, pInternalImport, baseToken);
    if (type == ELEMENT_TYPE_SZARRAY || type == ELEMENT_TYPE_PTR)
        return(i);

    _ASSERTE(type == ELEMENT_TYPE_ARRAY);
    if (i + 6 > buffLen)
        return(i + 6);

    i += CorSigCompressData(typeHnd.AsArray()->GetRank(), &sigBuff[i]);
    sigBuff[i++] = 0;       // bound count
    sigBuff[i++] = 0;       // lower bound count
    return(i);
}



//******************************************************************************
//
// Return a type spec token given a reflected type
//
//******************************************************************************
mdTypeSpec __stdcall COMModule::GetTypeSpecToken(_getTypeSpecArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle      typeHnd = ((ReflectClass *) args->arrayClass->GetData())->GetTypeHandle();
    COR_SIGNATURE   aBuff[32];
    PCOR_SIGNATURE  buff = aBuff;
    ULONG           cSig;
    mdTypeSpec      ts;
    RefClassWriter  *pRCW; 
    HRESULT         hr = NOERROR;

    _ASSERTE(typeHnd.IsTypeDesc());

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    cSig = GetSigForTypeHandle(typeHnd, buff, 32, pRCW->GetEmitter(), pRCW->GetMDImport(), args->baseToken);
    if (cSig >= 32) {
        ULONG buffSize = cSig + 1;
        buff = (PCOR_SIGNATURE) _alloca(buffSize + 1);
        cSig = GetSigForTypeHandle(typeHnd, buff, buffSize, pRCW->GetEmitter(), pRCW->GetMDImport(), args->baseToken);
        _ASSERTE(cSig < buffSize);
    }
    hr = pRCW->GetEmitter()->GetTokenFromTypeSpec(buff, cSig, &ts);  
    _ASSERTE(SUCCEEDED(hr));
    return ts;

}


//******************************************************************************
//
// Return a type spec token given a byte array
//
//******************************************************************************
mdTypeSpec __stdcall COMModule::GetTypeSpecTokenWithBytes(_getTypeSpecWithBytesArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    mdTypeSpec      ts;
    RefClassWriter  *pRCW; 
    HRESULT         hr = NOERROR;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (!pModule->IsReflection())  
        COMPlusThrow(kNotSupportedException, L"NotSupported_NonReflectedType");   

    pRCW = ((ReflectionModule*) pModule)->GetClassWriter(); 
    _ASSERTE(pRCW); 

    hr = pRCW->GetEmitter()->GetTokenFromTypeSpec((PCCOR_SIGNATURE)args->signature->GetDataPtr(), args->sigLength, &ts);  
    _ASSERTE(SUCCEEDED(hr));
    return ts;

}

HRESULT COMModule::ClassNameFilter(IMDInternalImport *pInternalImport, mdTypeDef* rgTypeDefs, 
    DWORD* pdwNumTypeDefs, LPUTF8 szPrefix, DWORD cPrefix, bool bCaseSensitive)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(rgTypeDefs && pdwNumTypeDefs && szPrefix);

    bool    bIsPrefix   = false;
    DWORD   dwCurIndex;
    DWORD   i;
    int     cbLen;
    CQuickBytes qbFullName;
    int     iRet;

    // Check to see if wzPrefix requires an exact match of method names or is just a prefix
    if(szPrefix[cPrefix-1] == '*')
    {
        bIsPrefix = true;
        cPrefix--;
    }

    // Now get the properties and then names of each of these classes
    for(i = 0, dwCurIndex = 0; i < *pdwNumTypeDefs; i++)
    {
        LPCUTF8 szcTypeDefName;
        LPCUTF8 szcTypeDefNamespace;
        LPUTF8  szFullName;

        pInternalImport->GetNameOfTypeDef(rgTypeDefs[i], &szcTypeDefName,
            &szcTypeDefNamespace);

        cbLen = ns::GetFullLength(szcTypeDefNamespace, szcTypeDefName);
        qbFullName.ReSize(cbLen);
        szFullName = (LPUTF8) qbFullName.Ptr();

        // Create the full name from the parts.
        iRet = ns::MakePath(szFullName, cbLen, szcTypeDefNamespace, szcTypeDefName);
        _ASSERTE(iRet);


        // If an exact match is required
        if(!bIsPrefix && strlen(szFullName) != cPrefix)
            continue;

        // @TODO - Fix this to use TOUPPER and compare!
        if(!bCaseSensitive && _strnicmp(szPrefix, szFullName, cPrefix))
            continue;

        // Check that the prefix matches
        if(bCaseSensitive && strncmp(szPrefix, szFullName, cPrefix))
            continue;

        // It passed, so copy it to the end of PASSED methods
        rgTypeDefs[dwCurIndex++] = rgTypeDefs[i];
    }

    // The current index is the number that passed
    *pdwNumTypeDefs = dwCurIndex;
    
    return ERROR_SUCCESS;
}

// GetClass
// Given a class name, this method will look for that class
//  with in the module. 
LPVOID __stdcall COMModule::GetClass(_GetClassArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF Throwable = NULL;
    OBJECTREF ret = NULL;
    TypeHandle typeHnd;
    UINT resId = IDS_CLASSLOAD_GENERIC;
    
    GCPROTECT_BEGIN(Throwable);
    
    if (args->refClassName == NULL)
        COMPlusThrow(kArgumentNullException,L"ArgumentNull_String");

    CQuickBytes bytes;
    LPSTR szClassName;
    DWORD cClassName;

    // Get the UTF8 version of args->refClassName
    szClassName = GetClassStringVars((STRINGREF) args->refClassName, &bytes, 
                                     &cClassName, true);

    if(!cClassName)
        COMPlusThrow(kArgumentException, L"Format_StringZeroLength");
    if (cClassName >= MAX_CLASSNAME_LENGTH)
        COMPlusThrow(kArgumentException, L"Argument_TypeNameTooLong");

    if (szClassName[0] == '\0')
        COMPlusThrow(kArgumentException, L"Argument_InvalidName");

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (NULL == NormalizeArrayTypeName(szClassName, cClassName)) 
        resId = IDS_CLASSLOAD_BAD_NAME; 
    else {
        NameHandle typeName(szClassName);
        if (args->bIgnoreCase)
            typeName.SetCaseInsensitive();
    
        typeHnd = pModule->GetAssembly()->FindNestedTypeHandle(&typeName, &Throwable);
        if (typeHnd.IsNull() ||
            (Throwable != NULL) ||
            (typeHnd.GetModule() != pModule))
            goto Done;
    
        // Check we have access to this type. Rules are:
        //  o  Public types are always visible.
        //  o  Callers within the same assembly (or interop) can access all types.
        //  o  Access to all other types requires ReflectionPermission.TypeInfo.
        EEClass *pClass = typeHnd.GetClassOrTypeParam();
        _ASSERTE(pClass);
        if (!IsTdPublic(pClass->GetProtection())) {
            EEClass *pCallersClass = SystemDomain::GetCallersClass(args->stackMark);
            Assembly *pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
            if (pCallersAssembly && // full trust for interop
                !ClassLoader::CanAccess(pCallersClass,
                                        pCallersAssembly,
                                        pClass,
                                        pClass->GetAssembly(),
                                        pClass->GetAttrClass())) 
                // This is not legal if the user doesn't have reflection permission
                COMMember::g_pInvokeUtil->CheckSecurity();
        }
    
        // If they asked for the transparent proxy lets ignore it...
        ret = typeHnd.CreateClassObj();
    }

Done:
    if (ret == NULL) {
        if (args->bThrowOnError) {
            if (Throwable == NULL)
                pModule->GetAssembly()->PostTypeLoadException(szClassName, resId, &Throwable);

            COMPlusThrow(Throwable);
        }
    }

    GCPROTECT_END();
    return (ret!=NULL) ? OBJECTREFToObject(ret) : NULL;
}


// GetName
// This routine will return the name of the module as a String
LPVOID __stdcall COMModule::GetName(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF modName;
    LPVOID    rv;
    LPCSTR    szName = NULL;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    if (pModule->IsResource())
        pModule->GetAssembly()->GetManifestImport()->GetFileProps(pModule->GetModuleRef(),
                                                                  &szName,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL);
    else {
        if (pModule->GetMDImport()->IsValidToken(pModule->GetMDImport()->GetModuleFromScope()))
            pModule->GetMDImport()->GetScopeProps(&szName,0);
        else
            COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    modName = COMString::NewString(szName);
    *((STRINGREF *)&rv) = modName;
    return rv;
}


/*============================GetFullyQualifiedName=============================
**Action:
**Returns:
**Arguments:
**Exceptions:
==============================================================================*/
LPVOID __stdcall COMModule::GetFullyQualifiedName(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    STRINGREF name=NULL;
    HRESULT hr = S_OK;

    WCHAR wszBuffer[64];

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    
    if (pModule->IsPEFile()) {
        LPCWSTR fileName = pModule->GetFileName();
        if (*fileName != 0) {
            name = COMString::NewString(fileName);
        } else {
            hr = LoadStringRC(IDS_EE_NAME_UNKNOWN, wszBuffer, sizeof( wszBuffer ) / sizeof( WCHAR ), true );
            if (SUCCEEDED(hr))
                name = COMString::NewString(wszBuffer);
            else
                COMPlusThrowHR(hr);
        }
    } else if (pModule->IsInMemory()) {
        hr = LoadStringRC(IDS_EE_NAME_INMEMORYMODULE, wszBuffer, sizeof( wszBuffer ) / sizeof( WCHAR ), true );
        if (SUCCEEDED(hr))
            name = COMString::NewString(wszBuffer);
        else
            COMPlusThrowHR(hr);
    } else {
        hr = LoadStringRC(IDS_EE_NAME_INTEROP, wszBuffer, sizeof( wszBuffer ) / sizeof( WCHAR ), true );
        if (SUCCEEDED(hr))
            name = COMString::NewString(wszBuffer);
        else
            COMPlusThrowHR(hr);
    }

    RETURN(name,STRINGREF);
}

/*===================================GetHINST===================================
**Action:  Returns the hinst for this module.
**Returns:
**Arguments: args->refThis
**Exceptions: None.
==============================================================================*/
HINSTANCE __stdcall COMModule::GetHINST(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    HMODULE hMod;
    
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    // This returns the base address - this will work for either HMODULE or HCORMODULES
    // Other modules should have zero base
    hMod = (HMODULE) pModule->GetILBase();

    //If we don't have an hMod, set it to -1 so that they know that there's none
    //available
    if (!hMod) {
        (*((INT32 *)&hMod))=-1;
    }
    
    return (HINSTANCE)hMod;
}

// Get class will return an array contain all of the classes
//  that are defined within this Module.    
LPVOID __stdcall COMModule::GetClasses(_GetClassesArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr;
    DWORD           dwNumTypeDefs = 0;
    DWORD           i;
    mdTypeDef*      rgTypeDefs;
    IMDInternalImport *pInternalImport;
    PTRARRAYREF     refArrClasses;
    PTRARRAYREF     xcept;
    DWORD           cXcept;
    LPVOID          rv;
    HENUMInternal   hEnum;
    bool            bSystemAssembly;    // Don't expose transparent proxy
    bool            bCheckedAccess = false;
    bool            bAllowedAccess = false;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    if (pModule->IsResource()) {
        *((PTRARRAYREF*) &rv) = (PTRARRAYREF) AllocateObjectArray(0, g_pRefUtil->GetTrueType(RC_Class));
        return rv;
    }

    pInternalImport = pModule->GetMDImport();

    // Get the count of typedefs
    hr = pInternalImport->EnumTypeDefInit(&hEnum);

    if(FAILED(hr)) {
        _ASSERTE(!"GetCountTypeDefs failed.");
        COMPlusThrowHR(hr);    
    }
    dwNumTypeDefs = pInternalImport->EnumTypeDefGetCount(&hEnum);

    // Allocate an array for all the typedefs
    rgTypeDefs = (mdTypeDef*) _alloca(sizeof(mdTypeDef) * dwNumTypeDefs);

    // Get the typedefs
    for (i=0; pInternalImport->EnumTypeDefNext(&hEnum, &rgTypeDefs[i]); i++) {

        // Filter out types we can't access.
        if (bCheckedAccess && bAllowedAccess)
            continue;

        DWORD dwFlags;
        pInternalImport->GetTypeDefProps(rgTypeDefs[i], &dwFlags, NULL);

        mdTypeDef mdEncloser = rgTypeDefs[i];
        while (SUCCEEDED(pInternalImport->GetNestedClassProps(mdEncloser, &mdEncloser)) &&
               IsTdNestedPublic(dwFlags))
            pInternalImport->GetTypeDefProps(mdEncloser,
                                             &dwFlags,
                                             NULL);

        // Public types always accessible.
        if (IsTdPublic(dwFlags))
            continue;

        // Need to perform a more heavyweight check. Do this once, since the
        // result is valid for all non-public types within a module.
        if (!bCheckedAccess) {

            Assembly *pCaller = SystemDomain::GetCallersAssembly(args->stackMark);
            if (pCaller == NULL || pCaller == pModule->GetAssembly())
                // Assemblies can access all their own types (and interop
                // callers always get access).
                bAllowedAccess = true;
            else {
                // For the cross assembly case caller needs
                // ReflectionPermission.TypeInfo (the CheckSecurity call will
                // throw if this isn't granted).
                COMPLUS_TRY {
                    COMMember::g_pInvokeUtil->CheckSecurity();
                    bAllowedAccess = true;
                } COMPLUS_CATCH {
                } COMPLUS_END_CATCH
            }
            bCheckedAccess = true;
        }

        if (bAllowedAccess)
            continue;

        // Can't access this type, remove it from the list.
        i--;
    }

    pInternalImport->EnumTypeDefClose(&hEnum);

    // Account for types we skipped.
    dwNumTypeDefs = i;

    // Allocate the COM+ array
    bSystemAssembly = (pModule->GetAssembly() == SystemDomain::SystemAssembly());
    int AllocSize = (!bSystemAssembly || (bCheckedAccess && !bAllowedAccess)) ? dwNumTypeDefs : dwNumTypeDefs - 1;
    refArrClasses = (PTRARRAYREF) AllocateObjectArray(
        AllocSize, g_pRefUtil->GetTrueType(RC_Class));
    GCPROTECT_BEGIN(refArrClasses);

    // Allocate an array to store the references in
    xcept = (PTRARRAYREF) AllocateObjectArray(dwNumTypeDefs,g_pExceptionClass);
    GCPROTECT_BEGIN(xcept);

    cXcept = 0;
    

    OBJECTREF throwable = 0;
    GCPROTECT_BEGIN(throwable);
    // Now create each COM+ Method object and insert it into the array.
    int curPos = 0;
    for(i = 0; i < dwNumTypeDefs; i++)
    {
        // Get the VM class for the current class token
        _ASSERTE(pModule->GetClassLoader());
        NameHandle name(pModule, rgTypeDefs[i]);
        EEClass* pVMCCurClass = pModule->GetClassLoader()->LoadTypeHandle(&name, &throwable).GetClass();
        if (bSystemAssembly) {
            if (pVMCCurClass->GetMethodTable()->IsTransparentProxyType())
                continue;
        }
        if (throwable != 0) {
            refArrClasses->ClearAt(i);
            xcept->SetAt(cXcept++, throwable);
            throwable = 0;
        }
        else {
            _ASSERTE("LoadClass failed." && pVMCCurClass);

            // Get the COM+ Class object
            OBJECTREF refCurClass = pVMCCurClass->GetExposedClassObject();
            _ASSERTE("GetExposedClassObject failed." && refCurClass != NULL);

            refArrClasses->SetAt(curPos++, refCurClass);
        }
    }
    GCPROTECT_END();    //throwable

    // check if there were exceptions thrown
    if (cXcept > 0) {
        PTRARRAYREF xceptRet = (PTRARRAYREF) AllocateObjectArray(cXcept,g_pExceptionClass);
        GCPROTECT_BEGIN(xceptRet);
        for (i=0;i<cXcept;i++) {
            xceptRet->SetAt(i, xcept->GetAt(i));
        }
        OBJECTREF except = COMMember::g_pInvokeUtil->CreateClassLoadExcept((OBJECTREF*) &refArrClasses,(OBJECTREF*) &xceptRet);
        COMPlusThrow(except);
        GCPROTECT_END();
    }

    // Assign the return value to the COM+ array
    *((PTRARRAYREF*) &rv) = refArrClasses;
    GCPROTECT_END();
    GCPROTECT_END();
    _ASSERTE(rv);
    return rv;
}


//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Member:     COMModule::GetSignerCertificate()
//  
//  Synopsis:   Gets the certificate with which the module was signed.
//
//  Effects:    Creates an X509Certificate and returns it.
// 
//  Arguments:  None.
//
//  Returns:    OBJECTREF to an X509Certificate object containing the 
//              signer certificate.
//
//  History:    06/18/1998  JerryK      Created
// 
//---------------------------------------------------------------------------
LPVOID __stdcall
COMModule::GetSignerCertificate(_GETSIGNERCERTARGS* args)
{
    THROWSCOMPLUSEXCEPTION();

    PCOR_TRUST                  pCorTrust = NULL;
    AssemblySecurityDescriptor* pSecDesc = NULL;
    PBYTE                       pbSigner = NULL;
    DWORD                       cbSigner = 0;

    MethodTable*                pX509CertVMC = NULL;
    MethodDesc*                 pMeth = NULL;
    U1ARRAYREF                  U1A_pbSigner = NULL;
    LPVOID                      rv = NULL;
    INT64                       callArgs[2];
    OBJECTREF                   o = NULL;

    // ******** Get the runtime module and its security descriptor ********

    // Get a pointer to the Module
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    // Get a pointer to the module security descriptor
    pSecDesc = pModule->GetSecurityDescriptor();
    _ASSERTE(pSecDesc);




    // ******** Construct an X509Certificate object to return ********
    
    // Load the X509Certificate class
    pX509CertVMC = g_Mscorlib.GetClass(CLASS__X509_CERTIFICATE);
    pMeth = g_Mscorlib.GetMethod(METHOD__X509_CERTIFICATE__CTOR);

    // ******** Get COR_TRUST info from module security descriptor ********
    if (FAILED(pSecDesc->LoadSignature(&pCorTrust)))
    {
        FATAL_EE_ERROR();
    }

    if( pCorTrust )
    {
        // Get a pointer to the signer certificate information in the COR_TRUST
        pbSigner = pCorTrust->pbSigner;
        cbSigner = pCorTrust->cbSigner;

        if( pbSigner && cbSigner )
        {
            GCPROTECT_BEGIN(o);
            
            // Allocate the X509Certificate object
            o = AllocateObject(pX509CertVMC);
            
            // Make a byte array to hold the certificate blob information
            U1A_pbSigner = 
                (U1ARRAYREF) AllocatePrimitiveArray(ELEMENT_TYPE_U1,
                                                     cbSigner);
            // Copy the certificate blob information into place
            memcpyNoGCRefs(U1A_pbSigner->m_Array,
                   pbSigner,
                   cbSigner);

            // Set up and call the X509Certificate constructor
            callArgs[1] = ObjToInt64(U1A_pbSigner);
            callArgs[0] = ObjToInt64(o);
            pMeth->Call(callArgs, METHOD__X509_CERTIFICATE__CTOR);

            *((OBJECTREF *)&rv) = o;

            GCPROTECT_END();

            return rv;
        }
    }

    // If we fell through to here, create and return a "null" X509Certificate
    return NULL;
}


LPVOID __stdcall COMModule::GetAssembly(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
        
    Assembly *pAssembly = pModule->GetAssembly();
    _ASSERTE(pAssembly);

    ASSEMBLYREF result = (ASSEMBLYREF) pAssembly->GetExposedObject();

    LPVOID rv; 
    *((ASSEMBLYREF*) &rv) = result;
    return rv;  
}

INT32 __stdcall COMModule::IsResource(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);
    return pModule->IsResource();
}

LPVOID __stdcall COMModule::GetMethods(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv;
    PTRARRAYREF     refArrMethods;

    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF) args->refThis);

    ReflectMethodList* pML = (ReflectMethodList*) args->refThis->GetGlobals();
    if (pML == 0) {
        void *pGlobals = ReflectModuleGlobals::GetGlobals(pModule);
        args->refThis->SetGlobals(pGlobals);
        pML = (ReflectMethodList*) args->refThis->GetGlobals();
        _ASSERTE(pML);
    }

    // Lets make the reflection class into
    //  the declaring class...
    ReflectClass* pRC = 0;
    if (pML->dwMethods > 0) {
        EEClass* pEEC = pML->methods[0].pMethod->GetClass();
        if (pEEC) {
            REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
            pRC = (ReflectClass*) o->GetData();
        }       
    }

    // Create an array of Methods...
    refArrMethods = g_pRefUtil->CreateClassArray(RC_Method,pRC,pML,BINDER_AllLookup, true);
    *((PTRARRAYREF*) &rv) = refArrMethods;
    return rv;
}

LPVOID __stdcall COMModule::InternalGetMethod(_InternalGetMethodArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    bool    addPriv;
    bool    ignoreCase;
    bool    checkCall;

    //Check Security
    if (args->invokeAttr & BINDER_NonPublic)
        addPriv = true;
    else
        addPriv = false;


    ignoreCase = (args->invokeAttr & BINDER_IgnoreCase) ? true : false;

    // Check the calling convention.
    checkCall = (args->callConv == Any_CC) ? false : true;

    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    // Convert the name into UTF8
    szName = GetClassStringVars((STRINGREF) args->name, &bytes, &cName);

    Module* pModule = (Module*) args->module->GetData();
    _ASSERTE(pModule);

    ReflectMethodList* pML = (ReflectMethodList*) args->module->GetGlobals();
    if (pML == 0) {
        void *pGlobals = ReflectModuleGlobals::GetGlobals(pModule);
        args->module->SetGlobals(pGlobals);
        pML = (ReflectMethodList*) args->module->GetGlobals();
        _ASSERTE(pML);
    }

    ReflectClass* pRC = 0;
    if (pML->dwMethods > 0) {
        EEClass* pEEC = pML->methods[0].pMethod->GetClass();
        if (pEEC) {
            REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
            pRC = (ReflectClass*) o->GetData();
        }       
    }

    // Find methods.....
    return COMMember::g_pInvokeUtil->FindMatchingMethods(args->invokeAttr,
                                                         szName,
                                                         cName,
                                                         (args->argTypes != NULL) ? &args->argTypes : NULL,
                                                         args->argCnt,
                                                         checkCall,
                                                         args->callConv,
                                                         pRC,
                                                         pML,
                                                         g_pRefUtil->GetTrueType(RC_Method),
                                                         true);
}

// GetFields
// Return an array of fields.
FCIMPL1(Object*, COMModule::GetFields, ReflectModuleBaseObject* vRefThis)
{
    THROWSCOMPLUSEXCEPTION();
    Object*          rv;
    HELPER_METHOD_FRAME_BEGIN_RET_1(vRefThis);    // Set up a frame

    PTRARRAYREF     refArrFields;
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF)vRefThis);

    ReflectFieldList* pFL = (ReflectFieldList*) ((REFLECTMODULEBASEREF)vRefThis)->GetGlobalFields();
    if (pFL == 0) {
        void *pGlobals = ReflectModuleGlobals::GetGlobalFields(pModule);
        ((REFLECTMODULEBASEREF)vRefThis)->SetGlobalFields(pGlobals);
        pFL = (ReflectFieldList*) ((REFLECTMODULEBASEREF)vRefThis)->GetGlobalFields();
        _ASSERTE(pFL);
    }

    // Lets make the reflection class into
    //  the declaring class...
    ReflectClass* pRC = 0;
    if (pFL->dwFields > 0) {
        EEClass* pEEC = pFL->fields[0].pField->GetMethodTableOfEnclosingClass()->GetClass();
        if (pEEC) {
            REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
            pRC = (ReflectClass*) o->GetData();
        }       
    }

    // Create an array of Methods...
    refArrFields = g_pRefUtil->CreateClassArray(RC_Field,pRC,pFL,BINDER_AllLookup, true);
    rv = OBJECTREFToObject(refArrFields);
    HELPER_METHOD_FRAME_END();
    return rv;
}
FCIMPLEND

// GetFields
// Return the specified fields
FCIMPL3(Object*, COMModule::GetField, ReflectModuleBaseObject* vRefThis, StringObject* name, INT32 bindingAttr)
{
    THROWSCOMPLUSEXCEPTION();
    Object*          rv = 0;

    HELPER_METHOD_FRAME_BEGIN_RET_2(vRefThis, name);    // Set up a frame
    RefSecContext   sCtx;

    DWORD       i;
    ReflectField* pTarget = 0;
    ReflectClass* pRC = 0;

    // Get the Module
    Module* pModule = ValidateThisRef((REFLECTMODULEBASEREF)vRefThis);

    // Convert the name into UTF8
    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    // Convert the name into UTF8
    szName = GetClassStringVars((STRINGREF)name, &bytes, &cName);

    // Find the list of global fields.
    ReflectFieldList* pFL = (ReflectFieldList*) ((REFLECTMODULEBASEREF)vRefThis)->GetGlobalFields();
    if (pFL == 0) {
        void *pGlobals = ReflectModuleGlobals::GetGlobalFields(pModule);
        ((REFLECTMODULEBASEREF)vRefThis)->SetGlobalFields(pGlobals);
        pFL = (ReflectFieldList*) ((REFLECTMODULEBASEREF)vRefThis)->GetGlobalFields();
        _ASSERTE(pFL);
    }
    if (pFL->dwFields == 0)
        goto exit;

    // Lets make the reflection class into
    //  the declaring class...
    if (pFL->dwFields > 0) {
        EEClass* pEEC = pFL->fields[0].pField->GetMethodTableOfEnclosingClass()->GetClass();
        if (pEEC) {
            REFLECTCLASSBASEREF o = (REFLECTCLASSBASEREF) pEEC->GetExposedClassObject();
            pRC = (ReflectClass*) o->GetData();
        }       
    }

    MethodTable *pParentMT = pRC->GetClass()->GetMethodTable();

    // Walk each field...
    for (i=0;i<pFL->dwFields;i++) {
        // Get the FieldDesc
        if (COMClass::MatchField(pFL->fields[i].pField,cName,szName,pRC,bindingAttr) &&
            InvokeUtil::CheckAccess(&sCtx, pFL->fields[i].pField->GetFieldProtection(), pParentMT, 0)) {
            if (pTarget)
                COMPlusThrow(kAmbiguousMatchException);
            pTarget = &pFL->fields[i];
        }
    }

    // If we didn't find any methods then return
    if (pTarget == 0)
        goto exit;
    rv = OBJECTREFToObject(pTarget->GetFieldInfo(pRC));
exit:;
    HELPER_METHOD_FRAME_END();
    return rv;
}
FCIMPLEND


// This code should be moved out of Variant and into Type.
FCIMPL1(INT32, COMModule::GetSigTypeFromClassWrapper, ReflectClassBaseObject* refType)
{
    VALIDATEOBJECTREF(refType);
    _ASSERTE(refType->GetData());

    ReflectClass* pRC = (ReflectClass*) refType->GetData();

    // Find out if this type is a primitive or a class object
    return pRC->GetSigElementType();
    
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commodule.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#ifndef _COMModule_H_
#define _COMModule_H_

#include "ReflectWrap.h"
#include "COMReflectionCommon.h"
#include "InvokeUtil.h"

class Module;

class COMModule
{
    friend class COMClass;

private:
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
    } _GETSIGNERCERTARGS;

    
public:

    static unsigned COMModule::GetSigForTypeHandle(TypeHandle typeHnd, PCOR_SIGNATURE sigBuff, unsigned buffLen, IMetaDataEmit* emit, IMDInternalImport *pImport, int baseToken);


    // GetFields
    // Return an array of fields.
    static FCDECL1(Object*, GetFields, ReflectModuleBaseObject* vRefThis);

    // GetFields
    // Return an array of fields.
    static FCDECL3(Object*, GetField, ReflectModuleBaseObject* vRefThis, StringObject* name, INT32 bindingAttr);

    static FCDECL1(INT32, GetSigTypeFromClassWrapper, ReflectClassBaseObject* refType);

    // DefineDynamicModule
    // This method will create a dynamic module given an assembly
    struct _DefineDynamicModuleArgs {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark*, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, filename);
        DECLARE_ECALL_I4_ARG(DWORD, emitSymbolInfo); 
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, containingAssembly);
    };
    static LPVOID __stdcall DefineDynamicModule(_DefineDynamicModuleArgs* args);


    // GetClassToken
    // This function will return the class token for the named element.
    struct _GetClassTokenArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_I4_ARG(INT32, tkResolution); 
            DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strRefedModuleFileName);
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refedModule);
            DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strFullName);
    };
    static mdTypeRef __stdcall GetClassToken(_GetClassTokenArgs* args);

    // _LoadInMemoryTypeByNameArgs
    // This function will return the class token for the named element.
    struct _LoadInMemoryTypeByNameArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strFullName);
    };
    LPVOID static __stdcall LoadInMemoryTypeByName(_LoadInMemoryTypeByNameArgs* args);


    // SetFieldRVAContent
    // This function is used to set the FieldRVA with the content data
    struct _SetFieldRVAContentArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_I4_ARG(INT32, length); 
            DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, content); 
            DECLARE_ECALL_I4_ARG(INT32, tkField); 
    };
    static void __stdcall SetFieldRVAContent(_SetFieldRVAContentArgs* args);
    

    //GetArrayMethodToken
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, baseToken); 
        DECLARE_ECALL_I4_ARG(INT32, sigLength); 
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, methodName);
        DECLARE_ECALL_I4_ARG(INT32, tkTypeSpec); 
        DECLARE_ECALL_OBJECTREF_ARG(INT32 *, retRef);
    } _getArrayMethodTokenArgs;
    static void __stdcall GetArrayMethodToken(_getArrayMethodTokenArgs *args);
    
    // GetMemberRefToken
    // This function will return the MemberRef token 
    struct _GetMemberRefTokenArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_I4_ARG(INT32, token); 
            DECLARE_ECALL_I4_ARG(INT32, tr); 
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refedModule);
    };
    static INT32 __stdcall GetMemberRefToken(_GetMemberRefTokenArgs* args);

    // This function return a MemberRef token given a MethodInfo describing a array method
    struct _GetMemberRefTokenOfMethodInfoArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, method);
            DECLARE_ECALL_I4_ARG(INT32, tr); 
    };
    static INT32 __stdcall COMModule::GetMemberRefTokenOfMethodInfo(_GetMemberRefTokenOfMethodInfoArgs *args);


    // GetMemberRefTokenOfFieldInfo
    // This function will return a memberRef token given a FieldInfo
    struct _GetMemberRefTokenOfFieldInfoArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, field);
            DECLARE_ECALL_I4_ARG(INT32, tr); 
    };
    static mdMemberRef __stdcall GetMemberRefTokenOfFieldInfo(_GetMemberRefTokenOfFieldInfoArgs* args);

    // GetMemberRefTokenFromSignature
    // This function will return the MemberRef token given the signature from managed code
    struct _GetMemberRefTokenFromSignatureArgs {
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
            DECLARE_ECALL_I4_ARG(INT32, sigLength); 
            DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature);
            DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strMemberName);
            DECLARE_ECALL_I4_ARG(INT32, tr); 
            DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refedModule);
    };
    static INT32 __stdcall GetMemberRefTokenFromSignature(_GetMemberRefTokenFromSignatureArgs* args);

    // GetTypeSpecToken
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, baseToken); 
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, arrayClass);
    } _getTypeSpecArgs;
    static mdTypeSpec __stdcall GetTypeSpecToken(_getTypeSpecArgs *args);

    // GetTypeSpecTokenWithBytes
    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
        DECLARE_ECALL_I4_ARG(INT32, sigLength); 
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, signature); 
    } _getTypeSpecWithBytesArgs;
    static mdTypeSpec __stdcall GetTypeSpecTokenWithBytes(_getTypeSpecWithBytesArgs *args);

    
    static HRESULT ClassNameFilter(IMDInternalImport *pInternalImport, mdTypeDef* rgTypeDefs, DWORD* pcTypeDefs,
        LPUTF8 szPrefix, DWORD cPrefix, bool bCaseSensitive);

    // GetCaller
    // Returns the module of the calling method. A value can be
    // added to skip uninteresting frames
    struct _GetCallerArgs {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
    };
    static LPVOID __stdcall GetCaller(_GetCallerArgs* args);

    // GetClass
    // Given a class name, this method will look for that class
    //  with in the module.
    struct _GetClassArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis); 
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(INT32, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(INT32, bIgnoreCase); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, refClassName);
    };
    LPVOID static __stdcall GetClass(_GetClassArgs* args);

    // Find classes will invoke a filter against all of the
    //  classes defined within the module.  For each class
    //  accepted by the filter, it will be returned to the
    //  caller in an array.
    struct _GetClassesArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis); 
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
    };

    // Get class will return an array contain all of the classes
    //  that are defined within this Module.
    LPVOID static __stdcall GetClasses(_GetClassesArgs* args);
    
    // GetStringConstant
    // If this is a dynamic module, this routine will define a new 
    //  string constant or return the token of an existing constant.
    struct _GetStringConstantArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strValue);
    };
    static mdString __stdcall GetStringConstant(_GetStringConstantArgs* args);

    /*X509Certificate*/
    LPVOID static __stdcall GetSignerCertificate(_GETSIGNERCERTARGS* args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strModuleName);
    } _setModulePropsArgs;
    static void __stdcall SetModuleProps(_setModulePropsArgs *args);
    

    struct NoArgs {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, refThis);
    };
    static LPVOID __stdcall GetAssembly(NoArgs *args);
    static INT32 __stdcall IsResource(NoArgs *args);
    static LPVOID __stdcall GetMethods(NoArgs* args);
    static INT32 __stdcall IsDynamic(NoArgs* args);
    static LPVOID __stdcall GetName(NoArgs* args);
    static LPVOID __stdcall GetFullyQualifiedName(NoArgs* args);
    static HINSTANCE __stdcall GetHINST(NoArgs *args);


    struct _InternalGetMethodArgs    {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module); 
        DECLARE_ECALL_I4_ARG(INT32, argCnt); 
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, argTypes);
        DECLARE_ECALL_I4_ARG(INT32, callConv); 
        DECLARE_ECALL_I4_ARG(INT32, invokeAttr); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, name);
    };
    static LPVOID __stdcall InternalGetMethod(_InternalGetMethodArgs* args);

    static Module *ValidateThisRef(REFLECTMODULEBASEREF pThis);

    static HRESULT DefineTypeRefHelper(
        IMetaDataEmit       *pEmit,         // given emit scope
        mdTypeDef           td,             // given typedef in the emit scope
        mdTypeRef           *ptr);          // return typeref

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// common.h - precompiled headers include for the COM+ Execution Engine
//

#ifndef _common_h_
#define _common_h_

    // These don't seem useful, so turning them off is no big deal
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4510)   // can't generate default constructor
//#pragma warning(disable:4511)   // can't generate copy constructor
#pragma warning(disable:4512)   // can't generate assignment constructor
#pragma warning(disable:4610)   // user defined constructor required 
#pragma warning(disable:4211)   // nonstandard extention used (char name[0] in structs)
#pragma warning(disable:4268)   // 'const' static/global data initialized with compiler generated default constructor fills the object with zeros
#pragma warning(disable:4238)   // nonstandard extension used : class rvalue used as lvalue
#pragma warning(disable:4291)   // no matching operator delete found
#pragma warning(disable :4786)	 // identifier was truncated to '255' characters in the browser (or debug) information

    // Depending on the code base, you may want to not disable these
#pragma warning(disable:4245)   // assigning signed / unsigned
//#pragma warning(disable:4146)   // unary minus applied to unsigned
#pragma warning(disable:4244)   // loss of data int -> char ..
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4100)   // unreferenced formal parameter

#ifndef DEBUG
#pragma warning(disable:4189)   // local variable initialized but not used
#pragma warning(disable:4505)   // unreferenced local function has been removed
//#pragma warning(disable:4702)   // unreachable code
#endif

    // CONSIDER put these back in
#pragma warning(disable:4063)   // bad switch value for enum (only in Disasm.cpp)
#pragma warning(disable:4710)   // function not inlined
#pragma warning(disable:4527)   // user-defined destructor required
#pragma warning(disable:4513)   // destructor could not be generated

    // TODO we really probably need this one put back in!!!
//#pragma warning(disable:4701)   // local variable may be used without being initialized 


#define _CRT_DEPENDENCY_   //this code depends on the crt file functions
#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>
#include <oledb.h>
#include <olectl.h>

//non inline intrinsics are faster
#pragma function(memcpy,memcmp,memset,strcmp,strcpy,strlen,strcat)


inline VOID EE_EnterCriticalSection(LPCRITICAL_SECTION);
#define EnterCriticalSection EE_EnterCriticalSection

inline VOID EE_LeaveCriticalSection(LPCRITICAL_SECTION);
#define LeaveCriticalSection EE_LeaveCriticalSection

#ifndef GOLDEN
    #define ZAPMONITOR_ENABLED 1
#endif

#define POISONC ((sizeof(int *) == 4)?0xCCCCCCCCL:0xCCCCCCCCCCCCCCCC)

#include "switches.h"
#include "classnames.h"
#include "DbgAlloc.h"
#include "util.hpp"
#include "new.hpp"
#include "corpriv.h"
//#include "WarningControl.h"

#ifndef memcpyGCRefs_f
#define memcpyGCRefs_f
class Object;
void SetCardsAfterBulkCopy( Object**, size_t );
// use this when you want to memcpy something that contains GC refs
inline void *  memcpyGCRefs(void *dest, const void *src, size_t len) 
{
    void *ret = memcpy(dest, src, len);
    SetCardsAfterBulkCopy((Object**) dest, len);
    return ret;
}
#endif

//
// By default logging, and debug GC are enabled under debug
//
// These can be enabled in non-debug by removing the #ifdef _DEBUG
// allowing one to log/check_gc a free build.
//
#ifdef _DEBUG
    #define DEBUG_FLAGS
    #define LOGGING

        // You should be using CopyValueClass if you are doing an memcpy
        // in the CG heap.  
    #if defined(COMPLUS_EE) && !defined(memcpy)
    inline void* memcpyNoGCRefs(void * dest, const void * src, size_t len) {
            return(memcpy(dest, src, len));
        }
    extern "C" void *  __cdecl GCSafeMemCpy(void *, const void *, size_t);
    #define memcpy(dest, src, len) GCSafeMemCpy(dest, src, len)
    #endif

    #if !defined(CHECK_APP_DOMAIN_LEAKS)
    #define CHECK_APP_DOMAIN_LEAKS 1
    #endif
#else
    #define memcpyNoGCRefs memcpy
    #define DEBUG_FLAGS
#endif

#include "log.h"
#include "vars.hpp"
#include "crst.h"
#include "stublink.h"
#include "cgensys.h"
#include "ceemain.h"
#include "hash.h"
#include "ceeload.h"
#include "stdinterfaces.h"
#include "handletable.h"
#include "objecthandle.h"
#include "codeman.h"
#include "class.h"
#include "assembly.hpp"
#include "clsload.hpp"
#include "eehash.h"
#include "gcdesc.h"
#include "list.h"
#include "syncblk.h"
#include "object.h"
#include "method.hpp"
#include "regdisp.h"
#include "frames.h"
#include "stackwalk.h"
#include "threads.h"
#include "stackingallocator.h"
#include "util.hpp"
#include "appdomain.hpp"
#include "interoputil.h"
#include "excep.h"
#include "wrappers.h"

#undef EnterCriticalSection
inline VOID EE_EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    INCTHREADLOCKCOUNT();
}
#define EnterCriticalSection EE_EnterCriticalSection

#undef LeaveCriticalSection
inline VOID EE_LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    LeaveCriticalSection(lpCriticalSection);
    DECTHREADLOCKCOUNT();
}
#define LeaveCriticalSection EE_LeaveCriticalSection

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commutex.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMMutex.cpp
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.Threading.Mutex
**
** Date:  February, 2000
** 
===========================================================*/
#include "common.h"
#include "COMMutex.h"

#define FORMAT_MESSAGE_BUFFER_LENGTH 1024
#define CreateExceptionMessage(wszFinal) \
        if (!WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,					\
                                                           NULL         /*ignored msg source*/,			\
                                                           ::GetLastError(),							\
                                                           0            /*pick appropriate languageId*/,\
                                                           wszFinal,									\
                                                           FORMAT_MESSAGE_BUFFER_LENGTH-1,				\
                                                           0            /*arguments*/)) wszFinal[0] = 0;

FCIMPL3(HANDLE, MutexNative::CorCreateMutex, BOOL initialOwnershipRequested, StringObject* pName, bool* gotOwnership)
{
	STRINGREF mutexString(pName);
    WCHAR* mutexName = L""; 
	if (mutexString != NULL)
		mutexName = mutexString->GetBuffer();

	if (gotOwnership == NULL)
    {
        FCThrow(kNullReferenceException);
    }

	HANDLE mutexHandle = WszCreateMutex(NULL,
										initialOwnershipRequested,
										mutexName);

	if (mutexHandle == NULL)
    {
		WCHAR   wszBuff[FORMAT_MESSAGE_BUFFER_LENGTH];
		WCHAR* wszFinal =wszBuff;
		CreateExceptionMessage(wszFinal)
        FCThrowEx(kApplicationException,0,wszFinal,0,0);
    }
	
    DWORD status = ::GetLastError();
    *gotOwnership = (status != ERROR_ALREADY_EXISTS);

    FC_GC_POLL_RET();
    return mutexHandle;
}
FCIMPLEND


FCIMPL1(void, MutexNative::CorReleaseMutex, HANDLE handle)
{
	_ASSERTE(handle);
	BOOL res = ::ReleaseMutex(handle);
	if (res == NULL)
	{
		WCHAR   wszBuff[FORMAT_MESSAGE_BUFFER_LENGTH];
		WCHAR* wszFinal = wszBuff;
		CreateExceptionMessage(wszFinal)
        FCThrowExVoid(kApplicationException,0,wszFinal,0,0);
	}
    FC_GC_POLL();
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commutex.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMMutex.h
**
** Author: Sanjay Bhansali (sanjaybh)
**
** Purpose: Native methods on System.Threading.Mutex
**
** Date:  February, 2000
** 
===========================================================*/

#ifndef _COMMUTEX_H
#define _COMMUTEX_H

#include "fcall.h"
#include "COMWaitHandle.h"

class MutexNative :public WaitHandleNative
{

public:
    static FCDECL3(HANDLE, CorCreateMutex, BOOL initialOwnershipRequested, StringObject* pName, bool* gotOwnership);
    static FCDECL1(void, CorReleaseMutex, HANDLE handle);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commtmemberinfomap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Map associated with a ComMethodTable that contains
**          information on its members.
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _COMMTMEMBERINFOMAP_H
#define _COMMTMEMBERINFOMAP_H

#include "vars.hpp"

// Forward declarations.
struct ComMethodTable;
class CDescPool;
class MethodDesc;

// Constants.
static const unsigned int FieldSemanticOffset = 100;
static LPCSTR szInitName = COR_CTOR_METHOD_NAME; // not unicode
static LPCWSTR szInitNameUse = L"Init";
static LPCWSTR szDefaultToString = L"ToString";
static LPCWSTR   szDuplicateDecoration = L"_%d";
static const int cchDuplicateDecoration = 10; // max is _16777215 (0xffffff)
static const int cbDuplicateDecoration = 20;  // max is _16777215 (0xffffff)

//*****************************************************************************
// Class to perform memory management for building FuncDesc's etc. for
//  TypeLib creation.  Memory is not moved as the heap is expanded, and
//  all of the allocations are cleaned up in the destructor.
//*****************************************************************************
class CDescPool : public StgPool
{
public:
    CDescPool() : StgPool() { InitNew(); }

    // Allocate some bytes from the pool.
    BYTE * Alloc(ULONG nBytes)
    {   
        BYTE *pRslt;
        if (!Grow(nBytes))
            return 0;
        pRslt = GetNextLocation();
        SegAllocate(nBytes);
        return pRslt;
    }

    // Allocate and clear some bytes.
    BYTE * AllocZero(ULONG nBytes)
    {   
        BYTE *pRslt = Alloc(nBytes);
        if (pRslt)
            memset(pRslt, 0, nBytes);
        return pRslt;
    }
}; // class CDescPool : public StgPool

// Properties of a method in a ComMethodTable.
struct ComMTMethodProps
{
    MethodDesc  *pMeth;             // MethodDesc for the method.
    LPWSTR      pName;              // The method name.  May be a property name.
    mdToken     property;           // Property associated with a name.  May be the token,
                                    //  the index of an associated member, or -1;
    ULONG       dispid;             // The dispid to use for the method.  Get from metadata
                                    //  or determine from "Value" or "ToString".
    USHORT      semantic;           // Semantic of the property, if any.
    SHORT       oVft;               // vtable offset, if not auto-assigned.
    SHORT       bMemberVisible;     // A flag indicating that the member is visible from COM
    SHORT       bFunction2Getter;   // If true, function was munged to getter
};

// Token and module pair.
class EEModuleTokenPair
{
public:
    mdToken         m_tk;
    Module *        m_pModule;

    EEModuleTokenPair() : m_tk(0), m_pModule(NULL) { }
    EEModuleTokenPair(mdToken tk, Module *pModule) : m_tk(tk), m_pModule(pModule) { }
};

// Token and module pair hashtable helper.
class EEModuleTokenHashTableHelper
{
public:
    static EEHashEntry_t *      AllocateEntry(EEModuleTokenPair *pKey, BOOL bDeepCopy, AllocationHeap Heap);
    static void                 DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap);
    static BOOL                 CompareKeys(EEHashEntry_t *pEntry, EEModuleTokenPair *pKey);
    static DWORD                Hash(EEModuleTokenPair *pKey);
    static EEModuleTokenPair *  GetKey(EEHashEntry_t *pEntry);
};

// Token and module pair hashtable.
typedef EEHashTable<EEModuleTokenPair *, EEModuleTokenHashTableHelper, FALSE> EEModuleTokenHashTable;

// Map associated with a ComMethodTable that contains information on its members.
class ComMTMemberInfoMap
{
public:
    ComMTMemberInfoMap(MethodTable *pMT)
    : m_pMT(pMT)
    {
        m_DefaultProp.ReSize(1);
        m_DefaultProp[0] = 0;
    }

    // Initialize the map.
    void Init();

    // Retrieve the member information for a given token.
    ComMTMethodProps *GetMethodProps(mdToken tk, Module *pModule);

    // Retrieves all the method properties.
    CQuickArray<ComMTMethodProps> &GetMethods()
    {
        return m_MethodProps;
    }

    BOOL HadDuplicateDispIds() { return m_bHadDuplicateDispIds;}

private:
    // Helper functions.
    void SetupPropsForIClassX();
    void SetupPropsForInterface();
    void GetMethodPropsForMeth(MethodDesc *pMeth, int ix, CQuickArray<ComMTMethodProps> &rProps, CDescPool &sNames);
    void EliminateDuplicateDispIds(CQuickArray<ComMTMethodProps> &rProps, UINT nSlots);
    void EliminateDuplicateNames(CQuickArray<ComMTMethodProps> &rProps, CDescPool &sNames, UINT nSlots);
    void AssignDefaultMember(CQuickArray<ComMTMethodProps> &rProps, CDescPool &sNames, UINT nSlots);
    void AssignNewEnumMember(CQuickArray<ComMTMethodProps> &rProps, CDescPool &sNames, UINT nSlots);
    void FixupPropertyAccessors(CQuickArray<ComMTMethodProps> &rProps, CDescPool &sNames, UINT nSlots);
    void AssignDefaultDispIds();
    void PopulateMemberHashtable();

    EEModuleTokenHashTable          m_TokenToComMTMethodPropsMap;
    CQuickArray<ComMTMethodProps>   m_MethodProps;
    MethodTable *                   m_pMT;  
    CQuickArray<CHAR>               m_DefaultProp;
    CDescPool                       m_sNames;
    BOOL                            m_bHadDuplicateDispIds;
};

#endif _COMMTMEMBERINFOMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comndirect.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// COMNDIRECT.CPP -
//
// ECall's for the PInvoke classlibs
//


#include "common.h"

#include "clsload.hpp"
#include "method.hpp"
#include "class.h"
#include "object.h"
#include "field.h"
#include "util.hpp"
#include "excep.h"
#include "siginfo.hpp"
#include "threads.h"
#include "stublink.h"
#include "ecall.h"
#include "COMPlusWrapper.h"
#include "ComClass.h"
#include "ndirect.h"
#include "gcdesc.h"
#include "JITInterface.h"
#include "ComCallWrapper.h"
#include "EEConfig.h"
#include "log.h"
#include "nstruct.h"
#include "cgensys.h"
#include "gc.h"
#include "ReflectUtil.h"
#include "ReflectWrap.h"
#include "security.h"
#include "COMStringBuffer.h"
#include "DbgInterface.h"
#include "objecthandle.h"
#include "COMNDirect.h"
#include "fcall.h"
#include "nexport.h"
#include "ml.h"
#include "COMString.h"
#include "OleVariant.h"
#include "remoting.h"
#include "ComMTMemberInfoMap.h"

#include "cominterfacemarshaler.h"
#include "comcallwrapper.h"

#define IDISPATCH_NUM_METHS 7
#define IUNKNOWN_NUM_METHS 3

BOOL IsStructMarshalable(EEClass *pcls)
{
    const FieldMarshaler *pFieldMarshaler = pcls->GetLayoutInfo()->GetFieldMarshalers();
    UINT  numReferenceFields              = pcls->GetLayoutInfo()->GetNumCTMFields();

    while (numReferenceFields--) {

        if (pFieldMarshaler->GetClass() == pFieldMarshaler->CLASS_ILLEGAL)
        {
            return FALSE;
        }

        ((BYTE*&)pFieldMarshaler) += MAXFIELDMARSHALERSIZE;
    }
    return TRUE;

}


/************************************************************************
 * PInvoke.SizeOf(Class)
 */
struct _SizeOfClassArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass); 
};

UINT32 __stdcall SizeOfClass(struct _SizeOfClassArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->refClass == NULL)
        COMPlusThrowArgumentNull(L"t");
    if (args->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

    EEClass *pcls = ((ReflectClass*) args->refClass->GetData())->GetClass();
    if (!(pcls->HasLayout() || pcls->IsBlittable())) 
    {
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pcls);
        COMPlusThrow(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_);
    }

    if (!IsStructMarshalable(pcls))
    {
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pcls);
        COMPlusThrow(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_);
    }

    return pcls->GetMethodTable()->GetNativeSize();
}


/************************************************************************
 * PInvoke.UnsafeAddrOfPinnedArrayElement(Array arr, int index)
 */

FCIMPL2(LPVOID, FCUnsafeAddrOfPinnedArrayElement, ArrayBase *arr, INT32 index) 
{   
    if (!arr)
        FCThrowArgumentNull(L"arr");

    return (arr->GetDataPtr() + (index*arr->GetComponentSize())); 
}
FCIMPLEND


/************************************************************************
 * PInvoke.SizeOf(Object)
 */

FCIMPL1(UINT32, FCSizeOfObject, LPVOID pVNStruct)
{

    OBJECTREF pNStruct;
    *((LPVOID*)&pNStruct) = pVNStruct;
    if (!pNStruct)
        FCThrow(kArgumentNullException);

    MethodTable *pMT = pNStruct->GetMethodTable();
    if (!(pMT->GetClass()->HasLayout() || pMT->GetClass()->IsBlittable()))
    {
        DefineFullyQualifiedNameForClassWOnStack();
        GetFullyQualifiedNameForClassW(pMT->GetClass());
        FCThrowEx(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_, NULL, NULL);
    }

    if (!IsStructMarshalable(pMT->GetClass()))
    {
        DefineFullyQualifiedNameForClassWOnStack();
        GetFullyQualifiedNameForClassW(pMT->GetClass());
        FCThrowEx(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_, NULL, NULL);
    }

    return pMT->GetNativeSize();
}
FCIMPLEND


struct _OffsetOfHelperArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF,      refField);
};

/************************************************************************
 * PInvoke.OffsetOfHelper(Class, Field)
 */
#pragma warning(disable:4702)
UINT32 __stdcall OffsetOfHelper(struct _OffsetOfHelperArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    // Managed code enforces this envariant.
    _ASSERTE(args->refField);

    if (args->refField->GetMethodTable() != g_pRefUtil->GetClass(RC_Field))
        COMPlusThrowArgumentException(L"f", L"Argument_MustBeRuntimeFieldInfo");

    ReflectField* pRF = (ReflectField*) args->refField->GetData();
    FieldDesc *pField = pRF->pField;
    EEClass *pcls = pField->GetEnclosingClass();

    if (!(pcls->IsBlittable() || pcls->HasLayout()))
    {
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pcls);
        COMPlusThrow(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_);
    }
    
    if (!IsStructMarshalable(pcls))
    {
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pcls);
        COMPlusThrow(kArgumentException, IDS_CANNOT_MARSHAL, _wszclsname_);
    }

    const FieldMarshaler *pFieldMarshaler = pcls->GetLayoutInfo()->GetFieldMarshalers();
    UINT  numReferenceFields              = pcls->GetLayoutInfo()->GetNumCTMFields();

    while (numReferenceFields--) {
        if (pFieldMarshaler->m_pFD == pField) {
            return pFieldMarshaler->m_dwExternalOffset;
        }
        ((BYTE*&)pFieldMarshaler) += MAXFIELDMARSHALERSIZE;
    }

    {
        DefineFullyQualifiedNameForClassW();
        GetFullyQualifiedNameForClassW(pcls);
        COMPlusThrow(kArgumentException, IDS_EE_OFFSETOF_NOFIELDFOUND, _wszclsname_);
    }
#ifdef PLATFORM_CE
    return 0;
#else // !PLATFORM_CE
    UNREACHABLE;
#endif // !PLATFORM_CE

}
#pragma warning(default:4702)




/************************************************************************
 * PInvoke.GetUnmanagedThunkForManagedMethodPtr()
 */


struct _GetUnmanagedThunkForManagedMethodPtrArgs
{
    DECLARE_ECALL_I4_ARG (ULONG,            cbSignature);
    DECLARE_ECALL_PTR_ARG(PCCOR_SIGNATURE,  pbSignature);
    DECLARE_ECALL_PTR_ARG(LPVOID,           pfnMethodToWrap);
};

LPVOID __stdcall GetUnmanagedThunkForManagedMethodPtr(struct _GetUnmanagedThunkForManagedMethodPtrArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pargs->pfnMethodToWrap == NULL ||
        pargs->pbSignature == NULL)
    {
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
    }

    Module *pModule = SystemDomain::GetCallersModule(1);
    _ASSERTE(pModule);
    LPVOID pThunk = pModule->GetUMThunk(pargs->pfnMethodToWrap, pargs->pbSignature, pargs->cbSignature);
    if (!pThunk) 
        COMPlusThrowOM();
    return pThunk;
}


/************************************************************************
 * PInvoke.GetManagedThunkForUnmanagedMethodPtr()
 */


struct _GetManagedThunkForUnmanagedMethodPtrArgs
{
    DECLARE_ECALL_I4_ARG (ULONG,            cbSignature);
    DECLARE_ECALL_PTR_ARG(PCCOR_SIGNATURE,  pbSignature);
    DECLARE_ECALL_PTR_ARG(LPVOID,           pfnMethodToWrap);
};



LPVOID __stdcall GetManagedThunkForUnmanagedMethodPtr(struct _GetManagedThunkForUnmanagedMethodPtrArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    Module *pModule = SystemDomain::GetCallersModule(1);
    LPVOID pThunk = pModule->GetMUThunk(pargs->pfnMethodToWrap, pargs->pbSignature, pargs->cbSignature);
    if (!pThunk) 
        COMPlusThrowOM();
    return pThunk;
}


UINT32 __stdcall GetSystemMaxDBCSCharSize(LPVOID /*no args*/)
{
    return GetMaxDBCSCharByteSize();
}


struct _PtrToStringArgs
{
    DECLARE_ECALL_I4_ARG       (INT32,        len);
    DECLARE_ECALL_I4_ARG       (LPVOID,       ptr);
};

/************************************************************************
 * PInvoke.PtrToStringAnsi()
 */

LPVOID __stdcall PtrToStringAnsi(struct _PtrToStringArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->ptr == NULL)
        COMPlusThrowArgumentNull(L"ptr");
    if (args->len < 0)
        COMPlusThrowNonLocalized(kArgumentException, L"len");

    int nwc = 0;
    if (args->len != 0) {
        nwc = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  (LPCSTR)(args->ptr),
                                  args->len,
                                  NULL,
                                  0);
        if (nwc == 0)
            COMPlusThrow(kArgumentException, IDS_UNI2ANSI_FAILURE);
    }                                      
    STRINGREF pString = COMString::NewString(nwc);
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        (LPCSTR)(args->ptr),
                        args->len,
                        pString->GetBuffer(),
                        nwc);

    return *((LPVOID*)&pString);
}


LPVOID __stdcall PtrToStringUni(struct _PtrToStringArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->ptr == NULL)
        COMPlusThrowArgumentNull(L"ptr");
    if (args->len < 0)
        COMPlusThrowNonLocalized(kArgumentException, L"len");

    STRINGREF pString = COMString::NewString(args->len);
    memcpyNoGCRefs(pString->GetBuffer(), (LPVOID)(args->ptr), args->len*sizeof(WCHAR));
    return *((LPVOID*)&pString);
}


struct _CopyToNativeArgs
{
    DECLARE_ECALL_I4_ARG       (UINT32,       length);
    DECLARE_ECALL_PTR_ARG      (LPVOID,       pdst);
    DECLARE_ECALL_I4_ARG       (UINT32,       startindex);
    DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, psrc);
};


/************************************************************************
 * Handles all PInvoke.Copy(array source, ....) methods.
 */
VOID __stdcall CopyToNative(struct _CopyToNativeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->pdst == NULL)
        COMPlusThrowArgumentNull(L"destination");
    if (args->psrc == NULL)
        COMPlusThrowArgumentNull(L"source");

    DWORD numelem = args->psrc->GetNumComponents();

    UINT32 startindex = args->startindex;
    UINT32 length     = args->length;

    if (startindex > numelem  ||
        length > numelem      ||
        startindex > (numelem - length)) {
        COMPlusThrow(kArgumentOutOfRangeException, IDS_EE_COPY_OUTOFRANGE);
    }

    UINT32 componentsize = args->psrc->GetMethodTable()->GetComponentSize();

    CopyMemory(args->pdst,
               componentsize*startindex + (BYTE*)(args->psrc->GetDataPtr()),
               componentsize*length);
}


struct _CopyToManagedArgs
{
    DECLARE_ECALL_I4_ARG       (UINT32,       length);
    DECLARE_ECALL_I4_ARG       (UINT32,       startindex);
    DECLARE_ECALL_OBJECTREF_ARG(BASEARRAYREF, pdst);
    DECLARE_ECALL_PTR_ARG      (LPVOID,       psrc);
};


/************************************************************************
 * Handles all PInvoke.Copy(..., array dst, ....) methods.
 */
VOID __stdcall CopyToManaged(struct _CopyToManagedArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (args->pdst == NULL)
        COMPlusThrowArgumentNull(L"destination");
    if (args->psrc == NULL)
        COMPlusThrowArgumentNull(L"source");

    DWORD numelem = args->pdst->GetNumComponents();

    UINT32 startindex = args->startindex;
    UINT32 length     = args->length;

    if (startindex > numelem  ||
        length > numelem      ||
        startindex > (numelem - length)) {
        COMPlusThrow(kArgumentOutOfRangeException, IDS_EE_COPY_OUTOFRANGE);
    }

    UINT32 componentsize = args->pdst->GetMethodTable()->GetComponentSize();

    _ASSERTE(CorTypeInfo::IsPrimitiveType(args->pdst->GetElementTypeHandle().GetNormCorElementType()));
    memcpyNoGCRefs(componentsize*startindex + (BYTE*)(args->pdst->GetDataPtr()),
               args->psrc,
               componentsize*length);
}





/************************************************************************
 * Helpers for PInvoke.ReadIntegerN() routines
 */
extern "C" __declspec(dllexport) INT32 __stdcall ND_RU1(VOID *psrc, INT32 ofs)
{
    _ASSERTE(!"Can't get here.");
    return 0;
}

extern "C" __declspec(dllexport) INT32 __stdcall ND_RI2(VOID *psrc, INT32 ofs)
{
    _ASSERTE(!"Can't get here.");
    return 0;
}

extern "C" __declspec(dllexport) INT32 __stdcall ND_RI4(VOID *psrc, INT32 ofs)
{
    _ASSERTE(!"Can't get here.");
    return 0;
}

extern "C" __declspec(dllexport) INT64 __stdcall ND_RI8(VOID *psrc, INT32 ofs)
{
    _ASSERTE(!"Can't get here.");
    return 0;
}


/************************************************************************
 * Helpers for PInvoke.WriteIntegerN() routines
 */
extern "C" __declspec(dllexport) VOID __stdcall ND_WU1(VOID *psrc, INT32 ofs, UINT8 val)
{
    _ASSERTE(!"Can't get here.");
}

extern "C" __declspec(dllexport) VOID __stdcall ND_WI2(VOID *psrc, INT32 ofs, INT16 val)
{
    _ASSERTE(!"Can't get here.");
}

extern "C" __declspec(dllexport) VOID __stdcall ND_WI4(VOID *psrc, INT32 ofs, INT32 val)
{
    _ASSERTE(!"Can't get here.");
}

extern "C" __declspec(dllexport) VOID __stdcall ND_WI8(VOID *psrc, INT32 ofs, INT64 val)
{
    _ASSERTE(!"Can't get here.");
}


/************************************************************************
 * PInvoke.GetLastWin32Error
 */
UINT32 __stdcall GetLastWin32Error(LPVOID)
{
    THROWSCOMPLUSEXCEPTION();
    return (UINT32)(GetThread()->m_dwLastError);
}


extern "C" __declspec(dllexport) VOID __stdcall ND_CopyObjSrc(LPBYTE source, int ofs, LPBYTE dst, int cb)
{
    _ASSERTE(!"Can't get here.");
}


extern "C" __declspec(dllexport) VOID __stdcall ND_CopyObjDst(LPBYTE source, LPBYTE dst, int ofs, int cb)
{
    _ASSERTE(!"Can't get here.");
}



/************************************************************************
 * Pinning
 */

struct _AddrOfPinnedObjectArgs
{
    DECLARE_ECALL_I4_ARG       (OBJECTHANDLE, handle);
};

LPVOID __stdcall AddrOfPinnedObject(struct _AddrOfPinnedObjectArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pargs->handle)
        COMPlusThrowArgumentNull(L"handleIndex");

    OBJECTREF or = ObjectFromHandle(pargs->handle);
    if (or->GetMethodTable() == g_pStringClass)
    {
        return ((*(StringObject **)&or))->GetBuffer();
    }
    else
        return (*((ArrayBase**)&or))->GetDataPtr();
}




struct _FreePinnedHandleArgs
{
    DECLARE_ECALL_I4_ARG       (OBJECTHANDLE, handle);
};
VOID   __stdcall FreePinnedHandle(struct _FreePinnedHandleArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pargs->handle)
        COMPlusThrowArgumentNull(L"handleIndex");

    DestroyPinningHandle(pargs->handle);
}



struct _GetPinnedHandleArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pobj);
};
OBJECTHANDLE __stdcall GetPinnedHandle(struct _GetPinnedHandleArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pargs->pobj)
        COMPlusThrowArgumentNull(L"obj");
    
    // allow strings and array of primitive types
    if (pargs->pobj->GetMethodTable() != g_pStringClass) {
        if (!pargs->pobj->GetMethodTable()->IsArray())
            COMPlusThrow(kArgumentException, IDS_EE_CANNOTPIN);

        BASEARRAYREF asArray = (BASEARRAYREF) pargs->pobj;
        if (!CorTypeInfo::IsPrimitiveType(asArray->GetElementType()))
            COMPlusThrow(kArgumentException, IDS_EE_CANNOTPIN);
    }

    OBJECTHANDLE hnd = GetAppDomain()->CreatePinningHandle(pargs->pobj);
    if (!hnd) {
        COMPlusThrowOM();
    }
    return hnd;
}



struct _GetPinnedObjectArgs
{
    DECLARE_ECALL_I4_ARG       (OBJECTHANDLE, handle);
};

LPVOID __stdcall GetPinnedObject(struct _GetPinnedObjectArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pargs->handle)
        COMPlusThrowArgumentNull(L"handleIndex");

    OBJECTREF or = ObjectFromHandle(pargs->handle);
    return *((LPVOID*)&or);
}



/************************************************************************
 * Support for the GCHandle class.
 */

// Allocate a handle of the specified type, containing the specified
// object.
FCIMPL2(LPVOID, GCHandleInternalAlloc, Object *obj, int type)
{
    OBJECTREF or(obj);
    OBJECTHANDLE hnd;

    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

    // If it is a pinned handle, check the object type.
    if (type == HNDTYPE_PINNED) GCHandleValidatePinnedObject(or);

    // Create the handle.
    if((hnd = GetAppDomain()->CreateTypedHandle(or, type)) == NULL)
        COMPlusThrowOM();
    HELPER_METHOD_FRAME_END_POLL();
    return (LPVOID) hnd;
}
FCIMPLEND

// Free a GC handle.
FCIMPL1(VOID, GCHandleInternalFree, OBJECTHANDLE handle)
{
    HELPER_METHOD_FRAME_BEGIN_0();
    THROWSCOMPLUSEXCEPTION();

    DestroyTypedHandle(handle);
    HELPER_METHOD_FRAME_END();
}
FCIMPLEND

// Get the object referenced by a GC handle.
FCIMPL1(LPVOID, GCHandleInternalGet, OBJECTHANDLE handle)
{
    OBJECTREF or;

    HELPER_METHOD_FRAME_BEGIN_RET_0();
    THROWSCOMPLUSEXCEPTION();

    or = ObjectFromHandle(handle);

    HELPER_METHOD_FRAME_END();
    return *((LPVOID*)&or);
}
FCIMPLEND

// Update the object referenced by a GC handle.
FCIMPL3(VOID, GCHandleInternalSet, OBJECTHANDLE handle, Object *obj, int isPinned)
{
    OBJECTREF or(obj);
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

    //@todo: If the handle is pinned check the object type.
    if (isPinned) GCHandleValidatePinnedObject(or);

    // Update the stored object reference.
    StoreObjectInHandle(handle, or);
    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND

// Update the object referenced by a GC handle.
FCIMPL4(VOID, GCHandleInternalCompareExchange, OBJECTHANDLE handle, Object *obj, Object* oldObj, int isPinned)
{
    OBJECTREF newObjref(obj);
    OBJECTREF oldObjref(oldObj);
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();
    THROWSCOMPLUSEXCEPTION();

    //@todo: If the handle is pinned check the object type.
    if (isPinned) GCHandleValidatePinnedObject(newObjref);

    // Update the stored object reference.
    InterlockedCompareExchangeObjectInHandle(handle, newObjref, oldObjref);
    HELPER_METHOD_FRAME_END_POLL();
}
FCIMPLEND

// Get the address of a pinned object referenced by the supplied pinned
// handle.  This routine assumes the handle is pinned and does not check.
FCIMPL1(LPVOID, GCHandleInternalAddrOfPinnedObject, OBJECTHANDLE handle)
{
    LPVOID p;
    HELPER_METHOD_FRAME_BEGIN_RET_0();
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF or = ObjectFromHandle(handle);
    if (or == NULL)
        p = NULL;
    else
    {
        // Get the interior pointer for the supported pinned types.
        if (or->GetMethodTable() == g_pStringClass)
        {
            p = ((*(StringObject **)&or))->GetBuffer();
        }
        else if (or->GetMethodTable()->IsArray())
        {
            p = (*((ArrayBase**)&or))->GetDataPtr();
        }
        else
        {
            p = or->GetData();
        }
    }

    HELPER_METHOD_FRAME_END();
    return p;
}
FCIMPLEND

// Make sure the handle is accessible from the current domain.  (Throw if not.)
FCIMPL1(VOID, GCHandleInternalCheckDomain, OBJECTHANDLE handle)
{
    DWORD index = HndGetHandleTableADIndex(HndGetHandleTable(handle));

    if (index != 0 && index != GetAppDomain()->GetIndex())
        FCThrowArgumentVoid(L"handle", L"Argument_HandleLeak");
}
FCIMPLEND

// Check that the supplied object is valid to put in a pinned handle.
// Throw an exception if not.
void GCHandleValidatePinnedObject(OBJECTREF or)
{
    THROWSCOMPLUSEXCEPTION();

    // NULL is fine.
    if (or == NULL) return;

    if (or->GetMethodTable() == g_pStringClass)
    {
        return;
    }

    if (or->GetMethodTable()->IsArray())
    {
        BASEARRAYREF asArray = (BASEARRAYREF) or;
        if (CorTypeInfo::IsPrimitiveType(asArray->GetElementType())) 
        {
            return;
        }
        {
            TypeHandle th = asArray->GetElementTypeHandle();
            if (th.IsUnsharedMT())
            {
                MethodTable *pMT = th.AsMethodTable();
                if (pMT->IsValueClass() && pMT->GetClass()->IsBlittable())
                {
                    return;
                }
            }
        }
        
    } 
    else if (or->GetMethodTable()->GetClass()->IsBlittable())
    {
        return;
    }

    COMPlusThrow(kArgumentException, IDS_EE_NOTISOMORPHIC);

}

struct _CalculateCountArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(ArrayWithOffsetData*, pRef);
};


UINT32 __stdcall CalculateCount(struct _CalculateCountArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pargs->pRef->m_Array != NULL)
    {
        if (!(pargs->pRef->m_Array->GetMethodTable()->IsArray()))
        {
            COMPlusThrow(kArgumentException, IDS_EE_NOTISOMORPHIC);
        }
        GCHandleValidatePinnedObject(pargs->pRef->m_Array);
    }

    BASEARRAYREF pArray = pargs->pRef->m_Array;

    if (pArray == NULL) {
        if (pargs->pRef->m_cbOffset != 0) {
            COMPlusThrow(kIndexOutOfRangeException, IDS_EE_ARRAYWITHOFFSETOVERFLOW);
        }
        return 0;
    }

    BASEARRAYREF pArrayBase = *((BASEARRAYREF*)&pArray);
    UINT32 cbTotalSize = pArrayBase->GetNumComponents() * pArrayBase->GetMethodTable()->GetComponentSize();
    if (pargs->pRef->m_cbOffset > cbTotalSize) {
        COMPlusThrow(kIndexOutOfRangeException, IDS_EE_ARRAYWITHOFFSETOVERFLOW);
    }
    return cbTotalSize - pargs->pRef->m_cbOffset;
}


#if 0
//// DON'T YANK THIS.
LPVOID __stdcall FuncPtr(VOID*vargs)
{
    struct _args {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, refThis);
    };
    _args *args = (_args*)vargs;
    MethodDesc *pMD = ((ReflectMethod*)(args->refThis->GetData()))->pMethod;


    OBJECTREF pException = NULL;
    Stub     *pMLStream;
    Stub     *pExecutableStub;

    GetMLExportStubs(pMD->GetSig(), pMD->GetModule(), &pMLStream, &pExecutableStub);

#ifdef _DEBUG
    VOID DisassembleMLStream(const MLCode *pMLCode);
    DisassembleMLStream( ( (NExportMLStub*)(pMLStream->GetEntryPoint()) )->GetMLCode() );
#endif

    struct Thing
    {
        // Reserves room for the "call" instruction that forms the beginning
        // of the unmanaged callback. This area must directly precede m_NExportInfo.
        // The "call" jumps to m_pNativeStub.
        BYTE         m_prefixCode[METHOD_PREPAD];
    
        // The NExport record that stores all information needed to perform the
        // call.
        NExportInfo  m_NExportInfo;
    };

    Thing *pThing = new Thing();
    _ASSERTE(pThing != NULL);

    pThing->m_NExportInfo.m_pFD = pMD;
    pThing->m_NExportInfo.m_pObjectHandle = NULL;
    pThing->m_NExportInfo.m_pMLStream = pMLStream;

    LPVOID pcode = (LPVOID)(pExecutableStub->GetEntryPoint());

    emitCall( pThing->m_prefixCode+3, pcode );
    return pThing->m_prefixCode+3;
}
#endif



    //====================================================================
    // *** Interop Helpers ***
    //====================================================================


//====================================================================
// map ITypeLib* to Module
//====================================================================  
struct __GetModuleForITypeLibArgs
{   
    DECLARE_ECALL_PTR_ARG(ITypeLib*, pUnk);
};
/*OBJECTREF */
LPVOID __stdcall Interop::GetModuleForITypeLib(struct __GetModuleForITypeLibArgs* pArgs)
{
    _ASSERTE(pArgs != NULL);

    return NULL;
}

//====================================================================
// map GUID to Type
//====================================================================  

struct __GetLoadedTypeForGUIDArgs
{   
    DECLARE_ECALL_PTR_ARG(GUID*, pGuid);
};
/*OBJECTREF */
LPVOID __stdcall Interop::GetLoadedTypeForGUID(__GetLoadedTypeForGUIDArgs* pArgs)
{
    _ASSERTE(pArgs != NULL);

    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);

    EEClass *pClass = pDomain->LookupClass(*(pArgs->pGuid));
    if (pClass)
    {
        OBJECTREF oref = pClass->GetExposedClassObject();
        return *((LPVOID*)&oref);
    }

    return NULL;
}

//====================================================================
// map Type to ITypeInfo*
//====================================================================
struct __GetITypeInfoForTypeArgs
{   
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
};
ITypeInfo* __stdcall Interop::GetITypeInfoForType(__GetITypeInfoForTypeArgs* pArgs )
{
    THROWSCOMPLUSEXCEPTION();
    
    HRESULT hr;
    ITypeInfo* pTI = NULL;

    // Check for null arguments.
    if(!pArgs->refClass)
        COMPlusThrowArgumentNull(L"t");
    if (pArgs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

    // Retrieve the EE class from the reflection type.
    ReflectClass* pRC = (ReflectClass*) pArgs->refClass->GetData();
    _ASSERTE(pRC);  
    EEClass* pClass = pRC->GetClass();          

    // Make sure the type is visible from COM.
    if (!::IsTypeVisibleFromCom(TypeHandle(pClass)))
        COMPlusThrowArgumentException(L"t", L"Argument_TypeMustBeVisibleFromCom");

    // Retrieve the ITypeInfo for the class.
    IfFailThrow(GetITypeInfoForEEClass(pClass, &pTI, true));
    _ASSERTE(pTI != NULL);
    return pTI;
}

//====================================================================
// return the IUnknown* for an Object
//====================================================================
struct __GetIUnknownForObjectArgs
{   
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, oref);
};

IUnknown* __stdcall Interop::GetIUnknownForObject(__GetIUnknownForObjectArgs* pArgs )
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    if(!pArgs->oref)
        COMPlusThrowArgumentNull(L"o");

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());   

    return GetComIPFromObjectRef(&pArgs->oref, ComIpType_Unknown, NULL);
}

IDispatch* __stdcall Interop::GetIDispatchForObject(__GetIUnknownForObjectArgs* pArgs )
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    if(!pArgs->oref)
        COMPlusThrowArgumentNull(L"o");

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());   

    return (IDispatch*)GetComIPFromObjectRef(&pArgs->oref, ComIpType_Dispatch, NULL);
}

//====================================================================
// return the IUnknown* representing the interface for the Object
// Object o should support Type T
//====================================================================
struct __GetComInterfaceForObjectArgs
{   
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, oref);
};

IUnknown* __stdcall Interop::GetComInterfaceForObject(__GetComInterfaceForObjectArgs* pArgs)
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    if(!pArgs->oref)
        COMPlusThrowArgumentNull(L"o");

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());   

    MethodTable* pMT = NULL;
    if(pArgs->refClass != NULL)
    {
        if (pArgs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
            COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

        ReflectClass* pRC = (ReflectClass*) pArgs->refClass->GetData();
        _ASSERTE(pRC);  
        pMT = pRC->GetClass()->GetMethodTable(); 

        // If the IID being asked for does not represent an interface then
        // throw an argument exception.
        if (!pMT->IsInterface())
            COMPlusThrowArgumentException(L"t", L"Arg_MustBeInterface");

        // If the interface being asked for is not visible from COM then
        // throw an argument exception.
        if (!::IsTypeVisibleFromCom(TypeHandle(pMT)))
            COMPlusThrowArgumentException(L"t", L"Argument_TypeMustBeVisibleFromCom");
    }

    return GetComIPFromObjectRef(&pArgs->oref, pMT);
}

//====================================================================
// return an Object for IUnknown
//====================================================================

struct __GetObjectForIUnknownArgs
{   
    DECLARE_ECALL_PTR_ARG(IUnknown*, pUnk);
};
/*OBJECTREF */
LPVOID __stdcall Interop::GetObjectForIUnknown(__GetObjectForIUnknownArgs*  pArgs)
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    IUnknown* pUnk = pArgs->pUnk;

    if(!pUnk)
        COMPlusThrowArgumentNull(L"pUnk");

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());   

    OBJECTREF oref = GetObjectRefFromComIP(pUnk);
    return *((LPVOID*)&oref);
}

//====================================================================
// return an Object for IUnknown, using the Type T, 
//  NOTE: 
//  Type T should be either a COM imported Type or a sub-type of COM imported Type
//====================================================================
struct __GetTypedObjectForIUnknownArgs
{   
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
    DECLARE_ECALL_PTR_ARG(IUnknown*, pUnk);
};
/*OBJECTREF */
LPVOID __stdcall Interop::GetTypedObjectForIUnknown(__GetTypedObjectForIUnknownArgs*  pArgs)
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    IUnknown* pUnk = pArgs->pUnk;
    MethodTable* pMTClass =  NULL;
    OBJECTREF oref = NULL;

    if(!pUnk)
        COMPlusThrowArgumentNull(L"pUnk");

    if(pArgs->refClass != NULL)
    {
        if (pArgs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
            COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

        ReflectClass* pRC = (ReflectClass*) pArgs->refClass->GetData();
        _ASSERTE(pRC);  
        pMTClass = pRC->GetClass()->GetMethodTable();
    }

    // Ensure COM is started up.
    IfFailThrow(QuickCOMStartup());   

    oref = GetObjectRefFromComIP(pUnk, pMTClass);

    if (pMTClass != NULL && !ClassLoader::CanCastToClassOrInterface(oref, pMTClass->GetClass()))
        COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_COMOBJECT);

    return *((LPVOID*)&oref);
}



//====================================================================
// check if the object is classic COM component
//====================================================================
struct __IsComObjectArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj); 
};

BOOL __stdcall Interop::IsComObject(__IsComObjectArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    if(!pArgs->obj)
        COMPlusThrowArgumentNull(L"o");

    MethodTable* pMT = pArgs->obj->GetTrueMethodTable();
    return pMT->IsComObjectType() ? TRUE : FALSE;
}


//====================================================================
// free the COM component and zombie this object
// further usage of this Object might throw an exception, 
//====================================================================

struct __ReleaseComObjectArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj); 
};

LONG __stdcall Interop::ReleaseComObject(__ReleaseComObjectArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    if(!pArgs->obj)
        COMPlusThrowArgumentNull(L"o");

    MethodTable* pMT = pArgs->obj->GetTrueMethodTable();
    if(!pMT->IsComObjectType())
        COMPlusThrow(kArgumentException, IDS_EE_SRC_OBJ_NOT_COMOBJECT);

    COMOBJECTREF cref = (COMOBJECTREF)(pArgs->obj);

    // Make sure we've correctly transitioned into the home AppDomain of the ComObject
    _ASSERTE(!CRemotingServices::IsTransparentProxy(OBJECTREFToObject(cref)));
    if (CRemotingServices::IsTransparentProxy(OBJECTREFToObject(cref)))
        return -1;
        
    // We are in the correct context, just release.
    return ComPlusWrapper::ExternalRelease(cref);
}


//====================================================================
// This method takes the given COM object and wraps it in an object
// of the specified type. The type must be derived from __ComObject.
//====================================================================
struct __InternalCreateWrapperOfTypeArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, obj); 
};

/*OBJECTREF */
LPVOID __stdcall Interop::InternalCreateWrapperOfType(__InternalCreateWrapperOfTypeArgs *pArgs)
{
    // Validate the arguments.
    THROWSCOMPLUSEXCEPTION();

    // This has already been checked in managed code.
    _ASSERTE(pArgs->refClass != NULL);
    _ASSERTE(pArgs->obj != NULL);

    if (pArgs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

    // Retrieve the class of the COM object.
    EEClass *pObjClass = pArgs->obj->GetClass();

    // Retrieve the method table for new wrapper type.
    ReflectClass* pRC = (ReflectClass*) pArgs->refClass->GetData();
    _ASSERTE(pRC);  
    MethodTable *pNewWrapMT = pRC->GetClass()->GetMethodTable();

    // Validate that the destination type is a COM object.
    _ASSERTE(pNewWrapMT->IsComObjectType());

    // Start by checking if we can cast the obj to the wrapper type.
    if (pObjClass->GetMethodTable()->IsTransparentProxyType())
    {
        if (CRemotingServices::CheckCast(pArgs->obj, pNewWrapMT->GetClass()))
            return *((LPVOID*)&pArgs->obj);
    }
    else
    {
        if (TypeHandle(pObjClass->GetMethodTable()).CanCastTo(TypeHandle(pNewWrapMT)))
            return *((LPVOID*)&pArgs->obj);
    }

    // Validate that the source object is a valid COM object.
    _ASSERTE(pObjClass->GetMethodTable()->IsComObjectType());

    // Validate that the source object has an RCW attached.
    if (!((COMOBJECTREF)pArgs->obj)->GetWrapper())
        COMPlusThrow(kInvalidComObjectException, IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER);

    // Make sure the COM object supports all the COM imported interfaces that the new 
    // wrapper class implements.
    int NumInterfaces = pNewWrapMT->GetNumInterfaces();
    for (int cItf = 0; cItf < NumInterfaces; cItf++)
    {
        MethodTable *pItfMT = pNewWrapMT->GetInterfaceMap()[cItf].m_pMethodTable;
        if (pItfMT->GetClass()->IsComImport())
        {
            if (!pObjClass->SupportsInterface(pArgs->obj, pItfMT))
                COMPlusThrow(kInvalidCastException, IDS_EE_CANNOT_COERCE_COMOBJECT);
        }
    }

    // Create the duplicate wrapper object.
    ComPlusWrapper *pNewWrap = ComPlusWrapper::CreateDuplicateWrapper(((COMOBJECTREF)pArgs->obj)->GetWrapper(), pNewWrapMT);
    COMOBJECTREF RetObj = pNewWrap->GetExposedObject();
    return *((LPVOID*)&RetObj);
}
   

//====================================================================
// map a fiber cookie from the hosting APIs into a managed Thread object
//====================================================================
FCIMPL1(Object*, Interop::GetThreadFromFiberCookie, int cookie)
{
    _ASSERTE(cookie);

    Object *ret = 0;
    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame

    // Any host who is sophisticated enough to correctly schedule fibers
    // had better be sophisticated enough to give us a real fiber cookie.
    Thread  *pThread = *((Thread **) &cookie);
    
    // Minimal check that it smells like a thread:
    _ASSERTE(pThread->m_fPreemptiveGCDisabled == 0 ||
        pThread->m_fPreemptiveGCDisabled == 1);
    
    ret = OBJECTREFToObject(pThread->GetExposedObject()); 
    HELPER_METHOD_FRAME_END();

    return ret;
}
FCIMPLEND
    

//====================================================================
// check if the type is visible from COM.
//====================================================================
struct __IsTypeVisibleFromCom
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
};

BOOL __stdcall Interop::IsTypeVisibleFromCom(__IsTypeVisibleFromCom *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    // Validate the arguments.
    if (pArgs->refClass == NULL) 
        COMPlusThrowArgumentNull(L"t");
    if (pArgs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"t", L"Argument_MustBeRuntimeType");

    // Retrieve the method table for new wrapper type.
    ReflectClass* pRC = (ReflectClass*) pArgs->refClass->GetData();
    _ASSERTE(pRC);  
    MethodTable *pMT = pRC->GetClass()->GetMethodTable();

    // Call the internal version of IsTypeVisibleFromCom.
    return ::IsTypeVisibleFromCom(TypeHandle(pMT));
}


//====================================================================
// IUnknown Helpers
//====================================================================
struct __QueryInterfaceArgs
{   
    DECLARE_ECALL_PTR_ARG(void**, ppv);
    DECLARE_ECALL_OBJECTREF_ARG(REFGUID, iid);
    DECLARE_ECALL_PTR_ARG(IUnknown*, pUnk);
};

// IUnknown::QueryInterface
HRESULT __stdcall Interop::QueryInterface(__QueryInterfaceArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    IUnknown* pUnk = pArgs->pUnk;
    void ** ppv = pArgs->ppv;

    if (!pUnk)
        COMPlusThrowArgumentNull(L"pUnk");
    if (!ppv)
        COMPlusThrowArgumentNull(L"ppv");

    HRESULT hr = SafeQueryInterface(pUnk,pArgs->iid,(IUnknown**)ppv);
    LogInteropQI(pUnk, pArgs->iid, hr, "PInvoke::QI");
    return hr;
}

// IUnknown::AddRef
struct __AddRefArgs
{   
    DECLARE_ECALL_PTR_ARG(IUnknown*, pUnk);
};

ULONG __stdcall Interop::AddRef(__AddRefArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    IUnknown* pUnk = pArgs->pUnk;
    ULONG cbRef = 0;

    if (!pUnk)
        COMPlusThrowArgumentNull(L"pUnk");

    cbRef = SafeAddRef(pUnk);
    LogInteropAddRef(pUnk, cbRef, "PInvoke.AddRef");
    return cbRef;
}

//IUnknown::Release
ULONG __stdcall Interop::Release(__AddRefArgs* pArgs)
{   
    THROWSCOMPLUSEXCEPTION();

    IUnknown* pUnk = pArgs->pUnk;
    ULONG cbRef = 0;

    if (!pUnk)
        COMPlusThrowArgumentNull(L"pUnk");

    cbRef = SafeRelease(pUnk);
    LogInteropRelease(pUnk, cbRef, "PInvoke.Release");
    return cbRef;
}


struct __GetNativeVariantForManagedVariantArgs        
{
    DECLARE_ECALL_I4_ARG(LPVOID, pDestNativeVariant); 
    DECLARE_ECALL_OBJECTREF_ARG(VariantData, SrcManagedVariant);
};

void __stdcall Interop::GetNativeVariantForManagedVariant(__GetNativeVariantForManagedVariantArgs *pArgs)
{
    OleVariant::MarshalOleVariantForComVariant(&pArgs->SrcManagedVariant, (VARIANT*)pArgs->pDestNativeVariant);
}


struct __GetManagedVariantForNativeVariantArgs        
{
    DECLARE_ECALL_I4_ARG(LPVOID, pSrcNativeVariant); 
    DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);      // Return reference
};

void __stdcall Interop::GetManagedVariantForNativeVariant(__GetManagedVariantForNativeVariantArgs *pArgs)
{
    OleVariant::MarshalComVariantForOleVariant((VARIANT*)pArgs->pSrcNativeVariant, pArgs->retRef);
}


struct __GetNativeVariantForObjectArgs
{
    DECLARE_ECALL_I4_ARG(LPVOID, pDestNativeVariant); 
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, Obj);
};

void __stdcall Interop::GetNativeVariantForObject(__GetNativeVariantForObjectArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pArgs->pDestNativeVariant == NULL)
        COMPlusThrowArgumentNull(L"pDstNativeVariant");

    // intialize the output variant
    VariantInit((VARIANT*)pArgs->pDestNativeVariant);
    OleVariant::MarshalOleVariantForObject(&pArgs->Obj, (VARIANT*)pArgs->pDestNativeVariant);
}


struct __GetObjectForNativeVariantArgs        
{
    DECLARE_ECALL_I4_ARG(LPVOID, pSrcNativeVariant); 
};

LPVOID __stdcall Interop::GetObjectForNativeVariant(__GetObjectForNativeVariantArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID Ret;

    if (pArgs->pSrcNativeVariant == NULL)
        COMPlusThrowArgumentNull(L"pSrcNativeVariant");

    OBJECTREF Obj = NULL;
    GCPROTECT_BEGIN(Obj)
    {
        OleVariant::MarshalObjectForOleVariant((VARIANT*)pArgs->pSrcNativeVariant, &Obj);
        Ret = *((LPVOID*)&Obj);
    }
    GCPROTECT_END();

    return Ret;
}


struct __GetObjectsForNativeVariantsArgs
{
    DECLARE_ECALL_I4_ARG(int, cVars); 
    DECLARE_ECALL_I4_ARG(VARIANT *, aSrcNativeVariant);
};

LPVOID __stdcall Interop::GetObjectsForNativeVariants(__GetObjectsForNativeVariantsArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID Ret;

    if (pArgs->aSrcNativeVariant == NULL)
        COMPlusThrowArgumentNull(L"aSrcNativeVariant");
    if (pArgs->cVars < 0)
        COMPlusThrowArgumentOutOfRange(L"cVars", L"ArgumentOutOfRange_NeedNonNegNum");

    PTRARRAYREF Array = NULL;
    OBJECTREF Obj = NULL;
    GCPROTECT_BEGIN(Array)
    GCPROTECT_BEGIN(Obj)
    {
        // Allocate the array of objects.
        Array = (PTRARRAYREF)AllocateObjectArray(pArgs->cVars, g_pObjectClass);

        // Convert each VARIANT in the array into an object.
        for (int i = 0; i < pArgs->cVars; i++)
        {
            OleVariant::MarshalObjectForOleVariant(&pArgs->aSrcNativeVariant[i], &Obj);
            Array->SetAt(i, Obj);
        }

        // Save the return value since the GCPROTECT_END will wack the Array GC ref.
        Ret = *((LPVOID*)&Array);
    }
    GCPROTECT_END();
    GCPROTECT_END();

    return Ret;
}


struct _StructureToPtrArgs
{
    DECLARE_ECALL_I4_ARG(INT32, fDeleteOld);
    DECLARE_ECALL_I4_ARG(LPVOID, ptr);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObj);
};

VOID   __stdcall StructureToPtr(struct _StructureToPtrArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pargs->ptr == NULL)
        COMPlusThrowArgumentNull(L"ptr");
    if (pargs->pObj == NULL) 
        COMPlusThrowArgumentNull(L"structure");

    // Code path will accept both regular layout objects and boxed value classes
    // with layout.

    MethodTable *pMT = pargs->pObj->GetMethodTable();
    EEClass     *pcls = pMT->GetClass();
    if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pargs->ptr, pargs->pObj->GetData(), pMT->GetNativeSize());
    } else if (pcls->HasLayout()) {
        if (pargs->fDeleteOld) {
            LayoutDestroyNative(pargs->ptr, pcls);
        }
        FmtClassUpdateNative( &(pargs->pObj), (LPBYTE)(pargs->ptr) );
    } else {
        COMPlusThrowArgumentException(L"structure", L"Argument_MustHaveLayoutOrBeBlittable");
    }
}


struct _PtrToStructureHelperArgs
{
    DECLARE_ECALL_I4_ARG(INT32, allowValueClasses);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObj);
    DECLARE_ECALL_I4_ARG(LPVOID, ptr);
};

VOID   __stdcall PtrToStructureHelper(struct _PtrToStructureHelperArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();
    if (pargs->ptr == NULL)
        COMPlusThrowArgumentNull(L"ptr");
    if (pargs->pObj == NULL) 
        COMPlusThrowArgumentNull(L"structure");

    // Code path will accept regular layout objects.
    MethodTable *pMT = pargs->pObj->GetMethodTable();
    EEClass     *pcls = pMT->GetClass();

    // Validate that the object passed in is not a value class.
    if (!pargs->allowValueClasses && pcls->IsValueClass()) {
        COMPlusThrowArgumentException(L"structure", L"Argument_StructMustNotBeValueClass");
    } else if (pcls->IsBlittable()) {
        memcpyNoGCRefs(pargs->pObj->GetData(), pargs->ptr, pMT->GetNativeSize());
    } else if (pcls->HasLayout()) {
        LayoutUpdateComPlus( (LPVOID*) &(pargs->pObj), Object::GetOffsetOfFirstField(), pcls, (LPBYTE)(pargs->ptr), FALSE);
    } else {
        COMPlusThrowArgumentException(L"structure", L"Argument_MustHaveLayoutOrBeBlittable");
    }
}


struct _DestroyStructureArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refClass);
    DECLARE_ECALL_I4_ARG(LPVOID, ptr);
};

VOID   __stdcall DestroyStructure(struct _DestroyStructureArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    if (pargs->ptr == NULL)
        COMPlusThrowArgumentNull(L"ptr");
    if (pargs->refClass == NULL)
        COMPlusThrowArgumentNull(L"structureType");
    if (pargs->refClass->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"structureType", L"Argument_MustBeRuntimeType");

    EEClass *pcls = ((ReflectClass*) pargs->refClass->GetData())->GetClass();
    MethodTable *pMT = pcls->GetMethodTable();

    if (pcls->IsBlittable()) {
        // ok to call with blittable structure, but no work to do in this case.
    } else if (pcls->HasLayout()) {
        LayoutDestroyNative(pargs->ptr, pcls);
    } else {
        COMPlusThrowArgumentException(L"structureType", L"Argument_MustHaveLayoutOrBeBlittable");
    }
}


struct __GenerateGuidForTypeArgs        
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, refType);
    DECLARE_ECALL_OBJECTREF_ARG(GUID *, retRef);
};

void __stdcall Interop::GenerateGuidForType(__GenerateGuidForTypeArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    // Validate the arguments.
    if (pArgs->refType == NULL)
        COMPlusThrowArgumentNull(L"type");
    if (pArgs->refType->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"type", L"Argument_MustBeRuntimeType");
    if (pArgs->retRef == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_GUID");

    // Retrieve the EEClass from the Runtime Type.
    ReflectClass* pRC = (ReflectClass*) pArgs->refType->GetData();

    // Check to see if the type is a COM object or not.
    if (pArgs->refType->IsComObjectClass()) 
    {
        // The type is a COM object then we get the GUID from the class factory.
        ComClassFactory* pComClsFac = (ComClassFactory*) pRC->GetCOMObject();
        if (pComClsFac)
            memcpy(pArgs->retRef,&pComClsFac->m_rclsid,sizeof(GUID));
        else
            memset(pArgs->retRef,0,sizeof(GUID));
    }
    else
    {
        // The type is a normal COM+ class so we need to generate the GUID.
        EEClass *pClass = pRC->GetClass();
        pClass->GetGuid(pArgs->retRef, TRUE);
    }
}


struct __GetTypeLibGuidForAssemblyArgs        
{
    DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, refAsm);
    DECLARE_ECALL_OBJECTREF_ARG(GUID *, retRef);
};

void __stdcall Interop::GetTypeLibGuidForAssembly(__GetTypeLibGuidForAssemblyArgs *pArgs)
{
    HRESULT hr = S_OK;

    THROWSCOMPLUSEXCEPTION();

    // Validate the arguments.
    if (pArgs->refAsm == NULL)
        COMPlusThrowArgumentNull(L"asm");
    if (pArgs->retRef == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_GUID");

    // Retrieve the assembly from the ASSEMBLYREF.
    Assembly *pAssembly = pArgs->refAsm->GetAssembly();
    _ASSERTE(pAssembly);

    // Retrieve the TLBID for the assembly.
    IfFailThrow(::GetTypeLibGuidForAssembly(pAssembly, pArgs->retRef));
}


//====================================================================
// Helper function used in the COM slot to method info mapping.
//====================================================================  

enum ComMemberType
{
    CMT_Method              = 0,
    CMT_PropGet             = 1,
    CMT_PropSet             = 2
};

int GetComSlotInfo(EEClass *pClass, EEClass **ppDefItfClass)
{
    _ASSERTE(ppDefItfClass);

    *ppDefItfClass = NULL;

    // If a class was passed in then retrieve the default interface.
    if (!pClass->IsInterface())
    {
        TypeHandle hndDefItfClass;
        DefaultInterfaceType DefItfType = GetDefaultInterfaceForClass(TypeHandle(pClass), &hndDefItfClass);
        if (DefItfType == DefaultInterfaceType_AutoDual || DefItfType == DefaultInterfaceType_Explicit)
        {
            pClass = hndDefItfClass.GetClass();
        }
        else
        {
            // The default interface does not have any user defined methods.
            return -1;
        }
    }

    // Set the default interface class.
    *ppDefItfClass = pClass;

    if (pClass->IsInterface())
    {
        // Return either 3 if the interface is IUnknown based or 7 if it is IDispatch based.
        return pClass->GetComInterfaceType() == ifVtable ? IUNKNOWN_NUM_METHS : IDISPATCH_NUM_METHS;
    }
    else
    {
        // We are dealing with an IClassX which are always IDispatch based.
        return IDISPATCH_NUM_METHS;
    }
}


struct __GetStartComSlotArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, t);
};

int __stdcall Interop::GetStartComSlot(struct __GetStartComSlotArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    if (!(pArgs->t))
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    EEClass *pClass = ((ReflectClass*) pArgs->t->GetData())->GetClass();

    // The service does not make any sense to be called for non COM visible types.
    if (!::IsTypeVisibleFromCom(TypeHandle(pClass)))
        COMPlusThrowArgumentException(L"t", L"Argument_TypeMustBeVisibleFromCom");

    return GetComSlotInfo(pClass, &pClass);
}


struct __GetEndComSlotArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, t);
};

int __stdcall Interop::GetEndComSlot(struct __GetEndComSlotArgs *pArgs)
{
    int StartSlot = -1;

    THROWSCOMPLUSEXCEPTION();

    if (!(pArgs->t))
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    EEClass *pClass = ((ReflectClass*) pArgs->t->GetData())->GetClass();

    // The service does not make any sense to be called for non COM visible types.
    if (!::IsTypeVisibleFromCom(TypeHandle(pClass)))
        COMPlusThrowArgumentException(L"t", L"Argument_TypeMustBeVisibleFromCom");

    // Retrieve the start slot and the default interface class.
    StartSlot = GetComSlotInfo(pClass, &pClass);
    if (StartSlot == -1)
        return StartSlot;

    // Retrieve the map of members.
    ComMTMemberInfoMap MemberMap(pClass->GetMethodTable());
    MemberMap.Init();

    // The end slot is the start slot plus the number of user defined methods.
    return int(StartSlot + MemberMap.GetMethods().Size() - 1);
}

struct __GetComSlotForMethodInfoArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTBASEREF, m);
};

int __stdcall Interop::GetComSlotForMethodInfo(struct __GetComSlotForMethodInfoArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pArgs != NULL);

    if (!(pArgs->m))
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    // This API only supports method info's.
    if (pArgs->m->GetMethodTable() != g_pRefUtil->GetClass(RC_Method))
        COMPlusThrowArgumentException(L"m", L"Argument_MustBeInterfaceMethod");

    // Get the method Descr  (this should not fail)
    //  NOTE: both a constructor and a method are represented by a MetodDesc.
    //      If this ever changes we will need to fix this.
    ReflectMethod* pRM = (ReflectMethod*)pArgs->m->GetData();
    if (!pRM)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");
    MethodDesc* pMeth = pRM->pMethod;
    _ASSERTE(pMeth);

    // This API only supports getting the COM slot for methods of interfaces.
    if (!pMeth->GetMethodTable()->IsInterface())
        COMPlusThrowArgumentException(L"m", L"Argument_MustBeInterfaceMethod");

    return pMeth->GetComSlot();    
}

struct __GetMethodInfoForComSlotArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(ComMemberType *, pMemberType);
    DECLARE_ECALL_I4_ARG(INT32, slot); 
    DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, t);
};

LPVOID __stdcall Interop::GetMethodInfoForComSlot(struct __GetMethodInfoForComSlotArgs *pArgs)
{
    int StartSlot = -1;
    OBJECTREF MemberInfoObj = NULL;

    THROWSCOMPLUSEXCEPTION();

    if (!(pArgs->t))
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    ReflectClass *pRC = (ReflectClass*) pArgs->t->GetData();
    EEClass *pClass = pRC->GetClass();

    // The service does not make any sense to be called for non COM visible types.
    if (!::IsTypeVisibleFromCom(TypeHandle(pClass)))
        COMPlusThrowArgumentException(L"t", L"Argument_TypeMustBeVisibleFromCom");

    // Retrieve the start slot and the default interface class.
    StartSlot = GetComSlotInfo(pClass, &pClass);
    if (StartSlot == -1)
        COMPlusThrowArgumentOutOfRange(L"slot", NULL);

    // Retrieve the map of members.
    ComMTMemberInfoMap MemberMap(pClass->GetMethodTable());
    MemberMap.Init();
    CQuickArray<ComMTMethodProps> &rProps = MemberMap.GetMethods();

    // Make sure the specified slot is valid.
    if (pArgs->slot < StartSlot)
        COMPlusThrowArgumentOutOfRange(L"slot", NULL);
    if (pArgs->slot >= StartSlot + (int)rProps.Size())
        COMPlusThrowArgumentOutOfRange(L"slot", NULL);

    ComMTMethodProps *pProps = &rProps[pArgs->slot - StartSlot];
    if (pProps->semantic >= FieldSemanticOffset)
    {
        // We are dealing with a field.
        ComCallMethodDesc *pFieldMeth = reinterpret_cast<ComCallMethodDesc*>(pProps->pMeth);
        FieldDesc *pField = pFieldMeth->GetFieldDesc();
        MemberInfoObj = pRC->FindReflectField(pField)->GetFieldInfo(pRC);
        *(pArgs->pMemberType) = (pProps->semantic == (FieldSemanticOffset + msGetter)) ? CMT_PropGet : CMT_PropSet;
    }
    else if (pProps->property == mdPropertyNil)
    {
        // We are dealing with a normal property.
        MemberInfoObj = pRC->FindReflectMethod(pProps->pMeth)->GetMethodInfo(pRC);
        *(pArgs->pMemberType) = CMT_Method;
    }
    else
    {
        // We are dealing with a property.
        mdProperty tkProp;
        if (TypeFromToken(pProps->property) == mdtProperty)
        {
            tkProp = pProps->property;
        }
        else
        {
            tkProp = rProps[pProps->property].property;
        }
        MemberInfoObj = pRC->FindReflectProperty(tkProp)->GetPropertyInfo(pRC);
        *(pArgs->pMemberType) = (pProps->semantic == msGetter) ? CMT_PropGet : CMT_PropSet;
    }

    return *((LPVOID*)&MemberInfoObj);
}


struct __ThrowExceptionForHR
{
    DECLARE_ECALL_I4_ARG(LPVOID, errorInfo); 
    DECLARE_ECALL_I4_ARG(INT32, errorCode); 
};

void __stdcall Interop::ThrowExceptionForHR(struct __ThrowExceptionForHR *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    // Only throw on failure error codes.
    if (FAILED(pArgs->errorCode))
    {
        // Retrieve the IErrorInfo to use.
        IErrorInfo *pErrorInfo = (IErrorInfo*)pArgs->errorInfo;
        if (pErrorInfo == (IErrorInfo*)(-1))
        {
            pErrorInfo = NULL;
        }
        else if (!pErrorInfo)
        {
            if (GetErrorInfo(0, &pErrorInfo) != S_OK)
                pErrorInfo = NULL;
        }

        // Throw the exception based on the HR and the IErrorInfo.
        COMPlusThrowHR(pArgs->errorCode, pErrorInfo);
    }
}


struct __GetHRForExceptionArgs        
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, e);
};

int __stdcall Interop::GetHRForException(struct __GetHRForExceptionArgs *pArgs)
{
    return SetupErrorInfo(pArgs->e);
}


//+----------------------------------------------------------------------------
//
//  Method:     Interop::::WrapIUnknownWithComObject
//  Synopsis:   unmarshal the buffer and return IUnknown
//
//  History:    01-Nov-99   RajaK      Created
//
//+----------------------------------------------------------------------------
struct __WrapIUnknownWithComObjectArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, owner);
    DECLARE_ECALL_PTR_ARG(IUnknown*, pUnk);
};

Object* __stdcall Interop::WrapIUnknownWithComObject(__WrapIUnknownWithComObjectArgs* pArgs)
{
	THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pArgs != NULL);

    if(pArgs->pUnk == NULL)
        COMPlusThrowArgumentNull(L"punk");
        
    OBJECTREF cref = NULL;

    HRESULT hr = QuickCOMStartup();
    if (FAILED(hr))
    {
        COMPlusThrowHR(hr);
    }   
	    
	COMInterfaceMarshaler marshaler;
    marshaler.Init(pArgs->pUnk, SystemDomain::GetDefaultComObject());
    
    cref = marshaler.FindOrWrapWithComObject(pArgs->owner);
    
    if (cref == NULL)
        COMPlusThrowOM();
        
    return OBJECTREFToObject(cref);
}

//+----------------------------------------------------------------------------
//
//  Method:     bool __stdcall Interop::SwitchCCW(switchCCWArgs* pArgs)
//
//  Synopsis:   switch the wrapper from oldtp to newtp
//
//  History:    01-Nov-99   RajaK      Created
//
//+----------------------------------------------------------------------------

BOOL __stdcall Interop::SwitchCCW(switchCCWArgs* pArgs)
{
    // defined in interoputil.cpp
    return ReconnectWrapper(pArgs);
}


struct ChangeWrapperHandleStrengthArgs
{
    DECLARE_ECALL_I4_ARG(INT32, fIsWeak);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, oref);
};
void __stdcall Interop::ChangeWrapperHandleStrength(ChangeWrapperHandleStrengthArgs* pArgs)
{
    THROWSCOMPLUSEXCEPTION();
    
    OBJECTREF oref = pArgs->oref;
    if(oref == NULL)
        COMPlusThrowArgumentNull(L"otp");
    
    if (CRemotingServices::IsTransparentProxy(OBJECTREFToObject(oref)) || !oref->GetClass()->IsComImport())
    {
        ComCallWrapper* pWrap = NULL;
        GCPROTECT_BEGIN(oref)
        {        
           pWrap = ComCallWrapper::InlineGetWrapper(&oref);
        }
        GCPROTECT_END();
        
        if (pWrap == NULL)
        {
            COMPlusThrowOM();
        }

        if(! pWrap->IsUnloaded())
        {
            if (pArgs->fIsWeak != 0)
            {
                pWrap->MarkHandleWeak();
            }
            else
            {
                pWrap->ResetHandleStrength();
            }
        }
        ComCallWrapper::Release(pWrap);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comndirect.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// COMNDIRECT.H -
//
// ECall's for the NDirect classlibs
//


#ifndef __COMNDIRECT_H__
#define __COMNDIRECT_H__

#include "fcall.h"

VOID __stdcall CopyToNative(struct _CopyToNativeArgs *args);
VOID __stdcall CopyToManaged(struct _CopyToManagedArgs *args);
UINT32 __stdcall SizeOfClass(struct _SizeOfClassArgs *args);


FCDECL1(UINT32, FCSizeOfObject, LPVOID pNStruct);
FCDECL2(LPVOID, FCUnsafeAddrOfPinnedArrayElement, ArrayBase *arr, INT32 index);

UINT32 __stdcall OffsetOfHelper(struct _OffsetOfHelperArgs *args);
UINT32 __stdcall GetLastWin32Error(LPVOID);
UINT32 __stdcall CalculateCount(struct _CalculateCountArgs *pargs);
LPVOID __stdcall PtrToStringAnsi(struct _PtrToStringArgs *pargs);
LPVOID __stdcall PtrToStringUni(struct _PtrToStringArgs *pargs);

VOID   __stdcall StructureToPtr(struct _StructureToPtrArgs *pargs);
VOID   __stdcall PtrToStructureHelper(struct _PtrToStructureHelperArgs *pargs);
VOID   __stdcall DestroyStructure(struct _DestroyStructureArgs *pargs);

LPVOID __stdcall GetUnmanagedThunkForManagedMethodPtr(struct _GetUnmanagedThunkForManagedMethodPtrArgs *pargs);
LPVOID __stdcall GetManagedThunkForUnmanagedMethodPtr(struct _GetManagedThunkForUnmanagedMethodPtrArgs *pargs);

UINT32 __stdcall GetSystemMaxDBCSCharSize(LPVOID /*no args*/);

FCDECL2(LPVOID, GCHandleInternalAlloc, Object *obj, int type);
FCDECL1(VOID, GCHandleInternalFree, OBJECTHANDLE handle);
FCDECL1(LPVOID, GCHandleInternalGet, OBJECTHANDLE handle);
FCDECL3(VOID, GCHandleInternalSet, OBJECTHANDLE handle, Object *obj, int isPinned);
FCDECL4(VOID, GCHandleInternalCompareExchange, OBJECTHANDLE handle, Object *obj, Object* oldObj, int isPinned);
FCDECL1(LPVOID, GCHandleInternalAddrOfPinnedObject, OBJECTHANDLE handle);
FCDECL1(VOID, GCHandleInternalCheckDomain, OBJECTHANDLE handle);
void GCHandleValidatePinnedObject(OBJECTREF or);


//!!! Must be kept in sync with ArrayWithOffset class layout.
struct ArrayWithOffsetData
{
    BASEARRAYREF    m_Array;
    UINT32          m_cbOffset;
    UINT32          m_cbCount;
};


	//====================================================================
	// *** Interop Helpers ***
	//====================================================================
	
class Interop
{
public:

	//====================================================================
	// map ITypeLib* to Module
	//====================================================================	
	static /*OBJECTREF */LPVOID __stdcall GetModuleForITypeLib(struct __GetModuleForITypeLibArgs*);

	//====================================================================
	// map GUID to Type
	//====================================================================	
	static /*OBJECTREF */LPVOID __stdcall GetLoadedTypeForGUID(struct __GetLoadedTypeForGUIDArgs*);

	//====================================================================
	// map Type to ITypeInfo*
	//====================================================================
	static ITypeInfo* __stdcall GetITypeInfoForType(struct __GetITypeInfoForTypeArgs* );

	//====================================================================
	// return the IUnknown* for an Object
	//====================================================================
	static IUnknown* __stdcall GetIUnknownForObject(struct __GetIUnknownForObjectArgs* );

	//====================================================================
	// return the IDispatch* for an Object
	//====================================================================
	static IDispatch* __stdcall GetIDispatchForObject(__GetIUnknownForObjectArgs* pArgs );

	//====================================================================
	// return the IUnknown* representing the interface for the Object
	// Object o should support Type T
	//====================================================================
	static IUnknown* __stdcall GetComInterfaceForObject(struct __GetComInterfaceForObjectArgs*);

	//====================================================================
	// return an Object for IUnknown
	//====================================================================
	static /*OBJECTREF */LPVOID __stdcall GetObjectForIUnknown(struct __GetObjectForIUnknownArgs*);

	//====================================================================
	// return an Object for IUnknown, using the Type T, 
	//	NOTE: 
	//	Type T should be either a COM imported Type or a sub-type of COM imported Type
	//====================================================================
	static /*OBJECTREF */LPVOID __stdcall GetTypedObjectForIUnknown(struct __GetTypedObjectForIUnknownArgs*);

	//====================================================================
	// check if the object is classic COM component
	//====================================================================
	static BOOL __stdcall IsComObject(struct __IsComObjectArgs* );

	//====================================================================
	// free the COM component and zombie this object
	// further usage of this Object might throw an exception, 
	//====================================================================
	static LONG __stdcall ReleaseComObject(struct __ReleaseComObjectArgs* );

    //====================================================================
    // This method takes the given COM object and wraps it in an object
	// of the specified type. The type must be derived from __ComObject.
    //====================================================================
    static /*OBJECTREF */LPVOID __stdcall InternalCreateWrapperOfType(struct __InternalCreateWrapperOfTypeArgs*);
    
    //====================================================================
    // There may be a thread-based cache of COM components.  This service can
    // force the aggressive release of the current thread's cache.
    //====================================================================
#ifdef FCALLAVAILABLE
    static FCDECL0(void, ReleaseThreadCache);
#else
    static void __stdcall ReleaseThreadCache(LPVOID /*no args*/);
#endif

    //====================================================================
    // map a fiber cookie from the hosting APIs into a managed Thread object
    //====================================================================
    static FCDECL1(Object*, GetThreadFromFiberCookie, int cookie);

    //====================================================================
    // check if the type is visible from COM.
	//====================================================================
	static BOOL __stdcall IsTypeVisibleFromCom(struct __IsTypeVisibleFromCom*);

	//====================================================================
	// IUnknown Helpers
	//====================================================================

	static HRESULT __stdcall QueryInterface(struct __QueryInterfaceArgs*);

	static ULONG __stdcall AddRef(struct __AddRefArgs*);
	static ULONG __stdcall Release(struct __AddRefArgs*);

	//====================================================================
	// These methods convert variants from native to managed and vice 
	// versa.
	//====================================================================
	static void __stdcall GetNativeVariantForManagedVariant(struct __GetNativeVariantForManagedVariantArgs *);
	static void __stdcall GetManagedVariantForNativeVariant(struct __GetManagedVariantForNativeVariantArgs *);

	//====================================================================
	// These methods convert OLE variants to and from objects.
	//====================================================================
	static void __stdcall GetNativeVariantForObject(struct __GetNativeVariantForObjectArgs *);
	static LPVOID __stdcall GetObjectForNativeVariant(struct __GetObjectForNativeVariantArgs *);
	static LPVOID __stdcall GetObjectsForNativeVariants(struct __GetObjectsForNativeVariantsArgs *);

	//====================================================================
	// This method generates a guid for the specified type.
	//====================================================================
	static void __stdcall GenerateGuidForType(struct __GenerateGuidForTypeArgs *);

	//====================================================================
    // Given a assembly, return the TLBID that will be generated for the
    // typelib exported from the assembly.
	//====================================================================
	static void __stdcall GetTypeLibGuidForAssembly(struct __GetTypeLibGuidForAssemblyArgs *);

    //====================================================================
    // These methods are used to map COM slots to method info's.
    //====================================================================
	static int __stdcall GetStartComSlot(struct __GetStartComSlotArgs *);
	static int __stdcall GetEndComSlot(struct __GetEndComSlotArgs *);
	static LPVOID __stdcall GetMethodInfoForComSlot(struct __GetMethodInfoForComSlotArgs *);

	static int __stdcall GetComSlotForMethodInfo(struct __GetComSlotForMethodInfoArgs *);
	

    //====================================================================
    // These methods convert between an HR and and a managed exception.
    //====================================================================
	static void __stdcall ThrowExceptionForHR(struct __ThrowExceptionForHR *);
	static int __stdcall GetHRForException(struct __GetHRForExceptionArgs *);
	static Object* __stdcall WrapIUnknownWithComObject(struct __WrapIUnknownWithComObjectArgs* pArgs);	
	static BOOL __stdcall SwitchCCW(struct switchCCWArgs* pArgs);

	static void __stdcall ChangeWrapperHandleStrength(struct ChangeWrapperHandleStrengthArgs* pArgs);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comnumber.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _COMNUMBER_H_
#define _COMNUMBER_H_

#include "common.h"
#include <windows.h>
#include <oleauto.h>

#pragma pack(push)
#pragma pack(1)

class NumberFormatInfo: public Object
{
public:
	// C++ data members	            // Corresponding data member in NumberFormat.cool
                                    // Also update mscorlib.h when you add/remove fields            
	I4ARRAYREF cNumberGroup;		// numberGroupSize
    I4ARRAYREF cCurrencyGroup;		// currencyGroupSize
    I4ARRAYREF cPercentGroup;		// percentGroupSize
    
    STRINGREF sPositive;           	// positiveSign
    STRINGREF sNegative;           	// negativeSign
    STRINGREF sNumberDecimal;      	// numberDecimalSeparator
    STRINGREF sNumberGroup;        	// numberGroupSeparator
    STRINGREF sCurrencyGroup;      	// currencyDecimalSeparator
    STRINGREF sCurrencyDecimal;    	// currencyGroupSeparator
    STRINGREF sCurrency;            // currencySymbol
    STRINGREF sAnsiCurrency;        // ansiCurrencySymbol
    STRINGREF sNaN;                 // nanSymbol
    STRINGREF sPositiveInfinity;    // positiveInfinitySymbol
    STRINGREF sNegativeInfinity;    // negativeInfinitySymbol
    STRINGREF sPercentDecimal;		// percentDecimalSeparator
    STRINGREF sPercentGroup;		// percentGroupSeparator
    STRINGREF sPercent;				// percentSymbol
    STRINGREF sPerMille;			// perMilleSymbol
    
    INT32 iDataItem;                // Index into the CultureInfo Table.  Only used from managed code.
    INT32 cNumberDecimals;			// numberDecimalDigits
    INT32 cCurrencyDecimals;        // currencyDecimalDigits
    INT32 cPosCurrencyFormat;       // positiveCurrencyFormat
    INT32 cNegCurrencyFormat;       // negativeCurrencyFormat
    INT32 cNegativeNumberFormat;    // negativeNumberFormat
    INT32 cPositivePercentFormat;   // positivePercentFormat
    INT32 cNegativePercentFormat;   // negativePercentFormat
    INT32 cPercentDecimals;			// percentDecimalDigits

	bool bIsReadOnly;              // Is this NumberFormatInfo ReadOnly?
    bool bUseUserOverride;          // Flag to use user override. Only used from managed code.
    bool bValidForParseAsNumber;   // Are the separators set unambiguously for parsing as number?
    bool bValidForParseAsCurrency; // Are the separators set unambiguously for parsing as currency?
    
};

typedef NumberFormatInfo * NUMFMTREF;

#define PARSE_LEADINGWHITE  0x0001
#define PARSE_TRAILINGWHITE 0x0002
#define PARSE_LEADINGSIGN   0x0004
#define PARSE_TRAILINGSIGN  0x0008
#define PARSE_PARENS        0x0010
#define PARSE_DECIMAL       0x0020
#define PARSE_THOUSANDS     0x0040
#define PARSE_SCIENTIFIC    0x0080
#define PARSE_CURRENCY      0x0100
#define PARSE_HEX			0x0200
#define PARSE_PERCENT       0x0400

class COMNumber
{
public:
    struct FormatDecimalArgs {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_DEFAULT_ARG(DECIMAL, value);
    };

    struct FormatDoubleArgs {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_R8_ARG(R8, value);
    };

    struct FormatInt32Args {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_I4_ARG(I4, value);
    };

    struct FormatUInt32Args {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_I4_ARG(U4, value);
    };

    struct FormatInt64Args {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_I8_ARG(I8, value);
    };

    struct FormatUInt64Args {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_I8_ARG(U8, value);
    };

    struct FormatSingleArgs {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
        DECLARE_ECALL_R4_ARG(R4, value);
    };

    struct ParseArgs {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_I4_ARG(I4, options);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    };

    struct TryParseArgs {
        DECLARE_ECALL_PTR_ARG(double *, result);
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_I4_ARG(I4, options);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
    };

    struct ParseDecimalArgs {
        DECLARE_ECALL_OBJECTREF_ARG(NUMFMTREF, numfmt);
        DECLARE_ECALL_I4_ARG(I4, options);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
        DECLARE_ECALL_PTR_ARG(DECIMAL *, result);
    };

    static LPVOID __stdcall FormatDecimal(FormatDecimalArgs *);
    static LPVOID __stdcall FormatDouble(FormatDoubleArgs *);
    static LPVOID __stdcall FormatInt32(FormatInt32Args *);
    static LPVOID __stdcall FormatUInt32(FormatUInt32Args *);
    static LPVOID __stdcall FormatInt64(FormatInt64Args *);
    static LPVOID __stdcall FormatUInt64(FormatUInt64Args *);
    static LPVOID __stdcall FormatSingle(FormatSingleArgs *);

    static double __stdcall ParseDouble(ParseArgs *);
    static bool __stdcall TryParseDouble(TryParseArgs *);
    static void __stdcall ParseDecimal(ParseDecimalArgs *);
    static int __stdcall ParseInt32(ParseArgs *);
    static unsigned int __stdcall ParseUInt32(ParseArgs *);
    static __int64 __stdcall ParseInt64(ParseArgs *);
    static unsigned __int64 __stdcall ParseUInt64(ParseArgs *);
    static float __stdcall ParseSingle(ParseArgs *);
};

#pragma pack(pop)

#endif _COMNUMBER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comobject.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMObject.cpp
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.Object
**
** Date:  March 27, 1998
** 
===========================================================*/

#include "common.h"

#include <object.h>
#include "excep.h"
#include "vars.hpp"
#include "field.h"
#include "COMObject.h"
#include "COMClass.h"
#include "COMSynchronizable.h"
#include "gcscan.h"
#include "remoting.h"


/********************************************************************/
/* gets an object's 'value'.  For normal classes, with reference
   based semantics, this means the object's pointer.  For boxed
   primitive types, it also means just returning the pointer (because
   they are immutable), for other value class, it means returning
   a boxed copy.  */

FCIMPL1(Object*, ObjectNative::GetObjectValue, Object* obj) 
    if (obj == 0)
        return(obj);

    MethodTable* pMT = obj->GetMethodTable();
    if (pMT->GetNormCorElementType() != ELEMENT_TYPE_VALUETYPE)
        return(obj);

    Object* retVal;
    OBJECTREF or(obj);
    HELPER_METHOD_FRAME_BEGIN_RET_1(or);    // Set up a frame
    retVal = OBJECTREFToObject(FastAllocateObject(pMT));
    CopyValueClass(retVal->GetData(), or->GetData(), pMT, retVal->GetAppDomain());
    HELPER_METHOD_FRAME_END();

    return(retVal);
FCIMPLEND

// Note that we obtain a sync block index without actually building a sync block.
// That's because a lot of objects are hashed, without requiring support for
FCIMPL1(INT32, ObjectNative::GetHashCode, Object* or) {
    if (or == 0)
        return 0;

    VALIDATEOBJECTREF(or);

    DWORD      idx = or->GetSyncBlockIndex();

    _ASSERTE(idx != 0);

    // If the syncblock already exists, it has now become precious.  Otherwise the
    // hash code would not be stable across GCs.
    SyncBlock *psb = or->PassiveGetSyncBlock();

    if (psb)
        psb->SetPrecious();

    return idx;
}
FCIMPLEND


//
// Compare by ref for normal classes, by value for value types.
//  
// @todo: it would be nice to customize this method based on the
// defining class rather than doing a runtime check whether it is
// a value type.
//

FCIMPL2(BOOL, ObjectNative::Equals, Object *pThisRef, Object *pCompareRef)
{
    if (pThisRef == pCompareRef)    
        return TRUE;

    // Since we are in FCALL, we must handle NULL specially.
    if (pThisRef == NULL || pCompareRef == NULL)
        return FALSE;

    MethodTable *pThisMT = pThisRef->GetMethodTable();

    // If it's not a value class, don't compare by value
    if (!pThisMT->IsValueClass())
        return FALSE;

    // Make sure they are the same type.
    if (pThisMT != pCompareRef->GetMethodTable())
        return FALSE;

    // Compare the contents (size - vtable - sink block index).
    BOOL ret = !memcmp((void *) (pThisRef+1), (void *) (pCompareRef+1), pThisRef->GetMethodTable()->GetBaseSize() - sizeof(Object) - sizeof(int));
    FC_GC_POLL_RET();
    return ret;
}
FCIMPLEND


LPVOID __stdcall ObjectNative::GetClass(GetClassArgs *args)
{
    OBJECTREF or = args->m_pThis;
    REFLECTCLASSBASEREF  refClass = NULL;
    EEClass* pClass = or->GetTrueMethodTable()->m_pEEClass;

    // Arrays of Pointers are implemented by reflection,
    //  defer to COMClass for them.
    if (pClass->IsArrayClass()) {
        // This code is essentially duplicated in GetExistingClass.
        ArrayBase* array = (ArrayBase*) OBJECTREFToObject(or);
        TypeHandle arrayType = array->GetTypeHandle();
        refClass = (REFLECTCLASSBASEREF) arrayType.AsArray()->CreateClassObj();
    }
    else if (or->GetClass()->IsThunking()) {

        refClass = CRemotingServices::GetClass(or);
    }
    else
        refClass = (REFLECTCLASSBASEREF) pClass->GetExposedClassObject();

    LPVOID rv;
    _ASSERTE(refClass != NULL);
    *((REFLECTCLASSBASEREF *)&rv) = refClass;
    return rv;
}

// *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING
// 
//   IF YOU CHANGE THIS METHOD, PLEASE ALSO MAKE CORRESPONDING CHANGES TO
//                CtxProxy::Clone() AS DESCRIBED BELOW.
//
// *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING

LPVOID __stdcall ObjectNative::Clone(NoArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pargs != NULL);

    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // ObjectNative::Clone() ensures that the source and destination are always in
    // the same context.  CtxProxy::Clone() must clone an object into a different
    // context.  Leaving aside that difference, the rest of the two methods should
    // be the same and should be maintained together.

    // @TODO: write barrier!

    MethodTable* pMT;
    OBJECTREF clone;
    LPVOID pvSrc;
    LPVOID pvClone;
    DWORD cb;

    pMT = pargs->m_pThis->GetMethodTable();

    // assert that String has overloaded the Clone() method
    _ASSERTE(pMT != g_pStringClass);

    cb = pMT->GetBaseSize() - sizeof(ObjHeader);
    if (pMT->IsArray()) {
        // @TODO: step through array cloning
        //        _ASSERTE(!"array cloning hasn't been tested yet");

        BASEARRAYREF base = (BASEARRAYREF)pargs->m_pThis;
        cb += base->GetNumComponents() * pMT->GetComponentSize();

        // @TODO: it would be nice to get a non-zeroed array,
        //        since we're gonna blast over it anyway
        clone = DupArrayForCloning(base);
    } else {
        // @TODO: it would be nice to get a non-zeroed object,
        //        since we're gonna blast over it anyway
        // We don't need to call the <cinit> because we know
        //  that it has been called....(It was called before this was created)
        clone = AllocateObject(pMT);
    }

    // copy contents of "this" to the clone
    *((OBJECTREF *)&pvSrc) = pargs->m_pThis;
    *((OBJECTREF *)&pvClone) = clone;
        
    memcpyGCRefs(pvClone, pvSrc, cb);
    return pvClone;
}

INT32 __stdcall ObjectNative::WaitTimeout(WaitTimeoutArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    if ((pargs->m_Timeout < 0) && (pargs->m_Timeout != INFINITE_TIMEOUT))
        COMPlusThrowArgumentOutOfRange(L"millisecondsTimeout", L"ArgumentOutOfRange_NeedNonNegNum");

    OBJECTREF   or = pargs->m_pThis;
    return or->Wait(pargs->m_Timeout,pargs->m_exitContext);
}

void __stdcall ObjectNative::Pulse(NoArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    OBJECTREF   or = pargs->m_pThis;
    or->Pulse();
}

void __stdcall ObjectNative::PulseAll(NoArgs *pargs)
{
    THROWSCOMPLUSEXCEPTION();

    ASSERT(pargs != NULL);
    if (pargs->m_pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    OBJECTREF   or = pargs->m_pThis;
    or->PulseAll();
}

// This method will return a Class object for the object
//  iff the Class object has already been created.  
//  If the Class object doesn't exist then you must call the GetClass() method.
FCIMPL1(Object*, ObjectNative::GetExistingClass, Object* thisRef) {

    if (thisRef == NULL)
        FCThrow(kNullReferenceException);

    
    EEClass* pClass = thisRef->GetTrueMethodTable()->m_pEEClass;

    // For marshalbyref classes, let's just punt for the moment
    if (pClass->IsMarshaledByRef())
        return 0;

    OBJECTREF refClass;
    if (pClass->IsArrayClass()) {
        // This code is essentially a duplicate of the code in GetClass, done for perf reasons.
        ArrayBase* array = (ArrayBase*) OBJECTREFToObject(thisRef);
        TypeHandle arrayType;
        // Erect a GC Frame around the call to GetTypeHandle, since on the first call,
        // it can call AppDomain::RaiseTypeResolveEvent, which allocates Strings and calls
        // a user-provided managed callback.  Yes, we have to do an allocation to do a
        // lookup, since TypeHandles are used as keys.  Yes this sucks.  -- BrianGru, 9/12/2000
        HELPER_METHOD_FRAME_BEGIN_RET_1(array);
        arrayType = array->GetTypeHandle();
        refClass = COMClass::QuickLookupExistingArrayClassObj(arrayType.AsArray());
        HELPER_METHOD_FRAME_END();
    }
    else 
        refClass = pClass->GetExistingExposedClassObject();
    return OBJECTREFToObject(refClass);
}
FCIMPLEND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\commtmemberinfomap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Map associated with a ComMethodTable that contains
**          information on its members.
**  
**      //  %%Created by: dmortens
===========================================================*/

#include "common.h"
#include "ComMTMemberInfoMap.h"
#include "ComCallWrapper.h"
#include "TlbExport.h"
#include "Field.h"

#define BASE_OLEAUT_DISPID 0x60020000

static LPCWSTR szDefaultValue           = L"Value";
static LPCWSTR szGetEnumerator          = L"GetEnumerator";
static LPCSTR szIEnumeratorClass        = "System.Collections.IEnumerator";

// ============================================================================
// Token and module pair hashtable.
// ============================================================================
EEHashEntry_t * EEModuleTokenHashTableHelper::AllocateEntry(EEModuleTokenPair *pKey, BOOL bDeepCopy, void *pHeap)
{
   _ASSERTE(!bDeepCopy && "Deep copy is not supported by the EEModuleTokenHashTableHelper");

    EEHashEntry_t *pEntry = (EEHashEntry_t *) new BYTE[SIZEOF_EEHASH_ENTRY + sizeof(EEModuleTokenPair)];
    if (!pEntry)
        return NULL;

    EEModuleTokenPair *pEntryKey = (EEModuleTokenPair *) pEntry->Key;
    pEntryKey->m_tk = pKey->m_tk;
    pEntryKey->m_pModule = pKey->m_pModule;

    return pEntry;
} // EEHashEntry_t * EEModuleTokenHashTableHelper::AllocateEntry()


void EEModuleTokenHashTableHelper::DeleteEntry(EEHashEntry_t *pEntry, AllocationHeap Heap)
{
    delete [] pEntry;
} // void EEModuleTokenHashTableHelper::DeleteEntry()


BOOL EEModuleTokenHashTableHelper::CompareKeys(EEHashEntry_t *pEntry, EEModuleTokenPair *pKey)
{
    EEModuleTokenPair *pEntryKey = (EEModuleTokenPair*) pEntry->Key;

    // Compare the token.
    if (pEntryKey->m_tk != pKey->m_tk)
        return FALSE;

    // Compare the module.
    if (pEntryKey->m_pModule != pKey->m_pModule)
        return FALSE;

    return TRUE;
} // BOOL EEModuleTokenHashTableHelper::CompareKeys()


DWORD EEModuleTokenHashTableHelper::Hash(EEModuleTokenPair *pKey)
{
    return (DWORD)((size_t)pKey->m_tk + (size_t)pKey->m_pModule); // @TODO WIN64 - Pointer Truncation
} // DWORD EEModuleTokenHashTableHelper::Hash()


EEModuleTokenPair *EEModuleTokenHashTableHelper::GetKey(EEHashEntry_t *pEntry)
{
    return (EEModuleTokenPair*)pEntry->Key;
} // EEModuleTokenPair *EEModuleTokenHashTableHelper::GetKey()


// ============================================================================
// ComMethodTable member info map.
// ============================================================================
void ComMTMemberInfoMap::Init()
{    
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    mdTypeDef   td;                     // Token for the class.
    const char  *pData;                 // Pointer to a custom attribute blob.
    ULONG       cbData;                 // Size of a custom attribute blob.
    EEClass     *pClass = m_pMT->GetClass();

    // Get the TypeDef and some info about it.
    td = pClass->GetCl();

    m_bHadDuplicateDispIds = FALSE;

    // See if there is a default property.
    m_DefaultProp[0] = 0; // init to 'none'.
    hr = pClass->GetMDImport()->GetCustomAttributeByName(
        td, INTEROP_DEFAULTMEMBER_TYPE, reinterpret_cast<const void**>(&pData), &cbData);
    if (hr == S_FALSE)
    {
        hr = pClass->GetMDImport()->GetCustomAttributeByName(
            td, "System.Reflection.DefaultMemberAttribute", reinterpret_cast<const void**>(&pData), &cbData);
    }
    if (hr == S_OK && cbData > 5 && pData[0] == 1 && pData[1] == 0)
    {   // Adjust for the prolog.
        pData += 2;
        cbData -= 2;
        // Get the length, and pointer to data.
        ULONG iLen;
        const char *pbData;
        pbData = reinterpret_cast<const char*>(CPackedLen::GetData(pData, &iLen));
        // If the string fits in the buffer, keep it.
        if (iLen <= cbData - (pbData-pData))
        {   // Copy the data, then null terminate (CA blob's string may not be).
            IfFailThrow(m_DefaultProp.ReSize(iLen+1));
            memcpy(m_DefaultProp.Ptr(), pbData, iLen);
            m_DefaultProp[iLen] = 0;
        }
    }

    // Set up the properties for the type.
    if (m_pMT->IsInterface())
    {
        SetupPropsForInterface();
    }
    else
    {
        SetupPropsForIClassX();
    }

    // Initiliaze the hashtable.
    m_TokenToComMTMethodPropsMap.Init((DWORD)m_MethodProps.Size(), NULL, NULL);

    // Populate the hashtable that maps from token to member info.
    PopulateMemberHashtable();
} // HRESULT ComMTMemberInfoMap::Init()


ComMTMethodProps *ComMTMemberInfoMap::GetMethodProps(mdToken tk, Module *pModule)
{
    EEModuleTokenPair TokenModulePair(tk, pModule);
    HashDatum Data;
    
    if (m_TokenToComMTMethodPropsMap.GetValue(&TokenModulePair, &Data))
    {
        return (ComMTMethodProps *)Data;
    }
    else
    {
        return NULL;
    }
} // ComMTMethodProps *ComMTMemberInfoMap::GetMethodProps()


void ComMTMemberInfoMap::SetupPropsForIClassX()
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    DWORD       dwTIFlags=0;            // TypeLib flags.
    ComMethodTable *pCMT;               // ComMethodTable for the Class Vtable.
    MethodDesc  *pMeth;                 // A method descriptor.
    ComCallMethodDesc *pFieldMeth;      // A method descriptor for a field.
    FieldDesc   *pField;                // Actual FieldDesc for field.
    DWORD       nSlots;                 // Number of vtable slots.
    UINT        i;                      // Loop control.
    LPCUTF8     pszName;                // A name in UTF8.
    CQuickArray<WCHAR> rName;           // A name.
    int         cVisibleMembers = 0;    // The count of methods that are visible to COM.
    ULONG       dispid;                 // A dispid.
    SHORT       oVftBase;                 // Offset in vtable, if not system defined.

    // Get the vtable for the class.
    pCMT = ComCallWrapperTemplate::SetupComMethodTableForClass(m_pMT, TRUE);
    nSlots = pCMT->GetSlots();

    // IDispatch derived.
    oVftBase = 7 * sizeof(void*);

    // Build array of descriptive information.
    IfFailThrow(m_MethodProps.ReSize(nSlots));
    for (i=0; i<nSlots; ++i)
    {
        if (pCMT->IsSlotAField(i))
        {
            // Fields better come in pairs.
            _ASSERTE(i < nSlots-1);

            pFieldMeth = pCMT->GetFieldCallMethodDescForSlot(i);
            pField = pFieldMeth->GetFieldDesc();

            DWORD dwFlags = pField->GetMDImport()->GetFieldDefProps(pField->GetMemberDef());
            BOOL bReadOnly = IsFdInitOnly(dwFlags) || IsFdLiteral(dwFlags);
            BOOL bFieldVisibleFromCom = IsMemberVisibleFromCom(pField->GetMDImport(), pField->GetMemberDef(), mdTokenNil);
            // Get the assigned dispid, or DISPID_UNKNOWN.
            hr = pField->GetMDImport()->GetDispIdOfMemberDef(pField->GetMemberDef(), &dispid);

            m_MethodProps[i].pMeth = (MethodDesc*)pFieldMeth; //pFieldMeth->GetFieldDesc();
            m_MethodProps[i].semantic = FieldSemanticOffset + (pFieldMeth->IsFieldGetter() ? msGetter : msSetter);
            m_MethodProps[i].property = mdPropertyNil;
            pszName = pField->GetMDImport()->GetNameOfFieldDef(pField->GetMemberDef());
            IfFailThrow(Utf2Quick(pszName, rName));
            m_MethodProps[i].pName = reinterpret_cast<WCHAR*>(m_sNames.Alloc((int)(wcslen(rName.Ptr())*sizeof(WCHAR)+2)));
            IfNullThrow(m_MethodProps[i].pName);
            wcscpy(m_MethodProps[i].pName, rName.Ptr());          
            m_MethodProps[i].dispid = dispid;
            m_MethodProps[i].oVft = 0;
            m_MethodProps[i].bMemberVisible = bFieldVisibleFromCom && (!bReadOnly || pFieldMeth->IsFieldGetter());
            m_MethodProps[i].bFunction2Getter = FALSE;

            ++i;
            pFieldMeth = pCMT->GetFieldCallMethodDescForSlot(i);
            m_MethodProps[i].pMeth = (MethodDesc*)pFieldMeth; //pFieldMeth->GetFieldDesc();
            m_MethodProps[i].semantic = FieldSemanticOffset + (pFieldMeth->IsFieldGetter() ? msGetter : msSetter);
            m_MethodProps[i].property = i - 1;
            m_MethodProps[i].dispid = dispid;
            m_MethodProps[i].oVft = 0;
            m_MethodProps[i].bMemberVisible = bFieldVisibleFromCom && (!bReadOnly || pFieldMeth->IsFieldGetter());
            m_MethodProps[i].bFunction2Getter = FALSE;
        }
        else
        {
            // Retrieve the method desc on the current class. This involves looking up the method
            // desc in the vtable if it is a virtual method.
            pMeth = pCMT->GetMethodDescForSlot(i);
            if (pMeth->IsVirtual())
                pMeth = m_pMT->GetClass()->GetUnknownMethodDescForSlot(pMeth->GetSlot());
            m_MethodProps[i].pMeth = pMeth;

            // Retrieve the properties of the method.
            GetMethodPropsForMeth(pMeth, i, m_MethodProps, m_sNames);

            // Turn off dispids that look system-assigned.
            if (m_MethodProps[i].dispid >= 0x40000000 && m_MethodProps[i].dispid <= 0x7fffffff)
                m_MethodProps[i].dispid = DISPID_UNKNOWN;
        }
    }

    // COM+ supports properties in which the getter and setter have different signatures,
    //  but TypeLibs do not.  Look for mismatched signatures, and break apart the properties.
    for (i=0; i<nSlots; ++i)
    {   // Is it a property, but not a field?  Fields only have one signature, so they are always OK.
        if (TypeFromToken(m_MethodProps[i].property) != mdtProperty &&
            m_MethodProps[i].semantic < FieldSemanticOffset)
        {
            // Get the indices of the getter and setter.
            size_t ixSet, ixGet;
            if (m_MethodProps[i].semantic == msGetter)
                ixGet = i, ixSet = m_MethodProps[i].property;
            else
            {   _ASSERTE(m_MethodProps[i].semantic == msSetter);
                ixSet = i, ixGet = m_MethodProps[i].property;
            }

            // Get the signatures.
            PCCOR_SIGNATURE pbGet, pbSet;
            ULONG           cbGet, cbSet;
            pMeth = pCMT->GetMethodDescForSlot((unsigned)ixSet);
            pMeth->GetSig(&pbSet, &cbSet);

            pMeth = pCMT->GetMethodDescForSlot((unsigned)ixGet);
            pMeth->GetSig(&pbGet, &cbGet);

            // Now reuse ixGet, ixSet to index through signature.
            ixGet = ixSet = 0;

            // Eat calling conventions.
            ULONG callconv;
            ixGet += CorSigUncompressData(&pbGet[ixGet], &callconv);
            _ASSERTE((callconv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_FIELD);
            ixSet += CorSigUncompressData(&pbSet[ixSet], &callconv);
            _ASSERTE((callconv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_FIELD);

            // Argument count.
            ULONG acGet, acSet;
            ixGet += CorSigUncompressData(&pbGet[ixGet], &acGet);
            ixSet += CorSigUncompressData(&pbSet[ixSet], &acSet);

            // Setter must take exactly on more parameter.
            if (acSet != acGet+1)
                goto UnLink;

            //@todo: parse rest of signature.

            // All matched, so on to next.
            continue;

            // Unlink the properties, and turn them into ordinary functions.
UnLink:
            // Get the indices of the getter and setter (again).
            if (m_MethodProps[i].semantic == msGetter)
                ixGet = i, ixSet = m_MethodProps[i].property;
            else
                ixSet = i, ixGet = m_MethodProps[i].property;

            // Eliminate the semantics.
            m_MethodProps[ixGet].semantic = 0;
            m_MethodProps[ixSet].semantic = 0;

            // Decorate the names.
            // These are the names of properties when properties don't have signatures
            // that match, and the "get" and "set" below don't have to match the CLS
            // property names.  This is an obscure corner case.  Decided by BillEv, 2/3/2000
            m_MethodProps[i].pName = m_MethodProps[m_MethodProps[i].property].pName;
            WCHAR *pNewName;
            pNewName = reinterpret_cast<WCHAR*>(m_sNames.Alloc((int)((4+wcslen(m_MethodProps[ixGet].pName))*sizeof(WCHAR)+2)));
            IfNullThrow(pNewName);
            wcscpy(pNewName, L"get");
            wcscat(pNewName, m_MethodProps[ixGet].pName);
            m_MethodProps[ixGet].pName = pNewName;
            pNewName = reinterpret_cast<WCHAR*>(m_sNames.Alloc((int)((4+wcslen(m_MethodProps[ixSet].pName))*sizeof(WCHAR)+2)));
            IfNullThrow(pNewName);
            wcscpy(pNewName, L"set");
            wcscat(pNewName, m_MethodProps[ixSet].pName);
            m_MethodProps[ixSet].pName = pNewName;

            // If the methods share a dispid, kill them both.
            if (m_MethodProps[ixGet].dispid == m_MethodProps[ixSet].dispid)
                m_MethodProps[ixGet].dispid = m_MethodProps[ixSet].dispid = DISPID_UNKNOWN;

            // Unlink from each other.
            m_MethodProps[i].property = mdPropertyNil;

        }
    }

    // Assign vtable offsets.
    for (i = 0; i < nSlots; ++i)
    {
        SHORT oVft = oVftBase + static_cast<SHORT>(i * sizeof(void*));
        m_MethodProps[i].oVft = oVft;
    }

    // Resolve duplicate dispids.
    EliminateDuplicateDispIds(m_MethodProps, nSlots);

    // Pick something for the "Value".
    AssignDefaultMember(m_MethodProps, m_sNames, nSlots);

    // Check to see if there is something to assign DISPID_NEWENUM to.
    AssignNewEnumMember(m_MethodProps, m_sNames, nSlots);

    // Resolve duplicate names.
    EliminateDuplicateNames(m_MethodProps, m_sNames, nSlots);

    // Do some PROPERTYPUT/PROPERTYPUTREF translation.
    FixupPropertyAccessors(m_MethodProps, m_sNames, nSlots);

    // Fix up all properties so that they point to their shared name.
    for (i=0; i<nSlots; ++i)
    {
        if (TypeFromToken(m_MethodProps[i].property) != mdtProperty)
        {
            m_MethodProps[i].pName = m_MethodProps[m_MethodProps[i].property].pName;
            m_MethodProps[i].dispid = m_MethodProps[m_MethodProps[i].property].dispid;
        }
    }

    // Assign default dispids.
    AssignDefaultDispIds();
} // void ComMTMemberInfoMap::SetupPropsForIClassX()


void ComMTMemberInfoMap::SetupPropsForInterface()
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    ULONG       iMD;                      // Loop control.
    ULONG       ulComSlotMin = ULONG_MAX; // Find first COM+ slot.
    ULONG       ulComSlotMax = 0;         // Find last COM+ slot.
    int         bSlotRemap=false;         // True if slots need to be mapped, due to holes.
    SHORT       oVftBase;                 // Offset in vtable, if not system defined.
    ULONG       ulIface;                  // Is this interface [dual]?
    MethodDesc  *pMeth;                   // A MethodDesc.
    CQuickArray<int> rSlotMap;            // Array to map vtable slots.
    EEClass     *pClass = m_pMT->GetClass(); // Class to set up properties for.
    DWORD       nSlots;                 // Number of vtable slots.

    // Retrieve the number of vtable slots the interface has.
    nSlots = pClass->GetNumVtableSlots();

    // IDispatch or IUnknown derived?
    IfFailThrow(pClass->GetMDImport()->GetIfaceTypeOfTypeDef(pClass->GetCl(), &ulIface));
    if (ulIface != ifVtable)
    {   
        // IDispatch derived.
        oVftBase = 7 * sizeof(void*);
    }
    else
    {   // IUnknown derived.
        oVftBase = 3 * sizeof(void*);
    }

    // Find lowest slot number.
    for (iMD=0; iMD < nSlots; ++iMD)
    {
        MethodDesc* pMD = pClass->GetMethodDescForSlot(iMD);
        _ASSERTE(pMD != NULL);
        ULONG tmp = pMD->GetComSlot();

        if (tmp < ulComSlotMin)
            ulComSlotMin = tmp;
        if (tmp > ulComSlotMax)
            ulComSlotMax = tmp;
    }

    if (ulComSlotMax-ulComSlotMin >= nSlots)
    {
        bSlotRemap = true;
        // Resize the array.
        rSlotMap.ReSize(ulComSlotMax+1);
        // Init to "slot not used" value of -1.
        memset(rSlotMap.Ptr(), -1, rSlotMap.Size()*sizeof(int));
        // See which vtable slots are used.
        for (iMD=0; iMD<pClass->GetNumVtableSlots(); ++iMD)
        {
            MethodDesc* pMD = pClass->GetMethodDescForSlot(iMD);
            _ASSERTE(pMD != NULL);
            ULONG tmp = pMD->GetComSlot();
            rSlotMap[tmp] = 0;
        }
        // Assign incrementing table indices to the slots.
        ULONG ix=0;
        for (iMD=0; iMD<=ulComSlotMax; ++iMD)
            if (rSlotMap[iMD] != -1)
                rSlotMap[iMD] = ix++;
    }

    // Iterate over the members in the interface and build the list of methods.
    IfFailThrow(m_MethodProps.ReSize(nSlots));
    for (iMD=0; iMD<pClass->GetNumVtableSlots(); ++iMD)
    {
        pMeth = pClass->GetMethodDescForSlot(iMD);
        if (pMeth != NULL)
        {
            ULONG ixSlot = pMeth->GetComSlot();
            if (bSlotRemap)
                ixSlot = rSlotMap[ixSlot];
            else
                ixSlot -= ulComSlotMin;

            m_MethodProps[ixSlot].pMeth = pMeth;
        }
    }

    // Now have a list of methods in vtable order.  Go through and build names, semantic.
    for (iMD=0; iMD < nSlots; ++iMD)
    {
        pMeth = m_MethodProps[iMD].pMeth;
        GetMethodPropsForMeth(pMeth, iMD, m_MethodProps, m_sNames);
    }

    // Assign vtable offsets.
    for (iMD=0; iMD < nSlots; ++iMD)
    {
        SHORT oVft = oVftBase + static_cast<SHORT>((m_MethodProps[iMD].pMeth->GetComSlot() -ulComSlotMin) * sizeof(void*));
        m_MethodProps[iMD].oVft = oVft;
    }

    // Resolve duplicate dispids.
    EliminateDuplicateDispIds(m_MethodProps, nSlots);

    // Pick something for the "Value".
    AssignDefaultMember(m_MethodProps, m_sNames, nSlots);

    // Check to see if there is something to assign DISPID_NEWENUM to.
    AssignNewEnumMember(m_MethodProps, m_sNames, nSlots);

    // Take care of name collisions due to overloading, inheritance.
    EliminateDuplicateNames(m_MethodProps, m_sNames, nSlots);

    // Do some PROPERTYPUT/PROPERTYPUTREF translation.
    FixupPropertyAccessors(m_MethodProps, m_sNames, nSlots);

    // Fix up all properties so that they point to their shared name.
    for (iMD=0; iMD<pClass->GetNumVtableSlots(); ++iMD)
    {
        if (TypeFromToken(m_MethodProps[iMD].property) != mdtProperty)
        {
            m_MethodProps[iMD].pName = m_MethodProps[m_MethodProps[iMD].property].pName;
            m_MethodProps[iMD].dispid = m_MethodProps[m_MethodProps[iMD].property].dispid;
        }
    }

    // If the interface is IDispatch based, then assign the default dispids.
    if (ulIface != ifVtable)
        AssignDefaultDispIds();
} // void ComMTMemberInfoMap::SetupPropsForInterface()


// ============================================================================
// Given a MethodDesc*, get the name of the method or property that the
//  method is a getter/setter for, plus the semantic for getter/setter.
//  In the case of properties, look for a previous getter/setter for this
//  property, and if found, link them, so that only one name participates in
//  name decoration.
// ============================================================================
void ComMTMemberInfoMap::GetMethodPropsForMeth(
    MethodDesc  *pMeth,                 // MethodDesc * for method.
    int         ix,                     // Slot.
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    CDescPool   &sNames)                // Pool of possibly decorated names.
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;                     // A result.
    LPCUTF8     pszName;                // Name in UTF8.
    CQuickArray<WCHAR> rName;           // Buffer for unicode conversion.
    LPCWSTR     pName;                  // Pointer to a name, after possible substitution.
    mdProperty  pd;                     // Property token.
    LPCUTF8     pPropName;              // Pointer to propterty name.
    ULONG       uSemantic;              // Property semantic.
    ULONG       dispid;                 // A property dispid.

    // Get any user-assigned dispid.
    rProps[ix].dispid = pMeth->GetComDispid();

    // Assume system-defined vtable offsets.
    rProps[ix].oVft = 0;

    // Generally don't munge function into a getter.
    rProps[ix].bFunction2Getter = FALSE;
    
    // See if there is property information for this member.
    hr = pMeth->GetMDImport()->GetPropertyInfoForMethodDef(pMeth->GetMemberDef(),
        &pd, &pPropName, &uSemantic);
    IfFailThrow(hr);
    if (hr == S_OK)
    {   // There is property information.  
        // See if there a method is already associated with this property.
        rProps[ix].property = pd;
        for (int i=ix-1; i>=0; --i)
        {   // Same property in same scope?
            if (rProps[i].property == pd && 
                rProps[i].pMeth->GetMDImport() == pMeth->GetMDImport())
            {
                rProps[ix].property = i;
                break;
            }
        }
        // If there wasn't another method for this property, save the name on
        //  this method, for duplicate elimination.
        if (i < 0)
        {   // Save the name.  Have to convert from UTF8.
            int iLen = WszMultiByteToWideChar(CP_UTF8, 0, pPropName, -1, 0, 0);
            rProps[ix].pName = reinterpret_cast<WCHAR*>(sNames.Alloc(iLen*sizeof(WCHAR)));
            IfNullThrow(rProps[ix].pName);
            WszMultiByteToWideChar(CP_UTF8, 0, pPropName, -1, rProps[ix].pName, iLen*sizeof(WCHAR));
            // Check whether the property has a dispid attribute.
            hr = pMeth->GetMDImport()->GetDispIdOfMemberDef(pd, &dispid);
            if (dispid != DISPID_UNKNOWN)
                rProps[ix].dispid = dispid;
            // If this is the default property, and the method or property doesn't have a dispid already, 
            //  use DISPID_DEFAULT.
            if (rProps[ix].dispid == DISPID_UNKNOWN)
            {
                if (strcmp(pPropName, m_DefaultProp.Ptr()) == 0)
                {
                    rProps[ix].dispid = DISPID_VALUE;
                    // Don't want to try to set multiple as default property.
                    m_DefaultProp[0] = 0;
                }
            }
        }
        // Save the semantic.
        rProps[ix].semantic = static_cast<USHORT>(uSemantic);

        // Determine if the property is visible from COM.
        rProps[ix].bMemberVisible = IsMemberVisibleFromCom(pMeth->GetMDImport(), pd, pMeth->GetMemberDef());
    }
    else
    {   // Not a property, just an ordinary method.
        rProps[ix].property = mdPropertyNil;
        rProps[ix].semantic = 0;
        // Get the name.
        pszName = pMeth->GetName();
        if (pszName == NULL)
            IfFailThrow(E_FAIL);
        if (_stricmp(pszName, szInitName) == 0)
            pName = szInitNameUse;
        else
        {
            IfFailThrow(Utf2Quick(pszName, rName));
            pName = rName.Ptr();
            // If this is a "ToString" method, make it a property get.
            if (_wcsicmp(pName, szDefaultToString) == 0)
            {
                rProps[ix].semantic = msGetter;
                rProps[ix].bFunction2Getter = TRUE;
            }
        }
        rProps[ix].pName = reinterpret_cast<WCHAR*>(sNames.Alloc((int)(wcslen(pName)*sizeof(WCHAR)+2)));
        IfNullThrow(rProps[ix].pName);
        wcscpy(rProps[ix].pName, pName);

        // Determine if the method is visible from COM.
        rProps[ix].bMemberVisible = !pMeth->IsArray() && IsMemberVisibleFromCom(pMeth->GetMDImport(), pMeth->GetMemberDef(), mdTokenNil);
    }
} // void ComMTMemberInfoMap::GetMethodPropsForMeth()


// ============================================================================
// This structure and class definition are used to implement the hash table
// used to make sure that there are no duplicate class names.
// ============================================================================
struct WSTRHASH : HASHLINK
{
    LPCWSTR     szName;         // Ptr to hashed string.
}; // struct WSTRHASH : HASHLINK

class CWStrHash : public CChainedHash<WSTRHASH>
{
public:
    virtual bool InUse(WSTRHASH *pItem)
    { return (pItem->szName != NULL); }

    virtual void SetFree(WSTRHASH *pItem)
    { pItem->szName = NULL; }

    virtual ULONG Hash(const void *pData)
    { 
        // Do case-insensitive hash
        return (HashiString(reinterpret_cast<LPCWSTR>(pData))); 
    }

    virtual int Cmp(const void *pData, void *pItem){
        return _wcsicmp(reinterpret_cast<LPCWSTR>(pData),reinterpret_cast<WSTRHASH*>(pItem)->szName);
    }
}; // class CWStrHash : public CChainedHash<WSTRHASH>


// ============================================================================
// Process the function names for an interface, checking for duplicates.  If
//  any duplicates are found, decorate the names with "_n".
//
//  NOTE:   Two implementations are provided, one using nested for-loops and a
//          second which implements a hashtable.  The first is faster when
//          the number of elements is less than 20, otherwise the hashtable
//          is the way to go.  The code-size of the first implementation is 574
//          bytes.  The hashtable code is 1120 bytes.
// ============================================================================
void ComMTMemberInfoMap::EliminateDuplicateNames(
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    CDescPool   &sNames,                // Pool of possibly decorated names.
    UINT        nSlots)                 // Count of entries
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr=S_OK;                // A result.
    CQuickBytes qb;
    LPWSTR      rcName = (LPWSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(WCHAR));
    UINT        iCur;
    ULONG       ulIface;                // VTBL, Dispinterface, or IDispatch.
    ULONG       cBaseNames;             // Count of names in base interface.
    BOOL        bDup;                   // Is the name a duplicate?
    EEClass     *pClass = m_pMT->GetClass(); // Class to set up properties for.
    
    // Tables of names of methods on IUnknown and IDispatch.
    static WCHAR *(rBaseNames[]) = 
    {    
        L"QueryInterface",
        L"AddRef",
        L"Release",
        L"GetTypeInfoCount",
        L"GetTypeInfo",
        L"GetIDsOfNames",
        L"Invoke"
    };
    
    // Determine which names are in the base interface.
    IfFailThrow(pClass->GetMDImport()->GetIfaceTypeOfTypeDef(pClass->GetCl(), &ulIface));
    if (ulIface == ifVtable)    // Is this IUnknown derived?
        cBaseNames = 3;
    else
    if (ulIface == ifDual)      // Is it IDispatch derived?
        cBaseNames = 7;
    else
        cBaseNames = 0;         // Is it pure dispinterface?
    
    if (nSlots < 2 && cBaseNames == 0) // we're wasting time if there aren't at least two items!
        return;
    
    else if (nSlots < 20)
    {
        // Eliminate duplicates.
        for (iCur=0; iCur<nSlots; ++iCur)
        {
            UINT iTst, iSuffix, iTry;
            // If a property with an associated (lower indexed) property, don't need to examine it.
            if (TypeFromToken(rProps[iCur].property) != mdtProperty)
                continue;
            // If the member is not visible to COM then we don't need to examine it.
            if (!rProps[iCur].bMemberVisible)
                continue;
            
            // Check for duplicate with already accepted member names.
            bDup = FALSE;
            for (iTst=0; !bDup && iTst<iCur; ++iTst)
            {
                // If a property with an associated (lower indexed) property, don't need to examine it.
                if (TypeFromToken(rProps[iTst].property) != mdtProperty)
                    continue;
                // If the member is not visible to COM then we don't need to examine it.
                if (!rProps[iTst].bMemberVisible)
                    continue;
                if (_wcsicmp(rProps[iCur].pName, rProps[iTst].pName) == 0)
                    bDup = TRUE;
            }
            
            // If OK with other members, check with base interface names.
            for (iTst=0; !bDup && iTst<cBaseNames; ++iTst)
            {
                if (_wcsicmp(rProps[iCur].pName, rBaseNames[iTst]) == 0)
                    bDup = TRUE;
            }
            
            // If the name is a duplicate, decorate it.
            if (bDup)
            {   // Duplicate.
                DWORD cchName = (DWORD) wcslen(rProps[iCur].pName);
                if (cchName > MAX_CLASSNAME_LENGTH-cchDuplicateDecoration)
                    cchName = MAX_CLASSNAME_LENGTH-cchDuplicateDecoration;

                wcsncpy(rcName, rProps[iCur].pName, cchName);
                LPWSTR pSuffix = rcName + cchName;
                for (iSuffix=2; ; ++iSuffix)
                {   // Form a new name.
                    _snwprintf(pSuffix, cchDuplicateDecoration, szDuplicateDecoration, iSuffix);
                    // Compare against ALL names.
                    for (iTry=0; iTry<nSlots; ++iTry)
                    {
                        // If a property with an associated (lower indexed) property, 
                        // or iTry is the same as iCur, don't need to examine it.
                        if (TypeFromToken(rProps[iTry].property) != mdtProperty || iTry == iCur)
                            continue;
                        if (_wcsicmp(rProps[iTry].pName, rcName) == 0)
                            break;
                    }
                    // Did we make it all the way through?  If so, we have a winner.
                    if (iTry == nSlots)
                        break;
                }
                // Remember the new name.
                rProps[iCur].pName = reinterpret_cast<WCHAR*>(sNames.Alloc((int)(wcslen(rcName)*sizeof(WCHAR)+2)));
                IfNullThrow(rProps[iCur].pName);
                wcscpy(rProps[iCur].pName, rcName);
                // Don't need to look at this iCur any more, since we know it is completely unique.
            }
        }
    }
    else
    {

        CWStrHash   htNames;
        WSTRHASH    *pItem;
        CUnorderedArray<ULONG, 10> uaDuplicates;    // array to keep track of non-unique names

        // Add the base interface names.   Already know there are no duplicates there.
        for (iCur=0; iCur<cBaseNames; ++iCur)
        {
            pItem = htNames.Add(rBaseNames[iCur]);
            IfNullThrow(pItem);
            pItem->szName = rBaseNames[iCur];
        }
        
        for (iCur=0; iCur<nSlots; iCur++)
        {
            // If a property with an associated (lower indexed) property, don't need to examine it.
            if (TypeFromToken(rProps[iCur].property) != mdtProperty)
                continue;

            // If the member is not visible to COM then we don't need to examine it.
            if (!rProps[iCur].bMemberVisible)
                continue;

            // see if name is already in table
            if (htNames.Find(rProps[iCur].pName) == NULL)
            {
                // name not found, so add it.
                pItem = htNames.Add(rProps[iCur].pName);
                IfNullThrow(pItem);
                pItem->szName = rProps[iCur].pName;
            }
            else
            {
                // name is a duplicate, so keep track of this index for later decoration
                ULONG *piAppend = uaDuplicates.Append();
                IfNullThrow(piAppend);
                *piAppend = iCur;
            }
        }

        ULONG i;
        ULONG iSize = uaDuplicates.Count();
        ULONG *piTable = uaDuplicates.Table();

        for (i = 0; i < iSize; i++)
        {
            // get index to decorate
            iCur = piTable[i];
                
            // Copy name into local buffer
            DWORD cchName = (DWORD) wcslen(rProps[iCur].pName);
            if (cchName > MAX_CLASSNAME_LENGTH-cchDuplicateDecoration)
                cchName = MAX_CLASSNAME_LENGTH-cchDuplicateDecoration;
            
            wcsncpy(rcName, rProps[iCur].pName, cchName);

            LPWSTR pSuffix = rcName + cchName;
            UINT iSuffix   = 2;
        
            // We know this is a duplicate, so immediately decorate name.
            do 
            {
                _snwprintf(pSuffix, cchDuplicateDecoration, szDuplicateDecoration, iSuffix);
                iSuffix++;

            // keep going while we find this name in the hashtable
            } while (htNames.Find(rcName) != NULL);

            // Now rcName has an acceptable (unique) name.  Remember the new name.
            rProps[iCur].pName = reinterpret_cast<WCHAR*>(sNames.Alloc((int)((wcslen(rcName)+1) * sizeof(WCHAR))));
            IfNullThrow(rProps[iCur].pName);
            wcscpy(rProps[iCur].pName, rcName);
            
            // Stick it in the table.
            pItem = htNames.Add(rProps[iCur].pName);
            IfNullThrow(pItem);
            pItem->szName = rProps[iCur].pName;
        }
    }
} // void ComMTMemberInfoMap::EliminateDuplicateNames()


// ============================================================================
// Process the dispids for an interface, checking for duplicates.  If
//  any duplicates are found, change them to DISPID_UNKNOWN.
// ============================================================================
void ComMTMemberInfoMap::EliminateDuplicateDispIds(
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    UINT        nSlots)                 // Count of entries
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr=S_OK;                // A result.
    UINT        ix;                     // Loop control.
    UINT        cDispids = 0;           // Dispids actually assigned.
    CQuickArray<ULONG> rDispid;         // Array of dispids.
    
    // Count the Dispids.
    for (ix=0; ix<nSlots; ++ix)
    {
        if (TypeFromToken(rProps[ix].property) == mdtProperty && rProps[ix].dispid != DISPID_UNKNOWN && rProps[ix].bMemberVisible)
            ++cDispids;
    }

    // If not at least two, can't be a duplicate.
    if (cDispids < 2) 
        return;

    // Make space for the dispids.
    IfFailThrow(rDispid.ReSize(cDispids));

    // Collect the Dispids.
    cDispids = 0;
    for (ix=0; ix<nSlots; ++ix)
    {
        if (TypeFromToken(rProps[ix].property) == mdtProperty && rProps[ix].dispid != DISPID_UNKNOWN && rProps[ix].bMemberVisible)
            rDispid[cDispids++] = rProps[ix].dispid;
    }

    // Sort the dispids.  Scope avoids "initialization bypassed by goto" error.
    {
    CQuickSort<ULONG> sorter(rDispid.Ptr(), cDispids);
    sorter.Sort();
    }

    // Look through the sorted dispids, looking for duplicates.
    for (ix=0; ix<cDispids-1; ++ix)
    {   // If a duplicate is found...
        if (rDispid[ix] == rDispid[ix+1])
        {   
            m_bHadDuplicateDispIds = TRUE;
            // iterate over all slots...
            for (UINT iy=0; iy<nSlots; ++iy)
            {   // and replace every instance of the duplicate dispid with DISPID_UNKNOWN.
                if (rProps[iy].dispid == rDispid[ix])
                {   // Mark the dispid so the system will assign one.
                    rProps[iy].dispid = DISPID_UNKNOWN;
                }
            }
        }
        // Skip through the duplicate range.
        while (ix <cDispids-1 && rDispid[ix] == rDispid[ix+1])
            ++ix;
    }
} // HRESULT ComMTMemberInfoMap::EliminateDuplicateDispIds()
        

// ============================================================================
// Assign a default member based on "Value" or "ToString", unless there is
//  a dispid of 0.
// ============================================================================
void ComMTMemberInfoMap::AssignDefaultMember(
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    CDescPool   &sNames,                // Pool of possibly decorated names.
    UINT        nSlots)                 // Count of entries
{
    int         ix;                     // Loop control.
    int         defDispid=-1;           // Default via dispid.
    int         defValueProp=-1;        // Default via szDefaultValue on a method.
    int         defValueMeth=-1;        // Default via szDefaultValue on a property.
    int         defToString=-1;         // Default via szDefaultToString.
    int         *pDef=0;                // Pointer to one of the def* variables.
    LPWSTR      pName;                  // Pointer to a name.
    PCCOR_SIGNATURE pbSig;              // Pointer to Cor signature.
    ULONG       cbSig;                  // Size of Cor signature.
    ULONG       ixSig;                  // Index into COM+ signature.
    ULONG       callconv;               // A member's calling convention.
    ULONG       cParams;                // A member's parameter count.
    ULONG       retval;                 // A default member's return type.

    for (ix=0; ix<(int)nSlots; ++ix)
    {
        // If this is the explicit default, done.
        if (rProps[ix].dispid == DISPID_VALUE)
        {
            defDispid = ix;
            break;
        }
        // If this has an assigned dispid, honor it.
        if (rProps[ix].dispid != DISPID_UNKNOWN)
            continue;
        // Skip linked properties and non-properties.
        if (TypeFromToken(rProps[ix].property) != mdtProperty)
            continue;
        pName = rProps[ix].pName;
        if (_wcsicmp(pName, szDefaultValue) == 0)
        {
            if (rProps[ix].semantic != 0)
                pDef = &defValueProp;
            else
                pDef = &defValueMeth;
        }
        else
        if (_wcsicmp(pName, szDefaultToString) == 0)
        {
            pDef = &defToString;
        }

        // If a potential match was found, see if it is "simple" enough.  A field is OK;
        //  a property get function is OK if it takes 0 params; a put is OK with 1.
        if (pDef)
        {   
            // Fields are by definition simple enough, so only check if some sort of func.
            if (rProps[ix].semantic < FieldSemanticOffset)
            {   // Get the signature, skip the calling convention, get the param count.
                rProps[ix].pMeth->GetSig(&pbSig, &cbSig);
                ixSig = CorSigUncompressData(pbSig, &callconv);
                _ASSERTE(callconv != IMAGE_CEE_CS_CALLCONV_FIELD);
                ixSig += CorSigUncompressData(&pbSig[ixSig], &cParams);

                // If too many params, don't consider this one any more.
                if (cParams > 1 || (cParams == 1 && rProps[ix].semantic != msSetter))
                    pDef = 0;
            }
            // If we made it through the above checks, save the index of this member.
            if (pDef)
                *pDef = ix, pDef = 0;
        }
    }

    // If there wasn't a DISPID_VALUE already assigned...
    if (defDispid == -1)
    {   // Was there a "Value" or "ToSTring"
        if (defValueMeth > -1)
            defDispid = defValueMeth;
        else
        if (defValueProp > -1)
            defDispid = defValueProp;
        else
        if (defToString > -1)
            defDispid = defToString;
        // Make it the "Value"
        if (defDispid >= 0)
            rProps[defDispid].dispid = DISPID_VALUE;
    }
    else
    {   // This was a pre-assigned DISPID_VALUE.  If it is a function, try to
        //  turn into a propertyget.
        if (rProps[defDispid].semantic == 0)
        {   // See if the function returns anything.
            rProps[defDispid].pMeth->GetSig(&pbSig, &cbSig);
            ixSig = CorSigUncompressData(pbSig, &callconv);
            _ASSERTE(callconv != IMAGE_CEE_CS_CALLCONV_FIELD);
            ixSig += CorSigUncompressData(&pbSig[ixSig], &cParams);
            ixSig += CorSigUncompressData(&pbSig[ixSig], &retval);
            if (retval != ELEMENT_TYPE_VOID)
            {
                rProps[defDispid].semantic = msGetter;
                rProps[defDispid].bFunction2Getter = TRUE;
            }
        }
    }
} // void ComMTMemberInfoMap::AssignDefaultMember()


// ============================================================================
// Assign a DISPID_NEWENUM member based on "GetEnumerator", unless there is
// already a member with DISPID_NEWENUM.
// ============================================================================
void ComMTMemberInfoMap::AssignNewEnumMember(
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    CDescPool   &sNames,                // Pool of possibly decorated names.
    UINT        nSlots)                 // Count of entries
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // HRESULT.
    int         ix;                     // Loop control.
    int         enumDispid=-1;          // Default via dispid.
    int         enumGetEnumMeth=-1;     // Default via szGetEnumerator on a method.
    int         *pNewEnum=0;            // Pointer to one of the def* variables.
    ULONG       elem;                   // The element type.
    mdToken     tkTypeRef;              // Token for a TypeRef/TypeDef
    CQuickArray<CHAR> rName;            // Library name.
    LPWSTR      pName;                  // Pointer to a name.
    PCCOR_SIGNATURE pbSig;              // Pointer to Cor signature.
    ULONG       cbSig;                  // Size of Cor signature.
    ULONG       ixSig;                  // Index into COM+ signature.
    ULONG       callconv;               // A member's calling convention.
    ULONG       cParams;                // A member's parameter count.
    MethodDesc  *pMeth;                 // A method desc.
    LPCUTF8     pclsname;               // Class name for ELEMENT_TYPE_CLASS.

    for (ix=0; ix<(int)nSlots; ++ix)
    {
        // If assigned dispid, that's it.
        if (rProps[ix].dispid == DISPID_NEWENUM)
        {
            enumDispid = ix;
            break;
        }

        // Only consider method.
        if (rProps[ix].semantic != 0)
            continue;

        // Skip any members that have explicitly assigned DISPID's.
        if (rProps[ix].dispid != DISPID_UNKNOWN)
            continue;

        // Check to see if the member is GetEnumerator.
        pName = rProps[ix].pName;
        if (_wcsicmp(pName, szGetEnumerator) != 0)
            continue;

        pMeth = rProps[ix].pMeth;

        // Get the signature, skip the calling convention, get the param count.
        pMeth->GetSig(&pbSig, &cbSig);
        ixSig = CorSigUncompressData(pbSig, &callconv);
        _ASSERTE(callconv != IMAGE_CEE_CS_CALLCONV_FIELD);
        ixSig += CorSigUncompressData(&pbSig[ixSig], &cParams);

        // If too many params, don't consider this one any more. Also disregard
        // this method if it doesn't have a return type.
        if (cParams != 0 || ixSig >= cbSig)
            continue;

        ixSig += CorSigUncompressData(&pbSig[ixSig], &elem);
        if (elem != ELEMENT_TYPE_CLASS)
            continue;

        // Get the TD/TR.
        ixSig = CorSigUncompressToken(&pbSig[ixSig], &tkTypeRef);

        LPCUTF8 pNS;
        if (TypeFromToken(tkTypeRef) == mdtTypeDef)
        {
            // Get the name of the TypeDef.
            pMeth->GetMDImport()->GetNameOfTypeDef(tkTypeRef, &pclsname, &pNS);
        }
        else
        {   
            // Get the name of the TypeRef.
            _ASSERTE(TypeFromToken(tkTypeRef) == mdtTypeRef);
            pMeth->GetMDImport()->GetNameOfTypeRef(tkTypeRef, &pNS, &pclsname);
        }

        if (pNS)
        {   
            // Pre-pend the namespace to the class name.
            IfFailThrow(rName.ReSize((int)(strlen(pclsname)+strlen(pNS)+2)));
            strcat(strcat(strcpy(rName.Ptr(), pNS), NAMESPACE_SEPARATOR_STR), pclsname);
            pclsname = rName.Ptr();
        }

        // Make sure the returned type is an IEnumerator.
        if (_stricmp(pclsname, szIEnumeratorClass) != 0)
            continue;

        // The method is a valid GetEnumerator method.
        enumGetEnumMeth = ix;
    }

    // If there wasn't a DISPID_NEWENUM already assigned...
    if (enumDispid == -1)
    {   
        // If there was a GetEnumerator then give it DISPID_NEWENUM.
        if (enumGetEnumMeth > -1)
            rProps[enumGetEnumMeth].dispid = DISPID_NEWENUM;
    }
} // void ComMTMemberInfoMap::AssignNewEnumMember()


// ============================================================================
// For each property set and let functions, determine PROPERTYPUT and 
//  PROPERTYPUTREF.
// ============================================================================
void ComMTMemberInfoMap::FixupPropertyAccessors(
    CQuickArray<ComMTMethodProps> &rProps,   // Array of method property information.
    CDescPool   &sNames,                // Pool of possibly decorated names.
    UINT        nSlots)                 // Count of entries
{
    UINT        ix;                     // Loop control.
    UINT        j;                      // Inner loop.
    int         iSet;                   // Index of Set method.
    int         iOther;                 // Index of Other method.

    for (ix=0; ix<nSlots; ++ix)
    {
        // Skip linked properties and non-properties.
        if (TypeFromToken(rProps[ix].property) != mdtProperty)
            continue;
        // What is this one?
        switch (rProps[ix].semantic)
        {
        case msSetter:
            iSet = ix;
            iOther = -1;
            break;
        case msOther:
            iOther = ix;
            iSet = -1;
            break;
        default:
            iSet = iOther = -1;
        }
        // Look for the others.
        for (j=ix+1; j<nSlots && (iOther == -1 || iSet == -1); ++j)
        {   
            if ((UINT)rProps[j].property == ix)
            {    // Found one -- what is it?
                switch (rProps[j].semantic)
                {
                case msSetter:
                    _ASSERTE(iSet == -1);
                    iSet = j;
                    break;
                case msOther:
                    _ASSERTE(iOther == -1);
                    iOther = j;
                    break;
                }
            }
        }
        // If both, or neither, or "VB Specific Let" (msOther) only, keep as-is.
        if (((iSet == -1) == (iOther == -1)) || (iSet == -1))
            continue;
        _ASSERTE(iSet != -1 && iOther == -1);
        // Get the signature.
        MethodDesc *pMeth = rProps[iSet].pMeth;
        PCCOR_SIGNATURE pSig;
        ULONG cbSig;
        pMeth->GetSig(&pSig, &cbSig);
        MetaSigExport msig(pSig, pMeth->GetModule());
        msig.GotoEnd();
        msig.PrevArg();
        if (msig.IsVbRefType())
            rProps[iSet].semantic = msSetter;
        else
            rProps[iSet].semantic = msOther;

    }
} // void ComMTMemberInfoMap::FixupPropertyAccessors()


void ComMTMemberInfoMap::AssignDefaultDispIds()
{
    // Assign the DISPID's using the same algorithm OLEAUT uses.
    DWORD nSlots = (DWORD)m_MethodProps.Size();
    for (DWORD i = 0; i < nSlots; i++)
    {
        // Retrieve the properties for the current member.
        ComMTMethodProps *pProps = &m_MethodProps[i];

        if (pProps->dispid == DISPID_UNKNOWN)
        {
            if (pProps->semantic > FieldSemanticOffset)
            {
                // We are dealing with a field.
                pProps->dispid = BASE_OLEAUT_DISPID + i;
                m_MethodProps[i + 1].dispid = BASE_OLEAUT_DISPID + i;

                // Skip the next method since field methods always come in pairs.
                _ASSERTE(i + 1 < nSlots && m_MethodProps[i + 1].property == i);
                i++;
            }
            else if (pProps->property == mdPropertyNil)
            {
                // Make sure that this is either a real method or a method transformed into a getter.
                _ASSERTE(pProps->semantic == 0 || pProps->semantic == msGetter);

                // We are dealing with a method.
                pProps->dispid = BASE_OLEAUT_DISPID + i;

            }
            else 
            {
                // We are dealing with a property.
                if (TypeFromToken(pProps->property) == mdtProperty)
                {
                    pProps->dispid = BASE_OLEAUT_DISPID + i;
                }
                else
                {
                    pProps->dispid = m_MethodProps[pProps->property].dispid;
                }
            }
        }
    }
} // void ComMTMemberInfoMap::AssignDefaultDispIds()


void ComMTMemberInfoMap::PopulateMemberHashtable()
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    DWORD nSlots = (DWORD)m_MethodProps.Size();

    // Go through the members and add them to the hashtable.
    for (DWORD i = 0; i < nSlots; i++)
    {
        // Retrieve the properties for the current member.
        ComMTMethodProps *pProps = &m_MethodProps[i];

        if (pProps->semantic > FieldSemanticOffset)
        {
            // We are dealing with a field.
            ComCallMethodDesc *pFieldMeth = reinterpret_cast<ComCallMethodDesc*>(pProps->pMeth);
            FieldDesc *pFD = pFieldMeth->GetFieldDesc();

            // Insert the member into the hashtable.
            EEModuleTokenPair Key(pFD->GetMemberDef(), pFD->GetModule());
            if (!m_TokenToComMTMethodPropsMap.InsertValue(&Key, (HashDatum)pProps))
                COMPlusThrowOM();

            // Skip the next method since field methods always come in pairs.
            _ASSERTE(i + 1 < nSlots && m_MethodProps[i + 1].property == i);
            i++;
        }
        else if (pProps->property == mdPropertyNil)
        {
            // Make sure that this is either a real method or a method transformed into a getter.
            _ASSERTE(pProps->semantic == 0 || pProps->semantic == msGetter);

            // We are dealing with a method.
            MethodDesc *pMD = pProps->pMeth;
            EEModuleTokenPair Key(pMD->GetMemberDef(), pMD->GetModule());
            if (!m_TokenToComMTMethodPropsMap.InsertValue(&Key, (HashDatum)pProps))
                COMPlusThrowOM();
        }
        else 
        {
            // We are dealing with a property.
            if (TypeFromToken(pProps->property) == mdtProperty)
            {
                // This is the first method of the property.
                MethodDesc *pMD = pProps->pMeth;
                EEModuleTokenPair Key(pProps->property, pMD->GetModule());
                if (!m_TokenToComMTMethodPropsMap.InsertValue(&Key, (HashDatum)pProps))
                    COMPlusThrowOM();
            }
        }
    }
} // void ComMTMemberInfoMap::PopulateMemberHashtable()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comoavariant.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Source:  COMOAVariant
**
** Author:  Brian Grunkemeyer (BrianGru)
**
** Purpose: Wrapper for Ole Automation compatable math ops.
** Calls through to OleAut.dll
**
** Date:    November 5, 1998
** 
===========================================================*/
#include <common.h>
#include <oleauto.h>
#include "excep.h"
#include "COMOAVariant.h"
#include "COMDateTime.h"  // DateTime <-> OleAut date conversions
#include "interoputil.h"
#include "InteropConverter.h"
#ifndef PLATFORM_CE

/***********************************************************************************
 ***********************************************************************************

                    WinCE Note:

  WinCE doesn't have variant.h in their OS build directory.  They apparently don't
  support OleAut.dll.  Consequently, these methods have to be ifdef'ed out.  We're
  providing stubs that throw NotSupportedException on WinCE.  11/12/98

  **********************************************************************************
  **********************************************************************************
*/

#include <variant.h>
#include "excep.h"
#include "COMString.h"
#include "COMUtilNative.h" // for COMDate

#define INVALID_MAPPING (byte)(-1)

byte CVtoVTTable [] = {
    VT_EMPTY,   // CV_EMPTY
    VT_VOID,    // CV_VOID
    VT_BOOL,    // CV_BOOLEAN
    VT_UI2,     // CV_CHAR
    VT_I1,      // CV_I1
    VT_UI1,     // CV_U1
    VT_I2,      // CV_I2
    VT_UI2,     // CV_U2
    VT_I4,      // CV_I4
    VT_UI4,     // CV_U4
    VT_I8,      // CV_I8
    VT_UI8,     // CV_U8
    VT_R4,      // CV_R4
    VT_R8,      // CV_R8
    VT_BSTR,    // CV_STRING
    INVALID_MAPPING,    // CV_PTR
    VT_DATE,    // CV_DATETIME
    INVALID_MAPPING, // CV_TIMESPAN
    VT_UNKNOWN, // CV_OBJECT
    VT_DECIMAL, // CV_DECIMAL
    VT_CY,      // CV_CURRENCY
    INVALID_MAPPING, // CV_ENUM
    INVALID_MAPPING, // CV_MISSING
    VT_NULL,    // CV_NULL
    INVALID_MAPPING  // CV_LAST
};


// Need translations from CVType to VARENUM and vice versa.  CVTypes
// is defined in COMVariant.h.  VARENUM is defined in OleAut's variant.h
// Assumption here is we will only deal with VARIANTs and not other OLE
// constructs such as property sets or safe arrays.
VARENUM COMOAVariant::CVtoVT(const CVTypes cv)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(cv >=0 && cv < CV_LAST);

    if (CVtoVTTable[cv] == INVALID_MAPPING)
        COMPlusThrow(kNotSupportedException, L"NotSupported_ChangeType");

    return (VARENUM) CVtoVTTable[cv];
}


byte VTtoCVTable[] = {
    CV_EMPTY,   // VT_EMPTY
    CV_NULL,    // VT_NULL
    CV_I2,      // VT_I2
    CV_I4,      // VT_I4
    CV_R4,      // VT_R4
    CV_R8,      // VT_R8
    CV_CURRENCY,// VT_CY
    CV_DATETIME,// VT_DATE
    CV_STRING,  // VT_BSTR
    INVALID_MAPPING, // VT_DISPATCH
    INVALID_MAPPING, // VT_ERROR
    CV_BOOLEAN, // VT_BOOL
    CV_OBJECT,  // VT_VARIANT
    CV_OBJECT,  // VT_UNKNOWN
    CV_DECIMAL, // VT_DECIMAL
    INVALID_MAPPING, // An unused enum table entry
    CV_I1,      // VT_I1
    CV_U1,      // VT_UI1
    CV_U2,      // VT_UI2
    CV_U4,      // VT_UI4
    CV_I8,      // VT_I8
    CV_U8,      // VT_UI8
    CV_I4,      // VT_INT
    CV_U4,      // VT_UINT
    CV_VOID     // VT_VOID
};


// Need translations from CVType to VARENUM and vice versa.  CVTypes
// is defined in COMVariant.h.  VARENUM is defined in OleAut's variant.h
CVTypes COMOAVariant::VTtoCV(const VARENUM vt)
{
    THROWSCOMPLUSEXCEPTION();

    if (vt >=0 && vt <= VT_VOID)
        if (VTtoCVTable[vt]!=INVALID_MAPPING)
            return (CVTypes) VTtoCVTable[vt];
    COMPlusThrow(kNotSupportedException, L"NotSupported_ChangeType");
    return CV_EMPTY;  // To appease the compiler.
}

// Version of VTtoCV without exception throwing capability
CVTypes COMOAVariant::VTtoCVNoExcep(const VARENUM vt)
{
    if (vt >=0 && vt <= VT_VOID)
        if (VTtoCVTable[vt]!=INVALID_MAPPING)
            return (CVTypes) VTtoCVTable[vt];
    return CV_EMPTY;  // To appease the compiler.
}


// Converts a COM+ Variant to an OleAut Variant.  Returns true if
// there was a native object allocated by this method that must be freed,
// else false.
bool COMOAVariant::ToOAVariant(const VariantData * const var, VARIANT * oa)
{
    THROWSCOMPLUSEXCEPTION();

    VariantInit(oa);
    UINT64 * dest = (UINT64*) &V_UI1(oa);
    *dest = 0;

    V_VT(oa) = CVtoVT(var->GetType());

    WCHAR * chars;
    int strLen;
    // Set the data field of the OA Variant to be either the object reference
    // or the data (ie int) that it needs.
    switch (var->GetType()) {
    case CV_STRING: 
		if (var->GetObjRef() == NULL) {
			V_BSTR(oa) = NULL;
			// OA perf feature: VarClear calls SysFreeString(null), which access violates.
			return false;
		}
        RefInterpretGetStringValuesDangerousForGC((STRINGREF) (var->GetObjRef()), &chars, &strLen);
        V_BSTR(oa) = SysAllocStringLen(chars, strLen);
        if (V_BSTR(oa) == NULL)
            COMPlusThrowOM();
        return true;

    case CV_CHAR: 
        chars = (WCHAR*) var->GetData();
        V_BSTR(oa) = SysAllocStringLen(chars, 1);
        if (V_BSTR(oa) == NULL)
            COMPlusThrowOM();
        return true;

    case CV_DATETIME:
        V_DATE(oa) = COMDateTime::TicksToDoubleDate(var->GetDataAsInt64());
        return false;

    case CV_BOOLEAN:
        V_BOOL(oa) = (var->GetDataAsInt64()==0 ? VARIANT_FALSE : VARIANT_TRUE);
        return false;
        
    case CV_DECIMAL:
        {
            OBJECTREF obj = var->GetObjRef();
            DECIMAL * d = (DECIMAL*) obj->GetData();
            // DECIMALs and Variants are the same size.  Variants are a union between
            // all the normal Variant fields (vt, bval, etc) and a Decimal.  Decimals
            // also have the first 2 bytes reserved, for a VT field.
            
            V_DECIMAL(oa) = *d;
            V_VT(oa) = VT_DECIMAL;
            return false;
        }

	case CV_OBJECT:
		{
			OBJECTREF obj = var->GetObjRef();
            GCPROTECT_BEGIN(obj)
            {
                IDispatch *pDisp = NULL;
                IUnknown *pUnk = NULL;
                
                // Convert the object to an IDispatch/IUnknown pointer.
                ComIpType FetchedIpType = ComIpType_None;
                pUnk = GetComIPFromObjectRef(&obj, ComIpType_Both, &FetchedIpType);
                V_VT(oa) = FetchedIpType == ComIpType_Dispatch ? VT_DISPATCH : VT_UNKNOWN;
                V_UNKNOWN(oa) = pUnk;
            }
            GCPROTECT_END();		    
			return true;
		}


    default:
        UINT64 * dest = (UINT64*) &V_UI1(oa);
        *dest = var->GetDataAsInt64();
        return false;
    }
}

// Converts an OleAut Variant into a COM+ Variant.
// NOte that we pass the VariantData Byref so that if GC happens, 'var' gets updated
void COMOAVariant::FromOAVariant(const VARIANT * const oa, VariantData * const& var)
{
    THROWSCOMPLUSEXCEPTION();
	// Make sure Variant has been loaded.  It has to have been, but...
	_ASSERTE(COMVariant::s_pVariantClass != NULL);

    // Clear the return variant value.  It's allocated on
    // the stack and we only want valid state data in there.
    memset(var, 0, sizeof(VariantData));

    CVTypes type = VTtoCV((VARENUM) V_VT(oa));
    var->SetType(type);

    switch (type) {
    case CV_STRING:
        {
           // BSTRs have an int with the string buffer length (not the string length) 
            // followed by the data.  The pointer to the BSTR points to the start of the 
            // characters, NOT the start of the BSTR.
            WCHAR * chars = V_BSTR(oa);
            int strLen = SysStringLen(V_BSTR(oa));
            STRINGREF str = COMString::NewString(chars, strLen);
            var->SetObjRef((OBJECTREF)str);
            break;
        }

    case CV_DATETIME:
        var->SetDataAsInt64(COMDateTime::DoubleDateToTicks(V_DATE(oa)));
        break;

    case CV_BOOLEAN:
        var->SetDataAsInt64(V_BOOL(oa)==VARIANT_FALSE ? 0 : 1);
        break;

    case CV_DECIMAL:
        {

			MethodTable * pDecimalMT = GetTypeHandleForCVType(CV_DECIMAL).GetMethodTable();
			_ASSERTE(pDecimalMT);
            OBJECTREF pDecimalRef = AllocateObject(pDecimalMT);
            
            *(DECIMAL *) pDecimalRef->GetData() = V_DECIMAL(oa);
            var->SetObjRef(pDecimalRef);
        }
        break;

    // All types less than 4 bytes need an explicit cast from their original
    // type to be sign extended to 8 bytes.  This makes Variant's ToInt32 
    // function simpler for these types.
    case CV_I1:
        var->SetDataAsInt64(V_I1(oa));
        break;

    case CV_U1:
        var->SetDataAsInt64(V_UI1(oa));
        break;

    case CV_I2:
        var->SetDataAsInt64(V_I2(oa));
        break;

    case CV_U2:
        var->SetDataAsInt64(V_UI2(oa));
        break;

    case CV_EMPTY:
    case CV_NULL:
        // Must set up the Variant's m_or to the appropriate classes.
        // Note that OleAut doesn't have any VT_MISSING.
        COMVariant::NewVariant(var, type);
        break;

    case CV_OBJECT:
        // Convert the IUnknown pointer to an OBJECTREF.
        var->SetObjRef(GetObjectRefFromComIP(V_UNKNOWN(oa)));
        break;

    default:
        // Copy all the bits there, and make sure we don't do any float to int conversions.
        void * src = (void*) &(V_UI1(oa));
        var->SetData(src);
    }
}


//
// Execution & error checking stubs
//

// Pass in a 2-operand (binary) Variant math function (such as VarAdd) and 
// an appropriate argument structure.
void COMOAVariant::BinaryOp(VarMathBinaryOpFunc mathFunc, const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(mathFunc);
    _ASSERTE(args);
    VARIANT vLeft, vRight, vResult;

    // Convert arguments to OleAut variants, remembering if an object 
    // was allocated while they were created.
    bool delLeft = ToOAVariant(&args->left, &vLeft);
    bool delRight = ToOAVariant(&args->right, &vRight);

    // Initialize return variant
    VariantInit(&vResult);

    // Call VarMath function
    HRESULT hr = mathFunc(&vLeft, &vRight, &vResult);

    // Free any allocated objects
    if (delLeft)
        SafeVariantClear(&vLeft);
    if (delRight)
        SafeVariantClear(&vRight);

	if (FAILED(hr))
		OAFailed(hr);

    // Convert result from OLEAUT variant to COM+ variant.
    FromOAVariant(&vResult, args->retRef);
    SafeVariantClear(&vResult);  // Free any allocated objects
}


// Pass in a 1-operand (unary) Variant math function (such as VarNeg) and 
// an appropriate argument structure.
void COMOAVariant::UnaryOp(VarMathUnaryOpFunc mathFunc, const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(mathFunc);
    _ASSERTE(args);
    VARIANT vOp, vResult;

    // Convert arguments to OleAut variants, remembering if an object 
    // was allocated while they were created.
    bool delOp = ToOAVariant(&args->operand, &vOp);

    // Initialize return variant
    VariantInit(&vResult);

    // Call VarMath function
    HRESULT hr = mathFunc(&vOp, &vResult);

    // Free any allocated objects
    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

    // Convert result from OLEAUT variant to COM+ variant.
    FromOAVariant(&vResult, args->retRef);
    SafeVariantClear(&vResult);  // Free any allocated objects
}


void COMOAVariant::OAFailed(const HRESULT hr)
{
	THROWSCOMPLUSEXCEPTION();
	switch (hr) {
    case E_OUTOFMEMORY:
        COMPlusThrowOM();

	case DISP_E_BADVARTYPE:
		COMPlusThrow(kNotSupportedException, L"NotSupported_OleAutBadVarType");
        
	case DISP_E_DIVBYZERO:
		COMPlusThrow(kDivideByZeroException);

	case DISP_E_OVERFLOW:
		COMPlusThrow(kOverflowException);
		
	case DISP_E_TYPEMISMATCH:
		COMPlusThrow(kInvalidCastException, L"InvalidCast_OATypeMismatch");

	case E_INVALIDARG:
		COMPlusThrow(kArgumentException);
		break;
		
	default:
		_ASSERTE(!"Unrecognized HResult - OAVariantLib routine failed in an unexpected way!");
		COMPlusThrowHR(hr);
	}
}


//
// Binary Operations
//
void COMOAVariant::Add(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarAdd, args);
}

void COMOAVariant::Subtract(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarSub, args);
}

void COMOAVariant::Multiply(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarMul, args);
}


void COMOAVariant::Divide(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarDiv, args);
}

void COMOAVariant::Mod(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarMod, args);
}

void COMOAVariant::Pow(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarPow, args);
}

void COMOAVariant::And(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarAnd, args);
}

void COMOAVariant::Or(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarOr, args);
}

void COMOAVariant::Xor(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarXor, args);
}

void COMOAVariant::Eqv(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarEqv, args);
}

void COMOAVariant::IntDivide(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarIdiv, args);
}

void COMOAVariant::Implies(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    BinaryOp(VarImp, args);
}


//
// Unary Operations
//
void COMOAVariant::Negate(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    UnaryOp(VarNeg, args);
}

void COMOAVariant::Not(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    UnaryOp(VarNot, args);
}

void COMOAVariant::Abs(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    UnaryOp(VarAbs, args);
}

void COMOAVariant::Fix(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    UnaryOp(VarFix, args);
}

void COMOAVariant::Int(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    UnaryOp(VarInt, args);
}


//
// Misc
//
INT32 COMOAVariant::Compare(const CompareArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    VARIANT vLeft, vRight;

    // Convert arguments to OleAut variants, remembering if an object 
    // was allocated while they were created.
    bool delLeft = ToOAVariant(&args->left, &vLeft);
    bool delRight = ToOAVariant(&args->right, &vRight);

	if (args->leftHardType)
		V_VT(&vLeft) |= VT_HARDTYPE;
	if (args->rightHardType)
		V_VT(&vRight) |= VT_HARDTYPE;

    // Call VarCmp
    HRESULT hr = VarCmp(&vLeft, &vRight, args->lcid, args->flags);

    // Free any allocated objects
    if (delLeft)
        SafeVariantClear(&vLeft);
    if (delRight)
        SafeVariantClear(&vRight);

	if (FAILED(hr))
		OAFailed(hr);

    return hr;
}

void COMOAVariant::ChangeType(const ChangeTypeArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    _ASSERTE(args->retRef);
    VARIANT vOp, ret;
	VARENUM vt = CVtoVT((CVTypes)args->cvType);

    bool delOp = ToOAVariant(&args->op, &vOp);

    VariantInit(&ret);

    HRESULT hr = SafeVariantChangeType(&ret, &vOp, args->flags, vt);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

    if ((CVTypes)args->cvType == CV_CHAR)
    {
        args->retRef->SetType(CV_CHAR);
        args->retRef->SetDataAsUInt16(V_UI2(&ret));
    }
    else
    {
        FromOAVariant(&ret, args->retRef);
    }
    
    SafeVariantClear(&ret);
}

void COMOAVariant::ChangeTypeEx(const ChangeTypeExArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    _ASSERTE(args->retRef);
    VARIANT vOp, ret;
	VARENUM vt = CVtoVT((CVTypes)args->cvType);

    bool delOp = ToOAVariant(&args->op, &vOp);

    VariantInit(&ret);

    HRESULT hr = SafeVariantChangeTypeEx(&ret, &vOp, args->lcid, args->flags, vt);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

    if ((CVTypes)args->cvType == CV_CHAR)
    {
        args->retRef->SetType(CV_CHAR);
        args->retRef->SetDataAsUInt16(V_UI2(&ret));
    }
    else
    {
        FromOAVariant(&ret, args->retRef);
    }

    SafeVariantClear(&ret);
}


void COMOAVariant::Round(const RoundArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args);
    _ASSERTE(args->retRef);
    VARIANT vOp, ret;

    bool delOp = ToOAVariant(&args->operand, &vOp);

    VariantInit(&ret);

    HRESULT hr = VarRound(&vOp, args->cDecimals, &ret);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

    FromOAVariant(&ret, args->retRef);
    SafeVariantClear(&ret);
}


//
// String Mangling code
//
LPVOID COMOAVariant::Format(FormatArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	VARIANT vOp;
	BSTR bstr = NULL;

	if (args->format==NULL)
		COMPlusThrowArgumentNull(L"format");

	LPOLESTR format = args->format->GetBuffer();

    bool delOp = ToOAVariant(&args->value, &vOp);

	HRESULT hr = VarFormat(&vOp, format, args->firstDay, args->firstWeek, args->flags, &bstr);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatBoolean(const FormatBooleanArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromBool(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatByte(const FormatByteArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromUI1(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatSByte(const FormatSByteArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromI1(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatInt16(const FormatInt16Args * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromI2(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatInt32(const FormatInt32Args * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromI4(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatSingle(const FormatSingleArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromR4(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatDouble(const FormatDoubleArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromR8(args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatCurrency(const FormatCurrencyArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	CY cy = args->value;
	HRESULT hr = VarBstrFromCy(cy, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatDateTime(const FormatDateTimeArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	double date = COMDateTime::TicksToDoubleDate(args->value);
	HRESULT hr = VarBstrFromDate(date, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatDecimal(FormatDecimalArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	BSTR bstr = NULL;
	HRESULT hr = VarBstrFromDec(&args->value, args->lcid, args->flags, &bstr);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatNumber(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	VARIANT vOp;
	BSTR bstr = NULL;

    bool delOp = ToOAVariant(&args->value, &vOp);

	HRESULT hr = VarFormatNumber(&vOp, args->numDig, args->incLead, args->useParens, args->group, args->flags, &bstr);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatCurrencySpecial(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	VARIANT vOp;
	BSTR bstr = NULL;

    bool delOp = ToOAVariant(&args->value, &vOp);

	HRESULT hr = VarFormatCurrency(&vOp, args->numDig, args->incLead, args->useParens, args->group, args->flags, &bstr);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatPercent(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	VARIANT vOp;
	BSTR bstr = NULL;

    bool delOp = ToOAVariant(&args->value, &vOp);

	HRESULT hr = VarFormatPercent(&vOp, args->numDig, args->incLead, args->useParens, args->group, args->flags, &bstr);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}

LPVOID COMOAVariant::FormatDateTimeSpecial(const FormatDateTimeSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	
	VARIANT vOp;
	BSTR bstr = NULL;

    bool delOp = ToOAVariant(&args->value, &vOp);

	HRESULT hr = VarFormatDateTime(&vOp, args->namedFormat, args->flags, &bstr);

    if (delOp)
        SafeVariantClear(&vOp);

	if (FAILED(hr))
		OAFailed(hr);

	STRINGREF str = COMString::NewString(bstr, SysStringLen(bstr));
	SysFreeString(bstr);
	RETURN(str, STRINGREF);
}


bool COMOAVariant::ParseBoolean(const ParseBooleanArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	_ASSERTE(args->str != NULL);

	int len;
	wchar_t * chars;
	RefInterpretGetStringValuesDangerousForGC(args->str, &chars, &len);
	BSTR bstr = SysAllocStringLen(chars, len);
	if (bstr == NULL)
		COMPlusThrowOM();
	
	VARIANT_BOOL b=false;

	HRESULT hr = VarBoolFromStr(bstr, args->lcid, args->flags, &b);

	SysFreeString(bstr);

	if (FAILED(hr))
		OAFailed(hr);

	return b!=0;
}

INT64 COMOAVariant::ParseDateTime(const ParseDateTimeArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
	_ASSERTE(args);
	_ASSERTE(args->str != NULL);

	int len;
	wchar_t * chars;
	RefInterpretGetStringValuesDangerousForGC(args->str, &chars, &len);
	BSTR bstr = SysAllocStringLen(chars, len);
	if (bstr == NULL)
		COMPlusThrowOM();

	double date=0;

	HRESULT hr = VarDateFromStr(bstr, args->lcid, args->flags, &date);

	SysFreeString(bstr);

	if (FAILED(hr))
		OAFailed(hr);

	INT64 ticks = COMDateTime::DoubleDateToTicks(date);
	return ticks;
}


#else  // PLATFORM_CE
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////                                     ///////////////
////////////           W I N   C E               ///////////////
////////////                                     ///////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

// Provide stubs for WinCE to compile.

//
// Binary Operations
//
void COMOAVariant::Add(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Subtract(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Multiply(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Divide(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Mod(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Pow(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::And(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Or(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Xor(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Eqv(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::IntDivide(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Implies(const ArithBinaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}


//
// Unary Operations
//
void COMOAVariant::Negate(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Not(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Abs(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Fix(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Int(const ArithUnaryOpArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}


//
// Misc
//
INT32 COMOAVariant::Compare(const CompareArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
    return E_NOTIMPL;
}

void COMOAVariant::ChangeType(const ChangeTypeArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::ChangeTypeEx(const ChangeTypeExArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}

void COMOAVariant::Round(const RoundArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
}


//
// String Mangling code
// 
LPVOID COMOAVariant::Format(FormatArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatBoolean(const FormatBooleanArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatByte(const FormatByteArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatSByte(const FormatSByteArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatInt16(const FormatInt16Args * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatInt32(const FormatInt32Args * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatSingle(const FormatSingleArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatDouble(const FormatDoubleArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatCurrency(const FormatCurrencyArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatCurrencySpecial(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatDateTime(const FormatDateTimeArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatDateTimeSpecial(const FormatDateTimeSpecialArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatDecimal(FormatDecimalArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatNumber(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

LPVOID COMOAVariant::FormatPercent(const FormatSpecialArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}


bool COMOAVariant::ParseBoolean(const ParseBooleanArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

INT64 COMOAVariant::ParseDateTime(const ParseDateTimeArgs * args)
{
	THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNotSupportedException, L"NotSupported_WinCEGeneric");
	return NULL;  // Compiler Appeasement.
}

#endif // PLATFORM_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comnumber.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "excep.h"
#include "COMNumber.h"
#include "COMString.h"

typedef wchar_t wchar;

#define NUMBER_MAXDIGITS 50
#define INT32_PRECISION 10
#define UINT32_PRECISION INT32_PRECISION 
#define INT64_PRECISION 19
#define UINT64_PRECISION 20
#define FLOAT_PRECISION 7
#define DOUBLE_PRECISION 15
#define DECIMAL_PRECISION 29
#define LARGE_BUFFER_SIZE 600
#define MIN_BUFFER_SIZE 105

struct NUMBER {
    int precision;
    int scale;
    int sign;
    wchar digits[NUMBER_MAXDIGITS + 1];
    NUMBER() : precision(0), scale(0), sign(0) {}
};

#define SCALE_NAN 0x80000000
#define SCALE_INF 0x7FFFFFFF

struct FPSINGLE {
    unsigned int mant: 23;
    unsigned int exp: 8;
    unsigned int sign: 1;
};

struct FPDOUBLE {
    unsigned int mantLo;
    unsigned int mantHi: 20;
    unsigned int exp: 11;
    unsigned int sign: 1;
};

static char* posCurrencyFormats[] = {
    "$#", "#$", "$ #", "# $"};
    
    static char* negCurrencyFormats[] = {
        "($#)", "-$#", "$-#", "$#-",
            "(#$)", "-#$", "#-$", "#$-",
            "-# $", "-$ #", "# $-", "$ #-",
            "$ -#", "#- $", "($ #)", "(# $)"};
        
        static char* posPercentFormats[] = {
            "# %", "#%", "%#", 
        };
        
        static char* negPercentFormats[] = {
            "-# %", "-#%", "-%#",    // BUGBUG yslin: have to verify on the negative Percent format for real format.
        };
        
        static char* negNumberFormats[] = {
            "(#)", "-#", "- #", "#-", "# -",
        };
        
        static char* posNumberFormat = "#";
        
#ifdef _X86_
        
        extern "C" void _cdecl /*__stdcall*/ DoubleToNumber(double value, int precision, NUMBER* number);
        extern "C" void _cdecl /*__stdcall*/ NumberToDouble(NUMBER* number, double* value);
        
#pragma warning(disable:4035)
        
        wchar* Int32ToDecChars(wchar* p, unsigned int value, int digits)
        {
            _asm {
                mov     eax,value
                    mov     ebx,10
                    mov     ecx,digits
                    mov     edi,p
                    jmp     L2
L1:     xor     edx,edx
        div     ebx
        add     dl,'0'
        sub     edi,2
        mov     [edi],dx
L2:     dec     ecx
        jge     L1
        or      eax,eax
        jne     L1
        mov     eax,edi
            }
        }
        
        unsigned int Int64DivMod1E9(unsigned __int64* value)
        {
            _asm {
                mov     ebx,value
                    mov     ecx,1000000000
                    xor     edx,edx
                    mov     eax,[ebx+4]
                    div     ecx
                    mov     [ebx+4],eax
                    mov     eax,[ebx]
                    div     ecx
                    mov     [ebx],eax
                    mov     eax,edx
            }
        }
        
        unsigned int DecDivMod1E9(DECIMAL* value)
        {
            _asm {
                mov     ebx,value
                    mov     ecx,1000000000
                    xor     edx,edx
                    mov     eax,[ebx+4]
                    div     ecx
                    mov     [ebx+4],eax
                    mov     eax,[ebx+12]
                    div     ecx
                    mov     [ebx+12],eax
                    mov     eax,[ebx+8]
                    div     ecx
                    mov     [ebx+8],eax
                    mov     eax,edx
            }
        }
        
        void DecMul10(DECIMAL* value)
        {
            _asm {
                mov     ebx,value
                    mov     eax,[ebx+8]
                    mov     edx,[ebx+12]
                    mov     ecx,[ebx+4]
                    shl     eax,1
                    rcl     edx,1
                    rcl     ecx,1
                    shl     eax,1
                    rcl     edx,1
                    rcl     ecx,1
                    add     eax,[ebx+8]
                    adc     edx,[ebx+12]
                    adc     ecx,[ebx+4]
                    shl     eax,1
                    rcl     edx,1
                    rcl     ecx,1
                    mov     [ebx+8],eax
                    mov     [ebx+12],edx
                    mov     [ebx+4],ecx
            }
        }
        
        void DecAddInt32(DECIMAL* value, unsigned int i)
        {
            _asm {
                mov     edx,value
                    mov     eax,i
                    add     dword ptr [edx+8],eax
                    adc     dword ptr [edx+12],0
                    adc     dword ptr [edx+4],0
            }
        }
        
#pragma warning(default:4035)
        
#else
        
        extern "C" _CRTIMP char* __cdecl _ecvt(double, int, int*, int*);
        extern "C" _CRTIMP double __cdecl atof(const char*);
        
        void DoubleToNumber(double value, int precision, NUMBER* number)
        {
            number->precision = precision;
            if (((FPDOUBLE*)&value)->exp == 0x7FF) {
                number->scale = ((FPDOUBLE*)&value)->mantLo || ((FPDOUBLE*)&value)->mantHi? SCALE_NAN: SCALE_INF;
                number->sign = ((FPDOUBLE*)&value)->sign;
                number->digits[0] = 0;
            }
            else {
                char* src = _ecvt(value, precision, &number->scale, &number->sign);
                wchar* dst = number->digits;
                if (*src != '0') {
                    while (*src) *dst++ = *src++;
                }
                *dst = 0;
            }
        }
        
        void NumberToDouble(NUMBER* number, double* value)
        {
            if (number->digits[0] != 0) {
                char buffer[64];
                char* p = buffer;
                if (number->sign) *p++ = '-';
                for (wchar* src = number->digits; *src;) *p++ = (char)*src++;
                int i = number->scale - number->precision;
                if (i != 0) {
                    *p++ = 'e';
                    if (i < 0) {
                        *p++ = '-';
                        i = -i;
                    }
                    if (i >= 100) {
                        if (i > 999) i = 999;
                        *p++ = i / 100 + '0';
                        i %= 100;
                    }
                    *p++ = i / 10 + '0';
                    *p++ = i % 10 + '0';
                }
                *p = 0;
                *value = atof(buffer);
            }
            else {
                *value = 0;
            }
        }
        
        wchar* Int32ToDecChars(wchar* p, unsigned int value, int digits)
        {
            while (--digits >= 0 || value != 0) {
                *--p = value % 10 + '0';
                value /= 10;
            }
            return p;
        }
        
        unsigned int Int64DivMod1E9(unsigned __int64* value)
        {
            unsigned int rem = (unsigned int)(*value % 1000000000);
            *value /= 1000000000;
            return rem;
        }
        
        unsigned int D32DivMod1E9(unsigned int hi32, unsigned long* lo32)
        {
            unsigned __int64 n = (unsigned __int64)hi32 << 32 | *lo32;
            *lo32 = (unsigned int)(n / 1000000000);
            return (unsigned int)(n % 1000000000);
        }
        
        unsigned int DecDivMod1E9(DECIMAL* value)
        {
            return D32DivMod1E9(D32DivMod1E9(D32DivMod1E9(0,
                &value->Hi32), &value->Mid32), &value->Lo32);
        }
        
        void DecShiftLeft(DECIMAL* value)
        {
            unsigned int c0 = value->Lo32 & 0x80000000? 1: 0;
            unsigned int c1 = value->Mid32 & 0x80000000? 1: 0;
            value->Lo32 <<= 1;
            value->Mid32 = value->Mid32 << 1 | c0;
            value->Hi32 = value->Hi32 << 1 | c1;
        }
        
        int D32AddCarry(unsigned long* value, unsigned int i)
        {
            unsigned int v = *value;
            unsigned int sum = v + i;
            *value = sum;
            return sum < v || sum < i? 1: 0;
        }
        
        void DecAdd(DECIMAL* value, DECIMAL* d)
        {
            if (D32AddCarry(&value->Lo32, d->Lo32)) {
                if (D32AddCarry(&value->Mid32, 1)) {
                    D32AddCarry(&value->Hi32, 1);
                }
            }
            if (D32AddCarry(&value->Mid32, d->Mid32)) {
                D32AddCarry(&value->Hi32, 1);
            }
            D32AddCarry(&value->Hi32, d->Hi32);
        }
        
        void DecMul10(DECIMAL* value)
        {
            DECIMAL d = *value;
            DecShiftLeft(value);
            DecShiftLeft(value);
            DecAdd(value, &d);
            DecShiftLeft(value);
        }
        
        void DecAddInt32(DECIMAL* value, unsigned int i)
        {
            if (D32AddCarry(&value->Lo32, i)) {
                if (D32AddCarry(&value->Mid32, 1)) {
                    D32AddCarry(&value->Hi32, 1);
                }
            }
        }
        
#endif // _X86_
        
        inline void AddStringRef(wchar** ppBuffer, STRINGREF strRef)
        {
            wchar* buffer = strRef->GetBuffer();
            DWORD length = strRef->GetStringLength();    
            for (wchar* str = buffer; str < buffer + length; (*ppBuffer)++, str++)
            {
                **ppBuffer = *str;
            }
        }
        
        wchar* MatchChars(wchar* p, wchar* str)
        {
            if (!*str) return 0;
            for (; *str; p++, str++) 
            {
                if (*p != *str) //We only hurt the failure case
                {
                    if ((*str == 0xA0) && (*p == 0x20)) // This fix is for French or Kazakh cultures. Since a user cannot type 0xA0 as a 
                        // space character we use 0x20 space character instead to mean the same.
                        continue;
                    return 0;
                }
            }
            return p;
        }
        
        wchar* Int32ToHexChars(wchar* p, unsigned int value, int hexBase, int digits)
        {
            while (--digits >= 0 || value != 0) {
                int digit = value & 0xF;
                *--p = digit + (digit < 10? '0': hexBase);
                value >>= 4;
            }
            return p;
        }
        
        STRINGREF Int32ToDecStr(int value, int digits, STRINGREF sNegative)
        {
            THROWSCOMPLUSEXCEPTION();
            CQuickBytes buf;
            
            UINT bufferLength = 100;
            int negLength = 0;
            wchar* src = NULL;
            if (digits < 1) digits = 1;
            
            if (value < 0) {
                src = sNegative->GetBuffer();
                negLength = sNegative->GetStringLength();
                if (negLength > 85) {// Since an int32 can have maximum of 10 chars as a String
                    bufferLength = negLength + 15;
                }
            }
            
            wchar *buffer = (wchar*)buf.Alloc(bufferLength * sizeof(WCHAR));
            if (!buffer)
                COMPlusThrowOM();
            
            wchar* p = Int32ToDecChars(buffer + bufferLength, value >= 0? value: -value, digits);
            if (value < 0) {
                for (int i =negLength - 1; i >= 0; i--)
                {
                    *(--p) = *(src+i);
                }
            }
            
            _ASSERTE( buffer + bufferLength - p >=0 && buffer <= p);
            return COMString::NewString(p, buffer + bufferLength - p);
        }
        
        STRINGREF UInt32ToDecStr(unsigned int value, int digits)
        {
            wchar buffer[100];
            if (digits < 1) digits = 1;
            wchar* p = Int32ToDecChars(buffer + 100, value, digits);
            return COMString::NewString(p, buffer + 100 - p);
        }
        
        STRINGREF Int32ToHexStr(unsigned int value, int hexBase, int digits)
        {
            wchar buffer[100];
            if (digits < 1) digits = 1;
            wchar* p = Int32ToHexChars(buffer + 100, value, hexBase, digits);
            return COMString::NewString(p, buffer + 100 - p);
        }
        
        void Int32ToNumber(int value, NUMBER* number)
        {
            wchar buffer[INT32_PRECISION+1];
            number->precision = INT32_PRECISION;
            if (value >= 0) {
                number->sign = 0;
            }
            else {
                number->sign = 1;
                value = -value;
            }
            wchar* p = Int32ToDecChars(buffer + INT32_PRECISION, value, 0);
            int i = buffer + INT32_PRECISION - p;
            number->scale = i;
            wchar* dst = number->digits;
            while (--i >= 0) *dst++ = *p++;
            *dst = 0;
        }
        
        void UInt32ToNumber(unsigned int value, NUMBER* number)
        {
            wchar buffer[UINT32_PRECISION+1];
            number->precision = UINT32_PRECISION;
            number->sign = 0;
            wchar* p = Int32ToDecChars(buffer + UINT32_PRECISION, value, 0);
            int i = buffer + UINT32_PRECISION - p;
            number->scale = i;
            wchar* dst = number->digits;
            while (--i >= 0) *dst++ = *p++;
            *dst = 0;
        }
        
        // Returns 1 on success, 0 for fail.
        int NumberToInt32(NUMBER* number, int* value)
        {
            int i = number->scale;
            if (i > INT32_PRECISION || i < number->precision) return 0;
            wchar* p = number->digits;
            int n = 0;
            while (--i >= 0) {
                if ((unsigned int)n > (0x7FFFFFFF / 10)) return 0;
                n *= 10;
                if (*p) n += *p++ - '0';
            }
            if (number->sign) {
                n = -n;
                if (n > 0) return 0;
            }
            else {
                if (n < 0) return 0;
            }
            *value = n;
            return 1;
        }
        
        // Returns 1 on success, 0 for fail.
        int NumberToUInt32(NUMBER* number, unsigned int* value)
        {
            int i = number->scale;
            if (i > UINT32_PRECISION || i < number->precision || number->sign) return 0;
            wchar* p = number->digits;
            unsigned int n = 0;
            while (--i >= 0) {
                if (n > ((unsigned int)0xFFFFFFFF / 10)) return 0;
                n *= 10;
                if (*p) {
                    unsigned int newN = n + (*p++ - '0');
                    // Detect an overflow here...
                    if (newN < n) return 0;
                    n = newN;
                }
            }
            *value = n;
            return 1;
        }
        
        // Returns 1 on success, 0 for fail.
        int HexNumberToUInt32(NUMBER* number, unsigned int* value)
        {
            int i = number->scale;
            if (i > UINT32_PRECISION || i < number->precision) return 0;
            wchar* p = number->digits;
            unsigned int n = 0;
            while (--i >= 0) {
                if (n > ((unsigned int)0xFFFFFFFF / 16)) return 0;
                n *= 16;
                if (*p) {
                    unsigned int newN = n;
                    if (*p) 
                    {
                        if (*p >='0' && *p <='9')
                            newN += *p - '0';
                        else
                        {
                            *p &= ~0x20; // Change to UCase
                            newN += *p - 'A' + 10;
                        }
                        p++;
                    }
                    
                    // Detect an overflow here...
                    if (newN < n) return 0;
                    n = newN;
                }
            }
            *value = n;
            return 1;
        }
        
#define LO32(x) ((unsigned int)(x))
#define HI32(x) ((unsigned int)(((x) & 0xFFFFFFFF00000000L) >> 32))
        
        STRINGREF Int64ToDecStr(__int64 value, int digits, STRINGREF sNegative)
        {
            THROWSCOMPLUSEXCEPTION();
            CQuickBytes buf;
            
            if (digits < 1) digits = 1;
            int sign = HI32(value);
            UINT bufferLength = 100;
            
            if (sign < 0) {
                value = -value;
                int negLength = sNegative->GetStringLength();
                if (negLength > 75) {// Since max is 20 digits
                    bufferLength = negLength + 25;
                }
            }
            
            wchar *buffer = (wchar*)buf.Alloc(bufferLength * sizeof(WCHAR));
            if (!buffer)
                COMPlusThrowOM();
            wchar* p = buffer + bufferLength;
            while (HI32(value)) {
                p = Int32ToDecChars(p, Int64DivMod1E9((unsigned __int64*)&value), 9);
                digits -= 9;
            }
            p = Int32ToDecChars(p, LO32(value), digits);
            if (sign < 0) {
                wchar* src = sNegative->GetBuffer();    
                for (int i =sNegative->GetStringLength() - 1; i >= 0; i--)
                {
                    *(--p) = *(src+i);
                }
            }
            return COMString::NewString(p, buffer + bufferLength - p);
        }
        
        STRINGREF UInt64ToDecStr(unsigned __int64 value, int digits)
        {
            wchar buffer[100];
            if (digits < 1) digits = 1;
            wchar* p = buffer + 100;
            while (HI32(value)) {
                p = Int32ToDecChars(p, Int64DivMod1E9(&value), 9);
                digits -= 9;
            }
            p = Int32ToDecChars(p, LO32(value), digits);
            return COMString::NewString(p, buffer + 100 - p);
        }
        
        STRINGREF Int64ToHexStr(unsigned __int64 value, int hexBase, int digits)
        {
            wchar buffer[100];
            wchar* p;
            if (HI32(value)) {
                Int32ToHexChars(buffer + 100, LO32(value), hexBase, 8);
                p = Int32ToHexChars(buffer + 100 - 8, HI32(value), hexBase, digits - 8);
            }
            else {
                if (digits < 1) digits = 1;
                p = Int32ToHexChars(buffer + 100, LO32(value), hexBase, digits);
            }
            return COMString::NewString(p, buffer + 100 - p);
        }
        
        void Int64ToNumber(__int64 value, NUMBER* number)
        {
            wchar buffer[INT64_PRECISION+1];
            number->precision = INT64_PRECISION;
            if (value >= 0) {
                number->sign = 0;
            }
            else {
                number->sign = 1;
                value = -value;
            }
            wchar* p = buffer + INT64_PRECISION;
            while (HI32(value)) {
                p = Int32ToDecChars(p, Int64DivMod1E9((unsigned __int64*)&value), 9);
            }
            p = Int32ToDecChars(p, LO32(value), 0);
            int i = buffer + INT64_PRECISION - p;
            number->scale = i;
            wchar* dst = number->digits;
            while (--i >= 0) *dst++ = *p++;
            *dst = 0;
        }
        
        void UInt64ToNumber(unsigned __int64 value, NUMBER* number)
        {
            wchar buffer[UINT64_PRECISION+1];
            number->precision = UINT64_PRECISION;
            number->sign = 0;
            wchar* p = buffer + UINT64_PRECISION;
            while (HI32(value)) {
                p = Int32ToDecChars(p, Int64DivMod1E9(&value), 9);
            }
            p = Int32ToDecChars(p, LO32(value), 0);
            int i = buffer + UINT64_PRECISION - p;
            number->scale = i;
            wchar* dst = number->digits;
            while (--i >= 0) *dst++ = *p++;
            *dst = 0;
        }
        
        int NumberToInt64(NUMBER* number, __int64* value)
        {
            int i = number->scale;
            if (i > INT64_PRECISION || i < number->precision) return 0;
            wchar* p = number->digits;
            __int64 n = 0;
            while (--i >= 0) {
                if ((unsigned __int64)n > (0x7FFFFFFFFFFFFFFF / 10)) return 0;
                n *= 10;
                if (*p) n += *p++ - '0';
            }
            if (number->sign) {
                n = -n;
                if (n > 0) return 0;
            }
            else {
                if (n < 0) return 0;
            }
            *value = n;
            return 1;
        }
        
        // Returns 1 on success, 0 for fail.
        int NumberToUInt64(NUMBER* number, unsigned __int64* value)
        {
            int i = number->scale;
            if (i > UINT64_PRECISION || i < number->precision || number->sign) return 0;
            wchar* p = number->digits;
            unsigned __int64 n = 0;
            while (--i >= 0) {
                if (n > ((unsigned __int64)0xFFFFFFFFFFFFFFFF / 10)) return 0;
                n *= 10;
                if (*p) {
                    unsigned __int64 newN = n + (*p++ - '0');
                    // Detect an overflow here...
                    if (newN < n) return 0;
                    n = newN;
                }
            }
            *value = n;
            return 1;
        }
        
        // Returns 1 on success, 0 for fail.
        int HexNumberToUInt64(NUMBER* number, unsigned __int64* value)
        {
            int i = number->scale;
            if (i > UINT64_PRECISION || i < number->precision) return 0;
            wchar* p = number->digits;
            unsigned __int64 n = 0;
            while (--i >= 0) {
                if (n > ((unsigned __int64)0xFFFFFFFFFFFFFFFF / 16)) return 0;
                n *= 16;
                if (*p) {
                    unsigned __int64 newN = n;
                    if (*p) 
                    {
                        if (*p >='0' && *p <='9')
                            newN += *p - '0';
                        else
                        {
                            *p &= ~0x20; // Change to UCase
                            newN += *p - 'A' + 10; 
                        }
                        p++;
                    }
                    
                    // Detect an overflow here...
                    if (newN < n) return 0;
                    n = newN;
                }
            }
            *value = n;
            return 1;
        }
        
        void DecimalToNumber(DECIMAL* value, NUMBER* number)
        {
            wchar buffer[DECIMAL_PRECISION+1];
            DECIMAL d = *value;
            number->precision = DECIMAL_PRECISION;
            number->sign = d.sign? 1: 0;
            wchar* p = buffer + DECIMAL_PRECISION;
            while (d.Mid32 | d.Hi32) {
                p = Int32ToDecChars(p, DecDivMod1E9(&d), 9);
            }
            p = Int32ToDecChars(p, d.Lo32, 0);
            int i = buffer + DECIMAL_PRECISION - p;
            number->scale = i - d.scale;
            wchar* dst = number->digits;
            while (--i >= 0) *dst++ = *p++;
            *dst = 0;
        }
        
        int NumberToDecimal(NUMBER* number, DECIMAL* value)
        {
            DECIMAL d;
            d.wReserved = 0;
            d.signscale = 0;
            d.Hi32 = 0;
            d.Lo32 = 0;
            d.Mid32 = 0;
            wchar* p = number->digits;
            if (*p) {
                int e = number->scale;
                if (e > DECIMAL_PRECISION || e < -DECIMAL_PRECISION) return 0;
                while ((e > 0 || *p && e > -28) &&
                    (d.Hi32 < 0x19999999 || d.Hi32 == 0x19999999 &&
                    (d.Mid32 < 0x99999999 || d.Mid32 == 0x99999999 &&
                    (d.Lo32 < 0x99999999 || d.Lo32 == 0x99999999 &&
                    *p <= '5')))) {
                    DecMul10(&d);
                    if (*p) DecAddInt32(&d, *p++ - '0');
                    e--;
                }
                if (*p++ >= '5') {
                    bool round = true;
                    if (*(p-1) == '5' && *(p-2) % 2 == 0) { // Check if previous digit is even, only if the when we are unsure whether hows to do Banker's rounding
                                                            // For digits > 5 we will be roundinp up anyway.
                        int count = 20; // Look at the next 20 digits to check to round
                        while (*p == '0' && count != 0) {
                            p++;
                            count--;
                        }
                        if (*p == '\0' || count == 0) 
                            round = false;// Do nothing
                    }

                    if (round) {
                    DecAddInt32(&d, 1);
                    if ((d.Hi32 | d.Mid32 | d.Lo32) == 0) {
                        d.Hi32 = 0x19999999;
                        d.Mid32 = 0x99999999;
                        d.Lo32 = 0x9999999A;
                        e++;
                    }
                }
                }
                if (e > 0) return 0;
                d.scale = -e;
                d.sign = number->sign? DECIMAL_NEG: 0;
            }
            *value = d;
            return 1;
        }
        
        void RoundNumber(NUMBER* number, int pos)
        {
            int i = 0;
            while (i < pos && number->digits[i] != 0) i++;
            if (i == pos && number->digits[i] >= '5') {
                while (i > 0 && number->digits[i - 1] == '9') i--;
                if (i > 0) {
                    number->digits[i - 1]++;
                }
                else {
                    number->scale++;
                    number->digits[0] = '1';
                    i = 1;
                }
            }
            else {
                while (i > 0 && number->digits[i - 1] == '0') i--;
            }
            if (i == 0) {
                number->scale = 0;
                number->sign = 0;
            }
            number->digits[i] = 0;
        }
        
        
        wchar ParseFormatSpecifier(STRINGREF str, int* digits)
        {
            if (str != 0) {
                wchar* p = str->GetBuffer();
                wchar ch = *p;
                if (ch != 0) {
                    if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z') {
                        p++;
                        int n = -1;
                        if (*p >= '0' && *p <= '9') {
                            n = *p++ - '0';
                            while (*p >= '0' && *p <= '9') {
                                n = n * 10 + *p++ - '0';
                                if (n >= 10) break;
                            }
                        }
                        if (*p == 0) {
                            *digits = n;
                            return ch;
                        }
                    }
                    return 0;
                }
            }
            *digits = -1;
            return 'G';
        }
        
        wchar* FormatExponent(wchar* buffer, int value, wchar expChar,
            STRINGREF posSignStr, STRINGREF negSignStr, int minDigits)
        {
            wchar digits[11];
            *buffer++ = expChar;
            if (value < 0) {
                AddStringRef(&buffer, negSignStr);
                value = -value;
            }
            else {
                if (posSignStr!= NULL) {
                    AddStringRef(&buffer, posSignStr);
                }
            }
            wchar* p = Int32ToDecChars(digits + 10, value, minDigits);
            int i = digits + 10 - p;
            while (--i >= 0) *buffer++ = *p++;
            return buffer;
        }
        
        wchar* FormatGeneral(wchar* buffer, NUMBER* number, int digits, wchar expChar,
            NUMFMTREF numfmt, BOOL bSuppressScientific = FALSE)
        {
            int digPos = number->scale;
            int scientific = 0;
            if (!bSuppressScientific) { // Don't switch to scientific notation
            if (digPos > digits || digPos < -3) {
                digPos = 1;
                scientific = 1;
            }
            }
            wchar* dig = number->digits;
            if (digPos > 0) {
                do {
                    *buffer++ = *dig != 0? *dig++: '0';
                } while (--digPos > 0);
            }
            else {
                *buffer++ = '0';
            }
            if (*dig != 0) {
                AddStringRef(&buffer, numfmt->sNumberDecimal);
                while (digPos < 0) {
                    *buffer++ = '0';
                    digPos++;
                }
                do {
                    *buffer++ = *dig++;
                } while (*dig != 0);
            }
            if (scientific) buffer = FormatExponent(buffer, number->scale - 1, expChar, numfmt->sPositive, numfmt->sNegative, 2);
            return buffer;
        }
        
        wchar* FormatScientific(wchar* buffer, NUMBER* number, int digits, wchar expChar,
            NUMFMTREF numfmt)
        {
            wchar* dig = number->digits;
            *buffer++ = *dig != 0? *dig++: '0';
            if (digits != 1) // For E0 we would like to suppress the decimal point
                AddStringRef(&buffer, numfmt->sNumberDecimal);
            while (--digits > 0) *buffer++ = *dig != 0? *dig++: '0';
            int e = number->digits[0] == 0? 0: number->scale - 1;
            buffer = FormatExponent(buffer, e, expChar, numfmt->sPositive, numfmt->sNegative, 3);
            return buffer;
        }
        
        wchar* FormatFixed(wchar* buffer, NUMBER* number, int digits, 
            I4ARRAYREF groupDigitsRef, STRINGREF sDecimal, STRINGREF sGroup)
        {
            
            THROWSCOMPLUSEXCEPTION();
            int bufferSize     = 0;                        // the length of the result buffer string.
            int digPos = number->scale;
            wchar* dig = number->digits;
            const I4* groupDigits = NULL;
            if (groupDigitsRef != NULL) {
                groupDigits = groupDigitsRef->GetDirectConstPointerToNonObjectElements();
            }
            
            if (digPos > 0) {
                if (groupDigits != NULL) {
                    
                    int groupSizeIndex = 0;     // index into the groupDigits array.
                    int groupSizeCount = groupDigits[groupSizeIndex];   // the current total of group size.
                    int groupSizeLen   = groupDigitsRef->GetNumComponents();    // the length of groupDigits array.
                    int bufferSize     = digPos;                        // the length of the result buffer string.
                    int groupSeparatorLen = sGroup->GetStringLength();  // the length of the group separator string.
                    int groupSize = 0;                                      // the current group size.
                    
                    //
                    // Find out the size of the string buffer for the result.
                    //
                    if (groupSizeLen != 0) // You can pass in 0 length arrays
                    {
                        while (digPos > groupSizeCount) {
                            groupSize = groupDigits[groupSizeIndex];
                            if (groupSize == 0) {
                                break;
                            }
                            
                            bufferSize += groupSeparatorLen;
                            if (groupSizeIndex < groupSizeLen - 1) {
                                groupSizeIndex++;
                            }
                            groupSizeCount += groupDigits[groupSizeIndex];
                            if (groupSizeCount < 0 || bufferSize < 0) {
                                COMPlusThrow(kArgumentOutOfRangeException); // if we overflow
                            }
                        }
                        if (groupSizeCount == 0) // If you passed in an array with one entry as 0, groupSizeCount == 0
                            groupSize = 0;
                        else
                            groupSize = groupDigits[0];
                    }
                    
                    groupSizeIndex = 0;
                    int digitCount = 0;
                    int digStart;
                    int digLength = (int)wcslen(dig);
                    digStart = (digPos<digLength)?digPos:digLength;
                    wchar* p = buffer + bufferSize - 1;
                    for (int i = digPos - 1; i >=0; i--) {
                        *(p--) = (i<digStart)?dig[i]:'0';
                        
                        if (groupSize > 0) { 
                            digitCount++;
                            if (digitCount == groupSize && i != 0) {
                                for (int j = groupSeparatorLen - 1; j >=0; j--) {
                                    *(p--) = sGroup->GetBuffer()[j];
                                }
                                
                                if (groupSizeIndex < groupSizeLen - 1) {
                                    groupSizeIndex++;
                                    groupSize = groupDigits[groupSizeIndex];
                                }
                                digitCount = 0;
                            }
                        }
                    }
                    buffer += bufferSize;
                    dig += digStart;
                } else {
                    do {
                        *buffer++ = *dig != 0? *dig++: '0';
                    } while (--digPos > 0);
                }
            }
            else {
                *buffer++ = '0';
            }
            if (digits > 0) {
                AddStringRef(&buffer, sDecimal);
                while (digPos < 0 && digits > 0) {
                    *buffer++ = '0';
                    digPos++;
                    digits--;
                }
                while (digits > 0) {
                    *buffer++ = *dig != 0? *dig++: '0';
                    digits--;
                }
            }
            return buffer;
        }
        
        wchar* FormatNumber(wchar* buffer, NUMBER* number, int digits, NUMFMTREF numfmt)
        {
            char ch;
            char* fmt;
            fmt = number->sign?
                negNumberFormats[numfmt->cNegativeNumberFormat]:
            posNumberFormat;
            
            while ((ch = *fmt++) != 0) {
                switch (ch) {
                case '#':
                    buffer = FormatFixed(buffer, number, digits, 
                        numfmt->cNumberGroup,
                        numfmt->sNumberDecimal, numfmt->sNumberGroup);
                    break;
                case '-':
                    AddStringRef(&buffer, numfmt->sNegative);
                    break;
                default:
                    *buffer++ = ch;
                }
            }
            return buffer;    
            
        }
        
        wchar* FormatCurrency(wchar* buffer, NUMBER* number, int digits, NUMFMTREF numfmt)
        {
            char ch;
            char* fmt;
            fmt = number->sign?
                negCurrencyFormats[numfmt->cNegCurrencyFormat]:
            posCurrencyFormats[numfmt->cPosCurrencyFormat];
            
            while ((ch = *fmt++) != 0) {
                switch (ch) {
                case '#':
                    buffer = FormatFixed(buffer, number, digits, 
                        numfmt->cCurrencyGroup,
                        numfmt->sCurrencyDecimal, numfmt->sCurrencyGroup);
                    break;
                case '-':
                    AddStringRef(&buffer, numfmt->sNegative);
                    break;
                case '$':
                    AddStringRef(&buffer, numfmt->sCurrency);
                    break;
                default:
                    *buffer++ = ch;
                }
            }
            return buffer;
        }
        
        wchar* FormatPercent(wchar* buffer, NUMBER* number, int digits, NUMFMTREF numfmt)
        {
            char ch;
            char* fmt;
            fmt = number->sign?
                negPercentFormats[numfmt->cNegativePercentFormat]:
            posPercentFormats[numfmt->cPositivePercentFormat];
            
            while ((ch = *fmt++) != 0) {
                switch (ch) {
                case '#':
                    buffer = FormatFixed(buffer, number, digits, 
                        numfmt->cPercentGroup,
                        numfmt->sPercentDecimal, numfmt->sPercentGroup);
                    break;
                case '-':
                    AddStringRef(&buffer, numfmt->sNegative);
                    break;
                case '%':
                    AddStringRef(&buffer, numfmt->sPercent);
                    break;
                default:
                    *buffer++ = ch;
                }
            }
            return buffer;    
        }
        
        STRINGREF NumberToString(NUMBER* number, wchar format, int digits, NUMFMTREF numfmt, BOOL bDecimal = FALSE )
        {
            THROWSCOMPLUSEXCEPTION();
            
            
            // Do the worst case calculation
            /* US English - for Double.MinValue.ToString("C99"); we require 514 characters
            ----------
            2 paranthesis
            1 currency character
            308 characters
            103 group seperators 
            1 decimal separator
            99 0's
            
              digPos + 99 + 6(slack) => digPos + 105
              C
              sNegative
              sCurrencyGroup
              sCurrencyDecimal
              sCurrency
              F
              sNegative
              sNumberDecimal
              N
              sNegative
              sNumberDecimal
              sNumberGroup
              E
              sNegative
              sPositive
              sNegative (for exponent)
              sPositive
              sNumberDecimal
              G
              sNegative
              sPositive
              sNegative (for exponent)
              sPositive
              sNumberDecimal
              P (+2 for some spaces)
              sNegative
              sPercentGroup
              sPercentDecimal
              sPercent
            */
            
            INT64 newBufferLen = MIN_BUFFER_SIZE;
            
            CQuickBytesSpecifySize<LARGE_BUFFER_SIZE * sizeof(WCHAR)> buf;
            
            wchar *buffer = NULL; 
            wchar* dst = NULL;
            wchar ftype = format & 0xFFDF;
            int digCount = 0;
            
            switch (ftype) {
            case 'C':
                if (digits < 0) digits = numfmt->cCurrencyDecimals;
                if (number->scale < 0)
                    digCount = 0;
                else
                    digCount = number->scale + digits;
                
                newBufferLen += digCount;
                newBufferLen += numfmt->sNegative->GetStringLength(); // For number and exponent
                newBufferLen += ((INT64)numfmt->sCurrencyGroup->GetStringLength() * digCount); // For all the grouping sizes
                newBufferLen += numfmt->sCurrencyDecimal->GetStringLength();
                newBufferLen += numfmt->sCurrency->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                RoundNumber(number, number->scale + digits); // Don't change this line to use digPos since digCount could have its sign changed.
                dst = FormatCurrency(dst, number, digits, numfmt);
                break;
            case 'F':
                if (digits < 0) digits = numfmt->cNumberDecimals;
                
                if (number->scale < 0)
                    digCount = 0;
                else
                    digCount = number->scale + digits;
                
                
                newBufferLen += digCount;
                newBufferLen += numfmt->sNegative->GetStringLength(); // For number and exponent
                newBufferLen += numfmt->sNumberDecimal->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                RoundNumber(number, number->scale + digits);
                if (number->sign) {
                    AddStringRef(&dst, numfmt->sNegative);
                }        
                dst = FormatFixed(dst, number, digits, 
                    NULL,
                    numfmt->sNumberDecimal, NULL);
                break;
            case 'N':
                if (digits < 0) digits = numfmt->cNumberDecimals; // Since we are using digits in our calculation
                
                if (number->scale < 0)
                    digCount = 0;
                else
                    digCount = number->scale + digits;
                
                
                newBufferLen += digCount;
                newBufferLen += numfmt->sNegative->GetStringLength(); // For number and exponent
                newBufferLen += ((INT64)numfmt->sNumberGroup->GetStringLength()) * digCount; // For all the grouping sizes
                newBufferLen += numfmt->sNumberDecimal->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                RoundNumber(number, number->scale + digits);
                dst = FormatNumber(dst, number, digits, numfmt);
                break;
            case 'E':
                if (digits < 0) digits = 6;
                digits++;
                
                newBufferLen += digits;
                newBufferLen += (((INT64)numfmt->sNegative->GetStringLength() + numfmt->sPositive->GetStringLength()) *2); // For number and exponent
                newBufferLen += numfmt->sNumberDecimal->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                RoundNumber(number, digits);
                if (number->sign) {
                    AddStringRef(&dst, numfmt->sNegative);
                }
                dst = FormatScientific(dst, number, digits, format, numfmt);
                break;
/*             case 'Z':
                if (!bDecimal)
                    COMPlusThrow(kFormatException, L"Format_BadFormatSpecifier");
                bDecimal = FALSE;
                */
            case 'G':
                {
                    bool enableRounding = true;
                    if (digits < 1) {
                        if (bDecimal && (digits == -1)) { // Default to 29 digits precision only for G formatting without a precision specifier
                            digits = DECIMAL_PRECISION;
                            enableRounding = false;  // Turn off rounding for ECMA compliance to output trailing 0's after decimal as significant
                        }
                        else {
                            digits = number->precision;
                        }
                    }

                newBufferLen += digits;
                newBufferLen += ((numfmt->sNegative->GetStringLength() + numfmt->sPositive->GetStringLength()) *2); // For number and exponent
                newBufferLen += numfmt->sNumberDecimal->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                    if (enableRounding) // Don't round for G formatting without precision
                        RoundNumber(number, digits); // This also fixes up the minus zero case
					else {
						if (bDecimal && (number->digits[0] == 0)) { // Minus zero should be formatted as 0
							number->sign = 0;
							number->scale = 0;
						}
					}
                if (number->sign) {
                    AddStringRef(&dst, numfmt->sNegative);
                }
                    dst = FormatGeneral(dst, number, digits, format - ('G' - 'E'), numfmt, !enableRounding);
                }
                break;
            case 'P':
                if (digits < 0) digits = numfmt->cPercentDecimals;
                number->scale += 2;
                
                if (number->scale < 0)
                    digCount = 0;
                else
                    digCount = number->scale + digits;
                
                
                newBufferLen += digCount;
                newBufferLen += numfmt->sNegative->GetStringLength(); // For number and exponent
                newBufferLen += ((INT64)numfmt->sPercentGroup->GetStringLength()) * digCount; // For all the grouping sizes
                newBufferLen += numfmt->sPercentDecimal->GetStringLength();
                newBufferLen += numfmt->sPercent->GetStringLength();
                
                newBufferLen = newBufferLen * sizeof(WCHAR);
                _ASSERTE(newBufferLen >= MIN_BUFFER_SIZE * sizeof(WCHAR));
                buffer = (WCHAR*)buf.Alloc(newBufferLen);
                if (!buffer)
                    COMPlusThrowOM();
                dst = buffer;
                
                RoundNumber(number, number->scale + digits);    
                dst = FormatPercent(dst, number, digits, numfmt);
                break;
            default:
                COMPlusThrow(kFormatException, L"Format_BadFormatSpecifier");
    }
    _ASSERTE((dst - buffer >= 0) && (dst - buffer) <= newBufferLen);
    return COMString::NewString(buffer, dst - buffer);
}

wchar* FindSection(wchar* format, int section)
{
    wchar* src;
    wchar ch;
    if (section == 0) return format;
    src = format;
    for (;;) {
        switch (ch = *src++) {
        case '\'':
        case '"':
            while (*src != 0 && *src++ != ch);
            break;
        case '\\':
            if (*src != 0) src++;
            break;
        case ';':
            if (--section != 0) break;
            if (*src != 0 && *src != ';') return src;
        case 0:
            return format;
        }
    }
}

STRINGREF NumberToStringFormat(NUMBER* number, STRINGREF str, NUMFMTREF numfmt)
{
    THROWSCOMPLUSEXCEPTION();
    int digitCount;
    int decimalPos;
    int firstDigit;
    int lastDigit;
    int digPos;
    int scientific;
    int percent;
    int permille;
    int thousandPos;
    int thousandCount = 0;
    int thousandSeps;
    int scaleAdjust;
    int adjust;
    wchar* format=NULL;
    wchar* section=NULL;
    wchar* src=NULL;
    wchar* dst=NULL;
    wchar* dig=NULL;
    wchar ch;
    wchar* buffer=NULL;
    CQuickBytes buf;
    
    format = str->GetBuffer();
    section = FindSection(format, number->digits[0] == 0? 2: number->sign? 1: 0);
    
ParseSection:
    digitCount = 0;
    decimalPos = -1;
    firstDigit = 0x7FFFFFFF;
    lastDigit = 0;
    scientific = 0;
    percent = 0;
    permille = 0;
    thousandPos = -1;
    thousandSeps = 0;
    scaleAdjust = 0;
    src = section;
    while ((ch = *src++) != 0 && ch != ';') {
        switch (ch) {
        case '#':
            digitCount++;
            break;
        case '0':
            if (firstDigit == 0x7FFFFFFF) firstDigit = digitCount;
            digitCount++;
            lastDigit = digitCount;
            break;
        case '.':
            if (decimalPos < 0) {
                decimalPos = digitCount;
            }
            break;
        case ',':
            if (digitCount > 0 && decimalPos < 0) {
                if (thousandPos >= 0) {
                    if (thousandPos == digitCount) {
                        thousandCount++;
                        break;
                    }
                    thousandSeps = 1;
                }
                thousandPos = digitCount;
                thousandCount = 1;
            }
            break;
        case '%':
            percent++;
            scaleAdjust += 2;
            break;
        case 0x2030:
            permille++;
            scaleAdjust += 3;
            break;
        case '\'':
        case '"':
            while (*src != 0 && *src++ != ch);
            break;
        case '\\':
            if (*src != 0) src++;
            break;
        case 'E':
        case 'e':
            if (*src=='0' || ((*src == '+' || *src == '-') && src[1] == '0')) {
                while (*++src == '0');
                scientific = 1;
            }
            break;
        }
    }
    
    if (decimalPos < 0) decimalPos = digitCount;
    if (thousandPos >= 0) {
        if (thousandPos == decimalPos) {
            scaleAdjust -= thousandCount * 3;
        }
        else {
            thousandSeps = 1;
        }
    }
    if (number->digits[0] != 0) {
        number->scale += scaleAdjust;
        int pos = scientific? digitCount: number->scale + digitCount - decimalPos;
        RoundNumber(number, pos);
        if (number->digits[0] == 0) {
            src = FindSection(format, 2);
            if (src != section) {
                section = src;
                goto ParseSection;
            }
        }
    } else {
        number->sign = 0; // We need to format -0 without the sign set.
    }
    
    firstDigit = firstDigit < decimalPos? decimalPos - firstDigit: 0;
    lastDigit = lastDigit > decimalPos? decimalPos - lastDigit: 0;
    if (scientific) {
        digPos = decimalPos;
        adjust = 0;
    }
    else {
        digPos = number->scale > decimalPos? number->scale: decimalPos;
        adjust = number->scale - decimalPos;
    }
    src = section;
    dig = number->digits;
    
    // Find maximum number of characters that the destination string can grow by
    // in the following while loop.  Use this to avoid buffer overflows.
    // Longest strings are potentially +/- signs with 10 digit exponents, 
    // or decimal numbers, or the while loops copying from a quote or a \ onwards.
    // Check for positive and negative
    UINT64 maxStrIncLen = 0; // We need this to be UINT64 since the percent computation could go beyond a UINT.
    if (number->sign) {
        maxStrIncLen = numfmt->sNegative->GetStringLength();
    }
    else {
        maxStrIncLen = numfmt->sPositive->GetStringLength();
    }
    
    // Add for any big decimal seperator
    maxStrIncLen += numfmt->sNumberDecimal->GetStringLength();
    
    // Add for scientific
    if (scientific) {
        int inc1 = numfmt->sPositive->GetStringLength();
        int inc2 = numfmt->sNegative->GetStringLength();
        maxStrIncLen +=(inc1>inc2)?inc1:inc2;
    }
    
    // Add for percent separator
    if (percent) {
        maxStrIncLen += ((INT64)numfmt->sPercent->GetStringLength()) * percent;
    }
    
    // Add for permilli separator
    if (permille) {
        maxStrIncLen += ((INT64)numfmt->sPerMille->GetStringLength()) * permille;
    }
    
    //adjust can be negative, so we make this an int instead of an unsigned int.
    // adjust represents the number of characters over the formatting eg. format string is "0000" and you are trying to
    // format 100000 (6 digits). Means adjust will be 2. On the other hand if you are trying to format 10 adjust will be
    // -2 and we'll need to fixup these digits with 0 padding if we have 0 formatting as in this example.
    INT64 adjustLen=(adjust>0)?adjust:0; // We need to add space for these extra characters anyway.
	CQuickBytes thousands;
    INT32 bufferLen2 = 125;
    INT32 *thousandsSepPos = NULL;
    INT32 thousandsSepCtr = -1;
    
    if (thousandSeps) { // Fixup possible buffer overrun problems
		// We need to precompute this outside the number formatting loop
		int groupSizeLen = numfmt->cNumberGroup->GetNumComponents(); 
		if(groupSizeLen == 0) {
            thousandSeps = 0; // Nothing to add
		}
		else {
			thousandsSepPos = (INT32 *)thousands.Alloc(bufferLen2 * sizeof(INT32));
			if (!thousandsSepPos)
				COMPlusThrowOM();
			// rajeshc - We need this array to figure out where to insert the thousands seperator. We would have to traverse the string
			// backwords. PIC formatting always traverses forwards. These indices are precomputed to tell us where to insert
			// the thousands seperator so we can get away with traversing forwards. Note we only have to compute upto digPos.
			// The max is not bound since you can have formatting strings of the form "000,000..", and this
			// should handle that case too.
			
			const I4* groupDigits = numfmt->cNumberGroup->GetDirectConstPointerToNonObjectElements();
			_ASSERTE(groupDigits != NULL);
	        
			int groupSizeIndex = 0;     // index into the groupDigits array.
			INT64 groupTotalSizeCount = 0;
			int groupSizeLen   = numfmt->cNumberGroup->GetNumComponents();    // the length of groupDigits array.
			if (groupSizeLen != 0)
				groupTotalSizeCount = groupDigits[groupSizeIndex];   // the current running total of group size.
			int groupSize = groupTotalSizeCount;
	        
			int totalDigits = digPos + ((adjust < 0)?adjust:0); // actual number of digits in o/p
			int numDigits = (firstDigit > totalDigits) ? firstDigit : totalDigits;
			while (numDigits > groupTotalSizeCount) {
				if (groupSize == 0)
					break;
				thousandsSepPos[++thousandsSepCtr] = groupTotalSizeCount;
				if (groupSizeIndex < groupSizeLen - 1) {
					groupSizeIndex++;
					groupSize = groupDigits[groupSizeIndex];
				}
				groupTotalSizeCount += groupSize;
				if (bufferLen2 - thousandsSepCtr < 10) { // Slack of 10
					bufferLen2 *= 2;
					HRESULT hr2 = thousands.ReSize(bufferLen2*sizeof(INT32)); // memcopied by QuickBytes automatically
					if (FAILED(hr2))
						COMPlusThrowOM();
					thousandsSepPos = (INT32 *)thousands.Ptr(); 
				}
			}
			
			// We already have computed the number of separators above. Simply add space for them.
			adjustLen += ( (thousandsSepCtr + 1) * ((INT64)numfmt->sNumberGroup->GetStringLength()));  
        }
    }
    
    maxStrIncLen += adjustLen;
    
    // Allocate temp buffer - gotta deal with Schertz' 500 MB strings.
    // Some computations like when you specify Int32.MaxValue-2 %'s and each percent is setup to be Int32.MaxValue in length
    // will generate a result that will be larget than an unsigned int can hold. This is to protect against overflow.
    UINT64 tempLen = str->GetStringLength() + maxStrIncLen + 10;  // Include a healthy amount of temp space.
    if (tempLen > 0x7FFFFFFF)
        COMPlusThrowOM(); // if we overflow
    
    unsigned int bufferLen = (UINT)tempLen;
    if (bufferLen < 250) // Stay under 512 bytes 
        bufferLen = 250; // This is to prevent unneccessary calls to resize
    buffer = (wchar *) buf.Alloc(bufferLen* sizeof(WCHAR));
    if (!buffer)
        COMPlusThrowOM();
    dst = buffer;
    
    
    
    if (number->sign && section == format) {
        AddStringRef(&dst, numfmt->sNegative);
    }
    
    while ((ch = *src++) != 0 && ch != ';') {
        // Make sure temp buffer is big enough, else resize it.
        if (bufferLen - (unsigned int)(dst-buffer) < 10) {
            int offset = dst - buffer;
            bufferLen *= 2;
            HRESULT hr = buf.ReSize(bufferLen*sizeof(WCHAR));
            if (FAILED(hr))
                COMPlusThrowOM();
            buffer = (wchar*)buf.Ptr(); // memcopied by QuickBytes automatically
            dst = buffer + offset;
        }
        
        switch (ch) {
        case '#':
        case '0':
            {
                while (adjust > 0) { // digPos will be one greater than thousandsSepPos[thousandsSepCtr] since we are at
                    // the character after which the groupSeparator needs to be appended.
                    *dst++ = *dig != 0? *dig++: '0';
                    if (thousandSeps && digPos > 1 && thousandsSepCtr>=0) {
                        if (digPos == thousandsSepPos[thousandsSepCtr] + 1)  {
                            AddStringRef(&dst, numfmt->sNumberGroup);
                            thousandsSepCtr--;
                        } 
                    }
                    digPos--;
                    adjust--;
                }
                if (adjust < 0) {
                    adjust++;
                    ch = digPos <= firstDigit? '0': 0;
                }
                else {
                    ch = *dig != 0? *dig++: digPos > lastDigit? '0': 0;
                }
                if (ch != 0) {
                    if (digPos == 0) {
                        AddStringRef(&dst, numfmt->sNumberDecimal);
                    }
                    
                    *dst++ = ch;
                    if (thousandSeps && digPos > 1 && thousandsSepCtr>=0) {
                        if (digPos == thousandsSepPos[thousandsSepCtr] + 1) {
                            AddStringRef(&dst, numfmt->sNumberGroup);
                            thousandsSepCtr--;
                        }
                    }
                }
                
                digPos--;
                break;
            }
        case '.':
            break;
        case 0x2030:
            AddStringRef(&dst, numfmt->sPerMille);
            break;
        case '%':
            AddStringRef(&dst, numfmt->sPercent);
            break;
        case ',':
            break;
        case '\'':
        case '"':
            // Buffer overflow possibility
            while (*src != 0 && *src != ch) {
                *dst++ = *src++;
                if ((unsigned int)(dst-buffer) == bufferLen-1) {
                    if (bufferLen - (unsigned int)(dst-buffer) < maxStrIncLen) {
                        int offset = dst - buffer;
                        bufferLen *= 2;
                        HRESULT hr = buf.ReSize(bufferLen*sizeof(WCHAR)); // memcopied by QuickBytes automatically
                        if (FAILED(hr))
                            COMPlusThrowOM();
                        
                        buffer = (wchar *)buf.Ptr(); 
                        dst = buffer + offset;
                    }
                }
            }
            if (*src != 0) src++;
            break;
        case '\\':
            if (*src != 0) *dst++ = *src++;
            break;
        case 'E':
        case 'e':
            {        
                STRINGREF sign = NULL;
                int i = 0;
                if (scientific) {
                    if (*src=='0') {
                        //Handles E0, which should format the same as E-0
                        i++;  
                    } else if (*src == '+' && src[1] == '0') {
                        //Handles E+0
                        sign = numfmt->sPositive; 
                    } else if (*src == '-' && src[1] == '0') {
                        //Handles E-0
                        //Do nothing, this is just a place holder s.t. we don't break out of the loop.
                    } else {
                        *dst++ = ch;
                        break;
                    }
                    while (*++src == '0') i++;
                    if (i > 10) i = 10;
                    int exp = number->digits[0] == 0? 0: number->scale - decimalPos;
                    dst = FormatExponent(dst, exp, ch, sign, numfmt->sNegative, i);
                    scientific = 0;
                }
                else
                {
                    *dst++ = ch; // Copy E or e to output
                    if (*src== '+' || *src == '-') {
                        *dst++ = *src++;
                    }
                    while (*src == '0') {
                        *dst++ = *src++;
                    }
                }
                break;
            }
        default:
            *dst++ = ch;
        }
    }
    _ASSERTE((dst - buffer >= 0) && (dst - buffer <= (int)bufferLen));
    STRINGREF newStr = COMString::NewString(buffer, (int)(dst - buffer));
    return newStr;
}

STRINGREF FPNumberToString(NUMBER* number, STRINGREF str, NUMFMTREF numfmt)
{
    wchar fmt;
    int digits;
    if (number->scale == SCALE_NAN) {
        return numfmt->sNaN;
    }
    if (number->scale == SCALE_INF) {
        return number->sign? numfmt->sNegativeInfinity: numfmt->sPositiveInfinity;
    }
    
    fmt = ParseFormatSpecifier(str, &digits);
    if (fmt != 0) {
        return NumberToString(number, fmt, digits, numfmt);
    }
    return NumberToStringFormat(number, str, numfmt);
}

LPVOID COMNumber::FormatDecimal(FormatDecimalArgs * args)
{
    NUMBER number;
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    DecimalToNumber(&args->value, &number);
    
    wchar fmt;
    int digits;
    fmt = ParseFormatSpecifier(args->format, &digits);
    if (fmt != 0) {
        RETURN(NumberToString(&number, fmt, digits, args->numfmt, TRUE),STRINGREF);
    }
    RETURN (NumberToStringFormat(&number, args->format, args->numfmt),STRINGREF);
}

LPVOID COMNumber::FormatDouble(FormatDoubleArgs * args)
{
    NUMBER number;
    int digits;
    double dTest;
    
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    wchar fmt = ParseFormatSpecifier(args->format, &digits);
    wchar val = (fmt & 0xFFDF);
    int precision = DOUBLE_PRECISION;
    switch (val) {
    case 'R':
        //In order to give numbers that are both friendly to display and round-trippable,
        //we parse the number using 15 digits and then determine if it round trips to the same
        //value.  If it does, we convert that NUMBER to a string, otherwise we reparse using 17 digits
        //and display that.  
        
        DoubleToNumber(args->value, DOUBLE_PRECISION, &number);
        
        if (number.scale == SCALE_NAN) {
            RETURN(args->numfmt->sNaN, STRINGREF);
        }
        if (number.scale == SCALE_INF) {
            RETURN((number.sign? args->numfmt->sNegativeInfinity: args->numfmt->sPositiveInfinity),STRINGREF);
        }
        
        NumberToDouble(&number, &dTest);
        
        if (dTest == args->value) {
            RETURN(NumberToString(&number, 'G', DOUBLE_PRECISION, args->numfmt), STRINGREF);
        }
        
        DoubleToNumber(args->value, 17, &number);
        RETURN(NumberToString(&number, 'G', 17, args->numfmt), STRINGREF);
        break;
        
    case 'E':
        // Here we round values less than E14 to 15 digits
        if (digits > 14) {
            precision = 17;
        }
        break;
        
    case 'G':
        // Here we round values less than G15 to 15 digits, G16 and G17 will not be touched
        if (digits > 15) {
            precision = 17;
        }
        break;
        
    }
    
    DoubleToNumber(args->value, precision, &number);
    RETURN (FPNumberToString(&number, args->format, args->numfmt), STRINGREF);
    
}

//HACK HACK HACK
//This function and the function pointer which we use to access are a really
//nasty hack to prevent VC7 from optimizing away our cast from double to float.
//We need this narrowing operation to verify whether or not we successfully round-tripped
//the single value.  We believe that the fact that we need the function pointer is a
//bug.  The volatile keyword should be enough to prevent the optimization from happening.
//HACK HACK HACK
static void CvtToFloat(double val, volatile float* fltPtr)
{
    *fltPtr = (float)val;
}

void (*CvtToFloatPtr)(double val, volatile float* fltPtr) = CvtToFloat;

LPVOID COMNumber::FormatSingle(FormatSingleArgs * args)
{
    NUMBER number;
    int digits;
    double dTest;
    double argsValue = args->value;
    
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    wchar fmt = ParseFormatSpecifier(args->format, &digits);
    wchar val = fmt & 0xFFDF;
    int precision = FLOAT_PRECISION;
    switch (val) {
    case 'R':
        //In order to give numbers that are both friendly to display and round-trippable,
        //we parse the number using 7 digits and then determine if it round trips to the same
        //value.  If it does, we convert that NUMBER to a string, otherwise we reparse using 9 digits
        //and display that.  
        
        DoubleToNumber(argsValue, FLOAT_PRECISION, &number);
        
        if (number.scale == SCALE_NAN) {
            RETURN(args->numfmt->sNaN, STRINGREF);
        }
        if (number.scale == SCALE_INF) {
            RETURN((number.sign? args->numfmt->sNegativeInfinity: args->numfmt->sPositiveInfinity),STRINGREF);
        }
        
        NumberToDouble(&number, &dTest);
        
        volatile float fTest;
        
        (*CvtToFloatPtr)(dTest, &fTest);
        
        if (fTest == args->value) {
            RETURN(NumberToString(&number, 'G', FLOAT_PRECISION, args->numfmt), STRINGREF);
        }
        
        DoubleToNumber(argsValue, 9, &number);
        RETURN(NumberToString(&number, 'G', 9, args->numfmt), STRINGREF);
        break;
    case 'E':
        // Here we round values less than E14 to 15 digits
        if (digits > 6) {
            precision = 9;
        }
        break;
        
        
    case 'G':
        // Here we round values less than G15 to 15 digits, G16 and G17 will not be touched
        if (digits > 7) {
            precision = 9;
        }
        break;
        
    }
    
    DoubleToNumber(args->value, precision, &number);
    RETURN (FPNumberToString(&number, args->format, args->numfmt), STRINGREF);
    
}


LPVOID COMNumber::FormatInt32(FormatInt32Args * args)
{
    wchar fmt;
    int digits;
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    fmt = ParseFormatSpecifier(args->format, &digits);
    
    //ANDing fmt with FFDF has the effect of uppercasing the character because
    //we've removed the bit that marks lower-case.
    switch (fmt & 0xFFDF) {
    case 'G':
        if (digits > 0) break;
        // fall through
    case 'D':
        RETURN(Int32ToDecStr(args->value, digits, args->numfmt->sNegative), STRINGREF);
    case 'X':
        //The fmt-(X-A+10) hack has the effect of dictating whether we produce uppercase
        //or lowercase hex numbers for a-f.  'X' as the fmt code produces uppercase. 'x'
        //as the format code produces lowercase. 
        RETURN(Int32ToHexStr(args->value, fmt - ('X' - 'A' + 10), digits), STRINGREF);
    }
    NUMBER number;
    Int32ToNumber(args->value, &number);
    if (fmt != 0) {
        RETURN(NumberToString(&number, fmt, digits, args->numfmt), STRINGREF);
    }
    RETURN(NumberToStringFormat(&number, args->format, args->numfmt), STRINGREF);
}

LPVOID COMNumber::FormatUInt32(FormatUInt32Args * args)
{
    wchar fmt;
    int digits;
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    fmt = ParseFormatSpecifier(args->format, &digits);
    switch (fmt & 0xFFDF) {
    case 'G':
        if (digits > 0) break;
        // fall through
    case 'D':
        RETURN(UInt32ToDecStr(args->value, digits), STRINGREF);
    case 'X':
        RETURN(Int32ToHexStr(args->value, fmt - ('X' - 'A' + 10), digits), STRINGREF);
    }
    NUMBER number;
    UInt32ToNumber(args->value, &number);
    if (fmt != 0) {
        RETURN(NumberToString(&number, fmt, digits, args->numfmt), STRINGREF);
    }
    RETURN(NumberToStringFormat(&number, args->format, args->numfmt), STRINGREF);
}

LPVOID COMNumber::FormatInt64(FormatInt64Args * args)
{
    wchar fmt;
    int digits;
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    fmt = ParseFormatSpecifier(args->format, &digits);
    switch (fmt & 0xFFDF) {
    case 'G':
        if (digits > 0) break;
        // fall through
    case 'D':
        RETURN(Int64ToDecStr(args->value, digits, args->numfmt->sNegative), STRINGREF);
    case 'X':
        RETURN(Int64ToHexStr(args->value, fmt - ('X' - 'A' + 10), digits), STRINGREF);
    }
    NUMBER number;
    Int64ToNumber(args->value, &number);
    if (fmt != 0) {
        RETURN(NumberToString(&number, fmt, digits, args->numfmt), STRINGREF);
    }
    RETURN(NumberToStringFormat(&number, args->format, args->numfmt), STRINGREF);
}

LPVOID COMNumber::FormatUInt64(FormatUInt64Args * args)
{
    wchar fmt;
    int digits;
    THROWSCOMPLUSEXCEPTION();
    if (args->numfmt == 0) COMPlusThrowArgumentNull(L"NumberFormatInfo");
    fmt = ParseFormatSpecifier(args->format, &digits);
    switch (fmt & 0xFFDF) {
    case 'G':
        if (digits > 0) break;
        // fall through
    case 'D':
        RETURN(UInt64ToDecStr(args->value, digits), STRINGREF);
    case 'X':
        RETURN(Int64ToHexStr(args->value, fmt - ('X' - 'A' + 10), digits), STRINGREF);
    }
    NUMBER number;
    UInt64ToNumber(args->value, &number);
    if (fmt != 0) {
        RETURN(NumberToString(&number, fmt, digits, args->numfmt), STRINGREF);
    }
    RETURN(NumberToStringFormat(&number, args->format, args->numfmt), STRINGREF);
}

#define STATE_SIGN     0x0001
#define STATE_PARENS   0x0002
#define STATE_DIGITS   0x0004
#define STATE_NONZERO  0x0008
#define STATE_DECIMAL  0x0010
#define STATE_CURRENCY 0x0020

#define ISWHITE(ch) (((ch) == 0x20)||((ch) >= 0x09 && (ch) <= 0x0D))

int ParseNumber(wchar** str, int options, NUMBER* number, NUMFMTREF numfmt, BOOL parseDecimal = FALSE)
{
    number->scale = 0;
    number->sign = 0;
    wchar* decSep;                  // decimal separator from NumberFormatInfo.
    wchar* groupSep;                // group separator from NumberFormatInfo.
    wchar* currSymbol = NULL;       // currency symbol from NumberFormatInfo.
    // The alternative currency symbol used in Win9x ANSI codepage, that can not roundtrip between ANSI and Unicode.
    // Currently, only ja-JP and ko-KR has non-null values (which is U+005c, backslash)
    wchar* ansicurrSymbol = NULL;   // currency symbol from NumberFormatInfo.
    wchar* altdecSep = NULL;        // decimal separator from NumberFormatInfo as a decimal
    wchar* altgroupSep = NULL;      // group separator from NumberFormatInfo as a decimal
    
    BOOL parsingCurrency = FALSE; 
    if (options & PARSE_CURRENCY) {
        currSymbol = numfmt->sCurrency->GetBuffer();
        if (numfmt->sAnsiCurrency != NULL) {
            ansicurrSymbol = numfmt->sAnsiCurrency->GetBuffer();
        }
        // The idea here to match the curreny separators and on failure match the number separators to keep the perf of VB's IsNumeric fast.
        // The values of decSep are setup to use the correct relevant seperator (currency in the if part and decimal in the else part).
        altdecSep = numfmt->sNumberDecimal->GetBuffer(); 
        altgroupSep = numfmt->sNumberGroup->GetBuffer();
        decSep = numfmt->sCurrencyDecimal->GetBuffer();
        groupSep = numfmt->sCurrencyGroup->GetBuffer();
        parsingCurrency = TRUE;
    }
    else {
        decSep = numfmt->sNumberDecimal->GetBuffer();
        groupSep = numfmt->sNumberGroup->GetBuffer();
    }
    
    int state = 0;
    int signflag = 0; // Cache the results of "options & PARSE_LEADINGSIGN && !(state & STATE_SIGN)" to avoid doing this twice
    wchar* p = *str;
    wchar ch = *p;
    wchar* next;
    
    while (true) {
        //Eat whitespace unless we've found a sign which isn't followed by a currency symbol.
        //"-Kr 1231.47" is legal but "- 1231.47" is not.
        if (ISWHITE(ch) 
            && (options & PARSE_LEADINGWHITE) 
            && (!(state & STATE_SIGN) || ((state & STATE_SIGN) && (state & STATE_CURRENCY || numfmt->cNegativeNumberFormat == 2)))) {
            // Do nothing here. We will increase p at the end of the loop.
        }
        else if ((signflag = (options & PARSE_LEADINGSIGN && !(state & STATE_SIGN))) != 0 && (next = MatchChars(p, numfmt->sPositive->GetBuffer())) != NULL) {
            state |= STATE_SIGN;
            p = next - 1;
        } else if (signflag && (next = MatchChars(p, numfmt->sNegative->GetBuffer())) != NULL) {
            state |= STATE_SIGN;
            number->sign = 1;
            p = next - 1;
        }
        else if (ch == '(' && options & PARSE_PARENS && !(state & STATE_SIGN)) {
            state |= STATE_SIGN | STATE_PARENS;
            number->sign = 1;
        }
        else if ((currSymbol != NULL && (next = MatchChars(p, currSymbol))!=NULL) ||
            (ansicurrSymbol != NULL && (next = MatchChars(p, ansicurrSymbol))!=NULL)) {
            state |= STATE_CURRENCY;
            currSymbol = NULL;  
            ansicurrSymbol = NULL;  
            // We already found the currency symbol. There should not be more currency symbols. Set
            // currSymbol to NULL so that we won't search it again in the later code path.
            p = next - 1;
        }
        else {
            break;
        }
        ch = *++p;
    }
    int digCount = 0;
    int digEnd = 0;
    while (true) {
        if ((ch >= '0' && ch <= '9') || ( (options & PARSE_HEX) && ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')))) {
            state |= STATE_DIGITS;
            if (ch != '0' || state & STATE_NONZERO) {
                if (digCount < NUMBER_MAXDIGITS) {
                    number->digits[digCount++] = ch;
                    if (ch != '0' || parseDecimal) digEnd = digCount;
                }

                if (!(state & STATE_DECIMAL)) number->scale++;
                state |= STATE_NONZERO;
            }
            else if (state & STATE_DECIMAL) number->scale--;
        }
        else if ((options & PARSE_DECIMAL) && !(state & STATE_DECIMAL) &&
            ((next = MatchChars(p, decSep)) !=NULL ||  ((parsingCurrency) && (state & STATE_CURRENCY) == 0) && (next = MatchChars(p, altdecSep))!=NULL)) {
            state |= STATE_DECIMAL;
            p = next - 1;
        }
        else if (options & PARSE_THOUSANDS && state & STATE_DIGITS && !(state & STATE_DECIMAL) &&
            ((next = MatchChars(p, groupSep))!=NULL || ((parsingCurrency) && (state & STATE_CURRENCY) == 0) && (next = MatchChars(p, altgroupSep))!=NULL)) {
            p = next - 1;
        }
        else {
            break;
        }
        ch = *++p;
    }
    
    int negExp = 0;
    number->precision = digEnd;
    number->digits[digEnd] = 0;
    if (state & STATE_DIGITS) {
        if ((ch == 'E' || ch == 'e') && options & PARSE_SCIENTIFIC) {
            wchar* temp = p;
            ch = *++p;
            if ((next = MatchChars(p, numfmt->sPositive->GetBuffer()))!=NULL)
            {
                ch = *(p = next);
            }
            else if ((next = MatchChars(p, numfmt->sNegative->GetBuffer())) != NULL)
            {
                ch = *(p = next);
                negExp = 1;
            }
            if (ch >= '0' && ch <= '9') {
                int exp = 0;
                do {
                    exp = exp * 10 + (ch - '0');
                    ch = *++p;
                    if (exp>1000) {
                        exp=9999;
                        while(ch>='0' && ch<='9') {
                            ch=*++p;
                        }
                    }
                } while (ch >= '0' && ch <= '9');
                if (negExp) exp = -exp;
                number->scale += exp;
            }
            else {
                p = temp;
                ch = *p;
            }
        }
        while (true) {
            wchar* next;
            if (ISWHITE(ch) && options & PARSE_TRAILINGWHITE) {
            }
            else if ((signflag = (options & PARSE_TRAILINGSIGN && !(state & STATE_SIGN))) != 0 && (next = MatchChars(p, numfmt->sPositive->GetBuffer())) != NULL) {
                state |= STATE_SIGN;
                p = next - 1;
            } else if (signflag && (next = MatchChars(p, numfmt->sNegative->GetBuffer())) != NULL) {
                state |= STATE_SIGN;
                number->sign = 1;
                p = next - 1;
            }
            else if (ch == ')' && state & STATE_PARENS) {
                state &= ~STATE_PARENS;
            }
            else if ((currSymbol != NULL && (next = MatchChars(p, currSymbol))!=NULL) ||
                (ansicurrSymbol != NULL && (next = MatchChars(p, ansicurrSymbol))!=NULL)) {
                currSymbol = NULL;
                ansicurrSymbol = NULL;
                p = next - 1;
            }
            else {
                break;
            }
            ch = *++p;
        }
        if (!(state & STATE_PARENS)) {
            if (!(state & STATE_NONZERO)) {
                number->scale = 0;
                if (!(state & STATE_DECIMAL)) {
                    number->sign = 0;
                }
            }
            *str = p;
            return 1;
        }
    }
    *str = p;
    return 0;
}

void StringToNumber(STRINGREF str, int options, NUMBER* number, NUMFMTREF numfmt, BOOL parseDecimal = FALSE)
{
    THROWSCOMPLUSEXCEPTION();
    
    if (str == 0 || numfmt == 0) {
        COMPlusThrowArgumentNull((str==NULL ? L"String" : L"NumberFormatInfo"));
    }
    // Check if NumberFormatInfo was not set up ambiguously for parsing as number and currency
    // eg. if the NumberDecimalSeparator and the NumberGroupSeparator were the same. This check
    // used to live in the managed code in NumberFormatInfo but it made it difficult to change the
    // values in managed code for the currency case since we had
    //   NDS != NGS, NDS != CGS, CDS != NGS, CDS != CGS to be true to parse and user were not 
    // easily able to switch these for certain european cultures.
    if (options & PARSE_CURRENCY) {
        if (!numfmt->bValidForParseAsCurrency) { 
            COMPlusThrow(kArgumentException,L"Argument_AmbiguousCurrencyInfo");
        }
    }
    else {
        if (!numfmt->bValidForParseAsNumber) {
            COMPlusThrow(kArgumentException,L"Argument_AmbiguousNumberInfo");
        }
    }
    wchar* p = str->GetBuffer();
    if (!ParseNumber(&p, options, number, numfmt,parseDecimal) || *p != 0) {
        COMPlusThrow(kFormatException, L"Format_InvalidString");
    }
}

bool TryStringToNumber(STRINGREF str, int options, NUMBER* number, NUMFMTREF numfmt)
{   
    // Check if NumberFormatInfo was not set up ambiguously for parsing as number and currency
    // eg. if the NumberDecimalSeparator and the NumberGroupSeparator were the same. This check
    // used to live in the managed code in NumberFormatInfo but it made it difficult to change the
    // values in managed code for the currency case since we had
    //   NDS != NGS, NDS != CGS, CDS != NGS, CDS != CGS to be true to parse and user were not 
    // easily able to switch these for certain european cultures.
    if (options & PARSE_CURRENCY) {
        if (!numfmt->bValidForParseAsCurrency) { 
            return false;
        }
    }
    else {
        if (!numfmt->bValidForParseAsNumber) {
            return false;
        }
    }
    wchar* p = str->GetBuffer();
    if (!ParseNumber(&p, options, number, numfmt) || *p != 0) {
        return false;
    }
    return true;
}

void COMNumber::ParseDecimal(ParseDecimalArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    DECIMAL d;
    StringToNumber(args->value, args->options, &number, args->numfmt, TRUE);
    if (!NumberToDecimal(&number, &d)) COMPlusThrow(kOverflowException, L"Overflow_Decimal");
    *args->result = d;
}

double COMNumber::ParseDouble(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    double d;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    NumberToDouble(&number, &d);
    unsigned int e = ((FPDOUBLE*)&d)->exp;
    unsigned int fmntLow = ((FPDOUBLE*)&d)->mantLo;
    unsigned int fmntHigh = ((FPDOUBLE*)&d)->mantHi;
    if (e == 0 && fmntLow ==0 && fmntHigh == 0)  return 0;
    if (e == 0x7FF) COMPlusThrow(kOverflowException,L"Overflow_Double");
    return d;
}

bool COMNumber::TryParseDouble(TryParseArgs * args)
{
    NUMBER number;
    double d;
    bool success = TryStringToNumber(args->value, args->options, &number, args->numfmt);
    if (!success)
        return false;
    NumberToDouble(&number, &d);
    unsigned int e = ((FPDOUBLE*)&d)->exp;
    unsigned int fmntLow = ((FPDOUBLE*)&d)->mantLo;
    unsigned int fmntHigh = ((FPDOUBLE*)&d)->mantHi;
    if (e == 0 && fmntLow ==0 && fmntHigh == 0)  {
		*args->result = 0;
		return true;
	}
    if (e == 0x7FF) return false;
    *args->result = d;
    return true;
}

float COMNumber::ParseSingle(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    double d;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    NumberToDouble(&number, &d);
    float f = (float)d;
    unsigned int e = ((FPSINGLE*)&f)->exp;
    unsigned int fmnt = ((FPSINGLE*)&f)->mant;
    
    if (e == 0 && fmnt == 0)  return 0;
    if (e == 0xFF) COMPlusThrow(kOverflowException,L"Overflow_Single");
    return f;
}

int COMNumber::ParseInt32(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    int i;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    if (args->options & PARSE_HEX)
    {
        if (!HexNumberToUInt32(&number, (unsigned int*)(&i))) COMPlusThrow(kOverflowException, L"Overflow_Int32"); // Same method for signed and unsigned
    }
    else
    {
        if (!NumberToInt32(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_Int32");
    }
    return i;
}

unsigned int COMNumber::ParseUInt32(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    unsigned int i;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    if (args->options & PARSE_HEX)
    {
        if (!HexNumberToUInt32(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_UInt32"); // Same method for signed and unsigned
    }
    else
    {
        if (!NumberToUInt32(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_UInt32");
    }
    
    return i;
}

__int64 COMNumber::ParseInt64(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    __int64 i;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    if (args->options & PARSE_HEX)
    {
        if (!HexNumberToUInt64(&number, (unsigned __int64*)&i)) COMPlusThrow(kOverflowException, L"Overflow_Int64"); // Same method for signed and unsigned
    }
    else
    {
        if (!NumberToInt64(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_Int64");
    }
    
    return i;
}

unsigned __int64 COMNumber::ParseUInt64(ParseArgs * args)
{
    THROWSCOMPLUSEXCEPTION();
    NUMBER number;
    unsigned __int64 i;
    StringToNumber(args->value, args->options, &number, args->numfmt);
    if (args->options & PARSE_HEX)
    {
        if (!HexNumberToUInt64(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_UInt64"); // Same method for signed and unsigned
    }
    else
    {
        if (!NumberToUInt64(&number, &i)) COMPlusThrow(kOverflowException, L"Overflow_UInt64");
    }
    
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comobject.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: COMObject.h
**
** Author: Derek Yenzer (dereky)
**
** Purpose: Native methods on System.Object
**
** Date:  March 27, 1998
** 
===========================================================*/

#ifndef _COMOBJECT_H
#define _COMOBJECT_H

#include "fcall.h"


//
// Each function that we call through native only gets one argument,
// which is actually a pointer to it's stack of arguments.  Our structs
// for accessing these are defined below.
//

class ObjectNative
{
#pragma pack(push, 4)
    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pThis);
    };

    struct GetClassArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pThis);
    };

    struct WaitTimeoutArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, m_pThis);
        DECLARE_ECALL_I4_ARG(INT32, m_Timeout);
        DECLARE_ECALL_I4_ARG(INT32, m_exitContext);
    };
#pragma pack(pop)

public:

    // This method will return a Class object for the object
    //  iff the Class object has already been created.
    //  If the Class object doesn't exist then you must call the GetClass() method.
    static FCDECL1(Object*, GetObjectValue, Object* vThisRef);
    static FCDECL1(Object*, GetExistingClass, Object* vThisRef);
    static FCDECL1(INT32, GetHashCode, Object* vThisRef);
    static FCDECL2(BOOL, Equals, Object *pThisRef, Object *pCompareRef);

    static LPVOID __stdcall GetClass(GetClassArgs *);
    static LPVOID __stdcall Clone(NoArgs *);
    static INT32 __stdcall WaitTimeout(WaitTimeoutArgs *);
    static void __stdcall Pulse(NoArgs *);
    static void __stdcall PulseAll(NoArgs *);
    static LPVOID __fastcall FastGetClass(Object* vThisRef);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\comoavariant.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMOAVariant
**
** Author:  Brian Grunkemeyer (BrianGru)
**
** Purpose: Wrapper for Ole Automation compatable math ops.
** Calls through to OleAut.dll
**
** Date:    November 5, 1998
** 
===========================================================*/

#ifndef __COM_OA_VARIANT_H__
#define __COM_OA_VARIANT_H__

#include "COMVariant.h"

// Function pointer definitions for VarMath functions.
typedef HRESULT (*VarMathUnaryOpFunc)(LPVARIANT pvarIn, LPVARIANT pvarResult);
typedef HRESULT (*VarMathBinaryOpFunc)(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);


class COMOAVariant
{

#pragma pack(push)
#pragma pack(4)

	struct ArithUnaryOpArgs {
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, operand);
 		DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);		// Return reference
	};

	struct ArithBinaryOpArgs {
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, right);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, left);
 		DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);		// Return reference
	};

	struct CompareArgs {
		DECLARE_ECALL_I4_ARG(DWORD, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I4_ARG(int, rightHardType);    // boolean, really
		DECLARE_ECALL_I4_ARG(int, leftHardType);     // boolean, really
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, right);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, left);
	};

	struct ChangeTypeArgs {
		DECLARE_ECALL_I2_ARG(unsigned short, flags);
		DECLARE_ECALL_I4_ARG(int, cvType);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, op);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);
	};

	struct ChangeTypeExArgs {
		DECLARE_ECALL_I2_ARG(unsigned short, flags);
		DECLARE_ECALL_I4_ARG(int, cvType);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, op);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);
	};

	struct RoundArgs {
		DECLARE_ECALL_I4_ARG(int, cDecimals);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, operand);
 		DECLARE_ECALL_OBJECTREF_ARG(VariantData*, retRef);		// Return reference
	};

	struct FormatArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(int, firstWeek);
		DECLARE_ECALL_I4_ARG(int, firstDay);
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, format);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, value);
	};

	struct FormatBooleanArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I1_ARG(bool, value);
	};

	struct FormatByteArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I1_ARG(unsigned char, value);
	};

	struct FormatSByteArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I1_ARG(signed char, value);
	};

	struct FormatInt16Args {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I2_ARG(short, value);
	};

	struct FormatInt32Args {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I4_ARG(int, value);
	};

	struct FormatSingleArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_R4_ARG(float, value);
	};

	struct FormatDoubleArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_R8_ARG(double, value);
	};

	struct FormatCurrencyArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I8_ARG(CY, value);
	};

	struct FormatDateTimeArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I8_ARG(UINT64, value);
	};

	struct FormatDateTimeSpecialArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(int, namedFormat);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, value);
	};

	struct FormatDecimalArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_I8_ARG(DECIMAL, value);  // This isn't done right...
	};

	struct FormatSpecialArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(int, group);
		DECLARE_ECALL_I4_ARG(int, useParens);
		DECLARE_ECALL_I4_ARG(int, incLead);
		DECLARE_ECALL_I4_ARG(int, numDig);
		DECLARE_ECALL_OBJECTREF_ARG(VariantData, value);
	};

	struct ParseDateTimeArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, str);
	};

	struct ParseBooleanArgs {
		DECLARE_ECALL_I4_ARG(ULONG, flags);
		DECLARE_ECALL_I4_ARG(LCID, lcid);
		DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, str);
	};

#pragma pack(pop)

public:
	// Utility Functions
	// Conversion between COM+ variant type field & OleAut Variant enumeration
#ifndef PLATFORM_CE
	// WinCE doesn't support Variants entirely.
	static VARENUM CVtoVT(const CVTypes cv);
	static CVTypes VTtoCV(const VARENUM vt);
	static CVTypes VTtoCVNoExcep(const VARENUM vt);

	// Conversion between COM+ Variant & OleAut Variant.  ToOAVariant
	// returns true if the conversion process allocated an object (like a BSTR).
	static bool ToOAVariant(const VariantData * const var, VARIANT * oa);
	static void FromOAVariant(const VARIANT * const oa, VariantData * const& var);

	static void __stdcall UnaryOp(VarMathUnaryOpFunc mathFunc, const ArithUnaryOpArgs * args);
	static void __stdcall BinaryOp(VarMathBinaryOpFunc mathFunc, const ArithBinaryOpArgs * args);

	// Throw a specific exception for a failure, specified by a given HRESULT.
	static void OAFailed(const HRESULT hr);
#endif // !PLATFORM_CE

	// Binary Variant Math functions
	static void __stdcall Add(const ArithBinaryOpArgs * args);
	static void __stdcall Subtract(const ArithBinaryOpArgs * args);
	static void __stdcall Multiply(const ArithBinaryOpArgs * args);
	static void __stdcall Divide(const ArithBinaryOpArgs * args);
	static void __stdcall Mod(const ArithBinaryOpArgs * args);
	static void __stdcall Pow(const ArithBinaryOpArgs * args);
	static void __stdcall And(const ArithBinaryOpArgs * args);
	static void __stdcall Or(const ArithBinaryOpArgs * args);
	static void __stdcall Xor(const ArithBinaryOpArgs * args);
	static void __stdcall Eqv(const ArithBinaryOpArgs * args);
	static void __stdcall IntDivide(const ArithBinaryOpArgs * args);
	static void __stdcall Implies(const ArithBinaryOpArgs * args);

	// Unary Variant Math functions
	static void __stdcall Negate(const ArithUnaryOpArgs * args);
	static void __stdcall Not(const ArithUnaryOpArgs * args);
	static void __stdcall Abs(const ArithUnaryOpArgs * args);
	static void __stdcall Fix(const ArithUnaryOpArgs * args);
	static void __stdcall Int(const ArithUnaryOpArgs * args);

	// Others
	static INT32 __stdcall Compare(const CompareArgs * args);
	static void __stdcall ChangeType(const ChangeTypeArgs * args);
	static void __stdcall ChangeTypeEx(const ChangeTypeExArgs * args);
	static void __stdcall Round(const RoundArgs * args);

	// String formatting & parsing
	static LPVOID __stdcall Format(FormatArgs * args);
	static LPVOID __stdcall FormatBoolean(const FormatBooleanArgs * args);
	static LPVOID __stdcall FormatByte(const FormatByteArgs * args);
	static LPVOID __stdcall FormatSByte(const FormatSByteArgs * args);
	static LPVOID __stdcall FormatInt16(const FormatInt16Args * args);
	static LPVOID __stdcall FormatInt32(const FormatInt32Args * args);
	static LPVOID __stdcall FormatSingle(const FormatSingleArgs * args);
	static LPVOID __stdcall FormatDouble(const FormatDoubleArgs * args);
	static LPVOID __stdcall FormatCurrency(const FormatCurrencyArgs * args);
	static LPVOID __stdcall FormatDateTime(const FormatDateTimeArgs * args);
	static LPVOID __stdcall FormatDateTimeSpecial(const FormatDateTimeSpecialArgs * args);
	static LPVOID __stdcall FormatDecimal(FormatDecimalArgs * args);
	static LPVOID __stdcall FormatNumber(const FormatSpecialArgs * args);
	static LPVOID __stdcall FormatCurrencySpecial(const FormatSpecialArgs * args);
	static LPVOID __stdcall FormatPercent(const FormatSpecialArgs * args);

	static bool __stdcall ParseBoolean(const ParseBooleanArgs * args);
	static INT64 __stdcall ParseDateTime(const ParseDateTimeArgs * args);

};


#endif  // __COM_OA_VARIANT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: compile.cpp
//
// Support for zap compiler and zap files
// 
// ===========================================================================


#include "common.h"

#include <corcompile.h>

#include "compile.h"
#include "excep.h"
#include "field.h"
#include "security.h"
#include "eeconfig.h"

#include "__file__.ver"

//
// CEECompileInfo implements most of ICorCompileInfo
//

HRESULT __stdcall CEECompileInfo::Startup()
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    HRESULT hr = CoInitializeEE(0);

    //
    // JIT interface expects to be called with
    // preemptive GC disabled
    //
    if (SUCCEEDED(hr)) {
        Thread *pThread = GetThread();
        _ASSERTE(pThread);

        if (!pThread->PreemptiveGCDisabled())
            pThread->DisablePreemptiveGC();
    }
    return hr;
}

HRESULT __stdcall CEECompileInfo::Shutdown()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    CoUninitializeEE(0);

    return S_OK;
}

HRESULT __stdcall CEECompileInfo::CreateDomain(ICorCompilationDomain **ppDomain,
                                               BOOL shared,
                                               CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame)

{
    HRESULT hr;

    COOPERATIVE_TRANSITION_BEGIN();

    CompilationDomain *pCompilationDomain = new (nothrow) CompilationDomain();
    if (pCompilationDomain == NULL)
        hr = E_OUTOFMEMORY;
    else
    {
        hr = pCompilationDomain->Init();

        if (SUCCEEDED(hr))
        {
            SystemDomain::System()->NotifyNewDomainLoads(pCompilationDomain);
            
            hr = pCompilationDomain->SetupSharedStatics();

#ifdef DEBUGGING_SUPPORTED    
            // Notify the debugger here, before the thread transitions into the 
            // AD to finish the setup.  If we don't, stepping won't work right (RAID 67173)
            SystemDomain::PublishAppDomainAndInformDebugger(pCompilationDomain);
#endif // DEBUGGING_SUPPORTED

            if(SUCCEEDED(hr)) {
                
                _ASSERTE(sizeof(CORCOMPILE_DOMAIN_TRANSITION_FRAME)
                         >= sizeof(ContextTransitionFrame));
            
                ContextTransitionFrame *pTransitionFrame 
                    = new (pFrame) ContextTransitionFrame();

                pCompilationDomain->EnterDomain(pTransitionFrame);
                
                if (shared)
                    hr = pCompilationDomain->InitializeDomainContext(BaseDomain::SHARE_POLICY_ALWAYS, NULL, NULL);
                else
                    hr = pCompilationDomain->InitializeDomainContext(BaseDomain::SHARE_POLICY_NEVER, NULL, NULL);
                
                if (SUCCEEDED(hr))
                    hr = SystemDomain::System()->LoadDomain(pCompilationDomain,
                                                            L"Compilation Domain");
            }
        }

        if(SUCCEEDED(hr)) 
            *ppDomain = (ICorCompilationDomain *) pCompilationDomain;
        else
            pCompilationDomain->Release();
    }

    COOPERATIVE_TRANSITION_END();
    return hr;
}

HRESULT __stdcall CEECompileInfo::DestroyDomain(ICorCompilationDomain *pDomain,
                                                CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame)
{
    COOPERATIVE_TRANSITION_BEGIN();

    CompilationDomain *pCompilationDomain = (CompilationDomain *) pDomain;

    pCompilationDomain->ExitDomain((ContextTransitionFrame*)pFrame);

    pCompilationDomain->Unload(TRUE);

    pCompilationDomain->Release();

    COOPERATIVE_TRANSITION_END();
    return S_OK;
}

HRESULT __stdcall CEECompileInfo::LoadAssembly(LPCWSTR path, 
                                               CORINFO_ASSEMBLY_HANDLE *pHandle)
{
    HRESULT hr;
    COOPERATIVE_TRANSITION_BEGIN();

    THROWSCOMPLUSEXCEPTION();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    Assembly *pAssembly;
    hr = AssemblySpec::LoadAssembly(path, &pAssembly, &throwable);
    if (FAILED(hr))
    {
        if (throwable != NULL)
            COMPlusThrow(throwable);
    }
    else
    {
        *pHandle = CORINFO_ASSEMBLY_HANDLE(pAssembly);

        CompilationDomain *pDomain = (CompilationDomain *) GetAppDomain();
        pDomain->SetTargetAssembly(pAssembly);
    }

    GCPROTECT_END();

    COOPERATIVE_TRANSITION_END();
    return hr;
}

HRESULT __stdcall CEECompileInfo::LoadAssemblyFusion(IAssemblyName *pFusionName, 
                                                     CORINFO_ASSEMBLY_HANDLE *pHandle)
{
    HRESULT hr;
    COOPERATIVE_TRANSITION_BEGIN();

    Assembly *pAssembly;
    CompilationDomain *pDomain;

    AssemblySpec spec;
    spec.InitializeSpec(pFusionName);

    _ASSERTE(GetAppDomain() == SystemDomain::GetCurrentDomain());
    IfFailGo(spec.LoadAssembly(&pAssembly, NULL));

    //
    // Return the module handle
    //

    *pHandle = CORINFO_ASSEMBLY_HANDLE(pAssembly);

    pDomain = (CompilationDomain *) GetAppDomain();
    pDomain->SetTargetAssembly(pAssembly);

 ErrExit:

    COOPERATIVE_TRANSITION_END();

    return hr;
}

HRESULT __stdcall CEECompileInfo::LoadAssemblyRef(IMetaDataAssemblyImport *pAssemblyImport, 
                                                  mdAssemblyRef ref,
                                                  CORINFO_ASSEMBLY_HANDLE *pHandle)
{
    HRESULT hr;
    COOPERATIVE_TRANSITION_BEGIN();
    Assembly *pAssembly;
    CompilationDomain *pDomain;

    AssemblySpec spec;

    IMDInternalImport *pMDImport;
    IfFailGo(GetMetaDataInternalInterfaceFromPublic((void*) pAssemblyImport, IID_IMDInternalImport, 
                                                    (void **)&pMDImport));

    spec.InitializeSpec(ref, pMDImport, NULL);

    pMDImport->Release();

    _ASSERTE(GetAppDomain() == SystemDomain::GetCurrentDomain());
    IfFailGo(spec.LoadAssembly(&pAssembly, NULL));

    //
    // Return the module handle
    //

    *pHandle = CORINFO_ASSEMBLY_HANDLE(pAssembly);

    pDomain = (CompilationDomain *) GetAppDomain();
    pDomain->SetTargetAssembly(pAssembly);

 ErrExit:

    COOPERATIVE_TRANSITION_END();

    return hr;
}

HRESULT __stdcall CEECompileInfo::LoadAssemblyModule(CORINFO_ASSEMBLY_HANDLE assembly,
                                                     mdFile file,
                                                     CORINFO_MODULE_HANDLE *pHandle)
{
    HRESULT hr;
    COOPERATIVE_TRANSITION_BEGIN();

    THROWSCOMPLUSEXCEPTION();

    Module *pModule;
    Assembly *pAssembly = (Assembly*) assembly;

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    hr = pAssembly->LoadInternalModule(file, pAssembly->GetManifestImport(), &pModule, 
                                       &throwable);

    if (throwable != NULL)
        COMPlusThrow(throwable);

    GCPROTECT_END();

    IfFailGo(hr);

    //
    // Return the module handle
    //

    *pHandle = CORINFO_MODULE_HANDLE(pModule);

    COOPERATIVE_TRANSITION_END();

 ErrExit:

    return hr;
}

BOOL __stdcall CEECompileInfo::CheckAssemblyZap(CORINFO_ASSEMBLY_HANDLE assembly,
                                                BOOL fForceDebug, 
                                                BOOL fForceDebugOpt, 
                                                BOOL fForceProfiling)
{
    BOOL result = FALSE;

    COOPERATIVE_TRANSITION_BEGIN();

    Assembly *pAssembly = (Assembly*) assembly;

    // 
    // See if we can find one which is currently up to date.
    //

    IAssembly *pZapAssembly;
    if (pAssembly->LocateZapAssemblyInFusion(&pZapAssembly, fForceDebug, fForceDebugOpt, fForceProfiling) == S_OK)
    {
        pZapAssembly->Release();
        result = TRUE;
    }

    COOPERATIVE_TRANSITION_END();

    return result;
}

HRESULT __stdcall CEECompileInfo::GetAssemblyShared(CORINFO_ASSEMBLY_HANDLE assembly, 
                                                    BOOL *pShared)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Assembly *pAssembly = (Assembly*) assembly;

    *pShared = pAssembly->IsShared();
    
    return S_OK;
}

HRESULT __stdcall CEECompileInfo::GetAssemblyDebuggableCode(CORINFO_ASSEMBLY_HANDLE assembly, 
                                                            BOOL *pDebug, BOOL *pDebugOpt)
{
    COOPERATIVE_TRANSITION_BEGIN();

    Assembly *pAssembly = (Assembly*) assembly;

    DWORD flags = pAssembly->ComputeDebuggingConfig();

    *pDebug = (flags & DACF_TRACK_JIT_INFO) != 0;
    *pDebugOpt = (flags & DACF_ALLOW_JIT_OPTS) != 0;
    
    COOPERATIVE_TRANSITION_END();

    return S_OK;
}

IMetaDataAssemblyImport * __stdcall 
    CEECompileInfo::GetAssemblyMetaDataImport(CORINFO_ASSEMBLY_HANDLE assembly)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    IMetaDataAssemblyImport *import = ((Assembly*)assembly)->GetManifestAssemblyImport();
    import->AddRef();
    return import;
}

IMetaDataImport * __stdcall 
    CEECompileInfo::GetModuleMetaDataImport(CORINFO_MODULE_HANDLE scope)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    IMetaDataImport *import = ((Module*)scope)->GetImporter();
    import->AddRef();
    return import;
}

CORINFO_MODULE_HANDLE __stdcall 
    CEECompileInfo::GetAssemblyModule(CORINFO_ASSEMBLY_HANDLE assembly)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return (CORINFO_MODULE_HANDLE) ((Assembly*)assembly)->GetSecurityModule();
}

BYTE * __stdcall CEECompileInfo::GetModuleBaseAddress(CORINFO_MODULE_HANDLE scope)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return ((Module*)scope)->GetILBase();
}

DWORD __stdcall CEECompileInfo::GetModuleFileName(CORINFO_MODULE_HANDLE scope,
                                                  LPWSTR buffer, DWORD length)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    LPCWSTR name = ((Module*)scope)->GetFileName();
    if (name == NULL)
        return 0;

    DWORD len = (DWORD)wcslen(name) + 1;

    if (len <= length)
        wcscpy(buffer, name);
    else
    {
        wcsncpy(buffer, name, length-1);
        // Make sure this gets null-terminated
        buffer[length-1] = 0;
    }
    return len;
}

CORINFO_ASSEMBLY_HANDLE __stdcall 
    CEECompileInfo::GetModuleAssembly(CORINFO_MODULE_HANDLE module)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return (CORINFO_ASSEMBLY_HANDLE) ((Module*)module)->GetAssembly();
}

HRESULT __stdcall
    CEECompileInfo::EmitSecurityInfo(CORINFO_ASSEMBLY_HANDLE assembly,
                                     IMetaDataEmit *pEmitScope)
{
    HRESULT hr = S_OK;

    COOPERATIVE_TRANSITION_BEGIN();

    THROWSCOMPLUSEXCEPTION();

    // Don't write any security info if security is off.
    if (Security::IsSecurityOn())
    {
        CompilationDomain *pDomain = (CompilationDomain *) GetAppDomain();

        OBJECTREF demands = pDomain->GetDemands();

        // Always store at least an empty permission set.  This serves as a marker
        // that security was turned on at compile time.
        if (demands == NULL)
            demands = SecurityHelper::CreatePermissionSet(FALSE);

        GCPROTECT_BEGIN(demands);

        Assembly *pAssembly = (Assembly*) assembly;

        PBYTE pbData;
        DWORD cbData;
        SecurityHelper::EncodePermissionSet(&demands, &pbData, &cbData);

        // Serialize the set into binary format and write it into the metadata
        // (attached to the assembly def token, with an appropriate action code
        // to differentiate it from a permission request).

        hr = pEmitScope->DefinePermissionSet(pAssembly->GetManifestToken(),
                                             dclPrejitGrant,
                                             (void const *)pbData, cbData,
                                             NULL);

        FreeM(pbData);

        GCPROTECT_END();
    }

    COOPERATIVE_TRANSITION_END();

    return hr;
}

HRESULT __stdcall CEECompileInfo::GetEnvironmentVersionInfo(CORCOMPILE_VERSION_INFO *pInfo)
{
    // 
    // Compute the relevant version info
    // @todo: should we get this from mscoree rather than hard coding?
    //

#if _X86_
    pInfo->wMachine = IMAGE_FILE_MACHINE_I386;
#else
    // port me!
#endif

    // 
    // Fill in the OS version info
    //

    OSVERSIONINFO osInfo;
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);
    if (!WszGetVersionEx(&osInfo))
    {
        _ASSERTE(!"GetVersionEx failed");
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    pInfo->wOSPlatformID = (WORD) osInfo.dwPlatformId;
    pInfo->wOSMajorVersion = (WORD) osInfo.dwMajorVersion;
    pInfo->wOSMinorVersion = (WORD) osInfo.dwMinorVersion;
    
    // 
    // Fill in the runtime version info
    //

    pInfo->wVersionMajor = COR_BUILD_MAJOR;
    pInfo->wVersionMinor = COR_BUILD_MINOR;
    pInfo->wVersionBuildNumber = COR_OFFICIAL_BUILD_NUMBER;
    pInfo->wVersionPrivateBuildNumber = COR_PRIVATE_BUILD_NUMBER;

#if _DEBUG
    pInfo->wBuild = CORCOMPILE_BUILD_CHECKED;
#else
    pInfo->wBuild = CORCOMPILE_BUILD_FREE;
#endif

    DWORD type = GetSpecificCpuType();
    pInfo->dwSpecificProcessor = type;

    return S_OK;
}

HRESULT __stdcall CEECompileInfo::GetAssemblyStrongNameHash(
        CORINFO_ASSEMBLY_HANDLE hAssembly,
        PBYTE                 pbSNHash,
        DWORD                *pcbSNHash)
{
    HRESULT hr;

    Assembly *pAssembly = (Assembly *)hAssembly;
    _ASSERTE(pAssembly != NULL);

    PEFile *pFile = pAssembly->GetManifestFile();
    _ASSERTE(pFile != NULL);

    IfFailGo(pFile->GetSNSigOrHash(pbSNHash, pcbSNHash));

ErrExit:
    return hr;
}

#ifdef _DEBUG
HRESULT __stdcall CEECompileInfo::DisableSecurity()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Security::DisableSecurity();
    return S_OK;
}
#endif

HRESULT __stdcall CEECompileInfo::GetTypeDef(CORINFO_CLASS_HANDLE classHandle,
                                             mdTypeDef *token)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    TypeHandle hClass(classHandle);
    EEClass *cls = hClass.GetClass();

    // Sanity test for class
    _ASSERTE(cls->GetMethodTable()->GetClass() == cls);

    *token = cls->GetCl();

    return S_OK;
}

HRESULT __stdcall CEECompileInfo::GetMethodDef(CORINFO_METHOD_HANDLE methodHandle,
                                               mdMethodDef *token)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    *token = ((MethodDesc*)methodHandle)->GetMemberDef();

    return S_OK;
}

HRESULT __stdcall CEECompileInfo::GetFieldDef(CORINFO_FIELD_HANDLE fieldHandle,
                                              mdFieldDef *token)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    *token = ((FieldDesc*)fieldHandle)->GetMemberDef();

    return S_OK;
}

HRESULT __stdcall CEECompileInfo::EncodeModule(CORINFO_MODULE_HANDLE fromHandle,
                                               CORINFO_MODULE_HANDLE handle,
                                               DWORD *pAssemblyIndex,
                                               DWORD *pModuleIndex,
                                               IMetaDataAssemblyEmit *pAssemblyEmit)
{
    HRESULT hr = S_OK;

    CANNOTTHROWCOMPLUSEXCEPTION();

    Module *fromModule = (Module *) fromHandle;
    Assembly *fromAssembly = fromModule->GetAssembly();

    Module *module = (Module *) handle;
    Assembly *assembly = module->GetAssembly();

    if (assembly == fromAssembly)
        *pAssemblyIndex = 0;
    else
    {
        mdToken token;

        CompilationDomain *pDomain = (CompilationDomain *) GetAppDomain();

        RefCache *pRefCache = pDomain->GetRefCache(fromModule);
        token = (mdAssemblyRef)pRefCache->m_sAssemblyRefMap.LookupValue((UPTR)assembly, 
                                                                        NULL);
        if ((UPTR)token == INVALIDENTRY)
            token = fromModule->FindAssemblyRef(assembly);

        if (IsNilToken(token))
        {
            IfFailRet(assembly->DefineAssemblyRef(pAssemblyEmit,
                                                  NULL, 0,
                                                  &token));

            token += fromModule->GetAssemblyRefMax();
        }

        *pAssemblyIndex = RidFromToken(token);

        pRefCache->m_sAssemblyRefMap.InsertValue((UPTR) assembly, (UPTR)token);
    }

    if (module == assembly->GetSecurityModule())
        *pModuleIndex = 0;
    else
    {
        _ASSERTE(module->GetModuleRef() != mdFileNil);
        *pModuleIndex = RidFromToken(module->GetModuleRef());
    }

    return hr;
}

Module *CEECompileInfo::DecodeModule(Module *fromModule,
                                     DWORD assemblyIndex,
                                     DWORD moduleIndex)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly *pAssembly;

    if (assemblyIndex == 0)
        pAssembly = fromModule->GetAssembly();
    else
    {
        OBJECTREF throwable = NULL;
        BEGIN_ENSURE_COOPERATIVE_GC();
        GCPROTECT_BEGIN(throwable);
        HRESULT hr;
        
        if (assemblyIndex < fromModule->GetAssemblyRefMax())
        {
            hr = fromModule->GetAssembly()->
              FindExternalAssembly(fromModule,
                                   RidToToken(assemblyIndex, mdtAssemblyRef),
                                   fromModule->GetMDImport(),
                                   mdTokenNil, 
                                   &pAssembly, &throwable);
        }
        else
        {
            assemblyIndex -= fromModule->GetAssemblyRefMax();

            hr = fromModule->GetAssembly()->
              LoadExternalAssembly(RidToToken(assemblyIndex, mdtAssemblyRef),
                                   fromModule->GetZapMDImport(),
                                   fromModule->GetAssembly(),
                                   &pAssembly, &throwable);
        }

        if (FAILED(hr))
            COMPlusThrow(throwable);

        GCPROTECT_END();
        END_ENSURE_COOPERATIVE_GC();
    }

    if (moduleIndex == 0)
        return pAssembly->GetSecurityModule();
    else
    {
        Module *pModule;
        OBJECTREF throwable = NULL;
        BEGIN_ENSURE_COOPERATIVE_GC();
        GCPROTECT_BEGIN(throwable);
        HRESULT hr;

        hr = pAssembly->FindInternalModule(RidToToken(moduleIndex, mdtFile),
                                           mdTokenNil, &pModule, &throwable);
        if (FAILED(hr))
            COMPlusThrow(throwable);

        GCPROTECT_END();
        END_ENSURE_COOPERATIVE_GC();

        return pModule;
    }
}

HRESULT __stdcall CEECompileInfo::EncodeClass(CORINFO_CLASS_HANDLE classHandle,
                                              BYTE *pBuffer,
                                              DWORD *cBuffer)
{
    BYTE *p = pBuffer;
    BYTE *pEnd = p + *cBuffer;

    COOPERATIVE_TRANSITION_BEGIN();

    TypeHandle th(classHandle);

    p += CorSigCompressDataSafe(ENCODE_TYPE_SIG, p, pEnd);

    p += MetaSig::GetSignatureForTypeHandle(NULL, NULL, th, p, pEnd);

    *cBuffer = (DWORD)(p - pBuffer);

    COOPERATIVE_TRANSITION_END();

    if (p <= pEnd)
        return S_OK;
    else
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
}

TypeHandle CEECompileInfo::DecodeClass(Module *pDefiningModule,
                                       BYTE *pBuffer, 
                                       BOOL dontRestoreType)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(*pBuffer == ENCODE_TYPE_SIG);
    pBuffer++;

    TypeHandle th;
    SigPointer p(pBuffer);

    BEGIN_ENSURE_COOPERATIVE_GC();
    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
        
    th = p.GetTypeHandle(pDefiningModule, &throwable, dontRestoreType);

    if (th.IsNull())
        COMPlusThrow(throwable);

    GCPROTECT_END();
    END_ENSURE_COOPERATIVE_GC();
    return th;
}

HRESULT __stdcall CEECompileInfo::EncodeMethod(CORINFO_METHOD_HANDLE handle,
                                              BYTE *pBuffer,
                                              DWORD *cBuffer)
{
    COOPERATIVE_TRANSITION_BEGIN();

    BYTE *p = pBuffer;
    BYTE *pEnd = p + *cBuffer;

    MethodDesc *pMethod = (MethodDesc *) handle;

#if 0    
    mdMethodDef token = pMethod->GetMemberDef();
    if (!IsNilToken(token))
    {
        p += CorSigCompressDataSafe(ENCODE_METHOD_TOKEN, p, pEnd);
        p += CorSigCompressDataSafe(RidFromToken(token), p, pEnd);
    }
    else
#endif
    {
        p += CorSigCompressDataSafe(ENCODE_METHOD_SIG, p, pEnd);

        TypeHandle th(pMethod->GetMethodTable());
        p += MetaSig::GetSignatureForTypeHandle(NULL, NULL, th, p, pEnd);

        p += CorSigCompressDataSafe(pMethod->GetSlot(), p, pEnd);
    }

    *cBuffer = (DWORD)(p - pBuffer);

    COOPERATIVE_TRANSITION_END();

    return S_OK;
}
                                              
MethodDesc *CEECompileInfo::DecodeMethod(Module *pDefiningModule,
                                         BYTE *pBuffer)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMethod = NULL;
    OBJECTREF throwable = NULL;
    BEGIN_ENSURE_COOPERATIVE_GC();
    GCPROTECT_BEGIN(throwable);

    switch (CorSigUncompressData(pBuffer))
    {
    case ENCODE_METHOD_TOKEN:
        {
            mdMethodDef token = TokenFromRid(CorSigUncompressData(pBuffer), 
                                             mdtMethodDef);
        
            if (FAILED(EEClass::GetMethodDescFromMemberRef(pDefiningModule, token, 
                                                           &pMethod, &throwable)))
                COMPlusThrow(throwable);
        }

        break;
        
    case ENCODE_METHOD_SIG:
        {
            TypeHandle th;
            SigPointer sig(pBuffer);

            th = sig.GetTypeHandle(pDefiningModule, &throwable);
            if (th.IsNull())
                COMPlusThrow(throwable);

            MethodTable *pMT = th.GetMethodTable();
            _ASSERTE(pMT != NULL);

            sig.SkipExactlyOne();
            BYTE *p = (BYTE *) sig.GetPtr();
            pMethod = pMT->GetMethodDescForSlot(CorSigUncompressData(p));
        }
        
        break;

    default:
        _ASSERTE(!"Bad Method Encoding");
    }

    GCPROTECT_END();
    END_ENSURE_COOPERATIVE_GC();

    return pMethod;
}
                                              
HRESULT __stdcall CEECompileInfo::EncodeField(CORINFO_FIELD_HANDLE handle,
                                              BYTE *pBuffer,
                                              DWORD *cBuffer)
{
    COOPERATIVE_TRANSITION_BEGIN();

    BYTE *p = pBuffer;
    BYTE *pEnd = p + *cBuffer;

    FieldDesc *pField = (FieldDesc *) handle;
    
#if 0
    mdFieldDef token = pField->GetMemberDef();
    if (!IsNilToken(token))
    {
        p += CorSigCompressDataSafe(ENCODE_FIELD_TOKEN, p, pEnd);
        p += CorSigCompressDataSafe(RidFromToken(token), p, pEnd);
    }
    else
#endif
    {
        p += CorSigCompressDataSafe(ENCODE_FIELD_SIG, p, pEnd);

        //
        // Write class
        //

        TypeHandle th(pField->GetMethodTableOfEnclosingClass());
        p += MetaSig::GetSignatureForTypeHandle(NULL, NULL, th, p, pEnd);

        //
        // Write field index
        //

        MethodTable *pMT = pField->GetMethodTableOfEnclosingClass();
        FieldDesc *pFields = pMT->GetClass()->GetFieldDescListRaw();

        DWORD i = (DWORD)(pField - pFields);

        _ASSERTE(i < (DWORD) (pMT->GetClass()->GetNumStaticFields() 
                              + pMT->GetClass()->GetNumIntroducedInstanceFields()));

        p += CorSigCompressDataSafe(i, p, pEnd);
    }

    *cBuffer = (DWORD)(p - pBuffer);

    COOPERATIVE_TRANSITION_END();

    return S_OK;
}

FieldDesc *CEECompileInfo::DecodeField(Module *pDefiningModule,
                                       BYTE *pBuffer)
{
    THROWSCOMPLUSEXCEPTION();

    FieldDesc *pField = NULL;
    OBJECTREF throwable = NULL;
    BEGIN_ENSURE_COOPERATIVE_GC();
    GCPROTECT_BEGIN(throwable);
    
    switch (CorSigUncompressData(pBuffer))
    {
    case ENCODE_FIELD_TOKEN:
        {
            mdFieldDef token = TokenFromRid(CorSigUncompressData(pBuffer), 
                                            mdtFieldDef);
        
            if (FAILED(EEClass::GetFieldDescFromMemberRef(pDefiningModule, token, 
                                                          &pField, &throwable)))
                COMPlusThrow(throwable);
        }

        break;
        
    case ENCODE_FIELD_SIG:
        {
            TypeHandle th;
            SigPointer sig(pBuffer);

            th = sig.GetTypeHandle(pDefiningModule, &throwable);
            if (th.IsNull())
                COMPlusThrow(throwable);

            MethodTable *pMT = th.GetMethodTable();
            _ASSERTE(pMT != NULL);

            sig.SkipExactlyOne();
            BYTE *p = (BYTE*) sig.GetPtr();
            pField = pMT->GetClass()->GetFieldDescListRaw() + CorSigUncompressData(p);
        }
        
        break;

    default:
        _ASSERTE(!"Bad Field Encoding");
    }

    GCPROTECT_END();
    END_ENSURE_COOPERATIVE_GC();

    return pField;
}

HRESULT __stdcall CEECompileInfo::EncodeString(mdString token,
                                               BYTE *pBuffer,
                                               DWORD *cBuffer)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    BYTE *p = pBuffer;
    BYTE *pEnd = p + *cBuffer;

    p += CorSigCompressDataSafe(ENCODE_STRING_TOKEN, p, pEnd);
    p += CorSigCompressDataSafe(RidFromToken(token), p, pEnd);

    *cBuffer = (DWORD)(p - pBuffer);

    return S_OK;
}

void CEECompileInfo::DecodeString(Module *pDefiningModule, BYTE *pBuffer,
                                          EEStringData *pData)
{
    THROWSCOMPLUSEXCEPTION();

    switch (CorSigUncompressData(pBuffer))
    {
    case ENCODE_STRING_TOKEN:
        pDefiningModule->ResolveStringRef(TokenFromRid(CorSigUncompressData(pBuffer), mdtString),
                                          pData);
        break;

    default:
        _ASSERTE(!"Bad String Encoding");
    } 

    return;
}

HRESULT __stdcall CEECompileInfo::EncodeSig(mdToken token,
                                            BYTE *pBuffer,
                                            DWORD *cBuffer)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    BYTE *p = pBuffer;
    BYTE *pEnd = p + *cBuffer;

    switch (TypeFromToken(token))
    {
    case mdtSignature:
        p += CorSigCompressDataSafe(ENCODE_SIG_TOKEN, p, pEnd);
        break;
        
    case mdtMemberRef:
        p += CorSigCompressDataSafe(ENCODE_SIG_METHODREF_TOKEN, p, pEnd);
        break;

    default:
        _ASSERTE(!"Bogus token for signature");
    }

    p += CorSigCompressDataSafe(RidFromToken(token), p, pEnd);

    *cBuffer = (DWORD)(p - pBuffer);

    return S_OK;
}

PCCOR_SIGNATURE CEECompileInfo::DecodeSig(Module *pDefiningModule, BYTE *pBuffer)
{
    THROWSCOMPLUSEXCEPTION();

    PCCOR_SIGNATURE result = NULL;

    switch (CorSigUncompressData(pBuffer))
    {
    case ENCODE_SIG_TOKEN:
        {
            mdSignature token = TokenFromRid(CorSigUncompressData(pBuffer), mdtSignature);

            DWORD cSig;
            result = pDefiningModule->GetMDImport()->GetSigFromToken(token, &cSig);
        }
        break;
        
    case ENCODE_SIG_METHODREF_TOKEN:
        {

            mdSignature token = TokenFromRid(CorSigUncompressData(pBuffer), mdtMemberRef);

            PCCOR_SIGNATURE pSig;
            DWORD cSig;
            pDefiningModule->GetMDImport()->GetNameAndSigOfMemberRef(token, &pSig, &cSig);

            result = pSig;
        }
        break;
        
    default:
        _ASSERTE(!"Bad String Encoding");
    } 

    return result;
}


HRESULT __stdcall CEECompileInfo::PreloadModule(CORINFO_MODULE_HANDLE module,
                                                ICorCompileDataStore *pData,
                                                mdToken *pSaveOrderArray,
                                                DWORD cSaveOrderArray,
                                                ICorCompilePreloader **ppPreloader)
{
    CEEPreloader *pPreloader = new (nothrow) CEEPreloader((Module *) module, pData);
    if (pPreloader == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr;
    COOPERATIVE_TRANSITION_BEGIN();

    hr = pPreloader->Preload(pSaveOrderArray, cSaveOrderArray);
    if (FAILED(hr))
        delete pPreloader;
    else
        *ppPreloader = pPreloader;

    COOPERATIVE_TRANSITION_END();
    return hr;
}

HRESULT __stdcall CEECompileInfo::GetZapString(CORCOMPILE_VERSION_INFO *pVersionInfo,
                                               LPWSTR buffer)
{
    return Assembly::GetZapString(pVersionInfo, buffer);
}

//
// Preloader:
//

CEEPreloader::CEEPreloader(Module *pModule,
             ICorCompileDataStore *pData)
  : m_pData(pData)
{
    m_image = new (nothrow) DataImage(pModule, this);
}

CEEPreloader::~CEEPreloader()
{
    delete m_image;
}

HRESULT CEEPreloader::Preload(mdToken *pSaveOrderArray, DWORD cSaveOrderArray)
{
    HRESULT hr;

    IfFailRet(m_image->GetModule()->ExpandAll(m_image));
    IfFailRet(m_image->GetModule()->Save(m_image, pSaveOrderArray, cSaveOrderArray));
    IfFailRet(m_image->CopyData());

    return S_OK;
}

//
// ICorCompilerPreloader
//

SIZE_T __stdcall CEEPreloader::MapMethodEntryPoint(void *methodEntryPoint)
{
    return m_image->GetImageAddress(methodEntryPoint);
}

SIZE_T __stdcall CEEPreloader::MapModuleHandle(CORINFO_MODULE_HANDLE handle)
{
    return m_image->GetImageAddress(handle);
}

SIZE_T __stdcall CEEPreloader::MapClassHandle(CORINFO_CLASS_HANDLE handle)
{
    return m_image->GetImageAddress(handle);
}

SIZE_T __stdcall CEEPreloader::MapMethodHandle(CORINFO_METHOD_HANDLE handle)
{
    return m_image->GetImageAddress(handle);
}

SIZE_T __stdcall CEEPreloader::MapFieldHandle(CORINFO_FIELD_HANDLE handle)
{
    return m_image->GetImageAddress(handle);
}

SIZE_T __stdcall CEEPreloader::MapAddressOfPInvokeFixup(void *addressOfPInvokeFixup)
{
    return m_image->GetImageAddress(addressOfPInvokeFixup);
}

SIZE_T __stdcall CEEPreloader::MapFieldAddress(void *staticFieldAddress)
{
    return m_image->GetImageAddress(staticFieldAddress);
}

SIZE_T __stdcall CEEPreloader::MapVarArgsHandle(CORINFO_VARARGS_HANDLE handle)
{
    return m_image->GetImageAddress(handle);
}

HRESULT CEEPreloader::Link(DWORD *pRidToCodeRVAMap)
{
    HRESULT hr = S_OK;

    COOPERATIVE_TRANSITION_BEGIN();

    hr = m_image->GetModule()->Fixup(m_image, pRidToCodeRVAMap);

    COOPERATIVE_TRANSITION_END();

    return hr;
}

ULONG CEEPreloader::Release()
{
    delete this;
    return 0;
}

HRESULT CEEPreloader::Allocate(ULONG size,
                               ULONG *sizesByDescription,
                               void **baseMemory)
{
    return m_pData->Allocate(size, sizesByDescription, baseMemory);
}

HRESULT CEEPreloader::AddFixup(ULONG offset, DataImage::ReferenceDest dest,
                               DataImage::Fixup type)
{
    return m_pData->AddFixup(offset, (CorCompileReferenceDest) dest,
                             (CorCompileFixup) type);
}

HRESULT CEEPreloader::AddTokenFixup(ULONG offset, mdToken tokenType, Module *module)
{
    return m_pData->AddTokenFixup(offset, tokenType,
                                  (CORINFO_MODULE_HANDLE) module);
}

HRESULT CEEPreloader::GetFunctionAddress(MethodDesc *method, void **pCode)
{
    return m_pData->GetFunctionAddress((CORINFO_METHOD_HANDLE) method,
                                       pCode);
}

HRESULT CEEPreloader::AdjustAttribution(mdToken token, LONG adjustment)
{
    return m_pData->AdjustAttribution(token, adjustment);
}

HRESULT CEEPreloader::Error(mdToken token, HRESULT hr, OBJECTREF *pThrowable)
{
    WCHAR buffer[256];
    WCHAR *message;

    _ASSERTE(pThrowable);

    if (*pThrowable == NULL)
        message = NULL;
    else
    {
        ULONG length = GetExceptionMessage(*pThrowable, buffer, 256);
        if (length < 256)
            message = buffer;
        else
        {
            message = (WCHAR *) _alloca((length+1)*sizeof(WCHAR));
            length = GetExceptionMessage(*pThrowable, message, length+1);
        }

        message[length] = 0;
    }

    return m_pData->Error(token, hr, message);
}

ICorCompileInfo *GetCompileInfo()
{
    // We want at most one of these objects, but we don't want to
    // allocate it in the heap or have to have a global initializer for it
    static ICorCompileInfo *info = NULL;
    static BYTE            infoSpace[sizeof(CEECompileInfo)];

    if (info == NULL)
        info = new (infoSpace) CEECompileInfo();

    return info;
}

//
// CompilationDomain
//


AssemblyBindingTable::AssemblyBindingTable(SIZE_T size)
      : m_pool(sizeof(AssemblyBinding), size, size)
{
    m_map.Init((unsigned)size, CompareSpecs, FALSE, NULL); // @TODO LBS downsizing
}

AssemblyBindingTable::~AssemblyBindingTable()
{
    MemoryPool::Iterator i(&m_pool);

    while (i.Next())
    {
        AssemblyBinding *pBinding = (AssemblyBinding *)i.GetElement();

        pBinding->spec.~AssemblySpec();
    }
}


BOOL AssemblyBindingTable::Bind(AssemblySpec *pSpec, Assembly *pAssembly)
{
    DWORD key = pSpec->Hash();

    AssemblyBinding *entry = (AssemblyBinding *) m_map.LookupValue(key, pSpec);

    if (entry == (AssemblyBinding*) INVALIDENTRY)
    {
        entry = new (m_pool.AllocateElement()) AssemblyBinding;
        if (entry) {
            entry->spec.Init(pSpec);
            entry->pAssembly = pAssembly;
            
            m_map.InsertValue(key, entry);
        }
        return FALSE;
    }
    else
        return TRUE;
}

Assembly *AssemblyBindingTable::Lookup(AssemblySpec *pSpec)
{
    DWORD key = pSpec->Hash();

    AssemblyBinding *entry = (AssemblyBinding *) 
      m_map.LookupValue(key, pSpec);

    if (entry == (AssemblyBinding*) INVALIDENTRY)
        return NULL;
    else
    {
        return entry->pAssembly;
    }
}

DWORD AssemblyBindingTable::Hash(AssemblySpec *pSpec)
{
    return pSpec->Hash();
}

BOOL AssemblyBindingTable::CompareSpecs(UPTR u1, UPTR u2)
{
    AssemblySpec *a1 = (AssemblySpec *) u1;
    AssemblySpec *a2 = (AssemblySpec *) u2;

    return a1->Compare(a2) != 0;
}


CompilationDomain::CompilationDomain()
  : m_pTargetAssembly(NULL),
    m_pBindings(NULL),
    m_pEmit(NULL),
    m_pDependencySpecs(NULL),
    m_pDependencies(NULL),
    m_pDependencyBindings(NULL),
    m_cDependenciesCount(0),
    m_cDependenciesAlloc(0),
    m_hDemands(NULL)
{
}

CompilationDomain::~CompilationDomain()
{
    if (m_pDependencySpecs != NULL)
        delete m_pDependencySpecs;

    if (m_pBindings != NULL)
        delete m_pBindings;

    if (m_pDependencies != NULL)
        delete [] m_pDependencies;

    if (m_pDependencyBindings != NULL)
        delete [] m_pDependencyBindings;

    if (m_pEmit != NULL)
        m_pEmit->Release();

    for (unsigned i = 0; i < m_rRefCaches.Size(); i++)
    {
        delete m_rRefCaches[i];
        m_rRefCaches[i]=NULL;
    }
}

HRESULT CompilationDomain::Init()
{
    HRESULT hr = AppDomain::Init();
    if (SUCCEEDED(hr))
    {
        GetSecurityDescriptor()->SetDefaultAppDomainProperty();
        SetCompilationDomain();
    }

    return hr;
}

void CompilationDomain::AddDependencyEntry(PEFile *pFile,
                                           mdAssemblyRef ref,
                                           GUID *pmvid,
                                           PBYTE rgbHash, DWORD cbHash)
{
    if (m_cDependenciesCount == m_cDependenciesAlloc)
    {
        if (m_cDependenciesAlloc == 0)
            m_cDependenciesAlloc = 20;
        else
            m_cDependenciesAlloc *= 2;

        CORCOMPILE_DEPENDENCY *pNewDependencies 
          = new (nothrow) CORCOMPILE_DEPENDENCY [m_cDependenciesAlloc];
        if (!pNewDependencies)
            return; //@TODO: shouldn't we return an error?

        if (m_pDependencies)
        {
            memcpy(pNewDependencies, m_pDependencies, 
                   m_cDependenciesCount*sizeof(CORCOMPILE_DEPENDENCY));

            delete [] m_pDependencies;
        }

        m_pDependencies = pNewDependencies;

        BYTE **pNewDependencyBindings 
          = new (nothrow) BYTE * [m_cDependenciesAlloc];
        if (!pNewDependencyBindings)
            return; //@TODO: shouldn't we return an error?

        if (m_pDependencyBindings)
        {
            memcpy(pNewDependencyBindings, m_pDependencyBindings, 
                   m_cDependenciesCount*sizeof(BYTE*));

            delete [] m_pDependencyBindings;
        }

        m_pDependencyBindings = pNewDependencyBindings;
    }

    CORCOMPILE_DEPENDENCY *pDependency = &m_pDependencies[m_cDependenciesCount];

    pDependency->dwAssemblyRef = ref;
    pDependency->mvid = *pmvid;

    _ASSERTE(cbHash <= MAX_SNHASH_SIZE);
    pDependency->wcbSNHash = (WORD) cbHash;
    memcpy(pDependency->rgbSNHash, rgbHash, min(cbHash, MAX_SNHASH_SIZE));

    m_pDependencyBindings[m_cDependenciesCount] = pFile->GetBase();

    m_cDependenciesCount++;
}

HRESULT CompilationDomain::AddDependency(AssemblySpec *pRefSpec,
                                         IAssembly* pIAssembly,
                                         PEFile *pFile)
{
    HRESULT hr;

    //
    // See if we've already added the contents of the ref
    //

    if (m_pDependencySpecs->Store(pRefSpec))
        return S_OK;

    //
    // Make a spec for the bound assembly
    //
    
    IAssemblyName *pFusionName;
    if (pIAssembly == NULL)
        pFusionName = NULL;
    else
        pIAssembly->GetAssemblyNameDef(&pFusionName);

    AssemblySpec assemblySpec;
    assemblySpec.InitializeSpec(pFusionName, pFile);

    if (pFusionName)
        pFusionName->Release();

    //
    // Emit token for the ref
    //

    mdAssemblyRef refToken;
    IfFailRet(pRefSpec->EmitToken(m_pEmit, &refToken));

    //
    // Fill in the mvid
    //

    GUID mvid = STRUCT_CONTAINS_HASH;

    // If this assembly has skip verification permission, then we can store the
    // mvid for the assembly so that at load time we know that an mvid comparison
    // may be all we need.
    {
        // Check to see if this assembly has already been loaded into this appdomain,
        // and if so just ask it if it has skip verification permission
        Assembly *pAsm = FindAssembly(pFile->GetBase());
        if (pAsm)
        {
            // @TODO: Use Security::QuickCanSkipVerification here
            if (Security::CanSkipVerification(pAsm))
                pAsm->GetManifestImport()->GetScopeProps(NULL, &mvid);
        }
        else
        {
            // This is the hacked way of figuring out if a file has skip verification permission
            if (Security::CanLoadUnverifiableAssembly(pFile, NULL, FALSE, NULL))
            {
                IMDInternalImport *pIMDI = pFile->GetMDImport(&hr);
                if (SUCCEEDED(hr))
                {
                    if (pIMDI->IsValidToken(pIMDI->GetModuleFromScope()))
                        pIMDI->GetScopeProps(NULL, &mvid);
                    else
                        return COR_E_BADIMAGEFORMAT;
                }
            }
        }
    }

    //
    // Get hash for bound file
    //

    DWORD cbSNHash = MAX_SNHASH_SIZE;
    CQuickBytes qbSNHash;
    IfFailRet(qbSNHash.ReSize(cbSNHash));
    IfFailRet(pFile->GetSNSigOrHash((BYTE *) qbSNHash.Ptr(), &cbSNHash));

    //
    // Add the entry.  Include the PEFile if we are not doing explicit bindings.
    //

    AddDependencyEntry(pFile, refToken, &mvid, (PBYTE) qbSNHash.Ptr(), cbSNHash);

    return S_OK;
}

HRESULT CompilationDomain::BindAssemblySpec(AssemblySpec *pSpec,
                                            PEFile **ppFile,
                                            IAssembly** ppIAssembly,
                                            Assembly **ppDynamicAssembly,
                                            OBJECTREF *pExtraEvidence,
                                            OBJECTREF *pThrowable)
{
    HRESULT hr;

    //
    // Do the binding
    //

    if (m_pBindings != NULL)
    {
        //
        // Use explicit bindings
        //

        Assembly *pAssembly = m_pBindings->Lookup(pSpec);
        if (pAssembly != NULL)
            hr = PEFile::Clone(pAssembly->GetManifestFile(), ppFile);
        else
        {
            //
            // Use normal binding rules
            // (possibly with our custom IApplicationContext)
            //

            hr = AppDomain::BindAssemblySpec(pSpec, ppFile, ppIAssembly, 
                                             ppDynamicAssembly,
                                             pExtraEvidence,
                                             pThrowable);
        }
    }
    else
    {
        //
        // Use normal binding rules
        // (possibly with our custom IApplicationContext)
        //

        hr = AppDomain::BindAssemblySpec(pSpec, ppFile, ppIAssembly, 
                                         ppDynamicAssembly, 
                                         pExtraEvidence, pThrowable);
    }

    //
    // Record the dependency
    // Don't store a binding from mscorlib to itself.  We do want to include other
    // bindings of mscorlib so we store the proper MVID (in case mscorlib gets
    // recompiled)
    //

    if (hr == S_OK
        && m_pEmit != NULL
        && !(m_pTargetAssembly == SystemDomain::SystemAssembly() && pSpec->IsMscorlib()))
    {
        AddDependency(pSpec, *ppIAssembly, *ppFile);
    }

    return hr;
}


HRESULT CompilationDomain::PredictAssemblySpecBinding(AssemblySpec *pSpec, GUID *pmvid, BYTE *pbHash, DWORD *pcbHash)
{
    if (m_pBindings != NULL)
    {
        //
        // Use explicit bindings
        //

        Assembly *pAssembly = m_pBindings->Lookup(pSpec);
        if (pAssembly != NULL)
        {
            return pAssembly->GetManifestFile()->GetSNSigOrHash(pbHash, pcbHash);
        }
    }

    // 
    // Use normal binding rules 
    // (possibly with our custom IApplicationContext)
    //

    return AppDomain::PredictAssemblySpecBinding(pSpec, pmvid, pbHash, pcbHash);
}

void CompilationDomain::OnLinktimeCheck(Assembly *pAssembly, 
                                        OBJECTREF refCasDemands,
                                        OBJECTREF refNonCasDemands)
{
    if (pAssembly == m_pTargetAssembly)
    {
        if (refNonCasDemands != NULL)
        {
            GCPROTECT_BEGIN(refCasDemands);
            AddPermissionSet(refNonCasDemands);
            GCPROTECT_END();
        }
        if (refCasDemands != NULL)
            AddPermissionSet(refCasDemands);
    }
}

void CompilationDomain::OnLinktimeCanCallUnmanagedCheck(Assembly *pAssembly)
{
    if (pAssembly == m_pTargetAssembly
        && !pAssembly->IsSystem())
    {
        OBJECTREF callUnmanaged = NULL;
        GCPROTECT_BEGIN(callUnmanaged);
        Security::GetPermissionInstance(&callUnmanaged, SECURITY_UNMANAGED_CODE);
        AddPermission(callUnmanaged);
        GCPROTECT_END();
    }
}

void CompilationDomain::OnLinktimeCanSkipVerificationCheck(Assembly * pAssembly)
{
    if (pAssembly == m_pTargetAssembly && !pAssembly->IsSystem())
    {
        OBJECTREF skipVerification = NULL;
        GCPROTECT_BEGIN(skipVerification);
        Security::GetPermissionInstance(&skipVerification, SECURITY_SKIP_VER);
        AddPermission(skipVerification);
        GCPROTECT_END();
    }
}

void CompilationDomain::OnLinktimeFullTrustCheck(Assembly *pAssembly)
{
    if (pAssembly == m_pTargetAssembly
        && !pAssembly->IsSystem())
    {
        OBJECTREF refFullTrust = NULL;
        GCPROTECT_BEGIN(refFullTrust);
        refFullTrust = SecurityHelper::CreatePermissionSet(TRUE);

        // Don't wack the old Permission Set, it could have identity permissions
        // Also don't use the SECURITY_FULL_TRUST object, it is not to be
        // modified.

        AddPermissionSet(refFullTrust);
        GCPROTECT_END();
    }
}

void CompilationDomain::AddPermission(OBJECTREF demand)
{
    GCPROTECT_BEGIN(demand);

    if (m_hDemands == NULL)
        m_hDemands = CreateHandle(SecurityHelper::CreatePermissionSet(FALSE));

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__ADD_PERMISSION);

    INT64 args[] = {
        ObjToInt64(ObjectFromHandle(m_hDemands)),
        ObjToInt64(demand)
    };

    pMD->Call(args, METHOD__PERMISSION_SET__ADD_PERMISSION);
    
    GCPROTECT_END();
}

void CompilationDomain::AddPermissionSet(OBJECTREF demandSet)
{
    GCPROTECT_BEGIN(demandSet);  

    if (m_hDemands == NULL)
        m_hDemands = CreateHandle(demandSet);
    else
    {
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__INPLACE_UNION);

        INT64 args[] = {
            ObjToInt64(ObjectFromHandle(m_hDemands)),
            ObjToInt64(demandSet)
        };

        pMD->Call(args, METHOD__PERMISSION_SET__INPLACE_UNION);
    }
    
    GCPROTECT_END();
}

HRESULT __stdcall 
    CompilationDomain::SetApplicationContext(IApplicationContext *pFusionContext)
{
    if (m_pFusionContext != NULL)
        m_pFusionContext->Release();

    m_pFusionContext = pFusionContext;
    pFusionContext->AddRef();

    return S_OK;
}

HRESULT __stdcall 
    CompilationDomain::SetContextInfo(LPCWSTR path, BOOL isExe)
{
    HRESULT hr = S_OK;

    COOPERATIVE_TRANSITION_BEGIN();

    if (isExe)
        SetupExecutableFusionContext((WCHAR*)path);
    else
    {
        hr = m_pFusionContext->Set(ACTAG_APP_BASE_URL,
                                   (void*) path, (DWORD) ((wcslen(path)+1) * sizeof(WCHAR)), 
                                   0);
    }

    COOPERATIVE_TRANSITION_END();

    return hr;
}



HRESULT __stdcall 
    CompilationDomain::SetExplicitBindings(ICorZapBinding **pBindings, 
                                           DWORD bindingCount)
{
    HRESULT hr = S_OK;

    AssemblyBindingTable *pTable = new (nothrow) AssemblyBindingTable(bindingCount);
    if (pTable == NULL)
        return E_OUTOFMEMORY;

    ICorZapBinding **pBindingsEnd = pBindings + bindingCount;
    while (pBindings < pBindingsEnd)
    {
        ICorZapBinding *pBinding = *pBindings;

        IAssemblyName *pRef;
        IAssemblyName *pAssembly;
        AssemblySpec assemblySpec;
        AssemblySpec refSpec;

        //
        // Get the ref
        //

        hr = pBinding->GetRef(&pRef);

        if (SUCCEEDED(hr))
        {
            hr = refSpec.InitializeSpec(pRef);
            pRef->Release();
        }

        //
        // Get the binding
        //

        if (SUCCEEDED(hr))
        {
            hr = pBinding->GetAssembly(&pAssembly);
            
            if (SUCCEEDED(hr))
            {
                hr = assemblySpec.InitializeSpec(pAssembly);

                pAssembly->Release();
            }
        }

        Assembly *pFoundAssembly;
        _ASSERTE(this == SystemDomain::GetCurrentDomain());
        hr = assemblySpec.LoadAssembly(&pFoundAssembly);

        if (SUCCEEDED(hr))
        {
            //
            // Store the binding in the table.
            //

            pTable->Bind(&refSpec, pFoundAssembly);
            hr = S_OK;
        }

        // For now, ignore load and continue - 
        // they will turn into load errors later.
            
        pBindings++;
    }

    if (SUCCEEDED(hr))
        m_pBindings = pTable;
    else
        delete pTable;

    return hr;
}

HRESULT __stdcall CompilationDomain::SetDependencyEmitter(IMetaDataAssemblyEmit *pEmit)
{
    pEmit->AddRef();
    m_pEmit = pEmit;

    m_pDependencySpecs = new (nothrow) AssemblySpecHash();
    if (!m_pDependencySpecs)
        return E_OUTOFMEMORY;
    
    return S_OK;
}


HRESULT __stdcall 
    CompilationDomain::GetDependencies(CORCOMPILE_DEPENDENCY **ppDependencies,
                                       DWORD *pcDependencies)
{
    //
    // Return the bindings.
    //

    *ppDependencies = m_pDependencies;
    *pcDependencies = m_cDependenciesCount;

    return S_OK;
}

void CompilationDomain::EnterDomain(ContextTransitionFrame *pFrame)
{
    Context *pContext = GetDefaultContext();

    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    // this is ok as are just compiling and not running user apps
    pThread->EnterContextRestricted(pContext, pFrame, TRUE);
}

void CompilationDomain::ExitDomain(ContextTransitionFrame *pFrame)
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    pThread->ReturnToContext(pFrame, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compluswrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  COMPlusWrapper
**
**
** Purpose: The implementation of the ComObject class
**
===========================================================*/

#include "common.h"

#include <ole2.h>

class Object;
#include "vars.hpp"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "threads.h"
#include "field.h"
#include "COMPlusWrapper.h"
#include "ComClass.h"
#include "ReflectUtil.h"
#include "hash.h"
#include "interopUtil.h"
#include "gcscan.h"
#include "ComCallWrapper.h"
#include "eeconfig.h"
#include "comdelegate.h"
#include "permset.h"
#include "wsperf.h"
#include "comcache.h"
#include "notifyexternals.h"
#include "remoting.h"
#include "olevariant.h"
#include "InteropConverter.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"

    #define OLE32DLL    L"ole32.dll"

    typedef struct
    {
        ComPlusWrapper  *pWrapper;
        IID              iid;
        BOOL             fSuccess;
    } CCBFailedQIProbeCallbackData;

    HRESULT CCBFailedQIProbeCallback(LPVOID pData);
    void    CCBFailedQIProbeOutput(CustomerDebugHelper *pCdh, MethodTable *pMT);
#endif // CUSTOMER_CHECKED_BUILD

TypeHandle ComObject::m_IEnumerableType;

//-------------------------------------------------------------
// Common code for licensing
// 
static IUnknown *CreateInstanceFromClassFactory(IClassFactory *pClassFact, REFIID riid, IUnknown *punkOuter, BOOL *pfDidContainment, MethodTable *pMTClass)
{
    THROWSCOMPLUSEXCEPTION();

    IClassFactory2 *pClassFact2 = NULL;
    BSTR            bstrKey = NULL;
    HRESULT         hr;
    IUnknown       *pUnk = NULL;

    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    EE_TRY_FOR_FINALLY
    {

        // Does this support licensing?
        if (FAILED(SafeQueryInterface(pClassFact, IID_IClassFactory2, (IUnknown**)&pClassFact2)))
        {
            // not a licensed class - just createinstance the usual way.
            // Create an instance of the object.
            DebuggerExitFrame __def;
            pThread->EnablePreemptiveGC();
            _ASSERTE(!pUnk);
            hr = pClassFact->CreateInstance(punkOuter, IID_IUnknown, (void **)&pUnk);
            if (FAILED(hr) && punkOuter)
            {
                hr = pClassFact->CreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                *pfDidContainment = TRUE;
            }
            pThread->DisablePreemptiveGC();
            __def.Pop();
            if (FAILED(hr))
            {
                COMPlusThrowHR(hr);
            }
    
        }
        else
        {

            if (pMTClass == NULL || !g_EnableLicensingInterop)
            {

                // Create an instance of the object.
                DebuggerExitFrame __def;
                pThread->EnablePreemptiveGC();
                _ASSERTE(!pUnk);
                hr = pClassFact->CreateInstance(punkOuter, IID_IUnknown, (void **)&pUnk);
                if (FAILED(hr) && punkOuter)
                {
                    hr = pClassFact->CreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                    *pfDidContainment = TRUE;
                }
                pThread->DisablePreemptiveGC();
                __def.Pop();
                if (FAILED(hr))
                {
                    COMPlusThrowHR(hr);
                }
            }
            else
            {
                MethodTable *pHelperMT = pThread->GetDomain()->GetLicenseInteropHelperMethodTable(pMTClass->GetClass()->GetClassLoader());

                MethodDesc *pMD = pHelperMT->GetClass()->FindMethod("GetCurrentContextInfo", &gsig_IM_LicenseInteropHelper_GetCurrentContextInfo);

                OBJECTREF pHelper = NULL; // LicenseInteropHelper
                GCPROTECT_BEGIN(pHelper);
                pHelper = AllocateObject(pHelperMT);
                
                TypeHandle rth = TypeHandle(pMTClass);


                // First, crack open the current licensing context.
                INT32 fDesignTime = 0;
                INT64 args[4];
                args[0] = ObjToInt64(pHelper);
                args[3] = (INT64)&fDesignTime;
                args[2] = (INT64)&bstrKey;
                *(TypeHandle*)&(args[1]) = rth;
                pMD->Call(args);
        
        
                if (fDesignTime)
                {
                    // If designtime, we're supposed to obtain the runtime license key
                    // from the component and save it away in the license context
                    // (the design tool can then grab it and embedded it into the
                    // app it's creating.)

                    if (bstrKey != NULL) 
                    {
                        // It's illegal for our helper to return a non-null bstrKey
                        // when the context is design-time. But we'll try to do the
                        // right thing anway.
                        _ASSERTE(!"We're not supposed to get here, but we'll try to cope anyway.");
                        SysFreeString(bstrKey);
                        bstrKey = NULL;
                    }
        
                    pThread->EnablePreemptiveGC();
                    hr = pClassFact2->RequestLicKey(0, &bstrKey);
                    pThread->DisablePreemptiveGC();
                    if (FAILED(hr) && hr != E_NOTIMPL) // E_NOTIMPL is not a true failure. It simply indicates that
                                                       // the component doesn't support a runtime license key.
                    {
                        COMPlusThrowHR(hr);
                    }
                    MethodDesc *pMD = pHelperMT->GetClass()->FindMethod("SaveKeyInCurrentContext", &gsig_IM_LicenseInteropHelper_SaveKeyInCurrentContext);

                    args[0] = ObjToInt64(pHelper);
                    args[1] = (INT64)bstrKey;
                    pMD->Call(args);
                }
        
        
        
                DebuggerExitFrame __def;
                pThread->EnablePreemptiveGC();
                if (fDesignTime || bstrKey == NULL) 
                {
                    // Either it's design time, or the current context doesn't
                    // supply a runtime license key.
                    _ASSERTE(!pUnk);
                    hr = pClassFact->CreateInstance(punkOuter, IID_IUnknown, (void **)&pUnk);
                    if (FAILED(hr) && punkOuter)
                    {
                        hr = pClassFact->CreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                        *pfDidContainment = TRUE;
                    }
                }
                else
                {
                    // It's runtime, and we do have a non-null license key.
                    _ASSERTE(!pUnk);
                    _ASSERTE(bstrKey != NULL);
                    hr = pClassFact2->CreateInstanceLic(punkOuter, NULL, IID_IUnknown, bstrKey, (void**)&pUnk);
                    if (FAILED(hr) && punkOuter)
                    {
                        hr = pClassFact2->CreateInstanceLic(NULL, NULL, IID_IUnknown, bstrKey, (void**)&pUnk);
                        *pfDidContainment = TRUE;
                    }
        
                }
                pThread->DisablePreemptiveGC();
                __def.Pop();
                if (FAILED(hr))
                {
                    COMPlusThrowHR(hr);
                }
    
                GCPROTECT_END();
            }
        }
    }
    EE_FINALLY
    {
        if (pClassFact2)
        {
            ULONG cbRef = SafeRelease(pClassFact2);
            LogInteropRelease(pClassFact2, cbRef, "Releasing class factory2 in ComClassFactory::CreateInstance");
        }
        if (bstrKey)
        {
            SysFreeString(bstrKey);
        }
    }
    EE_END_FINALLY

    _ASSERTE(pUnk != NULL);  // Either we get here with a real punk or we threw above
    return pUnk;
}


//-------------------------------------------------------------
// ComClassFactory::CreateAggregatedInstance(MethodTable* pMTClass)
// create a COM+ instance that aggregates a COM instance

OBJECTREF ComClassFactory::CreateAggregatedInstance(MethodTable* pMTClass, BOOL ForManaged)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pMTClass != NULL);

    ULONG cbRef;
    BOOL fDidContainment = FALSE;

    #ifdef _DEBUG
    // verify the class extends a COM import class
        EEClass * pClass = pMTClass->GetClass();
        do 
        {
            pClass = pClass->GetParentClass();
        }
        while (pClass == NULL || pClass->IsComImport());
    _ASSERTE(pClass != NULL);
    #endif

    HRESULT hr = S_OK;
    IUnknown* pOuter = NULL;
    IUnknown *pUnk = NULL;
    IClassFactory *pClassFact = NULL;
    ComPlusWrapper* pPlusWrap = NULL;
    ComCallWrapper* pComWrap = NULL;
    BOOL bCreationSuccessfull = FALSE;
    BOOL bUseDelegate = FALSE;
    EEClass *pCallbackClass = NULL;
    OBJECTREF Throwable = NULL;
    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    OBJECTREF oref = NULL;
    COMOBJECTREF cref = NULL;
    GCPROTECT_BEGIN(cref)
    {
        cref = (COMOBJECTREF)ComObject::CreateComObjectRef(pMTClass);
        if (cref == NULL)
        {
            goto LExit;
        }

        //get wrapper for the object, this could enable GC
        pComWrap =  ComCallWrapper::InlineGetWrapper((OBJECTREF *)&cref); 
        
        if (pComWrap == NULL)
        {
            goto LExit;
        }

#if 0
        CallDefaultConstructor(cref);            
#endif  

        // Make sure the ClassInitializer has run, since the user might have
        // wanted to set up a COM object creation callback.
        if (!pMTClass->CheckRunClassInit(&Throwable))
            COMPlusThrow(Throwable);

        // If the user is going to use a delegate to allocate the COM object
        // (rather than CoCreateInstance), we need to know now, before we enable
        // preemptive GC mode (since we touch object references in the
        // determination).
        // We don't just check the current class to see if it has a cllabck
        // registered, we check up the class chain to see if any of our parents
        // did.
        pCallbackClass = pMTClass->GetClass();
        while ((pCallbackClass != NULL) &&
               (pCallbackClass->GetMethodTable()->GetObjCreateDelegate() == NULL) &&
               !pCallbackClass->IsComImport())
            pCallbackClass = pCallbackClass->GetParentClass();
        if (pCallbackClass && !pCallbackClass->IsComImport())
            bUseDelegate = TRUE;

        // Create a new scope here so that declaration of DebuggerExitFrame doesn't cause
        // compiler to complain about skipping init of local var with goto LExit above.
        {
            DebuggerExitFrame __def;
    
            // enable GC
            pThread->EnablePreemptiveGC();
            
            // get the IUnknown interface for the COM+ object
            pOuter = ComCallWrapper::GetComIPfromWrapper(pComWrap, IID_IUnknown, NULL, FALSE);
            _ASSERTE(pOuter != NULL);
    
            // If the user has set a delegate to allocate the COM object, use it.
            // Otherwise we just CoCreateInstance it.
            if (bUseDelegate)
            {
                // We need preemptive GC mode disabled becuase we're going to mess
                // with object references.
                pThread->DisablePreemptiveGC();
    
                COMPLUS_TRYEX(pThread)
                {
                    INT64 args[2];
        
    
                    OBJECTREF orDelegate = pCallbackClass->GetMethodTable()->GetObjCreateDelegate();
                    MethodDesc *pMeth = COMDelegate::GetMethodDesc(orDelegate);
                    _ASSERTE(pMeth);
    
                    // Get the OR on which we are going to invoke the method and set it
                    //  as the first parameter in arg above.
                    FieldDesc *pFD = COMDelegate::GetOR();
                    args[0] = pFD->GetValue32(orDelegate);
                    
                    // Pass the IUnknown of the aggregator as the second argument.
                    args[1] = (INT64)pOuter;
    
                    // Call the method...
                    pUnk = (IUnknown *)pMeth->Call(args);
    
                    hr = pUnk ? S_OK : E_FAIL;
                }
                COMPLUS_CATCH
                {
                    pUnk = NULL;
                    hr = SetupErrorInfo(GETTHROWABLE());
                }
                COMPLUS_END_CATCH
            }
            else
            {
                // Retrieve the IClassFactory to use to create the instances of the COM components.
                hr = GetIClassFactory(&pClassFact);
                if (SUCCEEDED(hr))
                {
                    // do a cocreate an instance
                    // as we don't expect to handle different threading models
                    pThread->DisablePreemptiveGC();
                    _ASSERTE(m_pEEClassMT);
                    pUnk = CreateInstanceFromClassFactory(pClassFact, IID_IUnknown, pOuter, &fDidContainment, m_pEEClassMT);
                    pThread->EnablePreemptiveGC();
                    SafeRelease(pClassFact);
                    pClassFact = NULL;
                }
    
                //Disable GC
                pThread->DisablePreemptiveGC();
            }
    
            __def.Pop();
        }
        
        // give up the extra release that we did in our QI
        ComCallWrapper::Release(pComWrap);

        // Here's the scary part.  If we are doing a managed 'new' of the aggregator,
        // then COM really isn't involved.  We should not be counting for our caller
        // because our caller relies on GC references rather than COM reference counting
        // to keep us alive.
        //
        // Drive the instances count down to 0 -- and rely on the GCPROTECT to keep us
        // alive until we get back to our caller.
        if (ForManaged && hr == S_OK)
        {
            ComCallWrapper::Release(pComWrap);
        }

        if (hr == S_OK)
        {                       
            ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();
            // create a wrapper for this COM object

            // try unwrapping the proxies to maintain identity
            IUnknown* pIdentity = pUnk;
            pPlusWrap = pCache->CreateComPlusWrapper(pUnk, pIdentity);
            // init it with the object reference
            if (pPlusWrap != NULL && pPlusWrap->Init((OBJECTREF)cref))
            {   
                // store the wrapper in the COMObject, for fast access
                // without going to the sync block
                cref->Init(pPlusWrap);

                // we used containment 
                // we need to store this wrapper in our hash table
                // NOTE: rajak
                // make sure we are in the right GC mode
                // as during GC we touch the Hash table 
                // to remove entries with out locking
                _ASSERTE(GetThread()->PreemptiveGCDisabled());

                pCache->LOCK();                    
                pCache->InsertWrapper(pUnk,pPlusWrap);
                pCache->UNLOCK();

                if (fDidContainment)
                {
                    // mark the wrapper as contained
                    pPlusWrap->MarkURTContained();
                }
                else
                {
                    // mark the wrapper as aggregated
                    pPlusWrap->MarkURTAggregated();
                }

                // The creation of the aggregated object was successfull.
                bCreationSuccessfull = TRUE;
            }
        }
        else
        {
            // We do not want the finalizer to run on this object since we haven't
            // even run the constructor yet.
            g_pGCHeap->SetFinalizationRun(OBJECTREFToObject((OBJECTREF)cref));
        }

LExit:
        // release the unknown as the wrapper takes its own ref-count
        if (pUnk)
        {
            cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "CreateAggInstance");
        }

        // If the object was created successfully then we need to copy the OBJECTREF
        // to oref because the GCPROTECT_END() will destroy the contents of cref.
        if (bCreationSuccessfull)
        {
            oref = ObjectToOBJECTREF(*(Object **)&cref);             
        }
    }
    GCPROTECT_END();

    if (oref == NULL)
    {
        if (pPlusWrap)
        {   
            pPlusWrap->CleanupRelease();
            pPlusWrap = NULL;
        }

        if (pClassFact)
        {
            cbRef = SafeRelease(pClassFact);
            LogInteropRelease(pClassFact, cbRef, "CreateAggInstance FAILED");
        }

        if (pOuter)
        {
            cbRef = SafeRelease(pOuter);    
            LogInteropRelease(pOuter, cbRef, "CreateAggInstance FAILED");
        }

        if (hr == S_OK)
        {
            COMPlusThrowOM();
        }
        else
        {
            ThrowComCreationException(hr, m_rclsid);
        }
    }

    return oref; 
}

//--------------------------------------------------------------
// Init the ComClassFactory.
void ComClassFactory::Init(WCHAR* pwszProgID, WCHAR* pwszServer, MethodTable* pEEClassMT)
{
    m_pwszProgID = pwszProgID;
    m_pwszServer = pwszServer;  
    m_pEEClassMT = pEEClassMT;
}

HRESULT ComClassFactory::GetIClassFactory(IClassFactory **ppClassFactory)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    
    // If a server name is specified, then first try CLSCTX_REMOTE_SERVER.
    if (m_pwszServer)
    {
        // Set up the COSERVERINFO struct.
        COSERVERINFO ServerInfo;
        memset(&ServerInfo, 0, sizeof(COSERVERINFO));
        ServerInfo.pwszName = m_pwszServer;
                
        // Try to retrieve the IClassFactory passing in CLSCTX_REMOTE_SERVER.
        hr = CoGetClassObject(m_rclsid, CLSCTX_REMOTE_SERVER, &ServerInfo, IID_IClassFactory, (void**)ppClassFactory);
        if (SUCCEEDED(hr))
            return S_OK;

        // Since a remote server was explicitly requested let's throw
        // for failures (instead of trying CLSCTX_SERVER below)
        COMPlusThrowHR(hr);
            return S_OK;
    }
    
    // No server name is specified so we use CLSCTX_SERVER.
    return CoGetClassObject(m_rclsid, CLSCTX_SERVER, NULL, IID_IClassFactory, (void**)ppClassFactory);
}

//-------------------------------------------------------------
// ComClassFactory::CreateInstance()
// create instance, calls IClassFactory::CreateInstance
OBJECTREF ComClassFactory::CreateInstance(MethodTable* pMTClass, BOOL ForManaged)
{
    THROWSCOMPLUSEXCEPTION();

    // Check for aggregates
    if (pMTClass != NULL && !pMTClass->GetClass()->IsComImport())
    {
        return CreateAggregatedInstance(pMTClass, ForManaged);
    }

    Thread *pThread = GetThread();   
    HRESULT hr = S_OK;
    ULONG cbRef;
    IUnknown *pUnk = NULL;
    IDispatch *pDisp = NULL;
    IClassFactory *pClassFact = NULL;
    OBJECTREF coref = NULL;
    OBJECTREF RetObj = NULL;

    _ASSERTE(pThread->PreemptiveGCDisabled());

    GCPROTECT_BEGIN(coref)
    {
        EE_TRY_FOR_FINALLY
        {
            // Enable GC
            pThread->EnablePreemptiveGC();

            // Retrieve the IClassFactory to use to create the instances of the COM components.
            hr = GetIClassFactory(&pClassFact);
            if (FAILED(hr))
                ThrowComCreationException(hr, m_rclsid);
            
            // Disable GC
            pThread->DisablePreemptiveGC();
            
            // Create the instance using the IClassFactory.
            pUnk = CreateInstanceFromClassFactory(pClassFact, IID_IUnknown, NULL, NULL, pMTClass ? pMTClass : m_pEEClassMT);

            // Even though we just created the object, it's possible that we got back a context
            // wrapper from the COM side.  For instance, it could have been an existing object
            // or it could have been created in a different context than we are running in.
            ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();

            // @TODO: Note that the pMT arg to GetComPlusWrapper is currently ignored.  But
            // we want to pass in the MT for IUnknown, or something to indicate that this
            // is an IUnknown here.
    
            // pMTClass is the class that wraps the com ip
            // if a class was passed in use it 
            // otherwise use the class that we know
            if (pMTClass == NULL)
                pMTClass = m_pEEClassMT;
                
            coref = GetObjectRefFromComIP(pUnk, pMTClass);
            
            if (coref == NULL)
                COMPlusThrowOM();
        }
        EE_FINALLY
        {
            if (pClassFact)
            {
                cbRef = SafeRelease(pClassFact);
                LogInteropRelease(pClassFact, cbRef, "Releasing class factory in ComClassFactory::CreateInstance");
            }
            if (pUnk)
            {
                cbRef = SafeRelease(pUnk);
                LogInteropRelease(pUnk, cbRef, "Releasing pUnk in ComClassFactory::CreateInstance");
            }
        }
        EE_END_FINALLY

        // Set the value of the return object.
        RetObj = coref;
    }
    GCPROTECT_END();

    return RetObj;
}


//-------------------------------------------------------------
// ComClassFactory::CreateInstance(LPVOID pv, EEClass* pClass)
// static function, casts void pointer to ComClassFactory
// and delegates the create instance call
OBJECTREF __stdcall ComClassFactory::CreateInstance(LPVOID pv, EEClass* pClass)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
     // Calls to COM up ahead.
    if (FAILED(hr = QuickCOMStartup()))
    {
        COMPlusThrowHR(hr);
    }

    _ASSERTE(pv != NULL || pClass != NULL);
    MethodTable* pMT = NULL;
    ComClassFactory* pComClsFac = (ComClassFactory*)pv;
    if (pClass != SystemDomain::GetDefaultComObject()->GetClass()) //HACK
    {
        pMT = pClass->GetMethodTable();
        _ASSERTE(pMT->IsComObjectType());
        _ASSERTE(pComClsFac == NULL);
        hr = ComClassFactory::GetComClassFactory(pMT, &pComClsFac);
    }
    else
    {
        pClass = NULL;
        _ASSERTE(pComClsFac != NULL);
    }
    if(pComClsFac == NULL)
    {
        _ASSERTE(FAILED(hr));
        COMPlusThrowHR(hr);
    }
    return pComClsFac->CreateInstance(pMT);
}


//-------------------------------------------------------------
// ComClassFactory::Cleanup(LPVOID pv)
//static 
void ComClassFactory::Cleanup(LPVOID pv)
{
    ComClassFactory *pclsFac = (ComClassFactory *)pv;
    if (pclsFac == NULL)
        return;

    if (pclsFac->m_bManagedVersion)
        return;
    
    if (pclsFac->m_pwszProgID != NULL)
    {
        delete [] pclsFac->m_pwszProgID;
    }

    if (pclsFac->m_pwszServer != NULL)
    {
        delete [] pclsFac->m_pwszServer;
    }

    delete pclsFac;
}


//-------------------------------------------------------------
// HRESULT ComClassFactory::GetComClassFactory(MethodTable* pClassMT, ComClassFactory** ppComClsFac)
// check if a ComClassFactory has been setup for this class
// if not set one up
//static 
HRESULT ComClassFactory::GetComClassFactory(MethodTable* pClassMT, ComClassFactory** ppComClsFac)
{
    HRESULT hr = S_OK;
    _ASSERTE(pClassMT != NULL);
    // assert the class represents a ComObject
    _ASSERTE(pClassMT->IsComObjectType());

    // EEClass
    EEClass* pClass = pClassMT->GetClass();
    _ASSERTE(pClass != NULL);

    while (!pClass->IsComImport())
    {
        pClass = pClass->GetParentClass();
        _ASSERTE(pClass != NULL);
         _ASSERTE(pClass->GetMethodTable()->IsComObjectType());      
    }

    // check if com data has been setup for this class
    ComClassFactory* pComClsFac = (ComClassFactory*)pClass->GetComClassFactory();

    if (pComClsFac == NULL)
    {
        ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();        
        
        //lock and see if somebody beat us to it            
        pCache->LOCK();

        pComClsFac = (ComClassFactory*)pClass->GetComClassFactory();
        if (pComClsFac == NULL)
        {
            GUID guid;
            pClass->GetGuid(&guid, TRUE);
            pComClsFac = new ComClassFactory(guid);
            if (pComClsFac != NULL)
            {
                pComClsFac->Init(NULL, NULL, pClassMT);
                // store the class factory in EE Class
                pClass->SetComClassFactory(pComClsFac);                
            }                       
        }
        pCache->UNLOCK();
    }

    _ASSERTE(ppComClsFac != NULL);
    *ppComClsFac = pComClsFac;
    return hr;
}

// OBJECTREF AllocateComClassObject(ComClassFactory* pComClsFac)
void AllocateComClassObject(ComClassFactory* pComClsFac, OBJECTREF* pComObj);
void AllocateComClassObject(ReflectClass* pRef, OBJECTREF* pComObj);

// Helper function to allocate a ComClassFactory. This is only here because we can't
// new a ComClassFactory in GetComClassFromProgID() because it uses SEH.
// !!! This API should only be called by GetComClassFromProgID
// !!! or GetComClassFromCLSID
ComClassFactory *ComClassFactory::AllocateComClassFactory(REFCLSID rclsid)
{
    // We create on Reflection Loader Heap.
    // We will not do clean up for this ComClassFactory.
    BYTE* pBuf = (BYTE*) GetAppDomain()->GetLowFrequencyHeap()->AllocMem(sizeof(ComClassFactory));
    if (!pBuf)
        return NULL;
    
    ComClassFactory *pComClsFac = new (pBuf) ComClassFactory(rclsid);
    if (pComClsFac)
        pComClsFac->SetManagedVersion();
    return pComClsFac;
}

void ComClassFactory::GetComClassHelper (OBJECTREF *pRef, EEClassFactoryInfoHashTable *pClassFactHash, ClassFactoryInfo *pClassFactInfo, WCHAR *wszProgID)
{
    THROWSCOMPLUSEXCEPTION();
    
    OBJECTHANDLE hRef;
    AppDomain *pDomain = GetAppDomain();
    
    CLR_CRST_HOLDER (holder, pDomain->GetRefClassFactCrst());

    BEGIN_ENSURE_PREEMPTIVE_GC();
    holder.Enter();
    END_ENSURE_PREEMPTIVE_GC();
        
    // Check again.
    if (pClassFactHash->GetValue(pClassFactInfo, (HashDatum *)&hRef))
    {
        *pRef = ObjectFromHandle(hRef);
    }
    else
    {

        //
        // There is no COM+ class for this CLSID
        // so we will create a ComClassFactory to
        // represent it.
        //

        ComClassFactory *pComClsFac = AllocateComClassFactory(pClassFactInfo->m_clsid);
        if (pComClsFac == NULL)
            COMPlusThrowOM();

        WCHAR *wszRefProgID = NULL;
        if (wszProgID) {
            wszRefProgID =
                (WCHAR*) pDomain->GetLowFrequencyHeap()->AllocMem((wcslen(wszProgID)+1) * sizeof (WCHAR));
            if (wszRefProgID == NULL)
                COMPlusThrowOM();
            wcscpy (wszRefProgID, wszProgID);
        }
        
        WCHAR *wszRefServer = NULL;
        if (pClassFactInfo->m_strServerName)
        {
            wszRefServer =
                (WCHAR*) pDomain->GetLowFrequencyHeap()->AllocMem((wcslen(pClassFactInfo->m_strServerName)+1) * sizeof (WCHAR));
            if (wszRefServer == NULL)
                COMPlusThrowOM();
            wcscpy (wszRefServer, pClassFactInfo->m_strServerName);
        }

        pComClsFac->Init(wszRefProgID, wszRefServer, NULL);
        AllocateComClassObject(pComClsFac, pRef);

        // Insert to hash.
        hRef = pDomain->CreateHandle(*pRef);
        pClassFactHash->InsertValue(pClassFactInfo, (LPVOID)hRef);
        // Make sure the hash code is working.
        _ASSERTE (pClassFactHash->GetValue(pClassFactInfo, (HashDatum *)&hRef));
    }
}


//-------------------------------------------------------------
// ComClassFactory::GetComClassFromProgID, 
// returns a ComClass reflect class that wraps the IClassFactory
void __stdcall ComClassFactory::GetComClassFromProgID(STRINGREF srefProgID, STRINGREF srefServer, OBJECTREF *pRef)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(srefProgID);
    _ASSERTE(pRef);
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    HRESULT hr = S_OK;
    WCHAR *wszProgID = NULL;
    WCHAR *wszServer = NULL;
    ComClassFactory *pComClsFac = NULL;
    EEClass* pClass = NULL;
    CLSID clsid = {0};
    Thread* pThread = GetThread();
    BOOL bServerIsLocal = (srefServer == NULL);

    EE_TRY_FOR_FINALLY
    {
        //
        // Allocate strings for the ProgID and the server.
        //

        int len = srefProgID->GetStringLength();

        wszProgID = new WCHAR[len+1];
        if (wszProgID == NULL)
            COMPlusThrowOM();

        memcpy(wszProgID, srefProgID->GetBuffer(), (len*2));
        wszProgID[len] = L'\0';

        if (srefServer != NULL)
        {
            len = srefServer->GetStringLength();

            wszServer = new WCHAR[len+1];
            if (wszServer == NULL)
                COMPlusThrowOM();

            if (len)
                memcpy(wszServer, srefServer->GetBuffer(), (len*2));
            wszServer[len] = L'\0';
        }


        //
        // Call GetCLSIDFromProgID() to convert the ProgID to a CLSID.
        //
    
        pThread->EnablePreemptiveGC();

        hr = QuickCOMStartup();
        if (SUCCEEDED(hr))
            hr = GetCLSIDFromProgID(wszProgID, &clsid);

        pThread->DisablePreemptiveGC();

        if (FAILED(hr))
            COMPlusThrowHR(hr);


        //
        // If no server name has been specified, see if we can find the well known 
        // COM+ class for this CLSID.
        //

        if (bServerIsLocal)
        {
            BOOL fAssemblyInReg = FALSE;
            // @TODO(DM): Do we really need to be this forgiving ? We should
            //            look into letting the type load exceptions percolate 
            //            up to the user instead of swallowing them and using __ComObject.
            COMPLUS_TRY
            {                
                pClass = GetEEClassForCLSID(clsid, &fAssemblyInReg);
            }
            COMPLUS_CATCH
            {
                // actually there was an assembly in the registry which we couldn't 
                // load, so rethrow the exception
                /*if (fAssemblyInReg)
                    COMPlusRareRethrow();*/
            }
            COMPLUS_END_CATCH
        }
        
        if (pClass != NULL)
        {               
            //
            // There is a COM+ class for this ProgID.
            //

            *pRef = pClass->GetExposedClassObject();
        }
        else
        {
            // Check if we have in the hash.
            OBJECTHANDLE hRef;
            ClassFactoryInfo ClassFactInfo;
            ClassFactInfo.m_clsid = clsid;
            ClassFactInfo.m_strServerName = wszServer;
            SystemDomain::EnsureComObjectInitialized();
            EEClassFactoryInfoHashTable *pClassFactHash = GetAppDomain()->GetClassFactHash();
            if (pClassFactHash->GetValue(&ClassFactInfo, (HashDatum *)&hRef))
            {
                *pRef = ObjectFromHandle(hRef);
            }
            else
            {
                GetComClassHelper (pRef, pClassFactHash, &ClassFactInfo, wszProgID);
            }
        }

        // If we made it this far *pRef better be set.
        _ASSERTE(*pRef != NULL);
    }
    EE_FINALLY
    {
        if (wszProgID)
            delete [] wszProgID;
        if (wszServer)
            delete [] wszServer;
    }
    EE_END_FINALLY
}


//-------------------------------------------------------------
// ComClassFactory::GetComClassFromCLSID, 
// returns a ComClass reflect class that wraps the IClassFactory
void __stdcall ComClassFactory::GetComClassFromCLSID(REFCLSID clsid, STRINGREF srefServer, OBJECTREF *pRef)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pRef);
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    HRESULT hr = S_OK;
    ComClassFactory *pComClsFac = NULL;
    EEClass* pClass = NULL;
    WCHAR *wszServer = NULL;
    BOOL bServerIsLocal = (srefServer == NULL);

    EE_TRY_FOR_FINALLY
    {
        //
        // Allocate strings for the server.
        //

        if (srefServer != NULL)
        {
            int len = srefServer->GetStringLength();

            wszServer = new WCHAR[len+1];
            if (wszServer == NULL)
                COMPlusThrowOM();

            if (len)
                memcpy(wszServer, srefServer->GetBuffer(), (len*2));
            wszServer[len] = L'\0';
        }


        //
        // If no server name has been specified, see if we can find the well known 
        // COM+ class for this CLSID.
        //

        if (bServerIsLocal)
        {
            // @TODO(DM): Do we really need to be this forgiving ? We should
            //            look into letting the type load exceptions percolate 
            //            up to the user instead of swallowing them and using __ComObject.
            COMPLUS_TRY
            {
                pClass = GetEEClassForCLSID(clsid);
            }
            COMPLUS_CATCH
            {
            }
            COMPLUS_END_CATCH
        }
              
        if (pClass != NULL)
        {               
            //
            // There is a COM+ class for this CLSID.
            //

            *pRef = pClass->GetExposedClassObject();
        }
        else
        {
            // Check if we have in the hash.
            OBJECTHANDLE hRef;
            ClassFactoryInfo ClassFactInfo;
            ClassFactInfo.m_clsid = clsid;
            ClassFactInfo.m_strServerName = wszServer;
            SystemDomain::EnsureComObjectInitialized();
            EEClassFactoryInfoHashTable *pClassFactHash = GetAppDomain()->GetClassFactHash();
            if (pClassFactHash->GetValue(&ClassFactInfo, (HashDatum*) &hRef))
            {
                *pRef = ObjectFromHandle(hRef);
            }
            else
            {
                GetComClassHelper (pRef, pClassFactHash, &ClassFactInfo, NULL);
            }
        }

        // If we made it this far *pRef better be set.
        _ASSERTE(*pRef != NULL);
    }
    EE_FINALLY
    {
        if (wszServer)
            delete [] wszServer;
    }
    EE_END_FINALLY
}


//-------------------------------------------------------------
// Helper method to throw an exception based on the returned 
// HRESULT from a call to create a COM object.
void ComClassFactory::ThrowComCreationException(HRESULT hr, REFGUID rclsid)
{
    THROWSCOMPLUSEXCEPTION();

    LPWSTR strClsid = NULL;

    EE_TRY_FOR_FINALLY
    {
        if (hr == REGDB_E_CLASSNOTREG)
        {
            StringFromCLSID(rclsid, &strClsid);
            COMPlusThrowHR(hr, IDS_EE_COM_COMPONENT_NOT_REG, strClsid, NULL);
        }
        else
        {
            COMPlusThrowHR(hr);
        }
    }
    EE_FINALLY
    {
        if (strClsid)
            CoTaskMemFree(strClsid);
    }
    EE_END_FINALLY
}

void ComPlusWrapper::ValidateWrapper()
{
    BEGIN_ENSURE_COOPERATIVE_GC()
    {

        OBJECTREF oref = GetExposedObject();
        if (oref == NULL)
        {
            FreeBuildDebugBreak();
        }
        SyncBlock* pBlock = oref->GetSyncBlockSpecial();
        if(pBlock == NULL)
        {
            FreeBuildDebugBreak();
        }

        ComPlusWrapper* pWrap = pBlock->GetComPlusWrapper();
        if (pWrap != this)
        {
            FreeBuildDebugBreak();
        }     
    }
    END_ENSURE_COOPERATIVE_GC()
}

//---------------------------------------------------------------------
// ComPlusWrapper cache, act as the manager for the ComPlusWrappers
// uses a hash table to map IUnknown to the corresponding wrappers
//---------------------------------------------------------------------

// Obtain the appropriate wrapper cache from the current context.
ComPlusWrapperCache *ComPlusWrapperCache::GetComPlusWrapperCache()
{
    Context     *curCtx = GetCurrentContext();

    return curCtx ? curCtx->GetComPlusWrapperCache() : NULL;
}

//---------------------------------------------------------------------
// Constructor.  Note we init the global RCW cleanup list in here too.
ComPlusWrapperCache::ComPlusWrapperCache(AppDomain *pDomain)
{
    m_cbRef = 1; // never goes away
    m_lock.Init(LOCK_PLUSWRAPPER_CACHE);
    LockOwner lock = {&m_lock, IsOwnerOfSpinLock};
    m_HashMap.Init(0,ComPlusWrapperCompare,false,&lock);
    m_pDomain = pDomain;
}

//--------------------------------------------------------------------------------
// ComPlusWrapper* ComPlusWrapperCache::SetupComPlusWrapperForRemoteObject(IUnknown* pUnk, OBJECTREF oref)
// DCOM interop, setup a COMplus wrapper for a managed object that has been remoted
//
//*** NOTE: make sure to pass the identity unknown to this function
// the IUnk passed in shouldn't be AddRef'ed 
ComPlusWrapper* ComPlusWrapperCache::SetupComPlusWrapperForRemoteObject(IUnknown* pUnk, OBJECTREF oref)
{
    _ASSERTE(pUnk != NULL);
    _ASSERTE(oref != NULL);
    ComPlusWrapper* pPlusWrap = NULL;

    OBJECTREF oref2 = oref;
    GCPROTECT_BEGIN(oref2)
    {
        // check to see if a complus wrapper already exists
        // otherwise setup one          
        ComCallWrapper* pComCallWrap = ComCallWrapper::InlineGetWrapper(&oref2);

        pPlusWrap = pComCallWrap->GetComPlusWrapper();

        if (pPlusWrap == NULL)
        {       
            pPlusWrap = CreateComPlusWrapper(pUnk, pUnk);
            pPlusWrap->MarkRemoteObject();
            
            if (pPlusWrap->Init(oref2))
            {   
                // synchronized to check see if somebody beat us to it
                LOCK();
                ComPlusWrapper* pPlusWrap2 = pComCallWrap->GetComPlusWrapper();
                if (pPlusWrap2 == NULL)
                {
                    // didn't find an existing wrapper
                    // use this one
                    pComCallWrap->SetComPlusWrapper(pPlusWrap);
                }
                UNLOCK();

                if (pPlusWrap2 == NULL)
                {
                    // didn't find an existing wrapper
                    // so insert our wrapper
                    // NOTE: rajak
                    // make sure we are in the right GC mode
                    // as during GC we touch the Hash table 
                    // to remove entries with out locking
                    _ASSERTE(GetThread()->PreemptiveGCDisabled());
                    
                    LOCK();                    
                    InsertWrapper(pUnk,pPlusWrap);
                    UNLOCK();

                    
                }
                else // already found an existing wrapper
                {
                    // get rid of our current wrapper
                    pPlusWrap->CleanupRelease();
                    pPlusWrap = pPlusWrap2;
                }               
            }
            else // Init Failed
            {
                // get rid of our current wrapper
                pPlusWrap->CleanupRelease();                
                pPlusWrap = NULL;
            }

        }
    }
    GCPROTECT_END();
    return pPlusWrap;
}



//--------------------------------------------------------------------------------
// ComPlusWrapper*  ComPlusWrapperCache::FindWrapperInCache(IUnknown* pIdentity)
//  Lookup to see if we already have an valid wrapper in cache for this IUnk
ComPlusWrapper*  ComPlusWrapperCache::FindWrapperInCache(IUnknown* pIdentity)
{
    _ASSERTE(pIdentity != NULL);

    // make sure this runs with GC disabled
    Thread* pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    #ifdef _DEBUG
    // don't allow any GC
    pThread->BeginForbidGC();
    #endif  

    ComPlusWrapper *pWrap = NULL;        

    LOCK(); // take a lock

    // lookup in our hash table
    pWrap = (ComPlusWrapper*)LookupWrapper(pIdentity);    

    // check if we found the wrapper, 
    if (pWrap != NULL && pWrap->IsValid())
    {               
        // found a wrapper, 
        // grab the object into a GC protected ref
        OBJECTREF oref = (OBJECTREF)pWrap->GetExposedObject();
        _ASSERTE(oref != NULL);
        // addref the wrapper
        pWrap->AddRef();
    }

    UNLOCK(); // unlock

    #ifdef _DEBUG
        // end forbid GC
        pThread->EndForbidGC();
    #endif

    return pWrap;
}

//--------------------------------------------------------------------------------
// ComPlusWrapper* ComPlusWrapperCache::FindOrInsertWrapper(IUnknown* pIdentity, ComPlusWrapper* pWrap)
//  Lookup to see if we already have a wrapper else insert this wrapper
//  return a valid wrapper that has been inserted into the cache
ComPlusWrapper* ComPlusWrapperCache::FindOrInsertWrapper(IUnknown* pIdentity, ComPlusWrapper* pWrap)
{
    _ASSERTE(pIdentity != NULL);
    _ASSERTE(pIdentity != (IUnknown*)-1);
    _ASSERTE(pWrap != NULL);

    ComPlusWrapper* pWrap2 = NULL;
    ComPlusWrapper* pWrapToRelease = NULL;

    // we have created a wrapper, let us insert it into the hash table
    // but we need to check if somebody beat us to it

    // make sure this runs with GC disabled
    Thread* pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());  
    
    LOCK();
    
    // see if somebody beat us to it    
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    
    #ifdef _DEBUG
        // don't allow any GC
        pThread->BeginForbidGC();
    #endif
    
    pWrap2 = (ComPlusWrapper*)LookupWrapper(pIdentity);

    // if we didn't find a valid wrapper, Insert our own wrapper
    if (pWrap2 == NULL || !pWrap2->IsValid())
    {
        // if we found a bogus wrapper, let us get rid of it
        // so that when we insert we insert a valid wrapper, instead of duplicate
        if (pWrap2 != NULL)
        {
            _ASSERTE(!pWrap2->IsValid());
            RemoveWrapper(pWrap2);
        }

        InsertWrapper(pIdentity,pWrap);        
    }
    else
    {       
        _ASSERTE(pWrap2 != NULL && pWrap2->IsValid());
        // okay we found a valid wrapper, 
        // get the object into a GC protected ref
               
        //addref the wrapper
         pWrap2->AddRef();
         
        // Remember to release this wrapper.
        pWrapToRelease = pWrap;

        // and use the wrapper we found in the hash table
        pWrap = pWrap2;
    }

    #ifdef _DEBUG
        // end forbid GC
        pThread->EndForbidGC();
    #endif

    UNLOCK();
    
    // get rid of our current wrapper
    if (pWrapToRelease)
    {
        OBJECTREF oref = NULL;
        GCPROTECT_BEGIN(oref)
        {
            if (pWrap)
            {
                // protect the exposed object, as pWrap only
                // has a weak handle to this object
                // and cleanup release will enable GC
                oref = (OBJECTREF)pWrap->GetExposedObject();
            }
            pWrapToRelease->CleanupRelease();
        }        
        GCPROTECT_END();
    }       
    return pWrap;
}

//--------------------------------------------------------------------------------
// ComPlusWrapper* ComPlusWrapperCache::CreateComPlusWrapper(IUnknown *pUnk, LPVOID pIdentity)
//  returns NULL for out of memory scenarios
// The IUnknown passed in is AddRef'ed if we succeed in creating the wrapper
ComPlusWrapper* ComPlusWrapperCache::CreateComPlusWrapper(IUnknown *pUnk, LPVOID pIdentity)
{
    _ASSERTE(pUnk != NULL);

    // now allocate the wrapper
    ComPlusWrapper* pWrap = new ComPlusWrapper();
    if (pWrap != NULL)
    {
        ULONG cbRef = SafeAddRef(pUnk);
        LogInteropAddRef(pUnk, cbRef, "Initialize wrapper");
        // Initialize wrapper with the interface pointer
        pWrap->Init(pUnk, pIdentity);
    }

    // return pWrap 
    return pWrap;
}

//--------------------------------------------------------------------------------
// ULONG ComPlusWrapperCache::ReleaseWrappers()
// Helper to release the complus wrappers in the cache that live in the specified
// context or all the wrappers if the pCtxCookie is null.
ULONG ComPlusWrapperCache::ReleaseWrappers(LPVOID pCtxCookie)
{
    ULONG cbCount = 0;
    ComPlusWrapperCleanupList CleanupList;
    ComPlusWrapperCleanupList AggregatedCleanupList;
    if (!CleanupList.Init() || !AggregatedCleanupList.Init())
        return 0;

    Thread* pThread = GetThread();
    _ASSERTE(pThread);

    // Switch to cooperative GC mode before we take the lock.
    int fNOTGCDisabled = !pThread->PreemptiveGCDisabled();
    if (fNOTGCDisabled)
        pThread->DisablePreemptiveGC();

    LOCK();

    // Go through the hash table and add the wrappers to the cleanup lists.
    for (PtrHashMap::PtrIterator iter = m_HashMap.begin(); !iter.end(); ++iter)
    {
        LPVOID val = iter.GetValue();
        _ASSERTE(val && ((UPTR)val) != INVALIDENTRY);
        ComPlusWrapper* pWrap = (ComPlusWrapper*)val;
        _ASSERTE(pWrap != NULL);

        // If a context cookie was specified, then only clean up wrappers that
        // are in that context. Otherwise clean up all the wrappers.
        if (!pCtxCookie || pWrap->GetWrapperCtxCookie() == pCtxCookie)
        {
            cbCount++;
            pWrap->FreeHandle();                
            RemoveWrapper(pWrap);

            if (!pWrap->IsURTAggregated())
            {                 
                CleanupList.AddWrapper(pWrap);
            }
            else
            {
                AggregatedCleanupList.AddWrapper(pWrap);
            }
        }
    }

    UNLOCK();

    // Clean up the non URT aggregated RCW's first then clean up the URT aggregated RCW's.
    CleanupList.CleanUpWrappers();
    AggregatedCleanupList.CleanUpWrappers();

    // Restore the GC mode.
    if (fNOTGCDisabled)
        pThread->EnablePreemptiveGC();

    return cbCount;
}

//--------------------------------------------------------------------------------
// void ComPlusWrapperCache::ReleaseComPlusWrappers(LPVOID pCtxCookie)
//  Helper to release the all complus wrappers in the specified context. Or in
//  all the contexts if pCtxCookie is null.
void ComPlusWrapperCache::ReleaseComPlusWrappers(LPVOID pCtxCookie)
{
    // Go through all the app domains and for each one release all the 
    // RCW's that live in the current context.
    AppDomainIterator i;
    while (i.Next())
        i.GetDomain()->ReleaseComPlusWrapper(pCtxCookie);

    if (!g_fEEShutDown)
    {
        Thread* pThread = GetThread();
        // Switch to cooperative GC mode 
        int fNOTGCDisabled = pThread && !pThread->PreemptiveGCDisabled();
        if (fNOTGCDisabled)
            pThread->DisablePreemptiveGC();
        {
            // If the finalizer thread has sync blocks to clean up or if it is in the process
            // of cleaning up the sync blocks, we need to wait for it to finish.
            if (g_pGCHeap->GetFinalizerThread()->RequireSyncBlockCleanup() || SyncBlockCache::GetSyncBlockCache()->IsSyncBlockCleanupInProgress())
                g_pGCHeap->FinalizerThreadWait();

            // If more sync blocks were added while the finalizer thread was calling the finalizers
            // or while it was transitioning into a context to clean up the IP's, we need to wake
            // it up again to have it clean up the newly added sync blocks.
            if (g_pGCHeap->GetFinalizerThread()->RequireSyncBlockCleanup() || SyncBlockCache::GetSyncBlockCache()->IsSyncBlockCleanupInProgress())
                g_pGCHeap->FinalizerThreadWait();
        }
          // Restore the GC mode.
        if (fNOTGCDisabled)            
            pThread->EnablePreemptiveGC();
    }
}

//--------------------------------------------------------------------------------
// Constructor.
ComPlusWrapperCleanupList::ComPlusWrapperCleanupList()
  : m_lock("ComPlusWrapperCleanupList", CrstSyncHashLock, FALSE, FALSE),
    m_pMTACleanupGroup(NULL),
    m_doCleanupInContexts(FALSE),
    m_currentCleanupSTAThread(NULL)
{
}

//--------------------------------------------------------------------------------
// Destructor.
ComPlusWrapperCleanupList::~ComPlusWrapperCleanupList()
{
    _ASSERTE(m_STAThreadToApartmentCleanupGroupMap.IsEmpty());
    if (m_pMTACleanupGroup != NULL)
        delete m_pMTACleanupGroup;
}


//--------------------------------------------------------------------------------
// Adds an RCW to the clean up list.
BOOL ComPlusWrapperCleanupList::AddWrapper(ComPlusWrapper *pRCW)
{
    CtxEntry *pCtxEntry = pRCW->GetWrapperCtxEntry();
    ComPlusApartmentCleanupGroup *pCleanupGroup;

    // For the global cleanup list, this is called only from the finalizer thread
    _ASSERTE(this != g_pRCWCleanupList
             || GetThread() == GCHeap::GetFinalizerThread());

    // Take the lock.  This protects against concurrent calls to CleanUpCurrentCtxWrappers.
    CLR_CRST(&m_lock);

    if (pCtxEntry->GetSTAThread() == NULL)
        pCleanupGroup = m_pMTACleanupGroup;
    else
    {
        // Lookup in the hashtable to find a clean up group that matches the wrapper's STA.
        if (!m_STAThreadToApartmentCleanupGroupMap.GetValue(pCtxEntry->GetSTAThread(), 
                                                            (HashDatum *)&pCleanupGroup))
        {
            // No group exists yet, so allocate a new one.
            pCleanupGroup = new (nothrow) ComPlusApartmentCleanupGroup(pCtxEntry->GetSTAThread());
            if (!pCleanupGroup)
            {
                pCtxEntry->Release();
                return FALSE;
            }

            // Insert the new group into the hash table.
            if (!pCleanupGroup->Init(NULL)
                || !m_STAThreadToApartmentCleanupGroupMap.InsertValue(pCtxEntry->GetSTAThread(), 
                                                                      pCleanupGroup))
            {
                pCtxEntry->Release();
                delete pCleanupGroup;
                return FALSE;
            }
        }
    }

    // Insert the wrapper into the clean up group.
    pCleanupGroup->AddWrapper(pRCW, pCtxEntry);

    // The wrapper was assed successfully.
    pCtxEntry->Release();

    return TRUE;
}

//--------------------------------------------------------------------------------
// Cleans up all the wrappers in the clean up list.
void ComPlusWrapperCleanupList::CleanUpWrappers()
{
    LOG((LF_INTEROP, LL_INFO10000, "Finalizer thread %p: CleanUpWrappers().\n", GetThread()));

    EEHashTableIteration Iter;
    ComPlusApartmentCleanupGroup *pCleanupGroup;
    Thread *pSTAThread;

    // For the global cleanup list, this is called only from the finalizer thread
    _ASSERTE(this != g_pRCWCleanupList
             || GetThread() == GCHeap::GetFinalizerThread());

    // Request help from other threads
    m_doCleanupInContexts = TRUE;

    // Take the lock.  This protects against concurrent calls to CleanUpCurrentCtxWrappers.
    CLR_CRST_HOLDER(holder, &m_lock);
    holder.Enter();

    // First, clean up the MTA group.

    m_pMTACleanupGroup->CleanUpWrappers(&holder);

    // Now clean up all of the STA groups.

    m_STAThreadToApartmentCleanupGroupMap.IterateStart(&Iter);
    while (m_STAThreadToApartmentCleanupGroupMap.IterateNext(&Iter))
    {
        // Get the first clean up group.
        pCleanupGroup = (ComPlusApartmentCleanupGroup *)m_STAThreadToApartmentCleanupGroupMap.IterateGetValue(&Iter);
        pSTAThread = (Thread *) m_STAThreadToApartmentCleanupGroupMap.IterateGetKey(&Iter);

        // Remove the previous group from the hash table.
        m_STAThreadToApartmentCleanupGroupMap.DeleteValue(pSTAThread);

        // Advertise the STA we are trying to enter, so a thread in that STA
        // can yield to us if necessary
        m_currentCleanupSTAThread = pSTAThread;

        LOG((LF_INTEROP, LL_INFO10000, 
             "Finalizer thread %p: Cleaning up STA %p.\n", 
             GetThread(), m_currentCleanupSTAThread));

        // Release the lock, so other threads can cooperate with cleanup and release
        // the group of their current context.  Note that these threads will not alter 
        // the entries in the hash table so our iteration state should be OK.
        holder.Leave();

        // Release the previous clean up group.
        pCleanupGroup->CleanUpWrappers(NULL);

        delete pCleanupGroup;

            // Retake the lock
        holder.Enter();

        LOG((LF_INTEROP, LL_INFO10000, 
             "Finalizer thread %p: Done cleaning up STA %p.\n", 
             GetThread(), m_currentCleanupSTAThread));

        // Reset the context we are trying to enter.
        m_currentCleanupSTAThread = NULL;

        // Just reset the iteration, since we've deleted the current (first) element
        m_STAThreadToApartmentCleanupGroupMap.IterateStart(&Iter);
    }

    // No more stuff for other threads to help with
    m_doCleanupInContexts = FALSE;

    _ASSERTE(m_STAThreadToApartmentCleanupGroupMap.IsEmpty());
}

//--------------------------------------------------------------------------------
// Extract any wrappers to cleanup for the given group
void ComPlusWrapperCleanupList::CleanUpCurrentWrappers(BOOL wait)
{
    // Shortcut to avoid taking the lock most of the time.
    if (!m_doCleanupInContexts)
        return;

    // Note that we cannot concurrently do a GetValue since the finalize thread is
    // calling ClearHashTable. So take the lock now.
    CLR_CRST_HOLDER(holder, &m_lock);

    // Find out our STA (if any)
    Thread *pThread = GetThread();
    if (pThread->GetApartment() != Thread::AS_InSTA)
    {
        // If we're in an MTA, just look for a matching context.
        holder.Enter();  
        m_pMTACleanupGroup->CleanUpCurrentCtxWrappers(&holder);
    }
    else
    {
        // See if we have any wrappers to cleanup for our apartment
        holder.Enter();  
        ComPlusApartmentCleanupGroup *pCleanupGroup;
        if (m_STAThreadToApartmentCleanupGroupMap.GetValue(pThread, (HashDatum *)&pCleanupGroup))
        {
            // Since we're in an STA, we will go ahead and clean up all wrappers
            // in all contexts for that apartment.
            
            m_STAThreadToApartmentCleanupGroupMap.DeleteValue(pThread);

            LOG((LF_INTEROP, LL_INFO1000, "Thread %p: Cleaning up my STA.\n", GetThread()));

            // Release the lock now since the hash table is coherent
            holder.Leave();

            pCleanupGroup->CleanUpWrappers(NULL);

            delete pCleanupGroup;
        }
        else if (wait && m_currentCleanupSTAThread == pThread)
        {
            // No wrappers, but the finalizer thread may be trying to enter our STA - 
            // make sure it can get in.

            LOG((LF_INTEROP, LL_INFO1000, "Thread %p: Yielding to finalizer thread.\n", pThread));

            holder.Leave();

            // Do a noop wait just to make sure we are cooperating 
            // with the finalizer thread
            HANDLE h = pThread->GetThreadHandle();
            pThread->DoAppropriateAptStateWait(1, &h, FALSE, 1, TRUE);
        }
    }

    // Let the crst holder release the lock if we didn't already.
}

//--------------------------------------------------------------------------------
// Constructor.
ComPlusApartmentCleanupGroup::ComPlusApartmentCleanupGroup(Thread *pSTAThread)
  : m_pSTAThread(pSTAThread)
{
}

//--------------------------------------------------------------------------------
// Destructor.
ComPlusApartmentCleanupGroup::~ComPlusApartmentCleanupGroup()
{
    _ASSERTE(m_CtxCookieToContextCleanupGroupMap.IsEmpty());
}


//--------------------------------------------------------------------------------
// Adds an RCW to the clean up list.
BOOL ComPlusApartmentCleanupGroup::AddWrapper(ComPlusWrapper *pRCW, CtxEntry *pCtxEntry)
{
    ComPlusContextCleanupGroup *pCleanupGroup;

    // Lookup in the hashtable to find a clean up group that matches the wrappers STA.
    if (!m_CtxCookieToContextCleanupGroupMap.GetValue(pCtxEntry->GetCtxCookie(), 
                                                      (HashDatum *)&pCleanupGroup))
    {
        // No group exists yet, so allocate a new one.
        pCleanupGroup = new (nothrow) ComPlusContextCleanupGroup(pCtxEntry, NULL);
        if (!pCleanupGroup)
            return FALSE;

        // Insert the new group into the hash table.
        if (!m_CtxCookieToContextCleanupGroupMap.InsertValue(pCtxEntry->GetCtxCookie(), 
                                                             pCleanupGroup))
        {
            delete pCleanupGroup;
            return FALSE;
        }
    }

    // If the clean up group is full, then we need to allocate a new one and 
    // link the old one with it.
    if (pCleanupGroup->IsFull())
    {
        // Keep a pointer to the old clean up group.
        ComPlusContextCleanupGroup *pOldCleanupGroup = pCleanupGroup;

        // Allocate the new clean up group and link the old one with it.
        CtxEntry *pCtxEntry = pRCW->GetWrapperCtxEntry();
        pCleanupGroup = new (nothrow) ComPlusContextCleanupGroup(pCtxEntry, pOldCleanupGroup);
        pCtxEntry->Release();
        if (!pCleanupGroup)
            return FALSE;

        // Replace the value in the hashtable to point to the new head.
        m_CtxCookieToContextCleanupGroupMap.ReplaceValue(pCtxEntry->GetCtxCookie(), pCleanupGroup);
    }

    // Insert the wrapper into the clean up group.
    pCleanupGroup->AddWrapper(pRCW);

    // The wrapper was assed successfully.
    return TRUE;
}

//--------------------------------------------------------------------------------
// Cleans up all the wrappers in the clean up list.
void ComPlusApartmentCleanupGroup::CleanUpWrappers(CrstHolder *pHolder)
{
    EEHashTableIteration Iter;
    ComPlusContextCleanupGroup *pCleanupGroup;
    LPVOID pCtxCookie;

    m_CtxCookieToContextCleanupGroupMap.IterateStart(&Iter);
    while (m_CtxCookieToContextCleanupGroupMap.IterateNext(&Iter))
    {
        pCleanupGroup = (ComPlusContextCleanupGroup *)m_CtxCookieToContextCleanupGroupMap.IterateGetValue(&Iter);
        pCtxCookie = m_CtxCookieToContextCleanupGroupMap.IterateGetKey(&Iter);

        LOG((LF_INTEROP, LL_INFO100000, 
             "Thread %p: Cleaning up context %p.\n", GetThread(), pCtxCookie));

        // Release the previous clean up group.

        if (GetSTAThread() == NULL
            || GetSTAThread() == GetThread() 
            || pCtxCookie == GetCurrentCtxCookie())
        {
            // Delete the value since we will clean it up
            m_CtxCookieToContextCleanupGroupMap.DeleteValue(pCtxCookie);

                // Release the lock, so other threads can cooperate with cleanup and release
                // the group of their current context.  Note that these threads will not alter 
                // the entries in the hash table so our iteration state should be OK.
            if (pHolder != NULL)
                pHolder->Leave();

                // No need to switch apartments.
            ReleaseCleanupGroupCallback(pCleanupGroup);
        }
        else
        {
            // Switch to this context & continue the cleanup from there.  This will
            // mimimize cross-apartment calls.

            CtxEntry *pCtxEntry = pCleanupGroup->GetCtxEntry();

            // Shouldn't ever have a holder for STA's - if we did, we'd have no
            // convenient place to pass it down to the callback.
            _ASSERTE(pHolder == NULL);

            // Leave the group in the hash table so it will still get cleaned up
            // if we reenter CleanUpWrappers in the new apartment

            HRESULT hr = pCtxEntry->EnterContext(CleanUpWrappersCallback, this);
            if (hr == RPC_E_DISCONNECTED)
            {
                // Delete the value since we will clean it up
                m_CtxCookieToContextCleanupGroupMap.DeleteValue(pCtxCookie);

                    // The context is disconnected so we cannot transition into it to clean up.
                    // The only option we have left is to try and clean up the RCW's from the
                    // current context.
                ReleaseCleanupGroup(pCleanupGroup);
            }

            pCtxEntry->Release();
        }

        // Retake the lock while we continue iteration
        if (pHolder != NULL)
            pHolder->Enter();

        // Just restart iteration since we deleted the current (first) element
        m_CtxCookieToContextCleanupGroupMap.IterateStart(&Iter);
    }
}


//--------------------------------------------------------------------------------
// Callback called to release the clean up group and any other clean up groups 
// that it is linked to.
HRESULT ComPlusApartmentCleanupGroup::CleanUpWrappersCallback(LPVOID pData)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // If we are releasing our IP's as a result of shutdown, we MUST not transition
    // into cooperative GC mode. This "fix" will prevent us from doing so.
    if (g_fEEShutDown & ShutDown_Finalize2)
    {
        Thread *pThread = GetThread();
        if (pThread && !GCHeap::IsCurrentThreadFinalizer())
            pThread->SetThreadStateNC(Thread::TSNC_UnsafeSkipEnterCooperative);
    }

    ComPlusApartmentCleanupGroup *pCleanupGroup = (ComPlusApartmentCleanupGroup*)pData;

    pCleanupGroup->CleanUpWrappers(NULL);

    // Reset the bit indicating we cannot transition into cooperative GC mode.
    if (g_fEEShutDown & ShutDown_Finalize2)
    {
        Thread *pThread = GetThread();
        if (pThread && !GCHeap::IsCurrentThreadFinalizer())
            pThread->ResetThreadStateNC(Thread::TSNC_UnsafeSkipEnterCooperative);
    }

    return S_OK;
}

//--------------------------------------------------------------------------------
// Callback called to release the clean up group and any other clean up groups 
// that it is linked to.
HRESULT ComPlusApartmentCleanupGroup::ReleaseCleanupGroupCallback(LPVOID pData)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    ComPlusContextCleanupGroup *pCleanupGroup = (ComPlusContextCleanupGroup*)pData;

    LPVOID pCurrCtxCookie = GetCurrentCtxCookie();
    if (pCurrCtxCookie == NULL || pCurrCtxCookie == pCleanupGroup->GetCtxCookie())
    {
        ReleaseCleanupGroup(pCleanupGroup);
    }
    else
    {
        // Retrieve the addref'ed context entry that the wrapper lives in.
        CtxEntry *pCtxEntry = pCleanupGroup->GetCtxEntry();

        // Transition into the context to release the interfaces.
        HRESULT hr = pCtxEntry->EnterContext(ReleaseCleanupGroupCallback, pCleanupGroup);
        if (hr == RPC_E_DISCONNECTED)
        {
            // The context is disconnected so we cannot transition into it to clean up.
            // The only option we have left is to try and clean up the RCW's from the
            // current context.
            ReleaseCleanupGroup(pCleanupGroup);
        }

        // Release the ref count on the CtxEntry.
        pCtxEntry->Release();
    }

    return S_OK;
}

//--------------------------------------------------------------------------------
// Extract any wrappers to cleanup for the given group
void ComPlusApartmentCleanupGroup::CleanUpCurrentCtxWrappers(CrstHolder *pHolder)
{
    LPVOID pCurrCtxCookie = GetCurrentCtxCookie();

    // See if we have any wrappers to cleanup for our context/apartment
    ComPlusContextCleanupGroup *pCleanupGroup;
    if (m_CtxCookieToContextCleanupGroupMap.GetValue(pCurrCtxCookie, (HashDatum *)&pCleanupGroup))
    {
        m_CtxCookieToContextCleanupGroupMap.DeleteValue(pCurrCtxCookie);

        LOG((LF_INTEROP, LL_INFO10000, 
             "Thread %p: Clean up context %p.\n", GetThread(), pCurrCtxCookie));

        // Release the lock now since the hash table is coherent
        pHolder->Leave();

        ReleaseCleanupGroup(pCleanupGroup);

    }
}

//--------------------------------------------------------------------------------
// Releases and deletes the clean up group and any other clean up groups that it 
// is linked to.
void ComPlusApartmentCleanupGroup::ReleaseCleanupGroup(ComPlusContextCleanupGroup *pCleanupGroup)
{
    do
    {
        // Clean up all the wrappers in the clean up group.
        pCleanupGroup->CleanUpWrappers();

        // Save the pointer to the clean up group.
        ComPlusContextCleanupGroup *pOldCleanupGroup = pCleanupGroup;

        // Retrieve the pointer to the next linked clean up group.
        pCleanupGroup = pOldCleanupGroup->GetNext();

        // Delete the old clean up group.
        delete pOldCleanupGroup;
    } 
    while (pCleanupGroup != NULL);
}

//--------------------------------------------------------------------------------
// LONG ComPlusWrapper::AddRef()
// Addref is called only from within the runtime, when we lookup a wrapper in our hash
// table 
LONG ComPlusWrapper::AddRef()
{
    // assert we are holding a lock
    _ASSERTE(ComPlusWrapperCache::GetComPlusWrapperCache()->LOCKHELD());

    LONG cbRef = ++m_cbRefCount;
    return cbRef;
}

//--------------------------------------------------------------------------------
// LONG ComPlusWrapper::ExternalRelease()
// Release, is called only for Explicit calls from the user code
// so we need to use InterlockedIncrement
// also the ref-count should never go below zero, which would be a bug in
// the user code.
LONG ComPlusWrapper::ExternalRelease(COMOBJECTREF cref)
{
    LONG cbRef = -1;
    BOOL fCleanupWrapper = FALSE;

     // Lock
    ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();
    _ASSERTE(pCache);
    pCache->LOCK(); //lock    

    // now to see if the wrapper is valid
    // if there is another ReleaseComObject on this object
    // of if an STA thread death decides to cleanup this wrapper
    // then the object will be disconnected from the wrapper
    ComPlusWrapper* pWrap = cref->GetWrapper();
    if (pWrap != NULL)
    {       
        // check for invalid case
        if ((LONG)pWrap->m_cbRefCount > 0)
        {   
            cbRef = --(pWrap->m_cbRefCount);
            if (cbRef == 0)
            {       
                // remove wrapper from the hash table
                // NOTE: rajak
                // make sure we are in the right GC mode
                // as during GC we touch the Hash table 
                // to remove entries without locking
                _ASSERTE(GetThread()->PreemptiveGCDisabled());
                pCache->RemoveWrapper(pWrap);        
                fCleanupWrapper = TRUE;
            }
        }
    }
    
    pCache->UNLOCK(); // unlock

    // do cleanup after releasing the lock
    if (fCleanupWrapper)
    {
        _ASSERTE(pWrap);

        // Release all the data associated with the __ComObject.
        ComObject::ReleaseAllData(pWrap->GetExposedObject());

        pWrap->FreeHandle();
        pWrap->Cleanup();
    }

    return cbRef;
}

//--------------------------------------------------------------------------------
// void ComPlusWrapper::CleanupRelease()
// Cleanup free all interface pointers
// release on dummy wrappers, that we create during contention
VOID ComPlusWrapper::CleanupRelease()
{
    LONG cbRef = --m_cbRefCount;
    _ASSERTE(cbRef == 0);
    FreeHandle();
    Cleanup();
}

//--------------------------------------------------------------------------------
// void ComPlusWrapper::MinorCleanup()
// schedule to free all interface pointers, called during GC to 
// do minimal work
void ComPlusWrapper::MinorCleanup()
{
    _ASSERTE(GCHeap::IsGCInProgress()
        || ( (g_fEEShutDown & ShutDown_SyncBlock) && g_fProcessDetach ));

#ifdef _DEBUG
    if (IsWrapperInUse())
    {
        // catch the GC hole that is causing this wrapper to get 
        // cleanedup when it is still in use
        DebugBreak();
    }
#endif
    
    // Log the wrapper minor cleanup.
    LogComPlusWrapperMinorCleanup(this, m_pUnknown);

    // remove the wrapper from the cache, so that 
    // other threads won't find this invalid wrapper
    // NOTE: we don't need to LOCK because we make sure 
    // the rest of the folks touch this hash table
    // with thier GC mode pre-emptiveGCDisabled
    ComPlusWrapperCache* pCache = m_pComPlusWrapperCache;
    _ASSERTE(pCache);

    // On server build, multiple threads will be removing
    // wrappers from wrapper cache, 
    pCache->RemoveWrapper(this);

    // clear the handle as the handle table is going to be nuked and m_hRef will be invalid in the
    // later cleanup stage
    if (m_pComPlusWrapperCache->GetDomain() == SystemDomain::System()->AppDomainBeingUnloaded())
        m_hRef = NULL;
}

//--------------------------------------------------------------------------------
// void ComPlusWrapper::Cleanup()
// Cleanup free all interface pointers
void ComPlusWrapper::Cleanup()
{
#ifdef _DEBUG
    if (IsWrapperInUse())
    {
        // catch the GC hole that is causing this wrapper to get 
        // cleanedup when it is still in use
        DebugBreak();
    }
#endif
    
#ifdef _DEBUG
    // If we can't switch to cooperative mode, then we need to skip the check to
    // if the wrapper is still in the cache.
    if (!(GetThread()->m_StateNC & Thread::TSNC_UnsafeSkipEnterCooperative))
    {
        // make sure this wrapper is not in the hash table   
        AUTO_COOPERATIVE_GC();
        m_pComPlusWrapperCache->LOCK();
        _ASSERTE((ComPlusWrapper*)m_pComPlusWrapperCache->LookupWrapper(m_pIdentity) != this);
        m_pComPlusWrapperCache->UNLOCK();
    }           
#endif

    // Validate that the weak reference handle is valid.
    if (!g_fEEShutDown && !g_fInControlC)
        _ASSERTE(m_hRef == NULL || !IsValid());

    // Destroy the weak reference handle.
    if (m_hRef != NULL)
        DestroyWeakHandle(m_hRef);

    // Release the IUnkEntry and the InterfaceEntries.
    ReleaseAllInterfacesCallBack(this);

#ifdef _DEBUG
    m_cbRefCount = 0;
    m_pUnknown = NULL;
#endif

    // Log the destruction of the RCW.
    LogComPlusWrapperDestroy(this, m_pUnknown);

    // Release the wrapper cache and delete the RCW.
    m_pComPlusWrapperCache->Release();
    delete this;
}


//--------------------------------------------------------------------------------
// Create a new wrapper for a different method table that represents the same
// COM object as the original wrapper.
ComPlusWrapper *ComPlusWrapper::CreateDuplicateWrapper(ComPlusWrapper *pOldWrap, MethodTable *pNewMT)
{
    THROWSCOMPLUSEXCEPTION();

    ComPlusWrapper *pNewWrap = NULL;    

    _ASSERTE(pNewMT->IsComObjectType());

    // Validate that there exists a default constructor for the new wrapper class.
    if (!pNewMT->HasDefaultConstructor())
        COMPlusThrow(kArgumentException, IDS_EE_WRAPPER_MUST_HAVE_DEF_CONS);

    // Allocate the wrapper COM object.
    COMOBJECTREF NewWrapperObj = (COMOBJECTREF)ComObject::CreateComObjectRef(pNewMT);
    GCPROTECT_BEGIN(NewWrapperObj)
    {
        TAutoItf<IUnknown> pAutoUnk = NULL;

        // Retrieve the ComPlusWrapperCache to use.
        ComPlusWrapperCache* pCache = ComPlusWrapperCache::GetComPlusWrapperCache();

        // Create the new ComPlusWrapper associated with the COM object. We need
        // to set the identity to some default value so we don't remove the original
        // wrapper from the hash table when this wrapper goes away.
        pAutoUnk = pOldWrap->GetIUnknown();
        pAutoUnk.InitMsg("Release Duplicate Wrapper");

        pNewWrap = pCache->CreateComPlusWrapper((IUnknown*)pAutoUnk, (IUnknown*)pAutoUnk);

        // Initialize the new wrapper with the COMOBJECTREF it is associated with.
        if (!pNewWrap->Init((OBJECTREF)NewWrapperObj))
        {
            pNewWrap->CleanupRelease();
            COMPlusThrowOM();
        }
    
        // Initialize the new one with its own ComPlusWrapper.
        NewWrapperObj->Init(pNewWrap);

        // Run the class constructor if it has not run yet.
        OBJECTREF Throwable;
        if (!pNewMT->CheckRunClassInit(&Throwable))
            COMPlusThrow(Throwable);

        CallDefaultConstructor(ObjectToOBJECTREF(NewWrapperObj));

        // Insert the wrapper into the hashtable. The wrapper will be a duplicate however we
        // we fix the identity to ensure there is no collison in the hash table & it is required 
        // since the hashtable is used on appdomain unload to determine what RCW's need to released.
        pCache->LOCK();
        pNewWrap->m_pIdentity = pNewWrap;
        pCache->InsertWrapper(pNewWrap, pNewWrap);
        pCache->UNLOCK();

        // safe release the interface while we are GCProtected
        pAutoUnk.SafeReleaseItf();
    }
    GCPROTECT_END();

    return pNewWrap;
}

//--------------------------------------------------------------------------------
// IUnknown* ComPlusWrapper::GetComIPFromWrapper(MethodTable* pTable)
// check the local cache, out of line cache 
// if not found QI for the interface and store it
// fast call for a quick check in the cache
IUnknown* ComPlusWrapper::GetComIPFromWrapper(REFIID iid)
{
    BaseDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);
    EEClass *pClass = pDomain->LookupClass(iid);

    if (pClass == NULL)
        return NULL;

    MethodTable *pMT = pClass->GetMethodTable();
    return GetComIPFromWrapper(pMT);
}



//--------------------------------------------------------------------------------
// IUnknown* ComPlusWrapper::GetComIPFromWrapper(MethodTable* pTable)
// check the local cache, out of line cache 
// if not found QI for the interface and store it

IUnknown* ComPlusWrapper::GetComIPFromWrapper(MethodTable* pTable)
{
    if (pTable == NULL 
        || pTable->GetClass()->IsObjectClass()
        || GetAppDomain()->IsSpecialObjectClass(pTable))
    {
        // give out the IUnknown or IDispatch
        IUnknown *result = GetIUnknown();
        _ASSERTE(result != NULL);
        return result;
    }

    // returns an AddRef'ed IP
    return GetComIPForMethodTableFromCache(pTable);
}


//-----------------------------------------------------------------
// Get the IUnknown pointer for the wrapper
// make sure it is on the right thread
IUnknown *ComPlusWrapper::GetIUnknown()
{
    THROWSCOMPLUSEXCEPTION();

    // Retrieve the IUnknown in the current context.
    return m_UnkEntry.GetIUnknownForCurrContext();
}

//-----------------------------------------------------------------
// Get the IUnknown pointer for the wrapper
// make sure it is on the right thread
IDispatch *ComPlusWrapper::GetIDispatch()
{
    IDispatch *pDisp = NULL;
    IUnknown *pUnk;

    // Get IUnknown on the current thread
    pUnk = GetIUnknown();   
    _ASSERTE(pUnk);

    HRESULT hr = SafeQueryInterfaceRemoteAware(pUnk, IID_IDispatch, (IUnknown**)&pDisp);
    LogInteropQI(pUnk, IID_IDispatch, hr, "IDispatch");
    // QI for IDispatch.
    if ( S_OK !=  hr )
    {
        // If anything goes wrong simply set pDisp to NULL to indicate that 
        // the wrapper does not support IDispatch.
        pDisp = NULL;
    }

    // release our ref-count on pUnk
    ULONG cbRef = SafeRelease(pUnk);
    LogInteropRelease(pUnk, cbRef, "GetIUnknown");

    // Return the IDispatch that is guaranteed to be valid on the current thread.
    return pDisp;
}



//-----------------------------------------------------------
// Init object ref
int ComPlusWrapper::Init(OBJECTREF cref)
{
    _ASSERTE(cref != NULL);
    m_cbRefCount = 1;

    // create handle for the object
    m_hRef = m_pComPlusWrapperCache->GetDomain()->CreateWeakHandle( NULL );
    if(m_hRef == NULL)
    {
        return 0;
    }        
    // store the wrapper in the sync block, that is the only way 
    // we can get cleaned up    
    // the low bit is set to differentiate this pointer from ComCallWrappers
    // which are also stored in the sync block
    // the syncblock is guaranteed to be present, 
    cref->GetSyncBlockSpecial()->SetComPlusWrapper((ComPlusWrapper*)((size_t)this | 0x1));
    StoreObjectInHandle( m_hRef, (OBJECTREF)cref );

    // Log the wrapper initialization.
    LOG((LF_INTEROP, LL_INFO100, "Initializing ComPlusWrapper %p with objectref %p\n", this, cref));

    // To help combat finalizer thread starvation, we check to see if there are any wrappers
    // scheduled to be cleaned up for our context.  If so, we'll do them here to avoid making
    // the finalizer thread do a transition.
    // @perf: This may need a bit of tuning.
    _ASSERTE(g_pRCWCleanupList != NULL);
    g_pRCWCleanupList->CleanUpCurrentWrappers();

    return 1;
}


//----------------------------------------------------------
// Init Iunknown and Idispatch cookies with the pointers
void ComPlusWrapper::Init(IUnknown* pUnk, LPVOID pIdentity)
{
    // Cache the IUnk and thread
    m_pUnknown = pUnk;
    m_pIdentity = pIdentity;

    // track the thread that created this wrapper
    // if this thread is an STA thread, then when the STA dies
    // we need to cleanup this wrapper
    m_pCreatorThread  = GetThread();
    _ASSERTE(m_pCreatorThread != NULL);

    m_pComPlusWrapperCache = ComPlusWrapperCache::GetComPlusWrapperCache();
    m_pComPlusWrapperCache->AddRef();

    LogComPlusWrapperCreate(this, pUnk);

    _ASSERTE(pUnk != NULL);

    // Initialize the IUnkEntry.
    m_UnkEntry.Init(pUnk, FALSE);
}


//-----------------------------------------------
// Free GC handle
void ComPlusWrapper::FreeHandle()
{
    // Since we are touching object ref's we need to be in cooperative GC mode.
    BEGIN_ENSURE_COOPERATIVE_GC()
    {
        if (m_hRef != NULL)
        {
            COMOBJECTREF cref = (COMOBJECTREF)ObjectFromHandle(m_hRef);
            if (cref != NULL)
            {
                // remove reference to wrapper from sync block
                cref->GetSyncBlockSpecial()->SetComPlusWrapper((ComPlusWrapper*)/*NULL*/0x1);
                // destroy the back pointer in the objectref
                cref->Init(NULL);
            }
            // destroy the handle
            DestroyWeakHandle(m_hRef);
            m_hRef = NULL;
        }
    }
    END_ENSURE_COOPERATIVE_GC();
}

//IID_IDtcTransactionIdentifier {59294581-ECBE-11ce-AED3-00AA0051E2C4}
const IID IID_IDtcTransactionIdentifier = {0x59294581,0xecbe,0x11ce,{0xae,0xd3,0x0,0xaa,0x0,0x51,0xe2,0xc4}};
const IID IID_ISharedProperty = {0x2A005C01,0xA5DE,0x11CF,{0x9E, 0x66, 0x00, 0xAA, 0x00, 0xA3, 0xF4, 0x64}};
const IID IID_ISharedPropertyGroup = {0x2A005C07,0xA5DE,0x11CF,{0x9E, 0x66, 0x00, 0xAA, 0x00, 0xA3, 0xF4, 0x64}};
const IID IID_ISharedPropertyGroupManager = {0x2A005C0D,0xA5DE,0x11CF,{0x9E, 0x66, 0x00, 0xAA, 0x00, 0xA3, 0xF4, 0x64}};


HRESULT ComPlusWrapper::SafeQueryInterfaceRemoteAware(IUnknown* pUnk, REFIID iid, IUnknown** pResUnk)
{   
    HRESULT hr = SafeQueryInterface(pUnk, iid, pResUnk);
    
    if (hr == CO_E_OBJNOTCONNECTED || hr == RPC_E_INVALID_OBJECT || hr == RPC_E_INVALID_OBJREF || hr == CO_E_OBJNOTREG)
    {
        // set apartment state
        GetThread()->SetApartment(Thread::AS_InMTA);
    
        // Release the stream of the IUnkEntry to force UnmarshalIUnknownForCurrContext
        // to remarshal to the stream.
        m_UnkEntry.ReleaseStream();
    
        // Unmarshal again to the current context to get a valid proxy.
        IUnknown *pTmpUnk = m_UnkEntry.UnmarshalIUnknownForCurrContext();
    
        // Try to QI for the interface again.
        hr = SafeQueryInterface(pTmpUnk, iid, pResUnk);
        LogInteropQI(pTmpUnk, iid, hr, "SafeQIRemoteAware - QI for Interface after lost");
    
        // release our ref-count on pTmpUnk
        int cbRef = SafeRelease(pTmpUnk);
        LogInteropRelease(pTmpUnk, cbRef, "SafeQIRemoteAware - Release for Interface after los");             
    }

    return hr;
}

//-----------------------------------------------------------------
// Retrieve correct COM IP for the method table 
// for the current apartment, use the cache and update the cache on miss
IUnknown *ComPlusWrapper::GetComIPForMethodTableFromCache(MethodTable* pMT)
{
    ULONG cbRef;
    IUnknown* pInnerUnk = NULL;
    IUnknown   *pUnk = 0;
    IID iid;
    HRESULT hr;
    int i;

    Thread* pThread = GetThread();
    LPVOID pCtxCookie = GetCurrentCtxCookie();
    _ASSERTE(pCtxCookie != NULL);

    // Check whether we can satisfy this request from our cache.
    // NOTE: If you change this code, update inlined versions in
    // InlineGetComIPFromWrapper and CreateStandaloneNDirectStubSys.
    if (pCtxCookie == GetWrapperCtxCookie())
    {
        for (i = 0; i < INTERFACE_ENTRY_CACHE_SIZE; i++)
        {
            if (m_aInterfaceEntries[i].m_pMT == pMT)
            {
                _ASSERTE(!m_aInterfaceEntries[i].IsFree());
                pUnk = m_aInterfaceEntries[i].m_pUnknown;
                _ASSERTE(pUnk != NULL);
                ULONG cbRef = SafeAddRef(pUnk);
                LogInteropAddRef(pUnk, cbRef, "Fetch from cache");
                goto Leave;
            }
        }
    }

    // We're going to be making some COM calls, better initialize COM.
    if (FAILED(QuickCOMStartup()))
        goto Leave;    

    // Retrieve the IID of the interface.
    pMT->GetClass()->GetGuid(&iid, TRUE);
    
    // Get IUnknown on the current context
    AddRefInUse();
        
    EE_TRY_FOR_FINALLY
    {
        pInnerUnk = GetIUnknown();
    }
    EE_FINALLY
    {
        ReleaseInUse();
    }
    EE_END_FINALLY
        
    if (pInnerUnk)
    {
        // QI for the interface.
        hr = SafeQueryInterfaceRemoteAware(pInnerUnk, iid, &pUnk);
        LogInteropQI(pInnerUnk, iid, hr, "GetCOMIPForMethodTableFromCache QI on inner");

#ifdef CUSTOMER_CHECKED_BUILD
        if (FAILED(hr))
        {
            CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

            if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_FailedQI))
            {
                // We are interested in the case where the QI fails because of wrong context.
                if (pCtxCookie != GetWrapperCtxCookie())        // GetWrapperCtxCookie() returns m_UnkEntry.m_pCtxCookie.
                {
                    // Try to change context and perform the QI in the new context again.
                    CCBFailedQIProbeCallbackData    data;
                    
                    data.pWrapper   = this;
                    data.iid        = iid;

                    m_UnkEntry.m_pCtxEntry->EnterContext(CCBFailedQIProbeCallback, &data);
                    if (data.fSuccess)
                    {
                        // QI succeeds in the other context, i.e. the original QI fails because of wrong context.
                        CCBFailedQIProbeOutput(pCdh, pMT);
                    }
                }
                else if (hr == E_NOINTERFACE)
                {
                    // Check if pInnerUnk is actually pointing to a proxy, i.e. that it is pointing to an address
                    // within the loaded ole32.dll image.  Note that WszGetModuleHandle does not increment the 
                    // ref count.
                    HINSTANCE hModOle32 = WszGetModuleHandle(OLE32DLL);
                    if (hModOle32 && IsIPInModule(hModOle32, (BYTE *)(*(BYTE **)pInnerUnk)))
                    {
                        CCBFailedQIProbeOutput(pCdh, pMT);
                    }
                }
            }
        }
#endif // CUSTOMER_CHECKED_BUILD
         
        // release our ref-count on pInnerUnk
        cbRef = SafeRelease(pInnerUnk);
        LogInteropRelease(pInnerUnk, cbRef, "GetIUnknown");

    #ifdef _DEBUG
    #ifdef _WIN64
        pInnerUnk = (IUnknown*)(size_t)0xcdcdcdcdcdcdcdcd;
    #else // !_WIN64
        pInnerUnk = (IUnknown*)(size_t)0xcdcdcdcd;
    #endif // _WIN64
    #endif // _DEBUG
    }

    if (pUnk == NULL)
    {
        goto Leave;
    }
    
    // Cache result of our search.
    
    // Multiple threads could be trying to update the cache. Only allow one
    // to do so.

    // check if we need to cache the entry & try to acquire the 
    // cookie to cache the entry
    if (GetWrapperCtxCookie() == pCtxCookie && TryUpdateCache())
    {
        // If the component is not aggregated then we need to ref-count
        BOOL fReleaseReq = !IsURTAggregated();

        for (i = 0; i < INTERFACE_ENTRY_CACHE_SIZE; i++)
        {
            if (m_aInterfaceEntries[i].IsFree())
            {
                if (fReleaseReq)
                {
                    // Get an extra addref to hold this reference alive in our cache
                    cbRef = SafeAddRef(pUnk);
                    LogInteropAddRef(pUnk, cbRef, "Store in cache");
                }

                m_aInterfaceEntries[i].Init(pMT, pUnk);
                break;
            }
        }

        if (i == INTERFACE_ENTRY_CACHE_SIZE)
        {
            // @TODO(COMCACHE_PORT): Add a linked list of InterfaceEntries
            //                       to handle more than INTERFACE_ENTRY_CACHE_SIZE
            //                       interfaces.
        }
    
        EndUpdateCache();
    }

 Leave:

    return pUnk;
}

//----------------------------------------------------------
// Determine if the COM object supports IProvideClassInfo.
BOOL ComPlusWrapper::SupportsIProvideClassInfo()
{
    BOOL bSupportsIProvideClassInfo = FALSE;
    IUnknown *pProvClassInfo = NULL;

    // Retrieve the IUnknown.
    IUnknown *pUnk = GetIUnknown();

    // QI for IProvideClassInfo on the COM object.
    HRESULT hr = SafeQueryInterfaceRemoteAware(pUnk, IID_IProvideClassInfo, &pProvClassInfo);
    LogInteropQI(pUnk, IID_IProvideClassInfo, hr, "QI for IProvideClassInfo on RCW");

    // Release the IUnknown.
    ULONG cbRef = SafeRelease(pUnk);
    LogInteropRelease(pUnk, cbRef, "Release RCW IUnknown after QI for IProvideClassInfo");

    // Check to see if the QI for IProvideClassInfo succeeded.
    if (SUCCEEDED(hr))
    {
        _ASSERTE(pProvClassInfo);
        bSupportsIProvideClassInfo = TRUE;
        ULONG cbRef = SafeRelease(pProvClassInfo);
        LogInteropRelease(pProvClassInfo, cbRef, "Release RCW IProvideClassInfo after QI for IProvideClassInfo");
    }

    return bSupportsIProvideClassInfo;
}

//---------------------------------------------------------------------
// Callback called to release the IUnkEntry and the Interface entries.
HRESULT __stdcall ComPlusWrapper::ReleaseAllInterfacesCallBack(LPVOID pData)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    ComPlusWrapper* pWrap = (ComPlusWrapper*)pData;

    LPVOID pCurrentCtxCookie = GetCurrentCtxCookie();
    if (pCurrentCtxCookie == NULL || pCurrentCtxCookie == pWrap->GetWrapperCtxCookie())
    {
        pWrap->ReleaseAllInterfaces();
    }
    else
    {
        // Retrieve the addref'ed context entry that the wrapper lives in.
        CtxEntry *pCtxEntry = pWrap->GetWrapperCtxEntry();

        // Transition into the context to release the interfaces.   
        HRESULT hr = pCtxEntry->EnterContext(ReleaseAllInterfacesCallBack, pWrap);
        if (hr == RPC_E_DISCONNECTED || hr == RPC_E_SERVER_DIED_DNE)
        {
            // The context is disconnected so we cannot transition into it to clean up.
            // The only option we have left is to try and release the interfaces from
            // the current context. This will work for context agile object's since we have
            // a pointer to them directly. It will however fail for others since we only
            // have a pointer to a proxy which is no longer attached to the object.

#ifdef CUSTOMER_CHECKED_BUILD
            CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
            if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_DisconnectedContext))
            {
                CQuickArray<WCHAR>  strMsg; 
                static WCHAR        szTemplateMsg[] = 
                                        {L"The context (cookie %lu) is disconnected.  Releasing the interfaces from the current context (cookie %lu)."};

                strMsg.Alloc(lengthof(szTemplateMsg) + MAX_INT32_DECIMAL_CHAR_LEN * 2);
                Wszwsprintf(strMsg.Ptr(), szTemplateMsg, pWrap->GetWrapperCtxCookie(), pCurrentCtxCookie);
                pCdh->LogInfo(strMsg.Ptr(), CustomerCheckedBuildProbe_DisconnectedContext);
            }
#endif // CUSTOMER_CHECKED_BUILD

            pWrap->ReleaseAllInterfaces();
        }

        // Release the ref count on the CtxEntry.
        pCtxEntry->Release();
    }

    return S_OK;
}

//---------------------------------------------------------------------
// Helper function called from ReleaseAllInterfacesCallBack do do the 
// actual releases.
void ComPlusWrapper::ReleaseAllInterfaces()
{
    // Free the IUnkEntry.       
    m_UnkEntry.Free();

    // If this wrapper is not an Extensible RCW, free all the interface entries that have been allocated.
    if (!IsURTAggregated())
    {
        for (int i = 0; i < INTERFACE_ENTRY_CACHE_SIZE && !m_aInterfaceEntries[i].IsFree(); i++)
        {
            DWORD cbRef = SafeRelease(m_aInterfaceEntries[i].m_pUnknown);                            
            LogInteropRelease(m_aInterfaceEntries[i].m_pUnknown, cbRef, "InterfaceEntry Release");
        }
    }
}


//--------------------------------------------------------------------------------
// class ComObject
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// OBJECTREF ComObject::CreateComObjectRef(MethodTable* pMT)
//  returns NULL for out of memory scenarios
OBJECTREF ComObject::CreateComObjectRef(MethodTable* pMT)
{   
    _ASSERTE(pMT != NULL);
    _ASSERTE(pMT->IsComObjectType());

    SystemDomain::EnsureComObjectInitialized();
    pMT->CheckRestore();
    pMT->CheckRunClassInit(NULL);

    OBJECTREF oref = FastAllocateObject(pMT);
    
    SyncBlock *pBlock = NULL;
    // this is to guarantee that there is syncblock for this object
    pBlock = (SyncBlock*)oref->GetSyncBlockSpecial();
    
    if (pBlock == NULL)
    {
        _ASSERTE(!"Unable to allocate a sync block");
        return NULL;
    }

    // For now, the assumption is that a ComObject can be created in any context.  So
    // we should not have got back a proxy to it.  If this assert fires, we may need
    // to do the CtxProxy::MeetComContextWrapper() here, after we are set up.
    _ASSERTE(!oref->GetMethodTable()->IsCtxProxyType());

    return oref;
}


//--------------------------------------------------------------------------------
// SupportsInterface
BOOL ComObject::SupportsInterface(OBJECTREF oref, MethodTable* pIntfTable)
{
    THROWSCOMPLUSEXCEPTION();

    IUnknown *pUnk;
    HRESULT hr;
    ULONG cbRef;
    BOOL bSupportsItf = false;

    GCPROTECT_BEGIN(oref);

    //EEClass::MapInterfaceFromSystem(SystemDomain::GetCurrentDomain(), pIntfTable);

    // This should not be called for interfaces that are in the normal portion of the 
    // interface map for this class. The only interfaces that are in the interface map
    // but are not in the normal portion are the dynamic interfaces on extensible RCW's.
    _ASSERTE(!oref->GetMethodTable()->FindInterface(pIntfTable));


    //
    // First QI the object to see if it implements the specified interface.
    //

    pUnk = ComPlusWrapper::InlineGetComIPFromWrapper(oref, pIntfTable);
    if (pUnk)
    {
        cbRef = SafeRelease(pUnk);
        LogInteropRelease(pUnk, cbRef, "SupportsInterface");       
        bSupportsItf = true;
    }
    else if (pIntfTable->IsComEventItfType())
    {
        EEClass *pSrcItfClass = NULL;
        EEClass *pEvProvClass = NULL;
        GUID SrcItfIID;
        IConnectionPointContainer *pCPC = NULL;
        IConnectionPoint *pCP = NULL;

        // Retrieve the IID of the source interface associated with this
        // event interface.
        pIntfTable->GetClass()->GetEventInterfaceInfo(&pSrcItfClass, &pEvProvClass);
        pSrcItfClass->GetGuid(&SrcItfIID, TRUE);

        // Get IUnknown on the current thread.
        pUnk = ((COMOBJECTREF)oref)->GetWrapper()->GetIUnknown();
        if (pUnk)
        {
            // QI for IConnectionPointContainer.
            hr = SafeQueryInterface(pUnk, IID_IConnectionPointContainer, (IUnknown**)&pCPC);
            LogInteropQI(pUnk, IID_IConnectionPointContainer, hr, "Supports Interface");

            // If the component implements IConnectionPointContainer, then check
            // to see if it handles the source interface.
            if (SUCCEEDED(hr))
            {
                hr = pCPC->FindConnectionPoint(SrcItfIID, &pCP);
                if (SUCCEEDED(hr))
                {
                    // The component handles the source interface so we can succeed the QI call.
                    cbRef = SafeRelease(pCP);
                    LogInteropRelease(pCP, cbRef, "SupportsInterface");       
                    bSupportsItf = true;
                }

                // Release our ref-count on the connection point container.
                cbRef = SafeRelease(pCPC);
                LogInteropRelease(pCPC, cbRef, "SupportsInterface");    
            }
            
            // Release our ref-count on pUnk
            cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "SupportsInterface: GetIUnknown");
        }
    }
    else
    {
        //
        // Handle casts to normal managed standard interfaces.
        //

        TypeHandle IntfType = TypeHandle(pIntfTable);

        // Check to see if the interface is a managed standard interface.
        IID *pNativeIID = MngStdInterfaceMap::GetNativeIIDForType(&IntfType);
        if (pNativeIID != NULL)
        {
            // It is a managed standard interface so we need to check to see if the COM component
            // implements the native interface associated with it.
            IUnknown *pNativeItf;

            // Get IUnknown on the current thread.
            pUnk = ((COMOBJECTREF)oref)->GetWrapper()->GetIUnknown();
            _ASSERTE(pUnk);

            // QI for the native interface.
            hr = SafeQueryInterface(pUnk, *pNativeIID, &pNativeItf);
            LogInteropQI(pUnk, *pNativeIID, hr, "Supports Interface");

            // Release our ref-count on pUnk
            cbRef = SafeRelease(pUnk);
            LogInteropRelease(pUnk, cbRef, "SupportsInterface: GetIUnknown");

            // If the component supports the native interface then we can say it implements the 
            // standard interface.
            if (pNativeItf)
            {
                cbRef = SafeRelease(pNativeItf);
                LogInteropRelease(pNativeItf, cbRef, "SupportsInterface: native interface");
                bSupportsItf = true;
            }
        }
        else 
        {
            //
            // Handle casts to IEnumerable.
            //

            // Load the IEnumerable type if is hasn't been loaded yet.
            if (m_IEnumerableType.IsNull())
                m_IEnumerableType = TypeHandle(g_Mscorlib.GetClass(CLASS__IENUMERABLE));

            // If the requested interface is IEnumerable then we need to check to see if the 
            // COM object implements IDispatch and has a member with DISPID_NEWENUM.
            if (m_IEnumerableType == IntfType)
            {
                // Get the IDispatch on the current thread.
                IDispatch *pDisp = ((COMOBJECTREF)oref)->GetWrapper()->GetIDispatch();
                if (pDisp)
                {
                    DISPPARAMS DispParams = {0, 0, NULL, NULL};
                    VARIANT VarResult;

                    // Initialize the return variant.
                    VariantInit(&VarResult);

#ifdef CUSTOMER_CHECKED_BUILD
                    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_ObjNotKeptAlive))
                    {
                        g_pGCHeap->GarbageCollect();
                        g_pGCHeap->FinalizerThreadWait(1000);
                    }
#endif // CUSTOMER_CHECKED_BUILD

                    // Call invoke with DISPID_NEWENUM to see if such a member exists.
                    hr = pDisp->Invoke( 
                                        DISPID_NEWENUM, 
                                        IID_NULL, 
                                        LOCALE_USER_DEFAULT,
                                        DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                                        &DispParams,
                                        &VarResult,
                                        NULL,              
                                        NULL
                                      );

#ifdef CUSTOMER_CHECKED_BUILD
                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_BufferOverrun))
                    {
                        g_pGCHeap->GarbageCollect();
                        g_pGCHeap->FinalizerThreadWait(1000);
                    }
#endif // CUSTOMER_CHECKED_BUILD

                    // If the invoke succeeded then the component has a member DISPID_NEWENUM 
                    // so we can expose it as an IEnumerable.
                    if (SUCCEEDED(hr))
                    {
                        // Clear the result variant.
                        VariantClear(&VarResult);
                        bSupportsItf = true;
                    }

                    // Release our ref-count on pUnk
                    cbRef = SafeRelease(pDisp);
                    LogInteropRelease(pDisp, cbRef, "SupportsInterface: GetIDispatch");
                }
            }
        }
    }

    if (bSupportsItf)
    {
        // If the object has a dynamic interface map then we have extra work to do.
        MethodTable *pMT = oref->GetMethodTable();
        if (pMT->HasDynamicInterfaceMap())
        {
            BOOL bAddedItf = FALSE;

            // Take the wrapper cache lock before we start playing with the interface map.
            ComPlusWrapperCache::GetComPlusWrapperCache()->LOCK();

            // If the interface was not yet in the interface map then we need to allocate
            // a new interface vtable map with this interface added to it.
            if (!pMT->FindDynamicallyAddedInterface(pIntfTable))
            {
                pMT->AddDynamicInterface(pIntfTable);
                bAddedItf = TRUE;
            }

            // Unlock the wrapper cache lock,
            ComPlusWrapperCache::GetComPlusWrapperCache()->UNLOCK();

            // If we added the map to the list of dynamically supported interface, ensure that 
            // any interfaces that are implemented by the current interface are also supported.
            if (bAddedItf)
            {
                for (UINT i = 0; i < pIntfTable->GetNumInterfaces(); i++)
                {
                    bSupportsItf = pMT->GetClass()->SupportsInterface(oref, pIntfTable->GetInterfaceMap()[i].m_pMethodTable);
                    if (!bSupportsItf)
                        break;
                }
            }
        }
    }

    GCPROTECT_END();

    return bSupportsItf;
}


//--------------------------------------------------------------------------------
// Release all the data associated with the __ComObject.
void ComObject::ReleaseAllData(OBJECTREF oref)
{
    _ASSERTE(GetThread()->PreemptiveGCDisabled());
    _ASSERTE(oref != NULL);
    _ASSERTE(oref->GetMethodTable()->IsComObjectType());

    static MethodDesc *s_pReleaseAllDataMD = NULL;

    GCPROTECT_BEGIN(oref)
    {
        // Retrieve the method desc for __ComObject::ReleaseAllData().
        if (!s_pReleaseAllDataMD)
            s_pReleaseAllDataMD = g_Mscorlib.GetMethod(METHOD__COM_OBJECT__RELEASE_ALL_DATA);

        // Release all the data associated with the ComObject.
        if (((COMOBJECTREF)oref)->m_ObjectToDataMap != NULL)
        {
            INT64 ReleaseAllDataArgs[] = { 
                ObjToInt64(oref)
            };
            s_pReleaseAllDataMD->Call(ReleaseAllDataArgs, METHOD__COM_OBJECT__RELEASE_ALL_DATA);
        }
    }
    GCPROTECT_END();
}



#ifdef CUSTOMER_CHECKED_BUILD

HRESULT CCBFailedQIProbeCallback(LPVOID pData)
{
    HRESULT                          hr = E_FAIL;
    IUnknown                        *pUnkInThisCtx = NULL, *pDummyUnk = NULL;
    CCBFailedQIProbeCallbackData    *pCallbackData = (CCBFailedQIProbeCallbackData *)pData;

    COMPLUS_TRY
    {
        pUnkInThisCtx   = pCallbackData->pWrapper->GetIUnknown();
        hr              = pCallbackData->pWrapper->SafeQueryInterfaceRemoteAware(pUnkInThisCtx, pCallbackData->iid, &pDummyUnk);
        LogInteropQI(pUnkInThisCtx, pCallbackData->iid, hr, "CCBFailedQIProbeCallback on RCW");
    }
    COMPLUS_FINALLY
    {
        if (pUnkInThisCtx)
            SafeRelease(pUnkInThisCtx);

        if (pDummyUnk)
            SafeRelease(pDummyUnk);
    }
    COMPLUS_END_FINALLY

    if (pUnkInThisCtx)
        SafeRelease(pUnkInThisCtx);

    if (pDummyUnk)
        SafeRelease(pDummyUnk);

    pCallbackData->fSuccess = SUCCEEDED(hr);

    return S_OK;        // Need to return S_OK so that the assert in CtxEntry::EnterContext() won't fire.
}


void CCBFailedQIProbeOutput(CustomerDebugHelper *pCdh, MethodTable *pMT)
{
    CQuickArrayNoDtor<WCHAR> strMsg;
    static WCHAR             szTemplateMsg[] = {L"Failed to QI for interface %s because it does not have a COM proxy stub registered."};

    DefineFullyQualifiedNameForClassWOnStack();
    GetFullyQualifiedNameForClassW(pMT->GetClass());

    strMsg.Alloc(lengthof(szTemplateMsg) + lengthof(_wszclsname_));
    Wszwsprintf(strMsg.Ptr(), szTemplateMsg, _wszclsname_);
    pCdh->LogInfo(strMsg.Ptr(), CustomerCheckedBuildProbe_FailedQI);
    strMsg.Destroy();
}

#endif // CUSTOMER_CHECKED_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: compile.h
//
// Interfaces and support for zap compiler and zap files
// 
// ===========================================================================

#ifndef COMPILE_H_
#define COMPILE_H_

#include "corzap.h"

class CEECompileInfo : public CEEInfo, public ICorCompileInfo
{
  public:
    
    HRESULT __stdcall Startup();
    HRESULT __stdcall Shutdown();

    HRESULT __stdcall CreateDomain(ICorCompilationDomain **ppDomain,
                                   BOOL shared,
                                   CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame);
    HRESULT __stdcall DestroyDomain(ICorCompilationDomain *pDomain,
                                    CORCOMPILE_DOMAIN_TRANSITION_FRAME *pFrame);

    HRESULT __stdcall LoadAssembly(LPCWSTR path,
                                   CORINFO_ASSEMBLY_HANDLE *pHandle);
    HRESULT __stdcall LoadAssemblyFusion(IAssemblyName *pFusionName,
                                         CORINFO_ASSEMBLY_HANDLE *pHandle);
    HRESULT __stdcall LoadAssemblyRef(IMetaDataAssemblyImport *pAssemblyImport, mdAssemblyRef ref,
                                      CORINFO_ASSEMBLY_HANDLE *pHandle);
    HRESULT __stdcall LoadAssemblyModule(CORINFO_ASSEMBLY_HANDLE assembly,
                                         mdFile file, CORINFO_MODULE_HANDLE *pHandle);

    BOOL __stdcall CheckAssemblyZap(CORINFO_ASSEMBLY_HANDLE assembly,
                                    BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfiling);
    HRESULT __stdcall GetAssemblyShared(CORINFO_ASSEMBLY_HANDLE assembly, BOOL *pShared);

    HRESULT __stdcall GetAssemblyDebuggableCode(CORINFO_ASSEMBLY_HANDLE assembly, 
                                                BOOL *pDebug, BOOL *pDebugOpt);

    IMetaDataAssemblyImport * __stdcall GetAssemblyMetaDataImport(CORINFO_ASSEMBLY_HANDLE scope);
    IMetaDataImport * __stdcall GetModuleMetaDataImport(CORINFO_MODULE_HANDLE scope);

    CORINFO_MODULE_HANDLE __stdcall GetAssemblyModule(CORINFO_ASSEMBLY_HANDLE module);

    CORINFO_ASSEMBLY_HANDLE __stdcall GetModuleAssembly(CORINFO_MODULE_HANDLE module);  
    BYTE * __stdcall GetModuleBaseAddress(CORINFO_MODULE_HANDLE scope);

    DWORD __stdcall GetModuleFileName(CORINFO_MODULE_HANDLE module, LPWSTR lpwszFilename, DWORD nSize);

    HRESULT __stdcall EncodeModule(CORINFO_MODULE_HANDLE fromHandle,
                                           CORINFO_MODULE_HANDLE handle,
                                           DWORD *pAssemblyIndex,
                                           DWORD *pModuleIndex,
                                           IMetaDataAssemblyEmit *pAssemblyEmit); 
    HRESULT __stdcall EncodeClass(CORINFO_CLASS_HANDLE classHandle,
                                          BYTE *pBuffer,
                                          DWORD *cBuffer);
    HRESULT __stdcall EncodeMethod(CORINFO_METHOD_HANDLE handle,
                                           BYTE *pBuffer,
                                           DWORD *cBuffer);
    HRESULT __stdcall EncodeField(CORINFO_FIELD_HANDLE handle,
                                          BYTE *pBuffer,
                                          DWORD *cBuffer);
    HRESULT __stdcall EncodeString(mdString token,
                                   BYTE *pBuffer,
                                   DWORD *cBuffer);
    HRESULT __stdcall EncodeSig(mdToken token,
                                BYTE *pBuffer,
                                DWORD *cBuffer);

    HRESULT __stdcall GetTypeDef(CORINFO_CLASS_HANDLE classHandle,
                                 mdTypeDef *token);
    HRESULT __stdcall GetMethodDef(CORINFO_METHOD_HANDLE methodHandle,
                                   mdMethodDef *token);
    HRESULT __stdcall GetFieldDef(CORINFO_FIELD_HANDLE fieldHandle,
                                  mdFieldDef *token);

    HRESULT __stdcall PreloadModule(CORINFO_MODULE_HANDLE moduleHandle,
                                    ICorCompileDataStore *pData,
                                    mdToken *pSaveOrderArray,
                                    DWORD cSaveOrderArray,
                                    ICorCompilePreloader **ppPreloader);

    HRESULT __stdcall GetZapString(CORCOMPILE_VERSION_INFO *pVersionInfo,
                                   LPWSTR buffer);

    HRESULT __stdcall EmitSecurityInfo(CORINFO_ASSEMBLY_HANDLE assembly,
                                       IMetaDataEmit *pEmitScope);

    HRESULT __stdcall GetEnvironmentVersionInfo(CORCOMPILE_VERSION_INFO *pInfo);

    HRESULT __stdcall GetAssemblyStrongNameHash(
                        CORINFO_ASSEMBLY_HANDLE hAssembly,
                        PBYTE                   pbSNHash,
                        DWORD                  *pcbSNHash);

#ifdef _DEBUG
    HRESULT __stdcall DisableSecurity();
#endif

    enum 
    {
        ENCODE_TYPE_SIG,
        ENCODE_METHOD_TOKEN,
        ENCODE_METHOD_SIG,
        ENCODE_FIELD_TOKEN,
        ENCODE_FIELD_SIG,
        ENCODE_STRING_TOKEN,
        ENCODE_SIG_TOKEN,
        ENCODE_SIG_METHODREF_TOKEN,
    };

    static int GetEncodedType(BYTE *pBuffer) { return CorSigUncompressData(pBuffer); }

    static Module *DecodeModule(Module *fromModule,
                                DWORD assemblyIndex,
                                DWORD moduleIndex);
    static TypeHandle DecodeClass(Module *fromModule,
                                  BYTE *pBuffer,
                                  BOOL dontRestoreType = FALSE);
    static MethodDesc *DecodeMethod(Module *fromModule,
                                    BYTE *pBuffer);
    static FieldDesc *DecodeField(Module *fromModule,
                                  BYTE *pBuffer);
    static void DecodeString(Module *fromModule, BYTE *pBuffer, EEStringData *pData);
    static PCCOR_SIGNATURE DecodeSig(Module *fromModule,
                                     BYTE *pBuffer);
};

class CEEPreloader : public ICorCompilePreloader, DataImage::IDataStore
{
  private:
    DataImage               *m_image;
    ICorCompileDataStore    *m_pData;

  public:
    CEEPreloader(Module *pModule,
                 ICorCompileDataStore *pData);
    ~CEEPreloader();

    HRESULT Preload(mdToken *pSaveOrderArray, DWORD cSaveOrderArray);

    //
    // ICorCompilerPreloader
    //

    SIZE_T __stdcall MapMethodEntryPoint(void *methodEntryPoint);
    SIZE_T __stdcall MapMethodPointer(void *methodPointer);
    SIZE_T __stdcall MapModuleHandle(CORINFO_MODULE_HANDLE handle);
    SIZE_T __stdcall MapClassHandle(CORINFO_CLASS_HANDLE handle);
    SIZE_T __stdcall MapMethodHandle(CORINFO_METHOD_HANDLE handle);
    SIZE_T __stdcall MapFieldHandle(CORINFO_FIELD_HANDLE handle);
    SIZE_T __stdcall MapAddressOfPInvokeFixup(void *addressOfPInvokeFixup);
    SIZE_T __stdcall MapFieldAddress(void *staticFieldAddress);
    SIZE_T __stdcall MapVarArgsHandle(CORINFO_VARARGS_HANDLE handle);

    HRESULT Link(DWORD *pRidToCodeRVAMap);
    ULONG Release();

    //
    // IDataStore
    //

    virtual HRESULT Allocate(ULONG size, ULONG *sizesByDescription, void **baseMemory);
    HRESULT AddFixup(ULONG offset, DataImage::ReferenceDest dest,
                     DataImage::Fixup type);
    HRESULT AddTokenFixup(ULONG offset, mdToken tokenType, Module *module);
    HRESULT GetFunctionAddress(MethodDesc *method, void **pCode);
    HRESULT AdjustAttribution(mdToken token, LONG adjustment);
    HRESULT Error(mdToken token, HRESULT hr, OBJECTREF *pThrowable);
};

class AssemblyBindingTable
{
    MemoryPool m_pool;
    PtrHashMap m_map;

    struct AssemblyBinding
    {
        AssemblySpec    spec;
        Assembly        *pAssembly;
    };

  public:

    AssemblyBindingTable(SIZE_T size);
    ~AssemblyBindingTable();

    // Returns TRUE if the spec was already in the table
    BOOL Bind(AssemblySpec *pSpec, Assembly *pAssembly);
    Assembly *Lookup(AssemblySpec *pSpec);

    DWORD Hash(AssemblySpec *pSpec);
    static BOOL CompareSpecs(UPTR u1, UPTR u2);
};


struct RefCache
{
    RefCache(Module *pModule)
    {
        m_pModule = pModule;
        m_sTypeRefMap.Init(FALSE,NULL);
        m_sMethodRefMap.Init(FALSE,NULL);
        m_sFieldRefMap.Init(FALSE,NULL);
        m_sAssemblyRefMap.Init(FALSE,NULL);
    }

    Module *m_pModule;

    HashMap m_sTypeRefMap;
    HashMap m_sMethodRefMap;
    HashMap m_sFieldRefMap;
    HashMap m_sAssemblyRefMap;
};

class CompilationDomain : public AppDomain, 
                          public ICorCompilationDomain
{
  private:
    Assembly                *m_pTargetAssembly;
    AssemblyBindingTable    *m_pBindings;

    IMetaDataAssemblyEmit   *m_pEmit;
    AssemblySpecHash        *m_pDependencySpecs;

    CORCOMPILE_DEPENDENCY   *m_pDependencies;
    BYTE                    **m_pDependencyBindings;
    USHORT                   m_cDependenciesCount, m_cDependenciesAlloc;

    OBJECTHANDLE            m_hDemands;

    CQuickArray<RefCache*> m_rRefCaches;

    void AddDependencyEntry(PEFile *pFile, mdAssemblyRef ref, GUID *pmvid, PBYTE rgbHash, DWORD cbHash);
    HRESULT AddDependency(AssemblySpec *pRefSpec, IAssembly* pIAssembly, PEFile *pFile);

    void AddPermission(OBJECTREF demand);
    void AddPermissionSet(OBJECTREF demandSet);

  public:

    CompilationDomain();
    ~CompilationDomain();

    HRESULT Init();

    void EnterDomain(ContextTransitionFrame *pFrame);
    void ExitDomain(ContextTransitionFrame *pFrame);

    HRESULT BindAssemblySpec(AssemblySpec *pSpec, 
                             PEFile **ppFile,
                             IAssembly** ppIAssembly,
                             Assembly **ppDynamicAssembly,
                             OBJECTREF *pExtraEvidence,
                             OBJECTREF *pThrowable);

    HRESULT PredictAssemblySpecBinding(AssemblySpec *pSpec, GUID *pmvid, BYTE *pbHash, DWORD *pcbHash);

    void OnLinktimeCheck(Assembly *pAssembly, 
                         OBJECTREF refCasDemands,
                         OBJECTREF refNonCasDemands);
    void OnLinktimeCanCallUnmanagedCheck(Assembly *pAssembly);
    void OnLinktimeCanSkipVerificationCheck(Assembly * pAssembly);
    void OnLinktimeFullTrustCheck(Assembly *pAssembly);

    RefCache *GetRefCache(Module *pModule)
    {
        unsigned uSize = (unsigned) m_rRefCaches.Size();
        for (unsigned i = 0; i < uSize; i++)
            if (m_rRefCaches[i]->m_pModule == pModule)
                return m_rRefCaches[i];
        m_rRefCaches.ReSize(uSize + 1);
        m_rRefCaches[uSize] = new RefCache(pModule);
        return m_rRefCaches[uSize];
    }

    void SetTargetAssembly(Assembly *pAssembly) { m_pTargetAssembly = pAssembly; }

    OBJECTREF GetDemands() { return m_hDemands == NULL ? NULL : ObjectFromHandle(m_hDemands); } 

    // ICorCompilationDomain

    HRESULT __stdcall SetApplicationContext(IApplicationContext *pContext);
    HRESULT __stdcall SetContextInfo(LPCWSTR exePath, BOOL isExe);
    HRESULT __stdcall SetExplicitBindings(ICorZapBinding **ppBindings, 
                                          DWORD cBindings);
    HRESULT __stdcall SetDependencyEmitter(IMetaDataAssemblyEmit *pEmitter);
    HRESULT __stdcall GetDependencies(CORCOMPILE_DEPENDENCY **ppDependencies,
                                      DWORD *cDependencies);

};

#endif // COMPILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\compluswrapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  COMPlusWrapper.h
**
**
** Purpose: Contains types and method signatures for the Com wrapper class
**
** 
===========================================================*/
//---------------------------------------------------------------------------------
// COM PLUS WRAPPERS on COM objects
//  Purpose: wrap com objects to behave as COM+ objects
//  Reqmts:  Wrapper has to have the same layout as the COM+ objects
//
//  Data members of wrapper, are basically COM2 Interface pointers on the COM2 object
//  Interfaces that belong to the same object are stored in the same wrapper, IUnknown
//  pointer determines the identity of the object.
//  As new COM2 interfaces are seen on the same object, they need to be added to the 
//  wrapper, wrapper is allocated as a fixed size object with overflow chain.
//  
//  struct IPMap 
//  {
//      MethodTable *pMT; // identifies the com+ interface class
//      IUnknown*   m_ip; // COM IP
//  }
//  
//  Issues : Performance/Identity trade-offs, create new wrappers or find and reuse wrappers
//      we use a hash table to track the wrappers and reuse them, maintains identity
//  ComPlusWrapperCache class maintains the lookup table and handles the clean up
//  Cast operations: requires a QI, unless a QI for that interface was done previously
//  
//  Threading : apartment model COM objects have thread affinity
//              choices: COM+ can guarantee thread affinity by making sure
//                       the calls are always made on the right thread
//              Advantanges: avoid an extra marshalling 
//              Dis.Advt.  : need to make sure legacy apartment semantics are preserved
//                           this includes any wierd behaviour currently hacked into DCOM.
//
//  COM+ Wrappers: Interface map (IMap) won't have any entries, the method table of COM+
//  wrappers have a special flag to indicate that these COM+ objects
//  require special treatment for interface cast, call interface operations.
//  
//  Stubs : need to find the COM2 interface ptr, and the slot within the interface to
//          re-direct the call  
//  Marshalling params and results (common case should be fast)
//  
//-----------------------------------------------------------------------------------


#ifndef _COMPLUSWRAPPER_H
#define _COMPLUSWRAPPER_H

#include "vars.hpp"
#include "objecthandle.h"
#include "spinlock.h"
#include "interoputil.h"
#include "mngstdinterfaces.h"
#include "excep.h"
#include "comcache.h"
#include <member-offset-info.h>

class Object;
class EEClass;
class ComCallWrapper;
class Thread;

#define UNINITED_GIT ~0
#define NO_GIT 0

enum {CLEANUP_LIST_INIT_MAP_SIZE = 7};

//-------------------------------------------------------------------------
// Class that wraps an IClassFactory
// This class allows a Reflection Class to wrap an IClassFactory
// Class::GetClassFromProgID("ProgID", "Server") can be used to get a Class
// object that wraps an IClassFactory.
// Calling class.CreateInstance() will create an instance of the COM object and
// wrap it with a ComPlusWrapper, the wrapper can be cast to the appropriate interface
// and used.
// 
class ComClassFactory 
{
public:
    WCHAR*          m_pwszProgID;   // progId 
    CLSID           m_rclsid;       // CLSID
    WCHAR*          m_pwszServer;   // server name
    MethodTable*    m_pEEClassMT;   // method table of the EEClass

private:
    // We have two types of ComClassFactory:
    // 1. We build for reflection purpose.  We should not clean up.
    // 2. We build for IClassFactory.  We should clean up.
    BOOL            m_bManagedVersion;
    //-----------------------------------------------------------
    // constructor
    ComClassFactory(REFCLSID rclsid) 
    {
        memset(this, 0, sizeof(ComClassFactory));
        // Default to unmanaged version.
        m_bManagedVersion = FALSE;
        m_rclsid = rclsid;
    }

    //---------------------------------------------------------
    // destructor
    ~ComClassFactory()
    {
    }

    //---------------------------------------------------------
    // Mark this instance as Managed Version, so we will not do clean up.
    void SetManagedVersion()
    {
        m_bManagedVersion = TRUE;
    }
    
    //--------------------------------------------------------------
    // Init the ComClassFactory
    void Init(WCHAR* pwszProgID, WCHAR* pwszServer, MethodTable* pEEClassMT);

    //--------------------------------------------------------------
    // Retrieve the IClassFactory.
	HRESULT GetIClassFactory(IClassFactory **ppClassFactory);

    //-------------------------------------------------------------
    // ComClassFactory *ComClassFactory::AllocateComClassFactory(REFCLSID rclsid);  
    // helper function called to allocate an instace of the ComClassFactory.
    static ComClassFactory *AllocateComClassFactory(REFCLSID rclsid);  

    // Helper used by GetComClassFromProgID and GetComClassFromCLSID
    static void ComClassFactory::GetComClassHelper (OBJECTREF *pRef,
                                                    EEClassFactoryInfoHashTable *pClassFactHash,
                                                    ClassFactoryInfo *pClassFactInfo,
                                                    WCHAR *wszProgID);

public:
    //-------------------------------------------------------------
    // create instance, calls IClassFactory::CreateInstance
    OBJECTREF CreateInstance(MethodTable* pMTClass, BOOL ForManaged = FALSE);

    //-------------------------------------------------------------
    // static function to clean up
    // LPVOID param is a ComClassFactory
    static void Cleanup(LPVOID pv);

    //-------------------------------------------------------------
    // ComClassFactory::CreateAggregatedInstance(MethodTable* pMTClass)
    // create a COM+ instance that aggregates a COM instance
    OBJECTREF CreateAggregatedInstance(MethodTable* pMTClass, BOOL ForManaged);

    //-------------------------------------------------------------
    // static function to create an instance
    // LPVOID param is a ComClassFactory
    static OBJECTREF CreateInstance(LPVOID pv, EEClass* pClass);

    //-------------------------------------------------------------
    // HRESULT GetComClassFactory(MethodTable* pClassMT, ComClassFactory** ppComClsFac)
    // check if a ComClassFactory has been setup for this class
    // if not set one up
    static HRESULT GetComClassFactory(MethodTable* pClassMT, ComClassFactory** ppComClsFac);

    //--------------------------------------------------------------------------
    // GetComClassFromProgID used by reflection class to setup a Class based on ProgID
    static void GetComClassFromProgID(STRINGREF srefProgID, STRINGREF srefServer, OBJECTREF* pRef);

    //--------------------------------------------------------------------------
    // GetComClassFromCLSID used by reflection class to setup a Class based on CLSID
    static void GetComClassFromCLSID(REFCLSID clsid, STRINGREF srefServer, OBJECTREF* pRef);

    //--------------------------------------------------------------------------
    // Helper method to throw an exception based on the returned HRESULT from a 
    // call to create a COM object.
    void ThrowComCreationException(HRESULT hr, REFGUID rclsid);
};

enum {INTERFACE_ENTRY_CACHE_SIZE = 8};

//----------------------------------------------------------------------------
// ComPlusWrapper , internal class
// caches the IPs for a single com object, this wrapper is
// not in the GC heap, this allows us to grab a pointer to this block
// and play with-it without worrying about GC
struct ComPlusWrapper 
{
    IUnkEntry           m_UnkEntry;    // cookies for tracking IUnknown on the correct thread  
    InterfaceEntry      m_aInterfaceEntries[INTERFACE_ENTRY_CACHE_SIZE];
    LPVOID              m_pIdentity; // identity 
    IUnknown*           m_pUnknown; // outer unknown (not ref-counted)    
    OBJECTHANDLE        m_hRef; // weak pointer to the exposed object
    ULONG               m_cbRefCount; //ref-count
    ComPlusWrapperCache* m_pComPlusWrapperCache;   // Wrapper Cache
    
    // thread in which the wrapper has been created
    // if this thread is an STA thread, then when the STA dies
    // we need to cleanup this wrapper
    Thread*             m_pCreatorThread;

    // make sure the following field is aligned
    // as we use this for InterlockedExchange
    long                m_Busy; 
    union
    {
        unsigned        m_Flags;
        struct
        {
            BYTE        m_fLinkedToCCW;
            BYTE        m_fURTAggregated;
            BYTE        m_fURTContained;
            BYTE        m_fRemoteObject;           
        };
    };  

    LONG			m_cbInUseCount;

    // constructor
    ComPlusWrapper()
    {
        memset(this, 0,  sizeof(*this));
    }
    

    bool TryUpdateCache()
    {
        //@TODO, perf check 
        return FastInterlockExchange(&m_Busy, 1) == 0;
    }

    void EndUpdateCache()
    {
        m_Busy = 0;
    }

    //-----------------------------------------------------------
    // Init object ref
    int Init(OBJECTREF cref);

    //-------------------------------------------------
    // initialize IUnknown and Identity
    void Init(IUnknown*, LPVOID);

    //-------------------------------------------------
    // return exposed ComObject
    COMOBJECTREF GetExposedObject()
    {
        _ASSERTE(m_hRef != NULL);
        return (COMOBJECTREF)ObjectFromHandle(m_hRef);
    }

    //-----------------------------------------------
    // Free GC handle
    void FreeHandle();

    //---------------------------------------------------
    // Cleanup free all interface pointers
    void Cleanup();

    //-----------------------------------------------------
    // called during GC to do minor cleanup and schedule the ips to be
    // released
    void MinorCleanup();

    //-----------------------------------------------------
    // AddRef
    LONG AddRef();

    //-----------------------------------------------------
    // Release
    static LONG ExternalRelease(COMOBJECTREF cref);

    //---------------------------------------------------------
    // release on dummy wrappers, that we create during contention
    VOID CleanupRelease();

    // Create a new wrapper for a different method table that represents the same
    // COM object as the original wrapper.
    static ComPlusWrapper *CreateDuplicateWrapper(ComPlusWrapper *pOldWrap, MethodTable *pNewMT);

    //--------------------------------------------------------------------------------
    // Get COM IP from Wrapper, inline call for fast check in our cache, 
    // if not found call GetComIPFromWrapper 
    static inline IUnknown* InlineGetComIPFromWrapper(OBJECTREF oref, MethodTable* pIntf);

    //--------------------------------------------------------------------------
    // Same as InlineGetComIPFromWrapper but throws an exception if the 
    // interface is not supported.
    static inline IUnknown* GetComIPFromWrapperEx(OBJECTREF oref, MethodTable* pIntf);

    //--------------------------------------------------------------------------
    // out of line call, takes a lock, does a QI if the interface was not found in local cache
    IUnknown*  GetComIPFromWrapper(MethodTable* pIntf);
    
    //-----------------------------------------------------------------
    // fast call for a quick check in the cache
    static inline IUnknown* GetComIPFromWrapper(OBJECTREF oref, REFIID iid);
    //-----------------------------------------------------------------
    // out of line call
    IUnknown* GetComIPFromWrapper(REFIID iid);

    //-----------------------------------------------------------------
    // Retrieve correct COM IP for the current apartment.
    // use the cache /update the cache
    IUnknown *GetComIPForMethodTableFromCache(MethodTable * pMT);

    // helpers to get to IUnknown and IDispatch interfaces
    IUnknown  *GetIUnknown();
    IDispatch *GetIDispatch();

    // Remoting aware QI that will attempt to re-unmarshal on object disconnect.
    HRESULT SafeQueryInterfaceRemoteAware(IUnknown* pUnk, REFIID iid, IUnknown** pResUnk);

    IUnkEntry *GetUnkEntry()
    {
        return &m_UnkEntry;
    }

    BOOL IsValid()
    {
        // check if the handle is pointing to a valid object
        return (m_hRef != NULL && (*(ULONG *)m_hRef) != NULL);
    }

    BOOL SupportsIProvideClassInfo();

    VOID MarkURTAggregated()
    {
        _ASSERTE(m_fURTContained == 0);
        m_fURTAggregated = 1;
        m_fURTContained = 0;
    }

    VOID MarkURTContained()
    {
        _ASSERTE(m_fURTAggregated == 0);
        m_fURTAggregated = 0;
        m_fURTContained = 1;
    }


    BOOL IsURTAggregated()
    {
        if (m_fURTAggregated == 1)
        {
            _ASSERTE(m_fLinkedToCCW == 1);
        }
        return m_fURTAggregated == 1;
    }
        
    BOOL IsURTContained()
    {
        if (m_fURTContained == 1)
        {
            _ASSERTE(m_fLinkedToCCW == 1);
        }
        return m_fURTContained == 1;
    }

    BOOL IsURTExtended()
    {
        return IsURTAggregated() || IsURTContained();
    }


    VOID MarkRemoteObject()
    {
        _ASSERTE(m_fURTAggregated == 0 && m_fURTContained == 0);
        m_fRemoteObject = 1;
    }

    BOOL IsRemoteObject()
    {
        return m_fRemoteObject == 1;
    }        

    VOID MarkLinkedToCCW()
    {
        _ASSERTE(m_fURTAggregated == 0 && m_fURTContained == 0 && 
                            m_fRemoteObject == 0 && m_fLinkedToCCW == 0);
        m_fLinkedToCCW = 1;
    }

    BOOL IsLinkedToCCW()
    {
        if (m_fLinkedToCCW == 1)
        {            
            _ASSERTE(m_fURTAggregated == 1 || m_fURTContained == 1 || m_fRemoteObject == 1);
        }
        return m_fLinkedToCCW == 1;
    }
    
    // GetWrapper context cookie
    LPVOID GetWrapperCtxCookie()
    {
        return m_UnkEntry.m_pCtxCookie;
    }

    // Returns an addref'ed context entry
    CtxEntry *GetWrapperCtxEntry()
    {
        CtxEntry *pCtxEntry = m_UnkEntry.m_pCtxEntry;
        pCtxEntry->AddRef();
        return pCtxEntry;
    }

private:
    // Returns a non addref'ed context entry
    CtxEntry *GetWrapperCtxEntryNoAddRef()
    {
        return m_UnkEntry.m_pCtxEntry;
    }

    //---------------------------------------------------------------------
    // Callback called to release the IUnkEntry and the InterfaceEntries,
    static HRESULT __stdcall ReleaseAllInterfacesCallBack(LPVOID pData);

    //---------------------------------------------------------------------
    // Helper function called from ReleaseAllInterfaces_CallBack do do the 
    // actual releases.
    void ReleaseAllInterfaces();

	// DEBUG helpers to catch wrappers that get cleanedup
	// when in use
    VOID AddRefInUse()
    {
   		InterlockedIncrement(&m_cbInUseCount);
   	#ifdef _DEBUG
   		ValidateWrapper();
   	#endif
    }

	VOID ReleaseInUse()
	{
		InterlockedDecrement(&m_cbInUseCount);
	}
	
    BOOL IsWrapperInUse()
    {
   		return g_fEEShutDown ? FALSE : (m_cbInUseCount != 0);
    }	

    void ValidateWrapper();
};


//---------------------------------------------------------------------
// Comparison function for the hashmap used inside the 
// ComPlusWrapperCache.
//---------------------------------------------------------------------
inline BOOL ComPlusWrapperCompare(UPTR pWrap1, UPTR pWrap2)
{
    if (pWrap1 == NULL)
    {
        // If there is no value to compare againts, then always succeed 
        // the comparison.
        return TRUE;
    }
    else 
    {
        // Otherwise compare the wrapper pointers.
        return (pWrap1 << 1) == pWrap2;
    }
}


//---------------------------------------------------------------------
// ComPlusWrapper cache, act as the manager for the ComPlusWrappers
// uses a hash table to map IUnknown to the corresponding wrappers.
// There is one such cache per thread affinity domain.
//
// @TODO context cwb: revisit.  One could have a cache per thread affinity
// domain, or one per context.  It depends on how we do the handshake between
// ole32 and runtime contexts.  For now, we only worry about apartments, so
// thread affinity domains are sufficient.
//---------------------------------------------------------------------
class ComPlusWrapperCache
{
    friend class AppDomain;
    PtrHashMap      m_HashMap;
    // spin lock for fast synchronization
    SpinLock        m_lock;
    AppDomain       *m_pDomain;
public:
    ULONG           m_cbRef; 

    // static ComPlusWrapperCache* GetComPlusWrapperCache()
    static ComPlusWrapperCache* GetComPlusWrapperCache();


    // constructor
    ComPlusWrapperCache(AppDomain *pDomain);

    // Lookup wrapper, lookup hash table for a wrapper for a given IUnk
    ComPlusWrapper* LookupWrapper(LPVOID pUnk)
    {
        _ASSERTE(LOCKHELD());
        _ASSERTE(GetThread()->PreemptiveGCDisabled());

        ComPlusWrapper* pWrap = (ComPlusWrapper*)m_HashMap.Gethash((UPTR)pUnk);
        return (pWrap == (ComPlusWrapper*)INVALIDENTRY) ? NULL : pWrap;
    }

    // Insert wrapper for a given IUnk into hash table
    void InsertWrapper(LPVOID pUnk, ComPlusWrapper* pv)
    {
        _ASSERTE(LOCKHELD());
        _ASSERTE(GetThread()->PreemptiveGCDisabled());

        m_HashMap.InsertValue((UPTR)pUnk, pv);
    }

    // Delete wrapper for a given IUnk from hash table
    ComPlusWrapper* RemoveWrapper(ComPlusWrapper* pWrap)
    {
        // Note that the GC thread doesn't have to take the lock
        // since all other threads access in cooperative mode

        _ASSERTE(LOCKHELD() && GetThread()->PreemptiveGCDisabled()
                 || (g_pGCHeap->IsGCInProgress() && 
                     (dbgOnly_IsSpecialEEThread() || GetThread() == g_pGCHeap->GetGCThread())));

        _ASSERTE(pWrap != NULL);
        
        LPVOID pUnk;
        pUnk =   pWrap->m_pIdentity;
            
        _ASSERTE(pUnk != NULL);

        ComPlusWrapper* pWrap2 = (ComPlusWrapper*)m_HashMap.DeleteValue((UPTR)pUnk,pWrap);
        return (pWrap2 == (ComPlusWrapper*)INVALIDENTRY) ? NULL : pWrap2;
    }

    // Create a new wrapper for given IUnk, IDispatch
    static ComPlusWrapper* CreateComPlusWrapper(IUnknown *pUnk, LPVOID pIdentity);

    // setup a COMplus wrapper got thru DCOM for a remoted managed object
    //*** NOTE: make sure to pass the identity unknown to this function
    // the IUnk passed in shouldn't be AddRef'ed 

    ComPlusWrapper* SetupComPlusWrapperForRemoteObject(IUnknown* pUnk, OBJECTREF oref);

    
    //  Lookup to see if we already have an valid wrapper in cache for this IUnk
    ComPlusWrapper*  FindWrapperInCache(IUnknown* pIdentity);

    //  Lookup to see if we already have a wrapper else insert this wrapper
    //  return a valid wrapper that has been inserted into the cache
    ComPlusWrapper* FindOrInsertWrapper(IUnknown* pIdentity, ComPlusWrapper* pWrap);

    // free wrapper, cleans up the wrapper, 
    void FreeComPlusWrapper(ComPlusWrapper *pWrap)
    {       
        // clean up the data
        pWrap->Cleanup();
    }

    // Lock and Unlock, use a very fast lock like a spin lock
    void LOCK()
    {
        // Everybody must access the thread in cooperative mode or we might deadlock
        _ASSERTE(GetThread()->PreemptiveGCDisabled());

        m_lock.GetLock();

        // No GC points when lock is held or we might deadlock with GC
        BEGINFORBIDGC();
    }

    void UNLOCK()
    {
        ENDFORBIDGC();
        m_lock.FreeLock();
    }

#ifdef _DEBUG
    BOOL LOCKHELD()
    {
        return m_lock.OwnedByCurrentThread();
    }
#endif

    ULONG AddRef()
    {
        ULONG cbRef = FastInterlockIncrement((LONG *)&m_cbRef);
        LOG((LF_INTEROP, LL_INFO100, "ComPlusWrapperCache::Addref %8.8x with %d in domain %8.8x %S\n", this, cbRef, GetDomain() ,GetDomain()->GetFriendlyName(FALSE)));
        return cbRef;
    }

    ULONG Release()
    {
        ULONG cbRef = FastInterlockDecrement((LONG *)&m_cbRef);
        LOG((LF_INTEROP, LL_INFO100, "ComPlusWrapperCache::Release %8.8x with %d in domain %8.8x %S\n", this, m_cbRef, GetDomain(), GetDomain() ? GetDomain()->GetFriendlyName(FALSE) : NULL));
        if (cbRef < 1)
            delete this;
        return cbRef;
    }
    
    AppDomain *GetDomain()
    {
        return m_pDomain;
    }
   
    //  Helper to release the all complus wrappers in the specified context. Or in
    //  all the contexts if pCtxCookie is null.
    static void ReleaseComPlusWrappers(LPVOID pCtxCookie);

protected:
    // Helper function called from the static ReleaseComPlusWrappers.
    ULONG ReleaseWrappers(LPVOID pCtxCookie);
};

enum {CLEANUP_LIST_GROUP_SIZE = 256};

//--------------------------------------------------------------------------
// A group of wrappers in the same context to clean up.
// NOTE: This data structure is NOT synchronized.
//--------------------------------------------------------------------------

class ComPlusContextCleanupGroup
{
    friend struct MEMBER_OFFSET_INFO(ComPlusContextCleanupGroup);
public:
    ComPlusContextCleanupGroup(CtxEntry *pCtxEntry, ComPlusContextCleanupGroup *pNext)
    : m_pNext(pNext)
    , m_dwNumWrappers(0)
    , m_pCtxEntry(pCtxEntry)
    {
        // Addref the context entry.
        m_pCtxEntry->AddRef();
    }

    ~ComPlusContextCleanupGroup()
    {
        // Make sure all the wrappers have been cleaned up.
        _ASSERTE(m_dwNumWrappers == 0);

        // Release the context entry.
        m_pCtxEntry->Release();
    }

    BOOL IsFull()
    {
        return m_dwNumWrappers == CLEANUP_LIST_GROUP_SIZE;
    }

    ComPlusContextCleanupGroup *GetNext()
    {
        return m_pNext;
    }

    LPVOID GetCtxCookie()
    {
        return m_pCtxEntry->GetCtxCookie();
    }

    CtxEntry *GetCtxEntry()
    {
        m_pCtxEntry->AddRef();
        return m_pCtxEntry;
    }

    void AddWrapper(ComPlusWrapper *pRCW)
    {
        _ASSERTE(m_dwNumWrappers < CLEANUP_LIST_GROUP_SIZE);
        m_apWrapper[m_dwNumWrappers++] = pRCW;
    }

    void CleanUpWrappers()
    {
        // Call clean up on all the wrappers in the group.
        for (DWORD i = 0; i < m_dwNumWrappers; i++)
            m_apWrapper[i]->Cleanup();

        // Reset the number of wrappers back to 0.
        m_dwNumWrappers = 0;
    }

private:
    ComPlusContextCleanupGroup *        m_pNext;
    ComPlusWrapper *                    m_apWrapper[CLEANUP_LIST_GROUP_SIZE];
    DWORD                               m_dwNumWrappers;
    CtxEntry *                          m_pCtxEntry;
};

//--------------------------------------------------------------------------
// A group of wrappers in the same apartment to clean up.
// NOTE: This data structure is NOT synchronized.
//--------------------------------------------------------------------------
class ComPlusApartmentCleanupGroup
{
    friend struct MEMBER_OFFSET_INFO(ComPlusApartmentCleanupGroup);
public:
    ComPlusApartmentCleanupGroup(Thread *pSTAThread);
    ~ComPlusApartmentCleanupGroup();

    static BOOL TrustMeIAmSafe(void *pLock)
    {
        return TRUE;
    }

    // Initialization method.
    BOOL Init(Crst *pCrst)
    {
        _ASSERTE(m_pSTAThread != NULL || pCrst != NULL);

        // The synchronization of the hash table is a bit complex.
     