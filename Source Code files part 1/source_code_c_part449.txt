   // check input format - dont check output: being asked to give one back
    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = NULL;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	// If the current disply mode is 8 bit return a size large enough
	// to hold a 256 palette after the BMIh
	hDC = GetDC(NULL);
	f8Bit = (8 == GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES));
	ReleaseDC(NULL, hDC);
#ifdef FORCE_8BIT_OUTPUT // { FORCE_8BIT_OUTPUT
	f8Bit = TRUE;
#endif // } FORCE_8BIT_OUTPUT
#if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT) // { if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)
	f8Bit = FALSE;
#endif // } if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)

    // if lpbiDst == NULL return size required to hold a output format
    // (add palette size)
    if (lpbiDst == NULL) 
		return(sizeof(BITMAPINFOHEADER) + (int)(f8Bit ? 1024 : 0));

	if (lpbiSrc == NULL) 
		return (DWORD)ICERR_ERROR;

	lpbiDst->biSize = sizeof(BITMAPINFOHEADER);
#ifdef FORCE_ZOOM_BY_2 // { FORCE_ZOOM_BY_2
    lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
    lpbiDst->biHeight = lpbiSrc->biHeight << 1;
#else // }{ FORCE_ZOOM_BY_2
    lpbiDst->biWidth  = lpbiSrc->biWidth;
    lpbiDst->biHeight = lpbiSrc->biHeight;
#endif // } FORCE_ZOOM_BY_2
#ifdef FORCE_16BIT_OUTPUT // { FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = 16;
#else // }{ FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = (int)(f8Bit ? 8 : 24);
#endif // } FORCE_16BIT_OUTPUT
	lpbiDst->biPlanes = 1;
	lpbiDst->biCompression =  BI_RGB;
	lpbiDst->biXPelsPerMeter = 0;
	lpbiDst->biYPelsPerMeter = 0;
	lpbiDst->biSizeImage = (DWORD) WIDTHBYTES(lpbiDst->biWidth * lpbiDst->biBitCount) * lpbiDst->biHeight;
	lpbiDst->biClrUsed = lpbiDst->biClrImportant = 0;

	if (f8Bit)
	{
		// Copy the palette
		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER) + 40;        // fill in starting from the 10th
		for(i = 0; i < (236 << 2); i++)
			*lpPalArea++ = PalTable[i]; 

		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER);   // reverse r&b: dealing with DIBs
		for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
								// fixed by CZHU, 1/23/95
		{
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea+=4;
		}
	}

	return ICERR_OK;
}

/**********************************************************************
 * DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL)
 *  Description:    Provides codec indication to prepare to receive
 *                 decompress requests for a particular input to output
 *                 conversion.  Begins arrive asynchronously, and should
 *                 result in the codec adapting to the changes specified,
 *                 if any.
 *
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressBegin(
    LPDECINST           lpInst, 
    ICDECOMPRESSEX FAR *lpicDecEx, 
    BOOL                bIsDCI)
{
	int     CodecID;
	DWORD   dw;
	UINT    ClrCnvtr;
	LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;

	// AviEdit tends to call ICDecompressBegin too soon...
	if (!lpInst || !lpicDecEx)
		return((DWORD)ICERR_ERROR);

	// Set source and destination pointers
	lpbiSrc = lpicDecEx->lpbiSrc;
	lpbiDst = lpicDecEx->lpbiDst;

    // at begin need to know input and output sizes
    if (!lpbiSrc || !lpbiDst)
		return((DWORD)ICERR_BADFORMAT);

    if(lpInst->Initialized == TRUE)	
    {
		/* We assume the source dimensions never change.  If they do change
		 * we should terminate the instance because the allocations are
		 * based on dimensions.  Until we add code to do that we need this
		 * assertion.
		 */
    	ASSERT(lpInst->xres == (WORD)lpbiSrc->biWidth);
    	ASSERT(lpInst->yres == (WORD)lpbiSrc->biHeight);
		
		if(lpbiDst != NULL)	
        { 
		    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
            {
				return(dw);    // error
			} 
            else 
            {    // apply changes
				lpInst->XScale = lpInst->pXScale;
				lpInst->YScale = lpInst->pYScale;
				lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
				lpInst->outputDepth = lpbiDst->biBitCount;
				ClrCnvtr = SelectConvertor(lpInst,lpbiDst, bIsDCI); 
				if (ClrCnvtr != lpInst->uColorConvertor ) 
                {
					if((dw = H263TermColorConvertor(lpInst)) == ICERR_OK)
					    dw = H263InitColorConvertor(lpInst, ClrCnvtr); 
					lpInst->uColorConvertor=ClrCnvtr; 
				}
				return(dw);
			}
	    }
	}

    // first time begin - check if this is a format I like
    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
    {
		return(dw);    // error
	} 
    else 
    {    // apply proposed format to 'current' format
		lpInst->XScale = lpInst->pXScale;
		lpInst->YScale = lpInst->pYScale;
		lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
		lpInst->outputDepth = lpbiDst->biBitCount;
	}
    
    if  (lpbiSrc->biCompression == FOURCC_H263)
    {
         CodecID = H263_CODEC;
    }
    else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	     CodecID = YUV12_CODEC;
	}

    if(dw = H263InitDecoderInstance(lpInst, CodecID)) 
    {
		return(dw);
	}
    ClrCnvtr = SelectConvertor(lpInst, lpbiDst, bIsDCI);
    dw = H263InitColorConvertor(lpInst, ClrCnvtr);
    
    return(dw);
}

/**********************************************************************
 * DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESS FAR *, DWORD);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL Decompress(
	LPDECINST           lpInst, 
	ICDECOMPRESSEX FAR *lpicDecEx, 
	DWORD               dwSize,
	BOOL                bIsDCI)
{
    DWORD ret = (DWORD) ICERR_ERROR;

	// Check for NULL parameters
    if ((lpInst == NULL) || (lpInst->Initialized != TRUE) || (lpicDecEx == NULL) ||
		(lpicDecEx->lpbiSrc == NULL) || (lpicDecEx->lpbiDst == NULL)) 
		goto done;

    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) 
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_YUV12)
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_IYUV) )
	{
		try
		{ 
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI);
		}
		catch (...)
		{
			// For a DEBUG build, display a message and pass the exception up.
			// For a release build, stop the exception here and return an error
			// code.  This gives upstream code a chance to gracefully recover.
			// We also need to clear the floating point control word, otherwise
			// the upstream code may incur an exception the next time it tries
			// a floating point operation (presuming this exception was due
			// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
			DBOUT("Exception during H263Decompress!!!");
			throw;
#else
			_clearfp();
			ret = (DWORD) ICERR_ERROR;
#endif
		}
	}

done:
	return ret;
}


/**********************************************************************
 * DWORD PASCAL DecompressEnd(LPDECINST);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressEnd(LPDECINST lpInst)
{
	if(lpInst && lpInst->Initialized == TRUE) 
    {
	    H263TermColorConvertor(lpInst);
	    H263TermDecoderInstance(lpInst);
	}

    return ICERR_OK;
}


/*****************************************************************************
 *
 * DecompressSetPalette() is called from the ICM_DECOMPRESS_SET_PALETTE
 * message.
 *
 * Fill in the palette using lpParam1.
 *
 ****************************************************************************/
DWORD PASCAL DecompressSetPalette(LPDECINST pinst,
						 LPBITMAPINFOHEADER lpbi,
						 LPBITMAPINFOHEADER unused)
{
	int i;
	unsigned char FAR * palette;
	RGBQUAD FAR *palptr;

	// Check for NULL parameter
	if (pinst == NULL)
	{
		return (DWORD)ICERR_ERROR;
	}

	pinst->InitActivePalette = 0;	/* must re-init AP at Begin */
	pinst->UseActivePalette = 0;	/* must re-init AP at Begin */
    
 	if (lpbi && (lpbi->biBitCount == 8 && lpbi->biCompression == 0))
	{
 		palette = (unsigned char FAR *)lpbi + (int)lpbi->biSize;
        
 		// Check if palette passed is identity
		for (i = 0*4, palptr = (RGBQUAD FAR *)PalTable; i < 236*4; 
             i += 4, palptr++)
		{
			if (palette[i+40] != palptr->rgbRed ||
				palette[i+41] != palptr->rgbGreen ||
				palette[i+42] != palptr->rgbBlue
               )
				break;
		}

		if (i < 236*4)
		{	/* broke early - not the identity palette */
			/* Actually RGBQUAD (BGR) format. */
			if (
				#ifdef WIN32
				 memcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
				#else
				 _fmemcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
				#endif
				)
			{	/* same as last palette - don't re-init AP */
				DBOUT("current active palette");
				pinst->UseActivePalette  = 1;
				pinst->InitActivePalette = 1;
			}
			else
			{
				DBOUT("new active palette");
				#ifdef WIN32
				memcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
				#else
				_fmemcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
				#endif
				pinst->UseActivePalette = 1;
			}
		}
		else
		{   
            DBOUT("DecompressSetPalette:fixed \n");
		}
	}
	else
	{      
        DBOUT("DecompressSetPalette:NULL fixed \n");
	}

	return ICERR_OK;
}

/**********************************************************************
 * Added to support the IH26XSnapshot interface.
 * The essence of this code is to set up the Snapshot fields in the Decoder
 * Catalog and then wait on an Event for the Decoder to do the copy.
 * Ben - 09/23/95
 **********************************************************************/
DWORD PASCAL Snapshot(LPDECINST lpInst, LPVOID pvBuffer, DWORD dwTimeout)
{
	DWORD dwReturn;
	U8 FAR * P32Inst;
	T_H263DecoderCatalog * DC = NULL;
	UINT uiSZ_Snapshot;
	int WaitCounter = 10;			// Number of retries in case of slowness.

  	/* check the input pointers */
	if(IsBadWritePtr( (LPVOID)lpInst, sizeof(DECINSTINFO) ))
	{
        DBOUT("Snapshot:Decoder instance invalid \n");
    	dwReturn = (DWORD)ICERR_BADPARAM;
    	goto SnapshotDone;
	}

    /* Lock the memory */
	if(lpInst->pDecoderInst == NULL)
	{
        DBOUT("Snapshot:Decoder catalog invalid \n");
		dwReturn = (DWORD)ICERR_MEMORY;
		goto  SnapshotDone;
	}

	/* Build the decoder catalog pointer */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	DC = (T_H263DecoderCatalog FAR *) P32Inst;

	/* Check that input buffer is large enough for Snapshot */
	uiSZ_Snapshot = (DC->uFrameWidth * DC->uFrameHeight * 12) >> 3;
	if(IsBadWritePtr(pvBuffer, uiSZ_Snapshot))
	{
        DBOUT("Snapshot:Decoder buffer invalid \n");
		dwReturn = (DWORD)ICERR_MEMORY;
		goto  SnapshotDone;
	}

	/* Check the Snapshot request flag. */
	if(DC->SnapshotRequest)
	{
        DBOUT("Snapshot:in progress \n");
    	dwReturn = (DWORD)ICERR_ABORT;
    	goto SnapshotDone;
	}

	/*********************************************************************/
	/* OK. Everything looks good. Lets set the pointer, trigger the copy */
	/* and then wait on the event for the decoder to do the copy.        */
	/* IMPORTANT: the order of these next three statements makes a       */
	/* critical section unnecessary.                                     */
	ResetEvent(DC->SnapshotEvent);              /* First ...             */
	DC->SnapshotBuffer = pvBuffer;              /* Second ...            */
	DC->SnapshotRequest = SNAPSHOT_REQUESTED;   /* Third ...             */
	/*********************************************************************/

SnapshotWait:

	/*********************************************************************/
	/* If wait is abondoned or a timeout occurs, but the Snapshot copy   */
	/* has started, I will loop back here up to WaitCounter times hoping */
	/* hoping that the copy in progress will complete soon.              */
	/*********************************************************************/

	dwReturn = WaitForSingleObject(DC->SnapshotEvent, dwTimeout);

	/* Check result of wait. */
	switch(dwReturn)
	{
	case WAIT_ABANDONED:	// Non-Signaled
        DBOUT("Snapshot:Wait abandoned \n");
 		if(DC->SnapshotRequest == SNAPSHOT_COPY_STARTED)
		{
			WaitCounter--;
			if(WaitCounter)
			{
				goto SnapshotWait;
			}
		}
   	dwReturn = (DWORD)ICERR_ABORT;
		break;
	case WAIT_TIMEOUT:		// Non-Signaled
        DBOUT("Snapshot:Wait timeout \n");
 		if(DC->SnapshotRequest == SNAPSHOT_COPY_STARTED)
		{
			WaitCounter--;
			if(WaitCounter)
			{
				goto SnapshotWait;
			}
		}
    	dwReturn = (DWORD)ICERR_ABORT;
		break;
	case WAIT_OBJECT_0:		// Signaled - Yep, this is the good one!
        DBOUT("Snapshot:Wait timeout 0\n");
		switch(DC->SnapshotRequest)
		{
		case SNAPSHOT_COPY_REJECTED:
            DBOUT("Snapshot:Copy rejected \n");
	    	dwReturn = (DWORD)ICERR_ERROR;
			break;
		case SNAPSHOT_COPY_FINISHED:
            DBOUT("Snapshot:Copy finished \n");
	    	dwReturn = (DWORD)ICERR_OK;
			break;
		}
		break;
	default:				// Call failed - This should be a WAIT_FAILED, but hey what the heck
        DBOUT("Snapshot:Wait failed \n");
    	dwReturn = (DWORD)ICERR_ERROR;
		break;
	}

SnapshotDone:
    if(NULL != DC)
	{
	    DC->SnapshotRequest = 0;
    }

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxpal.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:05:16  $
;// $Archive:   S:\h26x\src\dec\dxpal.cpv  $
;// $Header:   S:\h26x\src\dec\dxpal.cpv   1.2   22 Dec 1995 14:05:16   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxpal.cpv  $
// 
//    Rev 1.2   22 Dec 1995 14:05:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   03 Nov 1995 11:49:48   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.0   31 Jul 1995 13:00:52   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:28   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:56   CZHU
// Initial revision.

#include "precomp.h"

#ifdef USE_WIN95_PAL // { USE_WIN95_PAL
unsigned char PalTable[236*4] = {
	   4,   4,   4, PC_NOCOLLAPSE,
	   8,   8,   8, PC_NOCOLLAPSE,
	  12,  12,  12, PC_NOCOLLAPSE,
	  17,  17,  17, PC_NOCOLLAPSE,
	  22,  22,  22, PC_NOCOLLAPSE,
	  28,  28,  28, PC_NOCOLLAPSE,
	  34,  34,  34, PC_NOCOLLAPSE,
	  41,  41,  41, PC_NOCOLLAPSE,
	  85,  85,  85, PC_NOCOLLAPSE,
	  77,  77,  77, PC_NOCOLLAPSE,
	  66,  66,  66, PC_NOCOLLAPSE,
	  57,  57,  57, PC_NOCOLLAPSE,
	 255, 124, 128, PC_NOCOLLAPSE,
	 255,  80,  80, PC_NOCOLLAPSE,
	 214,   0, 147, PC_NOCOLLAPSE,
	 204, 236, 255, PC_NOCOLLAPSE,
	 239, 214, 198, PC_NOCOLLAPSE,
	 231, 231, 214, PC_NOCOLLAPSE,
	 173, 169, 144, PC_NOCOLLAPSE,
	  51,   0,   0, PC_NOCOLLAPSE,
	 102,   0,   0, PC_NOCOLLAPSE,
	 153,   0,   0, PC_NOCOLLAPSE,
	 204,   0,   0, PC_NOCOLLAPSE,
	   0,  51,   0, PC_NOCOLLAPSE,
	  51,  51,   0, PC_NOCOLLAPSE,
	 102,  51,   0, PC_NOCOLLAPSE,
	 153,  51,   0, PC_NOCOLLAPSE,
	 204,  51,   0, PC_NOCOLLAPSE,
	 255,  51,   0, PC_NOCOLLAPSE,
	   0, 102,   0, PC_NOCOLLAPSE,
	  51, 102,   0, PC_NOCOLLAPSE,
	 102, 102,   0, PC_NOCOLLAPSE,
	 153, 102,   0, PC_NOCOLLAPSE,
	 204, 102,   0, PC_NOCOLLAPSE,
	 255, 102,   0, PC_NOCOLLAPSE,
	   0, 153,   0, PC_NOCOLLAPSE,
	  51, 153,   0, PC_NOCOLLAPSE,
	 102, 153,   0, PC_NOCOLLAPSE,
	 153, 153,   0, PC_NOCOLLAPSE,
	 204, 153,   0, PC_NOCOLLAPSE,
	 255, 153,   0, PC_NOCOLLAPSE,
	   0, 204,   0, PC_NOCOLLAPSE,
	  51, 204,   0, PC_NOCOLLAPSE,
	 102, 204,   0, PC_NOCOLLAPSE,
	 153, 204,   0, PC_NOCOLLAPSE,
	 204, 204,   0, PC_NOCOLLAPSE,
	 255, 204,   0, PC_NOCOLLAPSE,
	 102, 255,   0, PC_NOCOLLAPSE,
	 153, 255,   0, PC_NOCOLLAPSE,
	 204, 255,   0, PC_NOCOLLAPSE,
	   0,   0,  51, PC_NOCOLLAPSE,
	  51,   0,  51, PC_NOCOLLAPSE,
	 102,   0,  51, PC_NOCOLLAPSE,
	 153,   0,  51, PC_NOCOLLAPSE,
	 204,   0,  51, PC_NOCOLLAPSE,
	 255,   0,  51, PC_NOCOLLAPSE,
	   0,  51,  51, PC_NOCOLLAPSE,
	  51,  51,  51, PC_NOCOLLAPSE,
	 102,  51,  51, PC_NOCOLLAPSE,
	 153,  51,  51, PC_NOCOLLAPSE,
	 204,  51,  51, PC_NOCOLLAPSE,
	 255,  51,  51, PC_NOCOLLAPSE,
	   0, 102,  51, PC_NOCOLLAPSE,
	  51, 102,  51, PC_NOCOLLAPSE,
	 102, 102,  51, PC_NOCOLLAPSE,
	 153, 102,  51, PC_NOCOLLAPSE,
	 204, 102,  51, PC_NOCOLLAPSE,
	 255, 102,  51, PC_NOCOLLAPSE,
	   0, 153,  51, PC_NOCOLLAPSE,
	  51, 153,  51, PC_NOCOLLAPSE,
	 102, 153,  51, PC_NOCOLLAPSE,
	 153, 153,  51, PC_NOCOLLAPSE,
	 204, 153,  51, PC_NOCOLLAPSE,
	 255, 153,  51, PC_NOCOLLAPSE,
	   0, 204,  51, PC_NOCOLLAPSE,
	  51, 204,  51, PC_NOCOLLAPSE,
	 102, 204,  51, PC_NOCOLLAPSE,
	 153, 204,  51, PC_NOCOLLAPSE,
	 204, 204,  51, PC_NOCOLLAPSE,
	 255, 204,  51, PC_NOCOLLAPSE,
	  51, 255,  51, PC_NOCOLLAPSE,
	 102, 255,  51, PC_NOCOLLAPSE,
	 153, 255,  51, PC_NOCOLLAPSE,
	 204, 255,  51, PC_NOCOLLAPSE,
	 255, 255,  51, PC_NOCOLLAPSE,
	   0,   0, 102, PC_NOCOLLAPSE,
	  51,   0, 102, PC_NOCOLLAPSE,
	 102,   0, 102, PC_NOCOLLAPSE,
	 153,   0, 102, PC_NOCOLLAPSE,
	 204,   0, 102, PC_NOCOLLAPSE,
	 255,   0, 102, PC_NOCOLLAPSE,
	   0,  51, 102, PC_NOCOLLAPSE,
	  51,  51, 102, PC_NOCOLLAPSE,
	 102,  51, 102, PC_NOCOLLAPSE,
	 153,  51, 102, PC_NOCOLLAPSE,
	 204,  51, 102, PC_NOCOLLAPSE,
	 255,  51, 102, PC_NOCOLLAPSE,
	   0, 102, 102, PC_NOCOLLAPSE,
	  51, 102, 102, PC_NOCOLLAPSE,
	 102, 102, 102, PC_NOCOLLAPSE,
	 153, 102, 102, PC_NOCOLLAPSE,
	 204, 102, 102, PC_NOCOLLAPSE,
	   0, 153, 102, PC_NOCOLLAPSE,
	  51, 153, 102, PC_NOCOLLAPSE,
	 102, 153, 102, PC_NOCOLLAPSE,
	 153, 153, 102, PC_NOCOLLAPSE,
	 204, 153, 102, PC_NOCOLLAPSE,
	 255, 153, 102, PC_NOCOLLAPSE,
	   0, 204, 102, PC_NOCOLLAPSE,
	  51, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 102, PC_NOCOLLAPSE,
	 204, 204, 102, PC_NOCOLLAPSE,
	 255, 204, 102, PC_NOCOLLAPSE,
	   0, 255, 102, PC_NOCOLLAPSE,
	  51, 255, 102, PC_NOCOLLAPSE,
	 153, 255, 102, PC_NOCOLLAPSE,
	 204, 255, 102, PC_NOCOLLAPSE,
	 255,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 255, PC_NOCOLLAPSE,
	   0, 153, 153, PC_NOCOLLAPSE,
	 153,  51, 153, PC_NOCOLLAPSE,
	 153,   0, 153, PC_NOCOLLAPSE,
	 204,   0, 153, PC_NOCOLLAPSE,
	   0,   0, 153, PC_NOCOLLAPSE,
	  51,  51, 153, PC_NOCOLLAPSE,
	 102,   0, 153, PC_NOCOLLAPSE,
	 204,  51, 153, PC_NOCOLLAPSE,
	 255,   0, 153, PC_NOCOLLAPSE,
	   0, 102, 153, PC_NOCOLLAPSE,
	  51, 102, 153, PC_NOCOLLAPSE,
	 102,  51, 153, PC_NOCOLLAPSE,
	 153, 102, 153, PC_NOCOLLAPSE,
	 204, 102, 153, PC_NOCOLLAPSE,
	 255,  51, 153, PC_NOCOLLAPSE,
	  51, 153, 153, PC_NOCOLLAPSE,
	 102, 153, 153, PC_NOCOLLAPSE,
	 153, 153, 153, PC_NOCOLLAPSE,
	 204, 153, 153, PC_NOCOLLAPSE,
	 255, 153, 153, PC_NOCOLLAPSE,
	   0, 204, 153, PC_NOCOLLAPSE,
	  51, 204, 153, PC_NOCOLLAPSE,
	 102, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 153, PC_NOCOLLAPSE,
	 204, 204, 153, PC_NOCOLLAPSE,
	 255, 204, 153, PC_NOCOLLAPSE,
	   0, 255, 153, PC_NOCOLLAPSE,
	  51, 255, 153, PC_NOCOLLAPSE,
	 102, 204, 153, PC_NOCOLLAPSE,
	 153, 255, 153, PC_NOCOLLAPSE,
	 204, 255, 153, PC_NOCOLLAPSE,
	 255, 255, 153, PC_NOCOLLAPSE,
	   0,   0, 204, PC_NOCOLLAPSE,
	  51,   0, 153, PC_NOCOLLAPSE,
	 102,   0, 204, PC_NOCOLLAPSE,
	 153,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 204, PC_NOCOLLAPSE,
	   0,  51, 153, PC_NOCOLLAPSE,
	  51,  51, 204, PC_NOCOLLAPSE,
	 102,  51, 204, PC_NOCOLLAPSE,
	 153,  51, 204, PC_NOCOLLAPSE,
	 204,  51, 204, PC_NOCOLLAPSE,
	 255,  51, 204, PC_NOCOLLAPSE,
	   0, 102, 204, PC_NOCOLLAPSE,
	  51, 102, 204, PC_NOCOLLAPSE,
	 102, 102, 153, PC_NOCOLLAPSE,
	 153, 102, 204, PC_NOCOLLAPSE,
	 204, 102, 204, PC_NOCOLLAPSE,
	 255, 102, 153, PC_NOCOLLAPSE,
	   0, 153, 204, PC_NOCOLLAPSE,
	  51, 153, 204, PC_NOCOLLAPSE,
	 102, 153, 204, PC_NOCOLLAPSE,
	 153, 153, 204, PC_NOCOLLAPSE,
	 204, 153, 204, PC_NOCOLLAPSE,
	 255, 153, 204, PC_NOCOLLAPSE,
	   0, 204, 204, PC_NOCOLLAPSE,
	  51, 204, 204, PC_NOCOLLAPSE,
	 102, 204, 204, PC_NOCOLLAPSE,
	 153, 204, 204, PC_NOCOLLAPSE,
	 204, 204, 204, PC_NOCOLLAPSE,
	 255, 204, 204, PC_NOCOLLAPSE,
	   0, 255, 204, PC_NOCOLLAPSE,
	  51, 255, 204, PC_NOCOLLAPSE,
	 102, 255, 153, PC_NOCOLLAPSE,
	 153, 255, 204, PC_NOCOLLAPSE,
	 204, 255, 204, PC_NOCOLLAPSE,
	 255, 255, 204, PC_NOCOLLAPSE,
	  51,   0, 204, PC_NOCOLLAPSE,
	 102,   0, 255, PC_NOCOLLAPSE,
	 153,   0, 255, PC_NOCOLLAPSE,
	   0,  51, 204, PC_NOCOLLAPSE,
	  51,  51, 255, PC_NOCOLLAPSE,
	 102,  51, 255, PC_NOCOLLAPSE,
	 153,  51, 255, PC_NOCOLLAPSE,
	 204,  51, 255, PC_NOCOLLAPSE,
	 255,  51, 255, PC_NOCOLLAPSE,
	   0, 102, 255, PC_NOCOLLAPSE,
	  51, 102, 255, PC_NOCOLLAPSE,
	 102, 102, 204, PC_NOCOLLAPSE,
	 153, 102, 255, PC_NOCOLLAPSE,
	 204, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 204, PC_NOCOLLAPSE,
	   0, 153, 255, PC_NOCOLLAPSE,
	  51, 153, 255, PC_NOCOLLAPSE,
	 102, 153, 255, PC_NOCOLLAPSE,
	 153, 153, 255, PC_NOCOLLAPSE,
	 204, 153, 255, PC_NOCOLLAPSE,
	 255, 153, 255, PC_NOCOLLAPSE,
	   0, 204, 255, PC_NOCOLLAPSE,
	  51, 204, 255, PC_NOCOLLAPSE,
	 102, 204, 255, PC_NOCOLLAPSE,
	 153, 204, 255, PC_NOCOLLAPSE,
	 204, 204, 255, PC_NOCOLLAPSE,
	 255, 204, 255, PC_NOCOLLAPSE,
	  51, 255, 255, PC_NOCOLLAPSE,
	 102, 255, 204, PC_NOCOLLAPSE,
	 153, 255, 255, PC_NOCOLLAPSE,
	 204, 255, 255, PC_NOCOLLAPSE,
	 255, 102, 102, PC_NOCOLLAPSE,
	 102, 255, 102, PC_NOCOLLAPSE,
	 255, 255, 102, PC_NOCOLLAPSE,
	 102, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 255, PC_NOCOLLAPSE,
	 102, 255, 255, PC_NOCOLLAPSE,
	 165,   0,  33, PC_NOCOLLAPSE,
	  95,  95,  95, PC_NOCOLLAPSE,
	 119, 119, 119, PC_NOCOLLAPSE,
	 134, 134, 134, PC_NOCOLLAPSE,
	 150, 150, 150, PC_NOCOLLAPSE,
	 203, 203, 203, PC_NOCOLLAPSE,
	 178, 178, 178, PC_NOCOLLAPSE,
	 215, 215, 215, PC_NOCOLLAPSE,
	 221, 221, 221, PC_NOCOLLAPSE,
	 227, 227, 227, PC_NOCOLLAPSE,
	 234, 234, 234, PC_NOCOLLAPSE,
	 241, 241, 241, PC_NOCOLLAPSE,
	 248, 248, 248, PC_NOCOLLAPSE
};
#else // }{ USE_WIN95_PAL
unsigned char PalTable[236*4] = {
                              0,  39+ 15,       0,  PC_NOCOLLAPSE,
                              0,  39+ 24,       0,  PC_NOCOLLAPSE,
                              0,  39+ 33,       0,  PC_NOCOLLAPSE,
                              0,  39+ 42,       0,  PC_NOCOLLAPSE,
                        -44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
                        -44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
                        -44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
                        -44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
                        -44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
                        -44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
                        -44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
                        -44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
                        -44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
                        -44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
                        -44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
                        -44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
                        -44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
                        -44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
                        -44+222,     255, -55+222,  PC_NOCOLLAPSE,
                        -44+231,     255, -55+231,  PC_NOCOLLAPSE,
                        -44+240,     255, -55+240,  PC_NOCOLLAPSE,

                              0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
                              0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
                              0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                              0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                        -44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
                        -44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
                        -44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
                        -44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
                        -44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
                        -44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
                        -44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
                        -44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
                        -44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
                        -44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
                        -44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
                        -44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
                        -44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
                        -44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
                        -44+231,     255,   0+231,  PC_NOCOLLAPSE,
                        -44+240,     255,   0+240,  PC_NOCOLLAPSE,

                              0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
                              0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
                              0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
                              0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
                        -44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
                        -44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
                        -44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

						// Replace this entry with a more ie-logo-friendly color 
						// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
							 51,     153,     255,  PC_NOCOLLAPSE,

                        -44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
                        -44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
                        -44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
                        -44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
                        -44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
                        -44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
                        -44+204,  14+204,     255,  PC_NOCOLLAPSE,
                        -44+213,  14+213,     255,  PC_NOCOLLAPSE,
                        -44+222,     255,     255,  PC_NOCOLLAPSE,
                        -44+231,     255,     255,  PC_NOCOLLAPSE,
                        -44+240,     255,     255,  PC_NOCOLLAPSE,

                          0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
                          0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
                          0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
                          0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
                          0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
                          0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
                          0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
                          0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
                          0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
                          0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
                          0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
                          0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
                          0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
                          0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
                          0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
                          0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
                          0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
                          0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
                          0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
                          0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
                          0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
                          0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
                          0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
                          0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
                          0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
                          0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

                          0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
                          0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
                          0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
                          0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
                          0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
                          0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
                          0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
                          0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
                          0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
                          0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
                          0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
                          0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
                          0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
                          0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
                          0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
                          0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
                          0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
                          0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
                          0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
                          0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
                          0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
                          0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
                          0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
                          0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
                          0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
                          0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

                          0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
                          0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
                          0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
                          0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
                          0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
                          0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
                          0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
                          0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
                          0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
                          0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
                          0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
                          0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
                          0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
                          0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
                          0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
                          0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
                          0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
                          0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
                          0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
                          0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
                          0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
                          0+204, -13+204,     255,  PC_NOCOLLAPSE,
                          0+213, -13+213,     255,  PC_NOCOLLAPSE,
                          0+222, -13+222,     255,  PC_NOCOLLAPSE,
                          0+231, -13+231,     255,  PC_NOCOLLAPSE,
                          0+240, -13+240,     255,  PC_NOCOLLAPSE,

                         44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
                         44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
                         44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
                         44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
                         44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
                         44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
                         44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
                         44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
                         44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
                         44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
                         44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
                         44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
                         44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
                         44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
                         44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
                         44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
                         44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
                         44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
                            255, -14+213, -55+213,  PC_NOCOLLAPSE,
                            255, -14+222, -55+222,  PC_NOCOLLAPSE,
                            255, -14+231, -55+231,  PC_NOCOLLAPSE,
                            255, -14+242, -55+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
                         44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                         44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
                         44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
                         44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
                         44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
                         44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
                         44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
                         44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
                         44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
                         44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
                         44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
                         44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
                         44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
                            255, -26+213,   0+213,  PC_NOCOLLAPSE,
                            255, -26+222,   0+222,  PC_NOCOLLAPSE,
                            255, -26+231,   0+231,  PC_NOCOLLAPSE,
                            255, -26+240,   0+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
                         44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
                         44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
                         44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
                         44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
                         44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
                         44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
                         44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
                         44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
                         44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
                         44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
                         44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
                         44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
                         44+204, -39+204,     255,  PC_NOCOLLAPSE,
                            255, -39+213,     255,  PC_NOCOLLAPSE,
                            255, -39+222,     255,  PC_NOCOLLAPSE,
                            255, -39+231,     255,  PC_NOCOLLAPSE,
                            255, -39+240,     255,  PC_NOCOLLAPSE,

			0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
			0x81, 0x81, 0x84, PC_NOCOLLAPSE
};
#endif // } USE_WIN95_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1vlc.h ===
/*
 * Define the TCOEF escape constant and field length.
 */
#define	TCOEF_ESCAPE_FIELDLEN	7
#define	TCOEF_ESCAPE_FIELDVAL	3
#define	TCOEF_RUN_FIELDLEN		6
#define	TCOEF_LEVEL_FIELDLEN	8

#define NUMBER_OF_TCOEF_ENTRIES	64*16

/* Declare the data structures that are defined in E1VLC.ASM
 */
extern "C" U8 FLC_INTRADC[256];
extern "C" int VLC_TCOEF_TBL[NUMBER_OF_TCOEF_ENTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Author:   AGUPTA2  $
// $Date:   14 Apr 1997 16:58:54  $
// $Archive:   S:\h26x\src\enc\e1rtp.cpv  $
// $Header:   S:\h26x\src\enc\e1rtp.cpv   1.10   14 Apr 1997 16:58:54   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1rtp.cpv  $
// 
//    Rev 1.10   14 Apr 1997 16:58:54   AGUPTA2
// Added a new function to return size of just the extended bit-stream (RTP pa
// 
//    Rev 1.9   21 Nov 1996 10:51:46   RHAZRA
// Changed the packet threshold to 80%
// 
//    Rev 1.8   18 Nov 1996 17:11:34   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.7   07 Nov 1996 14:43:46   RHAZRA
// Changed declaration of packet size threshold function.
// 
//    Rev 1.6   30 Sep 1996 08:50:06   RHAZRA
// Look for zero GOB number entry in Rewind operation.
// 
//    Rev 1.5   24 Sep 1996 13:48:46   RHAZRA
// Changed MBAP to be in the range 0-31 as demanded by the RTP spec.
// 
//    Rev 1.4   17 Sep 1996 21:59:44   RHAZRA
// Assigned GOB number to zero at GOB-level packet fragmentation to
// be consistent with the RTP spec.
// 
//    Rev 1.3   16 Sep 1996 09:31:14   RHAZRA
// 
// Now return motion vectors in interger pel units as opposed to
// half pel units for interoperability.
// 
//    Rev 1.2   26 Aug 1996 10:11:44   RHAZRA
// Fixed a bug in RewindBSinfoStream function.
// 
//    Rev 1.1   23 Aug 1996 13:04:52   RHAZRA
// Added #ifdef RING0 ... #endif to avoid wsprintf and GlobaclAlloc
// problems in RING0
// 
//    Rev 1.0   21 Aug 1996 18:31:20   RHAZRA
// Initial revision.
// 
//    Rev 1.1   28 Apr 1996 20:09:04   BECHOLS
// 
// Removed RTP_HEADER IFDEFs.
// 
//    Rev 1.0   22 Apr 1996 17:46:10   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:33:04   CZHU
// Moved packet loss sim to c3rtp.cpp
// 
//    Rev 1.6   29 Mar 1996 13:37:42   CZHU
// 
// 
//    Rev 1.5   01 Mar 1996 16:37:08   DBRUCKS
// 
// change to use 3/4ths of packet size as the threshold 
// change to make packet size a parameter
// 
//    Rev 1.4   23 Feb 1996 17:36:48   CZHU
// 
// 
//    Rev 1.3   23 Feb 1996 16:18:28   CZHU
// integrate with build 29
// 
//    Rev 1.2   15 Feb 1996 12:00:42   CZHU
// ean up
// Clean up
// 
//    Rev 1.1   14 Feb 1996 14:59:36   CZHU
// Support both mode A and mode B payload modes.
// 
//    Rev 1.0   12 Feb 1996 17:04:44   CZHU
// Initial revision.
// 
//    Rev 1.5   25 Jan 1996 16:14:34   CZHU
// 
// name changes
// 
//    Rev 1.4   15 Dec 1995 13:06:46   CZHU
// 
// 
// 
// 
//    
// 
//    Rev 1.3   11 Dec 1995 14:52:42   CZHU
// Added support for per MB packetization
// 
//    Rev 1.2   04 Dec 1995 16:50:26   CZHU
// 
//    Rev 1.1   01 Dec 1995 15:53:52   CZHU
// Included Init() and Term() functions.
// 
//    Rev 1.0   01 Dec 1995 15:31:02   CZHU
// Initial revision.
*/

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#include "precomp.h"

/*
 * Helper function to calculate the threshold of packet size 
 * for given maximum packet size and data rate
 */

 
U32 getRTPPacketSizeThreshold(U32 uRequested)
{ U32 uSize;
  uSize = (uRequested * 85) / 100;
  ASSERT(uSize);
 return uSize;  
}

I32 H261RTP_InitBsInfoStream(
	T_H263EncoderCatalog * EC,
	UINT unPacketSize)
{
  U32 uBsInfoSize;

  uBsInfoSize = EC->FrameHeight * EC->FrameWidth * 3 / 4 ; 
  uBsInfoSize = uBsInfoSize*sizeof(T_RTP_H261_BSINFO)/ DEFAULT_PACKET_SIZE;
  EC->hBsInfoStream= GlobalAlloc(GHND, uBsInfoSize);
  if ( EC->hBsInfoStream)
  {
   EC->pBaseBsInfoStream = (void *)GlobalLock(EC->hBsInfoStream);
   EC->pBsInfoStream = EC->pBaseBsInfoStream;
   EC->uBase = 0;
   EC->uNumOfPackets=0;
   EC->uPacketSizeThreshold =  getRTPPacketSizeThreshold(unPacketSize);
   
  }
  else return FALSE;

#ifndef RING0
 #ifdef _DEBUG
 DBOUT("BsInfoStream  initialized....\n");
 #endif
#endif
 return TRUE;
}

/*
 * H263RTPFindMVs
 * Find motion vector predictors for current MB and return in arraryMVs[]
 *
*/

U32 H261RTPFindMVs (
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    //U32 uMBA,
    //U32 uGOBN,
    I8 arrayMVs[2],
    UN unCurrentMB,
    UN unLastCodedMB
)
{
  if ( ((unCurrentMB - unLastCodedMB) != 1) || ((unCurrentMB % 11) == 0) )
  {
   arrayMVs[0]=0;
   arrayMVs[1]=0;

  }
  else
  {	
	arrayMVs[0]= pMBlockAction[-1].BlkY1.PHMV;
	arrayMVs[1]= pMBlockAction[-1].BlkY1.PVMV;
  }


  return TRUE;

 }

/*
 * This routine is called at the beginning of each MB
 * to update the BitstreamInfoStream;
 * 
 */

I32 H261RTP_MBUpdateBsInfo  (
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    U32 uQuant, 
    U32 uMBAP,
	U32 uGOBN,
	U8  *pBitStream,
	U32 uBitOffset,
    UN unCurrentMB,
    UN unLastCodedMB
)
{
 U32 uNewBytes;
 T_RTP_H261_BSINFO *pBsInfoStream ;

 //compute the difference
 uNewBytes = (U32)pBitStream - (U32)EC->pU8_BitStream - EC->uBase;

 if ((uNewBytes < EC->uPacketSizeThreshold) || 
     (unCurrentMB == 0) )
 { 
  return TRUE;
 }
 else
 {
   I8 arrayMVs[2];
   ASSERT(unCurrentMB); //it should not happen on the first MB in a GOB
   pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;
   EC->uBase += uNewBytes;
   pBsInfoStream->uFlags       = 0;
   pBsInfoStream->uBitOffset = uBitOffset + EC->uBase*8;	//next bit 
   
   //pBsInfoStream->u8MBA       = (U8)(unLastCodedMB + 1); 
     pBsInfoStream->u8MBA       = (U8)(unLastCodedMB); 
   

   if (!unCurrentMB)
      pBsInfoStream->u8Quant     = (U8)0; // this case should never be true
   else
      pBsInfoStream->u8Quant     = (U8)uQuant;
   
   pBsInfoStream->u8GOBN      = (U8)uGOBN;
	
	H261RTPFindMVs(EC, pMBlockAction,/* uMBAP, uGOBN,*/ arrayMVs, unCurrentMB,
                       unLastCodedMB);

    pBsInfoStream->i8HMV      = (arrayMVs[0]>>1);
    pBsInfoStream->i8VMV      = (arrayMVs[1]>>1);
   
  }//end of if (size <packetSize)

#ifndef RING0
  #ifdef _DEBUG 
  { char msg[200];

    wsprintf(msg, "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d,pBitStream=%lx,PacketSize= %d B",
                 pBsInfoStream->uFlags,
                 pBsInfoStream->uBitOffset,
                 pBsInfoStream->u8MBA,
                 pBsInfoStream->u8Quant,
                 pBsInfoStream->u8GOBN,
                 (U32)pBitStream, 
                 uNewBytes);
   DBOUT(msg);
   }
   #endif
#endif

   EC->pBsInfoStream          = (void *) ++pBsInfoStream;	//create a new packet
   EC->uNumOfPackets++;

 return TRUE;
}

/*
 * This Routine is called every GOB except GOB 1 to build a 
 * packet
 *
 */

I32 H261RTP_GOBUpdateBsInfo  (
    T_H263EncoderCatalog * EC, 
	U32 uGOBN,
	U8  *pBitStream,
	U32 uBitOffset
)
{
 U32 uNewBytes;
 T_RTP_H261_BSINFO *pBsInfoStream ;

 //compute the difference
 uNewBytes = (U32)pBitStream - (U32)EC->pU8_BitStream - EC->uBase;
 
 {
  pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;

  if (uGOBN > 1)  //avoid break between uMBA=0 and GOB header.
  {
    if (uNewBytes) 
	{
 	EC->uBase += uNewBytes;
    pBsInfoStream->uBitOffset = uBitOffset + EC->uBase*8;	//next bit 
    }
    else 
	{
	 goto nobreak;
	}
  }
  else	
   pBsInfoStream->uBitOffset = 0;	  

  pBsInfoStream->uFlags      = 0;
  pBsInfoStream->u8MBA       = 0;
  pBsInfoStream->u8Quant     = 0; // invalid Quant to signal packet starts a GOB
  //pBsInfoStream->u8GOBN      =(U8)uGOBN;
  pBsInfoStream->u8GOBN      = 0;
  pBsInfoStream->i8HMV       = 0;
  pBsInfoStream->i8VMV       = 0;
  
  EC->uNumOfPackets++;
#ifndef RING0
  #ifdef _DEBUG
  { char msg[120];
    wsprintf(msg, "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d,pBitStream=%lx,PacketSize= %d B",
                 pBsInfoStream->uFlags,
                 pBsInfoStream->uBitOffset,
                 pBsInfoStream->u8MBA,
                 pBsInfoStream->u8Quant,
                 pBsInfoStream->u8GOBN,
                 (U32)pBitStream, 
                 uNewBytes);
    DBOUT(msg);
   }
   #endif
#endif
   EC->pBsInfoStream= (void *) ++pBsInfoStream;	//create a new packet

 }
nobreak:

 return TRUE;
}


 void H261RTP_TermBsInfoStream(T_H263EncoderCatalog * EC)
 {

 #ifndef RING0
  #ifdef _DEBUG
   DBOUT("BsInfoStream freed....");
	#endif
 #endif

  if ( EC->hBsInfoStream)
  {
   GlobalUnlock(EC->hBsInfoStream);
   GlobalFree(EC->hBsInfoStream);
  }
   EC->hBsInfoStream= NULL;
  return;
 }

#define DONTCARE 0

/*************************************************
 *  Return the maximum size of EBS (i.e. RTP part)
 *  including maximum of 3 bytes required for aligning
 *  start of EBS
 ************************************************/
U32 H261RTP_GetMaxBsInfoStreamSize(
     T_H263EncoderCatalog * EC
)
{
    return (3 + (EC->uNumOfPackets *sizeof(T_RTP_H261_BSINFO)) + sizeof(T_H26X_RTP_BSINFO_TRAILER));
}


U32 H261RTP_AttachBsInfoStream(
     T_H263EncoderCatalog * EC,
     U8 *lpOutput,
     U32 uSize
)
{  U32 uIncreasedSize;
   T_H26X_RTP_BSINFO_TRAILER BsInfoTrailer;
   T_RTP_H261_BSINFO *pBsInfoStream ;
   U8 * lpAligned;
   //build bsinfo for the last packets
   BsInfoTrailer.uVersion = H26X_RTP_PAYLOAD_VERSION;
   BsInfoTrailer.uFlags   = 0;
   
   if (EC->PictureHeader.PicCodType == INTRAPIC) 
      BsInfoTrailer.uFlags |= RTP_H26X_INTRA_CODED;
   
   
   BsInfoTrailer.uUniqueCode     =  H261_RTP_BS_START_CODE;
   BsInfoTrailer.uCompressedSize =  uSize;
   BsInfoTrailer.uNumOfPackets   =  EC->uNumOfPackets;
   BsInfoTrailer.u8Src           =  0;
   BsInfoTrailer.u8TR            =  EC->PictureHeader.TR;
   BsInfoTrailer.u8TRB           =  DONTCARE;
   BsInfoTrailer.u8DBQ           =  DONTCARE;
   //update size feild for the last BsInfoTrailer
   pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;

   uIncreasedSize = EC->uNumOfPackets *sizeof(T_RTP_H261_BSINFO);
   lpAligned =(U8 *)( (U32)(lpOutput + uSize + 3 ) & 0xfffffffc);
   memcpy( lpAligned, 
           EC->pBaseBsInfoStream, 
           uIncreasedSize);
   memcpy(lpAligned + uIncreasedSize,
          &BsInfoTrailer,
          sizeof(T_H26X_RTP_BSINFO_TRAILER));

   EC->pBsInfoStream = EC->pBaseBsInfoStream;
   EC->uBase =0;
   EC->uNumOfPackets=0;

   uIncreasedSize += sizeof(T_H26X_RTP_BSINFO_TRAILER)+ (U32)(lpAligned- lpOutput-uSize);

   return uIncreasedSize;
 }

I32 H261RTP_RewindBsInfoStream(T_H263EncoderCatalog *EC, U32 uGOBN)
{
    T_RTP_H261_BSINFO *pBsInfoStream;

    pBsInfoStream = (T_RTP_H261_BSINFO *) EC->pBsInfoStream;

    pBsInfoStream--; 

    while ( ! ((pBsInfoStream->u8GOBN == 0) && 
               (pBsInfoStream->u8Quant == 0)
               )
          )
    {
          EC->uNumOfPackets--;
          pBsInfoStream--;
    }

	EC->pBsInfoStream = (void *) ++pBsInfoStream;
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1mbenc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/******************************************************************************
 * e1mbenc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  GOB_Q_RLE_VLC_WriteBS
 *  MB_Quantize_RLE
 *  ComputeCheckSum
 *  WriteMBCheckSum
 */
/* $Header:   S:\h26x\src\enc\e1mbenc.cpv   1.47   30 Oct 1996 09:58:46   MBODART  $
 *  $Log:   S:\h26x\src\enc\e1mbenc.cpv  $
// 
//    Rev 1.47   30 Oct 1996 09:58:46   MBODART
// Fixed assertion failure.  Need to reclamp unMQuant after adding delta.
// 
//    Rev 1.46   29 Oct 1996 11:18:18   RHAZRA
// Bug fix: in the IA code we previously modified MQuant on a MB basis
// even if we were operating with a fixed quantizer. Now we don't
// 
//    Rev 1.45   21 Oct 1996 09:05:16   RHAZRA
// 
// MMX integration
// 
//    Rev 1.44   21 Aug 1996 19:06:02   RHAZRA
// Added RTP generatio code; fixed additional divide-by-zero possibilities.
// 
//    Rev 1.42   21 Jun 1996 10:08:34   AKASAI
// Changes to e1enc.cpp, e1mbenc.cpp, ex5me.asm to support "improved
// bit rate control", changing MacroBlock Quantization within a
// row of MB's in addition to changing the Quantization change
// between rows of macro blocks.
// 
// ex5me.asm had a problem with SLF SWD.  Brian updated asm code.
// 
// 
//    Rev 1.41   14 May 1996 11:41:18   AKASAI
// Needed to test 0th and 1st coefficient to avoid clamping errors.
// 
//    Rev 1.40   14 May 1996 10:39:04   AKASAI
// Two files changed to hopefully eliminate Quantization clamping 
// artifacts and to reduce the max buffer overflow case: e1enc.cpp
// and e1mbenc.cpp.
// 
// In e1mbenc.cpp when the MQuant level is < 6 I test to see if
// the 0th coefficient is larger than the values representable
// at that Quant level if it is I increase the Quant level until
// the clamping artifact will not occur.  Note: I am test only 
// the Oth coefficient, there is the possibility that some other
// coefficient is larger but the performance trade off seems to
// indicate this is good for now and if we still see clamping
// artifacts we can add more testing later.
// 
// In e1enc.cpp I modified when the Overflow types of warnings are
// turn on as well as changing the rate the Quantization level
// changes at.
// 
//    Rev 1.39   24 Apr 1996 12:18:22   AKASAI
// Added re-compression strategy to encoder.  Had to change e1enc.cpp,
// e1enc.h and e1mbenc.cpp.  
// Basic strategy is if spending too many bits in a GOB quantize the
// next GOB at a higher rate.  If after compressing the frame too
// many bits have been used, re-compress the last GOB at a higher
// QUANT level if that still doesn't work send a "Skip" GOB.
// Needed to add extra parameter to GOB+Q_RLE_VLC_WriteBS because
// CalcMBQuant kept decreasing the QUANT when we were in trouble with
// possibly overflowing the buffer.
// 
//    Rev 1.38   22 Apr 1996 11:02:14   AKASAI
// Two files changed e1enc.cpp and e1mbenc.cpp to try and support
// allowing the Quantization values to go down to 2 instead of
// CLAMP to 6.
// This is part 1 of implementing the re-compression (what to do
// if exceed max compressed buffer size 8KBytes QCIF, 32KBytes FCIF).
// Also changed in e1enc was to limit request uFrameSize to 8KB or
// 32KB.  Problem was if user specified too large of a datarate
// request frame size would be larger than the allowed buffer size.
// If you try to compress qnoise10.avi or fnoise5.avi you get an
// ASSERT error until rest of re-compression is implemented.
// 
//    Rev 1.37   19 Apr 1996 14:26:28   SCDAY
// Added adaptive bit usage profile (Karl's BRC changes)
// 
//    Rev 1.36   08 Jan 1996 10:11:16   DBRUCKS
// add an assert
// 
//    Rev 1.35   29 Dec 1995 18:11:42   DBRUCKS
// 
// optimize walking pCurrMB and add CLAMP_N_TO(qp,6,31)
// 
//    Rev 1.34   27 Dec 1995 16:48:06   DBRUCKS
// moved incrementing InterCodeCnt from e1enc.cpp
// 
//    Rev 1.33   26 Dec 1995 17:45:18   DBRUCKS
// moved statistics to e1stat
// 
//    Rev 1.32   20 Dec 1995 14:56:52   DBRUCKS
// add timing stats
// 
//    Rev 1.31   18 Dec 1995 15:38:04   DBRUCKS
// improve stats
// 
//    Rev 1.30   15 Dec 1995 10:53:34   AKASAI
// Fixed bug that encoded the wrong type when spatial loop filter on
// bug 0 MV.  Was incorrectly been encoded with no spatial loop filter.
// This seemed to have caused the "#" bug.
// 
//    Rev 1.29   13 Dec 1995 13:59:08   DBRUCKS
// added include exutil.h
// parameter change in call to cnvt_fdct_output - uses INTRA boolean instead
// of blocktype
// 
//    Rev 1.28   07 Dec 1995 12:50:54   DBRUCKS
// integrate Macroblock checksum fixes
// 
//    Rev 1.27   04 Dec 1995 12:12:30   DBRUCKS
// Unsigned compares using MQuant and lastencoded -2 yielded 
// unexpected results when lastencoded was 1.
// 
//    Rev 1.26   01 Dec 1995 15:33:14   DBRUCKS
// 
// Added the bit rate controller support.  The one possibly confusing
// part is that the quantizer can change in the encoder on a macro block
// that is skipped or on one that does not have coefficients.  In either
// case the decoder is not told of the change.  The decoder is told of
// the change on the next macroblock that has coefficients.
// 
//    Rev 1.25   27 Nov 1995 17:53:40   DBRUCKS
// add spatial loop filtering
// 
//    Rev 1.24   22 Nov 1995 17:37:34   DBRUCKS
// cleanup me changes
// 
//    Rev 1.23   22 Nov 1995 15:34:52   DBRUCKS
// 
// Motion Estimation works - but needs to be cleaned up
// 
//    Rev 1.22   17 Nov 1995 14:26:20   BECHOLS
// 
// Made modifications so that this file can be made for ring 0.
// 
//    Rev 1.21   15 Nov 1995 14:40:34   AKASAI
// Union thing change ...
// (Integration point)
// 
//    Rev 1.20   01 Nov 1995 09:00:16   DBRUCKS
// cleanup
// 
//    Rev 1.19   27 Oct 1995 17:21:12   DBRUCKS
// fix MTYPE calc, improve var names and debug
// 
//    Rev 1.18   27 Oct 1995 15:06:30   DBRUCKS
// update cnvt_fdct_output
// 
//    Rev 1.17   27 Oct 1995 14:30:36   DBRUCKS
// delta frame support "coded", key frames tested
// 
//    Rev 1.15   17 Oct 1995 15:56:56   DBRUCKS
// cleanup debug message
// 
//    Rev 1.14   17 Oct 1995 15:52:10   DBRUCKS
// 
// turn off a debug message
// 
//    Rev 1.13   16 Oct 1995 11:41:44   DBRUCKS
// fix the sign part of the checksum
// 
//    Rev 1.12   29 Sep 1995 10:31:02   DBRUCKS
// change to use e35qrle to get the latest
// 
//    Rev 1.11   27 Sep 1995 16:53:48   DBRUCKS
// move MB checksum before MB
// 
//    Rev 1.10   26 Sep 1995 13:33:14   DBRUCKS
// fixed TCOEFF table 4,1 and on used earlier values
// 
//    Rev 1.9   26 Sep 1995 09:29:46   DBRUCKS
// turn on MBEncodeVLC
// 
//    Rev 1.8   26 Sep 1995 09:09:24   DBRUCKS
// add checksum test code
// 
//    Rev 1.7   25 Sep 1995 10:23:16   DBRUCKS
// 
// add checksum info AND
// fix the final param that is passed to MBEncodeVLC
// 
//    Rev 1.6   21 Sep 1995 20:37:56   BECHOLS
// Modified the VLC tables for H261.  I included a placeholder for the
// sign bit, so that I can achieve an optimization in the code.
// 
//    Rev 1.5   21 Sep 1995 18:14:48   BECHOLS
// Changed the initialization of the VLC tables for efficient use of memory,
// and proper operation with VLC code.  This is an intermediate step towards
// completion, but is not operable yet.
// 
//    Rev 1.4   20 Sep 1995 17:50:18   BECHOLS
// 
// Removed VLC_TCOEF_LAST_TBL and changed the initialization code that
// use to assume 2 DWORDS to now make use of a single DWORD to conserve
// memory.
// 
//    Rev 1.3   20 Sep 1995 16:34:28   BECHOLS
// Moved the data declared in E1VLC.H to this module, where it is used.
// 
//    Rev 1.2   20 Sep 1995 12:39:38   DBRUCKS
// turn on complete mb processing and 
// cleanup two routines
// 
//    Rev 1.1   18 Sep 1995 10:09:54   DBRUCKS
// 
// activate more of the mb processing
// 
//    Rev 1.0   12 Sep 1995 18:57:16   BECHOLS
// Initial revision.
 */

#include "precomp.h"

#ifdef CHECKSUM_MACRO_BLOCK
static U32 ComputeCheckSum(I8 * pi8MBRunValTriplets, I8 * pi8EndAddress, I32 iBlockNumber);
static void WriteMBCheckSum(U32 uCheckSum, U8 * pu8PictureStart, U8 ** ppu8BitStream, U8 * pu8BitOffset, UN unCurrentMB);
#endif
static I8 * MB_Quantize_RLE(I32 **DCTCoefs, I8 *MBRunValPairs, U8 * CodedBlocks, U8 BlockType, I32 QP, U32 *puChecksum);

extern char string[128];

/*
 * VLC table for TCOEFs
 * Table entries are size INCLUDING PLACE HOLDER FOR SIGN BIT, code.
 * Stored as (size, value)
 */
int VLC_TCOEF[102*2] = {
	0X0003, 0x0006,	// 0
	0X0005, 0x0008,
	0X0006, 0x000A,
	0X0008, 0x000C,
	0X0009, 0x004C,
	0X0009, 0x0042,
	0X000B, 0x0014,
	0X000D, 0x003A,
	0X000D, 0x0030,
	0X000D, 0x0026,
	0X000D, 0x0020,
	0X000E, 0x0034,
	0X000E, 0x0032,
	0X000E, 0x0030,
	0X000E, 0x002E,
	0X0004, 0x0006,	// 1
	0X0007, 0x000C,
	0X0009, 0x004A,
	0X000B, 0x0018,
	0X000D, 0x0036,
	0X000E, 0x002C,
	0X000E, 0x002A,
	0X0005, 0x000A,	// 2
	0X0008, 0x0008,
	0X000B, 0x0016,
	0X000D, 0x0028,
	0X000E, 0x0028,
	0X0006, 0x000E,	// 3
	0X0009, 0x0048,
	0X000D, 0x0038,
	0X000E, 0x0026,
	0X0006, 0x000C,	// 4
	0X000B, 0x001E,
	0X000D, 0x0024,
	0X0007, 0x000E,	// 5
	0X000B, 0x0012,
	0X000E, 0x0024,
	0X0007, 0x000A,	// 6
	0X000D, 0x003C,
	0X0007, 0x0008,	// 7
	0X000D, 0x002A,
	0X0008, 0x000E, // 8
	0X000D, 0x0022,
	0X0008, 0x000A,	// 9
	0X000E, 0x0022,
	0X0009, 0x004E,	// 10
	0X000E, 0x0020,
	0X0009, 0x0046,	// 11
	0X0009, 0x0044,	// 12
	0X0009, 0x0040,	// 13
	0X000B, 0x001C,	// 14
	0X000B, 0x001A,	// 15
	0X000B, 0x0010,	// 16
	0X000D, 0x003E,	// 17
	0X000D, 0x0034,	// 18
	0X000D, 0x0032,	// 19
	0X000D, 0x002E,	// 20
	0X000D, 0x002C,	// 21
	0X000E, 0x003E,	// 22
	0X000E, 0x003C,	// 23
	0X000E, 0x003A,	// 24
	0X000E, 0x0038,	// 25
 	0X000E, 0x0036	// 26
  };

/*
 * This table lists the maximum level represented in the
 * VLC table for a given run. If the level exceeds the
 * max, then escape codes must be used to encode the
 * run & level.
 * The table entries are of the form {maxlevel, ptr to table for this run}.
 */

T_MAXLEVEL_PTABLE TCOEF_RUN_MAXLEVEL[65] = {
	{15, &VLC_TCOEF[0]},	// run of 0
	{ 7, &VLC_TCOEF[15*2]},	// run of 1
	{ 5, &VLC_TCOEF[22*2]},	// run of 2
	{ 4, &VLC_TCOEF[27*2]},	// run of 3
	{ 3, &VLC_TCOEF[31*2]},	// run of 4
	{ 3, &VLC_TCOEF[34*2]},	// run of 5
	{ 2, &VLC_TCOEF[37*2]},	// run of 6
	{ 2, &VLC_TCOEF[39*2]},	// run of 7
	{ 2, &VLC_TCOEF[41*2]},	// run of 8
	{ 2, &VLC_TCOEF[43*2]},	// run of 9
	{ 2, &VLC_TCOEF[45*2]},	// run of 10
	{ 1, &VLC_TCOEF[47*2]},	// run of 11
	{ 1, &VLC_TCOEF[48*2]},	// run of 12
	{ 1, &VLC_TCOEF[49*2]},	// run of 13
	{ 1, &VLC_TCOEF[50*2]},	// run of 14
	{ 1, &VLC_TCOEF[51*2]},	// run of 15
	{ 1, &VLC_TCOEF[52*2]},	// run of 16
	{ 1, &VLC_TCOEF[53*2]},	// run of 17
	{ 1, &VLC_TCOEF[54*2]},	// run of 18
	{ 1, &VLC_TCOEF[55*2]},	// run of 19
	{ 1, &VLC_TCOEF[56*2]},	// run of 20
	{ 1, &VLC_TCOEF[57*2]},	// run of 21
	{ 1, &VLC_TCOEF[58*2]},	// run of 22
	{ 1, &VLC_TCOEF[59*2]},	// run of 23
	{ 1, &VLC_TCOEF[60*2]},	// run of 24
	{ 1, &VLC_TCOEF[61*2]},	// run of 25
	{ 1, &VLC_TCOEF[62*2]},	// run of 26
	{ 0, 0},	// run of 27 not in VLC table
	{ 0, 0},	// run of 28 not in VLC table
	{ 0, 0},	// run of 29 not in VLC table
	{ 0, 0},	// run of 30 not in VLC table
	{ 0, 0},	// run of 31 not in VLC table
	{ 0, 0},	// run of 32 not in VLC table
	{ 0, 0},	// run of 33 not in VLC table
	{ 0, 0},	// run of 34 not in VLC table
	{ 0, 0},	// run of 35 not in VLC table
	{ 0, 0},	// run of 36 not in VLC table
	{ 0, 0},	// run of 37 not in VLC table
	{ 0, 0},	// run of 38 not in VLC table
	{ 0, 0},	// run of 39 not in VLC table
	{ 0, 0},	// run of 40 not in VLC table
	{ 0, 0},	// run of 41 not in VLC table
	{ 0, 0},	// run of 42 not in VLC table
	{ 0, 0},	// run of 43 not in VLC table
	{ 0, 0},	// run of 44 not in VLC table
	{ 0, 0},	// run of 45 not in VLC table
	{ 0, 0},	// run of 46 not in VLC table
	{ 0, 0},	// run of 47 not in VLC table
	{ 0, 0},	// run of 48 not in VLC table
	{ 0, 0},	// run of 49 not in VLC table
	{ 0, 0},	// run of 50 not in VLC table
	{ 0, 0},	// run of 51 not in VLC table
	{ 0, 0},	// run of 52 not in VLC table
	{ 0, 0},	// run of 53 not in VLC table
	{ 0, 0},	// run of 54 not in VLC table
	{ 0, 0},	// run of 55 not in VLC table
	{ 0, 0},	// run of 56 not in VLC table
	{ 0, 0},	// run of 57 not in VLC table
	{ 0, 0},	// run of 58 not in VLC table
	{ 0, 0},	// run of 59 not in VLC table
	{ 0, 0},	// run of 60 not in VLC table
	{ 0, 0},	// run of 61 not in VLC table
	{ 0, 0},	// run of 62 not in VLC table
	{ 0, 0},	// run of 63 not in VLC table
	{ 0, 0}		// run of 64 not in VLC table
	 };

/* VLC table for MBA
 * Table is stored as {number of bits, code}.
 * The index to the table should be the MBA value.
 * The zero entry is not used.
 */
int VLC_MBA[34][2] =
	{ {0, 0},     /* Not Used */
	  {1, 0x1},   /* 1 */
	  {3, 0x3},   /* 2 */
	  {3, 0x2},   /* 3 */
	  {4, 0x3},   /* 4 */
	  {4, 0x2},   /* 5 */
	  {5, 0x3},   /* 6 */
	  {5, 0x2},   /* 7 */
	  {7, 0x7},   /* 8 */
	  {7, 0x6},   /* 9 */
	  {8, 0xB},   /* 10 */
	  {8, 0xA},   /* 11 */
	  {8, 0x9},	  /* 12 */
	  {8, 0x8},   /* 13 */
	  {8, 0x7},	  /* 14 */
	  {8, 0x6},	  /* 15 */
	  {10, 0x17}, /* 16 */
	  {10, 0x16}, /* 17 */
	  {10, 0x15}, /* 18 */
	  {10, 0x14}, /* 19 */
	  {10, 0x13}, /* 20 */
	  {10, 0x12}, /* 21 */
	  {11, 0x23}, /* 22 */
	  {11, 0x22}, /* 23 */
	  {11, 0x21}, /* 24 */
	  {11, 0x20}, /* 25 */
	  {11, 0x1F}, /* 26 */
	  {11, 0x1E}, /* 27 */
	  {11, 0x1D}, /* 28 */
	  {11, 0x1C}, /* 29 */
	  {11, 0x1B}, /* 30 */
	  {11, 0x1A}, /* 31 */
	  {11, 0x19}, /* 32 */
	  {11, 0x18}  /* 33 */
	};

/* VLC table for MTYPE
 * Table is stored as {number of bits, code}.
 */
int VLC_MTYPE[10][2] =
	{ {4, 0x1}, /* Intra        :                TCOEFF */
	  {7, 0x1}, /* Intra        : MQUANT         TCOEEF */
	  {1, 0x1}, /* Inter        :            CBP TCOEFF */
	  {5, 0x1}, /* Inter        : MQUANT     CBP TCOEFF */
	  {9, 0x1}, /* Inter MC     :        MVD            */
	  {8, 0x1}, /* Inter MC     :        MVD CBP TCOEFF */
	  {10,0x1}, /* Inter MC     : MQUANT MVD CBP TCOEFF */
	  {3, 0x1}, /* Inter MC FIL :        MVD            */
	  {2, 0x1}, /* Inter MC FIL :        MVD CBP TCOEFF */
	  {6, 0x1}  /* Inter MC FIL : MQUANT MVD CBP TCOEFF */
    };

/* VLC table for CBP
 * Table is stored as {number of bits, code}.
 */
int VLC_CBP[64][2] =
	{ {0, 0},   /* Not Used - if zero it is not coded */
	  {5, 0x0B},/*  1 */
	  {5, 0x09},/*  2 */
	  {6, 0x0D},/*  3 */
	  {4, 0xD}, /*  4 */
	  {7, 0x17},/*  5 */
	  {7, 0x13},/*  6 */
	  {8, 0x1F},/*  7 */
	  {4, 0xC}, /*  8 */
	  {7, 0x16},/*  9 */

	  {7, 0x12},/* 10 */
	  {8, 0x1E},/* 11 */
	  {5, 0x13},/* 12 */
	  {8, 0x1B},/* 13 */
	  {8, 0x17},/* 14 */
	  {8, 0x13},/* 15 */
	  {4, 0xB}, /* 16 */
	  {7, 0x15},/* 17 */
	  {7, 0x11},/* 18 */
	  {8, 0x1D},/* 19 */

	  {5, 0x11},/* 20 */
	  {8, 0x19},/* 21 */
	  {8, 0x15},/* 22 */
	  {8, 0x11},/* 23 */
	  {6, 0x0F},/* 24 */
	  {8, 0x0F},/* 25 */
	  {8, 0x0D},/* 26 */
	  {9, 0x03},/* 27 */
	  {5, 0x0F},/* 28 */
	  {8, 0x0B},/* 29 */

	  {8, 0x07},/* 30 */
	  {9, 0x07},/* 31 */
	  {4, 0xA}, /* 32 */
	  {7, 0x14},/* 33 */
	  {7, 0x10},/* 34 */
	  {8, 0x1C},/* 35 */
	  {6, 0x0E},/* 36 */
	  {8, 0x0E},/* 37 */
	  {8, 0x0C},/* 38 */
	  {9, 0x02},/* 39 */

	  {5, 0x10},/* 40 */
	  {8, 0x18},/* 41 */
	  {8, 0x14},/* 42 */
	  {8, 0x10},/* 43 */
	  {5, 0x0E},/* 44 */
	  {8, 0x0A},/* 45 */
	  {8, 0x06},/* 46 */
	  {9, 0x06},/* 47 */
	  {5, 0x12},/* 48 */
	  {8, 0x1A},/* 49 */

	  {8, 0x16},/* 50 */
	  {8, 0x12},/* 51 */
	  {5, 0x0D},/* 52 */
	  {8, 0x09},/* 53 */
	  {8, 0x05},/* 54 */
	  {9, 0x05},/* 55 */
	  {5, 0x0C},/* 56 */
	  {8, 0x08},/* 57 */
	  {8, 0x04},/* 58 */
	  {9, 0x04},/* 59 */

	  {3, 0x7}, /* 60 */
	  {5, 0x0A},/* 61 */
	  {5, 0x08},/* 62 */
	  {6, 0x0C},/* 63 */
    };

/* VLC table for MVD
 * Table is stored as {number of bits, code}.
 */
int VLC_MVD[32][2] =
	{ {11, 0x19}, /* -16 & 16 */
	  {11, 0x1B}, /* -15 & 17 */
	  {11, 0x1D}, /* -14 & 18 */
	  {11, 0x1F}, /* -13 & 19 */
	  {11, 0x21}, /* -12 & 20 */
	  {11, 0x23}, /* -11 & 21 */
	  {10, 0x13}, /* -10 & 22 */
	  {10, 0x15}, /*  -9 & 23 */
	  {10, 0x17}, /*  -8 & 24 */
	  { 8, 0x07}, /*  -7 & 25 */
	  { 8, 0x09}, /*  -6 & 26 */
	  { 8, 0x0B}, /*  -5 & 27 */
	  { 7, 0x07}, /*  -4 & 28 */
	  { 5, 0x03}, /*  -3 & 29 */
	  { 4,  0x3}, /*  -2 & 30 */
	  { 3,  0x3}, /*  -1 */
	  { 1,  0x1}, /*   0 */
	  { 3,  0x2}, /*   1 */
	  { 4,  0x2}, /*   2 & -30 */
	  { 5, 0x02}, /*   3 & -29 */
	  { 7, 0x06}, /*   4 & -28 */
	  { 8, 0x0A}, /*   5 & -27 */
	  { 8, 0x08}, /*   6 & -26 */
	  { 8, 0x06}, /*   7 & -25 */
	  {10, 0x16}, /*   8 & -24 */
	  {10, 0x14}, /*   9 & -23 */
	  {10, 0x12}, /*  10 & -22 */
	  {11, 0x22}, /*  11 & -21 */
	  {11, 0x20}, /*  12 & -20 */
	  {11, 0x1E}, /*  13 & -19 */
	  {11, 0x1C}, /*  14 & -18 */
	  {11, 0x1A}  /*  15 & -17 */
	};

/* Table to limit quant changes through out a row of Macro Blocks */
static U8 QPMaxTbl[32] = 
	{ 0,		/* Not Used */
	  1,		/* Not Used when clamp to (2,31) */
	  1,		/* 2 */
	  1,		/* 3 */
	  2,		/* 4 */
	  2,		/* 5 */
	  2,		/* 6 */
	  2,		/* 7 */
	  2,		/* 8 */
	  2,		/* 9 */
	  2,		/* 10 */
	  2,		/* 11 */
	  2,		/* 12 */
	  2,		/* 13 */
	  2,		/* 14 */
	  2,		/* 15 */
	  2,		/* 16 */
	  2,		/* 17 */
	  2,		/* 18 */
	  2,		/* 19 */
	  2,		/* 20 */
	  2,		/* 21 */
	  2,		/* 22 */
	  2,		/* 23 */
	  2,		/* 24 */
	  2,		/* 25 */
	  2,		/* 26 */
	  2,		/* 27 */
	  2,		/* 28 */
	  2,		/* 29 */
	  2,		/* 30 */
	  2			/* 31 */
	};

/* Table to limit Quant changes between Rows of Marco Blocks */
extern U8 MaxChangeRowMBTbl[32]; 

/*****************************************************************************
 *
 *  GOB_Q_RLE_VLC_WriteBS
 *
 *  Quantize and RLE each macroblock, then VLC and write to stream
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I32 *piDCTCoefs,
	U8 **ppu8BitStream,
	U8 *pu8BitOffset,
	UN unStartingMB,
	UN unGQuant,
	BOOL bOverFlowWarningFlag,
    BOOL bRTPHeader, //RTP: switch
    U32  uGOBNumber,        // RTP: info
	U8 u8QPMin
	)
{
	T_MBlockActionStream *pCurrMB = NULL;
	T_MBlockActionStream *pLastMB = NULL;
	int iMBIndex;
	int iLastMBIndex = -1;
	UN unCurrentMB;
	U32 uCheckSum;
	UN unMBA;
	UN unLastEncodedMBA=0; // RTP: information
    UN unLastCodedMB = 0;    // RTP: information
    UN unCBP;
	UN unMQuant;
	UN unLastEncodedMQuant;
	UN unMType;
	UN bWriteTCOEFF;
	UN bWriteMVD;
	UN bWriteMQuant;
	I8 MBRunValSign[65*3*6], *pi8EndAddress, *rvs;
	T_MBlockActionStream *pMBActionStream = EC->pU8_MBlockActionStream;
	int bIntraBlock;
  	int	inPrecedingHMV;
  	int inPrecedingVMV;
  	int	inHDelta;
  	int inVDelta;
	U32 uCumFrmSize;
	U32 uBlockCount;
	ENC_BITSTREAM_INFO * pBSInfo = &EC->BSInfo;
	UN unMQuantLast;

	U32 SWDmax[3] = {0,0,0};
	U32 SWDmin[3] = {65536,65536,65536};
	U32 SWDrange[3] = {0,0,0};
	U32 SWDSum[3] = {0,0,0};
	U32 SWDNum[3] = {0,0,0};
	double SWDAvg[3] = {0.0,0.0,0.0};
	double Step, Delta;
	int QPMax;
	int NeedClamp=0;
	int irow;
	U8 SaveQuants[3];
	UN unSaveMQuant;


	unMQuant = unGQuant;
	unMQuantLast = unMQuant;	// save last MQuant so can reset if needed
	/* initially it should be the same because the GOB header
	 * included the GQuant.
	 */
	unLastEncodedMQuant = unMQuant;  

	unSaveMQuant = unGQuant;
	SaveQuants[0] = unSaveMQuant;

	/* New code to modify Quant inside a row of MB based on SWD */
	/* Loop through each macroblock of the GOB to find min and max SWD
	 */
	pCurrMB = &pMBActionStream[unStartingMB];
	for(irow = 0; irow < 3; irow++)
	{
		for(iMBIndex = irow*11 ; iMBIndex < (irow+1)*11; iMBIndex++, pLastMB = pCurrMB++)
		{
			if (pCurrMB->BlockType != INTRABLOCK)
			{
//				ASSERT(pCurrMB->SWD >= 0); Always True
				SWDSum[irow] += pCurrMB->SWD;
				SWDNum[irow]++;
				if (pCurrMB->SWD > SWDmax[irow])
					SWDmax[irow] = pCurrMB->SWD;
				if (pCurrMB->SWD < SWDmin[irow])
					SWDmin[irow] = pCurrMB->SWD;
			}
		}
	}
	SWDrange[0] = SWDmax[0] - SWDmin[0];
	SWDrange[1] = SWDmax[1] - SWDmin[1];
	SWDrange[2] = SWDmax[2] - SWDmin[2];

    if (SWDNum[0] != 0)
	    SWDAvg[0] = (double) SWDSum[0] / SWDNum[0];
    else
        SWDAvg[0] = 0.0;

    if (SWDNum[1] != 0)
	   SWDAvg[1] = (double) SWDSum[1] / SWDNum[1];
    else
       SWDAvg[1] = 0.0;

    if (SWDNum[2] != 0)
    	SWDAvg[2] = (double) SWDSum[2] / SWDNum[2];
    else
        SWDAvg[2] = 0.0;

	QPMax = unGQuant + QPMaxTbl[unGQuant];
	if (QPMax > 31)
		QPMax = 32;

    if ((SWDAvg[0] - SWDmin[0]) != 0) 
	    Step = (double) (QPMax - unGQuant)/(SWDAvg[0] - SWDmin[0]);
    else
        Step = 0.0;

	/* Loop through each macroblock of the GOB.
	 */
	pLastMB = NULL;
	pCurrMB = &pMBActionStream[unStartingMB];
	for(iMBIndex = 0 ; iMBIndex < 33; iMBIndex++, pLastMB = pCurrMB++)
	{

		unCurrentMB = unStartingMB + (unsigned int)iMBIndex;

		#ifdef DEBUG_ENC
		wsprintf(string, "MB #%d: QP=%d", unCurrentMB, unMQuant);
		trace(string);
		#endif


		if (bRTPHeader)
        {
            H261RTP_MBUpdateBsInfo(EC, 
				                   pCurrMB, 
								   unLastEncodedMQuant, 
								   (U32 )unLastEncodedMBA, 
								   uGOBNumber,
                                   *ppu8BitStream, 
								   (U32) *pu8BitOffset,
                                   unCurrentMB,
                                   unLastCodedMB
								   );
        }

		unMQuant = unMQuantLast;	// reset MQuant in case needed to
									// to raise on previous MB to avoid
									// Quant clamping artifact.

									/* Look to update the Quant on each new row.
		 */
        if (EC->bBitRateControl && ((iMBIndex == 11) || (iMBIndex == 22)))
        {
	        /* Calculate number of bytes used in frame so far.
			 */
	        uCumFrmSize = *ppu8BitStream - EC->pU8_BitStream;

            unMQuant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[unCurrentMB], EC->uBitUsageProfile[EC->NumMBs], uCumFrmSize, EC->PictureHeader.PicCodType);

			QPMax = unMQuant + QPMaxTbl[unMQuant];
			if (QPMax > 31)
				QPMax = 32;
            if ((SWDAvg[iMBIndex/11] - SWDmin[iMBIndex/11]) != 0) 
			    Step = (double) (QPMax - unMQuant)/(SWDAvg[iMBIndex/11] - SWDmin[iMBIndex/11]);
            else
                Step = 0.0;

	   		EC->uBitUsageProfile[unCurrentMB] = uCumFrmSize;

			if (bOverFlowWarningFlag)
			{
				DBOUT("DON'T CHANGE QUANT SET unMQuant = unGQuant");
				unMQuant = unGQuant;
			}
		    else if ((int)unMQuant > ((int)unLastEncodedMQuant + MaxChangeRowMBTbl[unGQuant]))
			{
				DBOUT("Slowing MQuant increase + [1-4]");
				unMQuant = unLastEncodedMQuant + MaxChangeRowMBTbl[unMQuant];
			}
			else if ((int)unMQuant < ((int)unLastEncodedMQuant -2))
			{
				DBOUT("Slowing MQuant decrease to -2");
				unMQuant = unLastEncodedMQuant -2;
			}

			//CLAMP_N_TO(unMQuant,6,31);
			if (EC->BRCState.uTargetFrmSize == 0)
			{
				CLAMP_N_TO(unMQuant,6,31);
			}
			else
			{
				CLAMP_N_TO(unMQuant, u8QPMin, 31);
			}
			#ifdef DEBUG_BRC
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			#endif

			#ifdef DEBUG_RECOMPRESS
			wsprintf(string,"At MB %d MQuant=%d uCumFrmSize=%d", unCurrentMB, unMQuant,uCumFrmSize*8);
			DBOUT(string);
			//trace(string);
			#endif

	        //EC->uQP_cumulative += unMQuant;
			//EC->uQP_count++;

			unSaveMQuant = unMQuant;
			if (iMBIndex == 11)
				SaveQuants[1] = unSaveMQuant;
			else
				SaveQuants[2] = unSaveMQuant;
        }

		/* new MB Quant code */
		if (pCurrMB->BlockType != INTRABLOCK)
		{
           if (EC->BRCState.uTargetFrmSize != 0)
		   {
			if (pCurrMB->SWD >= SWDAvg[iMBIndex/11])
			{
				Delta = (double) -1.0 * ((double) (pCurrMB->SWD - SWDAvg[iMBIndex/11]) * Step);
				if (Delta < -2.0)
				{
					Delta = -2.0;
					NeedClamp++;
				}
			}
			else
			{
				Delta = (double) (SWDAvg[iMBIndex/11] - pCurrMB->SWD)*Step;
			}
		   }
		   else
		
			    Delta = 0.0;

			if (Delta > 0.0)
			{
				unMQuant = unSaveMQuant + (int) (Delta);
				/* Need to clamp again, but only worry about upper limit */
				if (unMQuant > 31)
				    unMQuant = 31;
			}
			else
			{
				unMQuant = unSaveMQuant + (int) (Delta - 0.5);
				/* Need to clamp again, but only worry about lower limit */
			    if (EC->BRCState.uTargetFrmSize == 0)
			    {
				    if (unMQuant < 6)
				        unMQuant = 6;
			    }
			    else
			    {
				    if (unMQuant < 2)
				        unMQuant = 2;
			    }
			}

		}
		/* end new stuff */

		/* Quantize and RLE each block in the macroblock, skipping empty blocks as denoted by pu8CodedBlocks.
		 * If any more blocks are empty after quantization then the appropriate pu8CodedBlocks bit is cleared.
		 */
		//ASSERT(unMQuant >= 6 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		if (EC->BRCState.uTargetFrmSize == 0)
		{
			ASSERT(unMQuant >= 6 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		}
		else
		{
			ASSERT(unMQuant >= 2 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		}

		/* Check iDCTCoefs to see if need to raise quant level to avoid
		 * clamping artifacts.
		 */
		// first block is at piDCTCoefs
		// second block is at piDCTCoefs + 0x80 and so on
		// coefficients are unsigned shorts
		// first coefficient is at 6 bytes, 3 words
		// second coefficient is at 38 bytes, 19 words
		// third coefficient is at 4 bytes, 2 words
		// forth coefficient is at 36 bytes, 18 words

		unMQuantLast = unMQuant;

		if (unMQuant < 6)
		{
			I8 iBlockNum;
			U8 u8Bitmask = 1;
			I32 * ptmpiDCTCoefs = piDCTCoefs;
			int coef0, coef1;
			int biggestcoefval = -2048;
			int smallestcoefval = 2048;

			#ifdef DEBUG_QUANT
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			//trace(string);
			#endif

			for(iBlockNum = 0; iBlockNum < 6; iBlockNum++, u8Bitmask <<= 1)
			{
				/* Skip this block if not coded.
				 */
				if( (pCurrMB->CodedBlocks & u8Bitmask) == 0)
				{
					continue;
				}
	    		if(IsIntraBlock(pCurrMB->BlockType))	// if Intra
				{
					coef0 = ((int)*((U16*)ptmpiDCTCoefs+3)) >> 4; 
				}
				else
				{
					coef0 = ((int)(*((U16*)ptmpiDCTCoefs+3) - 0x8000) ) >> 4;
				}

				coef1 = ((int)(*((U16*)ptmpiDCTCoefs+19) - 0x8000)) >> 4;

				#ifdef DEBUG_QUANT
				wsprintf(string,"At Block %d 0 = %x %d", iBlockNum,coef0,coef0);
				//DBOUT(string);
				//trace(string);
				#endif

				if (coef0 > biggestcoefval)
				{
					biggestcoefval = coef0;
				}
				if (coef1 > biggestcoefval)
				{
					biggestcoefval = coef1;
				}

				if (coef0 < smallestcoefval)
				{
					smallestcoefval = coef0;
				}
				if (coef1 < smallestcoefval)
				{
					smallestcoefval = coef1;
				}

				ptmpiDCTCoefs += 32;		
			}

			#ifdef DEBUG_QUANT
			wsprintf(string,"biggest = %x %d, smallest = %x %d",
			biggestcoefval, biggestcoefval, smallestcoefval, smallestcoefval);
				DBOUT(string);
			//	trace(string);
			#endif

			if (unMQuant == 5) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
			}
			else if (unMQuant == 4) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
			}
			else if (unMQuant == 3) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
				else if ((biggestcoefval > 765) || (smallestcoefval < -765))
					unMQuant = 4;
			}
			else {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
				else if ((biggestcoefval > 765) || (smallestcoefval < -765))
					unMQuant = 4;
				else if ((biggestcoefval > 509) || (smallestcoefval < -509))
					unMQuant = 3;
			}

			#ifdef DEBUG_QUANT
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			//trace(string);
			#endif
		}

		/* This is the place to trace how Quant on a MB bases is varying
		*/
	    EC->uQP_cumulative += unMQuant;
		EC->uQP_count++;

	

	    pi8EndAddress = MB_Quantize_RLE(
	    		&piDCTCoefs,
	    		(I8 *) MBRunValSign,
	    		&(pCurrMB->CodedBlocks),
	    		pCurrMB->BlockType,
				unMQuant,
				&uCheckSum
	    	);

		

		pBSInfo->uQuantsUsedOnBlocks[unMQuant] += 6;

		bWriteMVD = (pCurrMB->BlkY1.PHMV != 0) ||
		  	        (pCurrMB->BlkY1.PVMV != 0) ||
	    			(IsSLFBlock(pCurrMB->BlockType)) ;


	    if (IsInterBlock(pCurrMB->BlockType)) 
		{
			/* Check if the Inter block is not coded?
			 */
			if ( ((pCurrMB->CodedBlocks & 0x3f) == 0) &&
		  	     (! bWriteMVD) )
		    {
				#ifdef DEBUG_MBLK
				wsprintf(string, "Inter MB (index=#%d) has neither Coeff nor MV - skipping", unCurrentMB);
				DBOUT(string);
				#endif
#ifdef FORCE_STUFFING
PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8CurBitStream, pu8BitOffset);
#endif
				continue;
			}
		}

		#ifdef CHECKSUM_MACRO_BLOCK
		/* Write a checksum before all coded blocks
		 */
		WriteMBCheckSum(uCheckSum, EC->pU8_BitStream,ppu8BitStream, pu8BitOffset, unCurrentMB);
		#endif

		/* Calculate the MB header information
		 */

		unMBA = iMBIndex - iLastMBIndex;
		iLastMBIndex = iMBIndex;
		unLastEncodedMBA = unMBA;
        unLastCodedMB = iMBIndex;
        
		
		/* Note: The calculation of whether to write MQuant is done after
		 * skipping macro blocks in order to handle the case that the 11th
		 * or 22nd macro blocks are skipped.  If they are skipped then
		 * the next macro block will be used to write the new quant value.
		 */

	    if(IsIntraBlock(pCurrMB->BlockType))
		{
	        ASSERT(pCurrMB->BlockType == INTRABLOCK);
			if (EC->PictureHeader.PicCodType != INTRAPIC)
			{	        
				pCurrMB->InterCodeCnt = ((U8)unCurrentMB)&0x7;
			} 

			bIntraBlock = 1;
			unCBP = 0;					   /* Never write CBP for Intra blocks */
			uBlockCount = 6;
			bWriteTCOEFF = 1;			   /* Always include TCOEFF for Intra blocks */
			
			/* Since we always have coefficients for Intra MBs we can always update
			 * the MQuant value.
			 */
			bWriteMQuant = (unMQuant != unLastEncodedMQuant);
			unLastEncodedMQuant = unMQuant;
			
			unMType = 0 + bWriteMQuant;	   /* Calculate MTYPE */
			bWriteMVD = 0;				   /* No motion vectors for INTRA */
		} 
		else
		{
			ASSERT(IsInterBlock(pCurrMB->BlockType));
                
			bIntraBlock = 0;

			unCBP  = (pCurrMB->CodedBlocks & 0x1) << 5;  /* x0 0000 */
			unCBP |= (pCurrMB->CodedBlocks & 0x2) << 3;	 /* 0x 0000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x4) << 1;	 /* 00 x000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x8) >> 1;	 /* 00 0x00 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x10) >> 3; /* 00 00x0 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x20) >> 5; /* 00 000x */

			uBlockCount = 0;
			if (unCBP &  0x1) uBlockCount++;
			if (unCBP &  0x2) uBlockCount++;
			if (unCBP &  0x4) uBlockCount++;
			if (unCBP &  0x8) uBlockCount++;
			if (unCBP & 0x10) uBlockCount++;
			if (unCBP & 0x20) uBlockCount++;

			/* Increment the count if it is transmitted 
			 * "should be forcibly updated at least once every
			 *  132 times it is transmitted" 3.4
			 */
			if (uBlockCount != 0 )
			{
        		pCurrMB->InterCodeCnt++;
			}
	
			bWriteTCOEFF = (unCBP != 0);
		
			if (bWriteTCOEFF)
			{
				/* We can only update the MQuant value when we have coefficients
				 */
				bWriteMQuant = (unMQuant != unLastEncodedMQuant);
				unLastEncodedMQuant = unMQuant;
			}
			else
			{
				bWriteMQuant = 0;
			}
			#ifdef CHECKSUM_MACRO_BLOCK
			/* Either there are coefficients or the checksum should equal zero
			 */
			ASSERT(bWriteTCOEFF || uCheckSum == 0);
			#endif	

			/* Calculate MType
			 */
		  	unMType = 1;
			if (bWriteMVD)
			{
				unMType += 3;
				if (IsSLFBlock(pCurrMB->BlockType))
				{				
					unMType += 3;
				}
			} 
			unMType += bWriteTCOEFF;
			unMType += bWriteMQuant;

			
			ASSERT(unMType > 1 && unMType < 10);
		}

		ASSERT(unMQuant >= 1 && unMQuant <= 31);
		ASSERT(uBlockCount <= 6);
		pBSInfo->uQuantsTransmittedOnBlocks[unMQuant] += uBlockCount;

		if (bWriteMVD)
		{
			/* Find the preceding motion vectors
			 */
			if ( (unMBA != 1) ||             /* skipped one or more MB */
			     ((unCurrentMB % 11) == 0) ) /* first MB in each row */
			{
				inPrecedingHMV = 0;
				inPrecedingVMV = 0;
			}
			else
			{
				inPrecedingHMV = pLastMB->BlkY1.PHMV;
				inPrecedingVMV = pLastMB->BlkY1.PVMV;
			}
			
			/* adjust vectors:
			 */
			inHDelta = pCurrMB->BlkY1.PHMV - inPrecedingHMV;	
			ASSERT((inHDelta & 0x1) == 0);
			ASSERT((inHDelta >> 1) == (inHDelta / 2));
			inHDelta >>= 1;		 /* Adjust to integer pels */
			if(inHDelta > 15)	 /* Adjust to the range of -16...+15 */
				inHDelta -= 32;
			if(inHDelta < -16)
				inHDelta += 32;
			inHDelta = inHDelta + 16;  /* 0 is at offset 16 */

			inVDelta = pCurrMB->BlkY1.PVMV - inPrecedingVMV;	
			ASSERT((inVDelta & 0x1) == 0);
			ASSERT((inVDelta >> 1) == (inVDelta / 2));
			inVDelta >>= 1;
			if(inVDelta > 15)
				inVDelta -= 32;
			if(inVDelta < -16)
				inVDelta += 32;
			inVDelta = inVDelta + 16;

			#ifndef RING0
			#ifdef DEBUG_PRINTMV
			{
				char buf132[132];
				int iLength;
				
				iLength = wsprintf(buf132, "MB # %d :: H MVD = %d; index = %d :: V MVD = %d; index = %d", unCurrentMB, 
								   pCurrMB->BlkY1.PHMV / 2, inHDelta,
								   pCurrMB->BlkY1.PVMV / 2, inVDelta);
				DBOUT(buf132);
				ASSERT(iLength < 132);
			}
			#endif
			#endif
		}
		else
		{
			/* MBs without MVD need to have zero motion vectors because of 
			 * Rule 3) under 4.2.3.4
			 */
			pCurrMB->BlkY1.PHMV = 0;
			pCurrMB->BlkY1.PVMV = 0;
		}

		/* we should only have MQuant if we have coefficients
		 */
		if (bWriteMQuant)
		{
			ASSERT(bWriteTCOEFF);
		}

		/* we should only have CBP if we have coefficients
		 */
		if (unCBP)
		{
			ASSERT(bWriteTCOEFF);
			ASSERT(uBlockCount > 0);
		}

	    /* Write the MacroBlock Header
		 */

#ifndef RING0
#ifdef DEBUG_MBLK
		{
			int iLength;
			char buf180[180]; 
			iLength = wsprintf(buf180, "Enc #%d: MBType=%ld unNextMQuant=%d MQuant=%ld bWriteMVD=%d MVDH=%ld MVDV=%ld CBP=%ld",
								(int) unCurrentMB,
								unMType, 
								(int) bWriteMQuant, 
								unMQuant,
								(int) bWriteMVD, 
								pCurrMB->BlkY1.PHMV / 2, 
								pCurrMB->BlkY1.PVMV / 2, 
								unCBP);
			DBOUT(buf180);
			ASSERT(iLength < 180);
		}
#endif
#endif
		/* MBA
		 */
	    PutBits(VLC_MBA[unMBA][1], VLC_MBA[unMBA][0], ppu8BitStream, pu8BitOffset);
       
	    /* MTYPE
		 */
		pBSInfo->uMTypeCount[unMType]++;
		pBSInfo->uBlockCount[unMType] += uBlockCount;
		PutBits(VLC_MTYPE[unMType][1], VLC_MTYPE[unMType][0], ppu8BitStream, pu8BitOffset);

		/* MQUANT
		 */
		if (bWriteMQuant) 
		{
			ASSERT(unMQuant > 0 && unMQuant < 32); /* 4.2.2.3 */
			PutBits((int)unMQuant, FIELDLEN_MQUANT, ppu8BitStream, pu8BitOffset);
		}

		/* MVD
		 */
		if (bWriteMVD)
		{
			ASSERT(inHDelta >= 0 && inHDelta < 32);
			ASSERT(inVDelta >= 0 && inVDelta < 32);
			PutBits(VLC_MVD[inHDelta][1], VLC_MVD[inHDelta][0], ppu8BitStream, pu8BitOffset);
			PutBits(VLC_MVD[inVDelta][1], VLC_MVD[inVDelta][0], ppu8BitStream, pu8BitOffset);
		}

		/* CBP
		 */
		if (unCBP != 0)
		{
			PutBits(VLC_CBP[unCBP][1], VLC_CBP[unCBP][0], ppu8BitStream, pu8BitOffset);
		}

		/* TCOEFF
		 */
		if (bWriteTCOEFF) 
		{
			/*
			 * Encode intra DC and all run/val pairs.
			 */
			rvs = MBRunValSign;
			MBEncodeVLC(
				&rvs,
				NULL,
				pCurrMB->CodedBlocks, 
				ppu8BitStream, 
				pu8BitOffset, 
				bIntraBlock,
				FALSE);
		}

		
	} /* for iMBIndex */

  
} /* end of GOB_Q_RLE_VLC_WriteBS() */


void GOB_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I8 *pMBRVS_Luma,
	I8 *pMBRVS_Chroma,
	U8 **ppu8BitStream,
	U8 *pu8BitOffset,
	UN  unGQuant,
	UN unStartingMB,
	BOOL bRTPHeader, //RTP: switch
    U32  uGOBNumber         // RTP: info
	)
{
	T_MBlockActionStream *pCurrMB = NULL;
	T_MBlockActionStream *pLastMB = NULL;
	int iMBIndex;
	int iLastMBIndex = -1;
	UN unCurrentMB;
	UN unMBA;
	UN unLastEncodedMBA=0; // RTP: information
    UN unLastCodedMB = 0;    // RTP: information
    UN unCBP;
	UN unMQuant;
	UN unLastEncodedMQuant;
	UN unMType;
	UN bWriteTCOEFF;
	UN bWriteMVD;
	UN bWriteMQuant;
//	I8 MBRunValSign[65*3*6], *pi8EndAddress, *rvs;
	T_MBlockActionStream *pMBActionStream = EC->pU8_MBlockActionStream;
	int bIntraBlock;
  	int	inPrecedingHMV;
  	int inPrecedingVMV;
  	int	inHDelta;
  	int inVDelta;
//	U32 uCumFrmSize;
	U32 uBlockCount;
	ENC_BITSTREAM_INFO * pBSInfo = &EC->BSInfo;
	

	unMQuant = unGQuant;
    unLastEncodedMQuant = unGQuant;
	
	/* Loop through each macroblock of the GOB.
	 */

	pLastMB = NULL;
	pCurrMB = &pMBActionStream[unStartingMB];
	for(iMBIndex = 0 ; iMBIndex < 33; iMBIndex++, pLastMB = pCurrMB++)
	{

		unCurrentMB = unStartingMB + (unsigned int)iMBIndex;

		#ifdef DEBUG_ENC
		wsprintf(string, "MB #%d: QP=%d", unCurrentMB, unMQuant);
		trace(string);
		#endif


		if (bRTPHeader)
        {
            H261RTP_MBUpdateBsInfo(EC, 
				                   pCurrMB, 
								   unLastEncodedMQuant, 
								   (U32 )unLastEncodedMBA, 
								   uGOBNumber,
                                   *ppu8BitStream, 
								   (U32) *pu8BitOffset,
                                   unCurrentMB,
                                   unLastCodedMB
								   );
        }


        EC->uQP_cumulative += unMQuant;
		EC->uQP_count++;

		bWriteMVD = (pCurrMB->BlkY1.PHMV != 0) ||
		  	        (pCurrMB->BlkY1.PVMV != 0) ||
	    			(IsSLFBlock(pCurrMB->BlockType)) ;


	    if (IsInterBlock(pCurrMB->BlockType)) 
		{
			/* Check if the Inter block is not coded?
			 */
			if ( ((pCurrMB->CodedBlocks & 0x3f) == 0) &&
		  	     (! bWriteMVD) )
		    {
				#ifdef DEBUG_MBLK
				wsprintf(string, "Inter MB (index=#%d) has neither Coeff nor MV - skipping", unCurrentMB);
				DBOUT(string);
				#endif
#ifdef FORCE_STUFFING
PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8CurBitStream, pu8BitOffset);
#endif
				continue;
			}
		}

		#ifdef CHECKSUM_MACRO_BLOCK
		/* Write a checksum before all coded blocks
		 */
		WriteMBCheckSum(uCheckSum, EC->pU8_BitStream,ppu8BitStream, pu8BitOffset, unCurrentMB);
		#endif

		/* Calculate the MB header information
		 */

		unMBA = iMBIndex - iLastMBIndex;
		iLastMBIndex = iMBIndex;
		unLastEncodedMBA = unMBA;
        unLastCodedMB = iMBIndex;
        
		
		/* Note: The calculation of whether to write MQuant is done after
		 * skipping macro blocks in order to handle the case that the 11th
		 * or 22nd macro blocks are skipped.  If they are skipped then
		 * the next macro block will be used to write the new quant value.
		 */

	    if(IsIntraBlock(pCurrMB->BlockType))
		{
	        ASSERT(pCurrMB->BlockType == INTRABLOCK);
			if (EC->PictureHeader.PicCodType != INTRAPIC)
			{	        
				pCurrMB->InterCodeCnt = ((U8)unCurrentMB)&0x7;
			} 

			bIntraBlock = 1;
			unCBP = 0;					   /* Never write CBP for Intra blocks */
			uBlockCount = 6;
			bWriteTCOEFF = 1;			   /* Always include TCOEFF for Intra blocks */
			
			/* Since we always have coefficients for Intra MBs we can always update
			 * the MQuant value.
			 */
			//bWriteMQuant = (unMQuant != unLastEncodedMQuant);
			//unLastEncodedMQuant = unMQuant;
			
			bWriteMQuant=0;
			unMType = 0; // + bWriteMQuant;	   /* Calculate MTYPE */
			bWriteMVD = 0;				   /* No motion vectors for INTRA */
		} 
		else
		{
			ASSERT(IsInterBlock(pCurrMB->BlockType));
                
			bIntraBlock = 0;

			unCBP  = (pCurrMB->CodedBlocks & 0x1) << 5;  /* x0 0000 */
			unCBP |= (pCurrMB->CodedBlocks & 0x2) << 3;	 /* 0x 0000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x4) << 1;	 /* 00 x000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x8) >> 1;	 /* 00 0x00 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x10) >> 3; /* 00 00x0 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x20) >> 5; /* 00 000x */

			uBlockCount = 0;
			if (unCBP &  0x1) uBlockCount++;
			if (unCBP &  0x2) uBlockCount++;
			if (unCBP &  0x4) uBlockCount++;
			if (unCBP &  0x8) uBlockCount++;
			if (unCBP & 0x10) uBlockCount++;
			if (unCBP & 0x20) uBlockCount++;

			/* Increment the count if it is transmitted 
			 * "should be forcibly updated at least once every
			 *  132 times it is transmitted" 3.4
			 */
			if (uBlockCount != 0 )
			{
        		pCurrMB->InterCodeCnt++;
			}
	
			bWriteTCOEFF = (unCBP != 0);
		    bWriteMQuant = 0;
			
			#ifdef CHECKSUM_MACRO_BLOCK
			/* Either there are coefficients or the checksum should equal zero
			 */
			ASSERT(bWriteTCOEFF || uCheckSum == 0);
			#endif	

			/* Calculate MType
			 */
		  	unMType = 1;
			if (bWriteMVD)
			{
				unMType += 3;
				if (IsSLFBlock(pCurrMB->BlockType))
				{				
					unMType += 3;
				}
			} 
			unMType += bWriteTCOEFF;
			unMType += bWriteMQuant;

			
			ASSERT(unMType > 1 && unMType < 10);
		}

		ASSERT(unMQuant >= 1 && unMQuant <= 31);
		ASSERT(uBlockCount <= 6);
		pBSInfo->uQuantsTransmittedOnBlocks[unMQuant] += uBlockCount;

		if (bWriteMVD)
		{
			/* Find the preceding motion vectors
			 */
			if ( (unMBA != 1) ||             /* skipped one or more MB */
			     ((unCurrentMB % 11) == 0) ) /* first MB in each row */
			{
				inPrecedingHMV = 0;
				inPrecedingVMV = 0;
			}
			else
			{
				inPrecedingHMV = pLastMB->BlkY1.PHMV;
				inPrecedingVMV = pLastMB->BlkY1.PVMV;
			}
			
			/* adjust vectors:
			 */
			inHDelta = pCurrMB->BlkY1.PHMV - inPrecedingHMV;	
			ASSERT((inHDelta & 0x1) == 0);
			ASSERT((inHDelta >> 1) == (inHDelta / 2));
			inHDelta >>= 1;		 /* Adjust to integer pels */
			if(inHDelta > 15)	 /* Adjust to the range of -16...+15 */
				inHDelta -= 32;
			if(inHDelta < -16)
				inHDelta += 32;
			inHDelta = inHDelta + 16;  /* 0 is at offset 16 */

			inVDelta = pCurrMB->BlkY1.PVMV - inPrecedingVMV;	
			ASSERT((inVDelta & 0x1) == 0);
			ASSERT((inVDelta >> 1) == (inVDelta / 2));
			inVDelta >>= 1;
			if(inVDelta > 15)
				inVDelta -= 32;
			if(inVDelta < -16)
				inVDelta += 32;
			inVDelta = inVDelta + 16;

			#ifndef RING0
			#ifdef DEBUG_PRINTMV
			{
				char buf132[132];
				int iLength;
				
				iLength = wsprintf(buf132, "MB # %d :: H MVD = %d; index = %d :: V MVD = %d; index = %d", unCurrentMB, 
								   pCurrMB->BlkY1.PHMV / 2, inHDelta,
								   pCurrMB->BlkY1.PVMV / 2, inVDelta);
				DBOUT(buf132);
				ASSERT(iLength < 132);
			}
			#endif
			#endif
		}
		else
		{
			/* MBs without MVD need to have zero motion vectors because of 
			 * Rule 3) under 4.2.3.4
			 */
			pCurrMB->BlkY1.PHMV = 0;
			pCurrMB->BlkY1.PVMV = 0;
		}

		/* we should only have MQuant if we have coefficients
		 */
		if (bWriteMQuant)
		{
			ASSERT(bWriteTCOEFF);
		}

		/* we should only have CBP if we have coefficients
		 */
		if (unCBP)
		{
			ASSERT(bWriteTCOEFF);
			ASSERT(uBlockCount > 0);
		}

	    /* Write the MacroBlock Header
		 */

#ifndef RING0
#ifdef DEBUG_MBLK
		{
			int iLength;
			char buf180[180];
			iLength = wsprintf(buf180,
		    "Enc #%d: MBType=%ld bWriteMQuant=%ld MQuant=%ld bWriteMVD=%d MVDH=%ld MVDV=%ld CBP=%ld",
								(int) unCurrentMB,
								unMType, 
								(int) bWriteMQuant, 
								unMQuant,
								(int) bWriteMVD, 
								pCurrMB->BlkY1.PHMV / 2, 
								pCurrMB->BlkY1.PVMV / 2, 
								unCBP);
			DBOUT(buf180);
			ASSERT(iLength < 180);
		}
#endif
#endif
		/* MBA
		 */
	    PutBits(VLC_MBA[unMBA][1], VLC_MBA[unMBA][0], ppu8BitStream, pu8BitOffset);
       
	    /* MTYPE
		 */
		pBSInfo->uMTypeCount[unMType]++;
		pBSInfo->uBlockCount[unMType] += uBlockCount;
		PutBits(VLC_MTYPE[unMType][1], VLC_MTYPE[unMType][0], ppu8BitStream, pu8BitOffset);

		/* MQUANT
		 */
		if (bWriteMQuant) 
		{
			ASSERT(unMQuant > 0 && unMQuant < 32); /* 4.2.2.3 */
			PutBits((int)unMQuant, FIELDLEN_MQUANT, ppu8BitStream, pu8BitOffset);
		}

		/* MVD
		 */
		if (bWriteMVD)
		{
			ASSERT(inHDelta >= 0 && inHDelta < 32);
			ASSERT(inVDelta >= 0 && inVDelta < 32);
			PutBits(VLC_MVD[inHDelta][1], VLC_MVD[inHDelta][0], ppu8BitStream, pu8BitOffset);
			PutBits(VLC_MVD[inVDelta][1], VLC_MVD[inVDelta][0], ppu8BitStream, pu8BitOffset);
		}

		/* CBP
		 */
		if (unCBP != 0)
		{
			PutBits(VLC_CBP[unCBP][1], VLC_CBP[unCBP][0], ppu8BitStream, pu8BitOffset);
		}

		/* TCOEFF
		 */
		if (bWriteTCOEFF) 
		{
			/*
			 * Encode intra DC and all run/val pairs.
			 */
			MBEncodeVLC(
				&pMBRVS_Luma, 
				&pMBRVS_Chroma,
				pCurrMB->CodedBlocks, 
				ppu8BitStream, 
				pu8BitOffset, 
				bIntraBlock,
				1);
		}

		
  } /* for iMBIndex */
  

} /* end of GOB_VLC_WriteBS() */





/*****************************************************************************
 *
 *  MB_Quantize_RLE
 *
 *  Takes the list of coefficient pairs from the DCT routine and returns a list 
 *  of Run/Level/Sign triples (each 1 byte).  The end of the run/level/sign 
 *  triples for a block is signalled by an illegal combination (TBD).
 */
static I8 * MB_Quantize_RLE(
		I32 ** ppiDCTCoefs,
		I8 * pi8MBRunValTriplets,
		U8 * pu8CodedBlocks,
		U8 u8BlockType,
		I32 iQP,
		U32 * puCheckSum
		)
{
	I32 iBlockNumber;
	U8 u8Bitmask = 1;
	I8 * pi8EndAddress;
	U32 uCheckSum;

	#ifdef DEBUG_DCT
	int  iDCTArray[64];
	#endif

	/*
	 * Loop through all 6 blocks of macroblock.
	 */
	uCheckSum = 0;
	for(iBlockNumber = 0; iBlockNumber < 6; iBlockNumber++, u8Bitmask <<= 1)
	{

		#ifdef DEBUG_ENC
		wsprintf(string, "Block #%d", iBlockNumber);
		trace(string);
		#endif

		/* Skip this block if not coded.
		 */
		if( (*pu8CodedBlocks & u8Bitmask) == 0)
		{
			continue;
		}

		#ifdef DEBUG_DCT
		cnvt_fdct_output((unsigned short *) *ppiDCTCoefs, iDCTArray, IsIntraBlock(u8BlockType));
		#endif
	
		/*
		 * Quantize and run-length encode a block.
		 */  
	    pi8EndAddress = QUANTRLE(*ppiDCTCoefs, pi8MBRunValTriplets, iQP, (I32)u8BlockType);

		#ifdef DEBUG_ENC
		I8 * pi8;
		for(pi8 = pi8MBRunValTriplets; pi8 < pi8EndAddress; pi8+=3)
		{
			wsprintf(string, "(%u, %u, %d)", (unsigned char)*pi8, (unsigned char)*(pi8+1), (int)*(pi8+2) );
			trace(string);
		}
		#endif
		#ifdef CHECKSUM_MACRO_BLOCK
		uCheckSum += ComputeCheckSum(pi8MBRunValTriplets, pi8EndAddress, iBlockNumber);
		#endif

		/* Clear coded block bit for this block.
		 */
		if ( pi8EndAddress == pi8MBRunValTriplets)
		{
			ASSERT(u8BlockType != INTRABLOCK)	/* should have at least INTRADC in an INTRA blck */
			*pu8CodedBlocks &= ~u8Bitmask;
		}
		else if ( (pi8EndAddress == (pi8MBRunValTriplets+3)) && (u8BlockType == INTRABLOCK) )
		{
			*pu8CodedBlocks &= ~u8Bitmask;
			pi8MBRunValTriplets = pi8EndAddress;
		}
		else
		{
			pi8MBRunValTriplets = pi8EndAddress;
			*pi8MBRunValTriplets = -1;		/* Assign an illegal run to signal end of block. */
			pi8MBRunValTriplets += 3;		/* Increment to the next triple. */
		}

		/*  Increment DCT Coefficient pointer to next block.
		 */
		*ppiDCTCoefs += 32;		
	}

	*puCheckSum = uCheckSum;

	return pi8MBRunValTriplets;

} /* end MB_Quantize_RLE() */


void InitVLC(void)
{
  int i;
  int run, level;

  /*
   * initialize INTRADC fixed length code table.
   */
  for(i = 1; i < 254; i++)
  {
    FLC_INTRADC[i] = i;
  }
  FLC_INTRADC[0] = 1;
  FLC_INTRADC[128] = 255;
  FLC_INTRADC[254] = 254;
  FLC_INTRADC[255] = 254;

 /*
  * Initialize tcoef tables.
  */

   for(i = 0; i < (NUMBER_OF_TCOEF_ENTRIES); i++) {
      VLC_TCOEF_TBL[i] = 0x0000FFFF;
   }
  
   for(run = 0; run < 64; run++) {
      for(level = 1; level <= TCOEF_RUN_MAXLEVEL[run].maxlevel; level++) {
         DWORD dwSize, dwCode;

         dwSize = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1) * 2);
         dwSize <<= 16;
         dwCode = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1) * 2 + 1);

         VLC_TCOEF_TBL[run + (level - 1) * 64] = dwCode;
         VLC_TCOEF_TBL[run + (level - 1) * 64] |= dwSize;
	   } // end of for level
   } // end of for run

} // InitVLC.


#ifdef CHECKSUM_MACRO_BLOCK
/*****************************************************************************
 *
 *  ComputeCheckSum
 *
 *  Compute the checksum for this block
 */
static U32 ComputeCheckSum(
	I8 * pi8MBRunValTriplets,
	I8 * pi8EndAddress,
	I32 iBlockNumber)
{
	I8 * pi8;
	U32 uRun;
	U32 uLevel;
	I32 iSign;
	U32 uSignBit;
	U32 uCheckSum = 0;
	#if CHECKSUM_MACRO_BLOCK_DETAIL
	char buf80[80];
	int iLength;
	#endif
	
	for (pi8 = pi8MBRunValTriplets; pi8 < pi8EndAddress; )
	{
		uRun = (U32)*pi8++;
		uLevel = (U32)(U8)*pi8++;
		iSign = (I32)*pi8++;
		if (iSign == 0) 
		{
			uSignBit = 0;
		}
		else
		{
			ASSERT(iSign == 0xFFFFFFFF);
			uSignBit = 1;
		}

		uCheckSum += uRun << 24;
		uCheckSum += uLevel << 8;
		uCheckSum += uSignBit;

		#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
		iLength = wsprintf(buf80,"Block=%d R=0x%x L=0x%x S=%d, CheckSum=0x%x", iBlockNumber, uRun, uLevel, uSignBit, uCheckSum);
		DBOUT(buf80);
		ASSERT(iLength < 80);
		#endif
	}
	
	return uCheckSum;
} /* end ComputeCheckSum() */


/*****************************************************************************
 *
 *  WriteMBCheckSum
 *
 *  Write the macro block checksum information.
 */
static void WriteMBCheckSum(
	U32 uCheckSum,
	U8 * pu8PictureStart, 
	U8 ** ppu8BitStream, 
	U8 * pu8BitOffset,
	UN unCurrentMB)
{
	U32 uBytes;
	U32 uTempBytes;
	U8 u8Bits;
	U8 u8TempBits;
	UN unCount;
	UN unKey;
	UN unData;

	uBytes = *ppu8BitStream - pu8PictureStart;
	u8Bits = *pu8BitOffset;

	/* Add in the space for the checksum info (eleven 8-bit fields + 12 "1"s + MBA stuffing)
	 */
	uBytes += 12;
	u8Bits += 4 + FIELDLEN_MBA_STUFFING;

	/* Adjust bits to < 7 
	 */
	while (u8Bits > 7)
	{
		u8Bits -= 8;
		uBytes++;
	}

	#if _DEBUG
	#if CHECKSUM_MACRO_BLOCK_DETAIL
	{
	char buf80[80];
	int iLength;

	iLength = wsprintf(buf80,"MB=%d CHK=0x%x Bytes=%ld Bits=%d", unCurrentMB, uCheckSum, uBytes, (int) u8Bits);
	DBOUT(buf80);
	ASSERT(iLength < 80);
	}
	#endif
	#endif

	/* Write the MBASTUFFING value 
	 */
	PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8BitStream, pu8BitOffset);

	/* Write the data to the bitstream
	 */

	/* Key - a value of 1 in an 8-bit field following a "1"
	 */
	unKey = 1;
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unKey, 8, ppu8BitStream, pu8BitOffset);
	
	/* Count - number of bits after the Count field.
	 */
	unCount = 9*8 + 10*1;  /* nine 8-bit value and 10 "1"s. */
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unCount, 8, ppu8BitStream, pu8BitOffset);

	/* Bytes - high to low bytes
	 */
	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Bits
	 */
	unData = (UN) u8Bits;
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Checksum - high to low bytes
	 */
	unData = (UN) ((uCheckSum >> 24) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uCheckSum >> 16) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uCheckSum >> 8) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) (uCheckSum & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Trailing 1 bit to avoid start code duplication.
	 */
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);

	/* Check that the pointers are correct
	 */
	uTempBytes = *ppu8BitStream - pu8PictureStart;
	u8TempBits = *pu8BitOffset;

	while (u8TempBits > 7) 
	{
		u8TempBits -= 8;
		uTempBytes++;
	}

	ASSERT(uTempBytes == uBytes);
	ASSERT(u8TempBits == u8Bits);

} /* end WriteMBCheckSum() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1stat.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  e1stat.h
 *
 *  Description:
 *		Encoder statistics interface
 *
 *  Notes
 *      - Functions are only defined ifdef ENCODE_STATS.  The data structures
 *        are always defined inorder that we have one memory layout regardless
 *        or our build parameters.
 */

// $Header:   R:\h26x\h26x\src\enc\e1stat.h_v   1.1   20 Mar 1996 14:20:28   Sylvia_C_Day  $
// $Log:   R:\h26x\h26x\src\enc\e1stat.h_v  $
;// 
;//    Rev 1.1   20 Mar 1996 14:20:28   Sylvia_C_Day
;// Added lower level timing stats for SLF_UV
;// 
;//    Rev 1.0   26 Dec 1995 17:46:14   DBRUCKS
;// Initial revision.

#ifndef __E1STAT_H__
#define __E1STAT_H__

/* Encoder BitStream Data
 */
typedef struct {
	U32 uMTypeCount[10];
	U32 uBlockCount[10];				
	U32 uKeyFrameCount;					
	U32 uDeltaFrameCount;				
	U32 uTotalDeltaBytes;				
	U32 uTotalKeyBytes;
	U32 uQuantsUsedOnBlocks[32];
	U32 uQuantsTransmittedOnBlocks[32];
} ENC_BITSTREAM_INFO;

/* Encoder Timing Data - per frame
 */
typedef struct {
	U32 uEncodeFrame;
	U32 uInputCC;
	U32 uMotionEstimation;
	U32 uFDCT;
	U32 uQRLE;
	U32 uDecodeFrame;
	U32 uZeroingBuffer;
	U32 uSLF_UV;
} ENC_TIMING_INFO;

#define ENC_TIMING_INFO_FRAME_COUNT 100

#ifdef ENCODE_STATS

extern void OutputEncodeBitStreamStatistics(char * szFileName, ENC_BITSTREAM_INFO * pBSInfo, int bCIF);
extern void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo);

#endif /* ENCODE_STATS */

#endif /* __E1STAT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   AGUPTA2  $
// $Date:   14 Apr 1997 16:58:24  $
// $Archive:   S:\h26x\src\enc\e1rtp.h_v  $
// $Header:   S:\h26x\src\enc\e1rtp.h_v   1.1   14 Apr 1997 16:58:24   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1rtp.h_v  $
// 
//    Rev 1.1   14 Apr 1997 16:58:24   AGUPTA2
// Added a new function to return size of just the extended bit-stream (RTP pa
// 
//    Rev 1.0   21 Aug 1996 18:32:00   RHAZRA
// Initial revision.
;// 
;//    Rev 1.0   22 Apr 1996 17:09:46   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.4   01 Mar 1996 16:36:30   DBRUCKS
;// 
;// add unPacketSize parameter to H263RTP_InitBsInfoStream
;// 
;//    Rev 1.3   23 Feb 1996 16:18:46   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:00:48   CZHU
;// ean up
;// Clean up
;// 
;//    Rev 1.1   14 Feb 1996 14:59:38   CZHU
;// Support both mode A and mode B payload modes.
;// 
;//    Rev 1.0   12 Feb 1996 17:04:46   CZHU
;// Initial revision.
;// 
;//    Rev 1.3   11 Dec 1995 14:53:24   CZHU
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H261_RTP_INC_
#define  _H261_RTP_INC_

extern  I32 H261RTP_InitBsInfoStream(T_H263EncoderCatalog *, UINT unPacketSize);
extern 	I32 H261RTP_MBUpdateBsInfo  (T_H263EncoderCatalog *,
                                     T_MBlockActionStream *,
                                     U32,U32,U32,U8 *,U32 , UN, UN); 
extern  I32 H261RTP_GOBUpdateBsInfo  (T_H263EncoderCatalog *,U32,U8 *,U32); 
extern  void H261RTP_TermBsInfoStream(T_H263EncoderCatalog * );
extern  U32 H261RTP_AttachBsInfoStream(T_H263EncoderCatalog * ,U8 *, U32);
extern  U32 H261RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog * EC);
extern  U32 H261RTPFindMVs (T_H263EncoderCatalog *, T_MBlockActionStream * , 
                            /* U32 ,U32,*/ 
                            I8 [2], UN, UN);
extern  I32 H261RTP_RewindBsInfoStream(T_H263EncoderCatalog *, U32);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exbitsio.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbitsio.cpp
 *
 * Description:
 *		Routines to write fields to a bit stream buffer.
 *
 * Routines:						Prototypes in:
 *		BSWriteField					e3enc.h
 */

//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 15:32:50  $
// $Archive:   S:\h26x\src\enc\exbitsio.cpv  $
// $Header:   S:\h26x\src\enc\exbitsio.cpv   1.5   27 Dec 1995 15:32:50   RMCKENZX  $
// $Log:   S:\h26x\src\enc\exbitsio.cpv  $
// 
//    Rev 1.5   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
//    Rev 1.4   09 Nov 1995 14:11:22   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.3   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.2   25 Aug 1995 11:54:06   TRGARDOS
// 
// Debugged PutBits routine.
// 
//    Rev 1.1   14 Aug 1995 11:35:18   TRGARDOS
// y
// Finished writing picture frame header
// 
//    Rev 1.0   11 Aug 1995 17:28:34   TRGARDOS
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

/*************************************************************************
 * BSWriteField
 *
 * Write a field value of a specified size of bits into the
 * bitstream at the specified byte and bit offset.
 *
 * It is assumed that the field value is right justified
 * in the parameter fieldval, and field len never exceeds
 * 25.
 *
 * Returns void
 */
void PutBits(
	unsigned int fieldval,
	unsigned int fieldlen,
	unsigned char **pbs,
	unsigned char *bitoffset
	)
{
  unsigned int wordval;

  // Shift field left so that the field starts at
  // the current bit offset in the dword.
  fieldval <<= (32 - fieldlen) - *bitoffset;

  // Read in next dword starting at current byte position.
  wordval = (**pbs << 24) + (*(*pbs+1) << 16) + (*(*pbs+2) << 8) + *(*pbs+3);

  // Bitwise or the two dwords.
  wordval |= fieldval;

  // Write word back into memory, big-endian.
  *(*pbs+3) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+2) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+1) = wordval & 0xff;
  wordval >>= 8;
  **pbs = wordval & 0xff;

  // update byte and bit counters.
  *pbs += (*bitoffset + fieldlen) >> 3;
  *bitoffset = (*bitoffset + fieldlen) % 8;

} // end of BSWriteField function.


/*************************************************************
 *  CopyBits
 *
 ************************************************************/
void CopyBits(
    U8        **pDestBS,
    U8         *pDestBSOffset,
    const U8   *pSrcBS,
    const U32   uSrcBitOffset,
    const U32   uBits
)
{
    U32       bitstocopy, bitsinbyte;
    const U8 *sptr;

    if (uBits == 0) goto done;

    bitstocopy = uBits;
    sptr = pSrcBS + (uSrcBitOffset >> 3);
    bitsinbyte = 8 - (uSrcBitOffset & 0x7);
    if (bitsinbyte <= bitstocopy)
    {
        PutBits((*sptr) & ((1 << bitsinbyte) - 1),
                bitsinbyte, pDestBS, pDestBSOffset);
        bitstocopy -= bitsinbyte;
        sptr++;
    }
    else
    {
        PutBits( (*sptr >> (8 - (uSrcBitOffset & 0x7) - bitstocopy))
                 & ((1 << bitstocopy) - 1),
                bitstocopy, pDestBS, pDestBSOffset);
        goto done;
    }
    while (bitstocopy >= 8)
    {
        PutBits(*sptr, 8, pDestBS, pDestBSOffset);
        bitstocopy -= 8;
        sptr++;
    }
    if (bitstocopy > 0)
    {
        PutBits((*sptr)>>(8-bitstocopy), bitstocopy, pDestBS, pDestBSOffset);
    }

done:
    return;
}  //  CopyBits function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
                                                                      //
////////////////////////////////////////////////////////////////////////////
//
// $Author:   mbodart  $
// $Date:   17 Mar 1997 08:22:08  $
// $Archive:   S:\h26x\src\enc\exbase.cpv  $
// $Header:   S:\h26x\src\enc\exbase.cpv   1.73   17 Mar 1997 08:22:08   mbodart  $
// $Log:   S:\h26x\src\enc\exbase.cpv  $
// 
//    Rev 1.73   17 Mar 1997 08:22:08   mbodart
// Minor fixes.
// 
//    Rev 1.72   11 Mar 1997 13:46:46   JMCVEIGH
// Allow input = 320x240 and output = 320x240 for YUV12. This is
// for snapshot mode.
// 
//    Rev 1.71   10 Mar 1997 17:34:34   MDUDA
// Put in a check for 9-bit YUV12 and adjusted the internal compress
// structure instead of the input bitmap header info.
// 
//    Rev 1.70   10 Mar 1997 10:41:20   MDUDA
// Treating inconsistent format/bitwidth as a debug warning. Changing
// bit count to match format.
// 
//    Rev 1.69   07 Mar 1997 16:00:32   JMCVEIGH
// Added checks for non-NULL lpInst before getting H263PlusState. 
// Two separate "suggestions" for image sizes if input size is not
// supported in GetFormat. 
// 
//    Rev 1.68   07 Mar 1997 11:55:44   JMCVEIGH
// Moved query in GetFormat to after we have filled out the output
// format. This is because some apps. will ask for the format and
// then use the returned data, regardless if there was an error.
// Silly apps!
// 
//    Rev 1.67   07 Mar 1997 09:53:08   mbodart
// Added a call to _clearfp() in the Compress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.66   06 Mar 1997 15:39:26   KLILLEVO
// 
// CompressQuery now checks for input/output formats regardless
// of configuration status. Also put in trace support for lparam1 and lparam2.
// 
//    Rev 1.65   22 Jan 1997 12:17:14   MDUDA
// 
// Put in more checking for H263+ option in CompressQuery
// and CompressBegin.
// 
//    Rev 1.64   22 Jan 1997 08:11:22   JMCVEIGH
// Backward compatibility with crop/stretch for 160x120 and 240x180
// in CompressGetFormat(). Do old way unless we have received the
// H263Plus custom message.
// 
//    Rev 1.63   13 Jan 1997 10:52:14   JMCVEIGH
// 
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.62   09 Jan 1997 13:50:50   MDUDA
// Removed some _CODEC_STATS stuff.
// 
//    Rev 1.61   06 Jan 1997 17:42:30   JMCVEIGH
// If H263Plus message is not sent, encoder only supports standard
// frame sizes (sub-QCIF, QCIF, or CIF along with special cases),
// as before.
// 
//    Rev 1.60   30 Dec 1996 19:57:04   MDUDA
// Making sure that input formats agree with the bit count field.
// 
//    Rev 1.59   20 Dec 1996 15:25:28   MDUDA
// Fixed problem where YUV12 was enabled for crop and stretch.
// This feature is only allowed for RGB, YVU9 and YUY2.
// 
//    Rev 1.58   16 Dec 1996 13:36:08   MDUDA
// 
// Modified Compress Instance info for input color convertors.
// 
//    Rev 1.57   11 Dec 1996 16:01:20   MBODART
// In Compress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.56   09 Dec 1996 17:59:36   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.55   09 Dec 1996 09:50:12   MDUDA
// 
// Allowing 240x180 and 160x120 (crop and stretch) for YUY2.
// Modified _CODEC_STATS stuff.
// 
//    Rev 1.54   07 Nov 1996 14:45:16   RHAZRA
// Added buffer size adjustment to H.261 CompressGetSize() function
// 
//    Rev 1.53   31 Oct 1996 22:33:32   BECHOLS
// Decided buffer arbitration must be done in cxq_main.cpp for RTP.
// 
//    Rev 1.52   31 Oct 1996 21:55:50   BECHOLS
// Added fudge factor for RTP waiting for Raj to decide what he wants to do.
// 
//    Rev 1.51   31 Oct 1996 10:05:46   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.50   18 Oct 1996 14:35:46   MDUDA
// 
// Separated CompressGetSize and CompressQuery for H261 and H263 cases.
// 
//    Rev 1.49   11 Oct 1996 16:05:16   MDUDA
// 
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.48   16 Sep 1996 16:50:52   CZHU
// Return larger size for GetCompressedSize when RTP is enabled.
// 
//    Rev 1.47   13 Aug 1996 10:36:46   MDUDA
// 
// Now allowing RGB4 input format.
// 
//    Rev 1.46   09 Aug 1996 09:43:30   MDUDA
// Now allowing RGB16 format on input. This is generated by the color Quick Ca
// 
//    Rev 1.45   02 Aug 1996 13:45:58   MDUDA
// 
// Went back to previous version that allows RGB8 and RGB24 in
// 240x180 and 160x120 frames.
// 
//    Rev 1.44   01 Aug 1996 11:54:58   BECHOLS
// Cut & Paste Error.
// 
//    Rev 1.43   01 Aug 1996 11:20:28   BECHOLS
// Fixed handling of RGB 24 bit stuff so that it doesn't allow sizes other
// than QCIF, SQCIF, or CIF.  I broke this earlier when I added the RGB 8
// bit support. ...
// 
//    Rev 1.42   22 Jul 1996 13:31:16   BECHOLS
// 
// Added code to allow a CLUT8 input providing that the input resolutions
// are either 240x180 or 160x120.
// 
//    Rev 1.41   11 Jul 1996 15:43:58   MDUDA
// Added support for YVU9 240 x 180 and 160 x 120 for H263 only.
// We now produce subQCIF for 160x120 and QCIF for 240x180.
// 
//    Rev 1.40   05 Jun 1996 10:57:54   AKASAI
// Added #ifndef H261 in CompressQuery to make sure that H.261 will
// only support FCIF and QCIF input image sizes.  All other input sizes
// should return ICERR_BADFORMAT.
// 
//    Rev 1.39   30 May 1996 17:02:34   RHAZRA
// Added SQCIF support for H.263 in CompressGetSize()
// 
//    Rev 1.38   06 May 1996 12:47:40   BECHOLS
// Changed the structure element to unBytesPerSecond.
// 
//    Rev 1.37   06 May 1996 00:09:44   BECHOLS
// Changed the handling of the CompressFramesInfo message to get DataRate
// from the configuration data if the configuration has the data, and
// we haven't received a CompressBegin message yet.
// 
//    Rev 1.36   23 Apr 1996 16:51:20   KLILLEVO
// moved paranthesis to fix format check in CompressQuery()
// 
//    Rev 1.35   18 Apr 1996 16:07:10   RHAZRA
// Fixed CompressQuery to keep compiler happy for the non-MICROSOFT version
// 
//    Rev 1.34   18 Apr 1996 15:57:46   BECHOLS
// RAJ- Changed the query logic to correctly filter the allowable resolutions
// for compression.
// 
//    Rev 1.33   12 Apr 1996 14:15:40   RHAZRA
// Added paranthesis in CompressGetSize() to make the ifdef case work
// 
//    Rev 1.32   12 Apr 1996 13:31:02   RHAZRA
// Added SQCIF support in CompressGetSize() with #ifdef SUPPORT_SQCIF;
// changed CompressGetSize() to return 0 if the input format is not
// supported.
// 
//    Rev 1.31   10 Apr 1996 16:53:08   RHAZRA
// Added a error return in CompressGetSize() to keep complier smiling...
// 
//    Rev 1.30   10 Apr 1996 16:39:56   RHAZRA
// Added a check for the 320x240 size in CompressGetSize() function;
// added a ifndef to disable certain sizes and compression formats.
// 
//    Rev 1.29   04 Apr 1996 13:35:00   RHAZRA
// Changed CompressGetSize() to return spec-compliant buffer sizes.
// 
//    Rev 1.28   03 Apr 1996 08:39:52   SCDAY
// Added H261 specific code to CompressGetSize to limit buffer size
// as defined in H261 spec
// 
//    Rev 1.27   21 Feb 1996 11:43:12   SCDAY
// cleaned up compiler build warning by changing conversion frlDataRate to (U3
// 
//    Rev 1.26   15 Feb 1996 16:03:36   RHAZRA
// 
// Added a check for NULL lpInst pointer in CompressGetFormat()
// 
//    Rev 1.25   02 Feb 1996 18:53:46   TRGARDOS
// Changed code to read frame rate from Compressor Instance
// instead of the hack from Quality field.
// 
//    Rev 1.24   26 Jan 1996 09:35:32   TRGARDOS
// Added #ifndef H261 for 160x120,320x240 support.
// 
//    Rev 1.23   04 Jan 1996 18:36:54   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.22   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef  YUV9FROMFILE
PAVIFILE paviFile;
PAVISTREAM paviStream; 
U8 huge * glpTmp;
HGLOBAL hgMem;
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns a format that 
;//                 we can deliver back to the caller.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressGetFormat(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    DWORD dwQuery;

	// lpInst == NULL is OK
	// this is what you get on ICOpen(...,ICMODE_QUERY)
#if 0
    if (lpInst == NULL) {
       DBOUT("CompressGetFormat: got a NULL lpInst pointer");
       return ((DWORD) ICERR_ERROR);
    }
#endif

    if(dwQuery = CompressQuery(lpInst, lParam1, NULL)) {
        DBOUT("encbase.c :: CompressGetFormat :: ICERR_BADFORMAT")
        return(dwQuery);
    }
    if(lParam2 == NULL) {
        // he just want me to return the output buffer size. 
        return ((DWORD)sizeof(BITMAPINFOHEADER));
    }

	// Check pointer
	if (!lParam1)
		return ICERR_ERROR;

    // give him back what he passed with our stuff in it 
	#ifndef WIN32
    (void)_fmemcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#else
	 (void)memcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#endif

    lParam2->biBitCount = 24;
    lParam2->biCompression = FOURCC_H263;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState);

	if (!bH263PlusState) {
		// For backward compatibility, make sure the crop and stretch cases are covered.
		if ( (lParam1->biCompression == FOURCC_YVU9) ||
			 (lParam1->biCompression == FOURCC_YUY2) ||
			 (lParam1->biCompression == FOURCC_UYVY) ||
			 (lParam1->biCompression == FOURCC_YUV12) ||
			 (lParam1->biCompression == FOURCC_IYUV) ||
			 (lParam1->biCompression == BI_RGB) )
		{
			if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
			{
				lParam2->biWidth        = 176;
				lParam2->biHeight       = 144;
			}
			if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
			{
				lParam2->biWidth        = 128;
				lParam2->biHeight       = 96;
			}
		}
	}
#else
	if ( (lParam1->biCompression == FOURCC_YVU9) ||
		 (lParam1->biCompression == FOURCC_YUY2) ||
		 (lParam1->biCompression == FOURCC_UYVY) ||
		 (lParam1->biCompression == FOURCC_YUV12) ||
		 (lParam1->biCompression == FOURCC_IYUV) ||
		 (lParam1->biCompression == BI_RGB) )
	{
		if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
			lParam2->biWidth        = 176;
			lParam2->biHeight       = 144;
		}
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
			lParam2->biWidth        = 128;
			lParam2->biHeight       = 96;
		}
	}
	else
	{
    	lParam2->biWidth        = MOD4(lParam1->biWidth);
    	lParam2->biHeight       = MOD4(lParam1->biHeight);
	}
#endif

    lParam2->biClrUsed      = 0;
    lParam2->biClrImportant = 0;
    lParam2->biPlanes       = 1;        
    lParam2->biSizeImage    = CompressGetSize(lpInst, lParam1, lParam2);
    return(ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns the maximum
;//                 size that a compressed buffer can be.  This size is
;//                 guaranteed in encoder design.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	if ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
		((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
		((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) {
		dwRet = 8192L;
	} else
		if  (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
			 ((lParam1->biWidth == 320) && (lParam1->biHeight == 240))) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			DBOUT("CompressGetSize:ICERR_BADIMAGESIZE");
			dwRet = 0;
		}  

	// Adjust the buffer size for RTP. Note that this adjustment will be performed
	// only if the codec has been told previously to use RTP and the RTP-related
	// information has been initialized. Therefore, the current (11/7) AM interface
	// will not take advantage of this routine.

#if 0
	if (dwRet && lpInst && lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += H261EstimateRTPOverhead(lpInst, lParam1);
	}
#endif

	return dwRet;
}
#else
/* H.263 case */
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

    if (lParam1 == NULL)
	{
		// We will use a size of zero to indicate an error for CompressGetSize
 	    dwRet = 0;
        return dwRet;
    }

#ifndef H263P
	if (((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
		((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
		((lParam1->biWidth == 160) && (lParam1->biHeight == 120))) {
		dwRet = 8192L;
	} else
		if  (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
			 ((lParam1->biWidth == 320) && (lParam1->biHeight == 240))) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			DBOUT("CompressGetSize:ICERR_BADIMAGESIZE");
			dwRet = 0;
		}  
#else
	// H.263+
	U32 unPaddedWidth;
	U32 unPaddedHeight;
	U32 unSourceFormatSize;

	// Base buffer size on frame dimensions padded to multiples of 16
	if (lParam2 == NULL) 
	{
		// In case an old application passed in a NULL pointer in lParam2,
		// we use the input frame dimensions to calculate the format size
		unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
	} 
	else 
	{
		unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
	}

	unSourceFormatSize = unPaddedWidth * unPaddedHeight;

	// See Table 1/H.263, document LBC-96-358
	if (unSourceFormatSize < 25348)
		dwRet = 8192L;
	else if (unSourceFormatSize < 101380)
		dwRet = 32768L;
	else if (unSourceFormatSize < 405508)
		dwRet = 65536L;
	else 
		dwRet = 131072L;
#endif

	//adjust if RTP is enabled, based on information in Configuration
   	//Size calculated using DataRate, FrameRate in lpInst, 
	//and lpInst->Configuration.unPacketSize;
	//Chad, 9/12/96
#if 0
 	if (dwRet && lpInst &&
		lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += getRTPBsInfoSize(lpInst);
	}
#endif

	return dwRet;
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    // Check for good input format

    if(NULL == lParam1)                          
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_UYVY) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if(!
      ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    	((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

#ifndef MICROSOFT
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
		  ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
#endif
	  ))
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( lParam1->biPlanes != 1 )
    {
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
    }

    if(0 == lParam2)                            // Checking input only
		return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
    {
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
    }

    return(ICERR_OK);
}
#else
/* H.263 case */
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState); 
#endif

    // Check for good input format

    if(NULL == lParam1)                          
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
#ifdef H263P
			(lParam1->biBitCount != 32) &&
#endif
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

#ifndef H263P
    if(!
      ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    	((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    	((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

	#ifndef MICROSOFT
	  ||
	  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
			(lParam1->biCompression == FOURCC_YUY2) ||
			(lParam1->biCompression == BI_RGB) )
	  		&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
	  ||
	  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
			(lParam1->biCompression == FOURCC_YUY2) ||
			(lParam1->biCompression == BI_RGB) )
	  		&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
	  ||
	  ( (   (lParam1->biCompression == FOURCC_YUV12) ||
			(lParam1->biCompression == FOURCC_IYUV) )
	  		&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
	#endif
	  ))
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}
#else
	if (((FOURCC_YVU9 == lParam1->biCompression) && (9 != lParam1->biBitCount)) ||
	    ((FOURCC_YUY2 == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
	    (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (12 != lParam1->biBitCount)))
	{
		DBOUT("CompressQuery:Incorrect bit width (ICERR_BADFORMAT)");
		return((DWORD)ICERR_BADFORMAT);
	}

	// The H263+ message indicates whether arbitrary frame
	// sizes are to be supported. If arbitrary frames are needed,
	// the H263+ message must be sent before the first call to
	// CompressQuery.

	if (bH263PlusState) {
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288)) {
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ) ||
		  ( (   (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV))
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) ) ))
		{
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

	if( lParam1->biPlanes != 1 )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

 	if(lParam2 == 0)                            // Checking input only
        return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

#if defined(H263P)
	if (bH263PlusState) {
		if ((lParam1->biWidth != lParam2->biWidth) ||
			(lParam1->biHeight != lParam2->biHeight)) {
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return ((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
			(( ( ((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
			     ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			     ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ) &&
			   (lParam1->biWidth == lParam2->biWidth) && (lParam1->biHeight == lParam2->biHeight) ) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) &&
	  			((lParam2->biWidth == 128) && (lParam2->biHeight == 96)))) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) &&
	  			((lParam2->biWidth == 176) && (lParam2->biHeight == 144)))) ||
			 (((lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV)) &&
			   (((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) &&
	  			((lParam2->biWidth == 320) && (lParam2->biHeight == 240)))) ) )
		{
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return ((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

	return(ICERR_OK);
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressFramesInfo(LPCODINST, ICCOMPRESSFRAMES *);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressFramesInfo(LPCODINST lpCompInst, ICCOMPRESSFRAMES *lParam1, int lParam2)
{
	FX_ENTRY("CompressFramesInfo");

	// Check to see if we are given a nonzero pointer.
	if (lpCompInst == NULL)
	{
		ERRORMESSAGE(("%s: CompressFramesInfo called with NULL parameter - returning ICERR_BADFORMAT", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	// lParam2 should be the size of the structure.
	if (lParam2 != sizeof(ICCOMPRESSFRAMES))
	{
		ERRORMESSAGE(("%s: wrong size of ICOMPRESSFRAMES structure", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	if (!lParam1 || (lParam1->dwScale == 0))
	{
		ERRORMESSAGE(("%s: dwScale is zero", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	lpCompInst->FrameRate = (float)lParam1->dwRate / (float)lParam1->dwScale;

	lpCompInst->DataRate  = (U32)lParam1->lDataRate;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Setting frame rate at %ld.%ld fps and bitrate at %ld bps", _fx_, (DWORD)lpCompInst->FrameRate, (DWORD)((lpCompInst->FrameRate - (float)(DWORD)lpCompInst->FrameRate) * 100.0f), lpCompInst->DataRate * 8UL));

	return ((DWORD)ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       BOOL bIsOkRes(LPCODINST);
;//
;// Description:    This function checks whether the desired height and
;//                 width are possible.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
BOOL bIsOkRes(LPCODINST lpCompInst)
{
    BOOL    bRet;

	// Check for NULL pointer
	if (lpCompInst == NULL)
		return 0;

    bRet = lpCompInst->xres <= 352
        && lpCompInst->yres <= 288
        && lpCompInst->xres >= 4
        && lpCompInst->yres >= 4
        && (lpCompInst->xres & ~3) == lpCompInst->xres
        && (lpCompInst->yres & ~3) == lpCompInst->yres;

    return(bRet);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressBegin(
		LPCODINST lpCompInst,
		LPBITMAPINFOHEADER lParam1,
		LPBITMAPINFOHEADER lParam2
	)
{
    DWORD dwQuery;
	LRESULT retval;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;
	if (lpCompInst)
		CustomGetH263PlusState(lpCompInst, (DWORD FAR *)&bH263PlusState);
#endif

	// Check input and output format.
    if( (dwQuery = CompressQuery(lpCompInst, lParam1, lParam2)) != ICERR_OK)
        return(dwQuery);

	// Check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

#ifdef H263P
	lpCompInst->InputCompression = lParam1->biCompression;
	lpCompInst->InputBitWidth = lParam1->biBitCount;
	if (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (9 == lParam1->biBitCount)) {
		lpCompInst->InputBitWidth = 12;
	}

	if ( lParam2 && bH263PlusState)
	{
		// This is the "new" style for indicating if the input should 
		// be cropped/stretched to a standard frame size.
		// Old applications may pass in NULL or junk for lparam2.
		// New applications should pass a valid lParam2 that indicates
		// the desired output frame size. Also, the H263Plus flag must
		// be set in the configuration structure before calling CompressBegin()
	    lpCompInst->xres    = (WORD)lParam2->biWidth;
		lpCompInst->yres    = (WORD)lParam2->biHeight;

	} else	
#endif // H263P
	{
		lpCompInst->xres    = (WORD)lParam1->biWidth;
		lpCompInst->yres    = (WORD)lParam1->biHeight;

		lpCompInst->Is160x120 = FALSE;
		lpCompInst->Is240x180 = FALSE;
		lpCompInst->Is320x240 = FALSE;
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
		  lpCompInst->xres    = 128;
		  lpCompInst->yres    = 96;
		  lpCompInst->Is160x120 = TRUE;
		}
		else if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
		  lpCompInst->xres    = 176;
		  lpCompInst->yres    = 144;
		  lpCompInst->Is240x180 = TRUE;
		}
		else if ( (lParam1->biWidth == 320) && (lParam1->biHeight == 240) )
		{
		  lpCompInst->xres    = 352;
		  lpCompInst->yres    = 288;
		  lpCompInst->Is320x240 = TRUE;
		}
	}

    if(!bIsOkRes(lpCompInst))
        return((DWORD)ICERR_BADIMAGESIZE);

    // Set frame size.
    if (lpCompInst->xres == 128 && lpCompInst->yres == 96)
  	  lpCompInst->FrameSz = SQCIF;
    else if (lpCompInst->xres == 176 && lpCompInst->yres == 144)
      lpCompInst->FrameSz = QCIF;
    else if (lpCompInst->xres == 352 && lpCompInst->yres == 288)
      lpCompInst->FrameSz = CIF;
#ifdef H263P
	else
	  lpCompInst->FrameSz = CUSTOM;
#else
    else	// unsupported frame size.
      return (DWORD)ICERR_BADIMAGESIZE;
#endif


    // Allocate and Initialize tables and memory that are specific to
    // this instance.
#if defined(H263P)
    retval = H263InitEncoderInstance(lParam1,lpCompInst);
#else
    retval = H263InitEncoderInstance(lpCompInst);
#endif

    return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressEnd(LPCODINST);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressEnd(LPCODINST lpInst)
{  
  LRESULT retval;

  retval = H263TermEncoderInstance(lpInst);
  
  return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL Compress(
				LPCODINST lpInst,			// ptr to Compressor instance information.
				ICCOMPRESS FAR * lpCompInfo, // ptr to ICCOMPRESS structure.
				DWORD dOutbufSize			// size, in bytes, of the ICCOMPRESS structure.
			)
{
    DWORD dwRet;
       
	// Check to see if we are given a NULL pointer.
	if(lpInst == NULL || lpCompInfo == NULL)
	{
		DBOUT("Compress called with NULL parameter");;
		return( (DWORD) ICERR_ERROR );
	}

	try
	{
		dwRet = H263Compress(lpInst, lpCompInfo);
	}
	catch (...)
	{
        // For a DEBUG build, display a message and pass the exception up.
        // For a release build, stop the exception here and return an error
        // code.  This gives upstream code a chance to gracefully recover.
		// We also need to clear the floating point control word, otherwise
		// the upstream code may incur an exception the next time it tries
		// a floating point operation (presuming this exception was due
		// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
        DBOUT("Exception during H263Compress!!!");
        throw;
#else
		_clearfp();
        return (DWORD) ICERR_ERROR;
#endif
	}

    if (dwRet != ICERR_OK)
	{
        DBOUT("H263Compress Failed");
	}

    // now transfer the information.
    lpCompInfo->lpbiOutput->biSize =sizeof(BITMAPINFOHEADER);
    lpCompInfo->lpbiOutput->biCompression  = FOURCC_H263;
    lpCompInfo->lpbiOutput->biPlanes       = 1;
    lpCompInfo->lpbiOutput->biBitCount     = 24;
    lpCompInfo->lpbiOutput->biWidth        = lpInst->xres;
    lpCompInfo->lpbiOutput->biHeight       = lpInst->yres;
    lpCompInfo->lpbiOutput->biSizeImage    = lpInst->CompressedSize;
    lpCompInfo->lpbiOutput->biClrUsed      = 0;
    lpCompInfo->lpbiOutput->biClrImportant = 0;

	// lpCompInfo->dwFlags is set inside the compressor.

	// set the chunk idea if requested
	if (lpCompInfo->lpckid)
	{
		*(lpCompInfo->lpckid) = TWOCC_H26X;
	}
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1stat.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * e1stat.cpp
 *
 * DESCRIPTION:
 *		Encoder statistics functions
 *
 * Routines:						Prototypes in:
 *  OutputEncodeTimingStatistics	e1stat.h	
 */

// $Header:   R:\h26x\h26x\src\enc\e1stat.cpv   1.2   20 Mar 1996 14:20:58   Sylvia_C_Day  $
// $Log:   R:\h26x\h26x\src\enc\e1stat.cpv  $
// 
//    Rev 1.2   20 Mar 1996 14:20:58   Sylvia_C_Day
// Added lower level timing stats for SLF_UV
// 
//    Rev 1.1   29 Dec 1995 18:08:56   DBRUCKS
// add average quant used and coded
// 
//    Rev 1.0   26 Dec 1995 17:46:16   DBRUCKS
// Initial revision.

#include "precomp.h"

#ifdef ENCODE_STATS

static void OutputEncTimingDetail(FILE * pFile,	ENC_TIMING_INFO * pEncTimingInfo);

/************************************************************************
 *
 *  OutputEncodeBitStreamStatistics
 */
extern void OutputEncodeBitStreamStatistics(
	char * szFileName,
	ENC_BITSTREAM_INFO * pBSInfo,
	int bCIF)
{
	FILE * pFile;
	U32 uTotalMBs;
	U32 uProcessedMBs;
	U32 uCOEFFBlocks;
	U32 uSkippedMBs;
	U32 uTotalQuantUsed;
	U32 uTotalQuantCoded;
	int i;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
	    DBOUT("Error opening encode stat file");
	    goto done;
	}

	/* Update the statistics
	 */
	if (bCIF)
	{
		uTotalMBs = (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) * 33 * 12;
	}
	else
	{
		uTotalMBs = (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) * 33 * 3;
	}

   	if (uTotalMBs == 0)
	{
		fprintf(pFile,"No Macro Blocks processed - skipping frame statistics\n");
		goto done;
	}

	uProcessedMBs = 0;
	uCOEFFBlocks = 0;
	for (i = 0 ; i < 10 ; i++)
	{
		uProcessedMBs += pBSInfo->uMTypeCount[i];
		uCOEFFBlocks += pBSInfo->uBlockCount[i];
	}
	uSkippedMBs = uTotalMBs - uProcessedMBs;

	fprintf(pFile,"Total Key Frames=%ld Delta Frames=%ld\n", 
		     pBSInfo->uKeyFrameCount, pBSInfo->uDeltaFrameCount);
	fprintf(pFile,"Total Total MBs=%ld\n", uTotalMBs);
	fprintf(pFile,"Total Coded MBs=%ld (%ld%%)\n", uProcessedMBs, ((uProcessedMBs*100)+(uTotalMBs/2))/uTotalMBs);
	fprintf(pFile,"Total Coded Blocks=%ld (%ld%%)\n", uCOEFFBlocks, ((uCOEFFBlocks*100)+(uTotalMBs/2))/(uTotalMBs*6));

	for (i = 0; i < 10 ; i++)
	{
		if (pBSInfo->uMTypeCount[i])
		{
			fprintf(pFile,"Total Coded MBType[%d]=%ld (%ld%%) blocks=%ld (%ld%%)\n", 
			        i, 
			        pBSInfo->uMTypeCount[i], 
			        ((pBSInfo->uMTypeCount[i]*100)+(uProcessedMBs/2))/uProcessedMBs,
				    pBSInfo->uBlockCount[i], 
				    ((pBSInfo->uBlockCount[i]*100)+(uCOEFFBlocks/2))/uCOEFFBlocks);
		}
	}

	if (pBSInfo->uKeyFrameCount)
	{
		fprintf(pFile,"Total Key Frame Bytes=%ld Average Per Key Frame=%ld\n",
	    	    pBSInfo->uTotalKeyBytes, 
	       		(pBSInfo->uTotalKeyBytes + (pBSInfo->uKeyFrameCount/2)) / pBSInfo->uKeyFrameCount);
	}
	if (pBSInfo->uDeltaFrameCount)
	{
		fprintf(pFile,"Total Delta Frame Bytes=%ld Average Per Delta Frame=%ld\n",
		        pBSInfo->uTotalDeltaBytes, 
		        (pBSInfo->uTotalDeltaBytes + (pBSInfo->uDeltaFrameCount/2)) / pBSInfo->uDeltaFrameCount);
	}
	if (pBSInfo->uKeyFrameCount || pBSInfo->uDeltaFrameCount)
	{
		fprintf(pFile,"Total Bytes=%ld Average Per Frame=%ld\n",
		        pBSInfo->uTotalKeyBytes + pBSInfo->uTotalDeltaBytes, 
		        ((pBSInfo->uTotalKeyBytes + pBSInfo->uTotalDeltaBytes) + ((pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) / 2)) / 
		        															(pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount));
	}

	/* Quantization Information
	 */
	uTotalQuantUsed = 0;
	uTotalQuantCoded = 0;
	for (i = 0; i <= 31; i++)
	{
		if (pBSInfo->uQuantsUsedOnBlocks[i])
		{
			fprintf(pFile,"QuantValue %2ld",i);
			fprintf(pFile," Used %7ld (%2ld%%)", pBSInfo->uQuantsUsedOnBlocks[i], 
				    ((pBSInfo->uQuantsUsedOnBlocks[i] * 100) + ((uTotalMBs*6)/2))/(uTotalMBs*6));
			fprintf(pFile," Coded %7ld (%2ld%%)\n", pBSInfo->uQuantsTransmittedOnBlocks[i],
				    ((pBSInfo->uQuantsTransmittedOnBlocks[i] * 100) + ((uTotalMBs*6)/2))/(uTotalMBs*6));
			uTotalQuantUsed += pBSInfo->uQuantsUsedOnBlocks[i] * i;
			uTotalQuantCoded += pBSInfo->uQuantsTransmittedOnBlocks[i] * i;
		}
		if (pBSInfo->uQuantsTransmittedOnBlocks[i])
			ASSERT(pBSInfo->uQuantsUsedOnBlocks[i]);
	}
	if ((uTotalMBs > 0) && (uCOEFFBlocks > 0))
	{
		fprintf(pFile,"Average Used %f Average Coded %f",
				(float) uTotalQuantUsed / (float)(uTotalMBs*6),
				(float) uTotalQuantCoded / (float) uCOEFFBlocks);
	}
	#ifdef _DEBUG
	{
		U32 uUsedTotal = 0;
		U32 uCodedTotal = 0;
		for (i = 0; i <= 31; i++)
		{	
			uUsedTotal += pBSInfo->uQuantsUsedOnBlocks[i];
			uCodedTotal += pBSInfo->uQuantsTransmittedOnBlocks[i];
		}
		ASSERT(uUsedTotal == (uTotalMBs*6));
		ASSERT(uCodedTotal == uCOEFFBlocks);
	}
	#endif

done:

	return;
} /* end OutputEncodeBitStreamStatistics() */


/************************************************************************
 *
 *  OutputEncodeTimingStatistics
 */
extern void OutputEncodeTimingStatistics(
    char * szFileName,
	ENC_TIMING_INFO * pEncTimingInfo)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
	    DBOUT("Error opening encode stat file");
	    goto done;
	}

	#ifdef DETAIL_ENCODE_STATS
		/* Output the detail information
		 */
		fprintf(pFile,"\nDetail Timing Information\n");
		for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; 
		      i < ENC_TIMING_INFO_FRAME_COUNT ; 
		      i++, pTempEncTimingInfo++ )
		{
			if (pTempEncTimingInfo->uDecodeFrame != 0)
			{
				fprintf(pFile, "Frame %d Detail Timing Information\n", i);
				OutputEncTimingDetail(pFile, pTempEncTimingInfo);
			}
		}
	#endif

	/* Compute the total information
	 */
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; 
	      i < ENC_TIMING_INFO_FRAME_COUNT ; 
	      i++, pTempEncTimingInfo++ )
	{
		if (pTempEncTimingInfo->uDecodeFrame != 0)
		{
			iCount++;

			etiTemp.uEncodeFrame      += pTempEncTimingInfo->uEncodeFrame;
			etiTemp.uInputCC	      += pTempEncTimingInfo->uInputCC;
			etiTemp.uMotionEstimation += pTempEncTimingInfo->uMotionEstimation;
			etiTemp.uFDCT             += pTempEncTimingInfo->uFDCT;
			etiTemp.uQRLE             += pTempEncTimingInfo->uQRLE;
			etiTemp.uDecodeFrame      += pTempEncTimingInfo->uDecodeFrame;
			etiTemp.uZeroingBuffer    += pTempEncTimingInfo->uZeroingBuffer;
			etiTemp.uSLF_UV           += pTempEncTimingInfo->uSLF_UV;
		}
	}

	if (iCount > 0) 
	{
		#ifdef DETAIL_ENCODE_STATS
			/* Output the total information
			 */
			fprintf(pFile,"Total for %d frames\n", iCount);
			OutputEncTimingDetail(pFile, &etiTemp);
		#endif

		/* Compute the average
		 */
		etiTemp.uEncodeFrame      = (etiTemp.uEncodeFrame + (iCount / 2)) / iCount;
		etiTemp.uInputCC	      = (etiTemp.uInputCC + (iCount / 2)) / iCount;
		etiTemp.uMotionEstimation = (etiTemp.uMotionEstimation + (iCount / 2)) / iCount;
		etiTemp.uFDCT             = (etiTemp.uFDCT + (iCount / 2)) / iCount;
		etiTemp.uQRLE             = (etiTemp.uQRLE + (iCount / 2)) / iCount;
		etiTemp.uDecodeFrame      = (etiTemp.uDecodeFrame + (iCount / 2)) / iCount;
		etiTemp.uZeroingBuffer    = (etiTemp.uZeroingBuffer + (iCount / 2)) / iCount;
		etiTemp.uSLF_UV           = (etiTemp.uSLF_UV + (iCount / 2)) / iCount;

		/* Output the average information
		 */
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
} /* OutputEncodeTimingStatistics() */

/************************************************************************
 *
 *  OutputEncTimingDetail
 */
static void OutputEncTimingDetail(
	FILE * pFile,
	ENC_TIMING_INFO * pEncTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tEncode Frame =     %10d (%d milliseconds at 90Mhz)\n", pEncTimingInfo->uEncodeFrame,
			(pEncTimingInfo->uEncodeFrame + 45000) / 90000);
	uOther = pEncTimingInfo->uEncodeFrame;
	
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pEncTimingInfo->uEncodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
	fprintf(pFile, "\tInputCC =          %10d (%2d%%)\n", pEncTimingInfo->uInputCC, 
			(pEncTimingInfo->uInputCC + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uInputCC;
								   
	fprintf(pFile, "\tMotionEstimation = %10d (%2d%%)\n", pEncTimingInfo->uMotionEstimation, 
			(pEncTimingInfo->uMotionEstimation + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uMotionEstimation;
								   
	fprintf(pFile, "\tFDCT =             %10d (%2d%%)\n", pEncTimingInfo->uFDCT, 
			(pEncTimingInfo->uFDCT + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uFDCT;

	fprintf(pFile, "\tQRLE =             %10d (%2d%%)\n", pEncTimingInfo->uQRLE, 
			(pEncTimingInfo->uQRLE + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uQRLE;
								   
	fprintf(pFile, "\tDecodeFrame =      %10d (%2d%%)\n", pEncTimingInfo->uDecodeFrame, 
			(pEncTimingInfo->uDecodeFrame + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uDecodeFrame;
								   
	fprintf(pFile, "\tZeroingBuffer =    %10d (%2d%%)\n", pEncTimingInfo->uZeroingBuffer, 
			(pEncTimingInfo->uZeroingBuffer + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uZeroingBuffer;
								   
	fprintf(pFile, "\tSLF_UV =           %10d (%2d%%)\n", pEncTimingInfo->uSLF_UV, 
			(pEncTimingInfo->uSLF_UV + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uSLF_UV;

	fprintf(pFile, "\tOther =            %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);


} /* end OutputEncTimingDetail() */

#endif /* ENCODE_STATS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exbrc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Header:   S:\h26x\src\enc\exbrc.h_v   1.2   12 Mar 1996 13:26:58   KLILLEVO  $
// $Log:   S:\h26x\src\enc\exbrc.h_v  $
;// 
;//    Rev 1.2   12 Mar 1996 13:26:58   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.1   05 Feb 1996 17:15:22   TRGARDOS
;// Converted an unused byte in the BRCState structure to
;// a variable to store the still quantizer number.
;// 
;//    Rev 1.0   27 Nov 1995 19:49:10   TRGARDOS
;// Initial revision.

#ifndef _EXBRC_H_
#define _EXBRC_H_

/*
 * Structure for bit rate controller state variables.
 * Size of structure is 32 Bytes.
 */
struct BRCStateStruct {
	U32		NumMBs;
	U32		uLastINTRAFrmSz;
	U32		uLastINTERFrmSz;
	int		QP_mean;
	U32		uTargetFrmSize;
	float 	Global_Adj;
	U8		u8INTRA_QP;
	U8		u8INTER_QP;
	U8		u8StillQnt;		// Keeps of tracker of Qnt used for still image compression.
	U8		Unassigned[1];	// pad to make a multiple of 16 bytes.
	float	TargetFrameRate;
	};

void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int NumMBs);

U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType);

U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uTargetPos, U32 uTargetSum, U32 uCumFrmSize, EnumPicCodType PicCodType);

U8 clampQP(int iUnclampedQP);


#endif // _EXBRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exutil.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * exutil.cpp
 *
 * DESCRIPTION:
 *		Common encoder utility routines
 *
 * Routines:					Prototypes in:
 *  trace						exutil.h			
 * 	cnvt_fdct_output
 */

// $Header:   S:\h26x\src\enc\exutil.cpv   1.2   18 Nov 1996 17:11:36   MBODART  $
// $Log:   S:\h26x\src\enc\exutil.cpv  $
// 
//    Rev 1.2   18 Nov 1996 17:11:36   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.1   13 Dec 1995 17:17:58   DBRUCKS
// 
// Include file needed for Ring0 compile
// 
//    Rev 1.0   13 Dec 1995 14:00:14   DBRUCKS
// Initial revision.

#include "precomp.h"

/*****************************************************************************
 *
 *  trace
 *
 *  Output a string ot the trace file 'trace.txt'.
 */
#ifdef DEBUG_ENC
#include <stdio.h>

void trace(char *str)
{
	FILE *fp;

	fp = fopen("trace.txt", "a");
	fprintf(fp, "%s\n", str);
	fclose(fp);
} /* end trace() */

#endif

/*****************************************************************************
 *
 *  cnvt_fdct_output
 *
 *  This is a DCT debug utility routine
 */
#ifdef DEBUG_DCT
void cnvt_fdct_output(
	unsigned short *DCTcoeff, 
	int DCTarray[64], 
	int bIntraBlock)
{
	register int i;
    static int coefforder[64] = {
     // 0  1  2  3  4  5  6  7 
        6,38, 4,36,70,100,68,102, // 0                     
       10,46, 8,44,74,104,72,106, // 1
       18,50,16,48,82,112,80,114, // 2
       14,42,12,40,78,108,76,110, // 3
       22,54,20,52,86,116,84,118, // 4
        2,34, 0,32,66, 96,64, 98, // 5
       26,58,24,56,90,120,88,122, // 6
       30,62,28,60,94,124,92,126  // 7
    };
	static int zigzag[64] = {
		0,   1,  5,  6, 14, 15, 27, 28,
		2,   4,  7, 13, 16, 26, 29, 42,
		3,   8, 12, 17, 25, 30, 41, 43,
		9,  11, 18, 24, 31, 40, 44, 53,
		10, 19, 23, 32, 39, 45, 52, 54,
		20, 22, 33, 38, 46, 51, 55, 60,
		21, 34, 37, 47, 50, 56, 59, 61,
		35, 36, 48, 49, 57, 58, 62, 63
	};

	unsigned int index;

    for (i = 0; i < 64; i++)
    {

		index = (coefforder[i])>>1;

		if( (i ==0) && bIntraBlock )
		{
			DCTarray[zigzag[i]] = ((int)(DCTcoeff[index])) >> 4 ;
		}
		else
		{
			DCTarray[zigzag[i]] = ((int)(DCTcoeff[index] - 0x8000)) >> 4;
		}
    }
} /* end cnvt_fdct_output() */
#endif


/************************************************************************
 *
 *  Increment_TR_UsingFrameRate
 */
void Increment_TR_UsingFrameRate(
	U8 * pu8TR,
	float * pfTR_Error,
	float fFrameRate,
	int bFirstFrame,
	U8 u8TRMask)
{
	float fTemp;
	int iIncrement;
	int iNewTR;
	
	if (bFirstFrame)
	{
		*pu8TR = 0; 		/* First Frame */
		*pfTR_Error = (float) 0.0;
	}
	else
	{
		fTemp = ((float)29.97 / fFrameRate) + *pfTR_Error;
		iIncrement = (int)fTemp;
		*pfTR_Error = fTemp - (float)iIncrement;
		
		iNewTR = *pu8TR + iIncrement;
  		*pu8TR = (U8)(iNewTR & u8TRMask);
	}
} /* end Increment_TR_UsingFrameRate() */


/************************************************************************
 *
 *  Increment_TR_UsingTemporalValue
 */
void Increment_TR_UsingTemporalValue(
	U8 * pu8TR,
	U8 * pu8LastTR, 
	long lTemporal,
	int bFirstFrame,
	U8 u8TRMask)
{
	*pu8TR = (lTemporal & u8TRMask);
	if (! bFirstFrame)
	{
#if defined(H261)
		/* For H.261, encountering two successive frames with the same
		   temporal value is harmless.  We don't want to ASSERT here
		   for two reasons.  First, it leads to an innocuous difference
		   between the release and debug builds.
		   Second, for some clips the temporal difference between two frames
		   can be a multiple of 32.  Two such temporal values are identical
		   in our eyes because we look only at the least significant 5 bits.
		   We should gracefully allow such input, an assert is not appropriate.
		 */
		if (*pu8TR == *pu8LastTR)
		  DBOUT("Identical consecutive temporal values");
#else
		ASSERT(*pu8TR != *pu8LastTR);
#endif
	}
	*pu8LastTR = *pu8TR;
} /* end Increment_TR_UsingTemporalValue() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exbrc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbrc.cpp
 *
 * Description:
 *   Bit rate control routines for H.261 and H.263.  The bit rate is controlled
 *   by changing QUANT value at the GOB level (H.261) or picture and GOB level
 *   (H.26X).  InitBRC() must be called at the time encoder is instanced; it
 *   initializes some data values in BRCState structure. CalcPQUANT() computes the new
 *   quant. value at the picture level; it must always be called.
 *   CalcMBQUANT computes the new quant. value at the MB level; it need not be 
 *   called if quant. adjustment is done at the picture level.
 *   
 *
 * Routines:
 *   InitBRC
 *   CalcPQUANT
 *   CalcMBQUANT
 * Prototypes in:
 *   e3enc.h
 * Note
 *   Encoder must update BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, and
 *   BRCState->uTargetFrmSize.
 */

/*
 * $Header:   S:\h26x\src\enc\exbrc.cpv   1.15   31 Oct 1996 14:59:26   MBODART  $
 * $Log:   S:\h26x\src\enc\exbrc.cpv  $
// 
//    Rev 1.15   31 Oct 1996 14:59:26   MBODART
// Prevent recent changes from inadvertantly affecting H.261.
// 
//    Rev 1.14   31 Oct 1996 10:05:38   KLILLEVO
// changed from DBOUT to DbgLog
// 
// 
//    Rev 1.13   29 Aug 1996 09:31:54   CZHU
// Map intra-coded GOB to simpliar quality of inter-coded neighbours
// 
//    Rev 1.12   14 Aug 1996 16:46:22   CZHU
// Adjust QP for intra frames other than the first Key frames. 
// 
//    Rev 1.11   12 Mar 1996 13:26:54   KLILLEVO
// new rate control with adaptive bit usage profile
// 
//    Rev 1.10   05 Feb 1996 17:15:12   TRGARDOS
// Added code to do custom quantizer selection for
// still frames
// 
//    Rev 1.9   01 Dec 1995 15:27:06   DBRUCKS
// I removed the QP_mean affects to the global_adj value.
// This resulted in removing any affect of the target frame rate on 
// the global adj value.
// 
//    Rev 1.8   28 Nov 1995 15:01:04   TRGARDOS
// Initialized target frame rate in BRCinit.
// 
//    Rev 1.7   27 Nov 1995 19:26:00   TRGARDOS
// Cleaned up bit rate control functions to be generic h26x bit rate
// controller.  Based off of macro blocks instead of GOBS now.
// 
//    Rev 1.6   26 Oct 1995 19:50:54   TRGARDOS
// Fixed a small mistake in the global adjust calculation
// and changed frame rate to a parameter.
// 
//    Rev 1.5   25 Oct 1995 23:22:36   SINGX
// Changed BRC back to we just get frame rate from client
// and compute global adjust ourselves.
// 
//    Rev 1.4   25 Oct 1995 20:14:40   TRGARDOS
// Added code to use global adjustment passed from client.
// 
//    Rev 1.3   12 Oct 1995 12:04:42   TRGARDOS
// Added QP_mean initialization in initBRC and added clipping
// to all calculations of the new QP.
// 
//    Rev 1.2   11 Oct 1995 19:35:00   TRGARDOS
// Modified bit rate controller.
// 
//    Rev 1.1   09 Oct 1995 11:48:10   TRGARDOS
// Added float typecasting.
// 
//    Rev 1.0   06 Oct 1995 16:41:22   AGUPTA2
// Initial revision.
 */

// PhilF-: In the LAN case and QCIF mode, it looks like even with the smallest quantizer
// we are way below the max allowed at 30fps. Therefore, with little motion,
// the bitrate looks constant at a low bitrate value. When high motion comes in,
// even with the same small quantizer we will remain below the max. So we will
// use that small quantizer, and the size of those compressed frames will get bigger
// because of the higher motion -> this explains why we don't have a straight
// line in the LAN case when looking at StatView...

#include "precomp.h"

U8 clampQP(int iUnclampedQP)
{
	return ((iUnclampedQP < 2) ? 2 : (iUnclampedQP > 31) ? 31 : iUnclampedQP);
}

/****************************************************************************
 * InitBRC
 * Parameter:
 *   BRCState: T_H263EncoderCatalog ptr
 *   Initializes some some variables in the encoder catalog.
 * Note
 *  Must be called when the encoder is instanced.
 */
void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int numMBs)
{
	FX_ENTRY("InitBRC");

	BRCState->NumMBs = numMBs;
	BRCState->u8INTRA_QP = DefIntraQP;
	BRCState->u8INTER_QP = DefInterQP;
	BRCState->uLastINTRAFrmSz = 0;
	BRCState->uLastINTERFrmSz = 0;
	BRCState->QP_mean = DefIntraQP;
	BRCState->TargetFrameRate = (float) 0.0;
	BRCState->u8StillQnt = 0;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Bitrate controller initial state:\r\n  numMBs = %ld macroblocks\r\n  u8INTRA_QP = %ld\r\n  u8INTER_QP = %ld\r\n", _fx_, BRCState->NumMBs, BRCState->u8INTRA_QP, BRCState->u8INTER_QP));
	DEBUGMSG(ZONE_BITRATE_CONTROL, ("  uLastINTRAFrmSz = %ld bytes\r\n  uLastINTERFrmSz = %ld bytes\r\n  QP_mean = %ld\r\n  TargetFrameRate = %ld.%ld fps\r\n", BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, BRCState->QP_mean, (DWORD)BRCState->TargetFrameRate, (DWORD)((BRCState->TargetFrameRate - (float)(DWORD)BRCState->TargetFrameRate) * 10.0f)));

}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcPQUANT | This function computes the PQUANT value to
 *   use for the current frame. This is done by using the target frame size
 *   and the results achieved with the previous frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The PQUANT value.
 *
 * @comm H.261 does not have PQUANT. So, H261 encoder can call this routine
 *   once and use the value returned as GQUANT for all GOBs.  Or, it can
 *   call CalcMBQUANT for all GOBs.
 *
 *   This routine MUST be called for every frame for which QUANT adjustment
 *   is required. CalcMBQUANT() might not be called.
 *
 * @xref <f FindNewQuant> <f CalcMBQUANT>
 ***************************************************************************/
U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcPQUANT");

    if (PicCodType == INTERPIC)
    {
        if (BRCState->uLastINTERFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last P-frame as the starting point
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTERFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / (float)BRCState->uTargetFrmSize;

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_, clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}
			else
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_,clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}

        	BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5));
        }
		else
		{
			// This the first P-frame - use default value
			BRCState->u8INTER_QP = clampQP((unsigned char) BRCState->QP_mean);
			BRCState->Global_Adj = (float)0.0;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTER_QP = %ld\r\n", _fx_, BRCState->u8INTER_QP));
		}

        return BRCState->u8INTER_QP;
    }
    else if (PicCodType == INTRAPIC)
    {
        if (BRCState->uLastINTRAFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last I-frame as the starting point
			// Assume lighting & other conditions haven't changed too much since last I-frame
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTRAFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float)BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}
			else
			{
				// This the first I-frame - use default value
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}

			BRCState->u8INTRA_QP = clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTRA_QP = %ld\r\n", _fx_, clampQP(BRCState->u8INTRA_QP)));
		}

        return clampQP(BRCState->u8INTRA_QP);
    }
    else
    {
        DBOUT("ERROR:BRC unknown frame type");
        return clampQP(BRCState->u8INTRA_QP);  //  return any valid value
    }
    
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcMBQUANT | This function computes the GQUANT value to
 *   use for the current GOB. This is done by using the target frame size and
 *   the running average of the GQUANTs computed for the previous GOBs in
 *   the current frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm U32 | uCumPrevFrmSize | Specifies the cumulated size of the previous
 *   GOBs in the previous frame.
 *
 * @parm U32 | uPrevFrmSize | Specifies the total size of the previous
 *   frame.
 *
 * @parm U32 | uCumFrmSize | Specifies the cumulated size of the previous
 *   GOBs.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f FindNewQuant> <f CalcPQUANT>
 ***************************************************************************/
U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uCumPrevFrmSize, U32 uPrevFrmSize, U32 uCumFrmSize, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcMBQUANT");

	float		Local_Adj;
	int			TargetCumSize;

	if (PicCodType == INTERPIC)
	{
		// Calculate the local adjustment parameter by looking at how well we've
		// been doing so far with the previous GOBs
		TargetCumSize = (int)uCumPrevFrmSize * BRCState->uTargetFrmSize / uPrevFrmSize;

		// If this is the first GOB there's no local adjustment to compute
		Local_Adj = TargetCumSize ? (float)((int)uCumFrmSize - TargetCumSize) / (float)TargetCumSize : 0.0f;

		BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj + Local_Adj) + (float)0.5));

#ifdef _DEBUG
		if (Local_Adj >= 0L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)Local_Adj, (DWORD)((Local_Adj - (float)(DWORD)Local_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)(Local_Adj * -1.0f), (DWORD)((Local_Adj - (float)(DWORD)(Local_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
#endif

		return BRCState->u8INTER_QP;
	}
	else if (PicCodType == INTRAPIC)
	{
		// The previous I-frame is so old that there isn't much point in doing local
		// adjustments - so only consider the global changes
		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTRA_QP = %ld\r\n", _fx_, BRCState->u8INTRA_QP));

		return BRCState->u8INTRA_QP;
	}
	else
	{
		DBOUT("ERROR:BRC unknown frame type");
		return BRCState->u8INTRA_QP;  //  return some valid value
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\precomp.h ===
#include <windows.h>
#include <windowsx.h>   /* for GlobalAllocPtr and GlobalFreePtr */
#include <math.h>
#include <memory.h>     // for _fmemcpy
#include <dos.h>        // for _FP_SEG, _FP_OFF
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>     // MAX_PATH
#include <float.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msviddrv.h>
#include <compddk.h>
#ifdef _DEBUG
#ifdef RING0
extern "C" {
#include <std.h>
#include <sys.h>
}
#endif
#endif
#include <confdbg.h>
#include <avutil.h>
#include "ctypedef.h"
#include "cdrvdefs.h"
#include "cproto.h"
#include "cldebug.h"
#ifdef H261
#include "d1dec.h"
#include "c1rtp.h"
#else
#include "d3dec.h"
#include "c3rtp.h"
#endif
#include "dxgetbit.h"
#ifdef H261
#include "d1rtp.h"
#include "d1coltbl.h"
#else
#include "d3rtp.h"
#include "d3coltbl.h"
#endif
#include "cresourc.h"
#include "cdialogs.h"
#include "exbrc.h"
#ifdef H261
#include "e1stat.h"
#include "e1enc.h"
#include "e1rtp.h"
#else
#include "e3enc.h"
#include "e3rtp.h"
#endif
#include "ccustmsg.h"
#include "cdrvcom.h"
#ifdef H261
#include "d1tables.h"
#else
#include "d3tables.h"
#endif
#include "dxcolori.h"
#ifdef H261
#include "d1const.h"
#else
#include "d3const.h"
#endif
#include "ccodecid.h"
#ifdef H261
#include "d1pict.h"
#include "d1gob.h"
#include "d1mblk.h"
#include "d1fm.h"
#else
#include "d3pict.h"
#include "d3gob.h"
#include "d3mblk.h"
#include "d3mvdec.h"
#include "dxfm.h"
#endif
#include "d3idct.h"
#ifndef H261
#include "d3halfmc.h"
#endif
#include "d3bvriq.h"
#ifdef H261
#include "e1vlc.h"
#else
#include "e3vlc.h"
#endif
#ifdef H261
#include "exutil.h"
#else
#include "dxap.h"
#ifdef ENCODE_STATS
#include "e3stat.h"
#endif /* ENCODE_STATS */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\exutil.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/***************************************************************************
 *
 *  exutil.h
 *
 *  Description
 *      Shared encoder utility interface file
 */

// $Header:   S:\h26x\src\enc\exutil.h_v   1.1   29 Dec 1995 18:09:30   DBRUCKS  $
// $Log:   S:\h26x\src\enc\exutil.h_v  $
;// 
;//    Rev 1.1   29 Dec 1995 18:09:30   DBRUCKS
;// 
;// add CLAMP_TO_N macro
;// 
;//    Rev 1.0   13 Dec 1995 14:00:50   DBRUCKS
;// Initial revision.

#ifndef __EXUTIL_H__
#define __EXUTIL_H__

/*********************** Initialization functions **********************/

typedef struct {
} EncoderOptions;

extern void GetEncoderOptions(EncoderOptions *);

/****************************** TR functions ***************************/

/* Increment the TR field using the specified frame rate with an 
 * accumulated error.  The first frame is assigned a value of 0.
 * If the increment were 1.5 then the values would be
 *
 *		TR		 	0	 1	  3	   4	6	...
 *		fTR_Error	0.0	 0.5  0.0  0.5	0.0 ...
 */
extern void Increment_TR_UsingFrameRate(
		U8 * pu8TR,			   	/* Pointer to the TR variable */	
		float * pfTR_Error,	   	/* Pointer to a place to save the error */
		float fFrameRate,		/* Frame rate - must be > 0.0 */
		int bFirstFrame,		/* First frame flag */
		U8 u8TRMask);			/* Mask to use */

/* Increment the TR field using the specified temporal reference value.
 */
extern void Increment_TR_UsingTemporalValue(
		U8 * pu8TR,			   	/* Pointer to the TR variable */
		U8 * pu8LastTR, 	  	/* Pointer to the last TR variable - used in an ASSERT */
		long lTemporal,			/* Temporal value - minimum of 8 bits of precision */
		int bFirstFrame,		/* First frame flag */
		U8 u8TRMask);			/* Mask to use */

/**************************** Debug Functions **************************/

/* Write the specified string to a trace file: "trace.txt".
 */
#ifdef DEBUG_ENC
extern void trace(
		char *str);				/* String to output */
#endif

/* Convert the DCT coefficients to unbiased coefficients in the correct 
 * order in DCTarray
 */
#ifdef DEBUG_DCT
void cnvt_fdct_output(
		unsigned short *DCTcoeff,	/* Pointer to coefficients */
		int DCTarray[64],			/* Output Array */
		int bIntraBlock);			/* Intra block flag */
#endif

/***************************** Misc Functions **************************/

#define CLAMP_N_TO(n,low,high)	\
{						\
	if (n < low)		\
		n = low;		\
	else if (n > high)	\
		n = high; 		\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ccinst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\ccinst.inv   1.7   05 Feb 1996 13:35:40   BNICKERS  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _CCINST_INC_
ELSE
_CCINST_INC = 1

include memmodel.inc

; Instance data in the Color Convertor's segment.

IFDEF WIN32

_H26xColorConvertorTbl SEGMENT DWORD PUBLIC 'DATA'
EXTERNDEF H26xColorConvertorTables:BYTE
_H26xColorConvertorTbl ENDS

ELSE

H26xColorConvertorTables = 0
LocalStorageCC EQU H26xColorConvertorTables ; 512 bytes for function locals
H26xColorConvertorTables = 512    ; locals under 16-bit Microsoft windows (tm).

ENDIF


; For CLUT8 and CLUT8Zoom2:

; 64 Dwords of UV contrib to line 0, dithered 4 ways.  Line 1 rotated 2 bytes.
UVDitherLine01  EQU H26xColorConvertorTables + 0

; 64 Dwords of UV contrib to line 2, dithered 4 ways.  Line 3 rotated 2 bytes.
UVDitherLine23  EQU H26xColorConvertorTables + 256

; 262 bytes of Y's contrib to CLUT indices.
YDither         EQU H26xColorConvertorTables + 512

; 26 bytes of padding.

; 256 Dwords of Y's contrib to CLUT indices, dithered 4 ways.
YDitherZ2       EQU H26xColorConvertorTables + 800

IFDEF WIN32
ELSE
SizeOf_CLUT8FixedPart    = H26xColorConvertorTables + 1824
H26xColorConvertorTables = H26xColorConvertorTables - 1824
ENDIF

; For RGB16   (Lo/Hi differ by dither.)

; These are the tables for 555 format.
RValLo        EQU H26xColorConvertorTables + 1824 ; 304 bytes for clamped R val.
GValLo        EQU H26xColorConvertorTables + 2128 ; 262 bytes for clamped G val.
BValLo        EQU H26xColorConvertorTables + 2390 ; 350 bytes for clamped B val.
RValHi        EQU H26xColorConvertorTables + 2740 ; 304 bytes for clamped R val.
GValHi        EQU H26xColorConvertorTables + 3044 ; 262 bytes for clamped G val.
BValHi        EQU H26xColorConvertorTables + 3306 ; 350 bytes for clamped B val.
; 565 format is 2048 bytes after 555 format.
; 655 format is 2048 bytes after 565 format.
; 664 format is 2048 bytes after 655 format.
                                                  ; 24 bytes Padding

UContrib      EQU H26xColorConvertorTables + 9824 ; interleaved with V.
VContrib      EQU H26xColorConvertorTables + 9828 ; interleaved with U.
                                                  ; 512 longwords.

; For RGB16 Zoom By 2.

; These are the tables for 555 format.
RValZ2        EQU H26xColorConvertorTables + 11872 ; 304 Dwords for clamped R.
GValZ2        EQU H26xColorConvertorTables + 13088 ; 262 Dwords for clamped G.
BValZ2        EQU H26xColorConvertorTables + 14136 ; 350 Dwords for clamped B.
; 565 format is 4096 bytes after 555 format.
; 655 format is 4096 bytes after 565 format.
; 664 format is 4096 bytes after 655 format.
                                                   ; 16 bytes Padding
IFDEF WIN32
ELSE
SizeOf_RGB16FixedPart    = H26xColorConvertorTables + 27840
H26xColorConvertorTables = H26xColorConvertorTables - 26016
ENDIF                                 


; For RGB24

B24Value      EQU H26xColorConvertorTables + 27840 ; 701 bytes for clamped Bval.
                                                   ; 3 bytes Padding
R24Value      EQU B24Value + 47                    ; Clamped R value.
G24Value      EQU B24Value + 96                    ; Clamped G value.

U24Contrib    EQU H26xColorConvertorTables + 28544 ; interleaved with V.
V24Contrib    EQU H26xColorConvertorTables + 28548 ; interleaved with U.
                                                   ; 512 longwords.

IFDEF WIN32
ELSE
SizeOf_RGB24FixedPart    = H26xColorConvertorTables + 30592
H26xColorConvertorTables = H26xColorConvertorTables -  2752
ENDIF

ActivePaletteIdxTable EQU H26xColorConvertorTables + 30592 ; 2^16 bytes.
UContribToAPIdx       EQU H26xColorConvertorTables + 96128 ; 1024 bytes UDith.
VContribToAPIdx       EQU H26xColorConvertorTables + 97152 ; 1024 bytes clamp B.

IFDEF WIN32
ELSE
SizeOf_CLUT8APFixedPart  = H26xColorConvertorTables + 12160 ; Keep it same as
H26xColorConvertorTables = H26xColorConvertorTables - 67584 ; three lines above
ENDIF

ENDIF

CCTYPE_YUV12ForEnc         =  0
CCTYPE_CLUT8               =  1
CCTYPE_CLUT8DCI            =  2
CCTYPE_CLUT8ZoomBy2        =  3
CCTYPE_CLUT8ZoomBy2DCI     =  4
CCTYPE_RGB24               =  5
CCTYPE_RGB24DCI            =  6
CCTYPE_RGB24ZoomBy2        =  7
CCTYPE_RGB24ZoomBy2DCI     =  8
CCTYPE_RGB16555            =  9
CCTYPE_RGB16555DCI         = 10
CCTYPE_RGB16555ZoomBy2     = 11
CCTYPE_RGB16555ZoomBy2DCI  = 12  
CCTYPE_IF09                = 13
CCTYPE_RGB16664            = 14
CCTYPE_RGB16664DCI         = 15
CCTYPE_RGB16664ZoomBy2     = 16
CCTYPE_RGB16664ZoomBy2DCI  = 17 
CCTYPE_RGB16565            = 18
CCTYPE_RGB16565DCI         = 19
CCTYPE_RGB16565ZoomBy2     = 20
CCTYPE_RGB16565ZoomBy2DCI  = 21 
CCTYPE_RGB16655            = 22
CCTYPE_RGB16655DCI         = 23
CCTYPE_RGB16655ZoomBy2     = 24
CCTYPE_RGB16655ZoomBy2DCI  = 25 
CCTYPE_CLUT8APDCI          = 26
CCTYPE_CLUT8APZoomBy2DCI   = 27
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\adjpels.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\adjpels.asv   1.2   22 Dec 1995 15:54:30   KMILLS  $
;//
;// $Log:   S:\h26x\src\dec\adjpels.asv  $
;// 
;//    Rev 1.2   22 Dec 1995 15:54:30   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.1   31 Oct 1995 10:50:56   BNICKERS
;// Save/restore ebx.
;// 
;//    Rev 1.0   01 Sep 1995 17:14:04   DBRUCKS
;// add adjustpels
;*  
;*     Rev 1.0   29 Mar 1995 12:17:14   BECHOLS
;*  Initial revision.
;// 
;//    Rev 1.2   07 Dec 1994 16:21:04   BNICKERS
;// Prepare entry sequence for flat model.
;// 
;//    Rev 1.1   05 Dec 1994 09:45:18   BNICKERS
;// Prepare for flat model.
;// 
;//    Rev 1.0   15 Jul 1994 11:10:20   BECHOLS
;// Initial revision.
;//
;////////////////////////////////////////////////////////////////////////////
;
;  adjpels -- This function adjusts pel values to track the user's tinkering
;             with brightness, contrast, and saturation knobs.  Each call
;             to this function adjusts one plane.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
;include decinst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataAdjustPels>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE AdjustPels (U8 FAR * InstanceBase,
;                                   X32 PlaneBase,
;                                   DWORD PlaneWidth,
;                                   DWORD PlanePitch,
;                                   DWORD PlaneHeight,
;                                   X32 AdjustmentTable);
;
;  In 16-bit Microsoft Windows (tm), InstanceBase provides the segment
;  descriptor for the plane and the adjustment table.
;
;  In 32-bit Microsoft Windows (tm), InstanceBase provides the base to apply
;  to the plane base and the adjustment table.

PUBLIC  AdjustPels

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        AdjustPels  proc DIST LANG AInstanceBase:      DWORD,
                                   APlaneBase:         DWORD,
                                   APlaneWidth:        DWORD,
                                   APlanePitch:        DWORD,
                                   APlaneHeight:       DWORD,
                                   AAdjustmentTable:   DWORD

IFDEF WIN32

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase             = LocalFrameSize + RegisterStorageSize +  4
PlaneBase                = LocalFrameSize + RegisterStorageSize +  8
PlaneWidth               = LocalFrameSize + RegisterStorageSize + 12
PlanePitch               = LocalFrameSize + RegisterStorageSize + 16
PlaneHeight              = LocalFrameSize + RegisterStorageSize + 20
AdjustmentTable          = LocalFrameSize + RegisterStorageSize + 24
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 28


; No Locals (on local stack frame)

LCL EQU <esp+>

ELSE

RegisterStorageSize = 20           ; Put local variables on stack.

; Arguments:

InstanceBase_zero        = RegisterStorageSize +  4
InstanceBase_SegNum      = RegisterStorageSize +  6
PlaneBase                = RegisterStorageSize +  8
PlaneWidth               = RegisterStorageSize + 12
PlanePitch               = RegisterStorageSize + 14
PlaneHeight              = RegisterStorageSize + 16
AdjustmentTable          = RegisterStorageSize + 18
EndOfArgList             = RegisterStorageSize + 20

LCL EQU <>

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   eax,PD InstanceBase[esp]
  mov   esi,PD AdjustmentTable[esp]
  mov   edi,PD PlaneBase[esp]
  add   esi,eax
  add   edi,eax
  mov   ecx,PD PlaneWidth[esp]
  mov   edx,PD PlaneHeight[esp]
  mov   ebp,PD PlanePitch[esp]
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  movzx esi,PW [ebp+AdjustmentTable]
  mov   edi,PD [ebp+PlaneBase]
  movzx ecx,PW [ebp+PlaneWidth]
  movzx edx,PW [ebp+PlaneHeight]
  movzx ebp,PW [ebp+PlanePitch]
ENDIF

  sub   ebp,ecx
   xor  ebx,ebx
  shl   ecx,5
   dec  edx
  shl   edx,16
   xor  eax,eax

; Register usage:
;  ebp -- skip distance, i.e. pitch minus width.
;  esi -- Adjustment table address.
;  edi -- Plane cursor.
;  edx[16:31] -- height.
;  dh  -- width counter.
;  ch  -- width.
;  dl  -- An adjusted pel.
;  cl  -- An adjusted pel.
;  bl  -- A raw pel.
;  al  -- A raw pel.
  
NextLine:
  mov   al,PB [edi  ]
   mov  bl,PB [edi+4]
  mov   dh,ch

Next8Pels:
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]  ; Table duplicated;  avoids many bank conflicts.
  mov   al,PB [edi+1]
   mov  bl,PB [edi+5]
  mov   PB [edi  ],cl
   mov  PB [edi+4],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+2]
   mov  bl,PB [edi+6]
  mov   PB [edi+1],cl
   mov  PB [edi+5],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+3]
   mov  bl,PB [edi+7]
  mov   PB [edi+2],cl
   mov  PB [edi+6],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+8]
   mov  bl,PB [edi+12]
  mov   PB [edi+3],cl
   mov  PB [edi+7],dl
  add   edi,8
   dec  dh
  jne   Next8Pels

  add   edi,ebp
   sub  edx,000010000H
  jge   NextLine

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

AdjustPels endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx1209.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;// 
;// $Header:   S:\h26x\src\dec\cx51209.asv
;// 
;// $Log:   S:\h26x\src\dec\cx51209.asv
;// 
;////////////////////////////////////////////////////////////////////////////
; cx1209  -- This function performs YUV12 to IF09 color conversion for H26x.
;            IF09 consists of Y, V, U in 8-bit, planar format, plus a plane of
;            4-bit flags, each in 8 bits of storage, with each bit indicative
;            of which dwords of Y are unchanged from the previous frame.
;            IF09 is only applicable using DCI.
;
;            This version is tuned for maximum performance on both the Pentium
;            (r) microcprocessor and the Pentium Pro (tm) microprocessor.
;
;            Indentation of instructions indicates expected U/V pipe execution
;            on Pentium (r) microprocessor;  indented instructions are
;            expected to execute in V-pipe, outdented instructions in U-pipe.
;            Inside loops, blank lines delineate groups of 1, 2, or 3
;            instructions that are expected to be decoded simultaneously
;            on the Pentium Pro (tm) microprocessor.
;
; cx1209
; ^^^^^^
; ||||++----- Convert to IF09.
; ||++------- Convert from YUV12.
; |+--------- For both H261 and H263.
; +---------- Color convertor.
;-------------------------------------------------------------------------------
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx1209>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

PUBLIC  YUV12ToIF09
YUV12ToIF09    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AUVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

; void * YUV12ToIF09 (
;       U8 * YPlane,
;       U8 * VPlane,
;       U8 * UPlane,
;       UN  FrameWidth,
;       UN  FrameHeight,
;       UN  YPitch,
;       UN  UVPitch,
;       UN  AspectAdjustmentCount,
;       U8 * ColorConvertedFrame,
;       U32 DCIOffset,
;       U32 CCOffsetToLine0,
;       IN  CCOPitch,
;       IN  CCType)
;
;  YPlane and VPlane are offsets relative to InstanceBase.  In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;
IFDEF WIN32

LocalFrameSize = 32
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
FrameWidth               = LocalFrameSize + RegisterStorageSize + 12
FrameHeight              = LocalFrameSize + RegisterStorageSize + 16
YPitch                   = LocalFrameSize + RegisterStorageSize + 20
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 24
DCIOffset                = LocalFrameSize + RegisterStorageSize + 28
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 32
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 36
CCType                   = LocalFrameSize + RegisterStorageSize + 40
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 44

; Locals (on local stack frame)

CCOCursor                  =   0
YLimit                     =   4
CCOVCursor                 =   8
CCOUCursor                 =  12
CCOSkipCursor              =  16
VLimit                     =  20
YLine1Limit                =  24
CCOUVPitch                 =  28

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
FrameWidth_arg             = RegisterStorageSize + 16
FrameHeight_arg            = RegisterStorageSize + 18
YPitch_arg                 = RegisterStorageSize + 20
ColorConvertedFrame        = RegisterStorageSize + 22
ColorConvertedFrame_SegNum = RegisterStorageSize + 24
DCIOffset                  = RegisterStorageSize + 26
CCOffsetToLine0            = RegisterStorageSize + 30
CCOPitch_arg               = RegisterStorageSize + 34
EndOfArgList               = RegisterStorageSize + 36

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
YLimit                     = LocalStorageCC +   4
CCOVCursor                 = LocalStorageCC +   8
CCOUCursor                 = LocalStorageCC +  12
CCOSkipCursor              = LocalStorageCC +  16
VLimit                     = LocalStorageCC +  20
YLine1Limit                = LocalStorageCC +  24
CCOUVPitch                 = LocalStorageCC +  28
YPlane                     = LocalStorageCC +  32
VPlane                     = LocalStorageCC +  36
FrameWidth                 = LocalStorageCC +  40
FrameHeight                = LocalStorageCC +  44
YPitch                     = LocalStorageCC +  48
CCOPitch                   = LocalStorageCC +  52

LCL EQU <>

ENDIF

  push    esi
  push    edi
  push    ebp
  push    ebx
IFDEF WIN32
  sub     esp,LocalFrameSize
  mov     eax,PD [esp+ColorConvertedFrame]
  add     eax,PD [esp+DCIOffset]
  add     eax,PD [esp+CCOffsetToLine0]
  mov     PD [esp+CCOCursor],eax
ELSE
  xor     eax,eax
  mov     eax,ds
  push    eax
  mov     ebp,esp
  and     ebp,00000FFFFH
  mov     ds, PW [ebp+InstanceBase_SegNum]
  mov     es, PW [ebp+ColorConvertedFrame_SegNum]

  mov     ebx,PD [ebp+YPlane_arg]           ; Make YPlane accessible
  mov     ds:PD YPlane,ebx
  mov     ebx,PD [ebp+VPlane_arg]           ; Make VPlane accessible.
  mov     ds:PD VPlane,ebx
  mov     ax,PW [ebp+FrameWidth_arg]        ; Make FrameWidth accessible
  mov     ds:PD FrameWidth,eax
  mov     ax,PW [ebp+FrameHeight_arg]       ; Make FrameHeight accessible
  mov     ds:PD FrameHeight,eax
  mov     ax,PW [ebp+YPitch_arg]            ; Make YPitch accessible
  mov     ds:PD YPitch,eax
  mov     ax,PW [ebp+ColorConvertedFrame]   ; Init CCOCursor
  add     eax,PD [ebp+DCIOffset]
  mov     ds:PD CCOCursor,eax
  movsx   ebx,PW [ebp+CCOPitch_arg]         ; Make CCOPitch accessible
  mov     ds:PD CCOPitch,ebx
ENDIF
  Ledx    FrameHeight
   Lebx   CCOPitch
  shr     ebx,2                    ; UV pitch for the output
   Lecx   YPitch
  add     ebx,3                    ; Pitch is always a multiple of 4.
   Lebp   CCOPitch
  and     ebx,0FFFFFFFCH
   Lesi   YPlane                   ; Fetch cursor over luma plane.
  Sebx    CCOUVPitch
   Leax   CCOCursor
  imul    ecx,edx                  ; ecx: size of Y input.
  imul    ebp,edx                  ; ebp: was CCOPitch, now size of Y output.
  imul    ebx,edx                  ; ebp: size of U/V output (times 4).
  add     ecx,esi                  ; ecx: Ylimit
   add    eax,ebp                  ; eax was CCOCursor, now CCOVCursor
  Secx    YLimit
   Seax   CCOVCursor
  sar     ebx,2                    ; ebx: UVsize of output
   Lecx   FrameWidth               ; ecx: Y frame width
  add     esi,ecx                  ; esi: end of first input Y
   add    eax,ebx                  ; eax: now CCOUCursor
  shr     ecx,2
   Seax   CCOUCursor
  Lebp    VPlane                   ; ebp Vplane input
   Ledx   YPitch
  lea     esi,[edx+esi]            ; End of Y line 1
   add    ebp,ecx                  ; end of Vline
  Sesi    YLine1Limit
   add    eax,ebx                  ; CCO Skip Blocks
  Sebp    VLimit                   ; UV width for input
   Seax   CCOSkipCursor

; Prepare the UV contribution to decide the skip blocks, and copy chroma
; planes at the same time.
;
; Register usage:
;
; esi: V plane input pointer
; edi; V output pointer
; ebp: U output pointer
; edx: Y plane input pointer
; ecx: V limit
; ebx: Work area for U
; eax: Work area for V

ChromaPrep:

  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Ledx    YPlane
   Leax   YPitch
  Lesi    VPlane
   Lecx   VLimit
  sub     edi,esi            ; make edi offset to esi.
   sub    ebp,esi            ; make ebp offset to esi to save inc in the loop.
  lea     edx,[eax+edx-1296] ; make edx point at place for chroma prep.
   mov    eax,PD [esi]           ; fetch four V
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

ChromaLoop:

  mov     Ze PD[esi+edi*1],eax   ; Store four V.
   mov    ebx,PD [esi+UOFFSET]   ; fetch four U
  add     esi,4

   mov    PD [edx],eax           ; Store four V to chroma-prep line in Y frame.
  add     edx,16                 ; Advance chroma-prep cursor.
   add    ebx,ebx                ; Change to 8-bit.  (Low bit undef, usually 0).

  mov     Ze PD[esi+ebp*1-4],ebx ; Store four U.
   mov    eax,PD [esi]           ; fetch next four V.
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

   mov    PD [edx-12],ebx        ; Store four U to chroma-prep line in Y frame.
  mov     bl,Ze PB [esi+edi*1]   ; Pre-load output cache line
   cmp    esi,ecx

  mov     bl,Ze PB [esi+ebp*1]   ; Pre-load output cache line
   jb     ChromaLoop

; update chroma pointers.

  add     ecx,VPITCH
   Lebx   CCOUVPitch
  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Secx    VLimit
   add    edi,ebx              ; update V output ptr to the next line
  Leax    VPlane
   add    ebp,ebx              ; update U output ptr to the next line
  Sedi    CCOVCursor
   add    eax,VPITCH
  Sebp    CCOUCursor
   Seax   VPlane

; now do Luma a row of 4x4 blocks
;
; register usage:
;
; esi: Y cursor
; edi: CCOCursor
; ebp: counts down 4 lines of luma.
; ecx: counts down frame width.
; ebx: Y Pitch.
; eax: Work area.

; copy a row of 4x4 luma

  Lesi    YPlane
   Lecx   FrameWidth
  Ledi    CCOCursor
   add    esi,ecx
  neg     ecx
   Lebx   YPitch

  sub     edi,ecx
   mov    eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
   mov    ebp,4

YLoop:

  mov     Ze PD[edi+ecx],eax   ; Store them to IF09 output, Y plane.
   mov    eax,PD[esi+ecx+4]    ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.

   add    ecx,4                ; Advance induction variable.
  jl      YLoop

YLoopDone:

  Lecx    FrameWidth
   add    esi,ebx
  add     edi,ecx
   neg    ecx
  mov     eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
  dec     ebp
   jne    YLoop

  add     edi,ecx
  Sedi    CCOCursor           ; save the output ptr for next four lines

; Build the skip block mask
;
; Register usage:
;
; esi: Y ptr
; edi: Mask Ptr
; ebp: Y Pitch
; edx: mask
; ecx: Archive value
; ebx: UV contribution
; eax: Dword of Y pels
;
; Y starts with Line 1 of 4x4 blocks, since UV pattern has been saved
; relative to line 1.

  Lesi    YPlane
   Lebp   YPitch
  Ledi    CCOSkipCursor
   add    esi,ebp                          ; esi point at line 1 of luma

BuildSkipDescrLoop:

  mov     ebx,PD [esi-1296]         ; Fetch 4 U's;  byte0 corresponds to this Y.
   mov    eax,PD [esi-1292]         ; Fetch 4 V's;  byte0 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,0000000FCH            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1300]         ; Fetch 4 U's;  byte1 corresponds to this Y.
   mov    eax,PD [esi-1296]         ; Fetch 4 V's;  byte1 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,00000FC00H            ; Extract 6 bits of V.
  and     ebx,007E00000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1304]         ; Fetch 4 U's;  byte2 corresponds to this Y.
   mov    eax,PD [esi-1300]         ; Fetch 4 V's;  byte2 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   and    eax,000FC0000H            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1308]         ; Fetch 4 U's;  byte3 corresponds to this Y.
   mov    eax,PD [esi-1304]         ; Fetch 4 V's;  byte3 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.
  shr     eax,26                    ; Extract 6 bits of V.
   and    ebx,007E00000H            ; Extract 6 bits of U.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   jne    BuildSkipDescrLoop

BuildSkipDescrLoopDone:


  add     edi,3               ; Round to next dword.
   lea    ebx,[ebx+ebp*4]     ; update YLine1Limit for next row of blocks
  and     edi,0FFFFFFFCH
   Lesi   YPlane
  Sedi    CCOSkipCursor
   Sebx   YLine1Limit
  lea     esi,[esi+ebp*4]
   Leax   YLimit
  Sesi    YPlane
   cmp    esi,eax
  jl      ChromaPrep

IFDEF WIN32
  add     esp,LocalFrameSize
ELSE
  pop     ebx
  mov     ds,ebx
ENDIF
  pop     ebx
  pop     ebp
  pop     edi
  pop     esi
  rturn

YUV12ToIF09 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512161.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cx512161.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:44   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Mar 1996 15:51:18   BNICKERS
;// Made this function non-destructive on input.  Only works on flat model now.
;// 
;//    Rev 1.4   05 Feb 1996 13:34:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   27 Dec 1995 14:35:40   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:50   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:20   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:26   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For H263 or H261.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11, 
;             and the high order field being R and fully contained in the high
;             order byte.  Formats presently supported:  555, 565, 655, and 664.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN   FrameWidth,
;                                     UN   FrameHeight,
;                                     UN   YPitch,
;                                     UN   VPitch,
;                                     UN   AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32  DCIOffset,
;                                     U32  CCOffsetToLine0,
;                                     IN   CCOPitch,
;                                     IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0
  cmp   ebx,CCTYPE_RGB16555
  je    @f
  cmp   ebx,CCTYPE_RGB16555DCI
  je    @f
  mov   ecx,2048
  cmp   ebx,CCTYPE_RGB16565
  je    @f
  cmp   ebx,CCTYPE_RGB16565DCI
  je    @f
  mov   ecx,4096
  cmp   ebx,CCTYPE_RGB16655
  je    @f
  cmp   ebx,CCTYPE_RGB16655DCI
  je    @f
  mov   ecx,6144
  cmp   ebx,CCTYPE_RGB16664DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,1
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   CCOSkipDistance,eax
   mov  YLimit,edx
  mov   YCursor,esi
   mov  esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   mov  ebx,AspectCount
  mov   [edi],ecx                   ; Store EOL indicator.
   mov  eax,CCType
  xor   edx,edx
   mov  edi,CCOCursor
  dec   ebx                         ; If count is non-zero, we keep the line.
   mov  esi,YCursor
  mov   AspectCount,ebx
   jne  KeepLine0

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine0

KeepLine0:

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- U contribution to B field of RGB value.
;  edx -- V contribution to R field of RGB value.
;         Clamped, positioned G value.
;  ecx -- UV contribution to G field of RGB value.
;         Clamped, positioned G value.
;  ebx -- Construction of two pels of RGB16.
;  al -- Y value (i.e. Y contribution to R, G, and B);

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine0:

  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel01.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel01.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel01.
  or    ebx,edx                        ; Combine RGB16 value for Pel01.
   mov  al,[esi]                       ; Fetch Y00.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel01.
   mov  dl,ChromaContribution+1536+2   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel00.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel00.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]             ; Get clamped R value for Pel00.
  or    ebx,ecx                        ; Combine RGB16 value for Pel00.
   mov  al,[esi+3]                     ; Fetch Y03. 
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4  ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+5   ; Get UV contribution to G value.
  mov   dl,ChromaContribution+1536+6   ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  mov   Ze [edi],ebx                   ; Write the 2 pels to output.
   add  esi,4                          ; Advance Y line cursor
  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel03.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel03.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel03.
  or    ebx,edx                        ; Combine RGB16 value for Pel03.
   mov  al,[esi+2-4]                   ; Fetch Y02.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel03.
   mov  dl,ChromaContribution+1536+6   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel02.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel02.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]          ; Get clamped R value for Pel02.
  or    ebx,ecx                        ; Combine RGB16 value for Pel02.
   mov  al,[esi+5-4]                   ; Fetch Y05.
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8  ; Get next pel's U contrib to B value.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+9   ; Get next pel's UV contrib to G value.
  mov   Ze [edi+4],ebx                 ; Write the 2 pels to output.
   add  edi,8                          ; Advance color converted output cursor.
  mov   dl,ChromaContribution+1536+10  ; Get next pel's V contrib to R value.
   and  ebp,0FFH                       ; Extract U contribution to G value.
  lea   esp,[esp+8]                    ; Advance Chroma contribution cursor.
   jne  DoNext4YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   ebp,YSkipDistance
   mov  ebx,AspectCount
  add   esi,ebp
   dec  ebx                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine1

KeepLine1:

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine1:

  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+2
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+3]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4
  shr   al,1
   mov  cl,ChromaContribution+1536+5
  mov   dl,ChromaContribution+1536+6
   and  ebp,0FFH
  mov   Ze [edi],ebx
   add  esi,4
  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi+2-4]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+6
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+5-4]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8
  shr   al,1
   mov  cl,ChromaContribution+1536+9
  mov   Ze [edi+4],ebx
   add  edi,8
  mov   dl,ChromaContribution+1536+10
   and  ebp,0FFH
  lea   esp,[esp+8]
   jne  DoNext4YPelsOfLine1

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine1:

   mov  eax,YSkipDistance           ; Inc LumaCursor to next line.
  add   eax,esi
   mov  ecx,ChromaPitch
  mov   CCOCursor,edi
   mov  YCursor,eax
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512162.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512162.asv
;//
;// $Log:   S:\h26x\src\dec\cx512162.asv  $
;// 
;//    Rev 1.8   22 Mar 1996 16:41:06   BNICKERS
;// Fix bug wherein UV contrib was being taken from one pel to the right.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:00   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 10:02:00   BNICKERS
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   16 Feb 1996 15:12:42   BNICKERS
;// Correct color shift.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:22   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:38:54   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:54   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:16   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:18   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cx512162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  for H26x.  It handles any format in which there
;             are three fields, the low order field being B and fully contained
;             in the low order byte, the second field being G and being
;             somewhere in bits 4 through 11, and the high order field being
;             R and fully contained in the high order byte.  Present support
;             for 555, 565, 655, and 644 formats only.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD, AUPlane: DWORD, AFrameWidth: DWORD, AFrameHeight: DWORD,
AYPitch: DWORD, AVPitch: DWORD, AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD, ADCIOffset: DWORD, ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD, ACCType: DWORD

LocalFrameSize = 64+768*6+24
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
LineParity               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
StashOddLinePel0         EQU  [esp+72]
StashOddLinePel1         EQU  [esp+76]
StashOddLinePel2         EQU  [esp+80]
StashOddLinePel3         EQU  [esp+84]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0/2
  cmp   ebx,CCTYPE_RGB16555ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16555ZoomBy2DCI
  je    @f
  mov   ecx,4096/2
  cmp   ebx,CCTYPE_RGB16565ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16565ZoomBy2DCI
  je    @f
  mov   ecx,8192/2
  cmp   ebx,CCTYPE_RGB16655ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16655ZoomBy2DCI
  je    @f
  mov   ecx,12288/2
  cmp   ebx,CCTYPE_RGB16664ZoomBy2DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664ZoomBy2
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
   mov  StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  shl   ebx,2
   add  edx,esi
  sub   eax,ebx
   mov  YSkipDistance,ecx
  shr   ebx,3
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  YLimit,edx
  mov   esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,24
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-20],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  mov   esi,YCursor
   xor  ecx,ecx
  mov   [edi],ecx                    ; Store EOL indicator.
   mov  edx,CCType
  mov   dl,[esi]                     ; Fetch Y00.
   xor  ebx,ebx
  mov   bl,ChromaContribution        ; Get U contribution to B value.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3,edx         ; Stash offset to RGB table to use.
   mov  edi,CCOCursor
  mov   al,ChromaContribution+2      ; Get V contribution to R value.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+1      ; Get UV contribution to G value.
   mov  LineParity,ch
  and   eax,0FFH
   sub  esp,4608

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- Construction of a pel (twice) of RGB16.
;  edx -- Y value (i.e. Y contribution to R, G, and B) times 4, plus offset
;         to select appropriate table.
;  cl  -- UV contribution to G field of RGB value.
;  bl  -- U contribution to B field of RGB value.
;  al  -- V contribution to R field of RGB value.

DoLine1:
DoNext4YPelsOfLine0:

   mov  ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel00.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel00.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel00.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi],ebp                 ; Store Pel00 to color converted output.
   mov  dl,[esi+1]                   ; Fetch Y01.
  rol   ebp,16                       ; Swap Pel00 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel0+4608,ebp    ; Stash Pel00 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  add   edi,16                       ; Advance output cursor.
   add  esi,4                        ; Advance luma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel01.
   mov  bl,ChromaContribution+4+4608 ; Load U contribution to B val for pels2&3.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel01.
   mov  al,ChromaContribution+6+4608 ; Load V contribution to R val for pels2&3.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel01.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+4-16],ebp            ; Store Pel01 to color converted output.
   mov  dl,[esi+2-4]                 ; Fetch Y02.
  rol   ebp,16                       ; Swap Pel01 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel1+4608,ebp    ; Stash Pel01 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+5+4608 ; Load UV contrib to G val for pels2&3.
   add  esp,24                       ; Advance chroma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel02.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel02.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel02.
   mov  edx,StashOddLinePel3+4608-24 ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+8-16],ebp            ; Store Pel02 to color converted output.
   mov  dl,[esi+3-4]                 ; Fetch Y03.
  rol   ebp,16                       ; Swap Pel02 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y02 to 7 bits.
  mov   StashOddLinePel3+4608,edx    ; Stash offset to RGB table to use.
   add  edx,edx                      ; Get four times luma.
  mov   StashOddLinePel2+4608-24,ebp ; Stash Pel02 for later xfer to 2nd line.
   mov  esi,esi                      ; Keep pairing happy.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel03.
   mov  bl,ChromaContribution+0+4608 ; Load U contribution to B val for pels0&1.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+2+4608 ; Load V contribution to R val for pels0&1.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel03.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+12-16],ebp           ; Store Pel03 to color converted output.
   mov  dl,[esi]                     ; Fetch Y00.
  rol   ebp,16                       ; Swap Pel03 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3+4608-24,ebp ; Stash Pel03 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  test  eax,eax
   mov  cl,ChromaContribution+1+4608 ; Load UV contrib to G val for pels2&3.
  jne   DoNext4YPelsOfLine0
   
  and   esp,0FFFFE000H
  add   esp,02000H
  mov   edx,YSkipDistance
   mov  ebp,CCOSkipDistance
  add   esi,edx
   mov  ebx,AspectCount
  add   edi,ebp
   sub  ebx,2                    ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   lea  ecx,StashOddLinePel0
  mov   edx,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   eax,[ecx]
   mov  ebx,[ecx+4]
  mov   Ze [edi],eax
   mov  eax,[ecx+8]
  mov   Ze [edi+4],ebx
   mov  ebx,[ecx+12]
  mov   Ze [edi+8],eax
   add  ecx,24
  mov   Ze [edi+12],ebx
   add  edi,16
  sub   edx,4
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebp

Skip2ndLineOfLine0:

   mov  al,LineParity
  xor   al,1
   je   Line1Done

  mov   LineParity,al
   mov  edx,CCType
  mov   dl,[esi]
   xor  ebx,ebx
  mov   bl,ChromaContribution
   and  edx,0FFFFFFFEH
  mov   StashOddLinePel3,edx
   xor  ecx,ecx
  add   edx,edx
   mov  al,ChromaContribution+2
  mov   cl,ChromaContribution+1
   sub  esp,4608
  and   eax,0FFH
   jmp  DoLine1

Line1Done:

  mov   YCursor,esi
   mov  eax,esi
  mov   CCOCursor,edi
   mov  ecx,ChromaPitch
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512241.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cx512241.asv  $
;// 
;//    Rev 1.7   27 Mar 1996 18:39:26   RMCKENZX
;// Corrected bug in line parity which manifests on odd aspects.
;// 
;//    Rev 1.6   27 Mar 1996 14:41:46   RMCKENZX
;// Changed YSkipDistance to use register ebp, not eax.  When
;// pitch-width was more than 255, the first 4 pels of odd lines
;// would get erroneous values for blue, due to the presence of
;// non-zero values in the high order bits of eax.  Also cleaned a
;// few comments.
;// 
;//    Rev 1.5   18 Mar 1996 09:58:46   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:40:52   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   30 Oct 1995 17:15:30   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:47:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:30   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB24    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]
G2B2R1G1                 EQU  [esp+68]
R3G3B3R2                 EQU  [esp+72]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   mov  CCOSkipDistance,eax
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   YLimit,edx
   mov  YCursor,esi
  mov   esi,VCursor
   xor  eax,eax
  mov   LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[ 9:15] -- Zero (pad).
  ;                                 ; ebx[ 0: 8] -- Zero (red).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,16
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-12],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   xor  ebx,ebx
  mov   [edi+4],ecx                 ; Store EOL indicator.
   mov  edx,AspectCount
  mov   edi,CCOCursor
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   esi,YCursor
   mov  AspectCount,edx
  jne   KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of one and a third pels of RGB24.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl,al  -- UV contrib to G field of RGB val,  U contrib to B field of RGB val.

  mov   cl,[esi+3]                     ; Get Y03.
   mov  bl,ChromaContribution+6        ; Get UV contribution to G value.
  mov   ebp,ChromaContribution+4       ; Get V contribution to R value.
   sub  esp,3072
  and   ebp,01FFH                      ; Extract V contribution to R value.
   mov  dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.

DoNext4YPelsOfLine0:

  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+3072+7   ; Get U contribution to B value.
  shl   edx,16                         ; Position R and G value for Pel03.
   mov  bl,[esi+2]                     ; Get Y02.
  mov   dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel03.
   mov  cl,ChromaContribution+3072+6   ; Reload UV contribution to G value.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel02.
   mov  ebp,ChromaContribution+3072    ; Get V contribution to R value.
  mov   R3G3B3R2+3072,edx              ; Stash 1.33 pels.
   mov  dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel02.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel02.
   mov  cl,[esi+1]                     ; Get Y01.
  mov   bl,ChromaContribution+3072+2   ; Get UV contribution to G value.
   and  ebp,01FFH                      ; Extract V contribution to R value.
  shl   edx,16                         ; Position G and B values for Pel02.
   mov  al,ChromaContribution+3072+3   ; Get U contribution to B value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   mov  bl,[esi]                       ; Get Y00.
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   add  esi,4                          ; Advance source stream cursor.
  mov   G2B2R1G1+3072,edx              ; Stash 1.33 pels.
   mov  dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
  mov   cl,ChromaContribution+3072+2   ; Reload UV contribution to G value.
   add  edi,12                         ; Advance color converted output cursor.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel00.
   mov  ebp,ChromaContribution+3072+20 ; Get next V contribution to R value.
  shl   edx,16                         ; Position R for Pel00 and B for Pel01.
   and  ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
  mov   dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel00.
   mov  eax,G2B2R1G1+3072              ; Reload 2nd 1.33 pels.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel00.
   mov  cl,[esi+3]                     ; Get next Y03.
  mov   Ze [edi-12],edx                ; Write the first 1.33 pels out.
   mov  bl,ChromaContribution+3072+22  ; Get UV contribution to G value.
  mov   Ze [edi-8],eax                 ; Write the second 1.33 pels out.
   mov  edx,R3G3B3R2+3072
  mov   Ze [edi-4],edx                 ; Write the third 1.33 pels out.
   mov  eax,ebx                        ; Zero out upper bytes of eax.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.
   lea  esp,[esp+16]
  jne   DoNext4YPelsOfLine0

  and   esp,0FFFFF000H
  add   esp,1000H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512322.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512322.asv
;//
;// $Log:   S:\h26x\src\dec\cx512322.asv  $
;// 
;//    Rev 1.2   12 Apr 1996 11:26:26   RMCKENZX
;// Corrected bug in fetching first V contribution to Red.
;// 
;//    Rev 1.1   10 Apr 1996 11:12:54   RMCKENZX
;// Fixed bug in aspect ratio correction -- clearing sign bit of bl.
;// 
;//    Rev 1.0   01 Apr 1996 10:25:48   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cx512322 -- This function performs YUV12-to-RGB32 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, the third byte is R, and the
;             high order byte is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB32ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]

YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  shl   ebx,3
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  add   edx,esi
   sub  eax,ebx
  shr   ebx,4
   mov  YLimit,edx
  mov   ChromaLineLen,ebx
   mov  CCOSkipDistance,eax
  mov   esi,VCursor
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi],eax                   ; Store EOL indicator.
   mov  LineParity,eax
  mov   edi,CCOCursor

Keep2ndLineOfOutput:
DoLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

   xor  edx,edx
  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  eax,eax

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
  mov   Ze [edi+4],edx                 ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+16]                   ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-8],edx                 ; Write RGB32 for Pel01.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  mov   eax,CCOSkipDistance
   mov  bl,LineParity
  add   edi,eax
   xor  bl,080H
  mov   esi,YCursor
   jns  SecondOutputLineDone
   
  mov   LineParity,bl
   mov  ebp,AspectCount
  sub   ebp,2                          ; If count is non-zero, we keep the line.
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ebp
   jg   Keep2ndLineOfOutput

  add   ebp,ecx
   and  bl, 7fh                     ; clear LineParity SecondOutputLineDone bit
  mov   AspectCount,ebp

SecondOutputLineDone:

  add   esi,LumaPitch
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512242.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:

  xor   ebx,ebx
   xor  ecx,ecx
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.
   xor  edx,edx
  mov   cl,[esi]                     ; Fetch Y0.
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.
   and  ebp,0000001FFH               ; Extract V contrib to R.
  mov   edi,CCOCursor
   sub  esp,6144
  xor   eax,eax

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:

  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.   -- -- R0 G0
   mov   cl,[esi+1]                    ; Fetch Y1.
  shl    ebx,16                        ;                 R0 G0 -- --
   mov   al,ah                         ; Copy Pel0 B.    -- -- B0 B0
  or     eax,ebx                       ;                 R0 G0 B0 B0
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R0 G0 G1 --
  ror    eax,8                         ; First output:   B0 R0 G0 B0
   mov   dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.
  mov    Ze [edi],eax                  ; Save B0R0G0B0.
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.   R0 G0 G1 B1
  rol    ebx,16                        ; Second output:  G1 B1 R0 G0
   mov   B0R0G0B0+6144,eax             ; Stash for saving to second line.
  mov    Ze [edi+4],ebx                ; Save G1B1R0G0.
   mov   G1B1R0G0+6144,ebx             ; Stash for saving to second line.
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R.   G1 B1 -- R1
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.
  mov    bh,bl                         ; Copy Pel1 R.    G1 B1 R1 R1
   mov   cl,[esi+2]                    ; Fetch Y2.
  ror    ebx,8                         ; Third output:   R1 G1 B1 R1
   and   ebp,0000001FFH                ; Extract V contrib to R.
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.
   xor   eax,eax
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.
   xor   ebx,ebx
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.   -- -- R2 G2
   mov   cl,[esi+3]                    ; Fetch Y3.
  shl    eax,16                        ;                 R2 G2 -- --
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2
  or     ebx,eax                       ;                 R2 G2 B2 B2
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3
   mov   cl,[esi+4]                    ; Fetch Y4.
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3
   xor   ebx,ebx
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.
   and   ebp,0000001FFH                ; Extract U contrib to B.
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.
   lea   esi,[esi+4]                   ; Advance input cursor.
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.
  mov    eax,ebx
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx51281.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cx51281.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:40   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:43:28   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 11:49:40   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:08   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:20   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cx51281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   YLimit,edx
   mov  ChromaLineLen,ebx

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  edx,AspectCount
  mov   esi,YCursor                 ; Reload cursor over Y line.
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine0

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:

  mov   edi,CCOCursor                 ; Fetch output cursor.
   mov  eax,CCOPitch                  ; Compute start of next line.
  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <UV03 UV02 xxxx xxxx>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+3]                    ; Fetch Y03.
   and  edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
  mov   eax,ChromaContribution        ; Fetch <xxxx xxxx UV01 UV00>.
   sub  esp,1536-8
  and   eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
   mov  cl,[esi+2]                    ; Fetch Y02.

Line0Loop:

  or    eax,edx                       ; <UV03 UV02 UV01 UV00>.
   mov  dh,PB YDither[ebx+4]          ; <xxxx xxxx  Y03 xxxx>.
  mov   dl,PB YDither[ecx+2]          ; <xxxx xxxx  Y03  Y02>.
   mov  bl,PB [esi+1]                 ; Fetch Y01.
  shl   edx,16                        ; < Y03  Y02 xxxx xxxx>.
   mov  cl,PB [esi]                   ; Fetch Y00.
  mov   dh,PB YDither[ebx+6]          ; < Y03  Y02  Y01 xxxx>.
   mov  bl,PB [esi+3+4]               ; Fetch next Y03.
  mov   dl,PB YDither[ecx+0]          ; < Y03  Y02  Y01  Y00>.
   mov  cl,PB [esi+2+4]               ; Fetch next Y02.
  add   eax,edx                       ; < P03  P02  P01  P00>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <UV03 UV02 xxxx xxxx>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <xxxx xxxx UV01 UV00>.
  and   edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  add   esp,8
   and  eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
  jne   Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine0:

; Color convert another line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Y Pitch.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   esi,YCursor                   ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor                 ; Fetch output cursor.
  lea   eax,[esi+ebp*2]               ; Compute address of next line of Y.
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch                  ; Compute start of next line.
  mov   AspectCount,edx
   jne  KeepLine1

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <xxxx xxxx UV13 UV12>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+ebp*1+3]              ; Fetch Y13.
   mov  eax,ChromaContribution        ; Fetch <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   sub  esp,1536-8
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   mov  cl,[esi+ebp*1+2]              ; Fetch Y12.

Line1Loop:

  or    eax,edx                       ; <UV13 UV12 UV11 UV10>.
   mov  dh,PB YDither[ebx+6]          ; <xxxx xxxx  Y13 xxxx>.
  mov   dl,PB YDither[ecx+0]          ; <xxxx xxxx  Y13  Y12>.
   mov  bl,PB [esi+ebp*1+1]           ; Fetch Y11.
  shl   edx,16                        ; < Y13  Y12 xxxx xxxx>.
   mov  cl,PB [esi+ebp*1]             ; Fetch Y10.
  mov   dh,PB YDither[ebx+4]          ; < Y13  Y12  Y11 xxxx>.
   mov  bl,PB [esi+ebp*1+3+4]         ; Fetch next Y13.
  mov   dl,PB YDither[ecx+2]          ; < Y13  Y12  Y11  Y10>.
   mov  cl,PB [esi+ebp*1+2+4]         ; Fetch next Y12.
  add   eax,edx                       ; < P13  P12  P11  P10>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <xxxx xxxx UV13 UV12>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   lea  esp,[esp+8]
  jne   Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

  mov   edi,VCursor                   ; Fetch addr of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU          ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                      ; Fetch first V pel.
   ;
  and   ebx,0FCH                      ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]                ; Fetch first U pel.
  and   ecx,0FCH                      ; Reduce to 6 bits.
   mov  VCursor,edx                   ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine23[ebx]
   mov  bl,[edi+1]
  mov   eax,PD UVDitherLine01[ecx]
   mov  cl,[edi+ebp*1+1]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   and  bl,0FCH
  add   eax,edx
   and  cl,0FCH
  mov   edx,PD UVDitherLine23[ebx]
   mov  [esi],eax
  mov   eax,PD UVDitherLine01[ecx]
   mov  bl,[edi+2]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   mov  cl,[edi+ebp*1+2]
  add   eax,edx
   mov  edx,EndOfChromaLine
  mov   [esi+4],eax
   add  edi,2
  and   bl,0FCH
   and  cl,0FCH
  add   esi,8
   sub  edx,edi
  jne   @b

  mov   [esi],edx
   mov  edx,AspectCount
  mov   esi,YCursor
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine2

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine2

KeepLine2:

  mov   edi,CCOCursor
   mov  eax,CCOPitch
  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+3]
   and  edx,0FFFF0000H
  mov   eax,ChromaContribution
   sub  esp,1536-8
  and   eax,00000FFFFH
   mov  cl,[esi+2]

Line2Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+2]
  mov   dl,PB YDither[ecx+4]
   mov  bl,PB [esi+1]
  shl   edx,16
   mov  cl,PB [esi]
  mov   dh,PB YDither[ebx+0]
   mov  bl,PB [esi+3+4]
  mov   dl,PB YDither[ecx+6]
   mov  cl,PB [esi+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  and   edx,0FFFF0000H
   add  esi,4
  add   esp,8
   and  eax,00000FFFFH
  jne   Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine2:

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor
  lea   eax,[esi+ebp*2]
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch
  mov   AspectCount,edx
   jne  KeepLine3

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+ebp*1+3]
   mov  eax,ChromaContribution
  shl   edx,16
   sub  esp,1536-8
  shr   eax,16
   mov  cl,[esi+ebp*1+2]

Line3Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+0]
  mov   dl,PB YDither[ecx+6]
   mov  bl,PB [esi+ebp*1+1]
  shl   edx,16
   mov  cl,PB [esi+ebp*1]
  mov   dh,PB YDither[ebx+2]
   mov  bl,PB [esi+ebp*1+3+4]
  mov   dl,PB YDither[ecx+4]
   mov  cl,PB [esi+ebp*1+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  shl   edx,16
   add  esi,4
  shr   eax,16
   lea  esp,[esp+8]
  jne   Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextFourLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx51282.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cx51282.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:42   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:08   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:53:50   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cx51282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   bl,[esi+1]                  ; Fetch Y01.
   add  eax,edi
  mov   cl,[esi]                    ; Fetch Y00.
   mov  CCOCursor,eax               ; Stash start of next line.
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.
  and   edx,0FFFF0000H              ; Extract < Y01  Y01  ___  ___>.
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.
   mov  bl,[esi+3]                  ; Fetch Y03.
  and   eax,00000FFFFH              ; Extract < ___  ___  Y00  Y00>.
   mov  cl,[esi+2]                  ; Fetch Y02.
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.
   add  esi,4                         ; Advance cursor.
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.
   mov  bl,[esi+1]                    ; Fetch next Y01.
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.
  add   eax,edx                       ; < P03  P03  P02  P02>.
   mov  cl,[esi]                      ; Fetch next Y00.
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.
   mov  bl,[esi+3]                    ; Fetch Y03.
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.
  add   esp,8
   mov  cl,[esi+2]                    ; Fetch Y02.
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  mov   bl,[esi+1]                  ; Fetch Y01.
   add  eax,edi
  mov   cl,[esi]                    ; Fetch Y00.
   mov  CCOCursor,eax               ; Stash start of next line.
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.
   mov  bl,[esi+3]                  ; Fetch Y03.
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.
   mov  cl,[esi+2]                  ; Fetch Y02.
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.
  rol   edx,16                      ; Swap dither pattern.
   sub  esp,1536

Line1Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.
   add  esi,4                         ; Advance cursor.
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.
   mov  bl,[esi+1]                    ; Fetch next Y01.
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.
  rol   edx,16                        ; Swap dither pattern.
   add  esp,8
  add   eax,edx                       ; < P03  P03  P02  P02>.
   mov  cl,[esi]                      ; Fetch next Y00.
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.
   mov  bl,[esi+3]                    ; Fetch Y03.
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.
  rol   edx,16                        ; Swap dither pattern.
   mov  cl,[esi+2]                    ; Fetch Y02.
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edi,CCOCursor
   mov  eax,CCOPitch
  mov   bl,[esi+ebp*1]
   add  eax,edi
  mov   cl,[esi+ebp*1+1]
   mov  CCOCursor,eax
  mov   edx,PD YDitherZ2[ebx*4]
   sub  edi,esi
  shl   edx,16
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]
   mov  bl,[esi+ebp*1+2]
  shr   eax,16
   mov  cl,[esi+ebp*1+3]
  or    eax,edx
   mov  edx,ChromaContribution
  rol   edx,16
   sub  esp,1536

Line2Loop:

  add   eax,edx
   mov  edx,PD YDitherZ2[ebx*4]
  bswap eax
  mov   Ze [edi+esi*2],eax
   add  esi,4
  shl   edx,16
   mov  eax,PD YDitherZ2[ecx*4]
  shr   eax,16
   mov  bl,[esi+ebp*1]
  or    eax,edx
   mov  edx,ChromaContribution+1536+4
  rol   edx,16
   add  esp,8
  add   eax,edx
   mov  cl,[esi+ebp*1+1]
  bswap eax
  mov   Ze [edi+esi*2+4-8],eax
   mov  edx,PD YDitherZ2[ebx*4]
  shl   edx,16
   mov  eax,PD YDitherZ2[ecx*4]
  shr   eax,16
   mov  bl,[esi+ebp*1+2]
  or    eax,edx
   mov  edx,ChromaContribution+1536
  rol   edx,16
   mov  cl,[esi+ebp*1+3]
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor
   sub  edx,2
  lea   eax,[esi+ebp*2]
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  mov   bl,[esi+ebp*1]
   mov  eax,CCOPitch
  add   eax,edi
   mov  cl,[esi+ebp*1+1]
  mov   CCOCursor,eax
   mov  edx,PD YDitherZ2[ebx*4]
  sub   edi,esi
   mov  eax,PD YDitherZ2[ecx*4]
  and   edx,0FFFF0000H
   sub  edi,esi
  mov   bl,[esi+ebp*1+2]
   and  eax,00000FFFFH
  mov   cl,[esi+ebp*1+3]
   or   eax,edx
  mov   edx,ChromaContribution
   sub  esp,1536

Line3Loop:

  add   eax,edx
   mov  edx,PD YDitherZ2[ebx*4]
  bswap eax
  mov   Ze [edi+esi*2],eax
   add  esi,4
  and   edx,0FFFF0000H
   mov  eax,PD YDitherZ2[ecx*4]
  and   eax,00000FFFFH
   mov  bl,[esi+ebp*1]
  or    eax,edx
   mov  edx,ChromaContribution+1536+4
  add   eax,edx
   mov  cl,[esi+ebp*1+1]
  bswap eax
  mov   Ze [edi+esi*2+4-8],eax
   mov  edx,PD YDitherZ2[ebx*4]
  and   edx,0FFFF0000H
   mov  eax,PD YDitherZ2[ecx*4]
  and   eax,00000FFFFH
   mov  bl,[esi+ebp*1+2]
  or    eax,edx
   mov  edx,ChromaContribution+1536+8
  add   esp,8
   mov  cl,[esi+ebp*1+3]
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx5128a1.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a1.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a1.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:26   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:30   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:22:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:58:38   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:40   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:14   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by one, i.e. non-zoom.
; cx5128a1  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;              It converts the input to the clut8 index dyncamically computed
;              for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a1>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8AP (U8 * YPlane,
;                                       U8 * VPlane,
;                                       U8 * UPlane,
;                                       UN  FrameWidth,
;                                       UN  FrameHeight,
;                                       UN  YPitch,
;                                       UN  VPitch,
;                                       UN  AspectAdjustmentCount,
;                                       U8 FAR * ColorConvertedFrame,
;                                       U32 DCIOffset,
;                                       U32 CCOffsetToLine0,
;                                       IN  CCOPitch,
;                                       IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8AP

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8AP    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine0

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine0

KeepLine0:

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*2-8+0]        ; 03 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+2]                ; 02 -- Fetch luma for Pel02
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+3]                ; 03 -- Fetch luma for Pel03
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+2]        ; 01 -- Fetch UV contrib to Active Pal addr
    
Line0Loop:

  mov   bh,PB [esi-768*2-8+1]        ; 02 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01 -- Fetch luma for Pel01
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither03 -8] ; 03 -- Pel03 clut index
  mov   al,PB [esi+0]                ; 00 -- Fetch luma for Pel00
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither02 -8] ; 02 -- Pel02 clut index
  shl   edx,16                       ; 03 & 02 -- Position high order pels
   mov  ah,PB [esi-768*1-4+3]        ; 00 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+2+4]              ; 02 -- Fetch luma for next Pel02
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither01 -8] ; 01 -- Pel01 clut index
   mov  ch,PB [esi-768*1-4+2+4]      ; 01 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither00 -8] ; 00 -- Pel00 clut index
   mov  ah,PB [esi-768*2-8+0+4]      ; 03 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+3+4]              ; 03 -- Fetch luma for next Pel03
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line0Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine0:

  Lesi  YPlane                       ; Reload luma cursor.
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine1

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*2-8+2]        ; 13 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+ebp*1+2]          ; 12 -- Fetch luma for Pel12
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+ebp*1+3]          ; 13 -- Fetch luma for Pel13
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+0]        ; 11 -- Fetch UV contrib to Active Pal addr
    
Line1Loop:

  mov   bh,PB [esi-768*2-8+3]        ; 12 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+ebp*1+1]          ; 11 -- Fetch luma for Pel11
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither13 -8] ; 13 -- Pel13 clut index
  mov   al,PB [esi+ebp*1+0]          ; 10 -- Fetch luma for Pel10
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither12 -8] ; 12 -- Pel12 clut index
  shl   edx,16                       ; 13 & 12 -- Position high order pels
   mov  ah,PB [esi-768*1-4+1]        ; 10 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+ebp*1+2+4]        ; 12 -- Fetch luma for next Pel12
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither11 -8] ; 11 -- Pel11 clut index
   mov  ch,PB [esi-768*1-4+0+4]      ; 11 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither10 -8] ; 10 -- Pel10 clut index
   mov  ah,PB [esi-768*2-8+2+4]      ; 13 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+ebp*1+3+4]        ; 13 -- Fetch luma for next Pel13
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line1Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine1:

  Lesi  YPlane                       ; Reload luma cursor.
   lea  edx,[ebp*2]
  add   esi,edx
   Ledi VPlane
  Sesi  YPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine2

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine2

KeepLine2:

  mov   ah,PB [esi-768*2-8+1]
   mov  bl,PB [esi+2]
  shr   bl,1
   mov  al,PB [esi+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+3]
    
Line2Loop:

  mov   bh,PB [esi-768*2-8+0]
   mov  cl,PB [esi+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither23 -8]
  mov   al,PB [esi+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither22 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+2]
  shr   al,1
   mov  bl,PB [esi+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither21 -8]
   mov  ch,PB [esi-768*1-4+3+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither20 -8]
   mov  ah,PB [esi-768*2-8+1+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line2Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine2:

  Lesi  YPlane
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine3

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*2-8+3]
   mov  bl,PB [esi+ebp*1+2]
  shr   bl,1
   mov  al,PB [esi+ebp*1+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+1]
    
Line3Loop:

  mov   bh,PB [esi-768*2-8+2]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither33 -8]
  mov   al,PB [esi+ebp*1+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither32 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+0]
  shr   al,1
   mov  bl,PB [esi+ebp*1+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither31 -8]
   mov  ch,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither30 -8]
   mov  ah,PB [esi-768*2-8+3+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+ebp*1+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line3Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine3:

  Lesi  YPlane
   lea  edx,[ebp*2]
  add   esi,edx
   Ledx YLimit
  Sesi  YPlane
   cmp  esi,edx
  jne   NextFourLines

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8AP endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512321.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512321.asv
;//
;// $Log:   S:\h26x\src\dec\cx512321.asv  $
;// 
;//    Rev 1.0   01 Apr 1996 10:25:46   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, the third byte is R, and the high order byte
;             is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB32    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  imul  edx,ecx
  sub   ecx,ebx
   lea  ebx,[ebx*4]
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,3
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  CCOSkipDistance,eax
  mov   YLimit,edx
   mov  ChromaLineLen,ebx
  mov   YCursor,esi
   xor  eax,eax
  mov   esi,VCursor
   mov  LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  edx,AspectCount
  mov   [edi],eax                   ; Store EOL indicator.
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   mov  edi,CCOCursor
  mov   esi,YCursor
   jne  KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  edx,edx

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+8]                    ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx5128a2.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a2.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a2.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:57:48   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:32   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:02   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:59:12   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:52   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:45:24   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:24   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by two
; cx5128a2  -- This function performs YUV12 to CLUT8, zoom by two color
;              conversion for H26x.  It converts the input to the clut8
;              index dyncamically computed for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a2>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8APZoomBy2 (U8 * YPlane,
;                                              U8 * VPlane,
;                                              U8 * UPlane,
;                                              UN  FrameWidth,
;                                              UN  FrameHeight,
;                                              UN  YPitch,
;                                              UN  VPitch,
;                                              UN  AspectAdjustmentCount,
;                                              U8 FAR * ColorConvertedFrame,
;                                              U32 DCIOffset,
;                                              U32 CCOffsetToLine0,
;                                              IN  CCOPitch,
;                                              IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8APZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8APZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  xor   eax,eax
   xor  ebx,ebx
  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledi  CCOCursor                    ; Re-load color converted output cursor.
   Sebp EndOfLine
  sub   edi,esi
   Lebp YPitch

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+0]        ; 01UL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1]        ; 01UR  Fetch UV contrib to Active Pal addr
  sub   edi,esi
   mov  PB [esi+1],cl                ; 01    Stash 7 bit luma for next line

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+2]        ; 00UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shr   cl,1                         ; 00    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+3]        ; 00UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 01    Position high order pels
   mov  PB [esi+0],cl                ; 00    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 03UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  shr   cl,1                         ; 03    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+1]        ; 03UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  PB [esi+3],cl                ; 03    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 02UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shr   cl,1                         ; 02    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+3]        ; 02UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 03    Position high order pels
   mov  PB [esi+2],cl                ; 02    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+0+4]      ; 01UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1+4]      ; 01UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  PB [esi+1+4],cl              ; 01    Stash 7 bit luma for next line
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  Lesi  YPlane                       ; Reload luma cursor.
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine1

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*1-4+2]        ; 01LL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  mov   bh,PB [esi-768*1-4+3]        ; 01LR  Fetch UV contrib to Active Pal addr
   sub  edi,esi

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+0]        ; 00LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shl   edx,16                       ; 01    Position high order pels
   mov  bh,PB [esi-768*1-4+1]        ; 00LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 03LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*2-8+3]        ; 03LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 02LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shl   edx,16                       ; 03    Position high order pels
   mov  bh,PB [esi-768*2-8+1]        ; 02LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+2+4]      ; 01LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*1-4+3+4]      ; 01LR  Fetch UV contrib to Active Pal addr
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine1:

  Sedi  CCOCursor
   Lesi YPlane                       ; Reload luma cursor.
  sub   edi,esi
   xor  eax,eax

; ebp -- Luma pitch
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  sub   edi,esi
   mov  bh,PB [esi-768*1-4+0]

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+0]
  shl   edx,16
   mov  bh,PB [esi-768*1-4+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+3]
  mov   PD es:[edi+esi*2],edx
   mov  bh,PB [esi-768*2-8+0]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+2]
  shl   edx,16
   mov  bh,PB [esi-768*2-8+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  bh,PB [esi-768*1-4+0+4]
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor
  Lesi  YPlane
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine3

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0]
  sub   edi,esi
   mov  PB [esi+ebp*1+1],cl

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+0]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+2]
  shl   edx,16
   mov  PB [esi+ebp*1+0],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+3]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+0]
  mov   PD es:[edi+esi*2],edx
   mov  PB [esi+ebp*1+3],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+2]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+2]
  shl   edx,16
   mov  PB [esi+ebp*1+2],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  PB [esi+ebp*1+1+4],cl
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine3:

  add   ebp,ebp
   Lesi YPlane
  Sedi  CCOCursor
   add  esi,ebp
  Sesi  YPlane
   Ledx YLimit
  cmp   esi,edx
   jne  NextFourLines


IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8APZoomBy2 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512yuv.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512yuv.asv   1.5   30 Dec 1996 20:02:08   MDUDA  $
;//
;// $Log:   S:\h26x\src\dec\cx512yuv.asv  $
;// 
;//    Rev 1.5   30 Dec 1996 20:02:08   MDUDA
;// Fixed problem where buffer boundaries were being over-written.
;// 
;//    Rev 1.4   11 Dec 1996 14:58:52   JMCVEIGH
;// 
;// Changed to support width the are multiples of 4.
;// 
;//    Rev 1.3   18 Jul 1996 12:52:58   KLILLEVO
;// changed cache heating to speed things up a bit 
;// 
;//    Rev 1.2   18 Jul 1996 09:39:34   KLILLEVO
;// 
;// added PVCS header and log

;; Very straightforward implementation of the YUV pitch changer
;; Does 16 pels at a time. If the width is not a multiple of 16
;; the remainder pels are handled as a special case. We assume
;; that the width is at least a multiple of 4

OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUV


YUV12ToYUV   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  12

RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

LineAdd          = 0          ; 1
LineWidth        = 4          ; 2

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_LineAdd                 EQU    [esp + LineAdd]
_LineWidth               EQU    [esp + LineWidth]
_uRemainderEdgePels		 EQU	[esp + uRemainderEdgePels]

; Save registers and start working

push    ebx
 push   esi
push    edi
 push   ebp

sub     esp, LocalFrameSize

 mov   	eax, _uCCOutputBuffer
add     eax, _uOffsetToLine0
 mov    ecx, _lOutput
add     eax, ecx        
 mov    ebx, _uYPitch
mov     ecx, _uWidth
 mov    esi, _uYPlane
mov     edi, eax

; luma
sub    ebx, ecx   ; ebx = pitch - width
 mov    edx, _uHeight
mov    eax, _uWidth
 mov    _LineAdd, ebx

L2:
test	ecx, 0FFFFFFF0H
 jz		LEdgePels			; Width may be less than 16

L1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 16
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 16], eax
 mov    DWORD PTR [edi - 12], ebx
mov     eax, DWORD PTR [esi + 8]
 mov    ebx, DWORD PTR [esi +12]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 16
 sub    ecx, 16

test	ecx, 0FFFFFFF0H
 jnz    L1

LEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 8 edge pels
test	ecx, 08H
 jz		Lchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 mov	ebx, DWORD PTR [esi + 4]			; Input pels 4-7
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 mov	DWORD PTR [edi + 4], ebx			; Output pels 4-7
add		esi, 8
 add	edi, 8

Lchk4:
; Check 4 edge pels
test	ecx, 04H
 jz		L2_cont
mov    eax, DWORD PTR [esi + 0]			; Input pels 0-3
add		esi, 4
mov    DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

L2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     L2

; chroma
mov     esi, _uUPlane
 mov    ecx, _uWidth
shr     ecx, 1
 mov    ebx, _uUVPitch
sub     ebx, ecx   ; ebx = pitch - width/2
 mov    edx, _uHeight
shr     edx, 1
 mov    _LineAdd, ebx
mov		_uWidth, ecx
 mov	_uHeight, edx

U2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

U1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    U1

UEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Uchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Uchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		U2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

U2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     U2


; chroma
mov    esi, _uVPlane
 mov	ecx, _uWidth
mov    edx, _uHeight
 nop

V2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

V1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    V1

VEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Vchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Vchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		V2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

V2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
jnz     V2

add     esp, LocalFrameSize  ; restore esp to registers                               

pop	    ebp
 pop    edi
pop	    esi
 pop    ebx
ret     52                   ; 13*4 bytes of arguments

YUV12ToYUV ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\decconst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\decconst.inv   1.1   27 Dec 1995 14:36:22   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\decconst.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:22   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

;//
;// DECCONST.INC - derived from MRV
;//

IFDEF _DECCONST_INC_
ELSE
_DECCONST_INC = 1

; Constants used by MRV decoder, post filtering functions, and color convertors.

YARCHIVEOFFSET    = 311688
UOFFSET           = 168
VPITCH            = 336

BEFTRIGGER        = 143
BEFWILLING        = 125
BEFUNWILLING      =  10
BEFENDOFLINE      =  21
BEFENDOFFRAME     = 246

YPITCH      = 384           
YSTARTOFF   = YPITCH*16+16  ; offset into output buffer of first pixel to write

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e15uvslf.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
.486
.Model FLAT, C
APP_32BIT equ 1
.CODE

IFDEF SLF_WORK_AROUND
EncUVLoopFilter PROC C PUBLIC USES esi edi ebx ebp in8x8:DWORD, out8x8:DWORD, pitch:DWORD
LOCAL filt_temp[32]:DWORD, loop_count:DWORD
; **************************************************
; output pitch is hard coded to 384
; 	input pitch is 384 (as passed parameter)
; **************************************************

	mov	esi,in8x8
;	mov	edi,out8x8		; for debug
	 lea	edi,filt_temp		; use temporary storage
	mov	loop_count,8
	xor	eax,eax

; filter 8x8 block horizontally
; input is 8-bit, output is 16-bit temporary storage
do_row:
; pixel 0
	mov	al,byte ptr [esi]	; get p0, eax = a
	 xor	ebx,ebx
	mov	edx,eax			; copy pixel 0
	 xor	ecx,ecx
	shl	edx,2			; a<<2
; pixel 0 + pixel 1
	 mov	bl,byte ptr [esi+1]	; get p1, ebx = b
	mov	[edi],dx		; output p0 = a<<2
	 add	eax,ebx			; eax = (a+b)
	mov	cl,byte ptr [esi+2]	; get p2, ecx = c
; pixel 1 + pixel 2
	 xor	edx,edx
	add	ebx,ecx			; ebx = (b+c)
	 mov	dl,byte ptr [esi+3]	; get p3, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	mov	[edi+2],ax		; output p1 = (a+b) + (b+c)
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
; pixel 2 + pixel 3
	mov	[edi+4],bx		; output p2 = (a+b) + (b+c)
	 xor	eax,eax
	mov	al,byte ptr [esi+4]	; get p4, eax = c
; pixel 3 + pixel 4
	 xor	ebx,ebx
	add	edx,eax			; edx = (b+c)
	 mov	bl,byte ptr [esi+5]	; get p5, ebx = c
	add	ecx,edx			; ecx = (a+b) + (b+c)
	 add	eax,ebx			; eax = (b+c)
	mov	[edi+6],cx		; output p3 = (a+b) + (b+c)
	 add	edx,eax			; edx = (a+b) + (b+c)
; pixel 4 + pixel 5
	mov	[edi+8],dx		; output p4 = (a+b) + (b+c)
	 xor	ecx,ecx
	mov	cl,byte ptr [esi+6]	; get p6, ecx = c
; pixel 5 + pixel 6
	 xor	edx,edx
	add	ebx,ecx			; ebx = (a+b)
	 mov	dl,byte ptr [esi+7]	; get p7, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	shl	edx,2			; p7<<2
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+10],ax		; output p5 = (a+b) + (b+c)
; pixel 6 + pixel 7
	 xor	eax,eax			; for next iteration
	mov	[edi+12],bx		; output p6 = (a+b) + (b+c)
	 mov	ecx,loop_count
	mov	[edi+14],dx		; output p7 = c<<2
	 mov	ebx,pitch
	add	edi,16
	 add	esi,ebx			; inc input ptr
	dec	ecx
	mov	loop_count,ecx
	 jnz	do_row

; filter 8x8 block vertically
; input is 16-bit from temporary storage, output is 8-bit

	lea	esi,filt_temp
	 mov	edi,out8x8
	
	mov	loop_count,4			; loop counter
row0:
	mov	eax,[esi]		; eax = a
; row0 + row1
	 mov	ebx,[esi+16]		; get b
	mov	edx,eax			; copy a
	 add	eax,ebx			; eax = (a+b)
	add	edx,00020002h		; round result
	 mov	ecx,[esi+32]		; get c
	shr	edx,2			; divide by 4
	 add	ebx,ecx			; ebx = (b+c)
	and	edx,00ff00ffh		; convert back to 8-bit
	 add	eax,ebx			; eax = (a+b) + (b+c)
	mov	[edi],dl		; output a for column 0  
	 add	eax,00080008h		; round
	shr	edx,16
	shr	eax,4
	 mov	[edi+1],dl		; output a for column 1
; row1 + row2
	mov	edx,[esi+48]		; get c
	 and	eax,00ff00ffh
	add	ecx,edx			; ecx = (b+c)
	 mov	[edi+384],al		; output b for column 0  
	shr	eax,16
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+385],al		; output b for column 1
	 add	ebx,00080008h		; round
	shr	ebx,4
; row2 + row3
	 mov	eax,[esi+64]		; get c
	and	ebx,00ff00ffh
	 add	edx,eax			; edx = (b+c)
	mov	[edi+768],bl		; output c for column 0  
	 add	ecx,edx			; ecx = (a+b) + (b+c)
	shr	ebx,16
	 add	ecx,00080008h		; round
	shr	ecx,4
	 mov	[edi+769],bl		; output c for column 1
	and	ecx,00ff00ffh
; row3 + row4
	 mov	ebx,[esi+80]		; get c
	mov	[edi+1152],cl		; output c
	 add	eax,ebx			; eax = (b+c)
	shr	ecx,16
	 add	edx,eax			; edx = (a+b) + (b+c)
	mov	[edi+1153],cl		; output c
	 add	edx,00080008h		; round
	shr	edx,4
; row4 + row5
	 mov	ecx,[esi+96]		; get c
	and	edx,00ff00ffh
	 add	ebx,ecx			; ebx = (b+c)
	mov	[edi+1536],dl		; output c
	 add	eax,ebx			; eax = (a+b) + (b+c)
	shr	edx,16
	 add	eax,00080008h		; round
	shr	eax,4
	 mov	[edi+1537],dl		; output c
	and	eax,00ff00ffh
; row5 + row6
	 mov	edx,[esi+112]		; get c
	mov	[edi+1920],al		; output c
	 add	ecx,edx			; ecx = (b+c)
	shr	eax,16
; row6 + row7
	 add	edx,00020002h		; round result
	shr	edx,2			; divide by 4
	 mov	[edi+1921],al		; output c
	add	ebx,ecx			; ebx = (a+b) + (b+c)
	 and	edx,00ff00ffh		; convert back to 8-bit
	add	ebx,00080008h		; round
	 mov	[edi+2688],dl		; output c
	shr	ebx,4
	 mov	ecx,loop_count
	shr	edx,16
	 and	ebx,00ff00ffh
	mov	[edi+2304],bl		; output c
	 mov	[edi+2689],dl		; output c
	shr	ebx,16
	 add	esi,4			; inc input ptr
	mov	[edi+2305],bl		; output c
	 add	edi,2
	dec	ecx
	mov	loop_count,ecx
	 jnz	row0

	ret
EncUVLoopFilter	EndP

ENDIF

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\dx5frmcp.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************
;//
;//
;// $Header:   S:\h26x\src\dec\dx5frmcp.asv
;//
;// $Log:   S:\h26x\src\dec\dx5frmcp.asv  $
;// 
;//    Rev 1.1   20 Dec 1995 15:55:42   RMCKENZX
;// Added FrameMirror function to file to support mirror imaging
;// 
;//    Rev 1.0   25 Oct 1995 18:11:36   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; File:
;   dx5frmcp 
;
; Functions:
;   FrameCopy
;     This function copies a frame from one frame buffer to another.
;     It is tuned for best performance on the Pentium(r) Microprocessor.
;
;     It is assumed that the frames have the same height, width, and
;     pitch, and that, if width is NOT a multiple of 8, it is okay
;     to copy up to the next multiple of 8.
;
;   FrameMirror
;     This function mirror images a frame from one frame buffer to
;     another.  It is tuned for best performance on the Pentium.
;
;     It is assumed that the frames have the same height, width, and
;     pitch.  The width may be any (non-negative) value.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_FrameCopy>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE FrameCopy (U8 FAR * InputBase,
;                                  X32 InputPlane,
;                                  U8 FAR * OutputBase,
;                                  X32 OutputPlane,
;                                  UN  FrameHeight,
;                                  UN  FrameWidth,
;                                  UN  Pitch)

PUBLIC  FrameCopy

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        FrameCopy    proc DIST LANG AInputPlane:        DWORD,
                                    AOutputPlane:       DWORD,
                                    AFrameHeight:       DWORD,
                                    AFrameWidth:        DWORD,
                                    APitch:             DWORD

IFDEF WIN32

RegisterStorageSize = 16

; Arguments:

InputPlane                 = RegisterStorageSize +  4
OutputPlane                = RegisterStorageSize +  8
FrameHeight                = RegisterStorageSize + 12
FrameWidth                 = RegisterStorageSize + 16
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 24

ELSE

; Arguments:

RegisterStorageSize = 24           ; Put local variables on stack.
InputPlane                 = RegisterStorageSize +  4
InputPlane_SegNum          = RegisterStorageSize +  6
OutputPlane                = RegisterStorageSize +  8
OutputPlane_SegNum         = RegisterStorageSize + 10
OutputPlane                = RegisterStorageSize + 12
FrameHeight                = RegisterStorageSize + 16
FrameWidth                 = RegisterStorageSize + 18
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 22

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  mov  esi,PD [esp+InputPlane]
   mov  edi,PD [esp+OutputPlane]
  mov   ebp,PD [esp+Pitch]
   mov  edx,PD [esp+FrameWidth]
  mov   ecx,PD [esp+FrameHeight]
ELSE
  mov   ax,ds
  mov   bx,es
  push  eax
   push ebx
  mov   ax,PW [esp+InputBase_SegNum]
  movzx esi,PW [esp+InputPlane]
  mov   bx,PW [esp+OutputBase_SegNum]
  movzx edi,PW [esp+OutputPlane]
  mov   ds,ebx
  mov   es,eax
  movzx ebp,PW [esp+Pitch]
  movzx edx,PW [esp+FrameWidth]
  movzx ecx,PW [esp+FrameHeight]
ENDIF
  add   edx,7
  and   edx,0FFFFFFF8H
  sub   ebp,edx
  sub   edi,esi

  push  edx

CopyLineLoop:

  mov   eax,Ze PD [esi]
   mov  ebx,PD [esi+edi]      ; Load output cache line
  mov   ebx,Ze PD [esi+4]
   mov  PD [esi+edi],eax
  mov   PD [esi+edi+4],ebx
   add  esi,8
  sub   edx,8
   jg   CopyLineLoop

  add   esi,ebp
   dec  ecx                  ; Reduce count of lines.
  mov   edx,PD [esp]         ; Reload frame width.
   jg   CopyLineLoop

  pop   edx

IFDEF WIN32
ELSE
  pop   ebx
  mov   es,ebx
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FrameCopy endp



PUBLIC  FrameMirror

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

FrameMirror    proc DIST LANG BInputPlane:        DWORD,
                              BOutputPlane:       DWORD,
                              BFrameHeight:       DWORD,
                              BFrameWidth:        DWORD,
                              BPitch:             DWORD

;  save registers
  push    esi
   push   edi
  push    ebp
   push   ebx

;  setup and get parameters
IFDEF WIN32
  mov     esi, PD [esp+InputPlane]
   mov    edi, PD [esp+OutputPlane]
  mov     ebp, PD [esp+Pitch]
   mov    edx, PD [esp+FrameWidth]
  mov     ecx, PD [esp+FrameHeight]

ELSE
  mov     ax, ds
   mov    bx, es
  push    eax
   push   ebx
  mov     ax, PW [esp+InputBase_SegNum]
   movzx  esi, PW [esp+InputPlane]
  mov     bx, PW [esp+OutputBase_SegNum]
   movzx  edi, PW [esp+OutputPlane]
  mov     ds, ebx
   mov    es, eax
  movzx   ebp, PW [esp+Pitch]
   movzx  edx, PW [esp+FrameWidth]
  movzx   ecx, PW [esp+FrameHeight]
ENDIF

;  start processing

;  prepare for the loop
   push   edx                   ; save width

per_line_loop:
  test    edx, 7				; check for short count
   je     skip_short_count		; skip when no short count

short_count_loop:
  mov     al, [esi+edx-1]
   dec    edx
  mov     [edi], al
   inc    edi
  test    edx, 7
   jne    short_count_loop

skip_short_count:
  test    edx, edx
   je     skip_inner_loop

;  inner loop is unrolled to do 8 bytes per iteration
inner_loop:
  mov     al, [edi]			  ; heat cache
   add    edi, 8
  mov     al, [esi+edx-1]
   mov    bl, [esi+edx-5]
  mov     [edi-8], al
   mov    [edi-4], bl
  mov     al, [esi+edx-2]
   mov    bl, [esi+edx-6]
  mov     [edi-7], al
   mov    [edi-3], bl
  mov     al, [esi+edx-3]
   mov    bl, [esi+edx-7]
  mov     [edi-6], al
   mov    [edi-2], bl
  mov     al, [esi+edx-4]
   mov    bl, [esi+edx-8]
  mov     [edi-5], al
   mov    [edi-1], bl
  sub     edx, 8
   jne    inner_loop

;  now move down to the next line
skip_inner_loop:
  mov     edx, [esp]		; restore width
   add    edi, ebp			; increment destination
  add     esi, ebp			; increment source
   sub    edi, edx			; correct destination by width
  dec     ecx
   jne    per_line_loop

;  restore stack pointer
  pop     eax

IFDEF WIN32
ELSE
  pop     ebx
   pop    eax
  mov     es, bx
   mov    ds, ax
ENDIF

;  restore registers and return
  pop     ebx
   pop    ebp
  pop     edi
   pop    esi
  rturn

FrameMirror endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUY2


YUV12ToYUY2   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]


; Save registers and start working

        push       ebx
         push      esi
        push       edi
         push      ebp

        sub        esp, LocalFrameSize

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
         mov       ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
        dec        eax                             ; eax = bShapingFlag - 1
         mov       edx, DWORD PTR _uUPlane         ; edx = uUPlane
        mov        DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
         mov       DWORD PTR _Y, ecx               ; ecx = FREE, Y

        mov        eax, DWORD PTR _uVPlane         ; eax = uVPlane
         mov       ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
        mov        DWORD PTR _U, edx               ; edx = FREE, U
         add       ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

        mov        DWORD PTR _V, eax               ; eax = FREE, V
        mov        eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
        add        eax, ecx                        ; eax = uCCOutputBuffer +
                                                   ;       uOffsetToLine0 +
                                                   ;       lOutput
                                                   ;       ecx = FREE
        mov        DWORD PTR _Out, eax             ; eax = FREE, Out
        mov        eax, DWORD PTR _uHeight         ; eax = uHeight

	      sar	       eax, 1                          ; eax = uHeight/2
        mov        DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
                                                   ; count down

RowLoop:; L27704 outer loop over all rows


        mov        ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
         mov       edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
        mov        ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
         mov       esi, DWORD PTR _Out             ; esi = OutTemp
        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
	      test	     eax, eax                        ; is LineCount == 0? eax = FREE
        je         SHORT SkipEvenRow               ; L27708 loop if so, skip the even loop
        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2                          ; eax = uWidth/4	** assume uWidth/4 != 0


EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         jne       SHORT EvenRowPels               ; L27709 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
        jmp        SHORT UpdatePointers						 ; L27770

SkipEvenRow:; L27708

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770


        mov        ecx, DWORD PTR _Y               ; ecx = Y
         dec       eax                             ; eax = LineCount-1 OR bShapingFlag - 1
        mov        edx, DWORD PTR _intPitch        ; edx = intPitch
         mov       esi, DWORD PTR _Out             ; esi = Out
				mov        DWORD PTR _LineCount, eax       ; store decremented linecount
                                                   ; eax = FREE
        add        esi, edx                        ; (esi) Out += intPitch ***
         mov       eax, DWORD PTR _uYPitch         ; eax = uYPitch
        mov        edi, DWORD PTR _U               ; edi = U	***
         add       ecx, eax                        ; (ecx) Y += uYPitch ***
        mov        ebp, DWORD PTR _V               ; ebp = V	***
         mov       DWORD PTR _Y, ecx               ; store updated Y 
      
        mov        DWORD PTR _Out, esi             ; store Out
         mov       eax, DWORD PTR _LineCount       ; eax = LineCount
    
        test       eax, eax                        ; is LineCount == 0?
                                                   ; if so, ignore the odd
                                                   ; row loop over columns
         je        SHORT SkipOddRow						  	 ; L27714

        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2											 ; eax = uWidth/4
	      

OddRowPels: ;L27715 loop over columns of odd rows

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         
        jne        SHORT OddRowPels                ; L27715 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
         jmp       SHORT UpdateAllPointers	  		 ; L27771

SkipOddRow: ;L27714 

        mov        eax, DWORD PTR _bShapingFlag		 ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

      	dec	       eax														 ; eax = LineCount-1 OR bShapingFlag - 1
         mov       ecx, DWORD PTR _Y							 ; ecx = Y
        mov        edx, DWORD PTR _intPitch				 ; edx = intPitch
         mov       ebx, DWORD PTR _Out						 ; ebx = Out
	      add	       ebx, edx												 ; ebx = Out + intPitch
         mov       ebp, DWORD PTR _ASMTMP2				 ; ebp = row loop counter
        mov        DWORD PTR _LineCount, eax			 ; store updated LineCount
         mov       DWORD PTR _Out, ebx						 ; store updated Out
				mov        edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
				 mov       eax, DWORD PTR _U               ; eax = U
				mov        esi, DWORD PTR _V               ; esi = V
				 add       eax, edx                        ; eax = U + uUVPitch
				add        esi, edx                        ; esi = V + uUVPitch
				 mov       DWORD PTR _U, eax               ; store updated U
				mov        DWORD PTR _V, esi               ; store updated V
         add       ecx, DWORD PTR _uYPitch				 ; ecx = Y + uYPitch
	      dec	       ebp														 ; decrement loop counter
         mov       DWORD PTR _Y, ecx							 ; store updated Y
        mov        DWORD PTR _ASMTMP2, ebp				 ; store updated loop counter
        
        jne        RowLoop                         ; back to L27704 row loop



CleanUp:

        add        esp, LocalFrameSize             ; restore esp to registers                               


      	pop	ebp
	       pop	edi
	      pop	esi
	       pop	ebx

        ret     52                                 ; 13*4 bytes of arguments

YUV12ToYUY2 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e15vlc.asm ===
; ++ ========================================================================
;
;              INTEL CORPORATION PROPRIETARY INFORMATION
;
;       This software is supplied under the terms of a license
;       agreement or nondisclosure agreement with Intel Corporation
;       and may not be copied or disclosed except in accordance
;       with the terms of that agreement.
;
;       Copyright (c) 1995 Intel Corporation.  All Rights Reserved.
;
;    ========================================================================
;
;       
;       Declaration:
;               void MBEncodeVLC (
;                       char *                  pMBRVS_Luma,
;                       char *                  pMBRVS_Chroma,
;                       unsigned int            CodedBlkPattern,
;                       unsigned char **        pBitStream,
;                       unsigned char *         pBitOffset,
;                       int                     IntraFlag,
;                       int                     MMxFlag
;               );

;       Description:
;               This function encodes a macroblock's worth of RLE values.
;               The RLE values are provided to me in a list of triplets
;               where the triplets consist of RUN, LEVEL, and SIGN, where
;               each element is a BYTE.
;
;       Register Usage:
;               ESI -- RLE stream cursor
;               EDI -- Bit stream cursor
;               EDX -- Bit stream offset
;
; $Header:   S:\h26x\src\enc\e15vlc.asv   1.9   21 Oct 1996 09:06:42   RHAZRA  $
;
; $Log:   S:\h26x\src\enc\e15vlc.asv  $
;// 
;//    Rev 1.9   21 Oct 1996 09:06:42   RHAZRA
;// 
;// Check for 0 level and change to 127 if so.
;// 
;//    Rev 1.8   01 Nov 1995 08:59:14   DBRUCKS
;// Don't output EOB on empty INTRA
;// 
;//    Rev 1.7   23 Oct 1995 16:38:08   DBRUCKS
;// fix sizeof VLC TCOEF Table
;// 
;//    Rev 1.6   28 Sep 1995 11:58:04   BECHOLS
;// Added exception code to handle the special case where the first code of
;// an inter block is 11s, and I change it to 1s per the spec.  I also added
;// a read to PutBits to preload the cache for the write.  I also looped the
;// main function to reduce code size.
;// 
;//    Rev 1.5   26 Sep 1995 13:32:24   DBRUCKS
;// write EOB after DC in empty Intra
;// 
;//    Rev 1.4   25 Sep 1995 17:23:12   BECHOLS
;// Modified the code to write what I think will be a valid H261 bit stream.
;// Also modified the code for optimum performance.
;// 
;//    Rev 1.3   21 Sep 1995 18:17:14   BECHOLS
;// 
;// Change the way I handle the VLC table called VLC_TCOEF_TBL to account
;// for its new format as initialized in E1MBENC.CPP.  The code is work in prog
;// 
;//    Rev 1.2   20 Sep 1995 17:34:42   BECHOLS
;// 
;// made correction to macro.
;// 
;//    Rev 1.1   20 Sep 1995 16:56:54   BECHOLS
;// 
;// Updated to the optimized version, and removed the TCOEF_LAST_TBL
;// because H261 doesn't use it.  I changed the TCOEF_TBL to a single
;// DWORD and will pack the size and code to save data space.
;
; -- ========================================================================
.486
.MODEL flat, c

; ++ ========================================================================
; Name mangling in C++ forces me to declare these tables in the ASM file
; and make them externally available to C++ as extern "C" ...
; -- ========================================================================
PUBLIC FLC_INTRADC
PUBLIC VLC_TCOEF_TBL

TCOEF_ESCAPE_FIELDLEN   EQU     6
TCOEF_ESCAPE_FIELDVAL   EQU     1
TCOEF_EOB_FIELDLEN      EQU     2
TCOEF_EOB_FIELDVAL      EQU     2
TCOEF_RUN_FIELDLEN      EQU     6
TCOEF_LEVEL_FIELDLEN    EQU     8

MAX_TABLE_LEVEL         EQU     12

; ++ ========================================================================
; RLS (Run Level Sign) Structure is defined just to make the code a little
; more readable.
; -- ========================================================================
RLS     STRUCT
        Run     BYTE    ?
        Level   BYTE    ?
        Sign    BYTE    ?
RLS     ENDS

; ++ ========================================================================
; The PutBits macro puts a Variable Length Code into the bit stream.  It
; expects registers to contain the correct information as follows.
;       EDX -- Field Length
;       EAX -- Field Value
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutBits MACRO
        push    esi
        push    ecx
        xor     ecx, ecx
        mov     cl,  BYTE PTR [ebx]     ;; Get the Bit Offset.
        add     edx, ecx                ;;  Add it to the field length.
        mov     ecx, 32                 ;; EAX <<= (32 - (EDX + [EBX]))
        sub     ecx, edx                ;;  EDX = Field Length + Bit Offset.
        mov     esi, DWORD PTR [edi]    ;; Set ESI to Bit Stream.
        shl     eax, cl                 ;;
        bswap   eax                     ;; Swaps byte order in EAX.
        mov     ecx, DWORD PTR [esi]    ;; Preload cache.
        or      DWORD PTR [esi], eax    ;; Write value to bit stream.
        mov     eax, edx
        shr     eax, 3
        add     [edi], eax              ;; Update Bit Stream Pointer.
        and     edx, 000000007h
        mov     BYTE PTR [ebx], dl      ;; Update Bit Stream Offset.
        pop     ecx
        pop     esi
ENDM

; ++ ========================================================================
; PutRunLev macro writes the ESCAPE code and Last bit, then the RUN length,
; and then the LEVEL into the stream.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX, ECX and EAX are trashed.
; -- ========================================================================
PutRunLev MACRO
        LOCAL   NotZero, NoClamp, NotNegative
        mov     eax, TCOEF_ESCAPE_FIELDVAL
        mov     edx, TCOEF_ESCAPE_FIELDLEN
        PutBits                         ;; Write ESCAPE.
        mov     al, (RLS PTR [esi]).Run ;; Retrieve Run Length.
        mov     edx, TCOEF_RUN_FIELDLEN
        PutBits                         ;; Write RUN length.
        mov     al, (RLS PTR [esi]).Level ;; Retrieve Level.
        sub     eax,  1      ; new
NotZero:
        cmp     eax, 127     ; new - was 128
        jb      NoClamp
        mov     eax, 126     ; new - was 127
NoClamp:
        add     eax,  1      ; new
        cmp     (RLS PTR [esi]).Sign, 0FFh
        jne     NotNegative
        mov     ecx, eax
        xor     eax, eax
        sub     eax, ecx
        and     eax, 0000000FFh         
NotNegative:
        mov     edx, TCOEF_LEVEL_FIELDLEN
        PutBits                         ;; Write LEVEL.
ENDM

; ++ ========================================================================
; PutVLC macro writes the Variable Length Code and its sign bit into the
; bit stream.  It expects the registers to be set up as follows.
;       EDX -- VLC Code Length
;       ECX -- First Code Written Flag.
;       EAX -- VLC Bit Code
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; It checks ECX and if Zero (0) then it must check for the special case of
; code length of 3 which indicates the special case code.  The contents of
; EDI and EBX are modified and EDX, ECX, and EAX are trashed.
; -- ========================================================================
PutVLC MACRO
        LOCAL   NotSpecial
        cmp     ecx, 0                  ;; If this is the first code to
        jnz     NotSpecial              ;;  get written and it is the
        cmp     edx, 3                  ;;  the special code for an inter
        jnz     NotSpecial              ;;  block, then we need to change
        and     eax, 000000003h         ;;  the code and its length, before
        dec     edx                     ;;  writing it to the stream.
NotSpecial:
        mov     cl, (RLS PTR [esi]).Sign ;; Get sign bit which is [ 0 | -1 ]
        and     ecx, 000000001h         ;;  Mask off all but the low bit
        or      eax, ecx                ;;  and place it in VLC.
        PutBits                         ;; Write the signed VLC into stream.
ENDM

; ++ ========================================================================
; IndexTable macro determines the pointer value as indexed into the table
; of coefficients.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EAX -- The level which is one (1) based.
;       EDX -- The base pointer to the coefficient array.
; The EDX register is modified, EAX is trashed, and ECX is preserved
; -- ========================================================================
IndexTable MACRO
        push    ecx                     ;; Save first code written flag.
        lea     edx, VLC_TCOEF_TBL      ;; Point to proper table,
        dec     eax                     ;; Zero base the level value.
        shl     eax, 6                  ;; EAX is # of run values per level
        mov     ecx, eax                ;;  added to the run value.
        xor     eax, eax                ;;
        mov     al, (RLS PTR [esi]).Run ;;
        add     eax, ecx                ;;
        shl     eax, 2                  ;; The array has DWORDs (4 bytes)
        add     edx, eax                ;; Add the index to the array.
        pop     ecx                     ;; Restore first code written flag.
ENDM

; ++ ========================================================================
; WriteOneCode macro takes one RLE code from the triplet list and VLC
; encodes it, and writes it to the bit stream.  It expects that the
; following registers will be set as shown.  It checks ECX and if Zero (0)
; then it must check for the special case of Run == 0 and Level == 1.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer.
;       EBX -- Pointer to the Bitstream Offset.
;       ECX -- First Code Written Flag.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX
; are trashed.
; -- ========================================================================
WriteOneCode MACRO
        LOCAL   RunLevel, VLCDone, NotZero
        mov     al, (RLS PTR [esi]).Level ;; Get the level value and check
        test    al, al                    ;; NEW
        jnz     NotZero                 ;; NEW
        mov     al, 127                 ;; NEW
NotZero:                                ;; NEW
        cmp     eax, MAX_TABLE_LEVEL    ;;  it against the max table level.
        jg      RunLevel                ;;
        IndexTable                      ;; Sets EDX to table index
        mov     eax, DWORD PTR [edx]    ;; Get the VLC code from table.
        cmp     eax, 00000FFFFh         ;; Is this an escape indicator?
        je      RunLevel                ;; If so then do RLE processing.
        mov     edx, eax
        and     eax, 00000FFFFh
        shr     edx, 16
        PutVLC                          ;; Write the Variable code.
        jmp     VLCDone
RunLevel:
        PutRunLev                       ;; Write the ESC RUN LEV stuff.
VLCDone:
ENDM

; ++ ========================================================================
; WriteIntraDC macro writes the Intra DC value into the bit stream.  It
; expects the following registers to be set correctly.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, ESI is updated, and EDX and
; EAX are preserved.
; -- ========================================================================
WriteIntraDC MACRO
        push    eax
        push    edx
        lea     edx, FLC_INTRADC        ;; Form index into Intra DC
        mov     al, (RLS PTR [esi]).Level ;;  array.
        add     edx, eax                ;;
        mov     al, BYTE PTR [edx]      ;; Get Intra DC value.
        mov     edx, 8                  ;; Set size of write to 8 bits.
        PutBits                         ;; Write the Intra DC value.
        add     esi, SIZEOF RLS         ;; Point to next triplet.
        pop     edx
        pop     eax
ENDM

; ++ ========================================================================
; WriteEndOfBlock macro writes the end of block code into the stream.  It
; assumes the the registers will be set up as follows.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, and EDX and EAX are trashed.
; -- ========================================================================
WriteEndOfBlock MACRO
        mov     eax, TCOEF_EOB_FIELDVAL
        mov     edx, TCOEF_EOB_FIELDLEN
        PutBits                         ;; Write EOB.
ENDM

; ++ ========================================================================
; WriteOneBlock macro writes all the coefficients for a single block of the
; macroblock.  It assumes that the registers will be set as follows.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
;       EDX -- Coded Block Pattern (CBP)
;       ECX -- Intra/Inter Flag
;       EAX -- CBP Mask.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX are
; preserved.
; -- ========================================================================
WriteOneBlock MACRO
        LOCAL   NotIntra, WriteDone, WriteCodes, WriteExit
        push    eax
        push    edx
        cmp     ecx, 1                  ;; Check to see if this is an 
        jne     NotIntra                ;;  Intra block, and if so,
        WriteIntraDC                    ;;  write the DC value.
        and     eax, edx                ;; Check CBP to see if done.
        jnz     WriteCodes
        WriteEndOfBlock
        jmp     WriteExit
NotIntra:
        and     eax, edx                ;; Check CBP to see if done.
        jnz     WriteCodes
        jmp     WriteExit
WriteCodes:
        mov     al, (RLS PTR [esi]).Run ;; Get the RUN value.
        cmp     eax, 0000000FFh         ;; Check to see if done.
        je      WriteDone               ;; If not, then continue to
        WriteOneCode                    ;;  write the codes in this
        add     esi, SIZEOF RLS         ;;  block until done.
        mov     ecx, 1                  ;; Flag WriteOneCode that not
        jmp     WriteCodes              ;;  first code.
WriteDone:
        WriteEndOfBlock
        add     esi, SIZEOF RLS         ;; Bump to next block.
WriteExit:
        pop     edx
        pop     eax
ENDM

.DATA

FLC_INTRADC             DB      256 DUP (?)
VLC_TCOEF_TBL           DD      (64 * 16) DUP (?)

.CODE

; ++ ========================================================================
; This is the C function call entry point.  This function variable length
; encodes an entire macroblock, one block at a time.
; -- ========================================================================
MBEncodeVLC     PROC PUBLIC USES edi esi ebx ecx, pMBRVS_Luma:DWORD, pMBRVS_Chroma:DWORD, CodedBlockPattern:DWORD, ppBitStream:DWORD, pBitOffset:DWORD, IntraFlag:DWORD, MMxFlag:DWORD

        mov     esi, pMBRVS_Luma
        mov     edi, ppBitStream
        mov     ebx, pBitOffset
        mov     edx, CodedBlockPattern
        mov     esi, [esi]
        mov     eax, 1                  ; CBP Mask.
LumaWriteLoop:
        test    eax, 000000010h         ; When EAX bit shifts to this
        jnz     LumaBlocksDone          ;  position, we are done with Luma.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     LumaWriteLoop
LumaBlocksDone:
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      ChromaWriteLoop
        mov     ecx, pMBRVS_Luma
        mov     [ecx],esi
        mov     ecx, pMBRVS_Chroma
        mov     esi,[ecx]
ChromaWriteLoop:
        test    eax, 000000040h         ; When EAX bit shifts to this
        jnz     ChromaBlocksDone          ;  position, we are done.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     ChromaWriteLoop
ChromaBlocksDone:
        mov     eax, pMBRVS_Chroma
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      MacroBlockDone
        mov     [eax],esi
MacroBlockDone:

        ret

MBEncodeVLC     ENDP
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\excolcnv.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   21 Nov 1996 17:33:56  $
// $Archive:   S:\h26x\src\enc\excolcnv.cpv  $
// $Header:   S:\h26x\src\enc\excolcnv.cpv   1.45   21 Nov 1996 17:33:56   MDUDA  $
// $Log:   S:\h26x\src\enc\excolcnv.cpv  $
// 
//    Rev 1.45   21 Nov 1996 17:33:56   MDUDA
// Added more non-compressed YUV12 support (RGB16 and RGB24).
// Also rewrote IA_YUV12toEncYUV12 to be more readable.
// 
//    Rev 1.44   31 Oct 1996 10:05:48   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.43   22 Oct 1996 16:44:22   MDUDA
// Added IA support for YUY2 input color conversion and cleaned up C version.
// Now using IA version.
// 
//    Rev 1.42   18 Oct 1996 14:31:32   MDUDA
// 
// Added a C-version of YUY2 input color conversion.
// 
//    Rev 1.41   11 Oct 1996 16:04:50   MDUDA
// Using new RGB to YUV lookup tables.
// 
//    Rev 1.40   03 Oct 1996 10:43:58   AGUPTA2
// Got rid of segment directives; made tables read-only.
// 
//    Rev 1.39   13 Sep 1996 13:34:04   MDUDA
// Fixed YVU9 bug where input = output frame size was not colored
// (U and V planes) properly.
// 
//    Rev 1.38   11 Sep 1996 15:45:06   MDUDA
// Modified RGB look-up tables and added C_H26X_YUV12toEncYUV12 and
// IA_H26X_YUV12toEncYUV12.
// 
//    Rev 1.37   03 Sep 1996 14:54:46   MDUDA
// Fixed problem causing VC++ 4.1 internal compiler error. Replaced
// inline assembler constructs such as [ebx.biWidth] with
// (LPBITMAPINFOHEADER)[ebx].biWidth.
// 
//    Rev 1.36   29 Aug 1996 16:31:14   MDUDA
// Added Pentium assembler versions for all RGB conversion routines.
// Also, rewrote YVU9 support to allow input frame sizes other
// than 160x120 and 240x180.
// 
//    Rev 1.35   16 Aug 1996 12:17:48   MDUDA
// Fixed bug where U and V values in the BGR converters were treated as unsign
// values. Also did some general cleanup of BGR converters in preparation for
// doing Pentium assembler version.
// 
//    Rev 1.34   13 Aug 1996 10:35:38   MDUDA
// Added support for RGB4. Generalized RGB LUT support for 4-bit and
// and 8-bit pixels into a single routine.
// 
//    Rev 1.33   09 Aug 1996 09:45:02   MDUDA
// Added support for RGB16 format on input. This is for the color
// Quick Cam. Also, generalized RGB16 for other bit combinations.
// However, these can only be specified under BI_BITFIELDS format.
// 
//    Rev 1.32   02 Aug 1996 13:44:48   MDUDA
// modified H26X_BGR24toYUV12 to crop and stretch 240x180 and 160x120
// frames
// 
//    Rev 1.31   01 Aug 1996 14:03:50   MDUDA
// 
// Optimized H26X_YVU9toYUV12 by rewriting function in assembler code. Used in
// _asm. Also re-arranged functions so that colorCnvtFrame is at the end of
// the file.
// 
//    Rev 1.30   22 Jul 1996 13:28:22   BECHOLS
// Added a CLUT8 to YUV12 color convertor (CC). This CC crops and stretches
// either the 240x180 or the 160x120 image size to produce QCIF and SubQCIF
// image sizes respectively.
// 
//    Rev 1.29   11 Jul 1996 15:47:02   MDUDA
// 
// Modified H263_YVU9toYUV12 to create subQCIF and QCIF from
// 160x120 and 240x180 images, respectively. To fit the new
// formats, the original images are cropped and stretched using a
// dither pattern for the color planes.
// 
//    Rev 1.28   14 May 1996 12:04:08   KLILLEVO
// changed RGB->YUV color conversion to use the inverse
// if the output YUV->RGB conversion instead of the conversion
// "recommended by the CCIR". Compression performance for RGB
// input was significantly improved (33% less bits for same
// fixed QP)
// 
//    Rev 1.27   04 May 1996 21:55:20   BECHOLS
// For RGB24 to YVU12 conversion, I unrolled the inner loop by 8 and changed
// the writes to DWORD vs. BYTE writes.  This resulted in a 30% reduction in
// the execution time.
// 
//    Rev 1.26   10 Apr 1996 16:44:14   RHAZRA
// Fixed a bug in 320x240 mode for the H26X_YUV12toEncYUV12() function.
// DWORD should be and-ed with 0x7f7f7f7f and not 0x7f7f7f.
// 
//    Rev 1.25   27 Mar 1996 15:10:08   SCDAY
// Optimized H26X_YUV12toEncYUV12 'C' code to read/write DWORDs
// 
//    Rev 1.24   08 Jan 1996 17:46:14   unknown
// 
// Correct logic on bIs320x240 check
// 
//    Rev 1.23   05 Jan 1996 17:34:38   RMCKENZX
// corrected chroma pad value to 0x40 to achieve black padding
// 
//    Rev 1.22   05 Jan 1996 17:29:46   RMCKENZX
// Added code to pad out 320x240 stills to 352x288 
// full CIF images.
// 
//    Rev 1.21   04 Jan 1996 18:37:20   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.20   02 Jan 1996 17:09:04   TRGARDOS
// Moved colorCnvFrame into this file and made the
// color convertor functions static.
// 
//    Rev 1.19   27 Dec 1995 15:32:56   RMCKENZX
// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:35:42   TRGARDOS
// Added Brian's fix to the input color convertor to avoid
// overflow of the chars.
// 
//    Rev 1.17   27 Nov 1995 16:09:04   TRGARDOS
// Removed two unused variables to get rid of compiler warnings.
// 
//    Rev 1.16   30 Oct 1995 14:34:12   TRGARDOS
// Fixed 240x180 to center clip.
// 
//    Rev 1.15   30 Oct 1995 12:03:16   TRGARDOS
// Added color convertor support for YUV9 240x180.
// 
//    Rev 1.14   28 Oct 1995 15:39:28   TRGARDOS
// Fixed color conversion problem from YVU9 to YVU12.
// 
//    Rev 1.13   12 Oct 1995 17:40:12   TRGARDOS
// Fixed YUV12 input color convertor.
// 
//    Rev 1.12   12 Oct 1995 12:04:16   TRGARDOS
// Changed some variable names in YUV12 convertor.
// 
//    Rev 1.11   10 Oct 1995 16:34:12   TRGARDOS
// Added YUV12 input support.
// 
//    Rev 1.10   28 Sep 1995 17:02:36   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.9   15 Sep 1995 16:37:38   TRGARDOS
// 
// 
//    Rev 1.8   13 Sep 1995 17:09:22   TRGARDOS
// 
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.7   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.6   07 Sep 1995 09:27:54   TRGARDOS
// Added YVU9 to YVU12 color convertor.
// 
//    Rev 1.5   05 Sep 1995 15:50:46   TRGARDOS
// Added color back in to convertors.
// 
//    Rev 1.4   01 Sep 1995 17:51:42   TRGARDOS
// Fixed bugs in color converter.
// 
//    Rev 1.3   01 Sep 1995 10:13:42   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.2   30 Aug 1995 12:42:26   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.1   02 Aug 1995 17:28:06   TRGARDOS
// 
// Cleaned up stuff to get stub working under new
// version control system.
// 
//    Rev 1.0   31 Jul 1995 13:07:10   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:16   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if defined(_CODEC_STATS)

static const double RDTSC_SHIFT_32 = 4294967296.0;

static double PENTIUM_TIMER()
{
	unsigned long int a, b;
	double temp1, temp2, result;

	__asm
	{
		_emit   0x0f
		_emit   0x31
		mov     a, eax
		mov     b, edx
	}

	temp1 = (double) a;
	temp2 = (double) (b & 0xFFFF);
	if (RDTSC_CLOCK_FREQ) {
		result = (temp1 + temp2 * RDTSC_SHIFT_32) / RDTSC_CLOCK_FREQ;
	} else {
		result = 0.0;
	}
	return( result * 1000.0 );
}

#endif

// Set all local functions to "static", and then set it accordingly if
// VTune statistics are to be collected. VTune doesn't recognize static functions
// so we need some way to turn off the static attribute if VTune is to be run
// on the executable. For now, simply use a define of _VTUNE to build the driver.
#if defined(_VTUNE)
#define _STATIC
#else
#define _STATIC static
#endif

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

// This is the code that was used to generate the tables.
#if 0
#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

#include <stdio.h>

void main() {
int i,j;

  printf("struct YUV {\n");
  printf("  int YU;\n");
  printf("  int V;\n");
  printf("};\n\n");

  printf("struct YUV  RYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YRCoef*((i*4)+j+1))>>9) |
         ((-(((URCoef*((i*4)+j+1)))>>9))<<16),
        ((VRCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  GYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YGCoef*((i*4)+j+1))>>9) |
         ((-(((UGCoef*((i*4)+j+1)))>>9))<<16),
         -((VGCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  BYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YBCoef*((i*4)+j+1))>>9) |
         (((UBCoef*((i*4)+j+1))>>9)<<16),
        -((VBCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");
}
#endif
 
struct YUV {
  int YU;
  int V;
};

const struct YUV  RYUV[] = {
{0xffee0020, 0x00000038}, {0xffc80062, 0x000000a8}, 
{0xffa200a4, 0x00000119}, {0xff7c00e6, 0x00000189}, 
{0xff560127, 0x000001f9}, {0xff300169, 0x0000026a}, 
{0xff0a01ab, 0x000002da}, {0xfee401ed, 0x0000034b}, 
{0xfebe022f, 0x000003bb}, {0xfe980270, 0x0000042b}, 
{0xfe7202b2, 0x0000049c}, {0xfe4c02f4, 0x0000050c}, 
{0xfe260336, 0x0000057d}, {0xfe000377, 0x000005ed}, 
{0xfdda03b9, 0x0000065d}, {0xfdb403fb, 0x000006ce}, 
{0xfd8e043d, 0x0000073e}, {0xfd68047e, 0x000007af}, 
{0xfd4204c0, 0x0000081f}, {0xfd1c0502, 0x0000088f}, 
{0xfcf60544, 0x00000900}, {0xfcd00585, 0x00000970}, 
{0xfcaa05c7, 0x000009e1}, {0xfc840609, 0x00000a51}, 
{0xfc5e064b, 0x00000ac2}, {0xfc38068d, 0x00000b32}, 
{0xfc1206ce, 0x00000ba2}, {0xfbec0710, 0x00000c13}, 
{0xfbc60752, 0x00000c83}, {0xfba00794, 0x00000cf4}, 
{0xfb7a07d5, 0x00000d64}, {0xfb540817, 0x00000dd4}, 
{0xfb2e0859, 0x00000e45}, {0xfb08089b, 0x00000eb5}, 
{0xfae208dc, 0x00000f26}, {0xfabc091e, 0x00000f96}, 
{0xfa960960, 0x00001006}, {0xfa7009a2, 0x00001077}, 
{0xfa4a09e3, 0x000010e7}, {0xfa240a25, 0x00001158}, 
{0xf9fe0a67, 0x000011c8}, {0xf9d80aa9, 0x00001239}, 
{0xf9b20aeb, 0x000012a9}, {0xf98c0b2c, 0x00001319}, 
{0xf9660b6e, 0x0000138a}, {0xf9400bb0, 0x000013fa}, 
{0xf91a0bf2, 0x0000146b}, {0xf8f40c33, 0x000014db}, 
{0xf8ce0c75, 0x0000154b}, {0xf8a80cb7, 0x000015bc}, 
{0xf8820cf9, 0x0000162c}, {0xf85c0d3a, 0x0000169d}, 
{0xf8360d7c, 0x0000170d}, {0xf8100dbe, 0x0000177d}, 
{0xf7ea0e00, 0x000017ee}, {0xf7c40e41, 0x0000185e}, 
{0xf79e0e83, 0x000018cf}, {0xf7780ec5, 0x0000193f}, 
{0xf7520f07, 0x000019af}, {0xf72c0f49, 0x00001a20}, 
{0xf7060f8a, 0x00001a90}, {0xf6e00fcc, 0x00001b01}, 
{0xf6ba100e, 0x00001b71}, {0xf6941050, 0x00001be2}, 
{0xf66e1091, 0x00001c52}, {0xf64810d3, 0x00001cc2}, 
{0xf6221115, 0x00001d33}, {0xf5fc1157, 0x00001da3}, 
{0xf5d61198, 0x00001e14}, {0xf5b011da, 0x00001e84}, 
{0xf58a121c, 0x00001ef4}, {0xf564125e, 0x00001f65}, 
{0xf53e12a0, 0x00001fd5}, {0xf51812e1, 0x00002046}, 
{0xf4f21323, 0x000020b6}, {0xf4cc1365, 0x00002126}, 
{0xf4a613a7, 0x00002197}, {0xf48013e8, 0x00002207}, 
{0xf45a142a, 0x00002278}, {0xf434146c, 0x000022e8}, 
{0xf40e14ae, 0x00002359}, {0xf3e814ef, 0x000023c9}, 
{0xf3c21531, 0x00002439}, {0xf39c1573, 0x000024aa}, 
{0xf37615b5, 0x0000251a}, {0xf35015f6, 0x0000258b}, 
{0xf32a1638, 0x000025fb}, {0xf304167a, 0x0000266b}, 
{0xf2de16bc, 0x000026dc}, {0xf2b816fe, 0x0000274c}, 
{0xf292173f, 0x000027bd}, {0xf26c1781, 0x0000282d}, 
{0xf24617c3, 0x0000289d}, {0xf2201805, 0x0000290e}, 
{0xf1fa1846, 0x0000297e}, {0xf1d41888, 0x000029ef}, 
{0xf1ae18ca, 0x00002a5f}, {0xf188190c, 0x00002acf}, 
{0xf162194d, 0x00002b40}, {0xf13c198f, 0x00002bb0}, 
{0xf11619d1, 0x00002c21}, {0xf0f01a13, 0x00002c91}, 
{0xf0ca1a54, 0x00002d02}, {0xf0a41a96, 0x00002d72}, 
{0xf07e1ad8, 0x00002de2}, {0xf0581b1a, 0x00002e53}, 
{0xf0321b5c, 0x00002ec3}, {0xf00c1b9d, 0x00002f34}, 
{0xefe61bdf, 0x00002fa4}, {0xefc01c21, 0x00003014}, 
{0xef9a1c63, 0x00003085}, {0xef741ca4, 0x000030f5}, 
{0xef4e1ce6, 0x00003166}, {0xef281d28, 0x000031d6}, 
{0xef021d6a, 0x00003246}, {0xeedc1dab, 0x000032b7}, 
{0xeeb61ded, 0x00003327}, {0xee901e2f, 0x00003398}, 
{0xee6a1e71, 0x00003408}, {0xee441eb2, 0x00003479}, 
{0xee1e1ef4, 0x000034e9}, {0xedf81f36, 0x00003559}, 
{0xedd21f78, 0x000035ca}, {0xedac1fba, 0x0000363a}, 
{0xed861ffb, 0x000036ab}, {0xed60203d, 0x0000371b}, 
{0xed3a207f, 0x0000378b}, {0xed1420c1, 0x000037fc}, 
};
const struct YUV  GYUV[] = {
{0xffdb0040, 0xffffffd1}, {0xff9100c1, 0xffffff73}, 
{0xff460142, 0xffffff15}, {0xfefc01c3, 0xfffffeb7}, 
{0xfeb10245, 0xfffffe59}, {0xfe6702c6, 0xfffffdfa}, 
{0xfe1c0347, 0xfffffd9c}, {0xfdd203c8, 0xfffffd3e}, 
{0xfd880449, 0xfffffce0}, {0xfd3d04ca, 0xfffffc82}, 
{0xfcf3054b, 0xfffffc23}, {0xfca805cc, 0xfffffbc5}, 
{0xfc5e064e, 0xfffffb67}, {0xfc1306cf, 0xfffffb09}, 
{0xfbc90750, 0xfffffaaa}, {0xfb7e07d1, 0xfffffa4c}, 
{0xfb340852, 0xfffff9ee}, {0xfae908d3, 0xfffff990}, 
{0xfa9f0954, 0xfffff932}, {0xfa5409d5, 0xfffff8d3}, 
{0xfa0a0a57, 0xfffff875}, {0xf9bf0ad8, 0xfffff817}, 
{0xf9750b59, 0xfffff7b9}, {0xf92a0bda, 0xfffff75b}, 
{0xf8e00c5b, 0xfffff6fc}, {0xf8960cdc, 0xfffff69e}, 
{0xf84b0d5d, 0xfffff640}, {0xf8010dde, 0xfffff5e2}, 
{0xf7b60e60, 0xfffff584}, {0xf76c0ee1, 0xfffff525}, 
{0xf7210f62, 0xfffff4c7}, {0xf6d70fe3, 0xfffff469}, 
{0xf68c1064, 0xfffff40b}, {0xf64210e5, 0xfffff3ad}, 
{0xf5f71166, 0xfffff34e}, {0xf5ad11e7, 0xfffff2f0}, 
{0xf5621269, 0xfffff292}, {0xf51812ea, 0xfffff234}, 
{0xf4cd136b, 0xfffff1d6}, {0xf48313ec, 0xfffff177}, 
{0xf439146d, 0xfffff119}, {0xf3ee14ee, 0xfffff0bb}, 
{0xf3a4156f, 0xfffff05d}, {0xf35915f0, 0xffffeffe}, 
{0xf30f1672, 0xffffefa0}, {0xf2c416f3, 0xffffef42}, 
{0xf27a1774, 0xffffeee4}, {0xf22f17f5, 0xffffee86}, 
{0xf1e51876, 0xffffee27}, {0xf19a18f7, 0xffffedc9}, 
{0xf1501978, 0xffffed6b}, {0xf10519f9, 0xffffed0d}, 
{0xf0bb1a7b, 0xffffecaf}, {0xf0701afc, 0xffffec50}, 
{0xf0261b7d, 0xffffebf2}, {0xefdb1bfe, 0xffffeb94}, 
{0xef911c7f, 0xffffeb36}, {0xef471d00, 0xffffead8}, 
{0xeefc1d81, 0xffffea79}, {0xeeb21e02, 0xffffea1b}, 
{0xee671e84, 0xffffe9bd}, {0xee1d1f05, 0xffffe95f}, 
{0xedd21f86, 0xffffe901}, {0xed882007, 0xffffe8a2}, 
{0xed3d2088, 0xffffe844}, {0xecf32109, 0xffffe7e6}, 
{0xeca8218a, 0xffffe788}, {0xec5e220b, 0xffffe72a}, 
{0xec13228d, 0xffffe6cb}, {0xebc9230e, 0xffffe66d}, 
{0xeb7e238f, 0xffffe60f}, {0xeb342410, 0xffffe5b1}, 
{0xeaea2491, 0xffffe552}, {0xea9f2512, 0xffffe4f4}, 
{0xea552593, 0xffffe496}, {0xea0a2614, 0xffffe438}, 
{0xe9c02696, 0xffffe3da}, {0xe9752717, 0xffffe37b}, 
{0xe92b2798, 0xffffe31d}, {0xe8e02819, 0xffffe2bf}, 
{0xe896289a, 0xffffe261}, {0xe84b291b, 0xffffe203}, 
{0xe801299c, 0xffffe1a4}, {0xe7b62a1d, 0xffffe146}, 
{0xe76c2a9f, 0xffffe0e8}, {0xe7212b20, 0xffffe08a}, 
{0xe6d72ba1, 0xffffe02c}, {0xe68c2c22, 0xffffdfcd}, 
{0xe6422ca3, 0xffffdf6f}, {0xe5f82d24, 0xffffdf11}, 
{0xe5ad2da5, 0xffffdeb3}, {0xe5632e26, 0xffffde55}, 
{0xe5182ea8, 0xffffddf6}, {0xe4ce2f29, 0xffffdd98}, 
{0xe4832faa, 0xffffdd3a}, {0xe439302b, 0xffffdcdc}, 
{0xe3ee30ac, 0xffffdc7e}, {0xe3a4312d, 0xffffdc1f}, 
{0xe35931ae, 0xffffdbc1}, {0xe30f322f, 0xffffdb63}, 
{0xe2c432b1, 0xffffdb05}, {0xe27a3332, 0xffffdaa6}, 
{0xe22f33b3, 0xffffda48}, {0xe1e53434, 0xffffd9ea}, 
{0xe19b34b5, 0xffffd98c}, {0xe1503536, 0xffffd92e}, 
{0xe10635b7, 0xffffd8cf}, {0xe0bb3638, 0xffffd871}, 
{0xe07136ba, 0xffffd813}, {0xe026373b, 0xffffd7b5}, 
{0xdfdc37bc, 0xffffd757}, {0xdf91383d, 0xffffd6f8}, 
{0xdf4738be, 0xffffd69a}, {0xdefc393f, 0xffffd63c}, 
{0xdeb239c0, 0xffffd5de}, {0xde673a41, 0xffffd580}, 
{0xde1d3ac3, 0xffffd521}, {0xddd23b44, 0xffffd4c3}, 
{0xdd883bc5, 0xffffd465}, {0xdd3d3c46, 0xffffd407}, 
{0xdcf33cc7, 0xffffd3a9}, {0xdca93d48, 0xffffd34a}, 
{0xdc5e3dc9, 0xffffd2ec}, {0xdc143e4a, 0xffffd28e}, 
{0xdbc93ecc, 0xffffd230}, {0xdb7f3f4d, 0xffffd1d2}, 
{0xdb343fce, 0xffffd173}, {0xdaea404f, 0xffffd115}, 
};
const struct YUV  BYUV[] = {
{0x0038000c, 0xfffffff7}, {0x00a80025, 0xffffffe5}, 
{0x0119003e, 0xffffffd3}, {0x01890057, 0xffffffc1}, 
{0x01fa0070, 0xffffffaf}, {0x026a0089, 0xffffff9c}, 
{0x02da00a2, 0xffffff8a}, {0x034b00bb, 0xffffff78}, 
{0x03bb00d5, 0xffffff66}, {0x042c00ee, 0xffffff54}, 
{0x049c0107, 0xffffff41}, {0x050d0120, 0xffffff2f}, 
{0x057d0139, 0xffffff1d}, {0x05ee0152, 0xffffff0b}, 
{0x065e016b, 0xfffffef9}, {0x06cf0184, 0xfffffee6}, 
{0x073f019d, 0xfffffed4}, {0x07b001b6, 0xfffffec2}, 
{0x082001cf, 0xfffffeb0}, {0x089001e8, 0xfffffe9e}, 
{0x09010201, 0xfffffe8b}, {0x0971021a, 0xfffffe79}, 
{0x09e20233, 0xfffffe67}, {0x0a52024c, 0xfffffe55}, 
{0x0ac30266, 0xfffffe43}, {0x0b33027f, 0xfffffe30}, 
{0x0ba40298, 0xfffffe1e}, {0x0c1402b1, 0xfffffe0c}, 
{0x0c8502ca, 0xfffffdfa}, {0x0cf502e3, 0xfffffde8}, 
{0x0d6602fc, 0xfffffdd5}, {0x0dd60315, 0xfffffdc3}, 
{0x0e46032e, 0xfffffdb1}, {0x0eb70347, 0xfffffd9f}, 
{0x0f270360, 0xfffffd8c}, {0x0f980379, 0xfffffd7a}, 
{0x10080392, 0xfffffd68}, {0x107903ab, 0xfffffd56}, 
{0x10e903c4, 0xfffffd44}, {0x115a03dd, 0xfffffd31}, 
{0x11ca03f7, 0xfffffd1f}, {0x123b0410, 0xfffffd0d}, 
{0x12ab0429, 0xfffffcfb}, {0x131c0442, 0xfffffce9}, 
{0x138c045b, 0xfffffcd6}, {0x13fc0474, 0xfffffcc4}, 
{0x146d048d, 0xfffffcb2}, {0x14dd04a6, 0xfffffca0}, 
{0x154e04bf, 0xfffffc8e}, {0x15be04d8, 0xfffffc7b}, 
{0x162f04f1, 0xfffffc69}, {0x169f050a, 0xfffffc57}, 
{0x17100523, 0xfffffc45}, {0x1780053c, 0xfffffc33}, 
{0x17f10555, 0xfffffc20}, {0x1861056e, 0xfffffc0e}, 
{0x18d20588, 0xfffffbfc}, {0x194205a1, 0xfffffbea}, 
{0x19b205ba, 0xfffffbd8}, {0x1a2305d3, 0xfffffbc5}, 
{0x1a9305ec, 0xfffffbb3}, {0x1b040605, 0xfffffba1}, 
{0x1b74061e, 0xfffffb8f}, {0x1be50637, 0xfffffb7d}, 
{0x1c550650, 0xfffffb6a}, {0x1cc60669, 0xfffffb58}, 
{0x1d360682, 0xfffffb46}, {0x1da7069b, 0xfffffb34}, 
{0x1e1706b4, 0xfffffb22}, {0x1e8806cd, 0xfffffb0f}, 
{0x1ef806e6, 0xfffffafd}, {0x1f6806ff, 0xfffffaeb}, 
{0x1fd90719, 0xfffffad9}, {0x20490732, 0xfffffac7}, 
{0x20ba074b, 0xfffffab4}, {0x212a0764, 0xfffffaa2}, 
{0x219b077d, 0xfffffa90}, {0x220b0796, 0xfffffa7e}, 
{0x227c07af, 0xfffffa6c}, {0x22ec07c8, 0xfffffa59}, 
{0x235d07e1, 0xfffffa47}, {0x23cd07fa, 0xfffffa35}, 
{0x243e0813, 0xfffffa23}, {0x24ae082c, 0xfffffa11}, 
{0x251e0845, 0xfffff9fe}, {0x258f085e, 0xfffff9ec}, 
{0x25ff0877, 0xfffff9da}, {0x26700890, 0xfffff9c8}, 
{0x26e008aa, 0xfffff9b6}, {0x275108c3, 0xfffff9a3}, 
{0x27c108dc, 0xfffff991}, {0x283208f5, 0xfffff97f}, 
{0x28a2090e, 0xfffff96d}, {0x29130927, 0xfffff95b}, 
{0x29830940, 0xfffff948}, {0x29f40959, 0xfffff936}, 
{0x2a640972, 0xfffff924}, {0x2ad4098b, 0xfffff912}, 
{0x2b4509a4, 0xfffff8ff}, {0x2bb509bd, 0xfffff8ed}, 
{0x2c2609d6, 0xfffff8db}, {0x2c9609ef, 0xfffff8c9}, 
{0x2d070a08, 0xfffff8b7}, {0x2d770a21, 0xfffff8a4}, 
{0x2de80a3b, 0xfffff892}, {0x2e580a54, 0xfffff880}, 
{0x2ec90a6d, 0xfffff86e}, {0x2f390a86, 0xfffff85c}, 
{0x2faa0a9f, 0xfffff849}, {0x301a0ab8, 0xfffff837}, 
{0x308a0ad1, 0xfffff825}, {0x30fb0aea, 0xfffff813}, 
{0x316b0b03, 0xfffff801}, {0x31dc0b1c, 0xfffff7ee}, 
{0x324c0b35, 0xfffff7dc}, {0x32bd0b4e, 0xfffff7ca}, 
{0x332d0b67, 0xfffff7b8}, {0x339e0b80, 0xfffff7a6}, 
{0x340e0b99, 0xfffff793}, {0x347f0bb2, 0xfffff781}, 
{0x34ef0bcc, 0xfffff76f}, {0x35600be5, 0xfffff75d}, 
{0x35d00bfe, 0xfffff74b}, {0x36400c17, 0xfffff738}, 
{0x36b10c30, 0xfffff726}, {0x37210c49, 0xfffff714}, 
{0x37920c62, 0xfffff702}, {0x38020c7b, 0xfffff6f0}, 
};

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = FrameWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif

//
// For the IA versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0
_STATIC void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// width_adj += width_adj << 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	mov		eax, esi
	shr		eax, 1
	add		esi, eax
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -(lpbiInput->biWidth + FrameWidth)
// iBackTwoLines += (iBackTwoLines << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	neg		ebp
	mov		eax, ebp
	shl		eax, 1
	add		ebp, eax
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	add		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		and 	ebx, 0xFE
	add	eax,  0x800
// 10
	sar 	eax, 8
	nop
// 11
		shr 	ebx, 1
		nop
// 12
		shr 	ecx, 9
	mov	 [edi + 1], al
// 13
		shr		edx, 17
		and		ecx, 0x7F
// 14
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 15
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 16
		add		eax, [RYUV+edx*8].YU
		nop
// 17
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 18
		add		eax, 8
		and		ebx, 1
// 19
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 20
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 21
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 22
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 23
	mov		[edx], al
	inc		edx
// 24
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 25
	sar 	ebx, 8
	inc		edx
// 26
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 27
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 28
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 29
	mov 	eax, ebx
	mov 	ecx, ebx
// 30
	shr		eax, 9
	mov		edx, ebx
// 31
	shr 	ecx, 17
	and 	eax, 0x7F
// 32
	shr 	edx, 25
	and		ecx, 0x7F
// 33
	mov 	eax, [BYUV+eax*8].YU
	nop
// 34
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 35
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 36
		shr		ebx, 1
	add	eax,  0x800
// 37
	sar 	eax, 8
		mov		edx, ebp
// 38
		shr		edx, 17
	mov	 [edi + 3], al
// 39
		shr 	ecx, 25
		and		edx, 0x7F
// 40
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 41
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 42
		add		eax, [BYUV+edx*8].YU
		nop
// 43
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 44
		add		eax, 8
		and		ebx, 1
// 45
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 46
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 47
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 48
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 49
	mov		[edx], al
	inc		edx
// 50
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 51
	sar 	ebx, 8
	inc		edx
// 52
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 53
	mov		[edx - 1], bl
	nop
L16:
// 54
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 55
	sub		eax, 4
	lea		edi, [edi + 4]
// 56
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

#if 0
_STATIC void C_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	UN  bitfield,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				switch (bitfield) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					case 555:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>24)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>8)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#if 0
// Beware - untested code ahead				
					//    664              3, 3, 9         0x78, 0x7E, 0x7E
					case 664:
						t = (BYUV[(tm>>13)&0x78].YU +
						     GYUV[(tm>>19)&0x7E].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<3)&0x78].YU +
						     GYUV[(tm>>3)&0x7E].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    565              2, 4, 9         0x7C, 0x7E, 0x7C
					case 565:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>20)&0x7E].YU +
						     RYUV[(tm>>25)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>4)&0x7E].YU +
						     RYUV[(tm>>9)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    655              2, 3, 9         0x7C, 0x7C, 0x7E
					case 655:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#endif
				}
				if (0 == (k&1)) {
					switch (bitfield) {
						//    555              2, 3, 8         0x7C, 0x7C, 0x7C
						case 555:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>8)&0x7C].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#if 0
// Beware - untested code ahead				
						//    664              3, 3, 9         0x78, 0x7E, 0x7E
						case 664:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7E].V +
							     BYUV[(tm<<3)&0x78].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    565              2, 4, 9         0x7C, 0x7E, 0x7C
						case 565:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7C].V +
							     GYUV[(tm>>4)&0x7E].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    655              2, 3, 9         0x7C, 0x7C, 0x7E
						case 655:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#endif
					}
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR16toYUV12
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = pnext[0]
// t = ( BYUV[(tm>>14)&0x7C].YU +
//       GYUV[(tm>>19)&0x7C].YU +
//       RYUV[(tm>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t = ( BYUV[(tm<< 2)&0x7C].YU +
//       GYUV[(tm>> 8)&0x7C].YU +
//       RYUV[(tm>>13)&0x7C].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	eax, [esi]
	nop
// 2
	mov 	ebx, eax
	mov 	ecx, eax
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		nop
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop
L9:
// 27
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 4]
// 28
	sub		eax, 2
	lea		edi, [edi + 2]
// 29
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*****************************************************************************
 *
 *  H26X_CLUTtoYUV12()
 * 	
 *  Convert from CLUT8/CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0
_STATIC void C_H26X_CLUTtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
    U8 * lpInput,
    U8 * YPlane,
    U8 * UPlane,
    U8 * VPlane,
    UN  FrameWidth,
    UN  FrameHeight,
	UN	pixel_bits,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm, tn;
	int t;
	int i, j, k, m, n;
	int iNextLine, iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int yshift, uvshift;
	int pixel_mask, loop_cnt, loop_limit;
	RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
	int LumaIters = 0;
	int ypitch_adj = (pitch - FrameWidth);
	int uvpitch_adj = (pitch - (FrameWidth >> 1));

	ASSERT((8 == pixel_bits) || (4 == pixel_bits));
	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = ((lpbiInput->biHeight - (FrameHeight - aspect)) >> 1);
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = lpbiInput->biWidth;
	iBackTwoLines = -((iNextLine + (int)FrameWidth) >> 2);
	if (8 == pixel_bits) {
		yshift = 8;
		uvshift = 16;
		pixel_mask = 0xFF;
		loop_cnt = 2;
		loop_limit = 4;
	} else {
		yshift = 4;
		uvshift = 8;
		pixel_mask = 0xF;
		loop_cnt = 1;
		loop_limit = 8;
		width_adj >>= 1;
		iNextLine >>= 1;
		iBackTwoLines >>= 1;
	}

	// The input image is upside down - process the lines in reverse order.

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					(iNextLine * ((FrameHeight - aspect - 1) + height_adj)) + width_adj);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 8) {

				for (n = 0; n < loop_cnt; n++) {
					tm = *pnext++;
					tm = ((4 == pixel_bits) ?
						( ((tm >> 4) & 0x0F0F0F0F) | ((tm << 4) & 0xF0F0F0F0) ) : tm);
					tn = tm;
					for (m = 0; m < loop_limit; m += 4) {
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
					}
					if (0 == (k&1)) {
						for (m = 0; m < loop_limit; m += 2, tn >>= uvshift) {
							lpCEntry = &lpCTable[tn&pixel_mask];
							t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
								  RYUV[lpCEntry->rgbRed>>1].YU +
								  GYUV[lpCEntry->rgbGreen>>1].YU );
							*UPlane++ = (U8)((t>>24)+64);
							t = ( RYUV[lpCEntry->rgbRed>>1].V +
								  GYUV[lpCEntry->rgbGreen>>1].V +
								  BYUV[lpCEntry->rgbBlue>>1].V );
							*VPlane++ = (U8)((t>>8)+64);
						}
					}
				}
			}

			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}

			pnext += iBackTwoLines;

			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}

		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUTtoYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 1
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
// iBackTwoLines = -(iNextline + FrameWidth)
	mov		edi, [esp + FRAME_WIDTH]
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput +
//            (iNextLine*((FrameHeight-aspect-1) + height_adj)) +
//            width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 2)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*(pnext+1)]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[*pnext]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>>24)+64)
// t = (  VBGR[lpCEntry->rgbRed>>1].V +
//        VBGR[lpCEntry->rgbGreen>>1].V +
//        VBGR[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	xor		eax, eax
	mov		ebp, [esp + LPCTABLE]
// 2
	mov		al, [esi + 1]
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
		xor		ebx, ebx
// 9
	add		eax, [RYUV+edx*4].YU
		mov		bl, [esi]
// 10
	sar		eax, 8
		lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
		mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
		mov		cl, (LPRGBQUAD)[ebp].rgbGreen
		and		bl, 0xFE
// 14
		mov		dl, (LPRGBQUAD)[ebp].rgbRed
		and		cl, 0xFE
// 15
		mov		eax, [BYUV+ebx*4].YU
		and		dl, 0xFE
// 16
		add		eax, [GYUV+ecx*4].YU
		mov		ebp, ebx
// 17
		add		eax, [RYUV+edx*4].YU
		nop
// 18
		sar		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
		add		eax, 8
	and		ebx, 1
// 20
		mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 29
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 2]
// 30
	sub		eax, 2
	lea		edi, [edi + 2]
// 31
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

__declspec(naked)
_STATIC void IA_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 2
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 2
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth >> 1
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
	shr		ebx, 1
// iBackTwoLines = -(iNextline + (FrameWidth >> 1))
	mov		edi, [esp + FRAME_WIDTH]
	shr		edi, 1
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput+(iNextLine*((FrameHeight-aspect-1)+height_adj))+ width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext++)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*pnext&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[(*pnext>>4)&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>24)+64)
// t = ( RYUV[lpCEntry->rgbRed>>1].V +
//       GYUV[lpCEntry->rgbGreen>>1].V +
//       BYUV[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	mov		al, [esi]
	mov		ebp, [esp + LPCTABLE]
// 2
	and		eax, 0xF
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
	mov		bl, [esi]
// 9
	add		eax, [RYUV+edx*4].YU
	and		ebx, 0xF0
//
	shr		ebx, 4
	nop
// 10
	shr		eax, 8
	lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
	mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
	mov		cl, (LPRGBQUAD)[ebp].rgbGreen
	and		bl, 0xFE
// 14
	mov		dl, (LPRGBQUAD)[ebp].rgbRed
	and		cl, 0xFE
// 15
	mov		eax, [BYUV+ebx*4].YU
	and		dl, 0xFE
// 16
	add		eax, [GYUV+ecx*4].YU
	mov		ebp, ebx
// 17
	add		eax, [RYUV+edx*4].YU
	nop
// 18
	shr		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
	add		eax, 8
	and		ebx, 1
// 20
	mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 32
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 1]
// 33
	sub		eax, 2
	lea		edi, [edi + 2]
// 34
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill(esi, pnext)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		edi, [esp + PYSPACE]
	 mov	ebp, [esp + FRAME_WIDTH]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#if 0
#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define READ_QWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned __int64 *)(src))), ((val) &= 0xFEFEFEFEFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define WRITE_QWORD(dest,val) ((*(unsigned __int64 *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))


_STATIC void C_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj) {

U8* pnext = psrc + (OutputFrameWidth>>1) + spitch_adj;
U8* pdest_copy = Plane;
U8* pdest_avg = Plane + pitch;
int dpitch_adj = pitch - OutputFrameWidth;
int stretch = (spitch_adj ? 1 : 0);
int mark = 6 - stretch;
int flag = stretch;
int i, j, k;
UN t1,t2;

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_copy += 8,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (stretch) {
			psrc -= ((OutputFrameWidth>>1) + spitch_adj);
			pnext -= ((OutputFrameWidth>>1) + spitch_adj);
			pdest_avg = pdest_copy;
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

_STATIC void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn;
U8  *pvsrc, *pusrc;
int width_adj, height_adj;
int stretch, mark, aspect;
int iNextLine;
int i, j, k, t;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);

	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = width_adj << 1;
	pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj;
	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4) {
				*(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
			}
			pnext += iNextLine;
			YPlane += ypitch_adj;
		}
		if (stretch) {
			plast = pnext - lpbiInput->biWidth;
			pbn = pnext;
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, plast += 4, pbn += 4) {
				*(U32 *)YPlane =
					( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
				        ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
	C_uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
}
#endif

__declspec(naked)
_STATIC void IA_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | spitch_adj      |  + 64
//    | ChromaIters     |  + 60
//    | OutputFrameWidth|  + 56
//    | pitch           |  + 52
//    | Plane           |  + 48
//    | psrc            |  + 44
//  -----------------------------
//    | return addr     |  + 40
//    | saved ebp       |  + 36
//    | saved ebx       |  + 32
//    | saved esi       |  + 28
//    | saved edi       |  + 24

//    | dpitch_adj      |  + 20
//    | stretch         |  + 16
//    | mark            |  + 12
//    | flag            |  +  8
//    | j               |  +  4
//    | k               |  +  0

#define LOCALSIZE           24

#define SPITCH_ADJ          64
#define CHROMA_ITERS        60
#define OUTPUT_FRAME_WIDTH  56
#define PITCH_PARM          52
#define PLANE               48
#define PSRC                44

#define DPITCH_ADJ          20
#define STRETCH             16
#define MARK                12
#define FLAG                 8
#define LOOP_J               4
#define LOOP_K               0

	_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// pnext = psrc + (OuputFrameWidth>>1) + uvpitch_adj
// pdest_copy = Plane
// pdest_avg = Plane + pitch
// assign (esi, psrc)
// assign (ecx, pnext)
// assign (edi, pdest_copy)
// assign (edx, pdest_avg)
// assign (ebp, i)
	mov		esi, [esp + PSRC]
	mov		ecx, esi
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	add		ecx, eax
	mov		edi, [esp + PLANE]
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// dpitch_adj = pitch - OutputFrameWidth
	mov		eax, [esp + PITCH_PARM]
	sub		eax, [esp + OUTPUT_FRAME_WIDTH]
	mov		[esp + DPITCH_ADJ], eax
// stretch = (spitch_adj ? 1 : 0)
	xor		ebx, ebx
	mov		eax, [esp + SPITCH_ADJ]
	test	eax, eax
	jz		L1
	inc		ebx
L1:
	mov		[esp + STRETCH], ebx
// mark = 6 - stretch
	mov		eax, 6
	sub		eax, ebx
	mov		[esp + MARK], eax
// flag = stretch
	mov		DWORD PTR [esp + FLAG], ebx

// for (j = ChromaIters; j > 0; j--)
	mov		eax, [esp + CHROMA_ITERS]
	mov		[esp + LOOP_J], eax
L2:
// for (k = mark + (flag & 1); k > 0; k--)
	mov		eax, [esp + FLAG]
	and		eax, 1
	add		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
L3:
// if (!stretch && (0 == j) && (0 == k))
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jnz		L4
	mov		eax, [esp + LOOP_J]
	cmp		eax, 1
	jne		L4
	mov		eax, [esp + LOOP_K]
	cmp		eax, 1
	jne		L4
// pnext = psrc
	mov		ecx, esi
L4:
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4,
//                                           pdest_copy += 8, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L5:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_copy,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi], ebx
// DUP_UPPER_TWO_BYTES((pdest_copy+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi+4], ebx
// READ_DWORD_AND_SHIFT(t2,pnext)
// AVERAGE_DWORDS(t1,t1,t2)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edi, [edi + 8]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L5

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + pitch_adj
// pdest_avg = pdest_copy + pitch
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// end of k loop
	dec		DWORD PTR [esp + LOOP_K]
	jnz		L3

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	jz		L6

// psrc -= ((OutputFrameWidth>>1)+spitch_adj)
// pnext -= ((OutputFrameWidth>>1)+spitch_adj)
// pdest_avg = pdest_copy
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	sub		esi, eax
	sub		ecx, eax
	mov		edx, edi
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L7:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// READ_DWORD_AND_SHIFT(t2,pnext)
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
// AVERAGE_DWORDS(t1,t1,t2)
// AVERAGE_DWORDS(t1,t1,t2)
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L7

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + dpitch_adj
// pdest_avg = pdest_copy + pitch
// flag++
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
	inc		DWORD PTR [esp + FLAG]

// end of j loop
L6:
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L2

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SPITCH_ADJ
#undef CHROMA_ITERS
#undef OUTPUT_FRAME_WIDTH
#undef PITCH_PARM
#undef PLANE
#undef PSRC

#undef DPITCH_ADJ
#undef STRETCH
#undef MARK
#undef FLAG
#undef LOOP_J
#undef LOOP_K

__declspec(naked)
_STATIC void IA_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 88
//    | FrameHeight     |  + 84
//    | FrameWidth      |  + 80
//    | VPlane          |  + 76
//    | UPlane          |  + 72
//    | YPlane          |  + 68
//    | lpInput         |  + 64
//    | lpbiInput       |  + 60
//  -----------------------------
//    | return addr     |  + 56
//    | saved ebp       |  + 52
//    | saved ebx       |  + 48
//    | saved esi       |  + 44
//    | saved edi       |  + 40

//    | width_adj       |  + 36
//    | height_adj      |  + 32
//    | stretch         |  + 28
//    | mark            |  + 24
//    | iNextLine       |  + 20
//    | j               |  + 16
//    | k               |  + 12
//    | LumaIters       |  +  8
//    | ypitch_adj      |  +  4
//    | uvpitch_adj     |  +  0

#define LOCALSIZE        40

#define PITCH_PARM       88
#define FRAME_HEIGHT     84
#define FRAME_WIDTH      80
#define VPLANE           76
#define UPLANE           72
#define YPLANE           68
#define LP_INPUT         64
#define LPBI_INPUT       60

#define WIDTH_ADJ        36
#define HEIGHT_ADJ       32
#define STRETCH          28
#define MARK             24
#define NEXT_LINE        20
#define LOOP_J           16
#define LOOP_K           12
#define LUMA_ITERS        8
#define YPITCH_ADJ        4
#define UVPITCH_ADJ       0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	shr		esi, 1
	mov		[esp + WIDTH_ADJ], esi
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
	mov		[esp + HEIGHT_ADJ], edx
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iNextLine = width_adj << 1
	mov		ebp, esi
	shl		ebp, 1
	mov		[esp + NEXT_LINE], ebp
// pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = LumaIters; j > 0; j--)
	mov		eax, [esp + LUMA_ITERS]
	mov		[esp + LOOP_J], eax
// for (k = mark; k > 0; k--)
L4:
	mov		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
L5:
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// *(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
// 1
	mov		eax, [esi]
	lea		esi, [esi + 4]
// 2
	and		eax, 0xFEFEFEFE
	lea		edi, [edi + 4]
// 3
	shr		eax, 1
	sub		ebp, 4
// 4
	mov		[edi - 4], eax
	jnz		L6

// pnext += iNextLine
// YPlane += ypitch_adj
	add		esi, [esp + NEXT_LINE]
	add		edi, [esp + YPITCH_ADJ]

// end of k loop
	mov		eax, [esp + LOOP_K]
	sub		eax, 1
	mov		[esp + LOOP_K], eax
	jnz		L5

// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L7

// plast = pnext - lpbiInput->biWidth
// pn = pnext
// assign (ecx, plast)
// assign (edx, pn)
	mov		ecx, esi
	mov		eax, [esp + LPBI_INPUT]
	sub		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		edx, esi

// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here just to make sure the loop code starts with the U pipe
	jmp		L8
L8:
// *(U32 *)YPlane =
//  ( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
//      ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1
// 1
	mov		eax, [ecx]
	lea		ecx, [ecx + 4]
// 2
	shr		eax, 1
// 3
	and		eax, 0x7F7F7F7F
	mov		ebx, [edx]
// 4
	shr		ebx, 1
	lea		edi, [edi + 4]
// 5
	and		ebx, 0x7F7F7F7F
// 6
	add		eax, ebx
// 7
	and		eax, 0xFEFEFEFE
// 8
	shr		eax, 1
// 9
	mov		[edi - 4], eax
	sub		ebp, 4
// 10
	lea		edx, [edx + 4]
	jnz		L8

// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]

L7:
// end of the LumaIters loop
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L4

// pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight)
// assign (esi, pvsrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	imul	ebx
	add		eax, [esp + LP_INPUT]
	mov		esi, eax
// pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight)>>2)
// assign (edi, pusrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		ecx, 2
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	shr		eax, 2
	imul	ecx
	add		eax, esi
	mov		edi, eax
// t = ((lpbiInput->biWidth>>2) * (height>>2)) + (width_adj>>2)
// assign (eax, t)
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		eax, 2
	mov		ebx, [esp + HEIGHT_ADJ]
	shr		ebx, 2
	imul	ebx
	mov		ebx, [esp + WIDTH_ADJ]
	shr		ebx, 2
	add		eax, ebx
// pvsrc += t
// pusrc += t
	add		esi, eax
	add		edi, eax

// uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + UPLANE]
	push	edi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

// uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + VPLANE]
	push	esi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef WIDTH_ADJ
#undef HEIGHT_ADJ
#undef STRETCH
#undef MARK
#undef NEXT_LINE
#undef LOOP_J
#undef LOOP_K
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

#if 0
_STATIC void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;

	int ypitch_adj = pitch - FrameWidth;
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = FrameHeight - yinput_height;
	int ywidth_diff = FrameWidth - yinput_width;

	int uvpitch_adj = pitch - (FrameWidth >> 1);
	int uvoutput_width = FrameWidth >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvinput_width = yinput_width >> 1;
	int uvheight_diff = yheight_diff >> 1;
	int uvwidth_diff = ywidth_diff >> 1;

	for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj) {
			for (i = yinput_width; i > 0; i -= 8) {
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
				}
			for (i = ywidth_diff; i > 0; i -= 8) {
					*(U32 *)YPlane = 0; YPlane += 4;
					*(U32 *)YPlane = 0; YPlane += 4;
				}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj) {
			for (i = FrameWidth; i > 0; i -= 8) {
				*(U32 *)YPlane = 0; YPlane += 4;
				*(U32 *)YPlane = 0; YPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
			}
	}

}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 92
//    | FrameHeight     |  + 88
//    | FrameWidth      |  + 84
//    | VPlane          |  + 80
//    | UPlane          |  + 76
//    | YPlane          |  + 72
//    | lpInput         |  + 68
//    | lpbiInput       |  + 64
//  -----------------------------
//    | return addr     |  + 60
//    | saved ebp       |  + 56
//    | saved ebx       |  + 52
//    | saved esi       |  + 48
//    | saved edi       |  + 44

//    | ypitch_adj      |  + 40
//    | yinput_height   |  + 36
//    | yinput_width    |  + 32
//    | yheight_diff    |  + 28
//    | ywidth_diff     |  + 24
//    | uvpitch_adj     |  + 20
//    | uvoutput_width  |  + 16
//    | uvinput_height  |  + 12
//    | uvinput_width   |  +  8
//    | uvheight_diff   |  +  4
//    | uvwidth_diff    |  +  0

#define LOCALSIZE        44

#define PITCH_PARM       92
#define FRAME_HEIGHT     88
#define FRAME_WIDTH      84
#define VPLANE           80
#define UPLANE           76
#define YPLANE           72
#define LP_INPUT         68
#define LPBI_INPUT       64

#define YPITCH_ADJ       40
#define YINPUT_HEIGHT    36
#define YINPUT_WIDTH     32
#define YHEIGHT_DIFF     28
#define YWIDTH_DIFF      24
#define UVPITCH_ADJ      20
#define UVOUTPUT_WIDTH   16
#define UVINPUT_HEIGHT   12
#define UVINPUT_WIDTH     8
#define UVHEIGHT_DIFF     4
#define UVWIDTH_DIFF      0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

		mov		ebx, [esp + FRAME_HEIGHT]
		mov		ecx, [esp + FRAME_WIDTH]
		mov		edx, [esp + PITCH_PARM]
// ypitch_adj = pitch - FrameWidth
		mov		eax, edx
		sub		eax, ecx
		mov		[esp + YPITCH_ADJ], eax
// uvoutput_width = FrameWidth >> 1
		mov		ebp, ecx
		shr		ebp, 1
		mov		[esp + UVOUTPUT_WIDTH], ebp
// uvpitch_adj = pitch - (FrameWidth >> 1)
		sub		edx, ebp
		mov		[esp + UVPITCH_ADJ], edx
// yinput_height = lpbiInput->biHeight
// uvinput_height = yinput_height >> 1
// yinput_width = lpbiInput->biWidth
// uvinput_width = yinput_width >> 1
		mov		ebx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biHeight
		mov		[esp + YINPUT_HEIGHT], eax
		shr		eax, 1
		mov		[esp + UVINPUT_HEIGHT], eax
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
// yheight_diff = FrameHeight - yinput_height
// uvheight_diff = yheight_diff >> 1;
		mov		eax, [esp + FRAME_HEIGHT]
		mov		ebx, eax
		sub		eax, [esp + YINPUT_HEIGHT]
		jns		NoCrop0
		xor		eax, eax
		mov		[esp + YINPUT_HEIGHT], ebx
		shr		ebx, 1
		mov		[esp + UVINPUT_HEIGHT], ebx
NoCrop0:
		mov		[esp + YHEIGHT_DIFF], eax
		shr		eax, 1
		mov		[esp + UVHEIGHT_DIFF], eax
// ywidth_diff = FrameWidth - yinput_width
// uvwidth_diff = ywidth_diff >> 1;
		mov		eax, [esp + FRAME_WIDTH]
		xor		ebx, ebx
		sub		eax, [esp + YINPUT_WIDTH]
		jns		NoCrop1
		mov		eax, [esp + FRAME_WIDTH]
		mov		ebx, [esp + YINPUT_WIDTH]
		sub		ebx, eax
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
		xor		eax, eax
NoCrop1:
		mov		[esp + YWIDTH_DIFF], eax
		shr		eax, 1
		mov		[esp + UVWIDTH_DIFF], eax
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]

// assign (edi, YPlane)
		mov		edi, [esp + YPLANE]
// for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YINPUT_HEIGHT]
L1:
// for (i = yinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + YINPUT_WIDTH]
L2:
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L2
// for (i = ywidth_diff; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + YWIDTH_DIFF]
		test	ebp, ebp
		jz		L3
L4:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L4
// j--, YPlane += ypitch_adj
L3:
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L1

// for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YHEIGHT_DIFF]
		test	ecx, ecx
		jz		L7
L5:
// for (i = FrameWidth; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + FRAME_WIDTH]
L6:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L6
// j--, YPlane += ypitch_adj
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L5

L7:
// recompute start of input U plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
// assign (edi, UPlane)
		mov		edi, [esp + UPLANE]
		shr		ebx, 1
// for (j = uvinput_height; j > 0; j--, UPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L8:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L9:
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L9
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L11
L10:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L10
// j--, UPlane += uvpitch_adj
L11:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L8

// for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L14
L12:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L13:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L13
// j--, UPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L12

L14:
// recompute start of input V plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
		shr		eax, 2
		add		esi, eax
// assign (edi, VPlane)
		mov		edi, [esp + VPLANE]
// for (j = uvinput_height; j > 0; j--, VPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L15:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L16:
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L16
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L18
L17:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L17
// j--, VPlane += uvpitch_adj
L18:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L15

// for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L21
L19:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L20:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L20
// j--, VPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L19

L21:
		add		esp, LOCALSIZE
		pop		edi
		pop		esi
		pop		ebx
		pop		ebp
		ret
	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef YPITCH_ADJ
#undef YINPUT_HEIGHT
#undef YINPUT_WIDTH
#undef YHEIGHT_DIFF
#undef YWIDTH_DIFF
#undef UVPITCH_ADJ
#undef UVOUTPUT_WIDTH
#undef UVINPUT_HEIGHT
#undef UVINPUT_WIDTH
#undef UVHEIGHT_DIFF
#undef UVWIDTH_DIFF

#if 0
void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1)) >> 1;
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1)) >> 1;
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1)) >> 1;
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1)) >> 1;
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1)) >> 1;
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1)) >> 1;
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1)) >> 1;
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1)) >> 1;
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1;
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1;
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1;
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define PEOL				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * Y 0 * U 0 * Y 1 * V 0 * Y 2 * U 1 * Y 3 * V 1 * Y 4 * U 2 * Y 5 * V 2 * Y 6 * U 3 * Y 7 * V 3 *
//         *************************************************************************************************
// Y Offsets  0			  2			  4			  6			  8			  10		  12		  14
// U Offsets        1                       5                       9   					13
// Y Offsets                    3                       7                       11                      15
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+9]			; U2
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+13]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+11]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+15]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi]			; Y0
; 6
	mov		bh, [esi+5]			; U1
	mov		ah, [esi+2]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi+1]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+7]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+3]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+12]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+14]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+8]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+10]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+12]		; Y6
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+14]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi]			; Y0
; 5
	mov		ah, [esi+2]			; Y1
	mov		bh, [esi+10]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+8]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+4]
	mov		bl, [ebp+4]
	mov		bh, [ebp+6]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+6]
	mov		bl, [ebp]
; 2
	shl		eax, 16
	mov		bh, [ebp+2]
; 3
	mov		al, [edx]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+2]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+4]
; 9
	shr		eax, 1
	mov		bh, [ebp+6]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+4]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}


bool UYVY_to_YUV12_Flip(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * pImage,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	DWORD dwFrameWidthHalf, dwFrameHeightHalf;
	BYTE *pRowStartY, *pRowStartSrc, *pRowStartU, *pRowStartV;
	int offset;

	int nRowsToSkip=0, nColsToSkip=0, nRowSkipDelta=0xffffff, nColSkipDelta=0xffffff;
	int nSrcRowIndex, nDstRowIndex, nSrcColIndex, nDstColIndex, COLUMNSTOSKIP=0, ROWSTOSKIP=0;


	if ((FrameWidth != (DWORD)(lpbiInput->biWidth)) || (FrameHeight != (DWORD)(lpbiInput->biHeight)))
	{
		nColsToSkip = COLUMNSTOSKIP = lpbiInput->biWidth - FrameWidth;
		nRowsToSkip = ROWSTOSKIP = lpbiInput->biHeight - FrameHeight;
		if ((nColsToSkip < 0) || (nRowsToSkip < 0))
		{
			return false;
		}

		// nXXXSkipDelta dictate how often we "skip" a row or col
		if (nRowsToSkip)
		{
			nRowSkipDelta = (lpbiInput->biHeight + (nRowsToSkip - 1)) / nRowsToSkip;
		}

		if (nColsToSkip)
		{
			nColSkipDelta = (lpbiInput->biWidth + (nColsToSkip - 1)) / nColsToSkip;
		}
	
	}

	// quick check to make sure we're processing CIF, QCIF, or SQCIF
	if ((FrameWidth % 4) || (FrameHeight % 4))
	{
		return false;
	}

	dwFrameWidthHalf = FrameWidth / 2;
	dwFrameHeightHalf = FrameHeight / 2;

	nSrcRowIndex = 0;
	nDstRowIndex = 0;

	// step 1, convert the Y values over
	while ((DWORD)nDstRowIndex < FrameHeight)
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		pRowStartY = YPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 1;

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		// Copy the Y values of the input row into the destination row		
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;

		while ((DWORD)nDstColIndex < FrameWidth)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nColsToSkip--;
				nSrcColIndex++;
				continue;
			}

			pRowStartY[nDstColIndex] = pRowStartSrc[nSrcColIndex * 2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}


	nSrcRowIndex = 0;
	nDstRowIndex = 0;
	nRowsToSkip = ROWSTOSKIP;

	// step 2, process U and V values
	while ((DWORD)nDstRowIndex < dwFrameHeightHalf)  // dest is only half as many rows as src
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		// don't process odd numbered rows
		if (nSrcRowIndex % 2)
		{
			
			// if we were supposed to skip this src row anyway, make sure
			// we update our decrement
			if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
			{
				nRowsToSkip--;
			}

			nSrcRowIndex++;

			continue;
		}

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		pRowStartU = UPlane + (pitch * nDstRowIndex);
		pRowStartV = VPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 0;

		// Copy the U and V values of the input row into the destination row
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;  // reset column skip count

		while ((DWORD)nDstColIndex < dwFrameWidthHalf)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// skip odd numbered columns
			if (nSrcColIndex % 2)
			{

				// if we were supposed to skip this src row anyway, make sure
				// we update our decrement

				if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
				{
					nColsToSkip--;
				}

				nSrcColIndex++;

				continue;
			}

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nSrcColIndex++;
				nColsToSkip--;
				continue;
			}

			offset = nSrcColIndex * 2;
			pRowStartU[nDstColIndex] = pRowStartSrc[offset] >> 1;
			pRowStartV[nDstColIndex] = pRowStartSrc[offset+2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}



	// and we are done!
	return true;

}





__declspec(naked)
_STATIC void IA_H26X_UYVYtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * U 0 * Y 0 * V 0 * Y 1 * U 1 * Y 2 * V 1 * Y 3 * U 2 * Y 4 * V 2 * Y 5 * U 3 * Y 6 * V 3 * Y 7 *
//         *************************************************************************************************
// Y Offsets        1           3           5           7           9           11          13          15
// U Offsets  0                       4                       8                       12       
// Y Offsets              2                       6                       10                      14      
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+8]			; U2
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+12]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+10]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+14]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi+1]			; Y0
; 6
	mov		bh, [esi+4]			; U1
	mov		ah, [esi+3]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+6]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+2]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+13]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+15]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+9]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+11]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+13]		; Y6
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+15]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi+1]			; Y0
; 5
	mov		ah, [esi+3]			; Y1
	mov		bh, [esi+11]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+9]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+5]
	mov		bl, [ebp+5]
	mov		bh, [ebp+7]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+7]
	mov		bl, [ebp+1]
; 2
	shl		eax, 16
	mov		bh, [ebp+3]
; 3
	mov		al, [edx+1]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+3]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+5]
; 9
	shr		eax, 1
	mov		bh, [ebp+7]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+5]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef PEOL
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
)
{
    U8 *RGBCursor = (U8 *) lpicComp->lpInput;
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;

    /*  The Connectix Quick Cam requires RGB to YUV12 conversion.
     *  The B/W camera generates palette versions (8 and 4 bit).
     *  The color camera generates RGB24 for million colors and
     *  RGB16555 for thousands colors.
     */

    if (BI_RGB == lpicComp->lpbiInput->biCompression)
	{
        if (24 == lpicComp->lpbiInput->biBitCount) {
#if 0
		if ((128 == lpbiInput->biWidth) && (96 == lpbiInput->biHeight)) {
			U8 YTest[12288];
			U8 UTest[6144];
			U8 VTest[6144];
			int i, j, k;
			U8 R,G,B;
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YTest, UTest, VTest,
				EC->FrameWidth, EC->FrameHeight, 128);
			for (i = 0; i < 96; i++) {
				for (j = 0; j < 128; j++) {
					k = (i*128)+j;
					if (1 < abs(YPlane[(i*384)+j]-YTest[(i*128)+j])) {
						B = RGBCursor[(((95-i)*128)+j)*3];
						G = RGBCursor[(((95-i)*128)+j)*3+1];
						R = RGBCursor[(((95-i)*128)+j)*3+2];
					}
					if ((0 == (i%2)) && (0 == (j%2))) {
						k =	((i>>1)*128)+(j>>1);
						if (1 < abs(UPlane[((i>>1)*384)+(j>>1)]-UTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
						if (1 < abs(VPlane[((i>>1)*384)+(j>>1)] != VTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
					}
				}
			}
		}
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#else
			IA_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(16 == lpicComp->lpbiInput->biBitCount)
		{
		// To use a common routine for all possible combinations of RGB16,
		// a bitfield number is passed. This number identifies the proper bit shift
		// and masking values to extract the color information
		// from the 16-bit pixel words.
		//
		//   number             shift              mask
		//                     B, G, R
		//   ------          -----------       ----------------
		//    555              2, 3, 8         0x7C, 0x7C, 0x7C
		//    664              3, 3, 9         0x78, 0x7E, 0x7E
		//    565              2, 4, 9         0x7C, 0x7E, 0x7C
		//    655              2, 3, 9         0x7C, 0x7C, 0x7E
		//
		// Only 555 falls under BI_RGB. The others are specified using the
		// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
		// Build16bitModeID to get the actual bitfield number. This routine requires the
		// three array elements in the bmiColors field of a BITMAPINFO object.
		//
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR16toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 555, PITCH);
#else
			IA_H26X_BGR16555toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(8 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 8, PITCH);
#else
			IA_H26X_CLUT8toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(4 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 4, PITCH);
#else
			IA_H26X_CLUT4toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else
		{
			DBOUT("ERROR: Unexpected input format detected.");
		}
    }
    else if (FOURCC_YVU9 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if ((FOURCC_YUV12 == lpicComp->lpbiInput->biCompression) || (FOURCC_IYUV == lpicComp->lpbiInput->biCompression))
	{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
	}
    else if (FOURCC_YUY2 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if (FOURCC_UYVY == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif

       UYVY_to_YUV12_Flip(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);


//        IA_H26X_UYVYtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
//            EC->FrameWidth, EC->FrameHeight, PITCH);



#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else
    {
        DBOUT("ERROR: Unexpected input format detected.");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\d1slf.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995, 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
.486
.Model FLAT, C
APP_32BIT equ 1
;.CODE
IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS

IACODE2 SEGMENT

LoopFilter PROC C PUBLIC USES esi edi ebx ebp in8x8:DWORD, out8x8:DWORD, pitch:DWORD
LOCAL filt_temp[32]:DWORD, loop_count:DWORD
; **************************************************
; output pitch is hard coded to 8 for uFilterBBuffer
; 	input pitch is 384 (as passed parameter)
; **************************************************

	mov	esi,in8x8
;	mov	edi,out8x8		; for debug
	 lea	edi,filt_temp		; use temporary storage
	mov	loop_count,8
	 xor	eax,eax

        

; filter 8x8 block horizontally
; input is 8-bit, output is 16-bit temporary storage
ALIGN 4
do_row:
; pixel 0
	mov	al,byte ptr [esi]	; get p0, eax = a
	 xor	ebx,ebx
	mov	edx,eax			; copy pixel 0
	 xor	ecx,ecx
	shl	edx,2			; a<<2
; pixel 0 + pixel 1
	 mov	bl,byte ptr [esi+1]	; get p1, ebx = b
	mov	[edi],dx		; output p0 = a<<2
	 add	eax,ebx			; eax = (a+b)
	mov	cl,byte ptr [esi+2]	; get p2, ecx = c
; pixel 1 + pixel 2
	 xor	edx,edx
	add	ebx,ecx			; ebx = (b+c)
	 mov	dl,byte ptr [esi+3]	; get p3, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	mov	[edi+2],ax		; output p1 = (a+b) + (b+c)
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
; pixel 2 + pixel 3
	mov	[edi+4],bx		; output p2 = (a+b) + (b+c)
	 xor	eax,eax
	mov	al,byte ptr [esi+4]	; get p4, eax = c
; pixel 3 + pixel 4
	 xor	ebx,ebx
	add	edx,eax			; edx = (b+c)
	 mov	bl,byte ptr [esi+5]	; get p5, ebx = c
	add	ecx,edx			; ecx = (a+b) + (b+c)
	 add	eax,ebx			; eax = (b+c)
	mov	[edi+6],cx		; output p3 = (a+b) + (b+c)
	 add	edx,eax			; edx = (a+b) + (b+c)
; pixel 4 + pixel 5
	mov	[edi+8],dx		; output p4 = (a+b) + (b+c)
	 xor	ecx,ecx
	mov	cl,byte ptr [esi+6]	; get p6, ecx = c
; pixel 5 + pixel 6
	 xor	edx,edx
	add	ebx,ecx			; ebx = (a+b)
	 mov	dl,byte ptr [esi+7]	; get p7, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	shl	edx,2			; p7<<2
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+10],ax		; output p5 = (a+b) + (b+c)
; pixel 6 + pixel 7
	 xor	eax,eax			; for next iteration
	mov	[edi+12],bx		; output p6 = (a+b) + (b+c)
	 mov	ecx,loop_count
	mov	[edi+14],dx		; output p7 = c<<2
	 mov	ebx,pitch
	add	edi,16
	 add	esi,ebx			; inc input ptr
	dec	ecx
	mov	loop_count,ecx
	 jnz	do_row

; filter 8x8 block vertically
; input is 16-bit from temporary storage, output is 8-bit

	lea	esi,filt_temp
	 mov	edi,out8x8
	
	mov	loop_count,4			; loop counter

         ;
;
ALIGN 4
row0:
	mov	eax,[esi]		; eax = a
; row0 + row1
	 mov	ebx,[esi+16]		; get b
	mov	edx,eax			; copy a
	 add	eax,ebx			; eax = (a+b)
	add	edx,00020002h		; round result
	 mov	ecx,[esi+32]		; get c
	shr	edx,2			; divide by 4
	 add	ebx,ecx			; ebx = (b+c)
	and	edx,00ff00ffh		; convert back to 8-bit
	 add	eax,ebx			; eax = (a+b) + (b+c)
	mov	[edi],dl		; output a for column 0  
	 add	eax,00080008h		; round
	shr	edx,16
	shr	eax,4
	 mov	[edi+1],dl		; output a for column 1
; row1 + row2
	mov	edx,[esi+48]		; get c
	 and	eax,00ff00ffh
	add	ecx,edx			; ecx = (b+c)
	 mov	[edi+8],al		; output b for column 0  
	shr	eax,16
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+9],al		; output b for column 1
	 add	ebx,00080008h		; round
	shr	ebx,4
; row2 + row3
	 mov	eax,[esi+64]		; get c
	and	ebx,00ff00ffh
	 add	edx,eax			; edx = (b+c)
	mov	[edi+16],bl		; output c for column 0  
	 add	ecx,edx			; ecx = (a+b) + (b+c)
	shr	ebx,16
	 add	ecx,00080008h		; round
	shr	ecx,4
	 mov	[edi+17],bl		; output c for column 1
	and	ecx,00ff00ffh
; row3 + row4
	 mov	ebx,[esi+80]		; get c
	mov	[edi+24],cl		; output c
	 add	eax,ebx			; eax = (b+c)
	shr	ecx,16
	 add	edx,eax			; edx = (a+b) + (b+c)
	mov	[edi+25],cl		; output c
	 add	edx,00080008h		; round
	shr	edx,4
; row4 + row5
	 mov	ecx,[esi+96]		; get c
	and	edx,00ff00ffh
	 add	ebx,ecx			; ebx = (b+c)
	mov	[edi+32],dl		; output c
	 add	eax,ebx			; eax = (a+b) + (b+c)
	shr	edx,16
	 add	eax,00080008h		; round
	shr	eax,4
	 mov	[edi+33],dl		; output c
	and	eax,00ff00ffh
; row5 + row6
	 mov	edx,[esi+112]		; get c
	mov	[edi+40],al		; output c
	 add	ecx,edx			; ecx = (b+c)
	shr	eax,16
; row6 + row7
	 add	edx,00020002h		; round result
	shr	edx,2			; divide by 4
	 mov	[edi+41],al		; output c
	add	ebx,ecx			; ebx = (a+b) + (b+c)
	 and	edx,00ff00ffh		; convert back to 8-bit
	add	ebx,00080008h		; round
	 mov	[edi+56],dl		; output c
	shr	ebx,4
	 mov	ecx,loop_count
	shr	edx,16
	 and	ebx,00ff00ffh
	mov	[edi+48],bl		; output c
	 mov	[edi+57],dl		; output c
	shr	ebx,16
	 add	esi,4			; inc input ptr
	mov	[edi+49],bl		; output c
	 add	edi,2
	dec	ecx
	mov	loop_count,ecx
	 jnz	row0

	ret
LoopFilter	EndP

IACODE2 ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3inst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3inst.inv   1.6   27 Dec 1995 15:33:00   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCINST_INC_
ELSE
_ENCINST_INC = 1

;
; Global definitions for the H26x encoder.
;
;

PITCH = 384     ; Pitch for each plane
VOFFSET = 192   ; Dist from U to corresponding V

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3dctc.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3dctc.inv   1.2   27 Dec 1995 15:32:58   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCDCTC_INC_
ELSE
_ENCDCTC_INC = 1

;
; Field offsets for DCT coefficients for the H26x encoder.
;

T_CoeffBlk STRUCT
  UNION
    C50C52      DWORD ?   ;    0
    BlockAddr   DWORD ?   ;    0
  ENDS
  UNION
    C00C02        DWORD ?  ;   4
    LinesDefined  BYTE  ?  ;   4
  ENDS
  UNION
    C10C12        DWORD ?  ;   8
    Cols03Defined DWORD ?  ;   8
  ENDS
  UNION
    C30C32        DWORD ?  ;  12
    Cols47Defined DWORD ?  ;  12
  ENDS
  C20C22      DWORD ?   ;   16
  C40C42      DWORD ?   ;   20
  C60C62      DWORD ?   ;   24
  C70C72      DWORD ?   ;   28
  C51C53      DWORD ?   ;   32
  C01C03      DWORD ?   ;   36
  C31C33      DWORD ?   ;   40
  C11C13      DWORD ?   ;   44
  C21C23      DWORD ?   ;   48
  C41C43      DWORD ?   ;   52
  C61C63      DWORD ?   ;   56
  C71C73      DWORD ?   ;   60
  C54C56      DWORD ?   ;   64
  C04C06      DWORD ?   ;   68
  C14C16      DWORD ?   ;   72
  C34C36      DWORD ?   ;   76
  C24C26      DWORD ?   ;   80
  C44C46      DWORD ?   ;   84
  C64C66      DWORD ?   ;   88
  C74C76      DWORD ?   ;   92
  C57C55      DWORD ?   ;   96
  C07C05      DWORD ?   ;  100
  C17C15      DWORD ?   ;  104
  C37C35      DWORD ?   ;  108
  C27C25      DWORD ?   ;  112
  C47C45      DWORD ?   ;  116
  C67C65      DWORD ?   ;  120
  C77C75      DWORD ?   ;  124
T_CoeffBlk ENDS


ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3mbad.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbad.inv   1.10   04 Oct 1996 08:47:58   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e3mbad.inv  $
;// 
;//    Rev 1.10   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.9   14 May 1996 12:18:46   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   02 May 1996 13:41:08   BNICKERS
;// started integration of MMX PB-frames
;// 
;//    Rev 1.7   22 Feb 1996 15:02:38   BNICKERS
;// Add unionized field for MMx implementation.
;// 
;//    Rev 1.6   22 Jan 1996 17:13:44   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.5   27 Dec 1995 15:33:00   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENDMBAD_INC_
ELSE
_ENDMBAD_INC = 1

;
; Fields for MacroBlock Action Stream Descriptors for the H26x encoder.
;


T_Blk STRUCT
  BlkOffset         DWORD ? ;  0  -- Offset from upper left viewable pel of Y
                            ;        plane to upper left pel of block.
  UNION
    PastRef         DWORD ? ;  4  -- Addr of 8*8 reference block, passed from
                            ;        P-Frame ME to P-Frame frame differencing.
    STRUCT
      CandidateHMVf BYTE ?  ;  4  -- Scratch area for figuring BestHMVf values.
      CandidateVMVf BYTE ?  ;  5  -- Must be 4 bytes after Best...
      CandidateHMVb BYTE ?  ;  6
      CandidateVMVb BYTE ?  ;  7
    ENDS
    CandidateBiDiMVs DWORD ? ; 4
  ENDS
  UNION
    STRUCT
      BestHMVf      BYTE ?  ;  8  -- "Real" MVs for B-Frame block, passed from
      BestVMVf      BYTE ?  ;  9  -- B-Frame ME to P-Frame frame differencing.
      BestHMVb      BYTE ?  ; 10  -- (Biased by 060H)
      BestVMVb      BYTE ?  ; 11
    ENDS
    BestBiDiMVs     DWORD ? ;  8
  ENDS
  UNION
    STRUCT
      PHMV        BYTE  ?   ; 12  -- Horz motion vector for P frame ref blk.
      PVMV        BYTE  ?   ; 13  -- Vert motion vector for P frame ref blk.
      BHMV        BYTE  ?   ; 14  -- Horz motion vector adjustment for B frm.
      BVMV        BYTE  ?   ; 15  -- Vert motion vector adjustment for B frame.
    ENDS
    MVs           DWORD ?   ; 12
  ENDS
T_Blk ENDS

; Symbolic offsets for MMx version:

T_MacroBlockActionDescr STRUCT 
  BlockType     BYTE  ? ;  0  -- See Block Types below.
  MBEdgeType    BYTE  ? ;  1  -- 1 left | 2 right | 4 top | 8 bottom
  Unassigned1   BYTE  ?
  FirstMEState  BYTE  ? ;  3  -- First State Num for Motion Estimation engine.
  UNION
    STRUCT
      CodedBlocks   BYTE  ? ;  4  -- [6] End-Of-Stream indicator
                            ;        [0] indicates Y1 non-empty.
                            ;        [1..5] indicate Y2, Y3, Y4, U, V non-empty.
                            ;        Other bits zero.
      CodedBlocksB  BYTE  ? ;  5  -- [0..5] like CodedBlocks, but for B frame.
                            ;        Set 0 for non-bi-di prediction.
      BestFullPelMBHMV BYTE ? ; 6 -- Best full pel HMV at macroblock level.
      BestFullPelMBVMV BYTE ? ; 7 -- Best full pel VMV at macroblock level.
    ENDS
    BestFullPelMBMVs DWORD ? ; 4
  ENDS
  SWD           DWORD ? ;  8  -- Sum of weighted diffs, from motion estimation.
  SWDB          DWORD ? ; 12  -- Sum of weighted diffs, from ME for B frame.
  BlkY1         T_Blk { }
  Blk           EQU       BlkY1
  BlkY2         T_Blk { }
  BlkY3         T_Blk { }
  BlkY4         T_Blk { }
  BlkU          T_Blk { }
  BlkV          T_Blk { }
  Unassigned4	BYTE  16 DUP (?) ; pad out 16 bytes to 128 bytes total to match C struct
T_MacroBlockActionDescr ENDS
T_MBAD TEXTEQU <T_MacroBlockActionDescr>

IF SIZEOF T_MacroBlockActionDescr-128
**** Size of T_MacroBlockActionDescr MUST BE a power of 2 bytes long.
ENDIF

IF 3*SIZEOF T_MBAD-PITCH
  **** Next instr works if PITCH==384 and SizeOf T_MacroBlockActionDescr==128.
  **** Here and throughout this file.
ELSE
BlkLvlSWD       TEXTEQU <BestBiDiMVs>
CandBlkLvlSWD   TEXTEQU <[CONST_384*1-128+CandidateBiDiMVs]>
BestBlkLvlSWD   TEXTEQU <[CONST_384*1-128+BestBiDiMVs]>
BlkLvlSWD0Delta TEXTEQU <[CONST_384*1-128+MVs]>
CandBiDiMVs     TEXTEQU <[CONST_384*1+CandidateBiDiMVs]>
CandHMVf        TEXTEQU <[CONST_384*1+CandidateHMVf]>
CandVMVf        TEXTEQU <[CONST_384*1+CandidateVMVf]>
CandHMVb        TEXTEQU <[CONST_384*1+CandidateHMVb]>
CandVMVb        TEXTEQU <[CONST_384*1+CandidateVMVb]>
BiDiMVs0Delta   TEXTEQU <[CONST_384*1+BestBiDiMVs]>
HMVf0Delta      TEXTEQU <[CONST_384*1+BestHMVf]>
VMVf0Delta      TEXTEQU <[CONST_384*1+BestVMVf]>
HMVb0Delta      TEXTEQU <[CONST_384*1+BestHMVb]>
VMVb0Delta      TEXTEQU <[CONST_384*1+BestVMVb]>
ENDIF

; Memory layout constraints:
;
; T_MacroBlockActionDescr structure must be 16-byte aligned.
; Each T_Blk structure must be 16-byte aligned.
; FirstMEState must be 3rd byte of a DWORD.
; CodedBlocks must be DWORD aligned.
; CodedBlocksB must be CodedBlocks plus one.
; CodedBlocks & CodedBlocksB should be in different memory bank than BlockType.
; Offset must be 16-byte aligned.
; PastRef must be at Targ plus four.
; Candidate MVs must be at DWORD before Best MVs.  MVs must be in order given.
;

; Block Types
;
;  Only INTER, INTRA, and INTERSLF used for H261.
;  Only INTER1MV, INTRA, INTER4MV used presently for H263.

INTER1MV  = 0
INTER     = INTER1MV
INTRA     = 1
INTERBIDI = 2
INTRABIDI = 3
INTER4MV  = 4
INTERSLF  = 2

IsINTRA   = 1  ; Mask to check for INTRA or INTER
IsBIDI    = 2  ; Mask to check for BIDI or not
Is4MV     = 4  ; Mask to check for 4 motion vectors or just 1.

LeftEdge   = 1 ; Mask to indicate MB is at left edge of picture.
RightEdge  = 2 ; Mask to indicate MB is at right edge of picture.
TopEdge    = 4 ; Mask to indicate MB is at top edge of picture.
BottomEdge = 8 ; Mask to indicate MB is at bottom edge of picture.
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5fdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5fdct.asv   1.5   14 May 1996 12:18:50   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\ex5fdct.asv  $
;// 
;//    Rev 1.5   14 May 1996 12:18:50   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.4   11 Apr 1996 16:02:06   AKASAI
;// Updated H261 encoder to new interface and macroblock action stream
;// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
;// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
;// 
;// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
;// not assembled for H261.
;// 
;//    Rev 1.3   24 Jan 1996 13:21:28   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.1   27 Dec 1995 15:32:42   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; e35fdct -- This function performs a Forward Discrete Cosine Transform for H263, on a stream of macroblocks comprised
;            of 8*8 blocks of pels or pel diffs.  This version is tuned for the Pentium Microprocessor.
;
; Arguments:
;
;   MBlockActionStream (Input)
;
;     A stream of MacroBlock Action Descriptors.  Each descriptor indicates which blocks of a macroblock are non-empty
;     and thus need to be transformed.  There are from 0 to 12 non-empty blocks in each macroblock.
;
;     Processing commences with the macroblock described by the first descriptor in the stream (regardless of whether
;     it's End-Of-Stream bit is set).  Processing continues up to but not including the next descriptor that has the
;     End-Of-Stream bit set.
;
;     This function requires each descripgor in the MBlockActionStream to be 16-byte aligned.  Moreover, each of the
;     T_Blk elements in the descriptor must also be 16-byte aligned, and ordered as they are now.  (Note that I am
;     talking about the address of these pointer variables, not the alignement of the data they point to.)
;
;     Best performance will be attained when 8*8 blocks are (or usually are) DWORD aligned.  MMx implementations will
;     probably prefer 8-byte alignment.
;
;     The complete format of the MacroBlock Action Descriptors is provided in e3mbad.inc.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.  When doing B frames, this
;                             is the Target B Frame Base Address.
;
;   PreviousFrameBaseAddress -- Address of the reconstructed previous frame.  This really isn't needed for P-frame
;                               processing, estimation since the address of each block's prediction was recorded by
;                               MotionEstimation.  It's only used by B-frame processing.
;
;   FutureFrameBaseAddress -- Address of the reconstructed future (a.k.a. current) P-frame.  Only used when processing
;                             B frames.
;
;   CoeffStream (Output)
;
;     A stream of storage blocks which receive the DCT output coefficient
;     blocks for each non-empty blocks described in the MBlockActionStream.
;     Each coefficient block is 128 bytes.  The stream must be large enough
;     to hold all the output coefficient blocks.
;
;     Best performance will be attained by assuring the storage is 32-byte
;     aligned.  Best performance will be attained by using the output before
;     the data cache gets changed by other data.  Consuming the coefficient
;     blocks in forward order is best, since they are defined in reverse
;     order (and thus the first blocks are most likely to be in cache).
;
;     The complete format of the coefficient blocks is provided in encdctc.inc.
;
;   IsBFrame (Input)
;
;     0 (False) if doing Key or P frame.  1 (True) if doing B frame.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include e3dctc.inc   ; DCT Coefficient block layout

.xlist
include memmodel.inc
.list
.DATA

InitTbl MACRO WeightHi,WeightLo,TableLabel
TableLabel LABEL DWORD
  CNT = -128
  REPEAT 128
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)+((WeightLo*CNT-08000H)/010000H)
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)-((WeightLo*CNT-08000H)/010000H)
   CNT = CNT + 1
  ENDM
  REPEAT 128
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)+((WeightLo*CNT+08000H)/010000H)
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)-((WeightLo*CNT+08000H)/010000H)
   CNT = CNT + 1
  ENDM
ENDM

InitTbl  080000H,04545FH,P80000_P4545F
P80000_N4545F = P80000_P4545F + 4

InitTbl  080000H,0A73D7H,P80000_PA73D7
P80000_NA73D7 = P80000_PA73D7 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl  02350BH, 06491AH,P2350B_P6491A
P2350B_N6491A = P2350B_P6491A + 4

InitTbl -0B18A8H,-096831H,NB18A8_N96831
NB18A8_P96831 = NB18A8_N96831 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl -096831H, 02350BH,N96831_P2350B
N96831_N2350B = N96831_P2350B + 4

InitTbl 06491AH, 0B18A8H,P6491A_PB18A8
P6491A_NB18A8 = P6491A_PB18A8 + 4

IFNDEF H261
ColsDefined        DD 000000000H,000000000H,07F7F7F7FH,07F7F7F7FH
                   DD 000000000H,07F7F7F00H,07F7F7F7FH,00000007FH
                   DD 000000000H,07F7F0000H,07F7F7F7FH,000007F7FH
                   DD 000000000H,07F000000H,07F7F7F7FH,0007F7F7FH,000000000H

                           ;  Right   Left  Chroma
                   DB   0  ;         -22.0
                   DB   0  ;         -21.5
                   DB   0  ;         -21.0
                   DB   0  ;         -20.5
                   DB   0  ;         -20.0
                   DB   0  ;         -19.5
                   DB   0  ;         -19.0
                   DB   0  ;         -18.5
                   DB   0  ;         -18.0
                   DB   0  ;         -17.5
                   DB   0  ;         -17.0
                   DB   0  ;         -16.5
                   DB   0  ;         -16.0
                   DB   0  ;         -15.5
                   DB   0  ;         -15.0
                   DB   0  ;         -14.5
                   DB   0  ;  -22.0  -14.0
                   DB   0  ;  -21.5  -13.5
                   DB   0  ;  -21.0  -13.0
                   DB   0  ;  -20.5  -12.5
                   DB   0  ;  -20.0  -12.0
                   DB   0  ;  -19.5  -11.5
                   DB   0  ;  -19.0  -11.0
                   DB   0  ;  -18.5  -10.5
                   DB   0  ;  -18.0  -10.0
                   DB   0  ;  -17.5   -9.5
                   DB   0  ;  -17.0   -9.0
                   DB   0  ;  -16.5   -8.5
                   DB   0  ;  -16.0   -8.0
                   DB   0  ;  -15.5   -7.5
                   DB  48  ;  -15.0   -7.0
                   DB  48  ;  -14.5   -6.5
                   DB  32  ;  -14.0   -6.0
                   DB  32  ;  -13.5   -5.5
                   DB  16  ;  -13.0   -5.0
                   DB  16  ;  -12.5   -4.5
                   DB   4  ;  -12.0   -4.0
                   DB   4  ;  -11.5   -3.5
                   DB  52  ;  -11.0   -3.0
                   DB  52  ;  -10.5   -2.5
                   DB  36  ;  -10.0   -2.0
                   DB  36  ;   -9.5   -1.5
                   DB  20  ;   -9.0   -1.0
                   DB  20  ;   -8.5    -.5
LeftYBlkColsDef    DB   8  ;   -8.0      0
                   DB   8  ;   -7.5     .5
                   DB   8  ;   -7.0    1.0
                   DB   8  ;   -6.5    1.5
                   DB   8  ;   -6.0    2.0
                   DB   8  ;   -5.5    2.5
                   DB   8  ;   -5.0    3.0
                   DB   8  ;   -4.5    3.5
                   DB   8  ;   -4.0    4.0
                   DB   8  ;   -3.5    4.5
                   DB   8  ;   -3.0    5.0
                   DB   8  ;   -2.5    5.5
                   DB   8  ;   -2.0    6.0
                   DB   8  ;   -1.5    6.5
                   DB   8  ;   -1.0    7.0
                   DB   8  ;    -.5    7.5
RightYBlkColsDef   DB   8  ;      0    8.0
                   DB  56  ;     .5    8.5
                   DB  56  ;    1.0    9.0
                   DB  40  ;    1.5    9.5
                   DB  40  ;    2.0   10.0
                   DB  24  ;    2.5   10.5
                   DB  24  ;    3.0   11.0
                   DB  12  ;    3.5   11.5
                   DB  12  ;    4.0   12.0
                   DB  60  ;    4.5   12.5
                   DB  60  ;    5.0   13.0
                   DB  44  ;    5.5   13.5
                   DB  44  ;    6.0   14.0
                   DB  28  ;    6.5   14.5
                   DB  28  ;    7.0   15.0
                   DB   0  ;    7.5   15.5
                   DB   0  ;    8.0   16.0
                   DB   0  ;    8.5   16.5
                   DB   0  ;    9.0   17.0
                   DB   0  ;    9.5   17.5
                   DB   0  ;   10.0   18.0
                   DB   0  ;   10.5   18.5
                   DB   0  ;   11.0   19.0
                   DB   0  ;   11.5   19.5
                   DB   0  ;   12.0   20.0
                   DB   0  ;   12.5   20.5
                   DB   0  ;   13.0   21.0
                   DB   0  ;   13.5   21.5
                   DB   0  ;   14.0   22.0
                   DB   0  ;   14.5
                   DB   0  ;   15.0
                   DB   0  ;   15.5
                   DB   0  ;   16.0
                   DB   0  ;   16.5
                   DB   0  ;   17.0
                   DB   0  ;   17.5
                   DB   0  ;   18.0
                   DB   0  ;   18.5         -11.0
                   DB   0  ;   19.0         -10.5
                   DB   0  ;   19.5         -10.0
                   DB   0  ;   20.0          -9.5
                   DB   0  ;   20.5          -9.0
                   DB   0  ;   21.0          -8.5
                   DB   0  ;   21.5          -8.0
                   DB   0  ;   22.0          -7.5
                   DB  48  ;                 -7.0
                   DB  48  ;                 -6.5
                   DB  32  ;                 -6.0
                   DB  32  ;                 -5.5
                   DB  16  ;                 -5.0
                   DB  16  ;                 -4.5
                   DB   4  ;                 -4.0
                   DB   4  ;                 -3.5
                   DB  52  ;                 -3.0
                   DB  52  ;                 -2.5
                   DB  36  ;                 -2.0
                   DB  36  ;                 -1.5
                   DB  20  ;                 -1.0
                   DB  20  ;                  -.5
ChromaColsDef      DB   8  ;                    0
                   DB  56  ;                   .5
                   DB  56  ;                  1.0
                   DB  40  ;                  1.5
                   DB  40  ;                  2.0
                   DB  24  ;                  2.5
                   DB  24  ;                  3.0
                   DB  12  ;                  3.5
                   DB  12  ;                  4.0
                   DB  60  ;                  4.5
                   DB  60  ;                  5.0
                   DB  44  ;                  5.5
                   DB  44  ;                  6.0
                   DB  28  ;                  6.5
                   DB  28  ;                  7.0
                   DB   0  ;                  7.5
                   DB   0  ;                  8.0
                   DB   0  ;                  8.5
                   DB   0  ;                  9.0
                   DB   0  ;                  9.5
                   DB   0  ;                 10.0
                   DB   0  ;                 10.5
                   DB   0  ;                 11.0

                           ;  Lower  Upper  Chroma
                   DB 000H ;         -22.0
                   DB 000H ;         -21.5
                   DB 000H ;         -21.0
                   DB 000H ;         -20.5
                   DB 000H ;         -20.0
                   DB 000H ;         -19.5
                   DB 000H ;         -19.0
                   DB 000H ;         -18.5
                   DB 000H ;         -18.0
                   DB 000H ;         -17.5
                   DB 000H ;         -17.0
                   DB 000H ;         -16.5
                   DB 000H ;         -16.0
                   DB 000H ;         -15.5
                   DB 000H ;         -15.0
                   DB 000H ;         -14.5
                   DB 000H ;  -22.0  -14.0
                   DB 000H ;  -21.5  -13.5
                   DB 000H ;  -21.0  -13.0
                   DB 000H ;  -20.5  -12.5
                   DB 000H ;  -20.0  -12.0
                   DB 000H ;  -19.5  -11.5
                   DB 000H ;  -19.0  -11.0
                   DB 000H ;  -18.5  -10.5
                   DB 000H ;  -18.0  -10.0
                   DB 000H ;  -17.5   -9.5
                   DB 000H ;  -17.0   -9.0
                   DB 000H ;  -16.5   -8.5
                   DB 000H ;  -16.0   -8.0
                   DB 000H ;  -15.5   -7.5
                   DB 001H ;  -15.0   -7.0
                   DB 001H ;  -14.5   -6.5
                   DB 003H ;  -14.0   -6.0
                   DB 003H ;  -13.5   -5.5
                   DB 007H ;  -13.0   -5.0
                   DB 007H ;  -12.5   -4.5
                   DB 00FH ;  -12.0   -4.0
                   DB 00FH ;  -11.5   -3.5
                   DB 01FH ;  -11.0   -3.0
                   DB 01FH ;  -10.5   -2.5
                   DB 03FH ;  -10.0   -2.0
                   DB 03FH ;   -9.5   -1.5
                   DB 07FH ;   -9.0   -1.0
                   DB 07FH ;   -8.5    -.5
UpperYBlkLinesDef  DB 0FFH ;   -8.0      0
                   DB 0FFH ;   -7.5     .5
                   DB 0FFH ;   -7.0    1.0
                   DB 0FFH ;   -6.5    1.5
                   DB 0FFH ;   -6.0    2.0
                   DB 0FFH ;   -5.5    2.5
                   DB 0FFH ;   -5.0    3.0
                   DB 0FFH ;   -4.5    3.5
                   DB 0FFH ;   -4.0    4.0
                   DB 0FFH ;   -3.5    4.5
                   DB 0FFH ;   -3.0    5.0
                   DB 0FFH ;   -2.5    5.5
                   DB 0FFH ;   -2.0    6.0
                   DB 0FFH ;   -1.5    6.5
                   DB 0FFH ;   -1.0    7.0
                   DB 0FFH ;    -.5    7.5
LowerYBlkLinesDef  DB 0FFH ;      0    8.0
                   DB 0FEH ;     .5    8.5
                   DB 0FEH ;    1.0    9.0
                   DB 0FCH ;    1.5    9.5
                   DB 0FCH ;    2.0   10.0
                   DB 0F8H ;    2.5   10.5
                   DB 0F8H ;    3.0   11.0
                   DB 0F0H ;    3.5   11.5
                   DB 0F0H ;    4.0   12.0
                   DB 0E0H ;    4.5   12.5
                   DB 0E0H ;    5.0   13.0
                   DB 0C0H ;    5.5   13.5
                   DB 0C0H ;    6.0   14.0
                   DB 080H ;    6.5   14.5
                   DB 080H ;    7.0   15.0
                   DB 000H ;    7.5   15.5
                   DB 000H ;    8.0   16.0
                   DB 000H ;    8.5   16.5
                   DB 000H ;    9.0   17.0
                   DB 000H ;    9.5   17.5
                   DB 000H ;   10.0   18.0
                   DB 000H ;   10.5   18.5
                   DB 000H ;   11.0   19.0
                   DB 000H ;   11.5   19.5
                   DB 000H ;   12.0   20.0
                   DB 000H ;   12.5   20.5
                   DB 000H ;   13.0   21.0
                   DB 000H ;   13.5   21.5
                   DB 000H ;   14.0   22.0
                   DB 000H ;   14.5
                   DB 000H ;   15.0
                   DB 000H ;   15.5
                   DB 000H ;   16.0
                   DB 000H ;   16.5
                   DB 000H ;   17.0
                   DB 000H ;   17.5
                   DB 000H ;   18.0
                   DB 000H ;   18.5         -11.0
                   DB 000H ;   19.0         -10.5
                   DB 000H ;   19.5         -10.0
                   DB 000H ;   20.0          -9.5
                   DB 000H ;   20.5          -9.0
                   DB 000H ;   21.0          -8.5
                   DB 000H ;   21.5          -8.0
                   DB 000H ;   22.0          -7.5
                   DB 001H ;                 -7.0
                   DB 001H ;                 -6.5
                   DB 003H ;                 -6.0
                   DB 003H ;                 -5.5
                   DB 007H ;                 -5.0
                   DB 007H ;                 -4.5
                   DB 00FH ;                 -4.0
                   DB 00FH ;                 -3.5
                   DB 01FH ;                 -3.0
                   DB 01FH ;                 -2.5
                   DB 03FH ;                 -2.0
                   DB 03FH ;                 -1.5
                   DB 07FH ;                 -1.0
                   DB 07FH ;                  -.5
ChromaLinesDef     DB 0FFH ;                    0
                   DB 0FEH ;                   .5
                   DB 0FEH ;                  1.0
                   DB 0FCH ;                  1.5
                   DB 0FCH ;                  2.0
                   DB 0F8H ;                  2.5
                   DB 0F8H ;                  3.0
                   DB 0F0H ;                  3.5
                   DB 0F0H ;                  4.0
                   DB 0E0H ;                  4.5
                   DB 0E0H ;                  5.0
                   DB 0C0H ;                  5.5
                   DB 0C0H ;                  6.0
                   DB 080H ;                  6.5
                   DB 080H ;                  7.0
                   DB 000H ;                  7.5
                   DB 000H ;                  8.0
                   DB 000H ;                  8.5
                   DB 000H ;                  9.0
                   DB 000H ;                  9.5
                   DB 000H ;                 10.0
                   DB 000H ;                 10.5
                   DB 000H ;                 11.0
ENDIF

.CODE

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

FORWARDDCT proc C AMBlockActionStream:       DWORD,
ATargetFrameBaseAddress: DWORD, APreviousFrameBaseAddress: DWORD, 
AFutureFrameBaseAddress: DWORD, ACoeffStream: DWORD, AIsBFrame: DWORD,
AIsAdvancedPrediction: DWORD, AIsPOfPBPair: DWORD, AScratchBlocks: DWORD,
ANumMBlksInGOB: DWORD

LocalFrameSize = 196
RegisterStorageSize = 16

; Arguments:

MBlockActionStream                    = RegisterStorageSize +  4
TargetFrameBaseAddress_arg            = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg          = RegisterStorageSize + 12
FutureFrameBaseAddress_arg            = RegisterStorageSize + 16
CoeffStream_arg                       = RegisterStorageSize + 20
IsBFrame                              = RegisterStorageSize + 24
IsAdvancedPrediction                  = RegisterStorageSize + 28
IsPOfPBPair                           = RegisterStorageSize + 32
ScratchBlocks                         = RegisterStorageSize + 36
NumMBlksInGOB                         = RegisterStorageSize + 40
EndOfArgList                          = RegisterStorageSize + 44

; Locals (on local stack frame)

P00                      EQU [esp+  8] ; Biased Pels or Biased Pel Differences
P01                      EQU [esp+  9]
P02                      EQU [esp+ 10]
P03                      EQU [esp+ 11]
P04                      EQU [esp+ 12]
P05                      EQU [esp+ 13]
P06                      EQU [esp+ 14]
P07                      EQU [esp+ 15]
P10                      EQU [esp+ 16]
P11                      EQU [esp+ 17]
P12                      EQU [esp+ 18]
P13                      EQU [esp+ 19]
P14                      EQU [esp+ 20]
P15                      EQU [esp+ 21]
P16                      EQU [esp+ 22]
P17                      EQU [esp+ 23]
P20                      EQU [esp+ 24]
P21                      EQU [esp+ 25]
P22                      EQU [esp+ 26]
P23                      EQU [esp+ 27]
P24                      EQU [esp+ 28]
P25                      EQU [esp+ 29]
P26                      EQU [esp+ 30]
P27                      EQU [esp+ 31]
P30                      EQU [esp+ 32]
P31                      EQU [esp+ 33]
P32                      EQU [esp+ 34]
P33                      EQU [esp+ 35]
P34                      EQU [esp+ 36]
P35                      EQU [esp+ 37]
P36                      EQU [esp+ 38]
P37                      EQU [esp+ 39]
P40                      EQU [esp+ 40]
P41                      EQU [esp+ 41]
P42                      EQU [esp+ 42]
P43                      EQU [esp+ 43]
P44                      EQU [esp+ 44]
P45                      EQU [esp+ 45]
P46                      EQU [esp+ 46]
P47                      EQU [esp+ 47]
P50                      EQU [esp+ 48]
P51                      EQU [esp+ 49]
P52                      EQU [esp+ 50]
P53                      EQU [esp+ 51]
P54                      EQU [esp+ 52]
P55                      EQU [esp+ 53]
P56                      EQU [esp+ 54]
P57                      EQU [esp+ 55]
P60                      EQU [esp+ 56]
P61                      EQU [esp+ 57]
P62                      EQU [esp+ 58]
P63                      EQU [esp+ 59]
P64                      EQU [esp+ 60]
P65                      EQU [esp+ 61]
P66                      EQU [esp+ 62]
P67                      EQU [esp+ 63]
P70                      EQU [esp+ 64]
P71                      EQU [esp+ 65]
P72                      EQU [esp+ 66]
P73                      EQU [esp+ 67]
P74                      EQU [esp+ 68]
P75                      EQU [esp+ 69]
P76                      EQU [esp+ 70]
P77                      EQU [esp+ 71]
I00I02                   EQU  P00  ; Intermed for row 0, columns 0 and 2. 
I01I03                   EQU  P04  ; Share storage with pels.
I04I06                   EQU [esp+ 72]
Mask00                   EQU [esp+ 72]
I07I05                   EQU [esp+ 76]
Mask04                   EQU [esp+ 76]
I10I12                   EQU  P10
I11I13                   EQU  P14
I14I16                   EQU [esp+ 80]
Mask10                   EQU [esp+ 80]
I17I15                   EQU [esp+ 84]
Mask14                   EQU [esp+ 84]
I20I22                   EQU  P20
I21I23                   EQU  P24
I24I26                   EQU [esp+ 88]
Mask20                   EQU [esp+ 88]
I27I25                   EQU [esp+ 92]
Mask24                   EQU [esp+ 92]
I30I32                   EQU  P30
I31I33                   EQU  P34
I34I36                   EQU [esp+ 96]
Mask30                   EQU [esp+ 96]
I37I35                   EQU [esp+100]
Mask34                   EQU [esp+100]
I40I42                   EQU  P40
I41I43                   EQU  P44
I44I46                   EQU [esp+104]
Mask40                   EQU [esp+104]
I47I45                   EQU [esp+108]
Mask44                   EQU [esp+108]
I50I52                   EQU  P50
I51I53                   EQU  P54
I54I56                   EQU [esp+112]
Mask50                   EQU [esp+112]
I57I55                   EQU [esp+116]
Mask54                   EQU [esp+116]
I60I62                   EQU  P60
I61I63                   EQU  P64
I64I66                   EQU [esp+120]
Mask60                   EQU [esp+120]
I67I65                   EQU [esp+124]
Mask64                   EQU [esp+124]
I70I72                   EQU  P70
I71I73                   EQU  P74
I74I76                   EQU [esp+128]
Mask70                   EQU [esp+128]
I77I75                   EQU [esp+132]
Mask74                   EQU [esp+132]
S4                       EQU  I10I12  ; Temp storage, shared.
S7                       EQU  I00I02  ; Temp storage, shared.
S3                       EQU  I30I32  ; Temp storage, shared.
S0                       EQU  I40I42  ; Temp storage, shared.

CoeffStreamStart         EQU [esp+  0]
CoeffStream              EQU [esp+  4]
BlkActionDescrAddr       EQU [esp+136]
FutureFrameBaseAddress   EQU [esp+140]
DistFromTargetToPastP    EQU [esp+144]
TargetFrameBaseAddress   EQU [esp+148]
PredictionsBaseAddress   EQU [esp+152]
IsPlainPFrame            EQU [esp+156]
PreviousFrameBaseAddress EQU [esp+160]
DistToBlockToLeft        EQU [esp+164]
DistToBlockAbove         EQU [esp+168]
DistToBlockToRight       EQU [esp+172]
DistToBlockBelow         EQU [esp+176]
DistFromBlk1ToBlk3Above  EQU [esp+180]
MBActionCursor           EQU [esp+184]
CentralRefAddrAndInterps EQU [esp+188]
StashESP                 EQU [esp+192]

  push  esi
   push edi
  push  ebp
   push ebx
  mov   ebx,esp
  sub   esp,LocalFrameSize+4
   mov  edi,[ebx+CoeffStream_arg]           ; Get address of storage for coeffs.
  and   esp,0FFFFFFC0H                      ; Get 64-byte aligned.
   xor  ebp,ebp
  add   esp,4                               ; esp at cache line plus 4.
   mov  esi,[ebx+MBlockActionStream]        ; Get address of MB action stream.
  mov   StashESP,ebx
   mov  edx,[ebx+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,edx
   mov  eax,[ebx+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   sub  eax,edx
  mov   ecx,[ebx+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,ecx
   mov  DistFromTargetToPastP,eax
  mov   CoeffStreamStart,edi
   xor  eax,eax
  xor   ecx,ecx

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
   cmp  ebp,[ebx+IsBFrame]
  mov   edx,PITCH
   jne  NextBMacroBlock

  cmp   ebp,[ebx+IsAdvancedPrediction]
   je   NextMacroBlock

  mov   eax,[ebx+ScratchBlocks]   ; We must do OBMC.
   mov  ecx,[esi].BlkY1.BlkOffset
  sub   eax,ecx
   mov  ebp,[ebx+IsPOfPBPair]
  xor   ebp,1
   mov  PredictionsBaseAddress,eax
  mov   IsPlainPFrame,ebp
   mov  ebp,[ebx+NumMBlksInGOB]
  imul  ebp,-SIZEOF T_MacroBlockActionDescr
  add   ebp,2*SIZEOF T_Blk
  mov   DistFromBlk1ToBlk3Above,ebp
  

;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  edx -- Address of a block to do
;  bl  -- BlockType;
;         MB edge condition:  1 off if left edge | 2: right | 4: top | 8: bottom
;  eax -- Coded block pattern for P block;
;         (Block_number - 1) *  SIZEOF T_Blk

NextMacroBlock_OBMC:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks        ; Bits  0- 3  set for non-empty Y blks.
                                       ; Bit      4  set for non-empty U blk.
                                       ; Bit      5  set for non-empty V blk.
                                       ; Bit      6  clear except at stream end.
                                       ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded_OBMC

  lea   edx,[esi].BlkY1+12             ; Addr of block addr (plus 12).
   test al,1                           ; Check if block 1 empty.
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block1DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax           ; Blk to left is blk 2 of mb to the left, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToLeft,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 2 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 3 of current macroblock.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY1
   jmp  BuildOBMCPrediction

Block1DescrBuilt:

  test  al,2                           ; Check if block 2 empty.
   lea  edx,[esi].BlkY2+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block2DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax          ; Blk to right is blk 1 of mb to right, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToRight,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,-SIZEOF T_Blk ; Blk to left is blk 1 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 4 of current macroblock.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY2
   jmp  BuildOBMCPrediction

Block1or2DescrBuilt:

  mov   al,PB [esi].CodedBlocks         ; Bits  0- 3  set for non-empty Y blks.
   mov  edi,CoeffStream                 ; Restore block descriptor ptr.
  jl    Block1DescrBuilt

Block2DescrBuilt:

  test  al,4                           ; Check if block 3 empty.
   lea  edx,[esi].BlkY3+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block3DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to left is blk 4 of mb to the left, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 1 of current mb.
  mov   DistToBlockToLeft,eax
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 4 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY3
   jmp  BuildOBMCPrediction

Block3DescrBuilt:

  test  al,8                           ; Check if block 4 empty.
   lea  edx,[esi].BlkY4+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block4DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to right is blk 3 of mb to right, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 2 of current mb.
  mov   DistToBlockToRight,eax
   mov  eax,-SIZEOF T_Blk  ; Blk to left is blk 3 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY4

BuildOBMCPrediction:

;  esi -- MacroBlockActionStream cursor
;  ebp -- T_MacroBlockActionDescr.BlkYN
;  edi -- Address at which to put prediction block

  mov   edi,PredictionsBaseAddress
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset; BlkOffset
  add   edi,eax                        ; Compute addr at which to put OBMC pred.
   mov  eax,[esi+ebp*1].T_Blk.MVs      ; al = horz MV;  ah = vert MV.
  test  eax,1
   mov  edx,[esi+ebp*1].T_Blk.PastRef  ; Fetch address for ref block.
  mov   MBActionCursor,esi
   jne  HorzInterpInCentralPred

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,PITCH
   jne  VertInterpInCentralPred

  ; No half pel interpolation for central point required.  Just copy it.

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8-080000000H    ; Address of ref, xor 10 in high 2 bits.
  jmp   CentralPredGottenForOBMC

HorzInterpInCentralPred:

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,1
   jne  BothInterpInCentralPred

VertInterpInCentralPred:

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  add   eax,[edx+ecx+0]
   add  ebx,[edx+ecx+4]
  add   eax,001010101H
   add  ebx,001010101H
  shr   eax,1
   and  ebx,0FEFEFEFEH
  shr   ebx,1
   and  eax,07F7F7F7FH
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8
  shl   ecx,30
  xor   edx,ecx            ; Address of ref, xor 00 in high 2 bits if vertically
  ;                        ; interpolated;  xor 01 if horizontally interpolated.
   jmp  CentralPredGottenForOBMC

BothInterpInCentralPred:
@@:
   
  mov   eax,[edx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[edx]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment OBMC prediction block pointer.
  mov   ecx,[edx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[edx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,ecx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  edx,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  eax,4
  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   and  eax,edi
  mov   [edi-4],ebx
   mov  [edi+8-4],ebx
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8         ; Advance to next line of block.
   add  edx,PITCH-8         ; Advance to next line of block.
  add   ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
   jnc  @b

   sub  edx,PITCH*8
  xor   edx,0C0000000H      ; Address of ref, xor 11 in high 2 bits.
   sub  edi,PITCH*8

CentralPredGottenForOBMC:

;  At this point, the central contribution to OBMC prediction is in its scratch
;  block, whose address has been written to PastRef in the block action descr.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to left.

  mov   eax,DistToBlockToLeft
   lea  ebx,[esi+ebp]
  add   ebx,eax            ; Address of block descriptor for block to the left.
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx            ; Address of macroblock descr for block to the left.
   mov  ah,IsPlainPFrame   ; 0 if P of PB;  1 if run-of-the-mill P frame.
  mov   ebx,[ebx].T_Blk.MVs
   mov  CentralRefAddrAndInterps,edx  ; Stash function of ref addr and interps.
  mov   al,[ecx].BlockType ; Bottom bit set if left neighbor is INTRA.
   mov  cl,bh
  and   al,ah              ; 0 if PB frame or if not INTRA
   jne  LeftPredGottenForOBMC  ; Jump if INTRA in plain P frame.  (Use central)
   
  shl   ebx,24             ; Get horz MV in [24:31].
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1              ; CF==1 if interp vertically.
   jc   InterpVertForTheLeftContrib

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpHorzForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,080000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also was not interpolated.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0]
  mov   [edi+PITCH*0+8],ebx
   mov  ebx,[ecx+PITCH*1]
  mov   [edi+PITCH*1+8],ebx
   mov  ebx,[ecx+PITCH*2]
  mov   [edi+PITCH*2+8],ebx
   mov  ebx,[ecx+PITCH*3]
  mov   [edi+PITCH*3+8],ebx
   mov  ebx,[ecx+PITCH*4]
  mov   [edi+PITCH*4+8],ebx
   mov  ebx,[ecx+PITCH*5]
  mov   [edi+PITCH*5+8],ebx
   mov  ebx,[ecx+PITCH*6]
  mov   [edi+PITCH*6+8],ebx
   mov  ebx,[ecx+PITCH*7]
  mov   [edi+PITCH*7+8],ebx
   jmp  LeftPredGottenForOBMC

InterpVertForTheLeftContrib:

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpBothForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax            ; Continue to accumulate left ref addr in eax.
  ;                        ; Hi 2 bits of central ref same as this ref if
  ;                        ; central ref also interpolated vertically.
  add   ecx,ebx            ; Finish accumulating left ref addr in ecx.
   mov  ebx,PITCH
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

DoInterpHorzForTheLeftContrib:
@@:

  mov   eax,[ecx+0]
   add  edi,PITCH
  mov   edx,[ecx+ebx+0]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+ 8-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpBothForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,0C0000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated both ways.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

@@:

  mov   eax,[ecx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[ecx]           ; <P03 P02 P01 P00>.
   add  edi,PITCH           ; Pre-increment OBMC prediction block pointer.
  mov   edx,[ecx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[ecx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,edx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  ecx,PITCH           ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.

  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   add  ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
  mov   [edi+8-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpHorzForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,040000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated horizontally.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
   mov  ebx,1
  cmp   ecx,edx            ; Is central ref the same?
   jne  DoInterpHorzForTheLeftContrib


LeftPredGottenForOBMC:

;  At this point, the left contribution to OBMC prediction is in its scratch
;  half block.  Now do the right contribution.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to right.

  mov   eax,DistToBlockToRight
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps  ; Reload function of ref addr and interps.
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  RightPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheRightContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+12],ebx
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+12],ebx
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+12],ebx
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+12],ebx
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+12],ebx
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+12],ebx
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+12],ebx
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+12],ebx
   jmp  RightPredGottenForOBMC

InterpVertForTheRightContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   RightPredGottenForOBMC

DoInterpHorzForTheRightContrib:
@@:

  mov   eax,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+ebx+4]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpBothForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

@@:

  mov   eax,[ecx+5]
   mov  esi,001010101H
  mov   ebx,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+PITCH+5]
   add  eax,ebx
  mov   ebx,[ecx+PITCH+4]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,PITCH
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax

  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpHorzForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheRightContrib

RightPredGottenForOBMC:

;  At this point, the left and right contributions to OBMC prediction are in
;  their scratch half blocks.  Now do the contribution for the block above.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockAbove
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  AbovePredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheAboveContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

  mov   edx,[ecx+PITCH*0+0]
   mov  ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+28],edx
   mov  [edi+PITCH*0+32],ebx
  mov   edx,[ecx+PITCH*1+0]
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+32],ebx
   mov  [edi+PITCH*1+28],edx
  mov   edx,[ecx+PITCH*2+0]
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+28],edx
   mov  [edi+PITCH*2+32],ebx
  mov   edx,[ecx+PITCH*3+0]
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+32],ebx
   mov  [edi+PITCH*3+28],edx
  jmp   AbovePredGottenForOBMC

InterpVertForTheAboveContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

DoInterpHorzForTheAboveContrib:
@@:

  mov   eax,[ecx+0]
   mov  edx,[ecx+4]
  add   eax,[ecx+ebx+0]
   add  edx,[ecx+ebx+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+28],eax
   mov  [edi+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpBothForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

@@:

  mov   eax,[ecx+1]
   mov  esi,001010101H
  mov   ebx,[ecx]
   add  edi,4
  mov   edx,[ecx+PITCH+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpHorzForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheAboveContrib

AbovePredGottenForOBMC:

;  At this point, the left, right, and above contributions to OBMC prediction
;  are in their scratch half blocks.  Now do contribution for the block below.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockBelow
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  BelowPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheBelowContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

  mov   edx,[ecx+PITCH*4+0]
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+28],edx
   mov  [edi+PITCH*4+32],ebx
  mov   edx,[ecx+PITCH*5+0]
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+32],ebx
   mov  [edi+PITCH*5+28],edx
  mov   edx,[ecx+PITCH*6+0]
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+28],edx
   mov  [edi+PITCH*6+32],ebx
  mov   edx,[ecx+PITCH*7+0]
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+32],ebx
   mov  [edi+PITCH*7+28],edx
  jmp   BelowPredGottenForOBMC

InterpVertForTheBelowContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
  add   ecx,eax
   mov  ebx,PITCH
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

DoInterpHorzForTheBelowContrib:
@@:

  mov   eax,[ecx+PITCH*4+0]
   mov  edx,[ecx+PITCH*4+4]
  add   eax,[ecx+ebx+PITCH*4+0]
   add  edx,[ecx+ebx+PITCH*4+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+PITCH*4+28],eax
   mov  [edi+PITCH*4+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpBothForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

@@:

  mov   eax,[ecx+PITCH*4+1]
   mov  esi,001010101H
  mov   ebx,[ecx+PITCH*4]
   add  edi,4
  mov   edx,[ecx+PITCH*5+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH*5]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+PITCH*4+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpHorzForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheBelowContrib

BelowPredGottenForOBMC:

;  At this point all the contributions to OBMC prediction are in their scratch
; half blocks.  Now combine them to get the OBMC prediction.
;
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
  
@@:

  mov   eax,[edi+4]             ; <C07 C05 C05 C04> or <C77 C76 C75 C74>
   mov  ebx,[edi+12]            ; <R07 R06 R05 R04> or <R77 R76 R75 R74>
  mov   ecx,[edi+32]            ; <A07 A06 A05 A04> or <B77 B76 B75 B74>
   mov  esi,[edi]               ; <C03 C02 C01 C00> or <C73 C72 C71 C70>
  lea   edx,[eax+ebx]           ; <junk C6+R6 C5+R5 C4+R4>
   and  ebx,0FF000000H          ; <R7 __ __ __>
  shr   edx,1                   ; <junk (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> dirty
   add  ecx,ebx                 ; <A7+R7 A6 A5 A4>
  and   edx,0007F7F7FH          ; <__ (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> clean
   mov  ebx,[edi+8]             ; <L03 L02 L01 L00> or <L73 L72 L71 L70>
  add   edx,ecx                 ; <(2A7+2R7)/2 (2A6+C5+R5)/2 ...>
   add  edi,PITCH*7             ; Move from line 0 to 7 (or 7 to 14)
  shr   edx,1                   ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> dirty
   add  ebx,esi                 ; <C3+L3 C2+L2 C1+L1 junk>
  shr   ebx,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> dirty
   and  edx,07F7F7F7FH          ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> clean
   mov  ecx,[edi+28-PITCH*7]    ; <A03 A02 A01 A00> or <B73 B72 B71 B70>
  lea   eax,[eax+edx+001010101H]; <(2A7+4C7+2R7+4)/4 (2A6+5C5+R5+4)/4 ...>
   mov  bl,[edi+8-PITCH*7]      ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 L0>
  shr   eax,1                   ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> dirty
   add  ebx,ecx                 ; <... (2A1+C1+L1)/2 (2A0+2L0)/2>
  shr   ebx,1                   ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> dirty
   and  eax,07F7F7F7FH          ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> clean
  and   ebx,07F7F7F7FH          ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> clean
   add  esi,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  add   ebx,esi                 ; <... (2A1+5C1+L1+4)/4 (2A0+4C0+2L0+4)/4>
   mov  [edi+4-PITCH*7],eax     ; Store OBMC pred for pels 4-7 of line 0 or 7.
  shr   ebx,1                   ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> dirty
   lea  esi,[edi-PITCH*13]      ; Speculatively advance to line 1.
  and   ebx,07F7F7F7FH          ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> clean
   add  ebp,080000000H
  mov   [edi-PITCH*7],ebx       ; Store OBMC pred for pels 0-3 of line 0 or 7.
   jnc  @b

@@:

  mov   edx,[esi+28]            ; <A13 A12 A11 A10> or <B63 B62 B61 B60>
   mov  eax,[esi+8]             ; <L13 L12 L11 L10> or <L63 L62 L61 L60>
  mov   ecx,[esi+32]            ; <A17 A16 A15 A14> or <B67 B66 B65 B64>
   mov  ebx,[esi+12]            ; <R17 R16 R15 R14> or <R67 R66 R65 R64>
  mov   edi,[esi]               ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   add  esi,PITCH*5             ; Move from line 1 to 6 (or 6 to 11)
  xchg  dx,ax                   ; edx: <A3 A2 L1 L0>   eax: <L3 L2 A1 A0>
  xchg  cx,bx                   ; ecx: <A7 A6 R5 R4>   ebx: <R7 R6 A5 A4>
  add   eax,edi                 ; <C3+L3 C2+L2 C1+A1 C0+A0>
   mov  edi,[esi+4-PITCH*5]     ; <C17 C15 C15 C14> or <C67 C66 C65 C64>
  shr   eax,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   add  ecx,edi                 ; <C7+A7 C6+A6 C5+R5 C4+R4>
  shr   ecx,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>dirty
   and  eax,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>clean
  add   eax,edx                 ; <(C3+L3+2A3)/2 ... (C1+2L1+A1)/2 ...>
   and  ecx,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>clean
  shr   eax,1                   ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,ebx                 ; <(C7+2R7+A7)/2 ... (C5+R5+2A5)/2 ...>
  mov   ebx,[esi-PITCH*5]       ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   and  eax,07F7F7F7FH          ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> clean
  shr   ecx,1                   ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> dirty
   add  edi,001010101H          ; <C7+1 C6+1 C5+1 C4+1>
  and   ecx,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> clean
   lea  eax,[eax+ebx+001010101H]; <(5C3+L3+2A3+4)/4 ... (5C1+2L1+A1)/4 ...>
  shr   eax,1                   ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>dirty
   add  ecx,edi                 ; <(5C7+2R7+A7+4)/4 ... (5C5+R5+2A5)/4 ...>
  shr   ecx,1                   ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>dirty
   and  eax,07F7F7F7FH          ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>clean
  and   ecx,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>clean
   mov  [esi-PITCH*5],eax       ; Store OBMC pred for pels 4-7 of line 1 or 6.
  mov   [esi+4-PITCH*5],ecx     ; Store OBMC pred for pels 0-3 of line 1 or 6.
   lea  edi,[esi-PITCH*9]       ; Speculatively advance to line 2.
  add   ebp,080000000H
   jnc  @b

@@:

  mov   eax,[edi+4]             ; <C27 C26 C25 C24> ... <C57 C56 C55 C54>
   mov  ebx,[edi+12]            ; <R27 R26 R25 R24> ... <R57 R56 R55 R54>
  add   bl,al                   ; <R7 R6 R5 C4+R4>
   mov  ecx,[edi]               ; <C23 C22 C21 C20> ... <C53 C52 C51 C50>
  shr   bl,1                    ; <R7 R6 R5 (C4+R4)/2>
   mov  edx,[edi+8]             ; <L23 L22 L21 L20> ... <L53 L52 L51 L50>
  add   bh,ah                   ; <R7 R6 C5+R5 (C4+R4)/2>
   add  edx,ecx                 ; <C3+L3 C2+L2 junk junk>
  shr   bh,1                    ; <2R7/2 2R6/2 (C5+R5)/2 (C4+R4)/2>
   mov  esi,[edi+32]            ; <A27 A26 A25 A24> ... <B57 B56 B55 B54>
  shr   edx,1                   ; <(C3+L3)/2 (C2+L2)/2 junk junk> dirty
   add  esi,eax                 ; <C7+A7 C6+A6 C5+A5 C4+A4>
  shr   esi,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>dirty
   and  edx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 junk junk> clean
  and   esi,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>clean
   mov  dl,[edi+8]              ; <(C3+L3)/2 (C2+L2)/2 junk 2L0/2>
  add   esi,ebx                 ; <(C7+2R7+A7)/2 ... (2C5+R5+A5)/2 ...>
   mov  ebx,[edi+28]            ; <A23 A22 A21 A20> ... <B53 B52 B51 B50>
  shr   esi,1                   ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> dirty
   add  ebx,ecx                 ; <C3+A3 C2+A2 C1+A1 C0+A0>
  shr   ebx,1                   ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   and  esi,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>clean
   mov  dh,[edi+9]              ; <(C3+L3)/2 (C2+L2)/2 2L1/2 2L0/2>
  add   ebx,edx                 ; <(2C3+L3+A3)/2 ... (C1+2L1+A1)/2 ...>
   lea  eax,[eax+esi+001010101H]; <(5C7+2R7+A7+4)/4 ... (6C5+R5+A5+4)/4 ...>
  shr   ebx,1                   ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  shr   eax,1                   ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>dirty
   and  ebx,07F7F7F7FH          ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> clean
  add   ebx,ecx                 ; <(6C3+L3+A3+4)/4 ... (5C1+2L1+A1+4)/4 ...>
   and  eax,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>clean
  shr   ebx,1                   ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>dirty
   mov  [edi+4],eax             ; Store OBMC pred for pels 4-7 of line 2 thru 5.
  and   ebx,07F7F7F7FH          ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>clean
   mov  [edi],ebx               ; Store OBMC pred for pels 0-3 of line 2 thru 5.
  add   edi,PITCH               ; Advance to next line.
   add  ebp,040000000H
  jnc   @b

  mov   esi,MBActionCursor
   cmp  ebp,T_MacroBlockActionDescr.BlkY2
  jle   Block1or2DescrBuilt

  mov   al,PB [esi].CodedBlocks
   mov  edi,CoeffStream                ; Restore block descriptor ptr.
  cmp   ebp,T_MacroBlockActionDescr.BlkY3
   je   Block3DescrBuilt

Block4DescrBuilt:

  shr   al,5                           ; Check if block 5 (U) empty.
   lea  edx,[esi].BlkU+4               ; Addr of block addr (plus 4).
  sbb   ebp,ebp                        ; -1 iff block not empty.
   mov  [edi].BlockAddr,edx            ; Store address of block address.
  shr   al,1                           ; Check if block 6 (Y) empty.
   lea  edx,[esi].BlkV+4               ; Addr of block addr (plus 4).
  sbb   ebx,ebx                        ; -1 iff block not empty.
   and  ebp,T_CoeffBlk                 ; 0 iff block empty, else inc. 
  and   ebx,T_CoeffBlk                 ; 0 iff block empty, else inc. 
   add  esi,SIZEOF T_MacroBlockActionDescr ; Move to next macroblock descriptor.
  mov   [edi+ebp*1].BlockAddr,edx      ; Store address of block address.
   add  edi,ebp                        ; Inc block descr ptr if blk non-empty.
  add   edi,ebx                        ; Inc block descr ptr if blk non-empty.
   xor  ebp,ebp
  and   al,1                           ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; partial end of section only defined when H261 not defined.
ENDIF
  
BuildBlockActionDescr MACRO BlockNumber,AddrOffset
  shr   al,1                                  ; Check if block empty.
   lea  edi,[edi+ebp]                         ; Adjust BlockActionDescr cursor.
  sbb   ebp,ebp                               ; -1 iff block not empty.
   lea  edx,[esi].Blk[BlockNumber*SIZEOF T_Blk]+AddrOffset ; Addr of block addr.
  and   ebp,T_CoeffBlk                        ; 0 iff block empty, else inc. 
   mov  [edi].BlockAddr,edx                   ; Store address of block address.
ENDM

IFNDEF H261
;; more code only used when H261 not defined

MBIsIntraCoded_OBMC:

  shr   al,1        ; Same as BuildBlockActionDescr macro, except don't inc edi.
  sbb   ebp,ebp
   lea  edx,[esi].BlkY1
  and   ebp,T_CoeffBlk
   mov  [edi].BlockAddr,edx
  BuildBlockActionDescr 1,0  ; If blk 2 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   add  edi,ebp
  test  al,1                                ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; end of section only defined when H261 not defined.
ENDIF
;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  al  -- Coded block pattern for I or P block
;  bl  -- BlockType

NextMacroBlock:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks  ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded

  BuildBlockActionDescr 0,4  ; If blk 1 non-empty, record BAD to do as inter.
  BuildBlockActionDescr 1,4  ; blk 2
  BuildBlockActionDescr 2,4  ; blk 3
  BuildBlockActionDescr 3,4  ; blk 4
  BuildBlockActionDescr 4,4  ; blk 5
  BuildBlockActionDescr 5,4  ; blk 6
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt
  
MBIsIntraCoded:

  BuildBlockActionDescr 0,0  ; If blk 1 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 1,0  ; blk 2
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt


IFNDEF H261
NextBMacroBlock:

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  cl  -- Used to compute defined columns mask case.
;  bh  -- Coded block pattern for B block
;  bl  -- Coded block pattern for I or P block
;  al  -- Used to compute defined rows mask.

BuildBBlockActionDescr MACRO BlkNum,LinesDefFutureFrame,ColsDefFutureFrame
  shr   bh,1                                        ; Check if block empty.
   mov  cl,[esi].Blk[BlkNum*SIZEOF T_Blk].BestHMVb  ; HMVb for block.
  lea   edi,[edi+ebp]                               ; Adjust BlockActionDescr.
   mov  al,[esi].Blk[BlkNum*SIZEOF T_Blk].BestVMVb  ; VMVb for block.
  sbb   ebp,ebp                                     ; -1 iff block not empty.
   mov  cl,ColsDefFutureFrame[ecx-96]           ; Case of columns to do bidi.
  and   ebp,T_CoeffBlk                          ; 0 iff block empty, else inc. 
   mov  al,LinesDefFutureFrame[eax-96]          ; Mask for lines to do bidi.
  mov   [edi].LinesDefined,al                   ; Stash it.
   mov  edx,ColsDefined[ecx]
  mov   [edi].Cols03Defined,edx                 ; Stash it.
   mov  edx,ColsDefined[ecx+4]
  mov   [edi].Cols47Defined,edx                 ; Stash it.
   lea  edx,[esi].Blk[BlkNum*SIZEOF T_Blk]+8    ; Addr of block addr.
  mov   [edi].BlockAddr,edx                     ; Store address of blk address.
ENDM

  mov   ebx,PD [esi].CodedBlocks ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
                                 ; Bits  8-13  like bits 0-5, but for B frame.
                                 ; Bit  14-15  clear.  Unused.

  BuildBBlockActionDescr 0, UpperYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 1, UpperYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 2, LowerYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 3, LowerYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 4, ChromaLinesDef,    ChromaColsDef
  BuildBBlockActionDescr 5, ChromaLinesDef,    ChromaColsDef
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  bl,040H                             ; Are we at end-of-stream?
  je    NextBMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
ENDIF
  
BlockActionStreamBuilt:

  mov   CoeffStream,edi         ; Stash address of last block of coeffs.

NextBlock:

;===============================================================================
;===============================================================================
; Second pass performs frame differencing of Inters and Forward DCT.
;===============================================================================
;===============================================================================

  mov   eax,[edi].BlockAddr          ; Fetch address of block to do
   mov  ebp,PITCH
  test  eax,4                        ; Is it an Inter block.
   jne  InterOrOBMCBlock             ; Jump if doing inter block.

  mov   edx,[eax].T_Blk.BlkOffset    ; BlkOffset if INTRA;  BestMVs if BiDi.
   mov  ecx,TargetFrameBaseAddress
  add   ecx,edx                      ; Target block address if INTRA
   mov  esi,[eax-8].T_Blk.BlkOffset  ; Addr of BlkOffset if BiDi

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;
  test  eax,8                        ; Is it a BiDi block?
   jne  BiDiBlock                    ; Jump if doing BiDi block.
ENDIF

IntraBlock:

; Register usage:
;   ecx,edi -- Address of block.
;   ebp -- Pitch.
;   ebx, eax -- Scratch.

  mov   ebx,[ecx]
   mov  eax,[ecx+4]
  mov   P00,ebx
   mov  P04,eax
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  lea   edi,[ecx+PITCH*5]
   lea  ecx,[ecx+ebp*2]
  mov   P10,eax
   mov  P14,edx
  mov   eax,[ecx]
   mov  edx,[ecx+4]
  mov   P20,eax
   mov  P24,edx
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  mov   P30,eax
   mov  P34,edx
  mov   eax,[ecx+ebp*2]
   mov  edx,[ecx+ebp*2+4]
  mov   P40,eax
   mov  P44,edx
  mov   eax,[edi]
   mov  edx,[edi+4]
  mov   P50,eax
   mov  P54,edx
  mov   eax,[edi+ebp*1]
   mov  edx,[edi+ebp*1+4]
  mov   P60,eax
   mov  P64,edx
  mov   eax,[edi+ebp*2]
   mov  edx,[edi+ebp*2+4]
  mov   P74,edx
   xor  ecx,ecx
  and   ebx,00000007FH                      ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  mov   P70,eax
   jmp  DoForwardDCT

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;

BiDiBlock:

  mov   BlkActionDescrAddr,eax               ; Extract VMVb.
   mov  ebp,FutureFrameBaseAddress
  shr   edx,25                               ; CF == 1 iff VMVb is half pel.
   mov  bl,[edi].LinesDefined
  lea   esi,[esi+ebp-48]                     ; Addr 0-MV blk in Future P Frame.
   mov  ebp,[edi].Cols47Defined
IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF
  lea   ecx,[edx+edx*2-48*3]                 ; Mult integer pel VMVb by PITCH.
   mov  edi,[edi].Cols03Defined
  mov   dl,[eax-8].T_Blk.BestHMVb            ; Fetch HMVb.
   jc   InterpVert_FuturePFrame

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpHorz_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   mov  Mask00+4,eax                    ; 0E  Stash Mask for use with past pred.
  and   eax,ecx                         ; 0F  Select in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  mov   P00+4,eax                       ; 0G  Stash in-range pels.
   and  edx,edi                         ; 1D
  mov   Mask10+4,edx                    ; 1E
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1F
  mov   P10+4,edx                       ; 1G
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   mov  Mask20+4,eax                    ; 2E
  and   eax,ecx                         ; 2F
   mov  ecx,[esi+PITCH*3]               ; 3C
  mov   P20+4,eax                       ; 2G
   and  edx,edi                         ; 3D
  mov   Mask30+4,edx                    ; 3E
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3F
  mov   P30+4,edx                       ; 3G
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   mov  Mask40+4,eax                    ; 4E
  and   eax,ecx                         ; 4F
   mov  ecx,[esi+PITCH*5]               ; 5C
  mov   P40+4,eax                       ; 4G
   and  edx,edi                         ; 5D
  mov   Mask50+4,edx                    ; 5E
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5F
  mov   P50+4,edx                       ; 5G
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   mov  Mask60+4,eax                    ; 6E
  and   eax,ecx                         ; 6F
   mov  ecx,[esi+PITCH*7]               ; 7C
  mov   P60+4,eax                       ; 6G
   and  edx,edi                         ; 7D
  mov   Mask70+4,edx                    ; 7E
   and  edx,ecx                         ; 7F
  mov   P70+4,edx                       ; 7G
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   add  esi,4
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpVert_FuturePFrame:

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpBoth_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+PITCH*1]               ; 0E  Fetch Future P10:P13.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P10:P13.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*2]               ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*3]               ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*4]               ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*5]               ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*6]               ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*7]               ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*8-4]             ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpHorz_FuturePFrame:

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Horizontally.

  add   esi,edx                              ; Add HMVb contrib to block addr.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+1]                     ; 0E  Fetch Future P01:P04.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P01:P04.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*1+1]             ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*2+1]             ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*3+1]             ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*4+1]             ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*5+1]             ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*6+1]             ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*7+1-4]           ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpBoth_FuturePFrame:

  add   esi,edx                              ; Add HMVb contrib to block addr.
   sub  esp,68

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  add   esp,8
   mov  eax,[esi]           ; Fetch Future P00:P03.
  mov   ecx,001010101H      ; Mask to extract halves.
   mov  edx,[esi+1]         ; Fetch Future P01:P04.
  add   eax,edx             ; <P04+P03 ...>.
   mov  edx,[esi+PITCH+1]   ; Fetch Future P11:P14.
  and   ecx,eax             ; <(P04+P03)&1 ...>.
   add  esi,PITCH           ; Advance to next line.
  xor   eax,ecx             ; <(P04+P03)/2*2 ...>.
   add  edx,ecx             ; <P14+((P04+P03)&1) ...>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   mov  ecx,[esi]           ; Fetch Future P10:P13.
  add   edx,ecx             ; <P14+P13+((P04+P03)&1) ...>.
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>
  shr   edx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  bl,bl               ; CF == 1 iff line 0 in range.
  sbb   ecx,ecx             ; ecx == -1 if line 0 in range.
   and  edx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
  add   eax,edx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   and  ecx,edi             ; In range among P00,P01,P02,P03.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  Mask00+60,ecx       ; Stash Mask for use with past prediction.
  and   eax,ecx             ; Select in-range pels from future pred (and clean).
  test  esp,000000038H
  mov   P00+60,eax          ; Stash in-range pels.
   jne  @b

  sub   esi,PITCH*8-4       ; Move to right 4 columns.
   mov  edx,BlkActionDescrAddr
  mov   edi,ebp
   sub  esp,60
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   jne  @b

  add   esp,60
   xor  eax,eax
  mov   edi,[edx-8].T_Blk.BlkOffset
   mov  al,[edx-8].T_Blk.BestVMVf

BiDiFuturePredDone:

  shr   al,1                                 ; CF == 1 iff VMVf is half pel.
   mov  esi,TargetFrameBaseAddress
  mov   cl,[edx-8].T_Blk.BestHMVf
   mov  edx,DistFromTargetToPastP
  lea   edi,[edi+esi]
   jc   InterpVert_PastPFrame

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpHorz_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  ebx,Mask00+64       ; 0B  Fetch bidi-prediction mask.
  mov   ecx,P00+64          ; 0C  Fetch future pred for bidi predicted pels.
   and  ebx,eax             ; 0D  Extract past for bidi predicted pels.
  mov   edx,[esi+4]         ; 4A
   mov  ebp,Mask04+64       ; 4B
  lea   eax,[ecx+eax*2]     ; 0E  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4C
  sub   eax,ebx             ; 0F  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4D
  shr   eax,1               ; 0G  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4E
  and   eax,07F7F7F7FH      ; 0H  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4F
  shr   edx,1               ; 4G
   mov  ebx,[edi]           ; 0I  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4H
   mov  ebp,[edi+4]         ; 4I
  sub   ebx,eax             ; 0J  Compute correction.
   sub  ebp,edx             ; 4J
  add   ebx,080808080H      ; 0K  Bias correction.
   add  ebp,080808080H      ; 4K
  mov   P00+64,ebx          ; 0K  Store correction.
   mov  P04+64,ebp          ; 4K
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT
   

InterpVert_PastPFrame:

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpBoth_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+PITCH]     ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+PITCH+4]   ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorz_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+1]         ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+5]         ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpBoth_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi+1]       ; 0A <P04 P03 P02 P01> prediction pels.
   mov  ebx,001010101H    ; 0B Mask for extraction of halves.
  mov   ebp,[esi+PITCH+1] ; 0C <P14 P13 P12 P11>.
   mov  ecx,[esi]         ; 0D <P03 P02 P01 P00>.
  add   eax,ecx           ; 0E <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ecx,[esi+PITCH]   ; 0F <P13 P12 P11 P10>.
  and   ebx,eax           ; 0G <(P04+P03)&1 ...>.
   and  eax,0FEFEFEFEH    ; 0H Pre-Clean
  shr   eax,1             ; 0I <(P04+P03)/2 ...>.
   add  ecx,ebp           ; 0J <P14+P13 P13+P12 P12+P11 P11+P10>.
  add   eax,001010101H    ; 0K <(P04+P03)/2+1 ...>.
   add  ecx,ebx           ; 0L <P14+P13+((P04+P03)&1) ...>.
  shr   ecx,1             ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   mov  edx,[esi+5]       ; 4A
  and   ecx,07F7F7F7FH    ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   mov  ebx,001010101H    ; 4B
  add   eax,ecx           ; 0N <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebp,[esi+PITCH+5] ; 4C
  shr   eax,1             ; 0O <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>
   mov  ecx,[esi+4]       ; 4D
  and   eax,07F7F7F7FH    ; 0P Interpolated prediction.
   add  edx,ecx           ; 4E
  mov   ecx,[esi+PITCH+4] ; 4F
   and  ebx,edx           ; 4G
  and   edx,0FEFEFEFEH    ; 4H
   add  ecx,ebp           ; 4J
  shr   edx,1             ; 4I
   add  ecx,ebx           ; 4L
  shr   ecx,1             ; 4M
   add  edx,001010101H    ; 4K
  and   ecx,07F7F7F7FH    ; 4M
   mov  ebx,Mask00+64     ; 0Q  Fetch bidi-prediction mask.
  add   edx,ecx           ; 4N
   mov  ecx,P00+64        ; 0R  Fetch future pred for bidi predicted pels.
  shr   edx,1             ; 4O
   and  ebx,eax           ; 0S  Extract past for bidi predicted pels.
  and   edx,07F7F7F7FH    ; 4P
   mov  ebp,Mask04+64     ; 4Q
  lea   eax,[ecx+eax*2]   ; 0T  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64        ; 4R
  sub   eax,ebx           ; 0U  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx           ; 4S
  shr   eax,1             ; 0V  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]   ; 4T
  and   eax,07F7F7F7FH    ; 0W  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp           ; 4U
  shr   edx,1             ; 4V
   mov  ebx,[edi]         ; 0X  Fetch target pels.
  and   edx,07F7F7F7FH    ; 4W
   mov  ebp,[edi+4]       ; 4X
  sub   ebx,eax           ; 0Y  Compute correction.
   sub  ebp,edx           ; 4Y
  add   ebx,080808080H    ; 0Z  Bias correction.
   add  ebp,080808080H    ; 4Z
  mov   P00+64,ebx        ; 0a  Store correction.
   mov  P04+64,ebp        ; 4a
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT

;; end of section of code not define when H261 defined
ENDIF

InterOrOBMCBlock:

  mov   esi,TargetFrameBaseAddress
   mov  edi,[eax-4].T_Blk.BlkOffset   ; Compute Addr of Target block.

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
  test  eax,8
   jne  OBMCBlock
ENDIF

  add   edi,esi
   mov  esi,[eax-4].T_Blk.PastRef     ; Addr of PrevRef block.
  mov   eax,[eax-4].T_Blk.MVs         ; al = Horz MV;  ah = Vert MV
   mov  ecx,080808080H

IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;
  test  al,1
   jne  InterpHorzOrBoth

ENDIF

  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]
  test  ah,1
   je   NoInterp


IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;

InterpVert:
InterpHorz:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebx -- Address of reference plus either 1 or PITCH, for interpolation.
;   ebp, edx, ecx, eax -- Scratch.

  sub   esp,16

@@:
  add   esp,4
   mov  eax,[esi]               ; 0A  <P03 P02 P01 P00> prediction pels.
  mov   ecx,[ebx]               ; 0B  <P04 ...> or <P13 ...> prediction pels.
   mov  edx,[edi]               ; 0C  <C03 C02 C01 C00> current pels.
  add   edx,080808080H          ; 0D  Add bias.
   mov  ebp,[esi+PITCH*2]       ; 2A
  lea   eax,[eax+ecx+001010101H]; 0E  Sum of pred pels to interpolate.
   mov  ecx,[ebx+PITCH*2]       ; 2B
  shr   eax,1                   ; 0F  Average of prediction pels (dirty).
  and   eax,07F7F7F7FH          ; 0G  Average of prediction pels (clean). 
   lea  ebp,[ebp+ecx+001010101H]; 2E
  sub   edx,eax                 ; 0H  Current - interpolated prediction, biased.
   mov  eax,[edi+PITCH*2]       ; 2C
  mov   P00+12,edx              ; 0I  Save correction.
   add  eax,080808080H          ; 2D
  shr   ebp,1                   ; 2F
   mov  edx,[esi+PITCH*4]       ; 4A
  and   ebp,07F7F7F7FH          ; 2G
   mov  ecx,[ebx+PITCH*4]       ; 4B
  sub   eax,ebp                 ; 2H
   mov  ebp,[edi+PITCH*4]       ; 4C
  mov   P20+12,eax              ; 2I
   lea  ecx,[ecx+edx+001010101H]; 4E
  shr   ecx,1                   ; 4F
   add  ebp,080808080H          ; 4D
  and   ecx,07F7F7F7FH          ; 4G
   mov  eax,[esi+PITCH*6]       ; 6A
  sub   ebp,ecx                 ; 4H
   mov  ecx,[ebx+PITCH*6]       ; 6B
  mov   P40+12,ebp              ; 4I
   mov  ebp,[edi+PITCH*6]       ; 6C
  lea   ecx,[ecx+eax+001010101H]; 6E
   add  ebp,080808080H          ; 6D
  shr   ecx,1                   ; 6F
   add  esi,4
  and   ecx,07F7F7F7FH          ; 6G
   add  ebx,4
  sub   ebp,ecx                 ; 6H
   add  edi,4
  test  esp,4
  mov   P60+12,ebp              ; 6I
   je   @b

  add   esi,PITCH-8
   add  edi,PITCH-8
  test  esp,8
  lea   ebx,[ebx+PITCH-8]
   jne  @b

  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorzOrBoth:

  lea   ebx,[esi+1]
  test  ah,1
   je   InterpHorz


InterpBoth:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebp -- Pitch and scratch.
;   edx, ebx, eax -- Scratch.

  sub   esp,64

@@:

  mov   eax,[esi+1]         ; <P04 P03 P02 P01> prediction pels.
   lea  edx,[ecx*2+1]       ; Get 001010101H mask.
  mov   ebx,[esi]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment target block pointer.
  add   eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ebx,[esi+ebp*1+1]   ; <P14 P13 P12 P11>.
  and   edx,eax             ; <(P04+P03)&1 ...>.
   mov  ebp,[esi+ebp*1]     ; <P13 P12 P11 P10>.
  xor   eax,edx             ; Clear insignificant fractional bit in each byte.
   add  ebx,ebp             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   add  ebx,edx             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  esi,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   lea  eax,[eax+ecx*2+1]   ; <(P04+P03)/2+1 ...>.
  add   eax,ebx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebx,[edi-4]         ; <C03 C02 C01 C00> current pels.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   add  ebx,ecx             ; Add bias.
  and   eax,07F7F7F7FH      ; Interpolated prediction.
   add  esp,4               ; Advance frame difference pointer.
  sub   ebx,eax             ; Correction.
   mov  ebp,PITCH           ; Reload Pitch.
  test  esp,4
  mov   P00+60,ebx          ; Save correction.
   je   @b

  lea   esi,[esi+ebp-8]
   xor  ebx,ebx
  test  esp,000000038H
  lea   edi,[edi+ebp-8]
   jne  @b

  mov   bl,P00                              ; Fetch P0.
   xor  ecx,ecx
  mov   cl,P03                              ; Fetch P3.
   jmp  DoForwardDCT


OBMCBlock:   ; Do OBMC frame differencing.  OBMC prediction computed above. 

  mov   ecx,080808080H
   mov  edi,[eax-12].T_Blk.BlkOffset  ; Compute Addr of Target block.
  add   edi,esi
   mov  esi,[eax-12].T_Blk.PastRef     ; Addr of PrevRef block.
  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]

;; end of section of code not included when H261 defined
ENDIF

NoInterp:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebp -- Pitch.
;   edx -- Pitch times 3.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebx, eax -- Scratch.

@@:

  xor   esp,4                   ; 1st time: Back off to cache line;
   mov  eax,[edi]               ; 0A  <C3 C2 C1 C0> current pels.
  add   eax,ecx                 ; 0C  Add bias.
   mov  ebx,[esi]               ; 0B  <P3 P2 P1 P0> prediction pels.
  sub   eax,ebx                 ; 0D  <Cn-Pn> Current - pred, biased.
   mov  ebx,[esi+ebp*1]         ; 1B
  mov   P00+4,eax               ; 0E  Save <Corr3 Corr2 Corr1 Corr0>
   mov  eax,[edi+ebp*1]         ; 1A
  sub   eax,ebx                 ; 1D
   mov  ebx,[esi+ebp*2]         ; 2B
  add   eax,ecx                 ; 1C
   sub  ebx,ecx                 ; 2C
  mov   P10+4,eax               ; 1E
   mov  eax,[edi+ebp*2]         ; 2A
  sub   eax,ebx                 ; 2D
   mov  ebx,[esi+ebp*4]         ; 4B
  mov   P20+4,eax               ; 2E
   mov  eax,[edi+ebp*4]         ; 4A
  sub   eax,ebx                 ; 4D
   mov  ebx,[esi+edx*1]         ; 3B
  add   eax,ecx                 ; 4C
   sub  ebx,ecx                 ; 3C
  mov   P40+4,eax               ; 4E
   mov  eax,[edi+edx*1]         ; 3A
  sub   eax,ebx                 ; 3D
   mov  ebx,[esi+edx*2]         ; 6B
  mov   P30+4,eax               ; 3E
   lea  esi,[esi+ebp+4]         ; Advance to line 1.
  mov   eax,[edi+edx*2]         ; 6A
   lea  edi,[edi+ebp+4]         ; Advance to line 1.
  sub   eax,ebx                 ; 6D
   mov  ebx,[esi+ebp*4-4]       ; 5B
  add   eax,ecx                 ; 6C
   sub  ebx,ecx                 ; 5C
  mov   P60+4,eax               ; 6E
   mov  eax,[edi+ebp*4-4]       ; 5A
  sub   eax,ebx                 ; 5D
   mov  ebx,[esi+edx*2-4]       ; 7B
  mov   P50+4,eax               ; 5E
   mov  eax,[edi+edx*2-4]       ; 7A
  sub   eax,ebx                 ; 7D
   sub  edi,ebp                 ; Back off to line 0.
  add   eax,ecx                 ; 7C
   sub  esi,ebp                 ; Back off to line 0.
  test  esp,4                   ; Do twice.
  mov   P70+4,eax               ; 7E
   je   @b

  xor   ecx,ecx
   xor  ebx,ebx
  mov   bl,P00                  ; Fetch P0.
   mov  cl,P03                  ; Fetch P3.

DoForwardDCT:

;=============================================================================
;
;  This section does the Forward Discrete Cosine Transform.  It performs a DCT
;  on a 8*8 block of pels or pel differences.  The row transforms are done
;  first using a table lookup method.  Then the columns are done, using
;  computation.
;
;
; Each intermediate and coefficient is a short.  There are four fractional
; bits.  All coefficients except an intrablock's DC are biased by 08000H.

; Perform row transforms.
;
; Register usage:
;   ebp - Accumulator for contributions to intermediates I0 (hi) and I2 (lo).
;   edi - Accumulator for contributions to intermediates I1 (hi) and I3 (lo).
;   esi - Accumulator for contributions to intermediates I4 (hi) and I6 (lo).
;   edx - Accumulator for contributions to intermediates I7 (hi) and I5 (lo).
;   ecx - Pel or pel difference.
;   ebx - Pel or pel difference.
;   eax - Place in which to fetch a pel's contribution to two intermediates.

  mov   esi,PD P80000_P4545F [ebx*8]   ; P0's contribution to I4|I6.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P3's contribution to I4|I6.
  mov   edx,PD P2350B_P6491A [ebx*8]   ; P0's contribution to I7|I5.
   mov  edi,PD NB18A8_P96831 [ecx*8]   ; P3's contribution to I7|I5.
  lea   esi,[esi+eax+40004000H]        ; P0, P3 contribs to   I4|I6, biased.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P3's contribution to I0|I2.
  lea   edx,[edx+edi+40004000H]        ; P0, P3 contribs to   I7|I5, biased.
   mov  ebp,PD P80000_PA73D7 [ebx*8]   ; P0's contribution to I0|I2.
  mov   edi,PD P2350B_N6491A [ecx*8]   ; P3's contribution to I1|I3.
   mov  cl,P01                         ; Fetch P1.
  lea   ebp,[ebp+eax+40004000H]        ; P0, P3 contribs to   I0|I2, biased.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P0's contribution to I1|I3.
  sub   edi,eax                        ; P0, P3 contribs to   I1|I3, unbiased.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P1's contribution to I0|I2.
  add   ebp,eax                        ; P0, P1, P3 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P1's contribution to I1|I3.
  sub   edi,eax                        ; P0, P1, P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P1's contribution to I4|I6.
  sub   esi,eax                        ; P0, P1, P3 contribs to I4|I6.
   mov  bl,P02                         ; Fetch P2.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P1's contribution to I7|I5.
   mov  cl,P04                         ; Fetch P4.
  sub   edx,eax                        ; P0, P1, P3 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P2's contribution to I0|I2.
  add   ebp,eax                        ; P0-P3 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P2's contribution to I1|I3.
  add   edi,eax                        ; P0-P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P2's contribution to I4|I6.
  sub   esi,eax                        ; P0-P3 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P2's contribution to I7|I5.
  sub   edx,eax                        ; P0-P3 contribs to I7|I5.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P4's contribution to I0|I2.
  add   ebp,eax                        ; P0-P4 contribs to I0|I2.
   mov  eax,PD P2350B_N6491A [ecx*8]   ; P4's contribution to I1|I3.
  sub   edi,eax                        ; P0-P4 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P4's contribution to I4|I6.
  add   esi,eax                        ; P0-P4 contribs to I4|I6.
   mov  bl,P05                         ; Fetch P5.
  mov   eax,PD NB18A8_P96831 [ecx*8]   ; P4's contribution to I7|I5.
   mov  cl,P06                         ; Fetch P6.
  sub   edx,eax                        ; P0-P4 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P5's contribution to I0|I2.
  add   ebp,eax                        ; P0-P5 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P5's contribution to I1|I3.
  sub   edi,eax                        ; P0-P5 contribs to I1|I3.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P5's contribution to I4|I6.
  sub   esi,eax                        ; P0-P5 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P5's contribution to I7|I5.
  add   edx,eax                        ; P0-P5 contribs to I3|I4.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P6's contribution to I0|I2.
  add   ebp,eax                        ; P0-P6 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P6's contribution to I1|I3.
  add   edi,eax                        ; P0-P6 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P6's contribution to I4|I6.
  sub   esi,eax                        ; P0-P6 contribs to I4|I6.
   mov  bl,P07                         ; Fetch P7.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P6's contribution to I7|I5.
   mov  cl,P13                         ; Fetch P0.
  add   edx,eax                        ; P0-P6 contribs to I7|I5.
   mov  eax,PD P80000_PA73D7 [ebx*8]   ; P7's contribution to I0|I2.
  add   ebp,eax                        ; P0-P7 contribs to I0|I2.
   mov  eax,PD P80000_P4545F [ebx*8]   ; P7's contribution to I4|I6.
  add   esi,eax                        ; P0-P7 contribs to I4|I6.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P7's contribution to I1|I3.
  mov   I00I02,ebp                     ; Store I0|I2 for line 0.
   mov  I04I06,esi                     ; Store I4|I6 for line 0.
  lea   edi,[edi+eax+40004000H]        ; P0-P7 contribs to I1|I3, biased.
   mov  eax,PD P2350B_P6491A [ebx*8]   ; P7's contribution to I7|I5.
  sub   edx,eax                        ; P0-P7 contribs to I7|I5.
   mov  bl,P10                         ; Fetch P3 of line 1.
  mov   I01I03,edi                     ; Store I1|I3 for line 0.
   mov  I07I05,edx                     ; Store I7|I5 for line 0.

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P11
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P12
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P14
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P15
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P16
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P17
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P23
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I10I12,ebp
   mov  I14I16,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P20
  mov   I11I13,edi
   mov  I17I15,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P21
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P22
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P24
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P25
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P26
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P27
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P33
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I20I22,ebp
   mov  I24I26,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P30
  mov   I21I23,edi
   mov  I27I25,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P31
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P32
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P34
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P35
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P36
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P37
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P43
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I30I32,ebp
   mov  I34I36,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P40
  mov   I31I33,edi
   mov  I37I35,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P41
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P42
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P44
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P45
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P46
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P47
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P53
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I40I42,ebp
   mov  I44I46,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P50
  mov   I41I43,edi
   mov  I47I45,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P51
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P52
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P54
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P55
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P56
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P57
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P63
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I50I52,ebp
   mov  I54I56,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P60
  mov   I51I53,edi
   mov  I57I55,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P61
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P62
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P64
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P65
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P66
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P67
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P73
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I60I62,ebp
   mov  I64I66,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P70
  mov   I61I63,edi
   mov  I67I65,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P71
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P72
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P74
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P75
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P76
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P77
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  ecx,I00I02                 ; Fetch I0  (upper_lim <skew>) = 2000  4000 
   ;                               ; (lower_lim is -upper_limit)
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax                    ; I70I72, aka I7.                2000  0000 
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I74I76,esi
   mov  esi,I30I32                 ; Fetch I3                       2000  4000 
  add   edi,eax
   mov  eax,I40I42                 ; Fetch I4                       2000  0000 
  sub   esi,eax                    ; I3 - I4                        4000  4000 
   sub  ecx,ebp                    ; I0 - I7                        4000  4000 
  shr   ecx,1                      ; R7 = (I0-I7)/2 (dirty)         2000  2000 
   and  esi,0FFFEFFFFH             ; pre-clean R4
  shr   esi,1                      ; R4 = (I3-I4)/2 (dirty)         2000  2000 
   and  ecx,0FFFF7FFFH             ; R7 = (I0-I7)/2 (clean)         2000  2000 
  mov   ebx,PD P2350B_P6491A [ebx*8]
   mov  I71I73,edi
  sub   edx,ebx
   lea  ebx,[ecx+ecx*2]            ; 3R7                            6000  6000
  mov   I77I75,edx
   lea  edi,[esi+esi*2]            ; 3R4                            6000  6000

                                   ; eax:  I4                       2000  0000
                                   ; ebx:  3R7                      6000  6000
                                   ; ecx:  R7                       2000  2000
                                   ; edx:  available
                                   ; esi:  R4                       2000  2000
                                   ; edi:  3R4                      6000  6000
                                   ; ebp:  I7                       2000  0000

  lea   ebp,[ebp+ecx+40004000H]    ; R0 = (I0+I7)/2                 2000  6000
   add  eax,esi                    ; R3 = (I3+I4)/2                 2000  2000
  shr   ecx,1                      ; R7/2 (dirty)                   1000  1000
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; R4/2 (clean)                   1000  1000
   and  ecx,0FFFF7FFFH             ; clean
  add   ebx,ecx                    ; 7R7/2                          7000  7000
   add  edi,esi                    ; 7R4/2                          7000  7000
  shr   ebx,6                      ; 7R7/128 (dirty)                01C0  01C0
   and  edi,0FFC0FFFFH             ; pre-clean
  shr   edi,6                      ; 7R4/128 (clean)                01C0  01C0
   and  ebx,0FFFF03FFH             ; clean
  add   ebx,ecx                    ; 71R7/128                       11C0  11C0
   add  edi,esi                    ; 71R4/128                       11C0  11C0
  lea   edx,[eax+ebp-40004000H]    ; S0 = R0 + R3                   4000  4000
   sub  ebp,eax                    ; S3 = R0 - R3                   4000  4000
  lea   ecx,[ebx+ebx*2+6E406E40H]  ; 213R7/128                      3540  A380
   lea  esi,[edi+edi*2+27402740H]  ; 213R4/128                      3540  5C80
  shr   ecx,1                      ; 213R7/256 (dirty)              1AA0  51C0
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; 213R4/256 (clean)              1AA0  2E40
   and  ecx,0FFFF7FFFH             ; clean
  sub   ecx,edi                    ; S7 = (213R7 - 142R4)/256       2C60  4000
   mov  S0,edx                     ; Free register for work.
  mov   S3,ebp                     ; Free register for work.
   lea  esi,[esi+ebx+80008000H]    ; S4 = (142R7 + 213R3)/256       2C60  C000
  mov   S7,ecx                     ; Free register for work.
   mov  eax,I10I12                 ; Fetch I1                       2000  4000
  mov   S4,esi                     ; Free register for work.

                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

   mov  ebx,I20I22                 ; Fetch I2                       2000  4000
  mov   ecx,I50I52                 ; Fetch I5                       2000  0000
   mov  edx,I60I62                 ; Fetch I6                       2000  0000
  sub   eax,edx                    ; I1 - I6                        4000  4000
   sub  ebx,ecx                    ; I2 - I5                        4000  4000
  shr   eax,1                      ; R6 = (I1-I6)/2 (dirty)         2000  2000 
   and  ebx,0FFFEFFFFH             ; pre-clean R4
  shr   ebx,1                      ; R5 = (I2-I5)/2 (dirty)         2000  2000 
   and  eax,0FFFF7FFFH             ; R6 = (I1-I6)/2 (clean)         2000  2000 

                                   ; eax:  R6                       2000  2000
                                   ; ebx:  R5                       2000  2000
                                   ; ecx:  I5                       2000  0000
                                   ; edx:  I6                       2000  0000
                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

  mov   esi,ebx                    ; R5                             2000  2000
   mov  edi,eax                    ; R6                             2000  2000
  shr   esi,6                      ; R5/64                          0080  0080
   and  edi,0FFC0FFFFH             ; pre-clean 
  shr   edi,6                      ; R6/65                          0080  0080
   and  esi,0FFFF03FFH             ; clean
  lea   edx,[eax+edx+20002000H]    ; R1 = (I1+I6)/2                 2000  4000
   lea  ecx,[ecx+ebx-20002000H]    ; R2 = (I2+I5)/2                 2000  0000
  lea   ebp,[ebx+ebx*2]            ; 3R5                            6000  6000
   sub  ebx,esi                    ; 63R5/64                        1F80  1F80
  shr   ebp,4                      ; 3R5/16 (dirty)                 0600  0600
   lea  esi,[eax+eax*2]            ; 3R6                            6000  6000
  sub   eax,edi                    ; 63R6/64                        1F80  1F80
   mov  edi,ebx                    ; 63R5/64                        1F80  1F80
  shr   edi,7                      ; 63R5/8192 (dirty)              003F  003F
   and  ebp,0FFFF0FFFH             ; clean
  shr   esi,4                      ; 3R6/16 (dirty)                 0600  0600
   and  edi,0FFFF01FFH             ; clean
  and   esi,0FFFF0FFFH             ; clean
   sub  edx,ecx                    ; S2 = R1 - R2                   4000  4000
  lea   edi,[edi+ebp-46BF46BFH]    ; 1599R5/8192                    063F -4080
   mov  ebp,eax                    ; 63R6/64                        1F80  1F80
  shr   ebp,7                      ; 63R6/8192 (dirty)              003F  003F
   sub  eax,edi                    ; S6 = 8064R6/8192 - 1599R5/8192 25BF  6000
  and   ebp,0FFFF01FFH             ; clean
   lea  ecx,[edx+ecx*2-80008000H]  ; S1 = R1 + R2                   4000 -4000
  add   ebp,esi                    ; 1599R6/8192                    063F  063F
   mov  esi,S0                     ; Reload S0                      4000  4000
  mov   edi,CoeffStream            ; Fetch addr at which to place blk of coeffs.
   sub  esi,ecx                    ; C4 = T1 = S0 - S1              8000  8000
  lea   ebx,[ebx+ebp-45BF45BFH]    ; S5 = 8064R5/8192 + 1599R6/8192 25BF -2000
   mov  ebp,S4                     ; Reload S4                      2C60  C000

                                   ; eax:  S6                       25BF  6000
                                   ; ebx:  S5                       25BF -2000
                                   ; ecx:  S0                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C4                       8000  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S3                       4000  4000

  sub   ebp,eax                    ; T6 = S4 - S6                   521F  6000
   mov  PD [edi+C40C42],esi        ; Store coeffs C40 and C42.
  lea   ecx,[esi+ecx*2+80008000H]  ; C0 = T0 = S0 + S1              8000  8000
   mov  esi,S7                     ; Reload S7                      2C60  4000
  sub   esi,ebx                    ; T5 = S7 - S5                   521F  6000
   lea  eax,[ebp+eax*2-0C000C000H] ; T4 = S4 + S6                   521F  6000
  mov   PD [edi+C00C02],ecx        ; Store coeffs C00 and C02.
   mov  ecx,ebp                    ; T6                             521F  6000
  shr   ebp,2                      ; T6/4 (dirty)                   1487  1800
   lea  ebx,[esi+ebx*2+0C000C000H] ; T7 = S7 + S5                   521F  E000

                                   ; eax:  T4                       521F  6000
                                   ; ebx:  T7                       521F  6000
                                   ; ecx:  T6                       521F  6000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  T5                       521F  6000
                                   ; edi:  Destination pointer.
                                   ; ebp:  T6/4 (dirty)             1487  1800
                                   ; mem:  S3                       4000  4000
                                   ; done:  C0, C4

  and   ebp,0FFFF3FFFH             ; T6/4 (clean)                   1487  1800
   sub  ebx,eax                    ; C7 = T7 - T4                  <7642> 8000
  add   ecx,ebp                    ; 5T6/4                          66A6  7800
   mov  PD [edi+C70C72],ebx        ; Store coeffs C70 and C72.
  mov   ebp,ecx                    ; 5T6/4                          66A6  7800
   and  ecx,0FFF8FFFFH             ; pre-clean
  shr   ecx,3                      ; 5T6/32 (clean)                 0CD4  0F00
   lea  eax,[ebx+eax*2-0C000C000H] ; C1 = T7 + T4                  <7642> 8000 
  mov   ebx,esi                    ; T5                             521F  6000
   and  esi,0FFFCFFFFH             ; pre-clean
  shr   esi,2                      ; T5/4 (clean)                   1487  1800
   lea  ecx,[ecx+ebp-07000700H]    ; C5 = 45T6/32                   737A  8000
  mov   PD [edi+C50C52],ecx        ; Store coeffs C50 and C52.
   add  esi,ebx                    ; 5T5/4                          66A6  7800
  mov   ebx,esi                    ; 5T5/4                          66A6  7800
   and  esi,0FFF8FFFFH             ; pre-clean
  shr   esi,3                      ; 5T5/32 (clean)                 0CD4  0F00
   mov  ebp,S3                     ; Reload S3                      4000  4000
  mov   ecx,edx                    ; S2                             4000  4000
   lea  esi,[esi+ebx-07000700H]    ; C3 = 45T5/32                   737A  8000
  mov   ebx,ebp                    ; S3                             4000  4000
   ;

                                   ; eax:  C1                       521E  8000
                                   ; ebx:  S3                       4000  4000
                                   ; ecx:  S2                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C3                       737A  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S3                       4000  4000
                                   ; done:  C0, C4, C5, C7

  shr   ebp,2                      ; S3/4 (dirty)                   1000  1000
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/4 (clean)                   1000  1000
   and  ebp,0FFFF3FFFH             ; S3/4 (clean)                   1000  1000
  mov   PD [edi+C10C12],eax        ; Store coeffs C10 and C12.
   mov  PD [edi+C30C32],esi        ; Store coeffs C30 and C32.
  lea   eax,[edx+ecx]              ; 5S2/4                          5000  5000
   lea  esi,[ebx+ebp]              ; 5S3/4                          5000  5000
  shr   ebp,2                      ; S3/16 (dirty)                  0400  0400
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/16 (clean)                  0400  0400
   and  ebp,0FFFF3FFFH             ; S3/16 (clean)                  0400  0400
  add   ecx,eax                    ; 21S2/16                        5400  5400
   add  ebp,esi                    ; 21S3/16                        5400  5400
  shr   eax,5                      ; 5S2/128 (dirty)                0280  0280
   and  esi,0FFE0FFFFH             ; pre-clean
  shr   esi,5                      ; 5S3/128 (clean)                0280  0280
   and  eax,0FFFF07FFH             ; 5S2/128 (clean)                0280  0280
  shr   edx,1                      ; S2/2 (dirty)                   2000  2000
   and  ebx,0FFFEFFFFH             ; pre-clean
  shr   ebx,1                      ; S3/2 (clean)                   2000  2000
   and  edx,0FFFF7FFFH             ; S2/2 (clean)                   2000  2000
  sub   ebx,ecx                    ; (64S3 - 168S2) / 128           7400 -3400
   add  eax,ebp                    ; (5S2 + 168S3) / 128            5680  5680

  mov   ecx,I01I03
   mov  ebp,I71I73
  lea   ebx,[ebx+esi+0B180B180H]   ; C6 = (69S3 - 168S2) / 128      7680  8000
   lea  edx,[eax+edx+009800980H]   ; C2 = (69S2 + 168S3) / 128      7680  8000
  mov   esi,I31I33
   mov  eax,I41I43
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C60C62],ebx
   mov  PD [edi+C20C22],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I11I13
  mov   S4,esi
   mov  ebx,I21I23
  mov   ecx,I51I53
   mov  edx,I61I63
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C41C43],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C01C03],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C71C73],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C51C53],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C11C13],eax
   mov  PD [edi+C31C33],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I04I06
   mov  ebp,I74I76
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I34I36
   mov  eax,I44I46
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C61C63],ebx
   mov  PD [edi+C21C23],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I14I16
  mov   S4,esi
   mov  ebx,I24I26
  mov   ecx,I54I56
   mov  edx,I64I66
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C44C46],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C04C06],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C74C76],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C54C56],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C14C16],eax
   mov  PD [edi+C34C36],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I07I05
   mov  ebp,I77I75
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I37I35
   mov  eax,I47I45
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C64C66],ebx
   mov  PD [edi+C24C26],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I17I15
  mov   S4,esi
   mov  ebx,I27I25
  mov   ecx,I57I55
   mov  edx,I67I65
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C47C45],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C07C05],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C77C75],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C57C55],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C17C15],eax
   mov  PD [edi+C37C35],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,CoeffStreamStart
   lea  ebp,[edi-SIZEOF T_CoeffBlk]  ; Advance cursor for block action stream.
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   PD [edi+C67C65],ebx
   mov  PD [edi+C27C25],edx

; Forward Slant Transform is done

  cmp   ebp,ecx
   mov  edi,ebp
  mov   CoeffStream,edi
   jae  NextBlock               ; Process next block.


Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FORWARDDCT endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\locals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\locals.inv   1.1   27 Dec 1995 15:33:02   RMCKENZX  $
;// $Log:   S:\h26x\src\enc\locals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 15:33:02   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc

LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\memmodel.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//  $Header:   S:\h26x\src\enc\memmodel.inv   1.1   27 Dec 1995 15:33:02   RMCKENZX  $
;//	 $Log:   S:\h26x\src\enc\memmodel.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 15:33:02   RMCKENZX
;// Added copyright notice
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ccodecid.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:46  $
// $Archive:   S:\h26x\src\common\ccodecid.h_v  $
// $Header:   S:\h26x\src\common\ccodecid.h_v   1.2   27 Dec 1995 14:11:46   RMCKENZX  $
// $Log:   S:\h26x\src\common\ccodecid.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:11:46   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __CODECID_H__
#define __CODECID_H__

#define YVU9_CODEC   0
#define H263_CODEC   1
#define YUV12_CODEC  2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ccustmsg.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   KLILLEVO  $
// $Date:   10 Sep 1996 16:13:10  $
// $Archive:   S:\h26x\src\common\ccustmsg.h_v  $
// $Header:   S:\h26x\src\common\ccustmsg.h_v   1.10   10 Sep 1996 16:13:10   KLILLEVO  $
//	$Log:   S:\h26x\src\common\ccustmsg.h_v  $
;// 
;//    Rev 1.10   10 Sep 1996 16:13:10   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.9   22 Jul 1996 14:46:16   BECHOLS
;// 
;// fixed last comment.
;// 
;//    Rev 1.8   22 Jul 1996 14:38:08   BECHOLS
;// 
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.7   22 May 1996 18:47:32   BECHOLS
;// 
;// Added EC_RESET_TO_FACTORY_DEFAULTS.
;// 
;//    Rev 1.6   28 Apr 1996 17:48:04   BECHOLS
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// 
;//    Rev 1.5   04 Jan 1996 10:09:16   TRGARDOS
;// Added bit flag to signal still image.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:52   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.3   18 Dec 1995 13:49:06   TRGARDOS
// Added bit flags for H.263 options.
// 
//    Rev 1.2   01 Dec 1995 12:37:12   TRGARDOS
// Added defines for h.263 options.
// 
//    Rev 1.1   25 Oct 1995 20:12:42   TRGARDOS
// Added bit field mask for bitrate controller.
// 
//    Rev 1.0   31 Jul 1995 12:55:18   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:54   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:18   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
//
//  CODECUST.H include file for use with the Indeo codec.
//
//  This file defines custom messages that the driver recognizes.
//
//  Copyright 1994 - Intel Corporation
//
// ---------------------------------------------------------------------
*/

//  DRV_USER is defined in windows.h and mmsystem.h as 0x4000
#define ICM_RESERVED_HIGH			(DRV_USER+0x2000)
#define CUSTOM_START				(ICM_RESERVED_HIGH+1)

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// CODEC_CUSTOM_VIDEO_EFFECTS:
//    This message is used to control custom video effects, most of
//    which are common between the capture drivers and the codec drivers.
//
//    See drvcomon.h (Supplied and maintained by Video Manager team)
// --------------------------------------------------------------------- 

#define CODEC_CUSTOM_VIDEO_EFFECTS      (CUSTOM_START+ 8)
#define CODEC_CUSTOM_ENCODER_CONTROL    (CUSTOM_START+ 9)
#define APPLICATION_IDENTIFICATION_CODE (CUSTOM_START+10)
#define CODEC_CUSTOM_DECODER_CONTROL    (CUSTOM_START+11)
#define CUSTOM_ENABLE_CODEC				(CUSTOM_START+200)

#define CODEC_CUSTOM_RATE_CONTROL	     0x10000
#define CODEC_CUSTOM_PB		 		     0x20000
#define CODEC_CUSTOM_AP				     0x40000
#define CODEC_CUSTOM_UMV			     0x80000
#define CODEC_CUSTOM_SAC			    0x100000
#define CODEC_CUSTOM_STILL              0x200000

#define	G723MAGICWORD1					0xf7329ace
#define	G723MAGICWORD2					0xacdeaea2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5qrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\ex5qrle.asv   1.2   06 Feb 1996 09:12:10   KLILLEVO  $
;// $Log:   S:\h26x\src\enc\ex5qrle.asv  $
;// 
;//    Rev 1.2   06 Feb 1996 09:12:10   KLILLEVO
;// now quantizes INTER blocks as TMN5 specifies and simulator does
;// 
;//    Rev 1.1   27 Dec 1995 15:32:48   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

; QuantRLE -- This function performs quantization on a block of coefficients
;             and produces (run,level,sign) triples. (These triples are VLC by 
;             another routine.)  'run' is unsigned byte integer, 'level' is 
;             unsigned byte integer, and 'sign' is a signed byte integer with 
;             a value of either 0  or -1.
; Arguments:
;   CoeffStr: Starting Address of coefficient stream
;   CodeStr:  Starting address of code stream; i.e. starting address for code 
;             stream triples
; Returns:
; Dependencies:
;   The order of coefficient storage comes from e3dctc.inc file.  These coeff
;   appear as CxxCxx in this file.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

.xlist
include locals.inc
include memmodel.inc
include e3dctc.inc
.list

; READ-ONLY TABLE
.CONST

; QP can range from 1 to 31; but we build the following table for QP from 0 to
; 31 so that we can use indexing without subtracting 1 from QP or subtracting
; 8 from the displacement term.  In each pair, the first value is "2^32/2*QP"
; or "2^31/QP".  For some QP values, e.g. QP = 3, "2^31/QP" is an infinite
; bit string.  We check the most significant bit of the bit string that we are
; throwing away, if it is 1 then we increment the value.  For eaxmple,
; 2^31/3 is 2AAAAAAA.AAAAAA... but we use 2AAAAAAB as the table value.

ALIGN 8                       ; so that each pair is in a cache line

RecipINTER2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTERSubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP - QP/2, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FBH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07F0H                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F6H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F4H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F1H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07EFH                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07ECH                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EAH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07E7H                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07E5H                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E2H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E0H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07DDH                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07DBH                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07D8H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07D6H                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07D3H                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07D1H                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07CEH                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07CCH                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07C9H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07C7H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07C4H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07C2H                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07BFH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07BDH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07BAH                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07B8H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07B5H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07B3H                 ; QP = 31
QuantINTERSubTerm = RecipINTER2QP + 4

RecipINTRA2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTRASubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FCH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07FAH                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F8H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F6H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F4H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07F2H                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07F0H                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EEH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07ECH                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07EAH                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E8H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E6H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07E4H                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07E2H                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07E0H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07DEH                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07DCH                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07DAH                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07D8H                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07D6H                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07D4H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07D2H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07D0H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07CEH                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07CCH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07CAH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07C8H                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07C6H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07C4H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07C2H                 ; QP = 31
QuantINTRASubTerm = RecipINTRA2QP + 4

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

QUANTRLE  proc C ACoeffStr: DWORD, ACodeStr:DWORD, AQP:DWORD, AIntraFlag:DWORD

LocalFrameSize = 8
RegisterStorageSize = 16
SIGNHIGH = 1
SIGNLOW  = 17
IsINTRA  = 1
;;;;; Arguments:
ACoeffStr_arg = LocalFrameSize + RegisterStorageSize +  4
ACodeStr_arg  = LocalFrameSize + RegisterStorageSize +  8
AQP_arg       = LocalFrameSize + RegisterStorageSize + 12
AIntraFlag_arg= LocalFrameSize + RegisterStorageSize + 16
;;;;; Locals (on local stack frame)
QST	EQU 0
R2P	EQU 4

  push  esi
   push edi
  push  ebp
   push ebx
  sub   esp, LocalFrameSize

   mov cl,  63                       ; Initialize run-length (64 - 1)

  mov  ebx, PD [esp+AQP_arg]         ; copy parameters
   mov  esi, PD [esp+ACoeffStr_arg]  
  mov edx, RecipINTRA2QP[ebx*8]      ; RecipINTRA2QP = RecipINTER2QP
   mov edi, PD [esp+ACodeStr_arg]
  mov [esp + R2P], edx		     ; store Recip2QP[QP] as local variable
   mov al,  PB [esp+AIntraFlag_arg]
  mov  edx, PD [esi+C00C02]          ; First coeff
   test al,  IsINTRA
  je  QuantINTERC00

  
;
; OPTIMIZATIONS:
;   The usual code to compute absolute value has been enhanced to subtract the 
;   bias without using extra instructions or cycles.  Division is achieved by
;   multiplying with the reciprocal value.  High AC coefficients that will 
;   almost always be 0 are moved out-of-line towards the end of the routine.
;   This reduces the execution time if the conditional branch is not in the BTB;
;   it also reduces L1 footprint.
;   There is one more optimization I want to implement: pair instructions such
;   that the conditional branch instruction is executed in the U pipe.  The 
;   mispredicted branch penalty for U pipe is 3 and for V pipe is 4.  Since the 
;   low AC branches will frequently be mispredicted, this is a worthwhile 
;   optimization.
;
; esi -- base addr of coefficients; the order expected is the same as produced 
;        by Fast DCT
; edi -- RLE stream cursor
; ebx -- QP
; ecx -- run value indicator
; edx -- normally used to load coefficients
; eax,ebp -- scratch registers
;
QuantINTRAC00:
  mov edx, QuantINTRASubTerm[ebx*8] ; Fetch QuantSubTerm for INTRA
   mov  eax, PD [esi+C00C02]
  mov [esp + QST], edx		    ; Store QuantSubTerm as local variable
   mov PB [edi], 0H                 ; Run-length
  sar  eax, 23                      ; 8-bit signed INTRA-DC value
   mov edx, PD [esi+C01C03]         ; Pre-load next coefficient
  mov  PB [edi+2], ah               ; sign of DC 
   jnz @f
  mov  al, 1
@@:
  mov  PB [edi+1], al               ; DC
   add edi, 3
  mov  cl, 62                       ; 64 - Index (2 for C01)
   jmp QuantC01
QuantINTERC00:
  mov   eax, QuantINTERSubTerm[ebx*8]	; Fetch QuantSubTerm for INTER
   sal  edx, SIGNHIGH                   ; C == sign of the coefficient
  sbb  ebp, ebp                         ; -1 if coeff is negative else 0
   mov   [esp + QST], eax							; store QuantSubTerm as local variable
                                    
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C01C03]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC01
  lea   eax, [eax+2*ebx]
   mov  cl, 62                      ; Initialize run length counter
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], 0H                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C01C03]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   add  edi, 3                      ; Increment output pointer
QuantC01:
  sal   edx, SIGNHIGH               ; C == sign of the coefficient
   mov  eax, [esp + QST]    ; 0 for INTRA, QP for INTER
  sbb   ebp, ebp                    ; -1 if coeff is negative else 0
   ;                                ; 
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C10C12]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC10
  lea   eax, [eax+2*ebx]
   sub  cl, 62                      ; compute run-length
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], cl                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C10C12]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   mov  cl, 61                      ; Initialize run length counter
  add   edi, 3                      ; Increment output pointer
   mov  eax, eax                    ; To keep pairing happy
QuantC10:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC20
  lea   eax, [eax+2*ebx]
   sub  cl, 61                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 60                     
  add   edi, 3
   mov  eax, eax
QuantC20:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC11
  lea   eax, [eax+2*ebx]
   sub  cl, 60                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C11C13]       
  mov   PB [edi+2], al
   mov  cl, 59                      ;
  add   edi, 3
   mov  eax, eax
QuantC11:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C00C02]       
  sub   eax, ebp
   jl   QuantC02
  lea   eax, [eax+2*ebx]
   sub  cl, 59                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C00C02]       
  mov   PB [edi+2], al
   mov  cl, 58                     
  add   edi, 3
   mov  eax, eax
QuantC02:
  sal   edx, SIGNLOW
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C01C03]       
  sub   eax, ebp
   jl   QuantC03
  lea   eax, [eax+2*ebx]
   sub  cl, 58                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 57
  mov   edx, PD [esi+C01C03]
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC03:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C10C12]       
  sub   eax, ebp
   jl   QuantC12
  lea   eax, [eax+2*ebx]
   sub  cl, 57                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 56                    
  mov   edx, PD [esi+C10C12]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC12:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC21
  lea   eax, [eax+2*ebx]
   sub  cl, 56                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 55                    
  mov   edx, PD [esi+C21C23]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC21:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC30
  lea   eax, [eax+2*ebx]
   sub  cl, 55                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C30C32]       
  mov   PB [edi+2], al
   mov  cl, 54                    
  add   edi, 3
   mov  eax, eax
QuantC30:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC40
  lea   eax, [eax+2*ebx]
   sub  cl, 54                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 53                    
  add   edi, 3
   mov  eax, eax
QuantC40:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC31
  lea   eax, [eax+2*ebx]
   sub  cl, 53                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C31C33]       
  mov   PB [edi+2], al
   mov  cl, 52                    
  add   edi, 3
   mov  eax, eax
QuantC31:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC22
  lea   eax, [eax+2*ebx]
   sub  cl, 52                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 51                    
  add   edi, 3
   mov  eax, eax
QuantC22:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC13
  lea   eax, [eax+2*ebx]
   sub  cl, 51                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 50                    
  mov   edx, PD [esi+C11C13]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC13:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC04
  lea   eax, [eax+2*ebx]
   sub  cl, 50                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 49                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC04:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC05
  lea   eax, [eax+2*ebx]
   sub  cl, 49                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C07C05]       
  mov   PB [edi+2], al
   mov  cl, 48                    
  add   edi, 3
   mov  eax, eax
QuantC05:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC14
  lea   eax, [eax+2*ebx]
   sub  cl, 48                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 47                    
  mov   edx, PD [esi+C14C16]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC14:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC23
  lea   eax, [eax+2*ebx]
   sub  cl, 47                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C21C23]       
  mov   PB [edi+2], al
   mov  cl, 46                    
  add   edi, 3
   mov  eax, eax
QuantC23:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC32
  lea   eax, [eax+2*ebx]
   sub  cl, 46                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 45                    
  mov   edx, PD [esi+C30C32]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC32:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC41
  lea   eax, [eax+2*ebx]
   sub  cl, 45                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 44                    
  mov   edx, PD [esi+C41C43]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC41:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC50
  lea   eax, [eax+2*ebx]
   sub  cl, 44                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C50C52]       
  mov   PB [edi+2], al
   mov  cl, 43                    
  add   edi, 3
   mov  eax, eax
QuantC50:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jl   QuantC60
  lea   eax, [eax+2*ebx]
   sub  cl, 43                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 42                    
  add   edi, 3 
   mov  eax, eax
QuantC60:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC51
  lea   eax, [eax+2*ebx]
   sub  cl, 42                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C51C53]       
  mov   PB [edi+2], al
   mov  cl, 41                    
  add   edi, 3 
   mov  eax, eax
QuantC51:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC42
  lea   eax, [eax+2*ebx]
   sub  cl, 41                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 40                    
  add   edi, 3 
   mov  eax, eax
QuantC42:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC33
  lea   eax, [eax+2*ebx]
   sub  cl, 40                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 39                    
  mov   edx, PD [esi+C31C33]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC33:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC24
  lea   eax, [eax+2*ebx]
   sub  cl, 39                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 38                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC24:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC15
  lea   eax, [eax+2*ebx]
   sub  cl, 38                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C17C15]       
  mov   PB [edi+2], al
   mov  cl, 37                    
  add   edi, 3  
   mov  eax, eax
QuantC15:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC06
  lea   eax, [eax+2*ebx]
   sub  cl, 37                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 36                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC06:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC07
  lea   eax, [eax+2*ebx]
   sub  cl, 36                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 35                    
  mov   edx, PD [esi+C07C05]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3 
QuantC07:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC16
  lea   eax, [eax+2*ebx]
   sub  cl, 35                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C14C16]       
  mov   PB [edi+2], al
   mov  cl, 34                    
  add   edi, 3             
   mov  eax, eax
QuantC16:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jl   QuantC25
  lea   eax, [eax+2*ebx]
   sub  cl, 34                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 33                    
  mov   edx, PD [esi+C27C25]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC25:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jl   QuantC34
  lea   eax, [eax+2*ebx]
   sub  cl, 33                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 32                    
  mov   edx, PD [esi+C34C36]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC34:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC43
  lea   eax, [eax+2*ebx]
   sub  cl, 32                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C41C43]       
  mov   PB [edi+2], al
   mov  cl, 31                    
  add   edi, 3                    
   mov  eax, eax
QuantC43:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC52
  lea   eax, [eax+2*ebx]
   sub  cl, 31                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 30                    
  mov   edx, PD [esi+C50C52]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC52:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jl   QuantC61
  lea   eax, [eax+2*ebx]
   sub  cl, 30                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 29                    
  mov   edx, PD [esi+C61C63]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC61:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jge  QuantNZC61
QuantC70:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jge  QuantNZC70
QuantC71:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jge  QuantNZC71
QuantC62:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC53
  lea   eax, [eax+2*ebx]
   sub  cl, 26                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 25                    
  mov   edx, PD [esi+C51C53]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC53:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC44
  lea   eax, [eax+2*ebx]
   sub  cl, 25                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 24                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC44:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jge  QuantNZC44
QuantC35:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC26
  lea   eax, [eax+2*ebx]
   sub  cl, 23                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 22                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC26:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC17
  lea   eax, [eax+2*ebx]
   sub  cl, 22                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 21                    
  mov   edx, PD [esi+C17C15]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC17:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jge  QuantNZC17
QuantC27:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jge  QuantNZC27
QuantC36:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jl   QuantC45
  lea   eax, [eax+2*ebx]
   sub  cl, 19                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 18                    
  mov   edx, PD [esi+C47C45]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC45:
  sal   edx, SIGNLOW                      
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jl   QuantC54
  lea   eax, [eax+2*ebx]
   sub  cl, 18                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 17                    
  mov   edx, PD [esi+C54C56]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC54:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jge  QuantNZC54
QuantC63:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jl   QuantC72
  lea   eax, [eax+2*ebx]
   sub  cl, 16                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 15                    
  mov   edx, PD [esi+C70C72]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC72:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jl   QuantC73
  lea   eax, [eax+2*ebx]
   sub  cl, 15                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 14                    
  mov   edx, PD [esi+C71C73]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC73:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC64
  lea   eax, [eax+2*ebx]
   sub  cl, 14                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 13                    
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC64:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jge  QuantNZC64
QuantC55:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC46
  lea   eax, [eax+2*ebx]
   sub  cl, 12                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 11                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC46:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jl   QuantC37
  lea   eax, [eax+2*ebx]
   sub  cl, 11                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 10                    
  mov   edx, PD [esi+C37C35]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC37:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jge  QuantNZC37
QuantC47:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jge  QuantNZC47
QuantC56:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jl   QuantC65
  lea   eax, [eax+2*ebx]
   sub  cl, 8                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 7                     
  mov   edx, PD [esi+C67C65]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC65:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jl   QuantC74
  lea   eax, [eax+2*ebx]
   sub  cl, 7                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 6                     
  mov   edx, PD [esi+C74C76]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC74:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jge  QuantNZC74
QuantC75:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC66
  lea   eax, [eax+2*ebx]
   sub  cl, 5                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 4                     
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC66:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jl   QuantC57
  lea   eax, [eax+2*ebx]
   sub  cl, 4                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 3                     
  mov   edx, PD [esi+C57C55]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC57:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jge  QuantNZC57
QuantC67:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jge  QuantNZC67
QuantC76:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jl   QuantC77
  lea   eax, [eax+2*ebx]
   sub  cl, 1                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 0                     
  mov   edx, PD [esi+C77C75]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC77:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, edx                  
  sub   eax, ebp
   jge  QuantNZC77

; Quantization and RLE is done
QuantDone:
  mov   eax, edi                   ; Return value

  add   esp,LocalFrameSize
  pop   ebx
   pop  ebp
  pop   edi
   pop  esi
  rturn

QuantNZC61:
  lea   eax, [eax+2*ebx]
   sub  cl, 29                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C70C72]       
  mov   PB [edi+2], al
   mov  cl, 28                    
  add   edi, 3                    
   jmp  QuantC70
QuantNZC70:
  lea   eax, [eax+2*ebx]
   sub  cl, 28                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C71C73]       
  mov   PB [edi+2], al
   mov  cl, 27                    
  add   edi, 3                    
   jmp  QuantC71
QuantNZC71:
  lea   eax, [eax+2*ebx]
   sub  cl, 27                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 26                    
  add   edi, 3                    
   jmp  QuantC62
QuantNZC44:
  lea   eax, [eax+2*ebx]
   sub  cl, 24                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C37C35]       
  mov   PB [edi+2], al
   mov  cl, 23                    
  add   edi, 3                    
   jmp  QuantC35
QuantNZC17:
  lea   eax, [eax+2*ebx]
   sub  cl, 21                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C27C25]       
  mov   PB [edi+2], al
   mov  cl, 20                    
  add   edi, 3                    
   jmp  QuantC27
QuantNZC27:
  lea   eax, [eax+2*ebx]
   sub  cl, 20                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C34C36]       
  mov   PB [edi+2], al
   mov  cl, 19                    
  add   edi, 3                    
   jmp  QuantC36
QuantNZC54:
  lea   eax, [eax+2*ebx]
   sub  cl, 17                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C61C63]       
  mov   PB [edi+2], al
   mov  cl, 16                    
  add   edi, 3                    
   jmp  QuantC63
QuantNZC64:
  lea   eax, [eax+2*ebx]
   sub  cl, 13                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C57C55]       
  mov   PB [edi+2], al
   mov  cl, 12                    
  add   edi, 3                    
   jmp  QuantC55
QuantNZC37:
  lea   eax, [eax+2*ebx]
   sub  cl, 10                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C47C45]       
  mov   PB [edi+2], al
   mov  cl, 9                     
  add   edi, 3                    
   jmp  QuantC47
QuantNZC47:
  lea   eax, [eax+2*ebx]
   sub  cl, 9                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C54C56]       
  mov   PB [edi+2], al
   mov  cl, 8                     
  add   edi, 3                    
   jmp  QuantC56
QuantNZC74:
  lea   eax, [eax+2*ebx]
   sub  cl, 6                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C77C75]       
  mov   PB [edi+2], al
   mov  cl, 5                     
  add   edi, 3                    
   jmp  QuantC75
QuantNZC57:
  lea   eax, [eax+2*ebx]
   sub  cl, 3                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C67C65]       
  mov   PB [edi+2], al
   mov  cl, 2                     
  add   edi, 3                    
   jmp  QuantC67
QuantNZC67:
  lea   eax, [eax+2*ebx]
   sub  cl, 2                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C74C76]       
  mov   PB [edi+2], al
   mov  cl, 1                     
  add   edi, 3                    
   jmp  QuantC76
QuantNZC77:
  lea   eax, [eax+2*ebx]
   sub  cl, 0                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, edx                  
  mov   PB [edi+2], al  
  add   edi, 3                    
   jmp  QuantDone

QUANTRLE endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5me.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5me.asv   1.17   24 Sep 1996 11:27:00   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\ex5me.asv  $
;// 
;//    Rev 1.17   24 Sep 1996 11:27:00   BNICKERS
;// 
;// Fix register colision.
;// 
;//    Rev 1.16   24 Sep 1996 10:40:32   BNICKERS
;// For H261, zero out motion vectors when classifying MB as Intra.
;// 
;//    Rev 1.13   19 Aug 1996 13:48:26   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.12   17 Jun 1996 15:19:34   BNICKERS
;// Fix recording of block and MB SWDs for Spatial Loop Filtering case in H261.
;// 
;//    Rev 1.11   30 May 1996 16:40:14   BNICKERS
;// Fix order of arguments.
;// 
;//    Rev 1.10   30 May 1996 15:08:36   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.9   29 May 1996 15:37:58   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.8   15 Apr 1996 10:48:48   AKASAI
;// Fixed bug in Spatial loop filter code.  Code had been unrolled and
;// the second case had not been updated in the fix put in place of
;// (for) the first case.  Basically an ebx instead of bl that cased 
;// and overflow from 7F to 3F.
;// 
;//    Rev 1.7   15 Feb 1996 15:39:26   BNICKERS
;// No change.
;// 
;//    Rev 1.6   15 Feb 1996 14:39:00   BNICKERS
;// Fix bug wherein access to area outside stack frame was occurring.
;// 
;//    Rev 1.5   15 Jan 1996 14:31:40   BNICKERS
;// Fix decrement of ref area addr when half pel upward is best in block ME.
;// Broadcast macroblock level MV when block gets classified as Intra.
;// 
;//    Rev 1.4   12 Jan 1996 13:16:08   BNICKERS
;// Fix SLF so that 3 7F pels doesn't overflow, and result in 3F instead of 7F.
;// 
;//    Rev 1.3   27 Dec 1995 15:32:46   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   19 Dec 1995 17:11:16   RMCKENZX
;// fixed 2 bugs:
;//   1.  do +-15 pel search if central and NOT 4 mv / macroblock
;//      (was doing when central AND 4 mv / macroblock)
;//   2.  correctly compute motion vectors when doing 4 motion
;//      vectors per block.
;// 
;//    Rev 1.1   28 Nov 1995 15:25:48   AKASAI
;// Added white space so that will complie with the long lines.
;// 
;//    Rev 1.0   28 Nov 1995 14:37:00   BECHOLS
;// Initial revision.
;// 
;// 
;//    Rev 1.13   22 Nov 1995 15:32:42   DBRUCKS
;// Brian made this change on my system.
;// Increased a value to simplify debugging
;// 
;// 
;// 
;//    Rev 1.12   17 Nov 1995 10:43:58   BNICKERS
;// Fix problems with B-Frame ME.
;// 
;// 
;// 
;//    Rev 1.11   31 Oct 1995 11:44:26   BNICKERS
;// Save/restore ebx.
;//
;////////////////////////////////////////////////////////////////////////////
;
; MotionEstimation -- This function performs motion estimation for the macroblocks identified
;                     in the input list.
;                     Conditional assembly selects either the H263 or H261 version.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       FirstMEState -- must be 0 for macroblocks that are forced to be Intracoded.  An
;                       IntraSWD will be calculated.
;                       Other macroblocks must have the following values:
;                        1:  upper left, without advanced prediction.  (Advanced prediction
;                            only applies to H263.)
;                        2:  upper edge, without advanced prediction.
;                        3:  upper right, without advanced prediction.
;                        4:  left edge, without advanced prediction.
;                        5:  central block, or any block if advanced prediction is being done.
;                        6:  right edge, without advanced prediction.
;                        7:  lower left, without advanced prediction.
;                        8:  lower edge, without advanced prediction.
;                        9:  lower right, without advanced prediction.
;                       If vertical motion is NOT allowed:
;                       10:  left edge, without advanced prediction.
;                       11:  central block, or any block if advanced prediction is being done.
;                       12:  right edge, without advanced prediction.
;                       *** Note that with advanced prediction, only initial states 0, 4, or
;                           11 can be specified.  Doing block level motion vectors mandates
;                           advanced prediction, but in that case, only initial
;                           states 0 and 4 are allowed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the previous Y plane.  Whether this is the
;                               reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FilteredFrameBaseAddress -- Address of upper left viewable pel in the scratch area that this function can record
;                               the spatially filtered prediction for each block, so that frame differencing can
;                               utilize it rather than have to recompute it.  (H261 only)
;
;   DoRadius15Search -- TRUE if central macroblocks should search a distance of 15 from center.  Else searches 7 out.
;
;   DoHalfPelEstimation -- TRUE if we should do ME to half pel resolution.  This is only applicable for H263 and must
;                          be FALSE for H261.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   DoBlockLevelVectors -- TRUE if we should do ME at block level.  This is only applicable for H263 and must be FALSE
;                          for H261.  (Note:  TRUE must be 1; FALSE must be 0).
;   DoSpatialFiltering -- TRUE if we should determine if spatially filtering the prediction reduces the SWD.  Only
;                         applicable for H261 and must be FALSE for H263.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   ZeroVectorThreshold -- If the SWD for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWD is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   BlockMVDifferential -- The amount by which the sum of four block level SWDs must be better than a single macroblock
;                          level SWD to cause us to choose block level motion vectors.  See NonZeroDifferential for
;                          how the SWDs are calculated.  Only applicable for H261.  (Initial recommendation:  BMVD=128)
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
;   InterCodingThreshold -- If any of the blocks are forced empty, we can simply skip calculating the INTRASWD for the
;                           macroblock.  If none of the blocks are forced empty, we will compare the macroblock's SWD
;                           against this threshold.  If below the threshold, we will likewise skip calculating the
;                           INTRASWD.  Otherwise, we will calculate the INTRASWD, and if it is less than the [Inter]SWD,
;                           we will classify the block as INTRA-coded.  Compute as follows, where D is the average
;                           tolerable pel difference to satisfy threshold.  (Initial recommendation:  D=4 ==> ICT=1152)
;                             ICT = (128 * ((int)((D**1.6)+.5)))
;
;   IntraCodingDifferential -- For INTRA coding to occur, the INTRASWD must be better than the INTERSWD by at least
;                              this amount.
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BlockType -- Set to INTRA, INTER1MV, or (H263 only) INTER4MV.
;
;       PHMV and PVMV -- The horizontal and vertical motion vectors,  in units of a half pel.
;
;       BHMV and BVMV -- These fields get clobbered.
;
;       PastRef -- If BlockType != INTRA, set to the address of the reference block.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;                  Indications of a half pel position can only happen for H263.
;
;                  In H261, when spatial filtering is done, the address will be in the SpatiallyFilteredFrame, where
;                  this function stashes the spatially filtered prediction for subsequent reuse by frame differencing.
;
;       CodedBlocks -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                      FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                      Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that MotionEstimation forces empty;
;                      they are set otherwise.
;
;                      Bits 6 and 7 are left unchanged.
;                      
;       SWD -- Set to the sum of the SWDs for the four luma blocks in the macroblock.  The SWD for any block that is
;              forced empty, is NOT included in the sum.
;
;
;
;   IntraSWDTotal  -- The sum of the block SWDs for all Intracoded macroblocks.
;
;   IntraSWDBlocks -- The number of blocks that make up the IntraSWDTotal.
;
;   InterSWDTotal  -- The sum of the block SWDs for all Intercoded macroblocks.
;                     None of the blocks forced empty are included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the layout of current and previous frames (and spatially filtered
;   frame for H261) rigourously conforms to the following guide.
;
;   The spatially filtered frame (only present and applicable for H261) is an output frame into which MotionEstimation
;   places spatially filtered macroblocks as it determines if filtering is good for a macroblock.  If it determines
;   such, frame differencing will be able to re-use the spatially filtered macroblock, rather than recomputing it.
;
;   Cache
;   Alignment
;   Points:  v       v       v       v       v       v       v       v       v       v       v       v       v
;             16 | 352 (narrower pictures are left justified)                                            | 16
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Current Frame Y Plane                                                                | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected.)                                                                |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Current Frame U Plane                    | D |  Current Frame V Plane                    |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;            72 dummy bytes.  I.e. enough dummy space to assure that MOD ((Previous_Frame - Current_Frame), 128) == 80
;            +-----------------------------------------------------------------------------------------------+
;            |                                                                                               |
;   16 lines | If Unrestricted Motion Vectors selected, 16 lines must appear above and below previous frame, |
;            | and these lines plus the 16 columns to the left and 16 columns to the right of the previous   |
;            | frame must be initialized to the values at the edges and corners, propagated outward.  If     |
;            | Unrestricted Motion Vectors is off, these lines don't have to be allocated.                   |
;            |                                                                                               |
;            |   +---------------------------------------------------------------------------------------+   +
;   Frame    |   |  Previous Frame Y Plane                                                               |   |
;   Height   |   |                                                                                       |   |
;   Lines    |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   +---------------------------------------------------------------------------------------+   +
;            |                                                                                               |
;   16 lines | See comment above Previous Y Plane                                                            |
;            |                                                                                               |
;            |+--- 8 bytes of dummy space.  Must be there, whether unrestricted MV or not.                   |
;            ||                                                                                              |
;            |v+-----------------------------------------------+---------------------------------------------+-+
;            +-+                                               |                                               |
;              | See comment above Previous Y Plane.           | See comment above Previous Y Plane.           |
;   8 lines    | Same idea here, but 8 lines are needed above  | Same idea here, but 8 lines are needed        |
;              | and below U plane, and 8 columns on each side.| and below V plane, and 8 columns on each side.|
;              |                                               |                                               |
;              |8  176                                        8|8  176                                        8|
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              | |  Previous Frame U Plane                   | | |  Previous Frame V Plane                   | |
;   Frame      | |                                           | | |                                           | |
;   Height     | |                                           | | |                                           | |
;   Div By 2   | |                                           | | |                                           | |
;   Lines      | |                                           | | |                                           | |
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              |                                               |                                               |
;   8 lines    | See comment above Previous U Plane            | See comment above Previous V Plane            |
;              |                                               |                                               |
;              |                                               |                                               |
;              |                                               |                                               |
;              +-----------------------------------------------+---------------------------------------------+-+
;            Enough dummy space to assure that MOD ((Spatial_Frame - Previous_Frame), 4096) == 2032
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Spatially Filtered Y Plane (present only for H261)                                   | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected, which is certainly the case for H261.)                          |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Spatially Filtered U plane (H261 only)   | D |  Spatially Filtered V plane (H261 only)   |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;
; Cache layout of the target block and the full range for the reference area (as restricted to +/- 7 in vertical,
; and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box represents a cache line (32 bytes),
; increasing incrementally from left to right, and then to the next row (like reading a book).  The 128 boxes taken
; as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the reference area.  Each box contains 23 of the pels belonging to a line of the reference area.
;        The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;        predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that
;        begin at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance
;        we might search.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;        macroblocks.  There are 16 T's corresponding to the 16 lines of the macroblocks.
;
;   S -- Space for the spatially filtered macroblock (H261 only).
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.
; An algorithm has been selected that calculates fewer SWDs (Sum of Weighted Differences) than the typical log search.
; In the typical log search, a three level search is done, in which the SWDs are compared for the center point and a
; point at each 45 degrees, initially 4 pels away, then 2, then 1.  This requires a total of 25 SWDs for each
; macroblock (except those near edges or corners).
;
; In this algorithm, six levels are performed, with each odd level being a horizontal search, and each even level being
; a vertical search.  Each search compares the SWD for the center point with that of a point in each direction on the
; applicable axis.  This requires 13 SWDs, and a lot simpler control structure.  Here is an example picture of a
; search, in which "0" represents the initial center point (the 0,0 motion vector), "A", and "a" represent the first
; search points, etc.  In this example, the "winner" of each level of the search proceeds as follows:  a, B, C, C, E, F,
; arriving at a motion vector of -1 horizontal, 5 vertical.
;
;                ...............
;                ...............
;                ...............
;                ...b...........
;                ...............
;                ...............
;                ...............
;                ...a...0...A...
;                ...............
;                .....d.........
;                ......f........
;                .c.BeCE........
;                ......F........
;                .....D.........
;                ...............
;
;
; A word about data cache performance.  Conceptually, the tables and local variables used by this function are placed
; in memory such that they will fit in one 4K page of the on-chip data cache.  For the Pentium (tm) microprocessor,
; this leaves the other 4K page for other purposes.  The other data structures consist of:
;
;   The current frame, from which we need to access the lines of the 16*16 macroblock.  Since cache lines are 32 bytes
;   wide, the cache fill operations that fetch one target macroblock will serve to fetch the macroblock to the right,
;   so an average of 8 cache lines are fetched for each macroblock.
;
;   The previous frame, from which we need to access a reference area of 30*30 pels.  For each macroblock for which we
;   need to search for a motion vector, we will typically need to access no more than about 25 of these, but in general
;   these lines span the 30 lines of the search area.  Since cache lines are 32 bytes wide, the cache fill operations
;   that fetch reference data for one macroblock, will tend to fetch data that is useful as reference data for the
;   macroblock to the right, so an average of about 15 (rounded up to be safe) cache lines are fetched for each
;   macroblock.
;
;   The MBlockActionStream, which controls the searching (since we don't need to motion estimate blocks that are
;   legislated to be intra) will disrupt cache behaviour of the other data structures, but not to a significant degree.
;
; By setting the pitch to a constant of 384, and by allocating the frames as described above, the one available 4K page
; of data cache will be able to contain the 30 lines of the reference area, the 16 lines of the target area, and the
; 16 lines of the spatially filtered area (H261 only) without any collisions.
;
;
; Here is a flowchart of the major sections of this function:
;
; +-- Execute once for Y part of each macroblock that is NOT Intra By Decree --+
; |                                                                            |
; |   +---------------------------------------------------------------+        |
; |   |  1) Compute average value for target match points.            |        |
; |   |  2) Prepare match points in target MB for easier matching.    |        |
; |   |  3) Compute the SWD for (0,0) motion vector.                  |        |
; |   +---------------------------------------------------------------+        |
; |                 |                                                          |
; |                 v                                                          |
; |           /---------------------------------\  Yes                         |
; |          < 4) Is 0-motion SWD good enough?   >-------------------------+   |
; |           \---------------------------------/                          |   |
; |                                          |                             |   |
; |                                          |No                           |   |
; |                                          v                             |   |
; |     +--- 5) While state engine has more motion vectors to check ---+   |   |
; |     |                                                              |   |   |
; |     |                                                              |   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |   | 5) Compute SWDs for 2 ref MBs and pick best of 3. |----->|   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |                                                              |   |   |
; |     +--------------------------------------------------------------+   |   |
; |                             |                                          |   |
; |                             v                                          |   |
; |                /-----------------------------------------\             |   |
; |               <  6) Is best motion vector the 0-vector?   >            |   |
; |                \-----------------------------------------/             |   |
; |                   |              |                                     |   |
; |                   |No            |Yes                                  |   |
; |                   v              v                                     |   |
; |     +-----------------+ +-------------------------------------------+  |   |
; |     | Mark all blocks | |  6) Identify as empty block any in which: |<-+   |
; |  +--| non-empty.      | |     -->  0-motion SWD < EmptyThresh, and  |      |
; |  |  +-----------------+ +-------------------------------------------+      |
; |  |                          |                                              |
; |  |                          v                                              |
; |  |   /--------------------------------\ Yes +--------------------------+   |
; |  |  <  6) Are all blocks marked empty? >--->|  6) Classify FORCEDEMPTY |-->|
; |  |   \--------------------------------/     +--------------------------+   |
; |  |                |                                                        |
; |  |                |No                                                      |
; |  |                v                                                        |
; |  |        /--------------------------------------------\                   |
; |  |       <  7) Are any non-phantom blocks marked empty? >                  |
; |  |        \--------------------------------------------/                   |
; |  |                |            |                                           |
; |  |                |No          |Yes                                        |
; |  v                v            v                                           |
; | +---------------------+   +--------------------------------+               |
; | | 8) Compute IntraSWD |   | Set IntraSWD artificially high |               |
; | +---------------------+   +--------------------------------+               |
; |              |                 |                                           |
; |              v                 v                                           |
; |         +-------------------------------+                                  |
; |         | 10) Classify block as one of: |                                  |
; |         |       INTRA                   |--------------------------------->|
; |         |       INTER                   |                                  |
; |         +-------------------------------+                                  |
; |                                                                            |
; +----------------------------------------------------------------------------+
;
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

;  Storage for tables and temps used by Motion Estimation function.  Fit into
;  4Kbytes contiguous memory so that it uses one cache page, leaving other
;  for reference area of previous frame and target macroblock of current frame.

PickPoint     DB  0,4,?,4,0,?,2,2 ; Map CF accum to new central pt selector.
IFNDEF H261
PickPoint_BLS DB  6,4,?,4,6,?,2,2 ; Same, for when doing block level search.
ENDIF

OffsetToRef LABEL DWORD    ; Linearized adjustments to affect horz/vert motion.
   DD  ?        ; This index used when zero-valued motion vector is good enough.
   DD  0        ; Best fit of 3 SWDs is previous center.
   DD  1        ; Best fit of 3 SWDs is the ref block 1 pel to the right.
   DD -1        ; Best fit of 3 SWDs is the ref block 1 pel to the left.
   DD  1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel above.
   DD -1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel below.
   DD  2        ; Best fit of 3 SWDs is the ref block 2 pels to the right.
   DD -2        ; Best fit of 3 SWDs is the ref block 2 pels to the left.
   DD  2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel above.
   DD -2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel below.
   DD  4        ; Best fit of 3 SWDs is the ref block 4 pels to the right.
   DD -4        ; Best fit of 3 SWDs is the ref block 4 pels to the left.
   DD  4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel above.
   DD -4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel below.
   DD  7        ; Best fit of 3 SWDs is the ref block 7 pels to the right.
   DD -7        ; Best fit of 3 SWDs is the ref block 7 pels to the left.
   DD  7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel above.
   DD -7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel below.

M0   =  4  ; Define symbolic indices into OffsetToRef lookup table.
MHP1 =  8
MHN1 = 12
MVP1 = 16
MVN1 = 20
MHP2 = 24
MHN2 = 28
MVP2 = 32
MVN2 = 36
MHP4 = 40
MHN4 = 44
MVP4 = 48
MVN4 = 52
MHP7 = 56
MHN7 = 60
MVP7 = 64
MVN7 = 68

                ; Map linearized motion vector to vertical part.
                ; (Mask bottom byte of linearized MV to zero, then use result
                ; as index into this array to get vertical MV.)
IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30

; Map initial states to initializers for half pel search.  Where search would
; illegally take us off edge of picture, set initializer artificially high.

IFNDEF H261
InitHalfPelSearchHorz LABEL DWORD
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H

InitHalfPelSearchVert LABEL DWORD
  DD 040000000H, 040000000H, 040000000H
  DD 000000000H, 000000000H, 000000000H
  DD 000004000H, 000004000H, 000004000H
  DD 040004000H, 040004000H, 040004000H
ENDIF

SWDState LABEL BYTE ; Rules that govern state engine of motion estimator.

   DB   8 DUP (?)       ; 0:  not used.

                        ; 1:  Upper Left Corner.  Explore 4 right and 4 down.
   DB  21, M0           ; (0,0)
   DB  22, MHP4         ; (0,4)
   DB  23, MVP4, ?, ?   ; (4,0)

                        ; 2:  Upper Edge.  Explore 4 left and 4 right.
   DB  22, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  22, MHP4, ?, ?   ; (0, 4)

                        ; 3:  Upper Right Corner.  Explore 4 right and 4 down.
   DB  31, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  32, MVP4, ?, ?   ; (4, 0)

                        ; 4:  Left Edge.  Explore 4 up and 4 down.
   DB  23, M0           ; ( 0,0)
   DB  23, MVN4         ; (-4,0)
   DB  23, MVP4, ?, ?   ; ( 4,0)

                        ; 5:  Interior Macroblock.  Explore 4 up and 4 down.
   DB  37, M0           ; ( 0,0)
   DB  37, MVN4         ; (-4,0)
   DB  37, MVP4, ?, ?   ; ( 4,0)

                        ; 6:  Right Edge.  Explore 4 up and 4 down.
   DB  32, M0           ; ( 0,0)
   DB  32, MVN4         ; (-4,0)
   DB  32, MVP4, ?, ?   ; ( 4,0)

                        ; 7:  Lower Left Corner.  Explore 4 up and 4 right.
   DB  38, M0           ; ( 0,0)
   DB  39, MHP4         ; ( 0,4)
   DB  23, MVN4, ?, ?   ; (-4,0)

                        ; 8:  Lower Edge.  Explore 4 left and 4 right.
   DB  39, M0           ; (0, 0)
   DB  39, MHN4         ; (0,-4)
   DB  39, MHP4, ?, ?   ; (0, 4)

                        ; 9:  Lower Right Corner.  Explore 4 up and 4 left.
   DB  44, M0           ; ( 0, 0)
   DB  39, MHN4         ; ( 0,-4)
   DB  32, MVN4, ?, ?   ; (-4, 0)

                        ; 10: Left Edge, No Vertical Motion Allowed.
   DB  46, M0           ; (0,0)
   DB  48, MHP2         ; (0,2)
   DB  47, MHP4, ?, ?   ; (0,4)

                        ; 11: Interior Macroblock, No Vertical Motion Allowed.
   DB  47, M0           ; (0, 0)
   DB  47, MHN4         ; (0,-4)
   DB  47, MHP4, ?, ?   ; (0, 4)

                        ; 12: Right Edge, No Vertical Motion Allowed.
   DB  49, M0           ; (0, 0)
   DB  48, MHN2         ; (0,-2)
   DB  47, MHN4, ?, ?   ; (0,-4)

                        ; 13: Horz by 2, Vert by 2, Horz by 1, Vert by 1.
   DB  14, M0 
   DB  14, MHP2 
   DB  14, MHN2, ?, ? 

                        ; 14: Vert by 2, Horz by 1, Vert by 1.
   DB  15, M0 
   DB  15, MVP2 
   DB  15, MVN2, ?, ? 

                        ; 15: Horz by 1, Vert by 1.
   DB  16, M0 
   DB  16, MHP1 
   DB  16, MHN1, ?, ? 

                        ; 16: Vert by 1.
   DB   0, M0
   DB   0, MVP1
   DB   0, MVN1, ?, ?

                        ; 17: Vert by 2, Horz by 2, Vert by 1, Horz by 1.
   DB  18, M0
   DB  18, MVP2
   DB  18, MVN2, ?, ?

                        ; 18: Horz by 2, Vert by 1, Horz by 1.
   DB  19, M0
   DB  19, MHP2
   DB  19, MHN2, ?, ?

                        ; 19: Vert by 1, Horz by 1.
   DB  20, M0
   DB  20, MVP1
   DB  20, MVN1, ?, ?

                        ; 20: Horz by 1.
   DB   0, M0
   DB   0, MHP1
   DB   0, MHN1, ?, ?

                        ; 21: From 1A.  Upper Left.  Try 2 right and 2 down.
   DB  24, M0           ; (0, 0)
   DB  25, MHP2         ; (0, 2)
   DB  26, MVP2, ?, ?   ; (2, 0)

                        ; 22: From  1B.
                        ;     From  2  center point would be (0,-4/0/4).
                        ;     From  3B center point would be (0,-4).
   DB  27, M0           ; (0, 4)
   DB  18, MVP2         ; (2, 4) Next: Horz 2, Vert 1, Horz 1.         (1:3,1:7)
   DB  13, MVP4, ?, ?   ; (4, 4) Next: Horz 2, Vert 2, Horz 1, Vert 1. (1:7,1:7)

                        ; 23: From  1C.
                        ;     From  4  center point would be (-4/0/4,0).
                        ;     From  7C center point would be (-4,0).
   DB  29, M0           ; (4, 0)
   DB  14, MHP2         ; (4, 2) Next: Vert 2, Horz 1, Vert 1.         (1:7,1:3)
   DB  17, MHP4, ?, ?   ; (4, 4) Next: Vert 2, Horz 2, Vert 1, Horz 1. (1:7,1:7)

                        ; 24: From 21A.  Upper Left.  Try 1 right and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHP1         ; (1, 0)
   DB   0, MVP1, ?, ?   ; (0, 1)

                        ; 25: From 21B.
                        ;     From 31B center point would be (0,-2).
   DB  20, M0           ; (0, 2) Next: Horz 1                            (0,1:3)
   DB  20, MVP1         ; (1, 2) Next: Horz 1                            (1,1:3)
   DB  15, MVP2, ?, ?   ; (2, 2) Next: Horz 1, Vert 1                  (1:3,1:3)

                        ; 26: From 21C.
                        ;     From 38C center point would be (-2,0).
   DB  16, M0           ; (2, 0) Next: Vert 1                            (1:3,0)
   DB  16, MHP1         ; (2, 1) Next: Vert 1                            (1:3,1)
   DB  19, MHP2, ?, ?   ; (2, 2) Next: Vert 1, Horz 1                  (1:3,1:3)

                        ; 27: From 22A.
   DB  28, M0           ; (0, 4)
   DB  28, MHN2         ; (0, 2)
   DB  28, MHP2, ?, ?   ; (0, 6)

                        ; 28: From 27.
   DB  20, M0           ; (0, 2/4/6) Next: Horz 1.                       (0,1:7)
   DB  20, MVP1         ; (1, 2/4/6) Next: Horz 1.                       (1,1:7)
   DB  20, MVP2, ?, ?   ; (2, 2/4/6) Next: Horz 1.                       (2,1:7)

                        ; 29: From 23A.
   DB  30, M0           ; (4, 0)
   DB  30, MVN2         ; (2, 0)
   DB  30, MVP2, ?, ?   ; (6, 0)

                        ; 30: From 29.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                       (1:7,0)
   DB  16, MHP1         ; (2/4/6, 1) Next: Vert 1.                       (1:7,1)
   DB  16, MHP2, ?, ?   ; (2/4/6, 2) Next: Vert 1.                       (1:7,2)

                        ; 31: From  3A.  Upper Right.  Try 2 left and 2 down.
   DB  33, M0           ; (0, 0)
   DB  25, MHN2         ; (0,-2)
   DB  34, MVP2, ?, ?   ; (2, 0)

                        ; 32: From  3C.
                        ;     From  6  center point would be (-4/0/4, 0)
                        ;     From  9C center point would be (-4, 0)
   DB  35, M0           ; (4, 0)
   DB  14, MHN2         ; (4,-2) Next: Vert2,Horz1,Vert1.            (1:7,-1:-3)
   DB  17, MHN4, ?, ?   ; (4,-4) Next: Vert2,Horz2,Vert1,Horz1.      (1:7,-1:-7)

                        ; 33: From 31A.  Upper Right.  Try 1 left and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MVP1, ?, ?   ; (1, 0)

                        ; 34: From 31C.
                        ;     From 44C center point would be (-2, 0)
   DB  16, M0           ; (2, 0) Next: Vert 1                           (1:3, 0)
   DB  16, MHN1         ; (2,-1) Next: Vert 1                           (1:3,-1)
   DB  19, MHN2, ?, ?   ; (2,-2) Next: Vert 1, Horz 1                (1:3,-1:-3)

                        ; 35: From 32A.
   DB  36, M0           ; (4, 0)
   DB  36, MVN2         ; (2, 0)
   DB  36, MVP2, ?, ?   ; (6, 0)

                        ; 36: From 35.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                      (1:7, 0)
   DB  16, MHN1         ; (2/4/6,-1) Next: Vert 1.                      (1:7,-1)
   DB  16, MHN2, ?, ?   ; (2/4/6,-2) Next: Vert 1.                      (1:7,-2)

                        ; 37: From  5.
   DB  17, M0           ; (-4/0/4, 0) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-3: 3)
   DB  17, MHP4         ; (-4/0/4,-4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7, 1: 7)
   DB  17, MHN4, ?, ?   ; (-4/0/4, 4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-7:-1)

                        ; 38: From 7A.  Lower Left.  Try 2 right and 2 up.
   DB  42, M0           ; ( 0,0)
   DB  43, MHP2         ; ( 0,2)
   DB  26, MVN2, ?, ?   ; (-2,0)

                        ; 39: From 13B.
                        ;     From 14  center point would be (0,-4/0/4)
                        ;     From 16B center point would be (0,-4)
   DB  40, M0           ; ( 0,4)
   DB  18, MVN2         ; (-2,4) Next: Horz2,Vert1,Horz1.            (-3:-1,1:7)
   DB  13, MVN4, ?, ?   ; (-4,4) Next: Horz2,Vert2,Horz1,Vert1.      (-7:-1,1:7)

                        ; 40: From 39A.
   DB  41, M0           ; (0, 4)
   DB  41, MHN2         ; (0, 2)
   DB  41, MHP2, ?, ?   ; (0, 6)

                        ; 41: From 40.
   DB  20, M0           ; ( 0,2/4/6) Next: Horz 1.                      ( 0,1:7)
   DB  20, MVN1         ; (-1,2/4/6) Next: Horz 1.                      (-1,1:7)
   DB  20, MVN2, ?, ?   ; (-2,2/4/6) Next: Horz 1.                      (-2,1:7)

                        ; 42: From 38A.  Lower Left.  Try 1 right and 1 up.
   DB   0, M0           ; ( 0,0)
   DB   0, MHP1         ; ( 0,1)
   DB   0, MVN1, ?, ?   ; (-1,0)

                        ; 43: From 38B.
                        ;     From 44B center point would be (0,-2)
   DB  20, M0           ; ( 0,2) Next: Horz 1                           ( 0,1:3)
   DB  20, MVN1         ; (-1,2) Next: Horz 1                           (-1,1:3)
   DB  15, MVN2, ?, ?   ; (-2,2) Next: Horz 1, Vert 1                (-1:-3,1:3)

                        ; 44: From 9A.  Lower Right.  Try 2 left and 2 up.
   DB  45, M0           ; ( 0, 0)
   DB  43, MHN2         ; ( 0,-2)
   DB  34, MVN2, ?, ?   ; (-2, 0)

                        ; 45: From 44A.  Lower Right.  Try 1 left and 1 up.
   DB   0, M0           ; ( 0, 0)
   DB   0, MHN1         ; ( 0,-1)
   DB   0, MVN1, ?, ?   ; (-1, 0)

                        ; 46: From 17A.
   DB   0, M0           ; (0,0)
   DB   0, MHP1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,1)

                        ; 47: From 10C.
                        ;     From 11 center point would be (0,4/0/-4)
                        ;     From 12C center point would be (0,-4)
   DB  48, M0           ; (0,4)
   DB  48, MHN2         ; (0,2)
   DB  48, MHP2, ?, ?   ; (0,6)

                        ; 48 From 10B.
                        ;    From 47  center point would be (0,2/4/6)
                        ;    From 12B center point would be (0,-2)
   DB   0, M0           ; (0,2)
   DB   0, MHN1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,3)

                        ; 49 From 12A.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MHN1, ?, ?   ; (0,-1)

                        ; 50:  Interior Macroblock.  Explore 7 up and 7 down.
   DB  51, M0           ; ( 0,0)
   DB  51, MVN7         ; (-7,0)
   DB  51, MVP7, ?, ?   ; ( 7,0)

                        ; 51:  Explore 7 left and 7 right.
   DB   5, M0           ; (-7|0|7, 0)
   DB   5, MHN7         ; (-7|0|7,-7)
   DB   5, MHP7, ?, ?   ; (-7|0|7, 7)

MulByNeg8 LABEL DWORD

CNT = 0
REPEAT 128
  DD WeightedDiff+CNT
  CNT = CNT - 8
ENDM


  ; The following treachery puts the numbers into byte 2 of each aligned DWORD.
  DB   0,  0
  DD 193 DUP (255)
  DD 250,243,237,231,225,219,213,207,201,195,189,184,178,172,167,162,156
  DD 151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89, 84, 80, 76
  DD  72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31, 28, 25, 22, 20
  DD  18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1
  DB   0,  0
WeightedDiff LABEL DWORD
  DB   0,  0
  DD   0,  0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18
  DD  20, 22, 25, 28, 31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72
  DD  76, 80, 84, 89, 93, 97,102,107,111,116,121,126,130,135,141,146,151
  DD 156,162,167,172,178,184,189,195,201,207,213,219,225,231,237,243,250
  DD 191 DUP (255)
  DB 255,  0


IFNDEF H261
MotionOffsets DD 1*PITCH,0,?,?
ENDIF

RemnantOfCacheLine DB 8 DUP (?)


LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses
                          ; whose lower 12 bits match this address.

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MOTIONESTIMATION proc C AMBAS: DWORD,
ATargFrmBase: DWORD,
APrevFrmBase: DWORD,
AFiltFrmBase: DWORD,
ADo15Search: DWORD,
ADoHalfPelEst: DWORD,
ADoBlkLvlVec: DWORD,
ADoSpatialFilt: DWORD,
AZeroVectorThresh: DWORD,
ANonZeroMVDiff: DWORD,
ABlockMVDiff: DWORD,
AEmptyThresh: DWORD,
AInterCodThresh: DWORD,
AIntraCodDiff: DWORD,
ASpatialFiltThresh: DWORD,
ASpatialFiltDiff: DWORD,
AIntraSWDTot: DWORD,
AIntraSWDBlks: DWORD,
AInterSWDTot: DWORD,
AInterSWDBlks: DWORD

LocalFrameSize = 128 + 168*4 + 32   ; 128 for locals;  168*4 for blocks;  32 for dummy block.
RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +  4
TargetFrameBaseAddress_arg   = RegStoSize +  8
PreviousFrameBaseAddress_arg = RegStoSize + 12
FilteredFrameBaseAddress_arg = RegStoSize + 16
DoRadius15Search_arg         = RegStoSize + 20
DoHalfPelEstimation_arg      = RegStoSize + 24
DoBlockLevelVectors_arg      = RegStoSize + 28
DoSpatialFiltering_arg       = RegStoSize + 32
ZeroVectorThreshold_arg      = RegStoSize + 36
NonZeroMVDifferential_arg    = RegStoSize + 40
BlockMVDifferential_arg      = RegStoSize + 44
EmptyThreshold_arg           = RegStoSize + 48
InterCodingThreshold_arg     = RegStoSize + 52
IntraCodingDifferential_arg  = RegStoSize + 56
SpatialFiltThreshold_arg     = RegStoSize + 60
SpatialFiltDifferential_arg  = RegStoSize + 64
IntraSWDTotal_arg            = RegStoSize + 68
IntraSWDBlocks_arg           = RegStoSize + 72
InterSWDTotal_arg            = RegStoSize + 76
InterSWDBlocks_arg           = RegStoSize + 80
EndOfArgList                 = RegStoSize + 84

; Locals (on local stack frame)

MBlockActionStream       EQU [esp+   0]
CurrSWDState             EQU [esp+   4]
MotionOffsetsCursor      EQU CurrSWDState
HalfPelHorzSavings       EQU CurrSWDState
VertFilterDoneAddr       EQU CurrSWDState
IntraSWDTotal            EQU [esp+   8]
IntraSWDBlocks           EQU [esp+  12]
InterSWDTotal            EQU [esp+  16]
InterSWDBlocks           EQU [esp+  20]

MBCentralInterSWD        EQU [esp+  24]
MBRef1InterSWD           EQU [esp+  28]
MBRef2InterSWD           EQU [esp+  32]
MBCentralInterSWD_BLS    EQU [esp+  36]
MB0MVInterSWD            EQU [esp+  40]
MBAddrCentralPoint       EQU [esp+  44]
MBMotionVectors          EQU [esp+  48]

DoHalfPelEstimation      EQU [esp+  52]
DoBlockLevelVectors      EQU [esp+  56]
DoSpatialFiltering       EQU [esp+  60]
ZeroVectorThreshold      EQU [esp+  64]
NonZeroMVDifferential    EQU [esp+  68]
BlockMVDifferential      EQU [esp+  72]
EmptyThreshold           EQU [esp+  76]
InterCodingThreshold     EQU [esp+  80]
IntraCodingDifferential  EQU [esp+  84]
SpatialFiltThreshold     EQU [esp+  88]
SpatialFiltDifferential  EQU [esp+  92]
TargetMBAddr             EQU [esp+  96]
TargetFrameBaseAddress   EQU [esp+ 100]
PreviousFrameBaseAddress EQU [esp+ 104]
TargToRef                EQU [esp+ 108]
TargToSLF                EQU [esp+ 112]
DoRadius15Search         EQU [esp+ 116]

StashESP                 EQU [esp+ 120]

BlockLen                 EQU 168
Block1                   EQU [esp+  128+40]      ; "128" is for locals.  "40" is so offsets range from -40 to 124.
Block2                   EQU Block1  + BlockLen
Block3                   EQU Block2  + BlockLen
Block4                   EQU Block3  + BlockLen
BlockN                   EQU Block4  + BlockLen
BlockNM1                 EQU Block4
BlockNM2                 EQU Block3
BlockNP1                 EQU Block4  + BlockLen + BlockLen
DummyBlock               EQU Block4  + BlockLen


Ref1Addr                 EQU  -40
Ref2Addr                 EQU  -36
AddrCentralPoint         EQU  -32
CentralInterSWD          EQU  -28
Ref1InterSWD             EQU  -24
Ref2InterSWD             EQU  -20
CentralInterSWD_BLS      EQU  -16  ; CentralInterSWD, when doing blk level search.
CentralInterSWD_SLF      EQU  -16  ; CentralInterSWD, when doing spatial filter.
HalfPelSavings           EQU  Ref2Addr
ZeroMVInterSWD           EQU  -12
BlkHMV                   EQU   -8
BlkVMV                   EQU   -7
BlkMVs                   EQU   -8
AccumTargetPels          EQU   -4

; Offsets for Negated Quadrupled Target Pels:
N8T00                    EQU    0
N8T04                    EQU    4
N8T02                    EQU    8
N8T06                    EQU   12
N8T20                    EQU   16
N8T24                    EQU   20
N8T22                    EQU   24
N8T26                    EQU   28
N8T40                    EQU   32
N8T44                    EQU   36
N8T42                    EQU   40
N8T46                    EQU   44
N8T60                    EQU   48
N8T64                    EQU   52
N8T62                    EQU   56
N8T66                    EQU   60
N8T11                    EQU   64
N8T15                    EQU   68
N8T13                    EQU   72
N8T17                    EQU   76
N8T31                    EQU   80
N8T35                    EQU   84
N8T33                    EQU   88
N8T37                    EQU   92
N8T51                    EQU   96
N8T55                    EQU  100
N8T53                    EQU  104
N8T57                    EQU  108
N8T71                    EQU  112
N8T75                    EQU  116
N8T73                    EQU  120
N8T77                    EQU  124

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   eax,[esp]                   ; Cause system to commit page.
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+31
  and   ebx,000000FE0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  ebx,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,ebx
   sub  ebx,eax
  mov   ecx,PD [esi+FilteredFrameBaseAddress_arg]
  sub   ecx,eax
   mov  TargToRef,ebx
  mov   TargToSLF,ecx
   mov  eax,PD [esi+EmptyThreshold_arg]
  mov   EmptyThreshold,eax
   mov  eax,PD [esi+DoHalfPelEstimation_arg]
  mov   DoHalfPelEstimation,eax
   mov  eax,PD [esi+DoBlockLevelVectors_arg]
  mov   DoBlockLevelVectors,eax
   mov  eax,PD [esi+DoRadius15Search_arg]
  mov   DoRadius15Search,eax
   mov  eax,PD [esi+DoSpatialFiltering_arg]
  mov   DoSpatialFiltering,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  eax,PD [esi+BlockMVDifferential_arg]
  mov   BlockMVDifferential,eax
   mov  eax,PD [esi+InterCodingThreshold_arg]
  mov   InterCodingThreshold,eax
   mov  eax,PD [esi+IntraCodingDifferential_arg]
  mov   IntraCodingDifferential,eax
   mov  eax,PD [esi+SpatialFiltThreshold_arg]
  mov   SpatialFiltThreshold,eax
   mov  eax,PD [esi+SpatialFiltDifferential_arg]
  mov   SpatialFiltDifferential,eax
   xor  ebx,ebx
  mov   IntraSWDBlocks,ebx
   mov  InterSWDBlocks,ebx
  mov   IntraSWDTotal,ebx
   mov  InterSWDTotal,ebx
  mov   Block1.BlkMVs,ebx
   mov  Block2.BlkMVs,ebx
  mov   Block3.BlkMVs,ebx
   mov  Block4.BlkMVs,ebx
  mov   DummyBlock.Ref1Addr,esp
   mov  DummyBlock.Ref2Addr,esp
  mov   StashESP,esi
   jmp  FirstMacroBlock

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     1)  To calculate an average value for the target match points of each
;         block, we sum the 32 match points.  The totals for each of the 4
;         blocks is output seperately.
;
;     2)  Define each prepared match point in the target macroblock as the
;         real match point times negative 8, with the base address of the
;         WeightedDiff lookup table added.  I.e.
;
;           for (i = 0; i < 16; i += 2)
;             for (j = 0; j < 16; j += 2)
;               N8T[i][j] = ( -8 * Target[i][j]) + ((U32) WeightedDiff);
;
;         Both the multiply and the add of the WeightedDiff array base are
;         effected by a table lookup into the array MulByNeg8.
;
;         Then the SWD of a reference macroblock can be calculated as follows:
;
;           SWD = 0;
;           for each match point (i,j)
;               SWD += *((U32 *) (N8T[i][j] + 8 * Ref[i][j]));
;
;         In assembly, the fetch of WeightedDiff array element amounts to this:
;
;           mov edi,DWORD PTR N8T[i][j]   ; Fetch N8T[i][j]
;           mov dl,BYTE PTR Ref[i][j]     ; Fetch Ref[i][j]
;           mov edi,DWORD PTR[edi+edx*8]  ; Fetch WeithtedDiff of target & ref.
;
;     3)  We calculate the 0-motion SWD, as described just above.  We use 32
;         match points per block, and write the result seperately for each
;         block.  The result is accumulated into the high half of ebp.
;
;     4)  If the SWD for the 0-motion vector is below a threshold, we don't
;         bother searching for other possibly better motion vectors.  Presently,
;         this threshold is set such that an average difference of less than
;         three per match point causes the 0-motion vector to be accepted.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edx -- MBlockActionStream
;
;   Predominate usage for body of this section:
;
;     esi -- Target block address.
;     edi -- 0-motion reference block address.
;     ebp[ 0:12] -- Accumulator for target pels.
;     ebp[13:15] -- Loop control
;     ebp[16:31] -- Accumulator for weighted diff between target and 0-MV ref. 
;     edx -- Address at which to store -8 times pels.
;     ecx -- A reference pel.
;     ebx -- A target pel.
;     eax -- A target pel times -8;  and a weighted difference.
;
; Expected Pentium (tm) microprocessor performance for section:
;
;   Executed once per macroblock.
;
;   520 clocks for instruction execution
;     8 clocks for bank conflicts (64 dual mem ops with 1/8 chance of conflict)
;    80 clocks generously estimated for an average of 8 cache line fills for
;       the target macroblock and 8 cache line fills for the reference area.
;  ----
;   608 clocks total time for this section.
;

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   cl,[edx].CodedBlocks          ; Init CBP for macroblock.
   mov  ebp,TargetFrameBaseAddress
  mov   bl,[edx].FirstMEState         ; First State
   mov  eax,DoRadius15Search          ; Searching 15 full pels out, or just 7?
  neg   al                            ; doing blk lvl => al=0, not => al=-1
  or    cl,03FH                       ; Indicate all 6 blocks are coded.
   and  al,bl
  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   cmp  al,5
  jne   @f
  mov   bl,50                         ; Cause us to search +/- 15 if central
  ;                                   ; block and willing to go that far.
@@:
   mov  edi,TargToRef
  add   esi,ebp
   mov  CurrSWDState,ebx              ; Stash First State Number as current.
  add   edi,esi
   xor  ebp,ebp
  mov   TargetMBAddr,esi              ; Stash address of target macroblock.
   mov  MBlockActionStream,edx        ; Stash list ptr.
  mov   [edx].CodedBlocks,cl
   mov  ecx,INTER1MV                  ; Speculate INTER-coding, 1 motion vector.
  mov   [edx].BlockType,cl
   lea  edx,Block1

PrepMatchPointsNextBlock:

  mov   bl,PB [esi+6]                 ; 06A -- Target Pel 00.
  add   ebp,ebx                       ; 06B -- Accumulate target pels.
   mov  cl,PB [edi+6]                 ; 06C -- Reference Pel 00.
  mov   eax,MulByNeg8[ebx*4]          ; 06D -- Target Pel 00 * -8.
   mov  bl,PB [esi+4]                 ; 04A
  mov   [edx].N8T06,eax               ; 06E -- Store negated quadrupled Pel 00.
   add  ebp,ebx                       ; 04B
  mov   eax,PD [eax+ecx*8]            ; 06F -- Weighted difference for Pel 00.
   mov  cl,PB [edi+4]                 ; 04C
  add   ebp,eax                       ; 06G -- Accumulate weighted difference.
   mov  eax,MulByNeg8[ebx*4]          ; 04D
  mov   bl,PB [esi+2]                 ; 02A
   mov  [edx].N8T04,eax               ; 04E
  add   ebp,ebx                       ; 02B
   mov  eax,PD [eax+ecx*8]            ; 04F
  mov   cl,PB [edi+2]                 ; 02C
   add  ebp,eax                       ; 04G
  mov   eax,MulByNeg8[ebx*4]          ; 02D
   mov  bl,PB [esi]                   ; 00A
  mov   [edx].N8T02,eax               ; 02E
   add  ebp,ebx                       ; 00B
  mov   eax,PD [eax+ecx*8]            ; 02F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 00C
   add  edi,PITCH+1
  lea   ebp,[ebp+eax+000004000H]      ; 02G  (plus loop control)
   mov  eax,MulByNeg8[ebx*4]          ; 00D
  mov   bl,PB [esi+6]                 ; 17A
   mov  [edx].N8T00,eax               ; 00E
  add   ebp,ebx                       ; 17B
   mov  eax,PD [eax+ecx*8]            ; 00F
  mov   cl,PB [edi+6]                 ; 17C
   add  ebp,eax                       ; 00G
  mov   eax,MulByNeg8[ebx*4]          ; 17D
   mov  bl,PB [esi+4]                 ; 15A
  mov   [edx].N8T17,eax               ; 17E
   add  ebp,ebx                       ; 15B
  mov   eax,PD [eax+ecx*8]            ; 17F
   mov  cl,PB [edi+4]                 ; 15C
  add   ebp,eax                       ; 17G
   mov  eax,MulByNeg8[ebx*4]          ; 15D
  mov   bl,PB [esi+2]                 ; 13A
   mov  [edx].N8T15,eax               ; 15E
  add   ebp,ebx                       ; 13B
   mov  eax,PD [eax+ecx*8]            ; 15F
  mov   cl,PB [edi+2]                 ; 13C
   add  ebp,eax                       ; 15G
  mov   eax,MulByNeg8[ebx*4]          ; 13D
   mov  bl,PB [esi]                   ; 11A
  mov   [edx].N8T13,eax               ; 13E
   add  ebp,ebx                       ; 11B
  mov   eax,PD [eax+ecx*8]            ; 13F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 11C
   add  edi,PITCH-1
  add   ebp,eax                       ; 13G
   mov  eax,MulByNeg8[ebx*4]          ; 11D
  mov   bl,PB [esi+6]                 ; 26A
   mov  [edx].N8T11,eax               ; 11E
  add   ebp,ebx                       ; 26B
   mov  eax,PD [eax+ecx*8]            ; 11F
  mov   cl,PB [edi+6]                 ; 26C
   add  ebp,eax                       ; 11G
  mov   eax,MulByNeg8[ebx*4]          ; 26D
   mov  bl,PB [esi+4]                 ; 24A
  mov   [edx].N8T26,eax               ; 26E
   add  ebp,ebx                       ; 24B
  mov   eax,PD [eax+ecx*8]            ; 26F
   mov  cl,PB [edi+4]                 ; 24C
  add   ebp,eax                       ; 26G
   mov  eax,MulByNeg8[ebx*4]          ; 24D
  mov   bl,PB [esi+2]                 ; 22A
   mov  [edx].N8T24,eax               ; 24E
  add   ebp,ebx                       ; 22B
   mov  eax,PD [eax+ecx*8]            ; 24F
  mov   cl,PB [edi+2]                 ; 22C
   add  ebp,eax                       ; 24G
  mov   eax,MulByNeg8[ebx*4]          ; 22D
   mov  bl,PB [esi]                   ; 20A
  mov   [edx].N8T22,eax               ; 22E
   add  ebp,ebx                       ; 20B
  mov   eax,PD [eax+ecx*8]            ; 22F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 20C
   add  edi,PITCH+1
  add   ebp,eax                       ; 22G
   mov  eax,MulByNeg8[ebx*4]          ; 20D
  mov   bl,PB [esi+6]                 ; 37A
   mov  [edx].N8T20,eax               ; 20E
  add   ebp,ebx                       ; 37B
   mov  eax,PD [eax+ecx*8]            ; 20F
  mov   cl,PB [edi+6]                 ; 37C
   add  ebp,eax                       ; 20G
  mov   eax,MulByNeg8[ebx*4]          ; 37D
   mov  bl,PB [esi+4]                 ; 35A
  mov   [edx].N8T37,eax               ; 37E
   add  ebp,ebx                       ; 35B
  mov   eax,PD [eax+ecx*8]            ; 37F
   mov  cl,PB [edi+4]                 ; 35C
  add   ebp,eax                       ; 37G
   mov  eax,MulByNeg8[ebx*4]          ; 35D
  mov   bl,PB [esi+2]                 ; 33A
   mov  [edx].N8T35,eax               ; 35E
  add   ebp,ebx                       ; 33B
   mov  eax,PD [eax+ecx*8]            ; 35F
  mov   cl,PB [edi+2]                 ; 33C
   add  ebp,eax                       ; 35G
  mov   eax,MulByNeg8[ebx*4]          ; 33D
   mov  bl,PB [esi]                   ; 31A
  mov   [edx].N8T33,eax               ; 33E
   add  ebp,ebx                       ; 31B
  mov   eax,PD [eax+ecx*8]            ; 33F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 31C
   add  edi,PITCH-1
  add   ebp,eax                       ; 33G
   mov  eax,MulByNeg8[ebx*4]          ; 31D
  mov   bl,PB [esi+6]                 ; 46A
   mov  [edx].N8T31,eax               ; 31E
  add   ebp,ebx                       ; 46B
   mov  eax,PD [eax+ecx*8]            ; 31F
  mov   cl,PB [edi+6]                 ; 46C
   add  ebp,eax                       ; 31G
  mov   eax,MulByNeg8[ebx*4]          ; 46D
   mov  bl,PB [esi+4]                 ; 44A
  mov   [edx].N8T46,eax               ; 46E
   add  ebp,ebx                       ; 44B
  mov   eax,PD [eax+ecx*8]            ; 46F
   mov  cl,PB [edi+4]                 ; 44C
  add   ebp,eax                       ; 46G
   mov  eax,MulByNeg8[ebx*4]          ; 44D
  mov   bl,PB [esi+2]                 ; 42A
   mov  [edx].N8T44,eax               ; 44E
  add   ebp,ebx                       ; 42B
   mov  eax,PD [eax+ecx*8]            ; 44F
  mov   cl,PB [edi+2]                 ; 42C
   add  ebp,eax                       ; 44G
  mov   eax,MulByNeg8[ebx*4]          ; 42D
   mov  bl,PB [esi]                   ; 40A
  mov   [edx].N8T42,eax               ; 42E
   add  ebp,ebx                       ; 40B
  mov   eax,PD [eax+ecx*8]            ; 42F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 40C
   add  edi,PITCH+1
  add   ebp,eax                       ; 42G
   mov  eax,MulByNeg8[ebx*4]          ; 40D
  mov   bl,PB [esi+6]                 ; 57A
   mov  [edx].N8T40,eax               ; 40E
  add   ebp,ebx                       ; 57B
   mov  eax,PD [eax+ecx*8]            ; 40F
  mov   cl,PB [edi+6]                 ; 57C
   add  ebp,eax                       ; 40G
  mov   eax,MulByNeg8[ebx*4]          ; 57D
   mov  bl,PB [esi+4]                 ; 55A
  mov   [edx].N8T57,eax               ; 57E
   add  ebp,ebx                       ; 55B
  mov   eax,PD [eax+ecx*8]            ; 57F
   mov  cl,PB [edi+4]                 ; 55C
  add   ebp,eax                       ; 57G
   mov  eax,MulByNeg8[ebx*4]          ; 55D
  mov   bl,PB [esi+2]                 ; 53A
   mov  [edx].N8T55,eax               ; 55E
  add   ebp,ebx                       ; 53B
   mov  eax,PD [eax+ecx*8]            ; 55F
  mov   cl,PB [edi+2]                 ; 53C
   add  ebp,eax                       ; 55G
  mov   eax,MulByNeg8[ebx*4]          ; 53D
   mov  bl,PB [esi]                   ; 51A
  mov   [edx].N8T53,eax               ; 53E
   add  ebp,ebx                       ; 51B
  mov   eax,PD [eax+ecx*8]            ; 53F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 51C
   add  edi,PITCH-1
  add   ebp,eax                       ; 53G
   mov  eax,MulByNeg8[ebx*4]          ; 51D
  mov   bl,PB [esi+6]                 ; 66A
   mov  [edx].N8T51,eax               ; 51E
  add   ebp,ebx                       ; 66B
   mov  eax,PD [eax+ecx*8]            ; 51F
  mov   cl,PB [edi+6]                 ; 66C
   add  ebp,eax                       ; 51G
  mov   eax,MulByNeg8[ebx*4]          ; 66D
   mov  bl,PB [esi+4]                 ; 64A
  mov   [edx].N8T66,eax               ; 66E
   add  ebp,ebx                       ; 64B
  mov   eax,PD [eax+ecx*8]            ; 66F
   mov  cl,PB [edi+4]                 ; 64C
  add   ebp,eax                       ; 66G
   mov  eax,MulByNeg8[ebx*4]          ; 64D
  mov   bl,PB [esi+2]                 ; 62A
   mov  [edx].N8T64,eax               ; 64E
  add   ebp,ebx                       ; 62B
   mov  eax,PD [eax+ecx*8]            ; 64F
  mov   cl,PB [edi+2]                 ; 62C
   add  ebp,eax                       ; 64G
  mov   eax,MulByNeg8[ebx*4]          ; 62D
   mov  bl,PB [esi]                   ; 60A
  mov   [edx].N8T62,eax               ; 62E
   add  ebp,ebx                       ; 60B
  mov   eax,PD [eax+ecx*8]            ; 62F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 60C
   add  edi,PITCH+1
  add   ebp,eax                       ; 62G
   mov  eax,MulByNeg8[ebx*4]          ; 60D
  mov   bl,PB [esi+6]                 ; 77A
   mov  [edx].N8T60,eax               ; 60E
  add   ebp,ebx                       ; 77B
   mov  eax,PD [eax+ecx*8]            ; 60F
  mov   cl,PB [edi+6]                 ; 77C
   add  ebp,eax                       ; 60G
  mov   eax,MulByNeg8[ebx*4]          ; 77D
   mov  bl,PB [esi+4]                 ; 75A
  mov   [edx].N8T77,eax               ; 77E
   add  ebp,ebx                       ; 75B
  mov   eax,PD [eax+ecx*8]            ; 77F
   mov  cl,PB [edi+4]                 ; 75C
  add   ebp,eax                       ; 77G
   mov  eax,MulByNeg8[ebx*4]          ; 75D
  mov   bl,PB [esi+2]                 ; 73A
   mov  [edx].N8T75,eax               ; 75E
  add   ebp,ebx                       ; 73B
   mov  eax,PD [eax+ecx*8]            ; 75F
  mov   cl,PB [edi+2]                 ; 73C
   add  ebp,eax                       ; 75G
  mov   eax,MulByNeg8[ebx*4]          ; 73D
   mov  bl,PB [esi]                   ; 71A
  mov   [edx].N8T73,eax               ; 73E
   add  ebp,ebx                       ; 71B
  mov   eax,PD [eax+ecx*8]            ; 73F
   mov  cl,PB [edi]                   ; 71C
  add   esi,PITCH-1-PITCH*8+8
   add  edi,PITCH-1-PITCH*8+8
  add   ebp,eax                       ; 73G
   mov  eax,MulByNeg8[ebx*4]          ; 71D
  mov   ebx,ebp
   mov  [edx].N8T71,eax               ; 71E
  and   ebx,000001FFFH                ; Extract sum of target pels.
   add  edx,BlockLen                  ; Move to next output block
  mov   eax,PD [eax+ecx*8]            ; 71F
   mov  [edx-BlockLen].AccumTargetPels,ebx ; Store acc of target pels for block.
  add   eax,ebp                       ; 71G
   and  ebp,000006000H                ; Extract loop control
  shr   eax,16                        ; Extract SWD;  CF == 1 every second iter.
   mov  ebx,ecx
  mov   [edx-BlockLen].CentralInterSWD,eax ; Store SWD for 0-motion vector.
   jnc  PrepMatchPointsNextBlock

  add   esi,PITCH*8-16                ; Advance to block 3, or off end.
   add  edi,PITCH*8-16                ; Advance to block 3, or off end.
  xor   ebp,000002000H
   jne  PrepMatchPointsNextBlock      ; Jump if advancing to block 3.

  mov   ebx,CurrSWDState              ; Fetch First State Number for engine.
   mov  edi,Block1.CentralInterSWD
  test  bl,bl                         ; Test for INTRA-BY-DECREE.
   je   IntraByDecree

  add   eax,Block2.CentralInterSWD
   add  edi,Block3.CentralInterSWD
  add   eax,edi
   mov  edx,ZeroVectorThreshold
  cmp   eax,edx                       ; Compare 0-MV against ZeroVectorThresh
   jle  BelowZeroThresh               ; Jump if 0-MV is good enough.

  mov   cl,PB SWDState[ebx*8+3]       ; cl == Index of inc to apply to central
  ;                                   ; point to get to ref1.
   mov  bl,PB SWDState[ebx*8+5]       ; bl == Same as cl, but for ref2.
  mov   edx,TargToRef
   mov  MB0MVInterSWD,eax             ; Stash SWD for zero motion vector.
  mov   edi,PD OffsetToRef[ebx]       ; Get inc to apply to ctr to get to ref2.
   mov  ebp,PD OffsetToRef[ecx]       ; Get inc to apply to ctr to get to ref1.
  lea   esi,[esi+edx-PITCH*16]        ; Calculate address of 0-MV ref block.
   ;
  mov   MBAddrCentralPoint,esi        ; Set central point to 0-MV.
   mov  MBCentralInterSWD,eax
  mov   eax,Block1.CentralInterSWD    ; Stash Zero MV SWD, in case we decide
   mov  edx,Block2.CentralInterSWD    ; the best non-zero MV isn't enough
  mov   Block1.ZeroMVInterSWD,eax     ; better than the zero MV.
   mov  Block2.ZeroMVInterSWD,edx
  mov   eax,Block3.CentralInterSWD
   mov  edx,Block4.CentralInterSWD
  mov   Block3.ZeroMVInterSWD,eax
   mov  Block4.ZeroMVInterSWD,edx

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     5)  The SWD for two different reference macroblocks is calculated; ref1
;         into the high order 16 bits of ebp, and ref2 into the low 16 bits.
;         This is performed for each iteration of the state engine.  A normal,
;         internal macroblock will perform 6 iterations, searching +/- 4
;         horizontally, then +/- 4 vertically, then +/- 2 horizontally, then
;         +/- 2 vertically, then +/- 1 horizontally, then +/- 1 vertically.
;
; Register usage for this section:
;
;   Input:
;
;     esi -- Addr of 0-motion macroblock in ref frame.
;     ebp -- Increment to apply to get to first ref1 macroblock.
;     edi -- Increment to apply to get to first ref2 macroblock.
;     ebx, ecx -- High order 24 bits are zero.
;     
;   Output:
;
;     ebp -- SWD for the best-fit reference macroblock.
;     ebx -- Index of increment to apply to get to best-fit reference MB.
;     MBAddrCentralPoint -- the best-fit of the previous iteration;  it is the
;                         value to which OffsetToRef[ebx] must be added.
;
;
; Expected performance for SWDLoop code:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

MBFullPelMotionSearchLoop:

  lea   edi,[esi+edi+PITCH*8+8]
   lea  esi,[esi+ebp+PITCH*8+8]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   esi,MBCentralInterSWD     ; Get SWD for central point of these 3 refs
   xor  eax,eax
  add   ebp,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ebp,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ebp,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD

  cmp   ebp,edx                   ; Carry flag == 1 iff ref1 SWD < ref2 SWD.
   mov  edi,CurrSWDState          ; Restore current state number.
  adc   eax,eax                   ; eax == 1 iff ref1 SWD < ref2 SWD.
   cmp  ebp,esi                   ; Carry flag == 1 iff ref1 SWD < central SWD.
  adc   eax,eax                   ;
   cmp  edx,esi                   ; Carry flag == 1 iff ref2 SWD < central SWD.
  adc   eax,eax                   ; 0 --> Pick central point.
  ;                               ; 1 --> Pick ref2.
  ;                               ; 2 --> Not possible.
  ;                               ; 3 --> Pick ref2.
  ;                               ; 4 --> Pick central point.
  ;                               ; 5 --> Not possible.
  ;                               ; 6 --> Pick ref1.
  ;                               ; 7 --> Pick ref1.
   mov  MBRef2InterSWD,edx
  mov   MBRef1InterSWD,ebp
   xor  edx,edx
  mov   dl,PB PickPoint[eax]        ; dl == 0: central pt;  2: ref1;  4: ref2
   mov  esi,MBAddrCentralPoint      ; Reload address of central ref block.
  ;
   ;
  mov   ebp,Block1.CentralInterSWD[edx*2] ; Get SWD for each block, picked pt.
   mov  al,PB SWDState[edx+edi*8+1] ; al == Index of inc to apply to old central
   ;                                ;       point to get new central point.
  mov   Block1.CentralInterSWD,ebp  ; Stash SWD for new central point.
   mov  ebp,Block2.CentralInterSWD[edx*2]
  mov   Block2.CentralInterSWD,ebp
   mov  ebp,Block3.CentralInterSWD[edx*2]
  mov   Block3.CentralInterSWD,ebp
   mov  ebp,Block4.CentralInterSWD[edx*2]
  mov   Block4.CentralInterSWD,ebp
   mov  ebp,MBCentralInterSWD[edx*2]; Get the SWD for the point we picked.
  mov   dl,PB SWDState[edx+edi*8]   ; dl == New state number.
   mov  MBCentralInterSWD,ebp       ; Stash SWD for new central point.
  mov   edi,PD OffsetToRef[eax]     ; Get inc to apply to get to new central pt.
   mov  CurrSWDState,edx            ; Stash current state number.
  mov   bl,PB SWDState[edx*8+3]     ; bl == Index of inc to apply to central
  ;                                 ;       point to get to next ref1.
   mov  cl,PB SWDState[edx*8+5]     ; cl == Same as bl, but for ref2.
  add   esi,edi                     ; Move to new central point.
   test dl,dl
  mov   ebp,PD OffsetToRef[ebx]     ; Get inc to apply to ctr to get to ref1.
   mov  edi,PD OffsetToRef[ecx]     ; Get inc to apply to ctr to get to ref2.
  mov   MBAddrCentralPoint,esi      ; Stash address of new central ref block.
   jne  MBFullPelMotionSearchLoop   ; Jump if not done searching.

;Done searching for integer motion vector for full macroblock

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF
  mov   ecx,TargToRef            ; To Linearize MV for winning ref blk.
   mov  eax,esi                  ; Copy of ref macroblock addr.
  sub   eax,ecx                  ; To Linearize MV for winning ref blk.
   mov  ecx,TargetMBAddr
  sub   eax,ecx
   mov  edx,MBlockActionStream   ; Fetch list ptr.
  mov   ebx,eax
   mov  ebp,DoHalfPelEstimation  ; Are we doing half pel motion estimation?
  shl   eax,25                   ; Extract horz motion component.
   mov  [edx].BlkY1.PastRef,esi  ; Save address of reference MB selected.
  sar   ebx,8                    ; Hi 24 bits of linearized MV lookup vert MV.
   mov  ecx,MBCentralInterSWD
  sar   eax,24                   ; Finish extract horz motion component.
   test ebp,ebp
  mov   bl,PB UnlinearizedVertMV[ebx] ; Look up proper vert motion vector.
   mov  [edx].BlkY1.PHMV,al      ; Save winning horz motion vector.
  mov   [edx].BlkY1.PVMV,bl      ; Save winning vert motion vector.

IFDEF H261
ELSE
   je   SkipHalfPelSearch_1MV

;Search for half pel motion vector for full macroblock.

  mov   Block1.AddrCentralPoint,esi
   lea  ebp,[esi+8]
  mov   Block2.AddrCentralPoint,ebp
   add  ebp,PITCH*8-8
  mov   Block3.AddrCentralPoint,ebp
   xor  ecx,ecx
  mov   cl,[edx].FirstMEState
   add  ebp,8
  mov   edi,esi
   mov  Block4.AddrCentralPoint,ebp
  mov   ebp,InitHalfPelSearchHorz[ecx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  mov   esi,MBlockActionStream
   xor  eax,eax                   ; Keep pairing happy
  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  mov   bl,[esi].FirstMEState
   mov  edi,Block1.AddrCentralPoint
  cmp   ecx,edx
   jl   MBHorz_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the right is best.
   mov  ecx,Block1.Ref2InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref2InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref2InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref2InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   inc  al
  mov   [esi].BlkY1.PHMV,al
   jmp  MBHorz_Done

MBHorz_CenterBest:

  mov   ecx,Block1.CentralInterSWD
   xor  ebp,ebp
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.CentralInterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   jmp  MBHorz_Done

MBHorz_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the left is best.
   mov  edx,[esi].BlkY1.PastRef
  dec   al
   mov  ecx,Block1.Ref1InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref1InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref1InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref1InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   dec  edx
  mov   [esi].BlkY1.PHMV,al
   mov  [esi].BlkY1.PastRef,edx

MBHorz_Done:

  mov   HalfPelHorzSavings,ebp
   mov  ebp,InitHalfPelSearchVert[ebx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  cmp   ecx,edx
   jl   MBVert_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel below is best.
  mov   Block1.CentralInterSWD,edx
   inc  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  [esi].BlkY1.PVMV,al
  mov   Block4.CentralInterSWD,edx
   jmp  MBVert_Done

MBVert_CenterBest:

  mov   ecx,Block1.CentralInterSWD_BLS
   xor  ebp,ebp
  mov   Block1.CentralInterSWD,ecx
   mov  ecx,Block2.CentralInterSWD_BLS
  mov   Block2.CentralInterSWD,ecx
   mov  ecx,Block3.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,ecx
   mov  ecx,Block4.CentralInterSWD_BLS
  mov   Block4.CentralInterSWD,ecx
   jmp  MBVert_Done

MBVert_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel above is best.
  mov   Block1.CentralInterSWD,edx
   dec  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,[esi].BlkY1.PastRef
  mov   Block4.CentralInterSWD,edx
   sub  ecx,PITCH
  mov   [esi].BlkY1.PVMV,al
   mov  [esi].BlkY1.PastRef,ecx

MBVert_Done:

  mov   ecx,HalfPelHorzSavings
   mov  edx,esi
  add   ebp,ecx                    ; Savings for horz and vert half pel motion.
   mov  ecx,MBCentralInterSWD      ; Reload SWD for new central point.
  sub   ecx,ebp                    ; Approx SWD for prescribed half pel motion.
   mov  esi,[edx].BlkY1.PastRef    ; Reload address of reference MB selected.
  mov   MBCentralInterSWD,ecx

SkipHalfPelSearch_1MV:

ENDIF ; H263

  mov   ebp,[edx].BlkY1.MVs    ; Load Motion Vectors
   add  esi,8
  mov   [edx].BlkY2.PastRef,esi
   mov  [edx].BlkY2.MVs,ebp
  lea   edi,[esi+PITCH*8]
   add  esi,PITCH*8-8
  mov   [edx].BlkY3.PastRef,esi
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,edi
   mov  [edx].BlkY4.MVs,ebp
IFDEF H261
ELSE ; H263
  mov   MBMotionVectors,ebp        ; Stash macroblock level motion vectors.
   mov  ebp,640 ; ??? BlockMVDifferential
  cmp   ecx,ebp
   jl   NoBlockMotionVectors

  mov   ecx,DoBlockLevelVectors
  test  ecx,ecx                    ; Are we doing block level motion vectors?
   je   NoBlockMotionVectors

;  Activity Details for this section of code  (refer to flow diagram above):
;
;  The following search is done similarly to the searches done above, except
;  these are block searches, instead of macroblock searches.
;
; Expected performance:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

;
;    Set up for the "BlkFullPelSWDLoop_4blks" loop to follow.
;    -  Store the SWD values for blocks 4, 3, 2, 1.
;    -  Compute and store the address of the central reference
;       point for blocks 1, 2, 3, 4.
;	 -  Compute and store the first address for ref 1 (minus 4 
;       pels horizontally) and ref 2 (plus 4 pels horizontally)
;       for blocks 4, 3, 2, 1 (in that order).
;    -  Initialize MotionOffsetsCursor
;    -  On exit:
;       esi = ref 1 address for block 1
;       edi = ref 2 address for block 1
;
  mov   esi,Block4.CentralInterSWD
   mov  edi,Block3.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,esi
   mov  Block3.CentralInterSWD_BLS,edi
  mov   esi,Block2.CentralInterSWD
   mov  edi,Block1.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,esi
   mov  eax,MBAddrCentralPoint   ; Reload addr of central, integer pel ref MB.
  mov   Block1.CentralInterSWD_BLS,edi
   mov  Block1.AddrCentralPoint,eax
  lea   edi,[eax+PITCH*8+8+1]
   lea  esi,[eax+PITCH*8+8-1]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   add  eax,8
  mov   Block2.AddrCentralPoint,eax
   add  eax,PITCH*8-8
  mov   Block3.AddrCentralPoint,eax
   add  eax,8
  mov   Block4.AddrCentralPoint,eax
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   mov  eax,OFFSET MotionOffsets
  mov   MotionOffsetsCursor,eax
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;
;  This loop will execute 6 times:
;    +- 4 pels horizontally
;    +- 4 pels vertically
;    +- 2 pels horizontally
;    +- 2 pels vertically
;    +- 1 pel horizontally
;    +- 1 pel vertically
;  It terminates when ref1 = ref2.  This simple termination
;  condition is what forces unrestricted motion vectors (UMV)
;  to be ON when advanced prediction (4MV) is ON.  Otherwise
;  we would need a state engine as above to distinguish edge
;  pels.
;
BlkFullPelSWDLoop_4blks:

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   eax,MotionOffsetsCursor

BlkFullPelSWDLoop_1blk:

  xor   esi,esi
   cmp  ebp,edx                         ; CF == 1 iff ref1 SWD < ref2 SWD.
  mov   edi,BlockNM1.CentralInterSWD_BLS; Get SWD for central pt of these 3 refs
   adc  esi,esi                         ; esi == 1 iff ref1 SWD < ref2 SWD.
  cmp   ebp,edi                         ; CF == 1 iff ref1 SWD < central SWD.
   mov  ebp,BlockNM2.Ref1InterSWD       ; Fetch next block's Ref1 SWD.
  adc   esi,esi
   cmp  edx,edi                         ; CF == 1 iff ref2 SWD < central SWD.
  adc   esi,esi                         ; 0 --> Pick central point.
  ;                                     ; 1 --> Pick ref2.
  ;                                     ; 2 --> Not possible.
  ;                                     ; 3 --> Pick ref2.
  ;                                     ; 4 --> Pick central point.
  ;                                     ; 5 --> Not possible.
  ;                                     ; 6 --> Pick ref1.
  ;                                     ; 7 --> Pick ref1.
   mov  edx,BlockNM2.Ref2InterSWD       ; Fetch next block's Ref2 SWD.
  sub   esp,BlockLen                    ; Move ahead to next block.
   mov  edi,[eax]                       ; Next ref2 motion vector offset.
  mov   cl,PickPoint_BLS[esi]           ; cl == 6: central pt; 2: ref1; 4: ref2
   mov  ebx,esp                         ; For testing completion.
  ;
   ;
  mov   esi,BlockN.AddrCentralPoint[ecx*2-12] ; Get the addr for pt we picked.
   mov  ecx,BlockN.CentralInterSWD[ecx*2]    ; Get the SWD for point we picked.
  mov   BlockN.AddrCentralPoint,esi          ; Stash addr for new central point.
   sub  esi,edi                              ; Compute next ref1 addr.
  mov   BlockN.Ref1Addr,esi                  ; Stash next ref1 addr.
   mov  BlockN.CentralInterSWD_BLS,ecx       ; Stash the SWD for central point.
  lea   edi,[esi+edi*2]                      ; Compute next ref2 addr.
   xor  ecx,ecx
  mov   BlockN.Ref2Addr,edi                  ; Stash next ref2 addr.
   and  ebx,00000001FH                       ; Done when esp at 32-byte bound.
  jne   BlkFullPelSWDLoop_1blk

  add   esp,BlockLen*4
   add  eax,4                       ; Advance MotionOffsets pointer.
  mov   MotionOffsetsCursor,eax
   cmp  esi,edi
  jne   BlkFullPelSWDLoop_4blks

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF

;
;  The following code has been modified to correctly decode the motion vectors
;  The previous code was simply subtracting the target frame base address
;  from the chosen (central) reference block address.
;  What is now done is the begining reference macroblock address computed
;  in ebp, then subtracted from the chosen (central) reference block address.
;  Then, for blocks 2, 3, and 4, the distance from block 1 to that block
;  is subtracted.  Care was taken to preserve the original pairing.
; 
  mov   esi,Block1.AddrCentralPoint ; B1a  Reload address of central ref block.
   mov  ebp,TargetMBAddr			; ****  CHANGE  ****  addr. of target MB

  mov   edi,Block2.AddrCentralPoint ; B2a
   add  ebp,TargToRef				; ****  CHANGE	****  add Reference - Target

; mov   ebp,PreviousFrameBaseAddress  ****  CHANGE  ****  DELETED

  mov   Block1.Ref1Addr,esi         ; B1b  Stash addr central ref block.
   sub  esi,ebp                     ; B1c  Addr of ref blk, but in target frame.

  mov   Block2.Ref1Addr,edi         ; B2b
   sub  edi,ebp                     ; B2c

  sub   edi,8                       ; ****  CHANGE  ****  Correct for block 2
   mov  eax,esi                     ; B1e Copy linearized MV.

  sar   esi,8                       ; B1f High 24 bits of lin MV lookup vert MV.
   mov  ebx,edi                     ; B2e

  sar   edi,8                       ; B2f
   add  eax,eax                     ; B1g Sign extend HMV;  *2 (# of half pels).

  mov   Block1.BlkHMV,al            ; B1h Save winning horz motion vector.
   add  ebx,ebx                     ; B2g

  mov   Block2.BlkHMV,bl            ; B2h
   mov  al,UnlinearizedVertMV[esi]  ; B1i Look up proper vert motion vector.

  mov   Block1.BlkVMV,al            ; B1j Save winning vert motion vector.
   mov  al,UnlinearizedVertMV[edi]  ; B2i

  mov   esi,Block3.AddrCentralPoint ; B3a
   mov  edi,Block4.AddrCentralPoint ; B4a

  mov   Block3.Ref1Addr,esi         ; B3b
   mov  Block4.Ref1Addr,edi         ; B4b

  mov   Block2.BlkVMV,al            ; B2j
   sub  esi,ebp                     ; B3c

  sub   esi,8*PITCH                 ; ****  CHANGE  ****  Correct for block 3
   sub  edi,ebp                     ; B4c

  sub   edi,8*PITCH+8               ; ****  CHANGE  ****  Correct for block 4
   mov  eax,esi                     ; B3e

  sar   esi,8                       ; B3f
   mov  ebx,edi                     ; B4e

  sar   edi,8                       ; B4f
   add  eax,eax                     ; B3g

  mov   Block3.BlkHMV,al            ; B3h
   add  ebx,ebx                     ; B4g

  mov   Block4.BlkHMV,bl            ; B4h
   mov  al,UnlinearizedVertMV[esi]  ; B3i

  mov   Block3.BlkVMV,al            ; B3j
   mov  al,UnlinearizedVertMV[edi]  ; B4i

  mov   ebp,Block1.CentralInterSWD_BLS
   mov  ebx,Block2.CentralInterSWD_BLS

  add   ebp,Block3.CentralInterSWD_BLS
   add  ebx,Block4.CentralInterSWD_BLS

  add   ebx,ebp
   mov  Block4.BlkVMV,al            ; B4j

  mov   ecx,DoHalfPelEstimation
   mov  MBCentralInterSWD_BLS,ebx

  test  ecx,ecx
   je   NoHalfPelBlockLevelMVs

HalfPelBlockLevelMotionSearch:

  mov   edi,Block1.AddrCentralPoint
   xor  ebp,ebp

;    ebp -- Initialized to 0, implying can search both left and right.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkHorz:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   BlockNM1.HalfPelSavings,ebp
   jl   BlkHorz_Ref1LTRef2

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,edx
   jle  BlkHorz_CenterBest

  inc   al
   mov  BlockN.HalfPelSavings,ebx
  mov   BlockN.BlkHMV,al
   jmp  BlkHorz_Done

BlkHorz_Ref1LTRef2:

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,ecx
   jle  BlkHorz_CenterBest

  mov   ecx,BlockN.Ref1Addr
   dec  al
  mov   BlockN.HalfPelSavings,ebx
   dec  ecx
  mov   BlockN.BlkHMV,al
   mov  BlockN.Ref1Addr,ecx

BlkHorz_CenterBest:
BlkHorz_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  jne   NextBlkHorz

  mov   edi,BlockN.AddrCentralPoint
   add  esp,BlockLen*4

;    ebp -- Initialized to 0, implying search both up and down is okay.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkVert:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   edi,BlockNM1.HalfPelSavings 
   jl   BlkVert_Ref1LTRef2

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   edx,ebx
   jge  BlkVert_CenterBest

  inc   al
   sub  edi,edx
  mov   BlockN.BlkVMV,al
   jmp  BlkVert_Done

BlkVert_Ref1LTRef2:

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   ecx,ebx
   jge  BlkVert_CenterBest

  sub   edi,ecx
   mov  ecx,BlockN.Ref1Addr
  dec   al
   sub  ecx,PITCH
  mov   BlockN.BlkVMV,al
   mov  BlockN.Ref1Addr,ecx

BlkVert_CenterBest:
BlkVert_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   sub  ebx,edi
  mov   BlockN.CentralInterSWD_BLS,ebx
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  lea   ebp,[ebp+edi]
   jne  NextBlkVert

  mov   ebx,MBCentralInterSWD_BLS+BlockLen*4
   add  esp,BlockLen*4
  sub   ebx,ebp
   xor  eax,eax  ; ??? Keep pairing happy

NoHalfPelBlockLevelMVs:

  mov   eax,MBCentralInterSWD
   mov  ecx,BlockMVDifferential
  sub   eax,ebx
   mov  edi,MB0MVInterSWD
  cmp   eax,ecx
   jle  BlockMVNotBigEnoughGain

  sub   edi,ebx
   mov  ecx,NonZeroMVDifferential
  cmp   edi,ecx
   jle  NonZeroMVNotBigEnoughGain

; Block motion vectors are best.

  mov   MBCentralInterSWD,ebx           ; Set MBlock's SWD to sum of 4 blocks.
   mov  edx,MBlockActionStream
  mov   eax,Block1.CentralInterSWD_BLS  ; Set each block's SWD.
   mov  ebx,Block2.CentralInterSWD_BLS
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,ebx
  mov   eax,Block3.CentralInterSWD_BLS
   mov  ebx,Block4.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,ebx
  mov   eax,Block1.BlkMVs               ; Set each block's motion vector.
   mov  ebx,Block2.BlkMVs
  mov   [edx].BlkY1.MVs,eax
   mov  [edx].BlkY2.MVs,ebx
  mov   eax,Block3.BlkMVs
   mov  ebx,Block4.BlkMVs
  mov   [edx].BlkY3.MVs,eax
   mov  [edx].BlkY4.MVs,ebx
  mov   eax,Block1.Ref1Addr             ; Set each block's reference blk addr.
   mov  ebx,Block2.Ref1Addr
  mov   [edx].BlkY1.PastRef,eax
   mov  [edx].BlkY2.PastRef,ebx
  mov   eax,Block3.Ref1Addr
   mov  ebx,Block4.Ref1Addr
  mov   [edx].BlkY3.PastRef,eax
   mov  eax,INTER4MV                    ; Set type for MB to INTER-coded, 4 MVs.
  mov   [edx].BlkY4.PastRef,ebx
   mov  [edx].BlockType,al
  jmp   MotionVectorSettled

NoBlockMotionVectors:

ENDIF ; H263

  mov   edi,MB0MVInterSWD

BlockMVNotBigEnoughGain:                ; Try MB-level motion vector.

  mov   eax,MBCentralInterSWD
   mov  ecx,NonZeroMVDifferential
  sub   edi,eax
   mov  edx,MBlockActionStream
  cmp   edi,ecx
   jg   MotionVectorSettled

NonZeroMVNotBigEnoughGain:              ; Settle on zero MV.

  mov   eax,Block1.ZeroMVInterSWD       ; Restore Zero MV SWD.
   mov  edx,Block2.ZeroMVInterSWD
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,edx
  mov   eax,Block3.ZeroMVInterSWD
   mov  edx,Block4.ZeroMVInterSWD
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,edx
  mov   eax,MB0MVInterSWD               ; Restore SWD for zero motion vector.

BelowZeroThresh:

  mov   edx,MBlockActionStream
   mov  ebx,TargetMBAddr              ; Get address of this target macroblock.
  mov   MBCentralInterSWD,eax         ; Save SWD.
   xor  ebp,ebp
  add   ebx,TargToRef
   mov  [edx].BlkY1.MVs,ebp           ; Set horz and vert MVs to 0 in all blks.
  mov   [edx].BlkY1.PastRef,ebx       ; Save address of ref block, all blks.
   add  ebx,8
  mov   [edx].BlkY2.PastRef,ebx
   mov  [edx].BlkY2.MVs,ebp
  lea   ecx,[ebx+PITCH*8]
   add  ebx,PITCH*8-8
  mov   [edx].BlkY3.PastRef,ebx
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,ecx
   mov  [edx].BlkY4.MVs,ebp

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     6)  We've settled on the motion vector that will be used if we do indeed
;         code the macroblock with inter-coding.  We need to determine if some
;         or all of the blocks can be forced as empty (copy).
;         blocks.  If all the blocks can be forced empty, we force the whole
;         macroblock to be empty.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per macroblock.
;
;    23 clocks.
;

MotionVectorSettled:

IFDEF H261
   mov  edi,MBCentralInterSWD
  mov   eax,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov  edi,TargetMBAddr
  test  eax,eax
   je   SkipSpatialFiltering

  mov   ebx,MBCentralInterSWD
   mov  esi,SpatialFiltThreshold
  cmp   ebx,esi
   jle  SkipSpatialFiltering

  add   edi,TargToSLF            ; Compute addr at which to put SLF prediction.
   xor  ebx,ebx
  mov   esi,[edx].BlkY1.PastRef
   xor  edx,edx
  mov   ebp,16
   xor  ecx,ecx

SpatialFilterHorzLoop:

  mov   dl,[edi]        ; Pre-load cache line for output.
   mov  bl,[esi+6]      ; p6
  mov   al,[esi+7]      ; p7
   inc  bl              ; p6+1
  mov   cl,[esi+5]      ; p5
   mov  [edi+7],al      ; p7' = p7
  add   al,bl           ; p7 + p6 + 1
   add  bl,cl           ; p6 + p5 + 1
  mov   dl,[esi+4]      ; p4
   add  eax,ebx         ; p7 + 2p6 + p5 + 2
  shr   eax,2           ; p6' = (p7 + 2p6 + p5 + 2) / 4
   inc  dl              ; p4 + 1
  add   cl,dl           ; p5 + p4 + 1
   mov  [edi+6],al      ; p6'
  mov   al,[esi+3]      ; p3
   add  ebx,ecx         ; p6 + 2p5 + p4 + 2
  shr   ebx,2           ; p5' = (p6 + 2p5 + p4 + 2) / 4
   add  dl,al           ; p4 + p3 + 1
  mov   [edi+5],bl      ; p5'
   mov  bl,[esi+2]      ; p2
  add   ecx,edx         ; p5 + 2p4 + p3 + 2
   inc  bl              ; p2 + 1
  shr   ecx,2           ; p4' = (p5 + 2p4 + p3 + 2) / 4
   add  al,bl           ; p3 + p2 + 1
  mov   [edi+4],cl      ; p4'
   add  edx,eax         ; p4 + 2p3 + p2 + 2
  shr   edx,2           ; p3' = (p4 + 2p3 + p2 + 2) / 4
   mov  cl,[esi+1]      ; p1
  add   bl,cl           ; p2 + p1 + 1
   mov  [edi+3],dl      ; p3'
  add   eax,ebx         ; p3 + 2p2 + p1 + 2
   mov  dl,[esi]        ; p0
  shr   eax,2           ; p2' = (p3 + 2p2 + p1 + 2) / 4
   inc  ebx             ; p2 + p1 + 2
  mov   [edi+2],al      ; p2'
   add  ebx,ecx         ; p2 + 2p1 + 2
  mov   [edi],dl        ; p0' = p0
   add  ebx,edx         ; p2 + 2p1 + p0 + 2
  shr   ebx,2           ; p1' = (p2 + 2p1 + p0 + 2) / 4
   mov  al,[esi+7+8]
  mov   [edi+1],bl      ; p1'
   mov  bl,[esi+6+8]
  inc   bl
   mov  cl,[esi+5+8]
  mov   [edi+7+8],al
   add  al,bl
  add   bl,cl
   mov  dl,[esi+4+8]
  add   eax,ebx
   ;
  shr   eax,2
   inc  dl
  add   cl,dl
   mov  [edi+6+8],al
  mov   al,[esi+3+8]
   add  ebx,ecx
  shr   ebx,2
   add  dl,al
  mov   [edi+5+8],bl
   mov  bl,[esi+2+8]
  add   ecx,edx
   inc  bl
  shr   ecx,2
   add  al,bl
  mov   [edi+4+8],cl
   add  edx,eax
  shr   edx,2
   mov  cl,[esi+1+8]
  add   bl,cl
   mov  [edi+3+8],dl
  add   eax,ebx
   mov  dl,[esi+8]
  shr   eax,2
   inc  ebx
  mov   [edi+2+8],al
   add  ebx,ecx
  mov   [edi+8],dl
   add  ebx,edx
  shr   ebx,2
   add  esi,PITCH
  mov   [edi+1+8],bl
   add  edi,PITCH
  dec   ebp             ; Done?
   jne  SpatialFilterHorzLoop

  mov   VertFilterDoneAddr,edi
   sub  edi,PITCH*16

SpatialFilterVertLoop:

  mov   eax,[edi]                ;  p0
   ;                             ;  Bank conflict for sure.
  ;
   mov  ebx,[edi+PITCH]          ;  p1
  add   eax,ebx                  ;  p0+p1
   mov  ecx,[edi+PITCH*2]        ;  p2
  add   ebx,ecx                  ;  p1+p2
   mov  edx,[edi+PITCH*3]        ;  p3
  shr   eax,1                    ; (p0+p1)/2                       dirty
   mov  esi,[edi+PITCH*4]        ;  p4
  add   ecx,edx                  ;  p2+p3
   mov  ebp,[edi+PITCH*5]        ;  p5
  shr   ebx,1                    ; (p1+p2)/2                       dirty
   add  edx,esi                  ;  p3+p4
  and   eax,07F7F7F7FH           ; (p0+p1)/2                       clean
   and  ebx,07F7F7F7FH           ; (p1+p2)/2                       clean
  and   ecx,0FEFEFEFEH           ;  p2+p3                          pre-cleaned
   and  edx,0FEFEFEFEH           ;  p3+p4                          pre-cleaned
  shr   ecx,1                    ; (p2+p3)/2                       clean
   add  esi,ebp                  ;  p4+p5
  shr   edx,1                    ; (p3+p4)/2                       clean
   lea  eax,[eax+ebx+001010101H] ; (p0+p1)/2+(p1+p2)/2+1
  shr   esi,1                    ; (p4+p5)/2                       dirty
   ;
  and   esi,07F7F7F7FH           ; (p4+p5)/2                       clean
   lea  ebx,[ebx+ecx+001010101H] ; (p1+p2)/2+(p2+p3)/2+1
  shr   eax,1                    ; p1' = ((p0+p1)/2+(p1+p2)/2+1)/2 dirty
   lea  ecx,[ecx+edx+001010101H] ; (p2+p3)/2+(p3+p4)/2+1
  shr   ebx,1                    ; p2' = ((p1+p2)/2+(p2+p3)/2+1)/2 dirty
   lea  edx,[edx+esi+001010101H] ; (p3+p4)/2+(p4+p5)/2+1
  and   eax,07F7F7F7FH           ; p1'                             clean
   and  ebx,07F7F7F7FH           ; p2'                             clean
  shr   ecx,1                    ; p3' = ((p2+p3)/2+(p3+p4)/2+1)/2 dirty
   mov  [edi+PITCH],eax          ; p1'
  shr   edx,1                    ; p4' = ((p3+p4)/2+(p4+p5)/2+1)/2 dirty
   mov  eax,[edi+PITCH*6]        ;  p6
  and   ecx,07F7F7F7FH           ; p3'                             clean
   and  edx,07F7F7F7FH           ; p4'                             clean
  mov   [edi+PITCH*2],ebx        ; p2'
   add  ebp,eax                  ;  p5+p6
  shr   ebp,1                    ; (p5+p6)/2                       dirty
   mov  ebx,[edi+PITCH*7]        ;  p7
  add   eax,ebx                  ;  p6+p7
   and  ebp,07F7F7F7FH           ; (p5+p6)/2                       clean
  mov   [edi+PITCH*3],ecx        ; p3'
   and  eax,0FEFEFEFEH           ; (p6+p7)/2                       pre-cleaned
  shr   eax,1                    ; (p6+p7)/2                       clean
   lea  esi,[esi+ebp+001010101H] ; (p4+p5)/2+(p5+p6)/2+1
  shr   esi,1                    ; p5' = ((p4+p5)/2+(p5+p6)/2+1)/2 dirty
   mov  [edi+PITCH*4],edx        ; p4'
  lea   ebp,[ebp+eax+001010101H] ; (p5+p6)/2+(p6+p7)/2+1
   and  esi,07F7F7F7FH           ; p5'                             clean
  shr   ebp,1                    ; p6' = ((p5+p6)/2+(p6+p7)/2+1)/2 dirty
   mov  [edi+PITCH*5],esi        ; p5'
  and   ebp,07F7F7F7FH           ; p6'                             clean
   add  edi,4
  test  edi,00000000FH
  mov   [edi+PITCH*6-4],ebp      ; p6'
   jne  SpatialFilterVertLoop

  add   edi,PITCH*8-16
   mov  eax,VertFilterDoneAddr
  cmp   eax,edi
   jne  SpatialFilterVertLoop
  

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     9)  The SAD for the spatially filtered reference macroblock is calculated
;         with half the pel differences accumulating into the low order half
;         of ebp, and the other half into the high order half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;
;   Predominate usage for body of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;     esi, eax -- -8 times pel values from target macroblock.
;     ebp[ 0:15] -- SAD Accumulator for half of the match points.
;     ebp[16:31] -- SAD Accumulator for other half of the match points.
;     edx[ 0: 7] -- Weighted difference for one pel.
;     edx[ 8:15] -- Zero.
;     edx[16:23] -- Weighted difference for another pel.
;     edx[24:31] -- Zero.
;     bl, cl -- Pel values from the spatially filtered reference macroblock.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
;   146 clocks instruction execution (typically).
;     6 clocks for bank conflicts (1/8 chance with 48 dual mem ops).
;     0 clocks for new cache line fills.
;  ----
;   152 clocks total time for this section.
;

SpatialFilterDone:

  sub   edi,PITCH*8-8             ; Get to block 4.
   xor  ebp,ebp
  xor   ebx,ebx
   xor  ecx,ecx

SLFSWDLoop:

  mov   eax,BlockNM1.N8T00        ; Get -8 times target Pel00.
   mov  bl,[edi]                  ; Get Pel00 in spatially filtered reference.
  mov   esi,BlockNM1.N8T04
   mov  cl,[edi+4]
  mov   edx,[eax+ebx*8]           ; Get abs diff for spatial filtered ref pel00.
   mov  eax,BlockNM1.N8T02
  mov   dl,[esi+ecx*8+2]          ; Get abs diff for spatial filtered ref pel04.
   mov  bl,[edi+2]
  mov   esi,BlockNM1.N8T06
   mov  cl,[edi+6]
  mov   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T11
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*1+1]
   mov  cl,[edi+PITCH*1+5]
  mov   esi,BlockNM1.N8T15
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T13
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*1+3]
  mov   cl,[edi+PITCH*1+7]
   mov  esi,BlockNM1.N8T17
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T20
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*2+0]
   mov  cl,[edi+PITCH*2+4]
  mov   esi,BlockNM1.N8T24
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T22
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*2+2]
  mov   cl,[edi+PITCH*2+6]
   mov  esi,BlockNM1.N8T26
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T31
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*3+1]
   mov  cl,[edi+PITCH*3+5]
  mov   esi,BlockNM1.N8T35
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T33
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*3+3]
  mov   cl,[edi+PITCH*3+7]
   mov  esi,BlockNM1.N8T37
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T40
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*4+0]
   mov  cl,[edi+PITCH*4+4]
  mov   esi,BlockNM1.N8T44
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T42
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*4+2]
  mov   cl,[edi+PITCH*4+6]
   mov  esi,BlockNM1.N8T46
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T51
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*5+1]
   mov  cl,[edi+PITCH*5+5]
  mov   esi,BlockNM1.N8T55
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T53
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*5+3]
  mov   cl,[edi+PITCH*5+7]
   mov  esi,BlockNM1.N8T57
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T60
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*6+0]
   mov  cl,[edi+PITCH*6+4]
  mov   esi,BlockNM1.N8T64
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T62
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*6+2]
  mov   cl,[edi+PITCH*6+6]
   mov  esi,BlockNM1.N8T66
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T71
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*7+1]
   mov  cl,[edi+PITCH*7+5]
  mov   esi,BlockNM1.N8T75
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T73
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*7+3]
  mov   cl,[edi+PITCH*7+7]
   mov  esi,BlockNM1.N8T77
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  add   edx,ebp   
   mov  cl,[esi+ecx*8+2]
  shr   edx,16 
   add  ebp,ecx
  and   ebp,0FFFFH
   sub  esp,BlockLen
  add   ebp,edx
   sub  edi,8
  test  esp,000000008H
  mov   BlockN.CentralInterSWD_SLF,ebp
   jne  SLFSWDLoop

  test  esp,000000010H
  lea   edi,[edi-PITCH*8+16]
   jne  SLFSWDLoop

  mov   eax,Block2.CentralInterSWD_SLF+BlockLen*4
   mov  ebx,Block3.CentralInterSWD_SLF+BlockLen*4
  mov   ecx,Block4.CentralInterSWD_SLF+BlockLen*4
   add  esp,BlockLen*4
  add   ebp,ecx
   lea  edx,[eax+ebx]
  add   ebp,edx
   mov  edx,SpatialFiltDifferential
  lea   esi,[edi+PITCH*8-8]
   mov  edi,MBCentralInterSWD
  sub   edi,edx
   mov  edx,MBlockActionStream
  cmp   ebp,edi
   jge  SpatialFilterNotAsGood

  mov   MBCentralInterSWD,ebp            ; Spatial filter was better.  Stash
   mov  ebp,Block1.CentralInterSWD_SLF   ; pertinent calculations.
  mov   Block2.CentralInterSWD,eax
   mov  Block3.CentralInterSWD,ebx
  mov   Block4.CentralInterSWD,ecx
   mov  Block1.CentralInterSWD,ebp
  mov   [edx].BlkY1.PastRef,esi
   mov  al,INTERSLF
  mov   [edx].BlockType,al

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

  mov   al,[edx].CodedBlocks       ; Fetch coded block pattern.
   mov  edi,EmptyThreshold         ; Get threshold for forcing block empty?
  mov   ebp,MBCentralInterSWD
   mov  esi,InterSWDBlocks
  mov   ebx,Block4.CentralInterSWD ; Is SWD > threshold?
  cmp   ebx,edi
   jg   @f

  and   al,0F7H                    ; If not, indicate block 4 is NOT coded.
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block3.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FBH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block2.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FDH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block1.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FEH
   dec  esi
  sub   ebp,ebx

@@:

  mov   [edx].CodedBlocks,al     ; Store coded block pattern.
   add  esi,4
  mov   InterSWDBlocks,esi
   xor  ebx,ebx
  and   eax,00FH
   mov  MBCentralInterSWD,ebp
  cmp   al,00FH                  ; Are any blocks marked empty?
   jne  InterBest                ; If some blocks are empty, can't code as Intra

  cmp   ebp,InterCodingThreshold ; Is InterSWD below inter-coding threshhold.
   lea  esi,Block1+128
  mov   ebp,0
   jae  CalculateIntraSWD

InterBest:

  mov   ecx,InterSWDTotal
   mov  ebp,MBCentralInterSWD
  add   ecx,ebp                    ; Add to total for this macroblock class.
   mov  PD [edx].SWD,ebp
  mov   InterSWDTotal,ecx
   jmp  NextMacroBlock


;  Activity Details for this section of code  (refer to flow diagram above):
;
;    11)  The IntraSWD is calculated as two partial sums, one in the low order
;         16 bits of ebp and one in the high order 16 bits.  An average pel
;         value for each block will be calculated to the nearest half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     None
;
;   Predominate usage for body of this section:
;
;     esi -- Address of target block 1 (3), plus 128.
;     ebp[ 0:15] -- IntraSWD Accumulator for block 1 (3).
;     ebp[16:31] -- IntraSWD Accumulator for block 2 (4).
;     edi -- Block 2 (4) target pel, times -8, and with WeightedDiff added.
;     edx -- Block 1 (3) target pel, times -8, and with WeightedDiff added.
;     ecx[ 0: 7] -- Weighted difference for one pel in block 2 (4).
;     ecx[ 8:15] -- Zero.
;     ecx[16:23] -- Weighted difference for one pel in block 1 (3).
;     ecx[24:31] -- Zero.
;     ebx -- Average block 2 (4) target pel to nearest .5.
;     eax -- Average block 1 (3) target pel to nearest .5.
;
;   Output of this section:
;
;     edi -- Scratch.
;     ebp[ 0:15] -- IntraSWD.  (Also written to MBlockActionStream.)
;     ebp[16:31] -- garbage.
;     ebx -- Zero.
;     eax -- MBlockActionStream.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Executed once per macroblock, (except for those for which one of more blocks
;   are marked empty, or where the InterSWD is less than a threshold).
;
;   183 clocks for instruction execution
;    12 clocks for bank conflicts  (94 dual mem ops with 1/8 chance of conflict)
;  ----
;   195 clocks total time for this section.

IntraByDecree:

  mov   eax,InterSWDBlocks            ; Inc by 4, because we will undo it below.
   xor  ebp,ebp
  mov   MBMotionVectors,ebp           ; Stash zero for MB level motion vectors.
   mov  ebp,040000000H                ; Set Inter SWD artificially high.
  lea   esi,Block1+128
   add  eax,4
  mov   MBCentralInterSWD,ebp
   mov  InterSWDBlocks,eax

CalculateIntraSWD:
CalculateIntraSWDLoop:

  mov   eax,[esi-128].AccumTargetPels  ; Fetch acc of target pels for 1st block.
   mov  edx,[esi-128].N8T00
  add   eax,8
   mov  ebx,[esi-128+BlockLen].AccumTargetPels
  shr   eax,4                ; Average block 1 target pel rounded to nearest .5.
   add  ebx,8
  shr   ebx,4
   mov  edi,[esi-128+BlockLen].N8T00
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T02
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T02
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T04
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T04
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T06
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T06
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T11
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T11
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T13
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T13
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T15
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T15
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T17
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T17
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T20
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T20
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T22
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T22
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T24
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T24
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T26
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T26
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T31
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T31
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T33
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T33
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T35
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T35
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T37
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T37
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T40
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T40
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T42
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T42
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T44
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T44
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T46
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T46
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T51
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T51
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T53
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T53
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T55
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T55
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T57
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T57
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T60
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T60
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T62
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T62
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T64
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T64
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T66
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T66
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T71
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T71
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T73
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T73
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T75
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T75
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T77
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T77
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   cl,PB [edi+ebx*4+2]
   mov  eax,000007FFFH
  add   ebp,ecx
   add  esi,BlockLen*2
  and   eax,ebp
   mov  ecx,MBCentralInterSWD
  shr   ebp,16
   sub  ecx,IntraCodingDifferential
  add   ebp,eax
   mov  edx,MBlockActionStream    ; Reload list ptr.
  cmp   ecx,ebp                    ; Is IntraSWD > InterSWD - differential?
   jl   InterBest

  lea   ecx,Block1+128+BlockLen*2
  cmp   ecx,esi
   je   CalculateIntraSWDLoop


;  ebp  -- IntraSWD
;  edx  -- MBlockActionStream

DoneCalcIntraSWD:

IntraBest:

  mov   ecx,IntraSWDTotal
   mov  edi,IntraSWDBlocks
  add   ecx,ebp                    ; Add to total for this macroblock class.
   add  edi,4                      ; Accumulate # of blocks for this type.
  mov   IntraSWDBlocks,edi
   mov  edi,InterSWDBlocks
  sub   edi,4
   mov  IntraSWDTotal,ecx
  mov   InterSWDBlocks,edi
   mov  bl,INTRA
  mov   PB [edx].BlockType,bl      ; Indicate macroblock handling decision.
IFDEF H261
   xor  ebx,ebx
ELSE ; H263
   mov  ebx,MBMotionVectors        ; Set MVs to best MB level motion vectors.
ENDIF
  mov   PD [edx].BlkY1.MVs,ebx
   mov  PD [edx].BlkY2.MVs,ebx
  mov   PD [edx].BlkY3.MVs,ebx
   mov  PD [edx].BlkY4.MVs,ebx
  xor   ebx,ebx
  mov   PD [edx].SWD,ebp
   jmp  NextMacroBlock

;==============================================================================
; Internal functions
;==============================================================================

DoSWDLoop:

;  Upon entry:
;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   bl,PB [esi]               ; 00A -- Get Pel 00 in reference ref1.
   mov  eax,Block1.N8T00+4        ; 00B -- Get -8 times target pel 00.
  mov   cl,PB [edi]               ; 00C -- Get Pel 00 in reference ref2.
   sub  esp,BlockLen*4+28

SWDLoop:

  mov   edx,PD [eax+ebx*8]        ; 00D -- Get weighted diff for ref1 pel 00.
   mov  bl,PB [esi+2]             ; 02A
  mov   dl,PB [eax+ecx*8+2]       ; 00E -- Get weighted diff for ref2 pel 00.
   mov  eax,BlockN.N8T02+32       ; 02B
  mov   ebp,edx                   ; 00F -- Accum weighted diffs for pel 00.
   mov  cl,PB [edi+2]             ; 02C
  mov   edx,PD [eax+ebx*8]        ; 02D
   mov  bl,PB [esi+4]             ; 04A
  mov   dl,PB [eax+ecx*8+2]       ; 02E
   mov  eax,BlockN.N8T04+32       ; 04B
  mov   cl,PB [edi+4]             ; 04C
   add  ebp,edx                   ; 02F
  mov   edx,PD [eax+ebx*8]        ; 04D
   mov  bl,PB [esi+6]
  mov   dl,PB [eax+ecx*8+2]       ; 04E
   mov  eax,BlockN.N8T06+32
  mov   cl,PB [edi+6]
   add  ebp,edx                   ; 04F
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T11+32
  mov   cl,PB [edi+PITCH*1+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T13+32
  mov   cl,PB [edi+PITCH*1+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T15+32
  mov   cl,PB [edi+PITCH*1+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T17+32
  mov   cl,PB [edi+PITCH*1+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T20+32
  mov   cl,PB [edi+PITCH*2+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T22+32
  mov   cl,PB [edi+PITCH*2+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T24+32
  mov   cl,PB [edi+PITCH*2+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T26+32
  mov   cl,PB [edi+PITCH*2+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T31+32
  mov   cl,PB [edi+PITCH*3+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T33+32
  mov   cl,PB [edi+PITCH*3+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T35+32
  mov   cl,PB [edi+PITCH*3+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T37+32
  mov   cl,PB [edi+PITCH*3+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T40+32
  mov   cl,PB [edi+PITCH*4+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T42+32
  mov   cl,PB [edi+PITCH*4+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T44+32
  mov   cl,PB [edi+PITCH*4+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T46+32
  mov   cl,PB [edi+PITCH*4+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T51+32
  mov   cl,PB [edi+PITCH*5+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T53+32
  mov   cl,PB [edi+PITCH*5+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T55+32
  mov   cl,PB [edi+PITCH*5+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T57+32
  mov   cl,PB [edi+PITCH*5+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T60+32
  mov   cl,PB [edi+PITCH*6+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T62+32
  mov   cl,PB [edi+PITCH*6+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T64+32
  mov   cl,PB [edi+PITCH*6+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T66+32
  mov   cl,PB [edi+PITCH*6+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T71+32
  mov   cl,PB [edi+PITCH*7+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T73+32
  mov   cl,PB [edi+PITCH*7+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T75+32
  mov   cl,PB [edi+PITCH*7+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T77+32
  mov   cl,PB [edi+PITCH*7+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   add  esp,BlockLen
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,ebp
  add   ebp,edx
   add  edx,eax
  shr   ebp,16                       ; Extract SWD for ref1.
   and  edx,00000FFFFH               ; Extract SWD for ref2.
  mov   esi,BlockN.Ref1Addr+32       ; Get address of next ref1 block.
   mov  edi,BlockN.Ref2Addr+32       ; Get address of next ref2 block.
  mov   BlockNM1.Ref1InterSWD+32,ebp ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,edx ; Store SWD for ref2.
  mov   bl,PB [esi]                  ; 00A -- Get Pel 02 in reference ref1.
   mov  eax,BlockN.N8T00+32          ; 00B -- Get -8 times target pel 00.
  test  esp,000000018H               ; Done when esp is 32-byte aligned.
  mov   cl,PB [edi]                  ; 00C -- Get Pel 02 in reference ref2.
   jne  SWDLoop

; Output:
;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  add   esp,28
  ret

IFDEF H261
ELSE ; H263

DoSWDHalfPelHorzLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelHorzLoop:

  mov   al,[edi]           ; 00A -- Fetch center ref pel 00.
   mov  esi,BlockN.N8T00+32; 00B -- Target pel 00 (times -8).
  mov   bl,[edi+2]         ; 02A -- Fetch center ref pel 02.
   mov  edx,BlockN.N8T02+32; 02B -- Target pel 02 (times -8).
  lea   esi,[esi+eax*4]    ; 00C -- Combine target pel 00 and center ref pel 00.
   mov  al,[edi-1]         ; 00D -- Get pel to left for match against pel 00.
  lea   edx,[edx+ebx*4]    ; 02C -- Combine target pel 02 and center ref pel 02.
   mov  bl,[edi+1]         ; 00E -- Get pel to right for match against pel 00,
   ;                       ; 02D -- and pel to left for match against pel 02.
  mov   ecx,[esi+eax*4]    ; 00F -- [16:23]  weighted diff for left ref pel 00.
   mov  al,[edi+3]         ; 02E -- Get pel to right for match against pel 02.
  add   ebp,ecx            ; 00G -- Accumulate left ref pel 00.
   mov  ecx,[edx+ebx*4]    ; 02F -- [16:23]  weighted diff for left ref pel 02.
  mov   cl,[edx+eax*4+2]   ; 02H -- [0:7] is weighted diff for right ref pel 02.
   mov  al,[edi+4]         ; 04A
  add   ebp,ecx            ; 02I -- Accumulate right ref pel 02,
  ;                        ; 02G -- Accumulate left ref pel 02.
   mov  bl,[esi+ebx*4+2]   ; 00H -- [0:7] is weighted diff for right ref pel 00.
  add   ebp,ebx            ; 00I -- Accumulate right ref pel 00.
   mov  esi,BlockN.N8T04+32; 04B
  mov   bl,[edi+6]         ; 06A
   mov  edx,BlockN.N8T06+32; 06B
  lea   esi,[esi+eax*4]    ; 04C
   mov  al,[edi+3]         ; 04D
  lea   edx,[edx+ebx*4]    ; 06C
   mov  bl,[edi+5]         ; 04E & 06D
  mov   ecx,[esi+eax*4]    ; 04F
   mov  al,[edi+7]         ; 06E
  add   ebp,ecx            ; 04G
   mov  ecx,[edx+ebx*4]    ; 06F
  mov   cl,[edx+eax*4+2]   ; 06H
   mov  al,[edi+PITCH*1+1] ; 11A
  add   ebp,ecx            ; 04I & 06G
   mov  bl,[esi+ebx*4+2]   ; 04H
  add   ebp,ebx            ; 04I
   mov  esi,BlockN.N8T11+32; 11B
  mov   bl,[edi+PITCH*1+3] ; 13A
   mov  edx,BlockN.N8T13+32; 13B
  lea   esi,[esi+eax*4]    ; 11C
   mov  al,[edi+PITCH*1+0] ; 11D
  lea   edx,[edx+ebx*4]    ; 13C
   mov  bl,[edi+PITCH*1+2] ; 11E & 13D
  mov   ecx,[esi+eax*4]    ; 11F
   mov  al,[edi+PITCH*1+4] ; 13E
  add   ebp,ecx            ; 11G
   mov  ecx,[edx+ebx*4]    ; 13F
  mov   cl,[edx+eax*4+2]   ; 13H
   mov  al,[edi+PITCH*1+5] ; 15A
  add   ebp,ecx            ; 11I & 13G
   mov  bl,[esi+ebx*4+2]   ; 11H
  add   ebp,ebx            ; 11I
   mov  esi,BlockN.N8T15+32; 15B
  mov   bl,[edi+PITCH*1+7] ; 17A
   mov  edx,BlockN.N8T17+32; 17B
  lea   esi,[esi+eax*4]    ; 15C
   mov  al,[edi+PITCH*1+4] ; 15D
  lea   edx,[edx+ebx*4]    ; 17C
   mov  bl,[edi+PITCH*1+6] ; 15E & 17D
  mov   ecx,[esi+eax*4]    ; 15F
   mov  al,[edi+PITCH*1+8] ; 17E
  add   ebp,ecx            ; 15G
   mov  ecx,[edx+ebx*4]    ; 17F
  mov   cl,[edx+eax*4+2]   ; 17H
   mov  al,[edi+PITCH*2+0] ; 20A
  add   ebp,ecx            ; 15I & 17G
   mov  bl,[esi+ebx*4+2]   ; 15H
  add   ebp,ebx            ; 15I
   mov  esi,BlockN.N8T20+32; 20B
  mov   bl,[edi+PITCH*2+2] ; 22A
   mov  edx,BlockN.N8T22+32; 22B
  lea   esi,[esi+eax*4]    ; 20C
   mov  al,[edi+PITCH*2-1] ; 20D
  lea   edx,[edx+ebx*4]    ; 22C
   mov  bl,[edi+PITCH*2+1] ; 20E & 22D
  mov   ecx,[esi+eax*4]    ; 20F
   mov  al,[edi+PITCH*2+3] ; 22E
  add   ebp,ecx            ; 20G
   mov  ecx,[edx+ebx*4]    ; 22F
  mov   cl,[edx+eax*4+2]   ; 22H
   mov  al,[edi+PITCH*2+4] ; 24A
  add   ebp,ecx            ; 20I & 22G
   mov  bl,[esi+ebx*4+2]   ; 20H
  add   ebp,ebx            ; 20I
   mov  esi,BlockN.N8T24+32; 24B
  mov   bl,[edi+PITCH*2+6] ; 26A
   mov  edx,BlockN.N8T26+32; 26B
  lea   esi,[esi+eax*4]    ; 24C
   mov  al,[edi+PITCH*2+3] ; 24D
  lea   edx,[edx+ebx*4]    ; 26C
   mov  bl,[edi+PITCH*2+5] ; 24E & 26D
  mov   ecx,[esi+eax*4]    ; 24F
   mov  al,[edi+PITCH*2+7] ; 26E
  add   ebp,ecx            ; 24G
   mov  ecx,[edx+ebx*4]    ; 26F
  mov   cl,[edx+eax*4+2]   ; 26H
   mov  al,[edi+PITCH*3+1] ; 31A
  add   ebp,ecx            ; 24I & 26G
   mov  bl,[esi+ebx*4+2]   ; 24H
  add   ebp,ebx            ; 24I
   mov  esi,BlockN.N8T31+32; 31B
  mov   bl,[edi+PITCH*3+3] ; 33A
   mov  edx,BlockN.N8T33+32; 33B
  lea   esi,[esi+eax*4]    ; 31C
   mov  al,[edi+PITCH*3+0] ; 31D
  lea   edx,[edx+ebx*4]    ; 33C
   mov  bl,[edi+PITCH*3+2] ; 31E & 33D
  mov   ecx,[esi+eax*4]    ; 31F
   mov  al,[edi+PITCH*3+4] ; 33E
  add   ebp,ecx            ; 31G
   mov  ecx,[edx+ebx*4]    ; 33F
  mov   cl,[edx+eax*4+2]   ; 33H
   mov  al,[edi+PITCH*3+5] ; 35A
  add   ebp,ecx            ; 31I & 33G
   mov  bl,[esi+ebx*4+2]   ; 31H
  add   ebp,ebx            ; 31I
   mov  esi,BlockN.N8T35+32; 35B
  mov   bl,[edi+PITCH*3+7] ; 37A
   mov  edx,BlockN.N8T37+32; 37B
  lea   esi,[esi+eax*4]    ; 35C
   mov  al,[edi+PITCH*3+4] ; 35D
  lea   edx,[edx+ebx*4]    ; 37C
   mov  bl,[edi+PITCH*3+6] ; 35E & 37D
  mov   ecx,[esi+eax*4]    ; 35F
   mov  al,[edi+PITCH*3+8] ; 37E
  add   ebp,ecx            ; 35G
   mov  ecx,[edx+ebx*4]    ; 37F
  mov   cl,[edx+eax*4+2]   ; 37H
   mov  al,[edi+PITCH*4+0] ; 40A
  add   ebp,ecx            ; 35I & 37G
   mov  bl,[esi+ebx*4+2]   ; 35H
  add   ebp,ebx            ; 35I
   mov  esi,BlockN.N8T40+32; 40B
  mov   bl,[edi+PITCH*4+2] ; 42A
   mov  edx,BlockN.N8T42+32; 42B
  lea   esi,[esi+eax*4]    ; 40C
   mov  al,[edi+PITCH*4-1] ; 40D
  lea   edx,[edx+ebx*4]    ; 42C
   mov  bl,[edi+PITCH*4+1] ; 40E & 42D
  mov   ecx,[esi+eax*4]    ; 40F
   mov  al,[edi+PITCH*4+3] ; 42E
  add   ebp,ecx            ; 40G
   mov  ecx,[edx+ebx*4]    ; 42F
  mov   cl,[edx+eax*4+2]   ; 42H
   mov  al,[edi+PITCH*4+4] ; 44A
  add   ebp,ecx            ; 40I & 42G
   mov  bl,[esi+ebx*4+2]   ; 40H
  add   ebp,ebx            ; 40I
   mov  esi,BlockN.N8T44+32; 44B
  mov   bl,[edi+PITCH*4+6] ; 46A
   mov  edx,BlockN.N8T46+32; 46B
  lea   esi,[esi+eax*4]    ; 44C
   mov  al,[edi+PITCH*4+3] ; 44D
  lea   edx,[edx+ebx*4]    ; 46C
   mov  bl,[edi+PITCH*4+5] ; 44E & 46D
  mov   ecx,[esi+eax*4]    ; 44F
   mov  al,[edi+PITCH*4+7] ; 46E
  add   ebp,ecx            ; 44G
   mov  ecx,[edx+ebx*4]    ; 46F
  mov   cl,[edx+eax*4+2]   ; 46H
   mov  al,[edi+PITCH*5+1] ; 51A
  add   ebp,ecx            ; 44I & 46G
   mov  bl,[esi+ebx*4+2]   ; 44H
  add   ebp,ebx            ; 44I
   mov  esi,BlockN.N8T51+32; 51B
  mov   bl,[edi+PITCH*5+3] ; 53A
   mov  edx,BlockN.N8T53+32; 53B
  lea   esi,[esi+eax*4]    ; 51C
   mov  al,[edi+PITCH*5+0] ; 51D
  lea   edx,[edx+ebx*4]    ; 53C
   mov  bl,[edi+PITCH*5+2] ; 51E & 53D
  mov   ecx,[esi+eax*4]    ; 51F
   mov  al,[edi+PITCH*5+4] ; 53E
  add   ebp,ecx            ; 51G
   mov  ecx,[edx+ebx*4]    ; 53F
  mov   cl,[edx+eax*4+2]   ; 53H
   mov  al,[edi+PITCH*5+5] ; 55A
  add   ebp,ecx            ; 51I & 53G
   mov  bl,[esi+ebx*4+2]   ; 51H
  add   ebp,ebx            ; 51I
   mov  esi,BlockN.N8T55+32; 55B
  mov   bl,[edi+PITCH*5+7] ; 57A
   mov  edx,BlockN.N8T57+32; 57B
  lea   esi,[esi+eax*4]    ; 55C
   mov  al,[edi+PITCH*5+4] ; 55D
  lea   edx,[edx+ebx*4]    ; 57C
   mov  bl,[edi+PITCH*5+6] ; 55E & 57D
  mov   ecx,[esi+eax*4]    ; 55F
   mov  al,[edi+PITCH*5+8] ; 57E
  add   ebp,ecx            ; 55G
   mov  ecx,[edx+ebx*4]    ; 57F
  mov   cl,[edx+eax*4+2]   ; 57H
   mov  al,[edi+PITCH*6+0] ; 60A
  add   ebp,ecx            ; 55I & 57G
   mov  bl,[esi+ebx*4+2]   ; 55H
  add   ebp,ebx            ; 55I
   mov  esi,BlockN.N8T60+32; 60B
  mov   bl,[edi+PITCH*6+2] ; 62A
   mov  edx,BlockN.N8T62+32; 62B
  lea   esi,[esi+eax*4]    ; 60C
   mov  al,[edi+PITCH*6-1] ; 60D
  lea   edx,[edx+ebx*4]    ; 62C
   mov  bl,[edi+PITCH*6+1] ; 60E & 62D
  mov   ecx,[esi+eax*4]    ; 60F
   mov  al,[edi+PITCH*6+3] ; 62E
  add   ebp,ecx            ; 60G
   mov  ecx,[edx+ebx*4]    ; 62F
  mov   cl,[edx+eax*4+2]   ; 62H
   mov  al,[edi+PITCH*6+4] ; 64A
  add   ebp,ecx            ; 60I & 62G
   mov  bl,[esi+ebx*4+2]   ; 60H
  add   ebp,ebx            ; 60I
   mov  esi,BlockN.N8T64+32; 64B
  mov   bl,[edi+PITCH*6+6] ; 66A
   mov  edx,BlockN.N8T66+32; 66B
  lea   esi,[esi+eax*4]    ; 64C
   mov  al,[edi+PITCH*6+3] ; 64D
  lea   edx,[edx+ebx*4]    ; 66C
   mov  bl,[edi+PITCH*6+5] ; 64E & 66D
  mov   ecx,[esi+eax*4]    ; 64F
   mov  al,[edi+PITCH*6+7] ; 66E
  add   ebp,ecx            ; 64G
   mov  ecx,[edx+ebx*4]    ; 66F
  mov   cl,[edx+eax*4+2]   ; 66H
   mov  al,[edi+PITCH*7+1] ; 71A
  add   ebp,ecx            ; 64I & 66G
   mov  bl,[esi+ebx*4+2]   ; 64H
  add   ebp,ebx            ; 64I
   mov  esi,BlockN.N8T71+32; 71B
  mov   bl,[edi+PITCH*7+3] ; 73A
   mov  edx,BlockN.N8T73+32; 73B
  lea   esi,[esi+eax*4]    ; 71C
   mov  al,[edi+PITCH*7+0] ; 71D
  lea   edx,[edx+ebx*4]    ; 73C
   mov  bl,[edi+PITCH*7+2] ; 71E & 73D
  mov   ecx,[esi+eax*4]    ; 71F
   mov  al,[edi+PITCH*7+4] ; 73E
  add   ebp,ecx            ; 71G
   mov  ecx,[edx+ebx*4]    ; 73F
  mov   cl,[edx+eax*4+2]   ; 73H
   mov  al,[edi+PITCH*7+5] ; 75A
  add   ebp,ecx            ; 71I & 73G
   mov  bl,[esi+ebx*4+2]   ; 71H
  add   ebp,ebx            ; 71I
   mov  esi,BlockN.N8T75+32; 75B
  mov   bl,[edi+PITCH*7+7] ; 77A
   mov  edx,BlockN.N8T77+32; 77B
  lea   esi,[esi+eax*4]    ; 75C
   mov  al,[edi+PITCH*7+4] ; 75D
  lea   edx,[edx+ebx*4]    ; 77C
   mov  bl,[edi+PITCH*7+6] ; 75E & 77D
  mov   ecx,[esi+eax*4]    ; 75F
   mov  al,[edi+PITCH*7+8] ; 77E
  add   ebp,ecx            ; 75G
   mov  ecx,[edx+ebx*4]    ; 77F
  mov   cl,[edx+eax*4+2]   ; 77H
   add  esp,BlockLen
  add   ecx,ebp            ; 75I & 77G
   mov  bl,[esi+ebx*4+2]   ; 75H
  add   ebx,ecx            ; 75I
   mov  edi,BlockN.AddrCentralPoint+32 ; Get address of next ref1 block.
  shr   ecx,16                         ; Extract SWD for ref1.
   and  ebx,00000FFFFH                 ; Extract SWD for ref2.
  mov   BlockNM1.Ref1InterSWD+32,ecx   ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,ebx   ; Store SWD for ref2.
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelHorzLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret


DoSWDHalfPelVertLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel up.  Ref2 is .5 down.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelVertLoop:

  mov   al,[edi]
   mov  esi,BlockN.N8T00+32
  mov   bl,[edi+2*PITCH]
   mov  edx,BlockN.N8T20+32
  lea   esi,[esi+eax*4]
   mov  al,[edi-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T40+32
  mov   bl,[edi+6*PITCH]
   mov  edx,BlockN.N8T60+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T11+32
  mov   bl,[edi+1+3*PITCH]
   mov  edx,BlockN.N8T31+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T51+32
  mov   bl,[edi+1+7*PITCH]
   mov  edx,BlockN.N8T71+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T02+32
  mov   bl,[edi+2+2*PITCH]
   mov  edx,BlockN.N8T22+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T42+32
  mov   bl,[edi+2+6*PITCH]
   mov  edx,BlockN.N8T62+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T13+32
  mov   bl,[edi+3+3*PITCH]
   mov  edx,BlockN.N8T33+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T53+32
  mov   bl,[edi+3+7*PITCH]
   mov  edx,BlockN.N8T73+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T04+32
  mov   bl,[edi+4+2*PITCH]
   mov  edx,BlockN.N8T24+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T44+32
  mov   bl,[edi+4+6*PITCH]
   mov  edx,BlockN.N8T64+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T15+32
  mov   bl,[edi+5+3*PITCH]
   mov  edx,BlockN.N8T35+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T55+32
  mov   bl,[edi+5+7*PITCH]
   mov  edx,BlockN.N8T75+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T06+32
  mov   bl,[edi+6+2*PITCH]
   mov  edx,BlockN.N8T26+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T46+32
  mov   bl,[edi+6+6*PITCH]
   mov  edx,BlockN.N8T66+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T17+32
  mov   bl,[edi+7+3*PITCH]
   mov  edx,BlockN.N8T37+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T57+32
  mov   bl,[edi+7+7*PITCH]
   mov  edx,BlockN.N8T77+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   add  esp,BlockLen
  add   ecx,ebp
   mov  bl,[esi+ebx*4+2]
  add   ebx,ecx
   mov  edi,BlockN.AddrCentralPoint+32
  shr   ecx,16
   and  ebx,00000FFFFH
  mov   BlockNM1.Ref1InterSWD+32,ecx
   mov  BlockNM1.Ref2InterSWD+32,ebx
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelVertLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret

ENDIF ; H263


; Performance for common macroblocks:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;  1412 clocks:  6-level search for best SWD.
;    16 clocks:  record best fit.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  2913 clocks total
;
; Performance for macroblocks in which 0-motion vector is "good enough":
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    16 clocks:  record best fit.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  1559 clocks total
;
; Performance for macroblocks marked as intrablock by decree of caller:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;    20 clocks:  classify (just weight the SWD for # of match points).
;  ----
;   476 clocks total
;
; 160*120 performance, generously estimated (assuming lots of motion):
;
;  2913 * 80 = 233000 clocks for luma.
;  2913 * 12 =  35000 clocks for chroma.
;              268000 clocks per frame * 15 = 4,020,000 clocks/sec.
;
; 160*120 performance, assuming typical motion:
;
;  2913 * 40 + 1559 * 40 = 179000 clocks for luma.
;  2913 *  8 + 1559 *  4 =  30000 clocks for chroma.
;                          209000 clocks per frame * 15 = 3,135,000 clocks/sec.
;
; Add 10-20% to allow for initial cache-filling, and unfortunate cases where
; cache-filling policy preempts areas of the tables that are not locally "hot",
; instead of preempting macroblocks upon which the processing was just finished.


Done:

  mov   eax,IntraSWDTotal
  mov   ebx,IntraSWDBlocks
  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+IntraSWDTotal_arg]
  mov   [edi],eax
  mov   edi,[esp+IntraSWDBlocks_arg]
  mov   [edi],ebx
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


MOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdialogs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * cdialog.h
 *
 * DESCRIPTION:
 *		Interface to the dialog functions.
 *
 */

// $Header:   S:\h26x\src\common\cdialogs.h_v   1.11   05 Feb 1997 12:14:20   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdialogs.h_v  $
;// 
;//    Rev 1.11   05 Feb 1997 12:14:20   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.10   16 Dec 1996 17:36:24   JMCVEIGH
;// Added custom messages for H.263+ options.
;// 
;//    Rev 1.9   11 Dec 1996 14:54:42   JMCVEIGH
;// Prototypes for setting/getting in-the-loop deblocking filter and
;// true B-frame modes.
;// 
;//    Rev 1.8   13 Nov 1996 00:33:30   BECHOLS
;// Removed registry stuff.
;// 
;//    Rev 1.7   16 Oct 1996 15:09:28   SCDAY
;// Added support for RTP AM interface
;// 
;//    Rev 1.6   10 Sep 1996 16:13:02   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.5   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.4   22 May 1996 18:46:54   BECHOLS
;// 
;// Added CustomResetToFactoryDefaults.
;// 
;//    Rev 1.3   06 May 1996 00:41:20   BECHOLS
;// 
;// Added bit rate control stuff for the configure dialog.
;// 
;//    Rev 1.2   26 Apr 1996 11:08:58   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.1   17 Oct 1995 15:07:10   DBRUCKS
;// add about box files
;//
;// Added declarations to support Encoder Control messages.
;// Add Configure dialog
;// 

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#define DLG_DRIVERCONFIGURE         300

extern I32 About(HWND hwnd);
extern I32 DrvConfigure(HWND hwnd);

extern void GetConfigurationDefaults(T_CONFIGURATION * pConfiguration);

LRESULT CustomGetRTPHeaderState(LPCODINST, DWORD FAR *);
LRESULT CustomGetResiliencyState(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRateState(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketSize(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketLoss(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRate(LPCODINST, DWORD FAR *);

LRESULT CustomSetRTPHeaderState(LPCODINST, DWORD);
LRESULT CustomSetResiliencyState(LPCODINST, DWORD);
LRESULT CustomSetBitRateState(LPCODINST, DWORD);
LRESULT CustomSetPacketSize(LPCODINST, DWORD);
LRESULT CustomSetPacketLoss(LPCODINST, DWORD);
LRESULT CustomSetBitRate(LPCODINST, DWORD);

#ifdef H263P
LRESULT CustomGetH263PlusState(LPCODINST, DWORD FAR *);
LRESULT CustomGetDeblockingFilterState(LPCODINST, DWORD FAR *);

LRESULT CustomSetH263PlusState(LPCODINST, DWORD);
LRESULT CustomSetDeblockingFilterState(LPCODINST, DWORD);
#endif // H263P

extern LRESULT CustomResetToFactoryDefaults(LPCODINST);

extern LRESULT CustomSetBlockEdgeFilter(LPDECINST, DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\i386\yuv12enc.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;//
;////////////////////////////////////////////////////////////////////////////
; yuv12enc -- This function performs "color conversion" in the H26X decoder for
;             consumption by the H26X encoder.  This entails reformatting the decoder's
;             YVU data into the shape required by the encoder - including YUV order.  It
;			  Also includes 7-bit pels.
; $Header:   S:\h26x\src\dec\yuv12enc.asv   1.5   30 Oct 1996 14:31:00   mbodart  $
; $Log:   S:\h26x\src\dec\yuv12enc.asv  $
;// 
;//    Rev 1.5   30 Oct 1996 14:31:00   mbodart
;// Re-checking in changes originally made by Atul, but lost when the server
;// ran out of disk space during a PVCS operation.  Atul's original log msg:
;// 
;// Removed AGI in IA code.  Added MMX code but it is not ready for prime-time.
;// 
;//    Rev 1.4   08 Mar 1996 15:11:10   AGUPTA2
;// Removed segment register override when compiling for WIN32.
;// Should speed-up this routine substantially.
;// 
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include decconst.inc
IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataH26x_YUV12ForEnc>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE H26x_YUV12ForEnc (
;							U8 FAR * InstanceBase,
;                           X32 YPlane,
;                           X32 VPlane,
;                           X32 UPlane,
;                           UN  FrameWidth,
;                           UN  FrameHeight,
;                           UN  Pitch,
;                           U8 FAR * ColorConvertedFrame, // encoder's buffers.
;                           X32 YOutputPlane,
;                           X32 VOutputPlane,
;                           X32 UOutputPlane)
;
;  YPlane, VPlane, YOutputPlane, and VOutputPlane are offsets. In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;

PUBLIC  H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD


LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor
;   esi -- Y plane input cursor
;   ebp -- Count down Y plane height
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  Lesi  YPlane
   Lebx Pitch
  Ledi  YOutputPlane

YLoopHeader:	
  mov   eax, PD [esi+ecx-8]        ; 
   mov  edx, PD [esi+ecx-4]
ALIGN 4
YLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
                                   ; NEXT 8 PELS
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8-8], eax
   mov  PD [edi+ecx-4-8], edx

  mov   eax, PD [esi+ecx-8-16]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-16]      ; for next iteration

  sub   ecx, 16
   jg   YLoop

  Lecx  FrameWidth
   add  esi, ebx
  add   edi, ebx
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

H26x_YUV12ForEnc endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\c3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\common\c3rtp.cpv   1.8   03 Dec 1996 13:16:16   CZHU  $
// $Log:   S:\h26x\src\common\c3rtp.cpv  $
// 
//    Rev 1.8   03 Dec 1996 13:16:16   CZHU
// adjust format of debug message.
// 
//    Rev 1.7   26 Nov 1996 16:00:26   GMLIM
// Increase size returned by getrtpBsInfoSize() for larger PB bs info buffer.
// 
//    Rev 1.6   06 Nov 1996 15:11:42   CZHU
// Added minor change for debug output
// 
//    Rev 1.5   31 Oct 1996 10:12:36   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.4   17 Sep 1996 09:22:58   CZHU
// minor cleaning
// 
//    Rev 1.3   16 Sep 1996 16:38:44   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.2   02 May 1996 13:27:04   CZHU
// Adjust for merging with main database in the decoder
// 
//    Rev 1.1   28 Apr 1996 20:34:50   BECHOLS
// 
// Removed IFDEF -- RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:54   BECHOLS
// Initial revision.
// 
//    Rev 1.3   10 Apr 1996 13:32:08   CZHU
// 
// Moved testing packet loss into this module for common use by encoder or dec
// 
//    Rev 1.2   29 Mar 1996 14:45:06   CZHU
// 
//    Rev 1.1   29 Mar 1996 14:39:34   CZHU
// Some cleaning
// 
//    Rev 1.0   29 Mar 1996 13:32:42   CZHU
// Initial revision.
// 
*/
#include "precomp.h"

const int MAX_RATE = 2*1024*1024 ;//set this limit for now

I32 H263RTP_VerifyBsInfoStream(
	T_H263DecoderCatalog *DC,
    U8 *pu8Src,
    U32 uSize
)
{
	T_H263_RTP_BSINFO_TRAILER *pBsTrailer;
	T_RTP_H263_BSINFO *pBsInfo;
	int  i;
	int iRet = FALSE;

	FX_ENTRY("H263RTP_VerifyBsInfoStream")

	ASSERT(!DC->iVerifiedBsExt);

	DC->iVerifiedBsExt=TRUE;
	pBsTrailer =(T_H263_RTP_BSINFO_TRAILER *)(pu8Src + uSize);
	pBsTrailer--;

	DEBUGMSG (ZONE_DECODE_RTP, ("%s: StartCode = %8ld, CompSize=%8ld, No.Pack=%4ld, SRC=%4d, TR=%4d, TRB=%4d, DBQ=%2d\r\n", _fx_, pBsTrailer->uUniqueCode, pBsTrailer->uCompressedSize, pBsTrailer->uNumOfPackets, pBsTrailer->u8Src, pBsTrailer->u8TR,pBsTrailer->u8TRB,pBsTrailer->u8DBQ));

	if (pBsTrailer->uUniqueCode != H263_RTP_BS_START_CODE)
	{
		//#ifdef LOSS_RECOVERY
		DEBUGMSG (ZONE_DECODE_RTP, ("%s: No RTP BS Extension found\r\n", _fx_));
		DC->iValidBsExt   = FALSE;
		DC->uNumOfPackets = 0;
		DC->pBsInfo       = NULL;
		DC->pBsTrailer    = NULL;

		//#endif

		return FALSE;
	}

	//bitstream is valid, so...
	pBsInfo = (T_RTP_H263_BSINFO *)pBsTrailer; 
	pBsInfo -= pBsTrailer->uNumOfPackets;

	//#ifdef LOSS_RECOVERY
	DC->pBsTrailer = (void *)pBsTrailer;
	DC->uNumOfPackets = pBsTrailer->uNumOfPackets;
	DC->iValidBsExt =TRUE;
	DC->pBsInfo     = (void *)pBsInfo;
	//#endif

	for (i=0; i< (int)pBsTrailer->uNumOfPackets; i++)
	{
		DEBUGMSG (ZONE_DECODE_RTP, ("%s: uFlag =%2d,BitOffset=%8d, Mode=%2d, MBA=%4d, uQuant=%2d,GOBN=%2d\r\n", _fx_, pBsInfo->uFlags, pBsInfo->uBitOffset, pBsInfo->u8Mode, pBsInfo->u8MBA, pBsInfo->u8Quant, pBsInfo->u8GOBN));
		pBsInfo++;
	}

	return TRUE;
}

//#ifdef LOSS_RECOVERY
void RtpForcePacketLoss( 
      U8 * pDst,
	  U32 uExtSize,
      U32 uLossNum)
 {	 
	  T_H263_RTP_BSINFO_TRAILER *pTrailer;
	  T_RTP_H263_BSINFO *pBsInfo, *pBsInfoNext;
	  U32 uNum;
//	  U32 uDelta,u, U32 uToCopy;
	  U8 * ptr;
	  U8 mask[]={0, 0x80, 0xc0, 0xe0, 0xf0,0xf8,0xfc,0xfe};

 	  //throw away packet number uPNum packet
	  pTrailer =(T_H263_RTP_BSINFO_TRAILER *)(pDst+uExtSize);
	  pTrailer--;

	  if (pTrailer->uUniqueCode != H263_RTP_BS_START_CODE)
	  {
       goto ret;
	  }

	  pBsInfo = (T_RTP_H263_BSINFO *)pTrailer;
	  pBsInfo -= pTrailer->uNumOfPackets;	  //point at the beginning of the BS_INFO

	  for (uNum =0; uNum < pTrailer->uNumOfPackets-1; uNum++)
	  {	pBsInfoNext = pBsInfo+1; //exclude the last packet
	     // if (pBsInfoNext->u8Mode == RTP_H263_MODE_B) 
	     if (uNum == uLossNum)
	      {  
	       pBsInfo->uFlags |= RTP_H26X_PACKET_LOST;
	       ptr = (U8 *)(pDst + (pBsInfo->uBitOffset)/8);
	       *ptr = *ptr & mask[pBsInfo->uBitOffset % 8];
	       if ( pBsInfo->uBitOffset % 8) ptr++;

	       *ptr++ = 0; //add dword of 0
	       *ptr++ = 0;
	       if (uNum) 
	       { 
	       *ptr++ = 0;  
	       *ptr++ = 0;
		   }
		   else 
		   {//first packet with PSC
		    *ptr++ = 128;
			*ptr++ =3;
		   }
		   break;
	      }
		pBsInfo++;
	  }				  
ret: 
   return;
 }

 /////////////////////////////////////////////////////////
 //	return the size of memory used for bitstream extension
 //	rate up limit set to 1MB for now.
 // Chad, 9/13/96
 /////////////////////////////////////////////////////////

DWORD getRTPBsInfoSize(LPCODINST lpInst)
{
	FX_ENTRY("getRTPBsInfoSize");

    DWORD dwExtSize = 1024UL;
	DWORD dwNumGOBs;
	DWORD dwNumPacketsPerGOB;

	// Get the max number of GOBs
	dwNumGOBs = (lpInst->FrameSz == SQCIF) ? 6 : (lpInst->FrameSz == QCIF) ? 9 : (lpInst->FrameSz == QCIF) ? 18 : 0;

	// Assume there will be at least one header per GOB - worse case
	// Double estimated size to be safe
	if ((lpInst->FrameRate != 0.0f) && dwNumGOBs && lpInst->Configuration.unPacketSize)
	{
		dwNumPacketsPerGOB = (DWORD)(lpInst->DataRate / lpInst->FrameRate) / dwNumGOBs / lpInst->Configuration.unPacketSize + 1;
		dwExtSize = (DWORD)(dwNumPacketsPerGOB * dwNumGOBs * sizeof(T_RTP_H263_BSINFO) + sizeof(T_H263_RTP_BSINFO_TRAILER)) << 1;
	}

    return (dwExtSize);
}

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\c3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   CZHU  $
// $Date:   16 Sep 1996 16:38:08  $
// $Archive:   S:\h26x\src\common\c3rtp.h_v  $
// $Header:   S:\h26x\src\common\c3rtp.h_v   1.2   16 Sep 1996 16:38:08   CZHU  $
// $Log:   S:\h26x\src\common\c3rtp.h_v  $
;// 
;//    Rev 1.2   16 Sep 1996 16:38:08   CZHU
;// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
;// 
;//    Rev 1.1   03 May 1996 13:09:58   CZHU
;// 
;// 
;//    Rev 1.0   22 Apr 1996 16:38:30   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.6   10 Apr 1996 13:32:50   CZHU
;// 
;// Moved testing packet loss into this module for common use by encoder or dec
;// 
;//    Rev 1.5   29 Mar 1996 13:33:16   CZHU
;// 
;// Moved bitstream verification from d3rtp.cpp to c3rtp.cpp
;// 
;//    Rev 1.4   23 Feb 1996 18:01:48   CZHU
;// 
;//    Rev 1.3   23 Feb 1996 17:23:58   CZHU
;// 
;// Changed packet size adjustment
;// 
;//    Rev 1.2   15 Feb 1996 12:02:14   CZHU
;// 
;//    Rev 1.1   14 Feb 1996 15:01:34   CZHU
;// clean up
;// 
;//    Rev 1.0   12 Feb 1996 17:06:42   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   29 Jan 1996 13:50:26   CZHU
;// Initial revision.
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H263_RTP_C3RTP_
#define  _H263_RTP_C3RTP_

const U32  DEFAULT_PACKET_SIZE               = 512;		        //over IP
const U32  DEFAULT_PACKET_SIZE_VARIANCE      = 100;
const U32  DEFAULT_FRAME_SIZE                = 64 * 1024 / 5;	//64KB at 5 fps

const U32  H263_RTP_BS_START_CODE = FOURCC_H263; 

const U32  RTP_H26X_INTRA_CODED   = 0x00000001;
const U32  RTP_H263_PB            = 0x00000002;
const U32  RTP_H263_AP            = 0x00000004;
const U32  RTP_H263_SAC           = 0x00000008;

const U8  RTP_H263_MODE_A        = 0;
const U8  RTP_H263_MODE_B        = 1;
const U8  RTP_H263_MODE_C        = 2;
const U32 H263_RTP_PAYLOAD_VERSION=0;
const U32 RTP_H26X_PACKET_LOST   =0x00000001;

typedef struct {
  U32 uVersion;
  U32 uFlags;
  U32 uUniqueCode;
  U32 uCompressedSize;
  U32 uNumOfPackets;
  U8  u8Src;
  U8  u8TR;
  U8  u8TRB;
  U8  u8DBQ;

} T_H263_RTP_BSINFO_TRAILER;


typedef struct {
	U32 uFlags;
	U32 uBitOffset;
	 U8 u8Mode;
	 U8 u8MBA;
	 U8 u8Quant;
	 U8 u8GOBN;
	 I8 i8HMV1;
	 I8 i8VMV1;
	 I8 i8HMV2;
	 I8 i8VMV2;

} T_RTP_H263_BSINFO	;

extern  I32 H263RTP_VerifyBsInfoStream(T_H263DecoderCatalog *,U8 *, U32 );
extern  void RtpForcePacketLoss(U8 * pDst, U32 uCompSize,U32 PacketNumber);
extern DWORD getRTPBsInfoSize(LPCODINST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ccpuvsn.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cpuvsn.h
 *
 *  Description:
 *		Interface to the CPU version functionality.  This is based on CPUVSN.H
 *      in MRV.
 *
 *	Routines:
 *		
 *  Data:
 *      ProcessorVersionInitialized - if initialized
 *      MMxVersion	- true if running on an MMX system
 *      P6Version	- true if running on a P6
 */

 /* $Header:   R:\h26x\h26x\src\common\ccpuvsn.h_v   1.2   10 Jul 1996 08:26:22   SCDAY  $
  * $Log:   R:\h26x\h26x\src\common\ccpuvsn.h_v  $
;// 
;//    Rev 1.2   10 Jul 1996 08:26:22   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.1   27 Dec 1995 14:11:48   RMCKENZX
;// 
;// Added copyright notice
  */
#ifndef __CPUVSN_H__
#define __CPUVSN_H__

/* This file provides global variables detailing which CPU is running the code.
 */
extern int ProcessorVersionInitialized;
extern int P6Version;
extern int MMxVersion;

/* Processor choices.
 */
#define TARGET_PROCESSOR_PENTIUM     0
#define TARGET_PROCESSOR_P6          1
#define TARGET_PROCESSOR_PENTIUM_MMX 2
#define TARGET_PROCESSOR_P6_MMX      3

#ifdef QUARTZ
void FAR __cdecl InitializeProcessorVersion(int nOn486); // Selects based on hardware
DWORD __cdecl SelectProcessor (DWORD dwTarget);		 // Selects based on the target
#else
void FAR InitializeProcessorVersion(int nOn486); // Selects based on hardware
DWORD SelectProcessor (DWORD dwTarget);		 // Selects based on the target
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdialogs.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifndef MF_SHELL
#ifndef RING0
extern HINSTANCE hDriverModule;
#endif
#endif

/*****************************************************************************
 *
 * cdialog.cpp
 *
 * DESCRIPTION:
 *		Dialog functions.
 *
 * Routines:					Prototypes in:
 *  About						cdialog.h
 *  DrvConfigure				cdialog.h			
 *  GetConfigurationDefaults	cdialogs.h
 */

// $Header:   S:\h26x\src\common\cdialogs.cpv   1.25   06 Mar 1997 14:48:58   KLILLEVO  $
// $Log:   S:\h26x\src\common\cdialogs.cpv  $
// 
//    Rev 1.25   06 Mar 1997 14:48:58   KLILLEVO
// Added check for valid pComp for release version.
// 
//    Rev 1.24   05 Mar 1997 16:17:10   JMCVEIGH
// No longer support configuration dialog box.
// 
//    Rev 1.23   13 Feb 1997 14:13:34   MBODART
// 
// Made Active Movie constant definitions consistent with those in cdialogs.
// 
//    Rev 1.22   12 Feb 1997 15:51:10   AGUPTA2
// Decreased minimum packet size allowed to 64.
// 
//    Rev 1.21   05 Feb 1997 12:13:58   JMCVEIGH
// Support for improved PB-frames custom message handling.
// 
//    Rev 1.20   16 Dec 1996 17:37:28   JMCVEIGH
// Setting/getting of H.263+ optional mode states.
// 
//    Rev 1.19   11 Dec 1996 14:55:26   JMCVEIGH
// 
// Functions for setting/getting in-the-loop deblocking filter and
// true B-frame mode states.
// 
//    Rev 1.18   04 Dec 1996 14:38:18   RHAZRA
// Fixed a couple of bugs: (1) SetResiliencyParameters was never called when
// an application sent a custom message to us turning on resiliency and
// (ii) in ReadDialogBox() the resiliency parameters were being set from
// the defaults rather than the values set by the user.
// 
// Upon Chad's suggestion, I have decided NOT to tie RTP header generation
// and resiliency as per discussion with Ben. This is to stay compliant with
// existing applications such as AV phone and XnetMM that haven't gone to
// ActiveMovie yet.
// 
//    Rev 1.17   25 Nov 1996 09:12:40   BECHOLS
// Bumped packet size to 9600.
// 
//    Rev 1.16   13 Nov 1996 00:33:50   BECHOLS
// 
// Removed registry persistance.
// 
//    Rev 1.15   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.14   21 Oct 1996 10:50:08   RHAZRA
// fixed a problem with H.261 initialization of RTP BS info call
// 
//    Rev 1.13   16 Sep 1996 16:38:46   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.12   10 Sep 1996 16:13:00   KLILLEVO
// added custom message in decoder to turn block edge filter on or off
// 
//    Rev 1.11   29 Aug 1996 09:27:18   CZHU
// Simplified handling of packet loss settings.
// 
//    Rev 1.10   26 Aug 1996 13:38:18   BECHOLS
// Fixed 2 bugs: The first was where if -1 was entered, it would be changed
// to (unsigned) -1, both of which are illegal values.  The second is where
// if an invalid value is entered, and the checkbox is unchecked, the user
// would be required to check the box, enter a valid value, and then uncheck
// the checkbox.  The fixed code notifies the user of the problem if the box
// is checked, and fills in the previous good value.  If the box is unchecked
// it fills in the previous good value, and doesn't notify the user, since
// the value being unchecked is of no concern to the user.
// Finally, I added an IFDEF H261 to the Key path assignment so that H261
// would use a separate Registry Entry.
// 
//    Rev 1.9   21 Aug 1996 18:53:42   RHAZRA
// 
// Added #ifdef s to accomodate both H.261 and H.263 in RTP related
// tasks.
// 
//    Rev 1.7   13 Jun 1996 14:23:36   CZHU
// Fix bugs in custom message handing for RTP related tasks.
// 
//    Rev 1.6   22 May 1996 18:46:02   BECHOLS
// Added CustomResetToFactoryDefaults.
// 
//    Rev 1.5   08 May 1996 10:06:42   BECHOLS
// 
// Changed the checking of the Packet size raising the minimum acceptable to 
// 256 vs. 64.  This will hopefully kludge around a known bug.  I also fixed a
// by preventing field overflow on the numerics.
// 
//    Rev 1.4   06 May 1996 12:53:56   BECHOLS
// Changed the bits per second to bytes per second.
// 
//    Rev 1.3   06 May 1996 00:40:04   BECHOLS
// 
// Added code to support the bit rate control stuff in the resource file.
// I also added the code necessary to handle messages to control the new
// dialog features.
// 
//    Rev 1.2   28 Apr 1996 20:24:54   BECHOLS
// 
// Merged RTP code into the Main Base.
// 
//    Rev 1.1   17 Nov 1995 14:50:54   BECHOLS
// Made modifications to make this file as a mini-filter.  The flags
// RING0 and MF_SHELL were added.
// 
//    Rev 1.0   17 Oct 1995 15:07:22   DBRUCKS
// add about box files
// 
// Added code to process Custom messages, and also code to differentiate
//  between different values for packet loss, and set the defaults for no
//  RTP header or resiliency.
// Modified RTP dialog box.
// Add Configure dialog
// 

static INT_PTR CALLBACK AboutDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration);

#define VALID_BOOLEAN(v) (v == 0 || v == 1)
#if defined(H261)
#define VALID_PACKET_SIZE(v) ((v) >= 128 && (v) <= 9600)
#else
#define VALID_PACKET_SIZE(v) ((v) >= 64 && (v) <= 9600)
#endif
#define VALID_PACKET_LOSS(v) (v >= 0 && v <= 100)
#define VALID_BITRATE(v) (v >= 1024 && v <= 13312)

/**************************************************************************
 * CustomGetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetRTPHeaderState(LPCODINST pComp, DWORD FAR *pRTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pRTPHeaderState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetRTPHeaderState;
   }
   if(pComp && pRTPHeaderState)
   {
      *pRTPHeaderState = (DWORD)pComp->Configuration.bRTPHeader;
      lRet = ICERR_OK;
   }

EXIT_GetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomGetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetResiliencyState(LPCODINST pComp, DWORD FAR *pResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pResiliencyState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetResiliencyState;
   }
   if(pComp && pResiliencyState)
   {
      *pResiliencyState = (DWORD)pComp->Configuration.bEncoderResiliency;
      lRet = ICERR_OK;
   }

EXIT_GetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRateState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRateState(LPCODINST pComp, DWORD FAR *pBitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRateState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRateState;
   }
   if(pComp && pBitRateState)
   {
      *pBitRateState = (DWORD)pComp->Configuration.bBitRateState;
      lRet = ICERR_OK;
   }

EXIT_GetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketSize() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Size.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketSize(LPCODINST pComp, DWORD FAR *pPacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketSize);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketSize;
   }
   if(pComp && pPacketSize)
   {
      *pPacketSize = (DWORD)pComp->Configuration.unPacketSize;
      lRet = ICERR_OK;
   }

EXIT_GetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Loss.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketLoss(LPCODINST pComp, DWORD FAR *pPacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketLoss);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketLoss;
   }
   if(pComp && pPacketLoss)
   {
      *pPacketLoss = (DWORD)pComp->Configuration.unPacketLoss;
      lRet = ICERR_OK;
   }

EXIT_GetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRate() is called from CDRVPROC.CPP.
 *
 * Returns the Bit Rate in bytes per second.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRate(LPCODINST pComp, DWORD FAR *pBitRate)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRate);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRate;
   }
   if(pComp && pBitRate)
   {
      *pBitRate = (DWORD)pComp->Configuration.unBytesPerSecond;
      lRet = ICERR_OK;
   }

EXIT_GetBitRate:
   return(lRet);
}

#ifdef H263P

/**************************************************************************
 * CustomGetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bH263Plus
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetH263PlusState(LPCODINST pComp, DWORD FAR *pH263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pH263PlusState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetH263PlusState;
   }
   if(pComp && pH263PlusState)
   {
      *pH263PlusState = (DWORD)pComp->Configuration.bH263PlusState;
      lRet = ICERR_OK;
   }

EXIT_GetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomGetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetImprovedPBState(LPCODINST pComp, DWORD FAR *pImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pImprovedPBState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetImprovedPBState;
   }
   if(pComp && pImprovedPBState)
   {
      *pImprovedPBState = (DWORD)pComp->Configuration.bImprovedPBState;
      lRet = ICERR_OK;
   }

EXIT_GetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomGetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetDeblockingFilterState(LPCODINST pComp, DWORD FAR *pDeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pDeblockingFilterState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetDeblockingFilterState;
   }
   if(pComp && pDeblockingFilterState)
   {
      *pDeblockingFilterState = (DWORD)pComp->Configuration.bDeblockingFilterState;
      lRet = ICERR_OK;
   }

EXIT_GetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomSetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if pComp is zero or RTPHeaderState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetRTPHeaderState(LPCODINST pComp, DWORD RTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

	FX_ENTRY("CustomSetRTPHeaderState")

   bState = (BOOL)RTPHeaderState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetRTPHeaderState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
    T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        lRet = ICERR_MEMORY;
        goto  EXIT_SetRTPHeaderState;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/

#ifndef H261
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
   P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    EC = &(P32Inst->EC);

    // Get pointer to encoder catalog.
  
   	if (!pComp->Configuration.bRTPHeader && bState)
	{ 
#ifndef H261    
	   H263RTP_InitBsInfoStream(pComp,EC);
#else
       H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
    }
   	if (pComp->Configuration.bRTPHeader && !bState)
	{ 
#ifndef H261
	   H263RTP_TermBsInfoStream(EC);
#else
       H261RTP_TermBsInfoStream(EC);
#endif

	}

    pComp->Configuration.bRTPHeader = bState;
    lRet = ICERR_OK;
   }

EXIT_SetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomSetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ResiliencyState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetResiliencyState(LPCODINST pComp, DWORD ResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)ResiliencyState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetResiliencyState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bEncoderResiliency = bState;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRateState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRateState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetBitRateState(LPCODINST pComp, DWORD BitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)BitRateState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRateState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bBitRateState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketSize() is called from CDRVPROC.CPP.
 *
 * Sets the size of ->unPacketSize.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketSize is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketSize(LPCODINST pComp, DWORD PacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unSize;

	FX_ENTRY("CustomSetPacketSize")

   unSize = (UINT)PacketSize;
   ASSERT(pComp);
   ASSERT(VALID_PACKET_SIZE(unSize));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketSize;
   }
   if(pComp && VALID_PACKET_SIZE(unSize))
   {
   	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        lRet = ICERR_MEMORY;
        goto  EXIT_SetPacketSize;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
#ifndef H261
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);
  
   	if (!pComp->Configuration.bRTPHeader)
	{   lRet = ICERR_ERROR;
        goto  EXIT_SetPacketSize;
    }
 
	if (pComp->Configuration.unPacketSize != unSize )
	{
#ifndef H261
		H263RTP_TermBsInfoStream(EC);
#else
        H261RTP_TermBsInfoStream(EC);
#endif
		pComp->Configuration.unPacketSize = unSize;
#ifndef H261
        H263RTP_InitBsInfoStream(pComp,EC);
#else
        H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
	}

    lRet = ICERR_OK;
   }

EXIT_SetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unPacketLoss.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketLoss is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketLoss(LPCODINST pComp, DWORD PacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unLoss;

   unLoss = (UINT)PacketLoss;
   ASSERT(pComp);
//    ASSERT(VALID_PACKET_LOSS(unLoss)); Always True
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketLoss;
   }
   if(pComp) // && VALID_PACKET_LOSS(unLoss)) Always True
   {
      pComp->Configuration.unPacketLoss = unLoss;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRate() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetBitRate(LPCODINST pComp, DWORD BitRate)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unBitRate;

   unBitRate = (UINT)BitRate;
   ASSERT(pComp);
   ASSERT(VALID_BITRATE(unBitRate));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRate;
   }
   if(pComp && VALID_BITRATE(unBitRate))
   {
      pComp->Configuration.unBytesPerSecond = unBitRate;
      lRet = ICERR_OK;
   }

EXIT_SetBitRate:
   return(lRet);
}

#ifdef H263P

/**************************************************************************
 * CustomSetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bH263PlusState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or H263PlusState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetH263PlusState(LPCODINST pComp, DWORD H263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)H263PlusState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetH263PlusState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bH263PlusState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomSetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ImprovedPB is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetImprovedPBState(LPCODINST pComp, DWORD ImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)ImprovedPBState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetImprovedPBState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bImprovedPBState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomSetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or DeblockingFilter is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetDeblockingFilterState(LPCODINST pComp, DWORD DeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)DeblockingFilterState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetDeblockingFilterState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bDeblockingFilterState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomResetToFactoryDefaults() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomResetToFactoryDefaults(LPCODINST pComp)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);

   if(pComp)
   {
      GetConfigurationDefaults(&pComp->Configuration); /* Overwrite the configuration data */
      lRet = ICERR_OK;
   }

   return(lRet);
}

/**************************************************************************
 * CustomSetBlockEdgeFilter() is called from CDRVPROC.CPP.
 *
 * Turns block edge filter on or off.
 *
 * Returns ICERR_OK if successfull, ICERR_BADPARAM otherwise 
 */
LRESULT CustomSetBlockEdgeFilter(LPDECINST pDeComp, DWORD dwValue)
{
	LRESULT lRet = ICERR_BADPARAM;

	if (dwValue == 1) {
		pDeComp->bUseBlockEdgeFilter = 1;
		lRet = ICERR_OK;
	}
	else if (dwValue == 0) {
		pDeComp->bUseBlockEdgeFilter = 0;
		lRet = ICERR_OK;
	}
	return(lRet);
}

/**************************************************************************
 *
 * About() implements the ICM_ABOUT message.
 *
 * Puts up an about box.
 *
 */
I32 
About(
	HWND hwnd)
{
    int inResult = 0;
    I32 iStatus = ICERR_OK;
#ifndef MF_SHELL
#ifndef RING0

	FX_ENTRY("About")
    
    if (hwnd != ((HWND)-1))
    {
        inResult = DialogBox(hDriverModule, "AboutDlg", hwnd, AboutDialogProc);
		if (inResult == -1) 
		{
			iStatus = ICERR_ERROR;
			ERRORMESSAGE(("%s: DialogBox returned -1\r\n", _fx_));
		}
    }
#endif
#endif
    return iStatus;
} /* end About() */

#ifdef QUARTZ
 void QTZAbout(U32 uData)
 {
	 About((HWND) uData);
 }
#endif

/**************************************************************************
 *
 * DrvConfigure() is called from the DRV_CONFIGURE message.
 *
 * Puts up an about box.
 *
 * Always returns DRV_CANCEL as nothing has changed and no action is required. 
 */
I32 DrvConfigure(
	HWND hwnd)
{  
	I32 iStatus = DRV_CANCEL;
#ifndef MF_SHELL
#ifndef RING0
	int inResult;

	FX_ENTRY("DrvConfigure")

    inResult = DialogBox(hDriverModule, "SetupDlg", hwnd, AboutDialogProc);
	if (inResult == -1) 
	{
		ERRORMESSAGE(("%s: DialogBox returned -1\r\n", _fx_));
	}
#endif
#endif

    return iStatus;
} /* end DrvConfigure() */

/************************************************************************
 *
 * SetResiliencyParams
 *
 * If ->bEncoderResiliency is TRUE, then set the configuration
 * parameters according to the expected packet loss.
 */
extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration)
{
   if (pConfiguration->bEncoderResiliency)
   {
      if(pConfiguration->unPacketLoss > 30)
      {	pConfiguration->bDisallowPosVerMVs = 1;
        pConfiguration->bDisallowAllVerMVs = 1;
        pConfiguration->unPercentForcedUpdate = 100; // rather severe eh Jeeves ?
        pConfiguration->unDefaultIntraQuant = 8;
        pConfiguration->unDefaultInterQuant = 16;
      }
      else if(pConfiguration->unPacketLoss > 0 )
      {	 
		pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = pConfiguration->unPacketLoss;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
	  else // no packet loss
	  {	pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = 0;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
   }

   return;
}

/************************************************************************
 *
 * GetConfigurationDefaults
 *
 * Get the hard-coded configuration defaults
 */
void GetConfigurationDefaults(
	T_CONFIGURATION * pConfiguration)
{
   pConfiguration->bRTPHeader = 0;
   pConfiguration->unPacketSize = 512L;
   pConfiguration->bEncoderResiliency = 0;
   //Moji says to tune the encoder for 10% packet loss.
   pConfiguration->unPacketLoss = 10L;
   pConfiguration->bBitRateState = 0;
   pConfiguration->unBytesPerSecond = 1664L;
   SetResiliencyParams(pConfiguration);  // Determine config values from packet loss.
   pConfiguration->bInitialized = TRUE;

#ifdef H263P
   pConfiguration->bH263PlusState = 0;
   pConfiguration->bImprovedPBState = 0;
   pConfiguration->bDeblockingFilterState = 0;
#endif 

} /* end GetConfigurationDefaults() */

/**************************************************************************
 *
 *  AboutDialogProc
 *
 *  Display the about box.
 */
static INT_PTR CALLBACK AboutDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
#ifndef MF_SHELL
#ifndef RING0
    switch(message) {
      case WM_INITDIALOG:
		return TRUE;
		break;

      case WM_CLOSE:
        PostMessage(hDlg, WM_COMMAND, IDOK, 0L);
        return TRUE;
		
      case WM_COMMAND:
		switch(wParam) {
		  case IDOK:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		
    }
    return FALSE;
#else
   return TRUE;
#endif
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ccpuvsn.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/////////////////////////////////////////////////////////////////////////////////
//  
//   cpuvsn.cpp
//   Description:
// 		This modules contains the functions needed to set the cpu version
// 		variable.  This was based on code found in CONTROLS.C and CPUVSN.ASM
//       in MRV.
// 
// 	Routines:
// 		
//   Data:
//       ProcessorVersionInitialized - if initialized
//       MMxVersion	- true if running on an MMX system
//       P6Version	- true if running on a P6
// 
// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:12:44  $
// $Archive:   S:\h26x\src\common\ccpuvsn.cpv  $
// $Header:   S:\h26x\src\common\ccpuvsn.cpv   1.5   31 Oct 1996 10:12:44   KLILLEVO  $
// $Log:   S:\h26x\src\common\ccpuvsn.cpv  $
// 
//    Rev 1.5   31 Oct 1996 10:12:44   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.4   15 Oct 1996 12:47:40   KLILLEVO
// save ebx
// 
//    Rev 1.3   10 Sep 1996 14:16:44   BNICKERS
// Recognize when running on Pentium Pro processor.
// 
//    Rev 1.2   29 May 1996 14:06:16   RHAZRA
// Enabled CPU sensing via CPUID instruction
// 
//    Rev 1.1   27 Dec 1995 14:11:22   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.0   31 Jul 1995 12:55:14   DBRUCKS
// rename files
// 
//    Rev 1.1   28 Jul 1995 09:26:40   CZHU
// 
// Include typedefs.h instead of datatype.h
/////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern int ProcessorVersionInitialized = {FALSE};
extern int P6Version = {FALSE};
extern int MMxVersion = {FALSE};

#define MMX_IS_ON(edxValue) ((edxValue >> 23)&0x1)  /* bit 23 */

/* Static Functions
 */
static long CPUVersion(U32 uEAX);


/*****************************************************************************
 *
 *  InitializeProcessorVersion
 *
 *  Determine the processor version - setting the global variables
 *
 *  History:	    06/13/95 -BRN-
 *					07/27/95 -DJB- Port to H26X	and turn on MMx detection
 */
void FAR InitializeProcessorVersion (
	int nOn486)
{
	I32 iVersion;

	FX_ENTRY("InitializeProcessorVersion")

	if (ProcessorVersionInitialized) {
		DEBUGMSG (ZONE_INIT, ("%s: ProcessorVersion already initialized\r\n", _fx_));
		goto done;
	}

	if (!nOn486)
	{
    	iVersion = CPUVersion (0);
		iVersion &= 0xffff;  /* Top 16-bits is part of the vendor id string */
    	if (iVersion < 1)
    	{
    		P6Version  = FALSE;
    		MMxVersion = FALSE;
     	} 
     	else 
     	{
     		iVersion = CPUVersion (1);
			P6Version   = (int) ((iVersion & 0xF00L) == 0x600L);
			MMxVersion = (int) MMX_IS_ON(iVersion);
    	}
    }

    ProcessorVersionInitialized = TRUE;

done:
	return;
} /* end InitializeProcessorVersion() */


/*****************************************************************************
 *
 *  SelectProcessor
 *
 *  Control the processor choice from above
 *
 *  Returns 0 if success and 1 if failure
 *
 *  History:	    06/13/95 -BRN-
 *					07/27/95 -DJB- Port to H26X
 */
DWORD SelectProcessor (DWORD dwTarget)
{
  if (! ProcessorVersionInitialized)
  {
    ProcessorVersionInitialized = TRUE;
    if (dwTarget == TARGET_PROCESSOR_PENTIUM)
    {
      P6Version  = FALSE;
      MMxVersion = FALSE;
    }
    else if (dwTarget == TARGET_PROCESSOR_P6)
    {
      P6Version  = TRUE;
      MMxVersion = FALSE;
    }
    else if (dwTarget == TARGET_PROCESSOR_PENTIUM_MMX)
    {
      P6Version  = FALSE;
      MMxVersion = TRUE;
    }
    else if (dwTarget == TARGET_PROCESSOR_P6_MMX)
    {
      P6Version  = TRUE;
      MMxVersion = TRUE;
    }
    return 0;
  }
  return 1;
} /* end SelectProcessor() */


/*****************************************************************************
 *
 *  CPUVersion
 *
 *  Accesss the CPUID information
 *
 *  Returns: Upper 16-bits of EDX and Lower 16-bits of EAX
 * 		
 *
 *  History:	    06/15/95 -BRN-
 *					07/27/95 -DJB- Port from MRV's CPUVSN.ASM to H26X
 */
static long CPUVersion(U32 uEAX) 
{
	long lResult;

	__asm {
		push  ebx
#ifdef WIN32
		mov   eax,uEAX
#else
		movzx eax,sp
		movzx eax,ss:PW [eax+4]
#endif
		xor  ebx,ebx
		xor   ecx,ecx
		xor  edx,edx
		_emit 00FH         ; CPUID instruction
		_emit 0A2H

		and   edx,0FFFF0000H
		and   eax,00000FFFFH
		or    eax,edx
		mov	  lResult,eax
		pop   ebx
	}

	return lResult;
} /* end CPUVersion() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvdefs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:24  $
// $Archive:   S:\h26x\src\common\cdrvdefs.h_v  $
// $Header:   S:\h26x\src\common\cdrvdefs.h_v   1.39   05 Feb 1997 12:14:24   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvdefs.h_v  $
;// 
;//    Rev 1.39   05 Feb 1997 12:14:24   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.38   14 Jan 1997 11:17:14   JMCVEIGH
;// Put flag for old still-frame mode backward compatibility under
;// #ifdef H263P
;// 
;//    Rev 1.37   06 Jan 1997 17:38:08   JMCVEIGH
;// Added flag in LPDECINST to ensure backward compatibility with
;// old still-frame mode (crop CIF image to 320x240).
;// 
;//    Rev 1.36   16 Dec 1996 17:37:00   JMCVEIGH
;// Added H263Plus state and changed name for true B-frame mode.
;// 
;//    Rev 1.35   16 Dec 1996 13:40:46   MDUDA
;// Added compression and bit width fields to compress info.
;// 
;//    Rev 1.34   11 Dec 1996 14:56:46   JMCVEIGH
;// 
;// Added H.263+ options to frame header structure and flags in
;// configuration structure.
;// 
;//    Rev 1.33   09 Dec 1996 17:43:10   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.32   09 Dec 1996 09:24:42   MDUDA
;// 
;// Re-arranged for H263P.
;// 
;//    Rev 1.31   10 Sep 1996 16:13:06   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.30   10 Sep 1996 10:32:10   KLILLEVO
;// changed GlobalAlloc/GlobalLock to HeapAlloc
;// 
;//    Rev 1.29   06 Sep 1996 15:00:20   MBODART
;// Added performance counters for NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h and cxprf.cpp.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.28   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.27   19 Jun 1996 14:37:26   RHAZRA
;// added #define FOURCC_YUY2
;// 
;//    Rev 1.26   06 May 1996 12:56:34   BECHOLS
;// changed unbitspersecond to unBytesPerSecond.
;// 
;//    Rev 1.25   06 May 1996 00:42:36   BECHOLS
;// 
;// Added support for the bit rate control in the configure dialog.
;// 
;//    Rev 1.24   26 Apr 1996 11:09:18   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.23   02 Feb 1996 18:52:52   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.22   19 Jan 1996 15:32:50   TRGARDOS
;// Added TRPrev field to PictureHeader structure.
;// 
;//    Rev 1.21   11 Jan 1996 16:52:24   DBRUCKS
;// added variables to store the aspect ratio correction boolean
;// 
;//    Rev 1.20   04 Jan 1996 18:07:54   TRGARDOS
;// Added boolean for 320x240 input into COMPINSTINFO.
;// 
;//    Rev 1.19   27 Dec 1995 14:11:54   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:22:56   DBRUCKS
// 
// Added blazer data rate, frame rate, and quality variables to 
// COMPINSTINFO inside an H261 ifdef
// 
//    Rev 1.17   30 Oct 1995 12:02:12   TRGARDOS
// Modified compressor instance structure to add
// 240x180 support.
// 
//    Rev 1.16   27 Sep 1995 19:09:30   TRGARDOS
// Changed enumeration name for picture code type.
// 
//    Rev 1.15   20 Sep 1995 12:37:40   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.14   19 Sep 1995 15:41:28   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.13   18 Sep 1995 08:42:46   CZHU
// 
// Define FOURCC for YUV12
// 
//    Rev 1.12   13 Sep 1995 17:08:26   TRGARDOS
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.11   12 Sep 1995 17:01:38   DBRUCKS
// add twocc
// 
//    Rev 1.10   11 Sep 1995 11:14:48   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.9   29 Aug 1995 17:18:48   TRGARDOS
// Padded H263HeaderStruct
// 
//    Rev 1.8   28 Aug 1995 17:45:04   DBRUCKS
// add size defines
// 
//    Rev 1.7   28 Aug 1995 11:45:52   TRGARDOS
// 
// Updated frame size bit field in PTYPE.
// 
//    Rev 1.6   25 Aug 1995 10:37:12   CZHU
// Changed PITCH from const int to #define, because of compiler bug for inline
// 
//    Rev 1.5   25 Aug 1995 09:02:32   TRGARDOS
// 
// Modified picture header structure.
// 
//    Rev 1.4   14 Aug 1995 11:34:52   TRGARDOS
// Finished writing picture frame header.
// 
//    Rev 1.3   11 Aug 1995 17:27:56   TRGARDOS
// Added bitstream writing and defined bitstream fields.
// 
//    Rev 1.2   07 Aug 1995 16:25:28   TRGARDOS
// 
// Moved PITCH definition here from c3dec.h.
// 
//    Rev 1.1   03 Aug 1995 10:38:40   TRGARDOS
// 
// Put picture header structure definition and GOB header 
// definition in here.
// 
//    Rev 1.0   31 Jul 1995 12:56:14   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:32   CZHU
// Initial revision.
;// 
;// Added encoder controls message support.
;// Modified RTP dialog box.
;// Change to PercentForcedUpdate
;// add T_CONFIGURATION
;// Integrate with build 29
;// 
////////////////////////////////////////////////////////////////////////////
#ifndef DRV_DEFS_H
#define DRV_DEFS_H

#ifndef WIN32

/*
 * Define standard data types.
 */
typedef BYTE __huge* HPBYTE;
typedef WORD __huge* HPWORD;
typedef BYTE __far*  LPBYTE;
typedef WORD __far*  LPWORD;
typedef int  __far*  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned int  U16;
#endif
#ifndef I16
typedef signed int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT short int        /* signed 16 bit */
#endif
#else //WIN32
typedef BYTE        * HPBYTE;
typedef WORD        * HPWORD;
typedef BYTE        *  LPBYTE;
typedef WORD        *  LPWORD;
typedef short int   *  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned short int  U16;
#endif
#ifndef I16
typedef signed short int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT int        /* signed 16 bit */
#endif
#endif //WIN32

/*
 * Define custom DRVPROC messages for playback.
 */
#define PLAYBACK_CUSTOM_START            (ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_END            (PLAYBACK_CUSTOM_START + 9)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST        (PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION    (PLAYBACK_CUSTOM_START + 2)
#define PLAYBACK_CUSTOM_RESET_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 3)
#define PLAYBACK_CUSTOM_RESET_SATURATION    (PLAYBACK_CUSTOM_START + 4)
#define PLAYBACK_CUSTOM_CHANGE_TINT        (PLAYBACK_CUSTOM_START + 5)
#define PLAYBACK_CUSTOM_RESET_TINT        (PLAYBACK_CUSTOM_START + 6)
#define PLAYBACK_CUSTOM_COLOR_CONVERT        (PLAYBACK_CUSTOM_START + 7)

typedef struct { char name[5]; HANDLE h; U16 FAR *log; U16 err; } TimeLog;

/*
 * Define various constants.
 */
#define TOTAL 0
#define OVERHEAD 1
#define HUFF 2
#define YSLANT 3
#define VSLANT 4
#define USLANT 5
#define YDIFF 6
#define VDIFF 7
#define UDIFF 8
#define TORQUE 9
#define FILTER 10
#define CSC 11

#ifdef H263P
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5, CUSTOM=6, EPTYPE=7};
#else
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};
#endif

#define MAX_WIDTH 	352	   // CIF
#define MAX_HEIGHT	288	   // CIF
#define PITCH 		(MAX_WIDTH+32)

//** Decompressor Instance information
typedef struct {
    BOOL    Initialized;
	BOOL	bProposedCorrectAspectRatio;	// proposed
	BOOL    bCorrectAspectRatio;	// whether to correct the aspect ratio
#ifdef H263P
	BOOL    bCIFto320x240;          // whether to crop CIF frames to 320x240 (old still-frame mode)
#endif
    WORD    xres, yres;             // size of image within movie
	FrameSize FrameSz;		// Which of the supported frame sizes.
    int     pXScale, pYScale;       // proposed scaling (Query)
    int     XScale, YScale;         // current scaling (Begin)  
    UINT    uColorConvertor;        // Current Color Convertor
    WORD    outputDepth;            // and bit depth
    LPVOID  pDecoderInst;
    BOOL 				UseActivePalette;	/* decompress to active palette == 1 */
	BOOL				InitActivePalette;	/* active palette initialized == 1 */
	BOOL				bUseBlockEdgeFilter;/* switch for block edge filter */
	RGBQUAD     		ActivePalette[256];	/* stored active palette */
} DECINSTINFO, FAR *LPDECINST;

//** Configuration Information
typedef struct {
   BOOL    	bInitialized;               // Whether custom msgs can be rcv'd.
   BOOL		bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
   BOOL    	bRTPHeader;                 // Whether to generate RTP header info
   /* used if bRTPHeader */
   UINT     unPacketSize;               // Maximum packet size
   BOOL     bEncoderResiliency;         // Whether to use resiliency restrictions
   /* used if bEncoderResiliency */
   UINT    	unPacketLoss;
   BOOL		bBitRateState;
   /* used if bBitRateState */
   UINT		unBytesPerSecond;
   /* The following information is determined from the packet loss value.   */
   /*  These values are calculated each time we receive a resiliency msg or */
   /*  the value is changed through the dialog box.  They are not stored in */
   /*  the registry.  Only the above elements are stored in the registry.   */
	BOOL    bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL    bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT    unDefaultIntraQuant;        // Default Intra Quant
	UINT    unDefaultInterQuant;        // Default Inter Quant

#ifdef H263P
	BOOL    bH263PlusState;				// Whether to use H.263+
	BOOL    bImprovedPBState;			// Whether to use improved PB-frames
	BOOL    bDeblockingFilterState;		// Whether to use in-the-loop deblocking filter
#endif
} T_CONFIGURATION;

//** Compressor Instance information
typedef struct{
    BOOL    Initialized;
    WORD    xres, yres;
	FrameSize FrameSz;		// Which of the supported frame sizes.
	float	FrameRate;
	U32		DataRate;		// Data rate in bytes per second.
    HGLOBAL hEncoderInst;   // Instance data private to encoder.
    LPVOID  EncoderInst;
    WORD    CompressedSize;
	BOOL	Is160x120;
	BOOL 	Is240x180;
	BOOL	Is320x240;
#if defined(H263P)
	U32		InputCompression;
	U32		InputBitWidth;
#endif
	T_CONFIGURATION Configuration;
#ifdef USE_BILINEAR_MSH26X
	U32		InputCompression;
	U32		InputBitWidth;
#endif

} COMPINSTINFO, FAR *LPCODINST;

//**
//** Instance information
//**
typedef struct tagINSTINFO {
    DWORD   dwFlags;
	DWORD	fccHandler;		// So we know what codec has been opened.
	BOOL	enabled;
    LPCODINST CompPtr;          // ICM
    LPDECINST DecompPtr;        // ICM
} INSTINFO, FAR *LPINST;

//**  local name definitions ***
#ifdef H261
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','1')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','1')

#else /* is H263 */
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','3')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','3')
#ifdef USE_BILINEAR_MSH26X
#define FOURCC_H26X mmioFOURCC('M','2','6','X')
#endif
#endif /* else is H263 */

#define FOURCC_YUV12 mmioFOURCC('I','4','2','0')
#define FOURCC_IYUV  mmioFOURCC('I','Y','U','V')
#define FOURCC_YVU9  mmioFOURCC('Y','V','U','9')
#define FOURCC_IF09  mmioFOURCC('I','F','0','9')
#define FOURCC_YUY2  mmioFOURCC('Y','U','Y','2')
#define FOURCC_UYVY  mmioFOURCC('U','Y','V','Y')
#define TWOCC_H26X aviTWOCC('i','v');

#define MOD4(a)     ((a/4)*4)

typedef struct {
    unsigned short PictureStartCodeZeros:16;
    unsigned short PictureStartCode:6;
    unsigned short TR:8;
    unsigned short Const:2;
    unsigned short Split:1;
    unsigned short DocCamera:1;
    unsigned short PicFreeze:1;
    unsigned short SrcFormat:3;
    unsigned short Inter:1;
    unsigned short UMV:1;
    unsigned short SAC:1;
    unsigned short AP:1;
    unsigned short PB:1;
	unsigned short CPM:1;
} T_H263FrameHeader;

enum EnumPicCodType	{INTRAPIC=0, INTERPIC=1};
enum EnumOnOff	{OFF=0, ON=1};

/*
 * If the size of T_H263FrameHeaderStruct is changed, then
 * that change must be updated in T_H263EncoderCatalog in e3enc.h
 */
typedef struct {
    U32	PictureStartCodeZeros;	// 0..3
    U8 	TR;						// 4
   	// PTYPE;
	U8	Const;					// 5 -- two bit constant: 10
    U8	SrcFormat;				// 6 -- source format
	U8	Unassigned1;			// 7
 	EnumOnOff	Split;			// 8..11 -- split screen indicator
    EnumOnOff	DocCamera;		// 12..15 -- document camera indicator
    EnumOnOff	PicFreeze;		// 16..19 -- freeze picture release
    EnumPicCodType	PicCodType;	// 20 -- picture coding type
    EnumOnOff	UMV;			// 24 -- optional unrestricted motion vector mode
    EnumOnOff	SAC;			// 28 -- optional syntax-based arithmetic coding mode
    EnumOnOff	AP;				// 32 -- optional advanced prediction mode
    EnumOnOff	PB;				// 36 -- optional PB frames mode
	//
	U8	PQUANT;			// 40
	U8	CPM;			// 41
	U8	PLCI;			// 42
	U8	TRB;			// 43
	U8	DBQUANT;		// 44
	U8	PEI;			// 45
	U8	PSPARE;			// 46
	U8	TRPrev;			// 47	Temporal Reference of Previous frame

#ifdef H263P
	// H.263+ encoding options, document LBC-96-358
	EnumOnOff   CustomPCF;			// 48 Custom PCF
	EnumOnOff   AdvancedIntra;		// 52 Advanced intra coding (Annex I)
	EnumOnOff   DeblockingFilter;	// 56 In-the-loop deblocking filter (Annex J)
	EnumOnOff   SliceStructured;	// 60 Slice-structured (Annex K)
	EnumOnOff   ImprovedPB;         // 64 Improved PB-frame mode (Annex M)
	EnumOnOff   BackChannel;		// 68 Back-channel operation (Annex N)
	EnumOnOff   Scalability;		// 72 SNR and spatial scalability (Annex O)
	EnumOnOff   TrueBFrame;			// 76 True B-frame mode (Annex O)
	EnumOnOff   RefPicResampling;	// 80 Reference-picture resampling (Annex P)
	EnumOnOff   RedResUpdate;		// 84 Reduced-resolution update (Annex Q)
#endif

} T_H263FrameHeaderStruct;

#ifdef H263P
const int sizeof_T_H263FrameHeaderStruct = 88;
#else
const int sizeof_T_H263FrameHeaderStruct = 48;
#endif

typedef struct {
    unsigned short StartCodeZeros:16;
    unsigned short StartCode:1;
    unsigned short GN:5;
    unsigned short GLCI:2;
    unsigned short GFID:2;
	unsigned short GQUANT:5;
} T_H263GOBHeader;

#endif /* multi inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cldebug.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cldebug.cpp
 *
 *  Description:
 *		This modules contains the debug support routines
 *
 *	Routines:
 *		AssertFailed
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\common\cldebug.cpv   1.2   27 Dec 1995 14:11:42   RMCKENZX  $
 * $Log:   S:\h26x\src\common\cldebug.cpv  $
// 
//    Rev 1.2   27 Dec 1995 14:11:42   RMCKENZX
// 
// Added copyright notice
 */

#include "precomp.h"

#ifdef _DEBUG


// CurtSm hack ... don't spew all the time
UINT DebugH26x = 0;


/*****************************************************************************
 *
 *  AssertFailed
 *
 *  Print out a message indicating that the assertion failed.  If in Ring3
 *  give the user the option of aborting.  Otherwise just output the message.
 */
extern void 
AssertFailed(
	void FAR * fpFileName, 
	int iLine, 
	void FAR * fpExp)
{
#ifndef RING0
	char szBuf[500];
	int n;

	wsprintf(szBuf,"Assertion (%s) failed in file '%s' at line %d - Abort?",
	    	 fpExp, fpFileName, iLine);
	DBOUT(szBuf);
	n = MessageBox(GetFocus(), szBuf, "Assertion Failure", 
				   MB_ICONSTOP | MB_YESNO | MB_SETFOREGROUND);
	if (n == IDYES) 
		abort();
#else
	SYS_printf("Assertion (%s) failed in file '%s' at line %d",
	    	   fpExp, fpFileName, iLine);
   _asm int 3;
#endif
} /* end AssertFailed() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cldebug.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:58  $
// $Archive:   S:\h26x\src\common\cldebug.h_v  $
// $Header:   S:\h26x\src\common\cldebug.h_v   1.6   27 Dec 1995 14:11:58   RMCKENZX  $
// $Log:   S:\h26x\src\common\cldebug.h_v  $
;// 
;//    Rev 1.6   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.5   17 Nov 1995 15:13:02   BECHOLS
// 
// Made modifications for ring 0.
// 
//    Rev 1.4   16 Nov 1995 17:34:08   AGANTZX
// Added TOUT macro to output timing data
// 
//    Rev 1.3   12 Sep 1995 15:44:50   DBRUCKS
// add H261 ifdef for debug statements
// 
//    Rev 1.2   03 Aug 1995 14:57:02   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.1   01 Aug 1995 12:24:40   DBRUCKS
// added TBD()
// 
//    Rev 1.0   31 Jul 1995 12:56:16   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:44:04   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:48   CZHU
// Initial revision.

/*
 * Copyright (C) 1992, 1993 Intel Corporation.
 */
extern UINT DebugH26x;
extern void AssertFailed(void FAR * fpFileName, int iLine, void FAR * fpExp);

#ifndef __CLDEBUG_H__
#define __CLDEBUG_H__

  #ifdef _DEBUG
    #ifdef RING0
      #define DBOUT(x) {SYS_printf(x);}
      #define TOUT(x) {SYS_printf(x);}
    #else
      #ifdef H261
        #define DBOUT(x)  { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M261 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #else
         #define DBOUT(x) { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M263 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #endif
      #define TOUT(x)  { if (DebugH26x) { \
                          OutputDebugString((LPSTR)"TIMING : "); \
                          OutputDebugString((LPSTR)x);          \
                          OutputDebugString((LPSTR)"\n"); }}
    #endif //RING0
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { if(!(x)) AssertFailed(__FILE__,__LINE__,#x); }
  #else
    #define TOUT(x) { } //  /##/
    #define DBOUT(x) { } //  /##/
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { } //  /##/ 
  #endif
 
  #define TBD(s) DBOUT(s)

#ifdef _DEBUG // { _DEBUG

int WINAPI H263DbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneH263;

#define ZONE_INIT (GETMASK(ghDbgZoneH263) & 0x0001)
#define ZONE_ICM_MESSAGES (GETMASK(ghDbgZoneH263) & 0x0002)
#define ZONE_DECODE_MB_HEADER (GETMASK(ghDbgZoneH263) & 0x0004)
#define ZONE_DECODE_GOB_HEADER (GETMASK(ghDbgZoneH263) & 0x0008)
#define ZONE_DECODE_PICTURE_HEADER (GETMASK(ghDbgZoneH263) & 0x0010)
#define ZONE_DECODE_COMPUTE_MOTION_VECTORS (GETMASK(ghDbgZoneH263) & 0x0020)
#define ZONE_DECODE_RTP (GETMASK(ghDbgZoneH263) & 0x0040)
#define ZONE_DECODE_DETAILS (GETMASK(ghDbgZoneH263) & 0x0080)
#define ZONE_BITRATE_CONTROL (GETMASK(ghDbgZoneH263) & 0x0100)
#define ZONE_BITRATE_CONTROL_DETAILS (GETMASK(ghDbgZoneH263) & 0x0200)
#define ZONE_ENCODE_MB (GETMASK(ghDbgZoneH263) & 0x0400)
#define ZONE_ENCODE_GOB (GETMASK(ghDbgZoneH263) & 0x0800)
#define ZONE_ENCODE_MV (GETMASK(ghDbgZoneH263) & 0x1000)
#define ZONE_ENCODE_RTP (GETMASK(ghDbgZoneH263) & 0x2000)
#define ZONE_ENCODE_DETAILS (GETMASK(ghDbgZoneH263) & 0x4000)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (H263DbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (H263DbgPrintf m)
#else // }{ _DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } _DEBUG

#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvproc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  This module is based on drvmain.c, Rev 1.24, 28 Apr 1995, from the
//  MRV video codec driver.
//
// $Author:   JMCVEIGH  $
// $Date:   17 Apr 1997 17:04:04  $
// $Archive:   S:\h26x\src\common\cdrvproc.cpv  $
// $Header:   S:\h26x\src\common\cdrvproc.cpv   1.39   17 Apr 1997 17:04:04   JMCVEIGH  $
// 
////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <oprahcom.h>

//  #define TIMING       1
                        //  Timing process  - for decode turn on in
                        //  CDRVPROC.CPP and D1DEC.CPP
#if TIMING
char            szTMsg[80];
unsigned long   tmr_time = 0L;
unsigned long   tmr_frms = 0L;
#endif

HINSTANCE hDriverModule; // the instance-handle of this driver set in LibMain

#if defined(H263P)
extern BOOL MMX_Enabled;
BOOL MMXDecoder_Enabled;
#define _PENTIUM_PROCESSOR           1
#define _PENTIUM_PRO_PROCESSOR       2
#define _PENTIUM_MMX_PROCESSOR       3
#define _PENTIUM_PRO_MMX_PROCESSOR   4
#endif

/* load free handshake */
static int Loaded = 0;    /* 0 prior to first DRV_LOAD and after DRV_FREE */

#ifdef DEBUG
HDBGZONE  ghDbgZoneH263 = NULL;
static PTCHAR _rgZonesH263[] = {
	TEXT("M263"),
	TEXT("Init"),
	TEXT("ICM Messages"),
	TEXT("Decode MB Header"),
	TEXT("Decode GOB Header"),
	TEXT("Decode Picture Header"),
	TEXT("Decode Motion Vectors"),
	TEXT("Decode RTP Info Stream"),
	TEXT("Decode Details"),
	TEXT("Bitrate Control"),
	TEXT("Bitrate Control Details"),
	TEXT("Encode MB"),
	TEXT("Encode GOB"),
	TEXT("Encode Motion Vectors"),
	TEXT("Encode RTP Info Stream"),
	TEXT("Encode Details")
};

int WINAPI H263DbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("M263", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

#if (defined(H261) || defined(H263))
/* Suppress FP thunking for now, for H261 and H263.
   Thunking currently has the side effect of masking floating point exceptions,
   which can cause exceptions like divide by zero to go undetected.
 */
#define FPThunking 0
#else
#define FPThunking 1
#endif

#if FPThunking
////////////////////////////////////////////////////////////////////////////
// These two routines are necessary to permit a 16 bit application call   //
// a 32 bit codec under Windows /95.  The Windows /95 thunk doesn't save  //
// or restore the Floating Point State. -Ben- 07/12/96                    //
//                                                                        //
U16 ThnkFPSetup(void)													  //
{																		  //
	U16	wOldFPState;													  //
	U16	wNewFPState = 0x027f;											  //
																		  //
	__asm																  //
	{																	  //
		fnstcw	WORD PTR [wOldFPState]									  //
		fldcw	WORD PTR [wNewFPState]									  //
	}																	  //
																		  //
	return(wOldFPState);												  //
}																		  //
																		  //
void ThnkFPRestore(U16 wFPState)										  //
{																		  //
	// Prevent any pending floating point exceptions from reoccuring.	  //
	_clearfp();												  			  //
	 																	  //
	__asm																  //
	{																	  //
		fldcw	WORD PTR [wFPState]										  //
	}																	  //
																		  //
	return;																  //
}																		  //
////////////////////////////////////////////////////////////////////////////
#endif /* FPThunking */

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT WINAPI _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
;//
;// Description:    Added Header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI DriverProc(
				DWORD dwDriverID,
				HDRVR hDriver,
				UINT uiMessage,
				LPARAM lParam1,
				LPARAM lParam2
			)
{
    SYSTEM_INFO sysinfo;

    LRESULT rval = 0;
    LPINST  pi;

    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };
	int nOn486;

	FX_ENTRY("DriverProc");

#if FPThunking
	U16	u16FPState = ThnkFPSetup();
#endif

	try
	{

    pi = (LPINST)dwDriverID;

    switch(uiMessage)
        {
        case DRV_LOAD:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_LOAD\r\n", _fx_));
            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return 0L to fail the load.

            */

            // put global initialization here...

            if(Loaded) {
                /* We used to return an undefined value here.  It's unclear
                 * whether this load should succeed, and if so, how or if
                 * we need to modify our memory usage to be truly reentrant.
                 * For now, let's explicitly fail this load attempt.
                 */
                rval = 0;
                break;
            }
            Loaded = 1;

#ifdef USE_MMX // { USE_MMX
	        GetSystemInfo(&sysinfo);
			nOn486 = (sysinfo.dwProcessorType == PROCESSOR_INTEL_486);
#endif // } USE_MMX

            if(!DrvLoad())
            {
                rval = 0;
                Loaded = 0;
                break;
            }

#ifdef USE_MMX // { USE_MMX
			InitializeProcessorVersion(nOn486);
#endif // } USE_MMX

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
			// Create performance counters
			InitCounters();
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

            rval = (LRESULT)TRUE;
            break;

        case DRV_FREE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_FREE\r\n", _fx_));
            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed. 

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return value is ignored.
            */

            // put global de-initialization here...

            if(!Loaded)
                break;
            
            Loaded = 0;
            DrvFree();

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
			// We're done with performance counters
			DoneCounters();
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

            rval = (LRESULT)TRUE;
            break;

        /*********************************************************************
         *     standard driver messages
         *********************************************************************/
        case DRV_DISABLE:
        case DRV_ENABLE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_ENABLE / DRV_DISABLE\r\n", _fx_));
            rval = (LRESULT)1L;
            break;
        
        case DRV_INSTALL:
        case DRV_REMOVE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_INSTALL / DRV_REMOVE\r\n", _fx_));
            rval = (LRESULT)DRV_OK;
            break;


        case DRV_OPEN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_OPEN\r\n", _fx_));

             /*
               Sent to the driver when it is opened. 

               dwDriverID is 0L.
               
               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.
               
               lParam2 is passed through from the drvOpen call. It is
               NULL if this open is from the Drivers Applet in control.exe
               It is a far pointer to an ICOPEN data structure otherwise.
                
               Return 0L to fail the open. Otherwise return a value that the
			   system will use for dwDriverID in subsequent messages. In our
			   case, we return a pointer to our INSTINFO data structure.
             */

           	if (lParam2 == 0)
            {    /* indicate we do process DRV_OPEN */
                rval = 0xFFFF0000;
                break;
            }

            /* if asked to draw, fail */
            if (((ICOPEN FAR *)lParam2)->dwFlags & ICMODE_DRAW)
            {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   DrvOpen wants ICMODE_DRAW\r\n", _fx_));
                rval = 0L;
                break;
            }

            if((pi = DrvOpen((ICOPEN FAR *) lParam2)) == NULL)
            {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   DrvOpen failed ICERR_MEMORY\r\n", _fx_));
				// We must return NULL on failure. We used to return
				// ICERR_MEMORY = -3, which implies a driver was opened
				rval = (LRESULT)0L;
                break;
            }
			rval = (LRESULT)pi;
            break;

        case DRV_CLOSE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_CLOSE\r\n", _fx_));

            if(pi != (tagINSTINFO*)0 && pi != (tagINSTINFO*)0xFFFF0000)
                DrvClose(pi);

            rval = (LRESULT)1L;
            break;

    //**************************
    //    state messages
    //**************************
        case DRV_QUERYCONFIGURE:// configuration from drivers applet
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_QUERYCONFIGURE\r\n", _fx_));
	    	// this is a GLOBAL query configure
            rval = (LRESULT)0L;
            break;
       
        case DRV_CONFIGURE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_CONFIGURE\r\n", _fx_));
			rval = DrvConfigure((HWND)lParam1);
			break;

        case ICM_CONFIGURE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_CONFIGURE\r\n", _fx_));
			//#ifndef H261
			   // This message is used to add extensions to the encode dialog box.
				// rval = Configure((HWND)lParam1);
		//	#else
			  	rval = ICERR_UNSUPPORTED;
		//	#endif
            break;
        
        case ICM_ABOUT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_ABOUT\r\n", _fx_));
			rval = About((HWND)lParam1);
			break;

        case ICM_GETSTATE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETSTATE\r\n", _fx_));
			rval = DrvGetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_SETSTATE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_SETSTATE\r\n", _fx_));
			rval = DrvSetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_GETINFO:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETINFO\r\n", _fx_));
            rval = DrvGetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);
            break;

    //***************************
    //  compression messages
    //***************************
        case ICM_COMPRESS_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_QUERY\r\n", _fx_));
#ifdef ENCODER_DISABLED
// This disables the encoder, as the debug message states.
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   ENCODER DISABLED\r\n", _fx_));
            rval = ICERR_UNSUPPORTED;
#else
#ifdef USE_BILINEAR_MSH26X
            if (pi && pi->enabled && ((pi->fccHandler == FOURCC_H263) || (pi->fccHandler == FOURCC_H26X)))
              	rval = CompressQuery(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
            if(pi && pi->enabled && (pi->fccHandler == FOURCC_H263))
              	rval = CompressQuery(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
#endif
            break;

		/*
		 * ICM Compress Frames Info Structure
		 */

		 case ICM_COMPRESS_FRAMES_INFO:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_FRAMES_INFO\r\n", _fx_));
			if (pi)
				rval = CompressFramesInfo((LPCODINST) pi->CompPtr, (ICCOMPRESSFRAMES *) lParam1, (int) lParam2);
			else
			  	rval = ICERR_UNSUPPORTED;
			break;

		/*
		 * ICM messages in support of quality.
		 */
		case ICM_GETDEFAULTQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETDEFAULTQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_GETQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_SETQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_SETQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

        case ICM_COMPRESS_BEGIN:
		    /*
			 * Notify driver to prepare to compress data by allocating and 
			 * initializing any memory it needs for compressing. Note that
			 * ICM_COMPRESS_BEGIN and ICM_COMPRESS_END do not nest.
			 *
			 * Should return ICERR_OK if the specified compression is supported
			 * or ICERR_BADFORMAT if the input or output format is not supported.
			 */
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_BEGIN\r\n", _fx_));
			if (pi && pi->enabled)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressBegin(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressBegin(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_FORMAT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_GET_FORMAT\r\n", _fx_));
			if (pi)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressGetFormat(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressGetFormat(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_SIZE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_GET_SIZE\r\n", _fx_));
			if (pi && lParam1)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressGetSize(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressGetSize(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS:
			/*
			 * Returns ICERR_OK if successful or an error code otherwise.
			 */
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS\r\n", _fx_));
			if (pi && pi->enabled)
				rval = Compress(
#ifdef USE_BILINEAR_MSH26X
            			pi,
#else
            			pi->CompPtr,				// ptr to Compressor instance information.
#endif
            			(ICCOMPRESS FAR *)lParam1,	// ptr to ICCOMPRESS structure.
            			(DWORD)lParam2				// size in bytes of the ICCOMPRESS structure.
            		   );
	        else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_END:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_END\r\n", _fx_));
			if (pi && pi->enabled)
				rval = CompressEnd(pi->CompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress messages
    //***************************
        case ICM_DECOMPRESS_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_QUERY\r\n", _fx_));
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_BEGIN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_BEGIN\r\n", _fx_));
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_FORMAT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_GET_FORMAT\r\n", _fx_));
			if (pi)
#ifdef USE_BILINEAR_MSH26X
				rval = DecompressGetFormat(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
#else
				rval = DecompressGetFormat(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
#endif
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_PALETTE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_GET_PALETTE\r\n", _fx_));
			if (pi)
				rval = DecompressGetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;
  	   case ICM_DECOMPRESS_SET_PALETTE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_SET_PALETTE : not supported\r\n", _fx_));
	        rval = ICERR_UNSUPPORTED;
	 //       rval = DecompressSetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
	        break;
 
        case ICM_DECOMPRESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS\r\n", _fx_));
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
			{
				ICDecExSt = DefaultICDecExSt;
				ICDecExSt.dwFlags = ((ICDECOMPRESS FAR *)lParam1)->dwFlags;
				ICDecExSt.lpbiSrc = ((ICDECOMPRESS FAR *)lParam1)->lpbiInput;
				ICDecExSt.lpSrc = ((ICDECOMPRESS FAR *)lParam1)->lpInput;
				ICDecExSt.lpbiDst = ((ICDECOMPRESS FAR *)lParam1)->lpbiOutput;
				ICDecExSt.lpDst = ((ICDECOMPRESS FAR *)lParam1)->lpOutput;
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, (DWORD)lParam2, FALSE);
#if TIMING              // Output Timing Results in VC++ 2.0 Debug Window
				wsprintf(szTMsg, "Total Decode Time = %ld ms", tmr_time);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Total Frames = %ld", tmr_frms);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Average Frame Decode = %ld.%ld ms",
						 tmr_time / tmr_frms,
						 ((tmr_time % tmr_frms) * 1000) / tmr_frms);
				TOUT(szTMsg);
#endif
			}
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_END:
        case ICM_DECOMPRESSEX_END:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_END / ICM_DECOMPRESSEX_END\r\n", _fx_));
			if (pi)
				rval = DecompressEnd(pi->DecompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress X messages
    //***************************
        case ICM_DECOMPRESSEX:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX\r\n", _fx_));
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12)|| (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, (DWORD)lParam2, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_BEGIN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX_BEGIN\r\n", _fx_));
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX_QUERY\r\n", _fx_));
#ifdef TURN_OFF_DECOMPRESSEX
				rval = ICERR_UNSUPPORTED;
#else
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
#endif
            break;

    
    // *********************************************************************
    // custom driver messages for bright/cont/sat
    // *********************************************************************

        case CODEC_CUSTOM_VIDEO_EFFECTS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_VIDEO_EFFECTS\r\n", _fx_));
            if(LOWORD(lParam1) == VE_HUE) {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_HUE : Unsupported\r\n", _fx_));
                rval = ICERR_UNSUPPORTED;
                break;
            }
            switch(HIWORD(lParam1))
                {
                case    VE_GET_FACTORY_DEFAULT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_GET_FACTORY_DEFAULT\r\n", _fx_));
                    *((WORD FAR *)lParam2) = 128;
                    rval = ICERR_OK;
                    break;
                case    VE_GET_FACTORY_LIMITS:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_GET_FACTORY_LIMITS\r\n", _fx_));
                    *((DWORD FAR *)lParam2) = 0x00FF0000;
                    rval = ICERR_OK;
                    break;
                case    VE_SET_CURRENT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_SET_CURRENT\r\n", _fx_));
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_BRIGHTNESS\r\n", _fx_));
                        rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_SATURATION\r\n", _fx_));
                        rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_CONTRAST\r\n", _fx_));
                        rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    break;
                case    VE_RESET_CURRENT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_RESET_CURRENT\r\n", _fx_));
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_BRIGHTNESS\r\n", _fx_));
                        rval = CustomResetBrightness(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_CONTRAST\r\n", _fx_));
                        rval = CustomResetContrast(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_SATURATION\r\n", _fx_));
                        rval = CustomResetSaturation(pi->DecompPtr);
					}
                    break;
                default:
                    rval = ICERR_UNSUPPORTED;
                    break;
                }
            break;

         case CODEC_CUSTOM_ENCODER_CONTROL:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_ENCODER_CONTROL\r\n", _fx_));
            switch(HIWORD(lParam1))
            {

               case EC_GET_FACTORY_DEFAULT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_FACTORY_DEFAULT\r\n", _fx_));
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_RESILIENCY:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_BITRATE_CONTROL:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 512L;    
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 10L;
                        break;
                     case EC_BITRATE:
                        *((DWORD FAR *)lParam2) = 1664L;
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_RESET_TO_FACTORY_DEFAULTS:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_RESET_TO_FACTORY_DEFAULTS\r\n", _fx_));
                  rval = CustomResetToFactoryDefaults(pi->CompPtr);
                  break;
               case EC_GET_FACTORY_LIMITS:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_FACTORY_LIMITS\r\n", _fx_));
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 0x05DC0100;
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 0x00640000;
                        break;
                     case EC_BITRATE:						  /* Bit rate limits are returned as */
                        *((DWORD FAR *)lParam2) = 0x34000400; /* the number of bytes per second  */
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_GET_CURRENT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_CURRENT\r\n", _fx_));
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        rval = CustomGetRTPHeaderState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_RESILIENCY:
                        rval = CustomGetResiliencyState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
                        rval = CustomGetBitRateState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_SIZE:
                        rval = CustomGetPacketSize(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_LOSS:
                        rval = CustomGetPacketLoss(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is returned in bits per second */
                        rval = CustomGetBitRate(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomGetH263PlusState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomGetImprovedPBState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomGetDeblockingFilterState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
					 case EC_MACHINE_TYPE:
						 // Return the machine type in (reference param) lParam2
						 // This message should not be invoked until after CompressBegin
						 // since this is where GetEncoderOptions is called, and the
						 // MMX version is properly set (via init file check).
						rval = ICERR_OK;
						if (ProcessorVersionInitialized) {
							if (MMX_Enabled) {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
								}
							} else {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_PROCESSOR;
								}
							}
						} else {
							rval = ICERR_UNSUPPORTED;
						}
						break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_SET_CURRENT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_SET_CURRENT\r\n", _fx_));
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_RTP_HEADER\r\n", _fx_));
                        rval = CustomSetRTPHeaderState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_RESILIENCY:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_RESILIENCY\r\n", _fx_));
                        rval = CustomSetResiliencyState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_BITRATE_CONTROL\r\n", _fx_));
                        rval = CustomSetBitRateState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_SIZE:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_PACKET_SIZE\r\n", _fx_));
                        rval = CustomSetPacketSize(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_LOSS:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_PACKET_LOSS\r\n", _fx_));
                        rval = CustomSetPacketLoss(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is set in bits per second */
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_BITRATE\r\n", _fx_));
                        rval = CustomSetBitRate(pi->CompPtr, (DWORD)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomSetH263PlusState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomSetImprovedPBState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomSetDeblockingFilterState(pi->CompPtr, (DWORD)lParam2);
                        break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               default:
                    rval = ICERR_UNSUPPORTED;
                  break;
               }
               break;

		// custom decoder control
		case CODEC_CUSTOM_DECODER_CONTROL:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_DECODER_CONTROL\r\n", _fx_));
			switch (HIWORD(lParam1))
			{
			case DC_SET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_BLOCK_EDGE_FILTER:
					rval = CustomSetBlockEdgeFilter(pi->DecompPtr,(DWORD)lParam2);
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#if defined(H263P)
			case DC_GET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_MACHINE_TYPE:
					// Return the machine type in (reference param) lParam2
					// This message should not be invoked until after DecompressBegin
					// since this is where GetDecoderOptions is called, and the
					// MMX version is properly set (via init file check). Note
					// that the DecoderContext flag is not used here. GetDecoderOptions has
					// been modified to supply the MMX flag in both DC->bMMXDecoder
					// and MMX_Enabled.
					rval = ICERR_OK;
					if (ProcessorVersionInitialized) {
						if (MMXDecoder_Enabled) {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
							}
						} else {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_PROCESSOR;
							}
						}
					}
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#endif
			default:
				rval = ICERR_UNSUPPORTED;
				break;
			}
			break;

        case PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS\r\n", _fx_));
            rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_CONTRAST:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_CONTRAST\r\n", _fx_));
            rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_SATURATION:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_SATURATION\r\n", _fx_));
            rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_RESET_BRIGHTNESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_RESET_BRIGHTNESS\r\n", _fx_));
            rval = CustomResetBrightness(pi->DecompPtr);
            rval |= CustomResetContrast(pi->DecompPtr);
            break;

        case PLAYBACK_CUSTOM_RESET_SATURATION:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_RESET_SATURATION\r\n", _fx_));
            rval = CustomResetSaturation(pi->DecompPtr);
            break;

    // *********************************************************************
    // custom application identification message
    // *********************************************************************
        case APPLICATION_IDENTIFICATION_CODE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: APPLICATION_IDENTIFICATION_CODE\r\n", _fx_));
            rval = ICERR_OK;
            break;

        case CUSTOM_ENABLE_CODEC:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CUSTOM_ENABLE_CODEC\r\n", _fx_));
			if (pi)
			{
				if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
					pi->enabled = TRUE;
				else
					pi->enabled = FALSE;
			}
			rval = ICERR_OK;
			break;

        default:
            if (uiMessage < DRV_USER)
                {
                if(dwDriverID == 0)
                    rval = ICERR_UNSUPPORTED;
                else
                    rval = DefDriverProc(dwDriverID, hDriver, uiMessage,
                        lParam1, lParam2);
                }
            else
                rval = ICERR_UNSUPPORTED;
        }    
  }
  catch (...)
  {
#if defined(DEBUG) || defined(_DEBUG)
	// For a DEBUG build, display a message and pass the exception up.
	ERRORMESSAGE(("%s: Exception during DriverProc!!!\r\n", _fx_));
	throw;
#else
	// For a release build, stop the exception here and return an error
	// code.  This gives upstream code a chance to gracefully recover.
	// We also need to clear the floating point status word, otherwise
	// the upstream code may incur an exception the next time it tries
	// a floating point operation (presuming this exception was due
	// to a floating point problem).
	_clearfp();
	rval = (DWORD) ICERR_INTERNAL;
#endif
  }

#if FPThunking
	ThnkFPRestore(u16FPState);
#endif

    return(rval);
}


#ifdef WIN32
#ifndef QUARTZ
/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL    | DllMain    | Library initialization & exit code.
 *
 * @parm HANDLE | hModule    | Our module handle.
 *
 * @parm DWORD  | dwReason   | The function being requested.
 *
 * @parm LPVOID | lpReserved | Unused at this time.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
BOOL rval = TRUE;
 
/* DO NOT INSTALL PROFILE PROBES HERE. IT IS CALLED PRIOR TO THE LOAD message */
 
	switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			/*======================================================*\
			/* A new instance is being invoked.
			/* Allocate data to be used by this instance, 1st thread
			/* lpReserved = NULL for dynamic loads, !NULL for static
			/* Use TlsAlloc() to create a TlsIndex for this instance
			/* The TlsIndex can be stored in a simple global variable
			/* as data allocated to each process is unique.
			/* Return TRUE upon success, FALSE otherwise.
			/*======================================================*/
			hDriverModule = hModule;
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Process Attach"));
#endif /* DEBUG */
			DBGINIT(&ghDbgZoneH263, _rgZonesH263);
            DBG_INIT_MEMORY_TRACKING(hModule);
#ifdef TRACK_ALLOCATIONS
			OpenMemmon();
#endif
			break;
		case DLL_PROCESS_DETACH:
			/*======================================================*\
			/* An instance is being terminated.
			/* Deallocate memory used by all threads in this instance
			/* lpReserved =  NULL if called by FreeLibrary()
			/*              !NULL if called at process termination
			/* Use TlsFree() to return TlsIndex to the pool.
			/* Clean up all known threads.
			/* May match many DLL_THREAD_ATTACHes.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Process Detach"));
#endif /* DEBUG */
#ifdef TRACK_ALLOCATIONS
			// CloseMemmon();
#endif
            DBG_CHECK_MEMORY_TRACKING(hModule);
			DBGDEINIT(&ghDbgZoneH263);
			break;
		case DLL_THREAD_ATTACH:
			/*======================================================*\
			/* A new thread within the specified instance is being invoked.
			/* Allocate data to be used by this thread.
			/* Use the TlsIndex to access instance data.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Thread Attach"));
#endif /* DEBUG */
			break;
		case DLL_THREAD_DETACH:
			/*======================================================*\
			/* A thread within the specified instance is being terminated.
			/* Deallocate memory used by this thread.
			/* Use the TlsIndex to access instance data.
			/* May match DLL_PROCESS_ATTACH instead of DLL_THREAD_ATTACH
			/* Will be called even if DLL_THREAD_ATTACH failed or wasn't called
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Thread Detach"));
#endif /* DEBUG */
			break;
		default:
			/*======================================================*\
			/* Don't know the reason the DLL Entry Point was called.
			/* Return FALSE to be safe.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Reason Unknown"));
#endif /* DEBUG */
			rval = FALSE; /* indicate failure with 0 as
					   * (NULL can't be used in WIN32
					   */
	}
return(rval);
}
#endif	/* end #ifndef QUARTZ */
#else	/* else not #ifdef WIN32 */

;////////////////////////////////////////////////////////////////////////////
;// Function:       int NEAR PASCAL LibMain(HANDLE, WORD, LPSTR);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
INT WINAPI LibMain(HANDLE hModule, WORD wHeapSize, LPSTR lpCmdLine)
    {
    hDriverModule = hModule;
    return 1;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   12 Sep 1996 13:54:06  $
// $Archive:   S:\h26x\src\common\cdrvbase.cpv  $
// $Header:   S:\h26x\src\common\cdrvbase.cpv   1.22   12 Sep 1996 13:54:06   KLILLEVO  $
//	$Log:   S:\h26x\src\common\cdrvbase.cpv  $
// 
//    Rev 1.22   12 Sep 1996 13:54:06   KLILLEVO
// changed to Win32 memory allocation
// 
//    Rev 1.21   03 Sep 1996 16:17:58   PLUSARDI
// updated for version 2.50 of 263 net 
// 
//    Rev 1.20   23 Aug 1996 13:44:56   SCDAY
// added version numbers for Quartz using #ifdef QUARTZ
// 
//    Rev 1.19   22 Aug 1996 10:17:14   PLUSARDI
// updated for quartz version 3.05 for h261
// 
//    Rev 1.18   16 Aug 1996 11:31:28   CPERGIEX
// updated not non-quartz build
// 
//    Rev 1.17   30 Jul 1996 12:57:22   PLUSARDI
// updated for RTP version string
// 
//    Rev 1.16   11 Jul 1996 07:54:18   PLUSARDI
// change the version number for h261 v3.05.003
// 
//    Rev 1.15   12 Jun 1996 09:47:22   KLILLEVO
// updated version number
// 
//    Rev 1.14   28 Apr 1996 20:25:36   BECHOLS
// 
// Merged the RTP code into the Main Base.
// 
//    Rev 1.13   21 Feb 1996 11:40:58   SCDAY
// cleaned up compiler build warnings by putting ifdefs around definition of b
// 
//    Rev 1.12   02 Feb 1996 18:52:22   TRGARDOS
// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
// 
//    Rev 1.11   27 Dec 1995 14:11:36   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.10   13 Dec 1995 13:21:52   DBRUCKS
// changed the h261 version string defintions to use V3.00
// 
//    Rev 1.9   01 Dec 1995 15:16:34   DBRUCKS
// added VIDCF_QUALITY to support the quality slider.
// 
//    Rev 1.8   15 Nov 1995 15:58:56   AKASAI
// Remove YVU9 from get info and return error "0" when unsupported.
// (Integration point)
// 
//    Rev 1.7   09 Oct 1995 11:46:56   TRGARDOS
// 
// Set VIDCF_CRUNCH flag to support bit rate control.
// 
//    Rev 1.6   20 Sep 1995 12:37:38   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.5   19 Sep 1995 15:41:00   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.4   19 Sep 1995 13:19:50   TRGARDOS
// Changed drv_open to check ICOPEN flags.
// 
//    Rev 1.3   12 Sep 1995 15:45:38   DBRUCKS
// add H261 ifdef to desc and name
// 
//    Rev 1.2   25 Aug 1995 11:53:00   TRGARDOS
// Debugging key frame encoder.
// 
//    Rev 1.1   23 Aug 1995 12:27:16   DBRUCKS
// 
// turn on color converter init
// 
//    Rev 1.0   31 Jul 1995 12:56:10   DBRUCKS
// rename files
// 
//    Rev 1.1   21 Jul 1995 18:20:36   DBRUCKS
// IsBadReadPtr fails with a NULL - protect against
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:28   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
#endif

#ifdef H261
	#ifdef QUARTZ
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.05";
		char    szName[]        = "MS H.261";
	#else
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.00";
		char    szName[]        = "MS H.261";
	#endif
#else // is H263
	#ifdef QUARTZ
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.55";
                char    szName[]        = "MS H.263";
	#else
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.50";
                char    szName[]        = "MS H.263";
	#endif
#endif

static U32 MakeFccUpperCase(U32 fcc);

void MakeCode32(U16 selCode16)
{
    BYTE    desc[8];

#define DSC_DEFAULT     0x40
#define dsc_access      6

    GlobalReAlloc((HGLOBAL)selCode16, 0, GMEM_MODIFY|GMEM_MOVEABLE);

    _asm
    {
        mov     bx, selCode16       ; bx = selector

        lea     di, word ptr desc   ; ES:DI --> desciptor
        mov     ax,ss
        mov     es,ax

        mov     ax, 000Bh           ; DPMI get descriptor
        int     31h

        ; set DEFAULT bit to make it a 32-bit code segment
        or      desc.dsc_access,DSC_DEFAULT

        mov     ax,000Ch            ; DPMI set descriptor
        int     31h
    }
}

/******************************************************
 * DrvLoad()
 ******************************************************/
BOOL PASCAL DrvLoad(void)
{
    static int AlreadyInitialised = 0;

    if (!AlreadyInitialised) {
      AlreadyInitialised = 1;

//      H263InitDecoderGlobal();
      H263InitColorConvertorGlobal ();
      H263InitEncoderGlobal();

    }
    return TRUE;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       void PASCAL DrvFree(void);
;//
;// Description:    Added header.
;//
;// History:        02/23/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
void PASCAL DrvFree(void)
{
    return;
}

/**********************************************************
 * DrvOpen()
 * Arguments:
 * 	Pointer to ICOPEN data structure passed by
 *	the system.
 * Returns:
 *  If successful, returns a pointer to our INSTINFO data structure. That
 *  will be passed back to us in the dwDriverID parameter on subsequent
 *  system calls.
 *  If unsuccessful, it returns NULL.
 **********************************************************/
LPINST PASCAL DrvOpen(ICOPEN FAR * icinfo)
{
	INSTINFO  *lpInst;

	FX_ENTRY("DrvOpen")

	// Allocate memory for our instance information structure, INSTINFO.
	if((lpInst = (INSTINFO *) HeapAlloc(GetProcessHeap(), 0, sizeof(INSTINFO))) == NULL)
	{
		ERRORMESSAGE(("%s: Unable to ALLOC INSTINFO\r\n", _fx_));
		return NULL;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "CDRVBASE: %7ld Ln %5ld\0", sizeof(INSTINFO), __LINE__);
	AddName((unsigned int)lpInst, gsz1);
#endif

	/*
	* Store the four cc so we know which codec is open.
	* TODO: handle both lower case and upper case fourcc's.
	*/
	lpInst->fccHandler = MakeFccUpperCase(icinfo->fccHandler);
	DEBUGMSG (ZONE_INIT, ("%s: fccHandler=0x%lx\r\n", _fx_, lpInst->fccHandler));

	lpInst->CompPtr = NULL;
	lpInst->DecompPtr = NULL;

	// Check if being opened for decompression.
	if ( ((icinfo->dwFlags & ICMODE_DECOMPRESS) == ICMODE_DECOMPRESS) || ((icinfo->dwFlags & ICMODE_FASTDECOMPRESS) == ICMODE_FASTDECOMPRESS) )
	{
		// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		if ((lpInst->DecompPtr = (DECINSTINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL)
		{
			DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC DECINSTINFO\r\n", _fx_));
			HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)lpInst);
#endif
			return NULL;
		}

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz2, "CDRVBASE: %7ld Ln %5ld\0", sizeof(DECINSTINFO), __LINE__);
		AddName((unsigned int)lpInst->DecompPtr, gsz2);
#endif

		// Set flag indicating decoder instance is unitialized.
		lpInst->DecompPtr->Initialized = FALSE;
	} 


	// Check if being opened for compression as H.263.
	if( (((icinfo->dwFlags & ICMODE_COMPRESS) == ICMODE_COMPRESS) || ((icinfo->dwFlags & ICMODE_FASTCOMPRESS) == ICMODE_FASTCOMPRESS)) &&
#ifdef USE_BILINEAR_MSH26X
		((lpInst->fccHandler == FOURCC_H263) || (lpInst->fccHandler == FOURCC_H26X) ))
#else
		(lpInst->fccHandler == FOURCC_H263) )
#endif
	{
		// Allocate memory for our compressor specific instance data, COMPINSTINFO.
		if ((lpInst->CompPtr = (COMPINSTINFO*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(COMPINSTINFO))) == NULL)
		{
			DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC COMPINSTINFO\r\n", _fx_));
			if (lpInst->DecompPtr != NULL)
			{
				HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
#ifdef TRACK_ALLOCATIONS
				// Track memory allocation
				RemoveName((unsigned int)lpInst->DecompPtr);
#endif
			}

			HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)lpInst);
#endif
			return NULL;
		}

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz3, "CDRVBASE: %7ld Ln %5ld\0", sizeof(COMPINSTINFO), __LINE__);
		AddName((unsigned int)lpInst->CompPtr, gsz3);
#endif

		// Set flag indicating encoder instance is uninitialized.
		lpInst->CompPtr->Initialized = FALSE;
		lpInst->CompPtr->FrameRate = (float) 0;
		lpInst->CompPtr->DataRate = 0;
#if 0
		// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		// Previously we didn't force this - assumed application specified 
		// decompressor needed to be allocated in dwFlags.
		// After installing ClearVideo encoder, Adobe Premiere crashed using off-line without this code.
		// Put same work around here (DECINSTINFO is fairly small)
		// Might be due to installation of DCI? JM
		if (lpInst->DecompPtr == NULL)
		{
			if ((lpInst->DecompPtr = (DECINSTINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL)
			{
				DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC DECINSTINFO\r\n", _fx_));
				HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
				// Track memory allocation
				RemoveName((unsigned int)lpInst);
#endif
				return NULL;
			}

			// Set flag indicating decoder instance is unitialized.
			lpInst->DecompPtr->Initialized = FALSE;
		} 
		#endif
	}

	// Assign instance info flag with ICOPEN flag.
	lpInst->dwFlags = icinfo->dwFlags;

	// Disable codec by default. The client will send us a private message
	// to enable it.
	lpInst->enabled = FALSE;

	return lpInst;
}

DWORD PASCAL DrvClose(LPINST lpInst)
{
	FX_ENTRY("DrvClose")

	if (IsBadReadPtr((LPVOID)lpInst, sizeof(INSTINFO)))
	{
		DEBUGMSG (ZONE_INIT, ("%s: instance NULL\r\n", _fx_));
		return 1;
	}

	if (lpInst->DecompPtr &&   // IsBadReadPtr errors on NT with NULL
		!IsBadReadPtr((LPVOID)lpInst->DecompPtr, sizeof(DECINSTINFO)))
	{
		if (lpInst->DecompPtr->Initialized)
		{
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			H263TermDecoderInstance(lpInst->DecompPtr, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			H263TermDecoderInstance(lpInst->DecompPtr);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		}
		HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)lpInst->DecompPtr);
#endif
		lpInst->DecompPtr = NULL;
	}

	if (lpInst->CompPtr &&    // IsBadReadPtr errors on NT with NULL
		!IsBadReadPtr((LPVOID)lpInst->CompPtr, sizeof(COMPINSTINFO)))
	{
		if (lpInst->CompPtr->Initialized)
		{
			H263TermEncoderInstance(lpInst->CompPtr);
		}
		HeapFree(GetProcessHeap(),0,lpInst->CompPtr);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)lpInst->CompPtr);
#endif
		lpInst->CompPtr = NULL;
	}

	HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst);
#endif

	return 1;
}


DWORD PASCAL DrvGetState(LPINST lpInst, LPVOID pv, DWORD dwSize)
{
    // Return current state of compression options
    if (pv == NULL) return (sizeof(COMPINSTINFO));
    
    // check that incoming buffer is big enough
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr)
	{
		// fill the incoming buffer
		_fmemcpy(pv, lpInst->CompPtr, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvSetState(LPINST lpInst, LPVOID pv, DWORD dwSize) 
{
    // check that there is enough incoming data
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr && pv)
	{
		// get data out of incoming buffer
		_fmemcpy(lpInst->CompPtr, pv, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvGetInfo(LPINST lpInst, ICINFO FAR *icinfo, DWORD dwSize)
{
	FX_ENTRY("DrvGetInfo")

    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    if (!lpInst)
        return 0;

    icinfo->dwSize	= sizeof(ICINFO);
    icinfo->fccType	= ICTYPE_VIDEO;
    icinfo->fccHandler	= lpInst->fccHandler;
    icinfo->dwVersion	= 9002;
	MultiByteToWideChar(CP_ACP,0,szName,-1,icinfo->szName,16);
		
#ifdef USE_BILINEAR_MSH26X
    if ((lpInst->fccHandler == FOURCC_H263) || (lpInst->fccHandler == FOURCC_H26X))
#else
    if(lpInst->fccHandler == FOURCC_H263)
#endif
	{
    	icinfo->dwFlags	=  VIDCF_TEMPORAL;		// We support inter frame compression.
    	icinfo->dwFlags |= VIDCF_FASTTEMPORALC; // We do not need ICM to provide previous frames on compress
    	icinfo->dwFlags |= VIDCF_CRUNCH; 		// We support bit rate control
		icinfo->dwFlags |= VIDCF_QUALITY; 		// We support Quality
		MultiByteToWideChar(CP_ACP,0,szDescription,-1,icinfo->szDescription,128);
	}
    else if ((lpInst->fccHandler == FOURCC_YUV12) || (lpInst->fccHandler == FOURCC_IYUV))
	{
    	icinfo->dwFlags	=  0;
		MultiByteToWideChar(CP_ACP,0,szDesc_i420,-1,icinfo->szDescription,128);
	}
	else
	{
		ERRORMESSAGE(("%s: unsupported four cc\r\n", _fx_));
		return(0);
	}

    return sizeof(ICINFO);
}


/**************************************************************************
 *
 * MakeFccUpperCase().
 *
 * Convert the passed parameter to upper case. No change to chars not in
 * the set [a..z].
 *
 * returns input parameter in all upper case
 */
static U32
MakeFccUpperCase(
	U32 fcc)
{
U32 ret;
	unsigned char c;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret = toupper(c);

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += toupper(c) << 8;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += ((U32)toupper(c)) << 16;

	c = (unsigned char)(fcc & 0xFF);
	ret += ((U32)toupper(c)) << 24;
	return ret;
} /* end MakeFccUpperCase() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvcom.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:22  $
// $Archive:   S:\h26x\src\common\cdrvcom.h_v  $
// $Header:   S:\h26x\src\common\cdrvcom.h_v   1.21   05 Feb 1997 12:14:22   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvcom.h_v  $
;// 
;//    Rev 1.21   05 Feb 1997 12:14:22   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.20   19 Dec 1996 16:44:08   MDUDA
;// Added custom messages to get machine type information.
;// 
;//    Rev 1.19   16 Dec 1996 17:36:46   JMCVEIGH
;// H.263+ custom message definitions.
;// 
;//    Rev 1.18   11 Dec 1996 14:56:08   JMCVEIGH
;// 
;// Added H.263+ field lengths for EPTYPE and custom message definitions.
;// 
;//    Rev 1.17   09 Dec 1996 17:42:46   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.16   09 Dec 1996 09:25:22   MDUDA
;// 
;// Modified _CODEC_STATS stuff.
;// 
;//    Rev 1.15   11 Oct 1996 16:01:46   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.14   10 Sep 1996 16:13:04   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.13   22 Jul 1996 14:44:36   BECHOLS
;// fixed last comment.
;// 
;//    Rev 1.12   22 Jul 1996 14:36:20   BECHOLS
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.11   22 May 1996 18:48:08   BECHOLS
;// 
;// Added APPLICATION_IDENTIFICATION_CODE.
;// 
;//    Rev 1.10   06 May 1996 00:41:50   BECHOLS
;// 
;// Added the necessary message constants to allow the app to control
;// the bit rate dialog stuff.
;// 
;//    Rev 1.9   26 Apr 1996 11:10:44   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.8   27 Dec 1995 14:11:54   RMCKENZX
;// Added copyright notice
;// 
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// Integrate with build 29
//
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_VIDEO_EFFECTS:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = VE_SET_CURRENT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = value of corresponding value..
//
//    HIWORD(lParam1) = VE_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (WORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = VE_SET_INPUT_CONNECTOR:
//        LOWORD(lParam1) = VE_INPUT_COMPOSITE_1, VE_INPUT_SVIDEO_1
//        lParam2 = 0 
// --------------------------------------------------------------------- 
*/

// CUSTOM_VIDEO_EFFECTS: LOWORD(lParam1)
#define VE_CONTRAST                 0
#define VE_HUE                      1
#define VE_SATURATION               2
#define VE_BRIGHTNESS               3

// CUSTOM_VIDEO_EFFECTS: HIWORD(lParam1)
#define VE_SET_CURRENT              0
#define VE_GET_FACTORY_DEFAULT      1
#define VE_GET_FACTORY_LIMITS       2
#define VE_SET_INPUT_CONNECTOR      3
#define VE_RESET_CURRENT            4

// CUSTOM_SET_INPUT_CONNECTOR: LOWORD(lParam1)
#define VE_INPUT_COMPOSITE_1        0
#define VE_INPUT_SVIDEO_1           1

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_ENCODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = EC_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = EC_GET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = EC_SET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = value of corresponding value..
// --------------------------------------------------------------------- 

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#ifdef H263P
// H.263+ options
#define EC_H263_PLUS				1000	// Must be sent before any option messages sent

// Numbering convention:
//	1xxx: H.263+ option
//  xBBx: Bit number of option in extended PTYPE field
// Numbers are spaced by 10 to allow for additional parameters related to each option
//#define EC_ADVANCED_INTRA			1040
#define EC_DEBLOCKING_FILTER		1050
//#define EC_SLICE_STRUCTURED		1060
//#define EC_CUSTOM_PCF				1070
//#define EC_BACK_CHANNEL			1080
//#define	EC_SCALABILITY			1090	
//#define EC_TRUE_BFRAMES			1100
//#define EC_REF_RESAMPLING			1110
//#define EC_RES_UPDATE				1120
#define EC_IMPROVED_PB_FRAMES		1130

// Test support, stats monitoring, etc. messages are isolated here.
#define EC_MACHINE_TYPE				2000

// The use of the improved PB-frame mode is currently not signaled in the picture header.
// We assume that if EPTYPE is present and the frame was signaled as a PB-frame
// in PTYPE, then the improved PB-frame mode is used.

// end H.263+ options
#endif // H263P

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4


////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_DECODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = DC_SET_CURRENT:
//        LOWORD(lParam1) = DC_BLOCK_EDGE_FILTER;
//        lParam2 = 0:off, 1:on

// CUSTOM_DECODER_CONTROL: LOWORD(lParam1)
#define DC_BLOCK_EDGE_FILTER         0
#if defined(H263P)
// Test support, stats monitoring, etc. messages are isolated here.
#define DC_MACHINE_TYPE           2000
#endif

// CUSTOM_DECODER_CONTROL: HIWORD(lParam1)
#define DC_SET_CURRENT               0
#if defined(H263P)
// This was added simply to provide a consistent way to access
// machine type (see DC_MACHINE_TYPE).
#define DC_GET_CURRENT               1
#endif


/*
 * Bit stream field sizes
 */
#ifdef H261
const unsigned int FIELDLEN_PSC = 20;
const unsigned int FIELDLEN_TR = 5;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 6;	// picture type
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 1;
const unsigned int FIELDLEN_PTYPE_STILL = 1;
const unsigned int FIELDLEN_PTYPE_SPARE = 1;
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 16;
const unsigned int FIELDLEN_GN = 4;
const unsigned int FIELDLEN_GQUANT = 5;
const unsigned int FIELDLEN_GEI = 1;

const unsigned int FIELDLEN_MQUANT = 5;
const unsigned int FIELDLEN_MBA_STUFFING = 11;

#else
const unsigned int FIELDLEN_PSC = 22;
const unsigned int FIELDLEN_TR = 8;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 13;	// picture type
const unsigned int FIELDLEN_PTYPE_CONST = 2;
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_PTYPE_CODINGTYPE = 1;
const unsigned int FIELDLEN_PTYPE_UMV = 1;
const unsigned int FIELDLEN_PTYPE_SAC = 1;
const unsigned int FIELDLEN_PTYPE_AP = 1;
const unsigned int FIELDLEN_PTYPE_PB = 1;

#ifdef H263P

const unsigned int FIELDLEN_EPTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_EPTYPE_CPCF = 1;
const unsigned int FIELDLEN_EPTYPE_AI = 1;
const unsigned int FIELDLEN_EPTYPE_DF = 1;
const unsigned int FIELDLEN_EPTYPE_SS = 1;
const unsigned int FIELDLEN_EPTYPE_IPB = 1;
const unsigned int FIELDLEN_EPTYPE_BCO = 1;
const unsigned int FIELDLEN_EPTYPE_SCALE = 1;
const unsigned int FIELDLEN_EPTYPE_TB = 1;
const unsigned int FIELDLEN_EPTYPE_RPR = 1;
const unsigned int FIELDLEN_EPTYPE_RRU = 1;
const unsigned int FIELDLEN_EPTYPE_CONST = 5;

const unsigned int FIELDLEN_CSFMT_PARC = 4;
const unsigned int FIELDLEN_CSFMT_FWI = 9;
const unsigned int FIELDLEN_CSFMT_CONST = 1;
const unsigned int FIELDLEN_CSFMT_FHI = 9;

const unsigned int FIELDLEN_EPAR_WIDTH = 8;
const unsigned int FIELDLEN_EPAR_HEIGHT = 8;

#endif

const unsigned int FIELDLEN_PQUANT = 5;	// picture quant value
const unsigned int FIELDLEN_CPM = 1;	// continuous presence multipoint indicator
const unsigned int FIELDLEN_PLCI = 2;	// picture logical channel indicator.
const unsigned int FIELDLEN_TRB = 3;	// temporal reference for B frames
const unsigned int FIELDLEN_DBQUANT = 2;// B frame differential quant value
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 17;	// Group of blocks start code
const unsigned int FIELDLEN_GN = 5;		// GOB number.
const unsigned int FIELDLEN_GLCI = 2;	// GOB logical channel indicator
const unsigned int FIELDLEN_GFID = 2;	// GOB Frame ID
const unsigned int FIELDLEN_GQUANT = 5;	// GQUANT
#endif

/*
 * Bit stream field values
 */
#ifdef H261
const unsigned int FIELDVAL_PSC  = 0x00010;
const unsigned int FIELDVAL_GBSC = 0x0001;
const unsigned int FIELDVAL_MBA_STUFFING = 0x00F;
#else
const unsigned int FIELDVAL_PSC = 0x000020;
const unsigned int FIELDVAL_GBSC = 1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ctypedef.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:12:02  $
// $Archive:   S:\h26x\src\common\ctypedef.h_v  $
// $Header:   S:\h26x\src\common\ctypedef.h_v   1.2   27 Dec 1995 14:12:02   RMCKENZX  $
// $Log:   S:\h26x\src\common\ctypedef.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:12:02   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __TYPEDEFS_H__
#define __TYPEDEFS_H__

typedef unsigned char       U8;
typedef signed   char       I8;

typedef unsigned short      U16;
typedef short               I16;

typedef long                I32;
typedef unsigned long       U32;

typedef unsigned int        UN;
typedef int                 IN;

typedef unsigned short int  X16;  /* Used for offsets of per-instance data < 64K */
typedef unsigned long       X32;  /* Used for offsets of per-instance data >= 64K */

#ifndef WIN32
#define BIGG _huge
#define FAR  _far
#else
#define BIGG 
#define _huge
#define _far
#ifndef FAR
#define FAR
#endif
#ifndef BIGG
#define BIGG
#endif
#endif

/* #define HUGE _huge // name conflict with name used in <math.h> */

#define TRUE  1
#define FALSE 0


#if defined WIN32
#define ASM_CALLTYPE _stdcall
#else
#define ASM_CALLTYPE
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\counters.cpp ===
//  COUNTERS.CPP
//
//      Global performance counters for H.263 video codec
//
//  Created 13-Nov-96 [JonT] <for NAC.DLL>
//  Added H.263 counters 30-Jan-97 [PhilF]

#include "precomp.h"

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

// Global ICounterMgr. We just use as an CLSID_Counter class factory
    ICounterMgr* g_pCtrMgr;

// Define all counters here
    ICounter* g_pctrCompressionTimePerFrame;   
    ICounter* g_pctrDecompressionTimePerFrame;
    ICounter* g_pctrBEFTimePerFrame;

// Put these in a .LIB file someday
const IID IID_ICounterMgr = {0x9CB7FE5B,0x3444,0x11D0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};
const CLSID CLSID_CounterMgr = {0x65DDC229,0x38FE,0x11d0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};

//  InitCounters
//      Initializes all counters that we want to use

extern "C"
BOOL
WINAPI
InitCounters(void)
{
    // Get a pointer to the statistics counter interface if it's around
    if (CoCreateInstance(CLSID_CounterMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICounterMgr,
        (void**)&g_pCtrMgr) != S_OK)
        return FALSE;

    // Create counters here
    DEFINE_COUNTER(&g_pctrCompressionTimePerFrame, "Compression Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrDecompressionTimePerFrame, "Decompression Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrBEFTimePerFrame, "Block Edge Filtering Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);

    return TRUE;
}


//  DoneCounters
//      Cleans up after all counters we wanted to use

extern "C"
void
WINAPI
DoneCounters(void)
{
    ICounterMgr* pctrmgr;

    // Release the statistics stuff if it's around
    if (!g_pCtrMgr)
        return;

    // Zero out the interface pointer so we don't accidentally use it elsewhere
    pctrmgr = g_pCtrMgr;
    g_pCtrMgr = NULL;

    // Remove counters here
    DELETE_COUNTER(&g_pctrCompressionTimePerFrame);
    DELETE_COUNTER(&g_pctrDecompressionTimePerFrame);
    DELETE_COUNTER(&g_pctrBEFTimePerFrame);

    // Done with ICounterMgr
    pctrmgr->Release();
}

#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cversion.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * $Header:   S:\h26x\src\common\cversion.h_v   1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI  $
 * $Log:   S:\h26x\src\common\cversion.h_v  $
;// 
;//    Rev 1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI
;// updated for version VH263.v2.55.103e
;// 
;//    Rev 1.65.1.0.1.0   08 Oct 1996 12:52:48   PLUSARDI
;// updated for H263.2.55.103d
;// 
;//    Rev 1.65.1.0   27 Sep 1996 07:04:38   PLUSARDI
;// updated for version 103 of h263
;// 
;//    Rev 1.65   24 Sep 1996 14:45:12   PLUSARDI
;// updated for version 102 of h263
;// 
;//    Rev 1.64   17 Sep 1996 09:06:00   PLUSARDI
;// updated for version 101 of h263 and rtp263
;// 
;//    Rev 1.63   12 Sep 1996 10:23:30   PLUSARDI
;// updated for version 2.55.100 for h263 and rtp263
;// 
;//    Rev 1.62   06 Sep 1996 14:40:22   BECHOLS
;// Removed the distinction between RTP and nonRTP.  I also updated the
;// release number to 2.55.016.
;// 
;//    Rev 1.61   05 Sep 1996 14:38:36   PLUSARDI
;// No change.
;// 
;//    Rev 1.60   04 Sep 1996 20:32:42   PLUSARDI
;// 
;// updated for 261 build 1.05.009 and 1.00.030
;// 
;//    Rev 1.59   03 Sep 1996 16:12:14   PLUSARDI
;// updated for 2.50.016 version of h263
;// 
;//    Rev 1.58   03 Sep 1996 16:05:06   PLUSARDI
;// updated for v2.50.015  263 internet 
;// 
;//    Rev 1.57   22 Aug 1996 10:02:04   PLUSARDI
;// updated for version 006 of h261 quartz
;// 
;//    Rev 1.56   22 Aug 1996 09:15:22   CPERGIEX
;// Rev'd H261 to version 029
;// 
;//    Rev 1.55   16 Aug 1996 11:27:14   CPERGIEX
;// updated for version 028 of h261
;// 
;//    Rev 1.54   15 Aug 1996 11:25:32   PLUSARDI
;// update the version build 004 quartz
;// 
;//    Rev 1.53   05 Aug 1996 16:57:56   CPERGIEX
;// Change version number to 027.
;// 
;//    Rev 1.52   01 Aug 1996 13:13:30   PLUSARDI
;// updated for build 14 of H263 RTP
;// 
;//    Rev 1.51   31 Jul 1996 18:44:16   PLUSARDI
;// updated for version 13 of net H263
;// 
;//    Rev 1.50   30 Jul 1996 12:52:04   PLUSARDI
;// updated for build 12 of net263
;// 
;//    Rev 1.49   11 Jul 1996 14:31:52   PLUSARDI
;// Build 026 of H261 Version 3.00 (not Quartz). C. Pergiel.
;// 
;//    Rev 1.48   11 Jul 1996 09:52:42   PLUSARDI
;// Change the version number for h261 v3.05.004
;// 
;//    Rev 1.47   11 Jul 1996 07:53:14   PLUSARDI
;// change the version number for h261 v3.05.003
;// 
;//    Rev 1.46   10 Jul 1996 17:17:56   PLUSARDI
;// updated to version 003 of H261 quartz
;// 
;//    Rev 1.45   10 Jul 1996 08:26:44   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.44   21 Jun 1996 10:53:44   AGANTZX
;// Revved Version String to Build 025
;// ]
;// 
;// 
;//    Rev 1.43   20 Jun 1996 14:10:50   AGANTZX
;// Revved to correct version string ...024
;// 
;//    Rev 1.42   06 Jun 1996 06:36:56   PLUSARDI
;// changed mmx version numbers to 1.5.xx
;// 
;//    Rev 1.41   31 May 1996 10:15:48   PLUSARDI
;// updated for verison 45 of mmx 236
;// 
;//    Rev 1.40   08 May 1996 11:50:42   PLUSARDI
;// updated for ver 009 of net263
;// 
;//    Rev 1.39   07 May 1996 21:11:02   PLUSARDI
;// updated for version 1.20.008 for net263
;// 
;//    Rev 1.38   07 May 1996 09:49:42   BECHOLS
;// Added ifdef RTP_HEADER for separate version control.
;// 
;//    Rev 1.37   24 Apr 1996 13:51:42   AGANTZX
;// Reved Version string to Build 022
;// 
;//    Rev 1.36   22 Apr 1996 11:54:34   AGANTZX
;// Revved Version strin to build 021
;// 
;//    Rev 1.35   05 Apr 1996 12:06:26   AGANTZX
;// Revved Version String to: "020"
;// 
;//    Rev 1.34   04 Apr 1996 16:52:08   AGANTZX
;// Revved Version Number to H261 to Build 019
;// 
;//    Rev 1.33   21 Mar 1996 14:47:12   unknown
;// Updated H261 Version Label to V3.00.018
;// 
;//    Rev 1.32   15 Feb 1996 16:52:46   RHAZRA
;// updated for versionb 28 of h263
;// 
;//    Rev 1.31   14 Feb 1996 17:11:14   AKASAI
;// Corrected CODEC_RELEASE to 15 was 14.
;// 
;//    Rev 1.30   14 Feb 1996 17:04:40   AGANTZX
;// none
;// 
;//    Rev 1.29   14 Feb 1996 09:36:08   AGANTZX
;// Incremented Build version to 014
;// 
;//    Rev 1.28   08 Feb 1996 14:46:00   AGANTZX
;// Rolled Build Revision to 013
;// 
;//    Rev 1.27   06 Feb 1996 14:41:06   PLUSARDI
;// Changed Build version to 012
;// 
;//    Rev 1.26   23 Jan 1996 17:52:30   PLUSARDI
;// No change.
;// 
;//    Rev 1.25   22 Jan 1996 18:50:24   PLUSARDI
;// No change.
;// 
;//    Rev 1.24   16 Jan 1996 13:37:56   AGANTZX
;// Changed Build Revision Number to 011
;// 
;//    Rev 1.23   15 Jan 1996 16:48:46   AGANTZX
;// Reved Version to Build 10
;// 
;//    Rev 1.22   15 Jan 1996 15:16:54   PLUSARDI
;// updated for version 016 of H263
;// 
;//    Rev 1.21   09 Jan 1996 13:49:00   AGANTZX
;// Updated H261 Version Number to 009
;// 
;//    Rev 1.20   08 Jan 1996 13:02:08   DBRUCKS
;// advance copyright to 1996
;// 
;//    Rev 1.19   03 Jan 1996 09:14:02   DKAYNORX
;// No change.
;// 
;//    Rev 1.18   27 Dec 1995 15:01:06   DKAYNORX
;// Edited H261 Version Number to "008"
;// 
;//    Rev 1.17   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
 */

//////////////////////////////////////////////////////////////////////////////
//
// Version
//
#if defined(H261)

#define CODEC_VERSION       4
#define CODEC_REVISION      50
#define CODEC_RELEASE       014
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH261.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.261 Video Codec\0"

#elif defined(H263P)

#define CODEC_VERSION       3
#define CODEC_REVISION      55
#define CODEC_RELEASE       211
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263P.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263P Video Codec\0"

#else	// is H263

#define CODEC_VERSION       2
#define CODEC_REVISION      55
#define CODEC_RELEASE       115
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263 Video Codec\0"

#endif //end else is H263

#define VERSIONCOMPANYNAME  "Microsoft Corp. and Intel Corporation\0"
#define VERSIONCOPYRIGHT    "Microsoft Corp. and Intel Corporation\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\counters.h ===
//  COUNTERS.H
//
//      Global performance counters for H.263 video codec
//
//  Created 13-Nov-96 [JonT] <for NAC.DLL>
//  Added H.263 counters 30-Jan-97 [PhilF]


#ifndef _COUNTERS_H
#define _COUNTER_H

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#include <objbase.h>
#include "icounter.h"
#include "stats.h"

// Interface pointer to counter manager object.
// If this pointer is NULL, stats are not around (or not initialized)
    extern ICounterMgr* g_pCtrMgr;

// Counter pointers. All available counters should be listed here
    extern ICounter* g_pctrCompressionTimePerFrame;
    extern ICounter* g_pctrDecompressionTimePerFrame;
    extern ICounter* g_pctrBEFTimePerFrame;

// Helper function prototypes (COUNTER.CPP)
extern "C" BOOL WINAPI InitCounters(void);
extern "C" void WINAPI DoneCounters(void);

// Function helpers (better than using macros)
void __inline DEFINE_COUNTER(ICounter** ppctr, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateCounter(ppctr) == S_OK)
        (*ppctr)->Initialize(szName, dwFlags);
}

void __inline DELETE_COUNTER(ICounter** ppctr)
{
    ICounter* pctrT;

    if (*ppctr)
    {
        pctrT = *ppctr;
        *ppctr = NULL;
        pctrT->Release();
    }
}

void __inline UPDATE_COUNTER(ICounter* pctr, int nValue)
{
    if (pctr)
        pctr->Update(nValue);
}

#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#endif // #ifndef _COUNTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cresourc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by C_H26X.RC
//

// Strings
#define IDS_YVU9_DESC                   1
#define IDS_YVU9_NAME                   2
#define IDS_DRV_NAME                    5
#define IDS_INCOMPAT                    6
// RTP
#define IDS_ERR_PACKET_SIZE             7
#define IDS_ERR_PACKET_LOSS             8
#define IDS_ERR_BITRATE                 9
#define IDS_ERR_TITLE                   11
#define IDS_ERR_NON_NUMERIC             12
// QUARTZ
#define IDS_QTZ_ERR_BRIGHTNESS_TITLE    13
#define IDS_QTZ_ERR_SATURATION_TITLE    14
#define IDS_QTZ_ERR_CONTRAST_TITLE      15
#define IDS_QTZ_ERR_BRIGHTNESS_MESSAGE  16
#define IDS_QTZ_ERR_SATURATION_MESSAGE  17
#define IDS_QTZ_ERR_CONTRAST_MESSAGE    18
#define IDS_QTZ_ERR_NON_NUMERIC_TITLE   19
#define IDS_QTZ_ERR_NON_NUMERIC_MESSAGE 20
#define IDS_QTZ_VIDEO_EFFECTS           21
#define IDS_QTZ_DIALOG_COMPRESS_NAME    22
#define IDS_QTZ_ERR_FRAMERATE_TITLE     23
#define IDS_QTZ_ERR_DATARATE_TITLE      24
#define IDS_QTZ_ERR_QUALITY_TITLE       25
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_TITLE 26
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_TITLE 27
#define IDS_QTZ_ERR_FRAMERATE_MESSAGE   28
#define IDS_QTZ_ERR_DATARATE_MESSAGE    29
#define IDS_QTZ_ERR_QUALITY_MESSAGE     30
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_MESSAGE 31
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_FCIF_MESSAGE 32
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_QCIF_MESSAGE 33
#define IDS_QTZ_RTP_COMPRESS_NAME       34
#define IDS_QTZ_ERR_PACKET_SIZE_TITLE   35
#define IDS_QTZ_ERR_PACKET_SIZE_MESSAGE 36
#define IDS_QTZ_ERR_PACKET_LOSS_TITLE   37
#define IDS_QTZ_ERR_PACKET_LOSS_MESSAGE 38
#define IDS_QTZ_ENCODE_OPTIONS          39
#define IDS_QTZ_ERR_ENCODE_OPTIONS_TITLE 40
#define IDS_QTZ_ERR_EXTENDEDMV          41
#define IDS_QTZ_ERR_EXTENDEDMV_MESSAGE  42
#define IDS_QTZ_ERR_PBFRAMES            43
#define IDS_QTZ_ERR_PBFRAMES_MESSAGE    44
#define IDS_QTZ_ERR_ADVPREDICTION       45
#define IDS_QTZ_ERR_ADVPREDICTION_MESSAGE 46

// Dialog Boxes
#define IDD_DIALOG1                     101
// QUARTZ
#define IDD_QTZ_VIDEO_EFFECTS           102
#define IDD_QTZ_DIALOG_COMPRESS		103
#define IDD_QTZ_RTP_COMPRESS            104
#define IDD_QTZ_ENCODE_OPTIONS          105

// Controls
// RTP
#define IDC_PACKET_SIZE                 1006
#define IDC_PACKET_SIZE_TEXT            1007
#define IDC_RTP_HEADER                  1008
#define IDC_ENCODER_RESILIENCY          1009
#define IDC_PACKET_LOSS                 1010
#define IDC_PACKET_LOSS_TEXT            1011
#define IDD_ABOUT                       1012
#define IDABOUT                         1013
#define IDDEFAULT                       1014
#define IDC_RESILIENCY_OPTIONS          1015
#define IDC_RTP_OPTIONS                 1016
#define IDC_ENCODER_BITRATE_CONTROL     1017
#define IDC_BITRATE_CONTROL             1018
#define IDC_BITRATE_CONTROL_TEXT        1019
// QUARTZ
#define IDC_QTZ_RESET                   1020
#define IDC_QTZ_LOAD_DEFAULT            1021
#define IDC_QTZ_ABOUT                   1022
#define IDC_QTZ_VE_BRIGHTNESS           1023
#define IDC_QTZ_VE_SATURATION           1024
#define IDC_QTZ_VE_CONTRAST             1025
#define IDC_QTZ_VE_MIRROR				1026
#define IDC_QTZ_VE_ASPECT_CORRECT		1027
#define IDC_QTZ_SATURATION_TEXT         1029
#define IDC_QTZ_CONTRAST_TEXT           1030
#define IDC_QTZ_TEXT                    1031
#define IDC_QTZ_BRIGHTNESS_TEXT         1032

#define IDC_CMP_KEYFRAME_RATE_TEXT      1033
#define IDC_CMP_KEYFRAME_RATE           1034
#define IDC_CMP_DATA_RATE_TEXT          1035
#define IDC_CMP_DATA_RATE               1036
#define IDC_CMP_FRAME_RATE_TEXT         1037
#define IDC_CMP_FRAME_RATE              1038
#define IDC_CMP_QUALITY_TEXT            1039
#define IDC_CMP_QUALITY                 1040
#define IDC_CMP_GENERATE_KEY            1041
#define IDC_CMP_TARGET_TEXT             1042
#define IDC_CMP_TARGET_FRAME_SIZE       1043
#define IDC_CMP_FSIZE_BRC               1044
#define IDC_CMP_FRATE_BRC               1045
#define IDC_QTZ_RTP_HEADER              1046
#define IDC_QTZ_PACKET_SIZE             1047
#define IDC_QTZ_PACKET_SIZE_TEXT        1048
#define IDC_QTZ_PACKET_LOSS             1049
#define IDC_QTZ_PACKET_LOSS_TEXT        1050
#define IDC_QTZ_EXTENDEDMV              1051
#define IDC_QTZ_PBFRAMES                1052
#define IDC_QTZ_ADVPREDICTION			1053

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1054
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\cproto.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   30 Dec 1996 19:59:06  $
// $Archive:   S:\h26x\src\common\cproto.h_v  $
// $Header:   S:\h26x\src\common\cproto.h_v   1.9   30 Dec 1996 19:59:06   MDUDA  $
// $Log:   S:\h26x\src\common\cproto.h_v  $
;// 
;//    Rev 1.9   30 Dec 1996 19:59:06   MDUDA
;// Modified H263InitEncoderInstance prototype.
;// 
;//    Rev 1.8   25 Sep 1996 17:23:28   BECHOLS
;// Added Snapshot declaration.
;// 
;//    Rev 1.7   24 Sep 1996 13:49:06   BECHOLS
;// Added Snapshot() prototype.
;// 
;//    Rev 1.6   10 Jul 1996 08:26:42   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.5   02 Feb 1996 18:52:56   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

/*
 * Prototypes for Low Bitrate VFW Codec
 */

#ifndef LB3PROTOIZE_H
#define LB3PROTOIZE_H

#ifndef VOID
#define VOID void
#endif

#ifndef WIN32
#ifndef FAR
#define FAR __far
#endif
#endif



#ifndef INLINE
#define INLINE __inline
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef SHORT
#define SHORT short
#endif

#ifndef S8
#define S8 signed char
#endif

#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressBegin(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);
#else
DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);
#endif

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER); 

DWORD PASCAL DecompressSetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL DecompressGetFormat(LPINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
#else
DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
#endif

DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESSEX FAR *, DWORD, BOOL);

DWORD PASCAL DecompressEnd(LPDECINST);

VOID MakeCode32(U16);

BOOL PASCAL DrvLoad(VOID);

VOID PASCAL DrvFree(VOID);

LPINST PASCAL DrvOpen(ICOPEN FAR *);

DWORD PASCAL DrvClose(LPINST);

DWORD PASCAL DrvGetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvSetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvGetInfo(LPINST, ICINFO FAR *, DWORD);

#ifdef WIN32
LRESULT WINAPI DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#else
LRESULT FAR PASCAL _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#endif


LPCODINST PASCAL CompressOpen(VOID);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL CompressClose(DWORD);

// controls.c
#ifdef QUARTZ
LRESULT __cdecl CustomChangeBrightness(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeContrast(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeSaturation(LPDECINST, BYTE);
LRESULT __cdecl CustomGetBrightness(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetContrast(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetSaturation(LPDECINST, BYTE *);
LRESULT __cdecl CustomResetBrightness(LPDECINST);
LRESULT __cdecl CustomResetContrast(LPDECINST);
LRESULT __cdecl CustomResetSaturation(LPDECINST);
#else
LRESULT CustomChangeBrightness(LPDECINST, BYTE);
LRESULT CustomChangeContrast(LPDECINST, BYTE);
LRESULT CustomChangeSaturation(LPDECINST, BYTE);
LRESULT CustomResetBrightness(LPDECINST);
LRESULT CustomResetContrast(LPDECINST);
LRESULT CustomResetSaturation(LPDECINST);
#endif

#ifdef WIN32
//BOOL  DriverDialogProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY DllMain(HINSTANCE , DWORD , LPVOID );
#else
INT WINAPI LibMain(HANDLE, WORD, LPSTR);
//BOOL FAR PASCAL _loadds _export DriverDialogProc(HWND, UINT, UINT, LONG);
#endif 

;// D3DEC.CPP 
LRESULT H263InitDecoderGlobal(void);
LRESULT H263InitDecoderInstance(LPDECINST, int);
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL, BOOL);
LRESULT H263TermDecoderInstance(LPDECINST, BOOL);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
LRESULT H263TermDecoderInstance(LPDECINST);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

void FAR H26332BitEncoderCodeSegment (void);
void FAR H26332BitDecoderCodeSegment (void);
void FAR H26332BitColorConvertCodeSegment (void);

;// E3ENC.CPP
LRESULT H263InitEncoderGlobal(void);
#ifdef USE_BILINEAR_MSH26X
LRESULT H263Compress(LPINST, ICCOMPRESS FAR *);
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263Compress(LPCODINST, ICCOMPRESS FAR *);
#if defined(H263P)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263InitEncoderInstance(LPCODINST);
#endif
#endif
LRESULT H263TermEncoderInstance(LPCODINST);

;// D3COLOR.C
LRESULT H263InitColorConvertorGlobal (void);
LRESULT H263InitColorConvertor(LPDECINST, UINT);
LRESULT H263TermColorConvertor(LPDECINST);
#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3bvriq.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:22:36  $
// $Archive:   S:\h26x\src\dec\d3bvriq.h_v  $
// $Header:   S:\h26x\src\dec\d3bvriq.h_v   1.5   22 Mar 1996 17:22:36   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.h_v  $
;// 
;//    Rev 1.5   22 Mar 1996 17:22:36   AGUPTA2
;// Minor interface change to accomodate MMX rtns.  Now the interface is the
;// same for MMX and IA.
;// 
;//    Rev 1.4   14 Mar 1996 14:58:26   AGUPTA2
;// Added decls for MMX rtn.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:10   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   09 Dec 1995 17:34:48   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.1   27 Nov 1995 14:39:28   CZHU
// 
//    Rev 1.0   27 Nov 1995 14:37:10   CZHU
// Initial revision.


#ifndef __VLD_RLD_IQ_Block__
#define __VLD_RLD_IQ_Block__

extern "C" U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);

#ifdef USE_MMX // { USE_MMX
extern "C" U32 MMX_VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);
#endif // } USE_MMX

typedef U32 (*T_pFunc_VLD_RLD_IQ_Block)
    (T_BlkAction *,
	 U8 *,
     U32,
	 U32 *,
     U32 *);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3bvriq.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:23:16  $
// $Archive:   S:\h26x\src\dec\d3bvriq.cpv  $
// $Header:   S:\h26x\src\dec\d3bvriq.cpv   1.7   22 Mar 1996 17:23:16   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.cpv  $
// 
//    Rev 1.7   22 Mar 1996 17:23:16   AGUPTA2
// Minor interface change to accomodate MMX rtns.  Now the interface is the
// same for MMX and IA.
// 
//    Rev 1.6   08 Mar 1996 16:46:10   AGUPTA2
// Added pragma code_seg.
// 
// 
//    Rev 1.5   15 Feb 1996 14:54:08   RMCKENZX
// Gutted and re-wrote routine, optimizing for performance
// for the p5.  Added clamping to -2048...+2047 to escape code
// portion.
// 
//    Rev 1.4   27 Dec 1995 14:36:00   RMCKENZX
// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:35:20   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.0   27 Nov 1995 14:36:46   CZHU
// Initial revision.
// 
//    Rev 1.28   03 Nov 1995 16:28:50   CZHU
// Cleaning up and added more comments
// 
//    Rev 1.27   31 Oct 1995 10:27:20   CZHU
// Added error checking for total run value.
// 
//    Rev 1.26   19 Sep 1995 10:45:12   CZHU
// 
// Improved pairing and cleaned up
// 
//    Rev 1.25   18 Sep 1995 10:20:28   CZHU
// Fixed bugs in handling escape codes for INTER blocks w.r.t. run.
// 
//    Rev 1.24   15 Sep 1995 09:35:30   CZHU
// fixed bugs in run cumulation for inter
// 
//    Rev 1.23   14 Sep 1995 10:13:32   CZHU
// 
// Initialize cumulated run for the INTER blocks.
// 
//    Rev 1.22   12 Sep 1995 17:36:06   AKASAI
// 
// Fixed bug in addressing to Intermediate when changed from writing
// BYTES to DWORDS.  Inter Butterfly only had the problem.
// 
//    Rev 1.21   12 Sep 1995 13:37:58   AKASAI
// Added Butterfly Inter code.  Also added optimizations to pre-fetch
// accumulators and "output" cache lines.
// 
//    Rev 1.20   11 Sep 1995 16:41:32   CZHU
// Adjust target block address: write to Target if INTRA, write to tempory sto
// 
//    Rev 1.19   11 Sep 1995 14:30:32   CZHU
// Seperate Butterfly for inter and intra, put place holder for inter blocks
// 
//    Rev 1.18   08 Sep 1995 11:49:00   CZHU
// Added support for P frames, fixed bugs related to INTRADC's presence.
// 
//    Rev 1.17   28 Aug 1995 14:51:22   CZHU
// Improve pairing and clean up
// 
//    Rev 1.16   24 Aug 1995 15:36:24   CZHU
// 
// Fixed bugs handling the escape code followed by 22bits fixed length code
// 
//    Rev 1.15   23 Aug 1995 14:53:32   AKASAI
// Changed butterfly writes to increment by bytes and take a PITCH.
// 
//    Rev 1.14   23 Aug 1995 11:58:46   CZHU
// Added signed extended inverse quant before calling idct. and others 
// 
//    Rev 1.13   22 Aug 1995 17:38:28   CZHU
// Calls the idct accumulation for each symbol and butterfly at the end.
// 
//    Rev 1.12   21 Aug 1995 14:39:58   CZHU
// 
// Added IDCT initialization code and stubs for accumulation and butterfly.
// Also added register saving and restoration before and after accumulation
// 
//    Rev 1.11   18 Aug 1995 17:03:32   CZHU
// Added comments and clean up for integration with IDCT
// 
//    Rev 1.10   18 Aug 1995 15:01:52   CZHU
// Fixed bugs in handling escape codes using byte oriented reading approach
// 
//    Rev 1.9   16 Aug 1995 14:24:22   CZHU
// Bug fixes for the integration with bitstream parsing. Also changed from DWO
// reading to byte oriented reading.
// 
//    Rev 1.8   15 Aug 1995 15:07:42   CZHU
// Fixed the stack so that the parameters have been passed in correctly.
// 
//    Rev 1.7   14 Aug 1995 16:39:02   DBRUCKS
// changed pPBlock to pCurBlock
// 
//    Rev 1.6   11 Aug 1995 16:08:12   CZHU
// removed local varables in C
// 
//    Rev 1.5   11 Aug 1995 15:51:26   CZHU
// 
// Readjust local varables on the stack. Clear ECX upfront.
// 
//    Rev 1.4   11 Aug 1995 15:14:32   DBRUCKS
// variable name changes
// 
//    Rev 1.3   11 Aug 1995 13:37:26   CZHU
// 
// Adjust to the joint optimation of IDCT, IQ, RLE, and ZZ.
// Also added place holders for IDCT.
// 
//    Rev 1.2   11 Aug 1995 10:30:26   CZHU
// Changed the functions parameters, and added codes to short-curcuit IDCT bef
// 
//    Rev 1.1   03 Aug 1995 14:39:04   CZHU
// 
// further optimization.
// 
//    Rev 1.0   02 Aug 1995 15:20:02   CZHU
// Initial revision.
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 


//--------------------------------------------------------------------------
//
//  d3xbvriq.cpp
//
//  Description:
//    This routine performs run length decoding and inverse quantization
//    of transform coefficients for one block.
//	 MMx version.
//
//  Routines:
//    VLD_RLD_IQ_Block
//
//  Inputs (dwords pushed onto stack by caller):
//    lpBlockAction  pointer to Block action stream for current blk.
//
//	 lpSrc			The input bitstream.
//
//	 uBitsInOut		Number of bits already read.
//
//    pIQ_INDEX		Pointer to coefficients and indices.
//
//    pN				Pointer to number of coefficients read.
//
//  Returns:
//    0 				on bit stream error, otherwise total number of bits read
//					(including number read prior to call).
//
//  Note: 
//			The structure of gTAB_TCOEFF_MAJOR is as follows:
//				bits		name:		description
//				----		-----		-----------
//				25-18		bits:		number of bitstream bits used
//				17			last:		flag for last coefficient
//				16-9		run:		number of preceeding 0 coefficients plus 1
//				8-2			level:		absolute value of coefficient
//				1			sign:		sign of coefficient
//				0			hit:		1 = major table miss, 0 = major table hit
//
//			The structure of gTAB_TCOEFF_MINOR is the same, right shifted by 1 bit. 
//			A gTAB_TCOEFF_MAJOR value of 00000001h indicates the escape code.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// local variable definitions
#define L_Quantizer		esp+20		// quantizer		P_BlockAction
#define L_Quantizer64	esp+24		// 64*quantizer		P_src
#define L_Bits      	esp+28		// bit offset		P_bits
#define L_CumRun		esp+36		// cumulative run	P_dst

// stack use
//	ebp					esp+0
//	esi					esp+4
//	edi					esp+8
//	ebx					esp+12
//	return address		esp+16

// input parameters
#define P_BlockAction 	esp+20		// L_Quantizer
#define P_src			esp+24		// L_Quantizer64
#define P_bits			esp+28		// L_Bits
#define P_num			esp+32		//
#define P_dst			esp+36		// L_CumRun


#pragma code_seg("IACODE1")
extern "C" __declspec(naked)
U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX)
{		
	__asm {

// save registers
	push	ebp
	 push	esi 
	push	edi			
	 push	ebx

//
// initialize
//	make sure we read in the P_src and P_dst pointers before we
//	overwrite them with L_Quantizer64 and L_CumRun.
//
//	Output Registers:
//		 dl = block type ([P_BlockAction])
//		esi = bitstream source pointer (P_src)
//		edi = coefficient destination pointer (P_dst)
//		ebp = coefficent counter (init to 0)
//
//	Locals initialized on Stack: (these overwrite indicated input parameters) 
//		local var		clobbers  		initial value
//		---------------------------------------------------
//		L_Quantizer		P_BlockAction	input quantizer
//		L_Quantizer64	P_src			64 * input quantizer
//		L_CumRun 		P_dst			-1
//
	xor 	ebp, ebp						// init coefficient counter to 0
 	 xor 	eax, eax						// zero eax for quantizer & coef. counter

	mov 	ecx, [P_BlockAction]        	// ecx = block action pointer
	 mov 	ebx, -1							// beginning cumulative run value

	mov 	esi, [P_src]  					// esi = bitstream source pointer
	 mov 	edi, [P_dst]					// edi = coefficient pointer

	mov 	al, [ecx+3]						// al = Quantizer
	 mov 	[L_CumRun], ebx					// init cumulative run to -1

	mov 	[L_Quantizer], eax				// save original quantizer
	 mov 	dl, [ecx]						// block type in dl

	shl 	eax, 6							// 64 * Quantizer
 	 mov 	ecx, [L_Bits]					// ecx = L_Bits

	mov 	ebx, ecx						// ebx = L_Bits
	 mov 	[L_Quantizer64], eax				// save 64*Quantizer for this block

	shr 	ebx, 3							// offset for input
	 and 	ecx, 7							// shift value

	cmp 	dl, 1							// check the block type for INTRA
	 ja 	get_next_coefficient			// if type 2 or larger, no INTRADC
	 
//
// Decode INTRADC
//
//	uses dword load & bitswap to achieve big endian ordering.
//	prior codes prepares ebx, cl, and dl as follows:
//		ebx = L_Bits>>3
//		cl  = L_Bits&7
//		dl  = BlockType (0=INTRA_DC, 1=INTRA, 2=INTER, etc.)
//
	mov 	eax, [esi+ebx]					// *** PROBABLE MALALIGNMENT ***
	 inc 	ebp								// one coefficient decoded

	bswap	eax								// big endian order
											// *** NOT PAIRABLE ***

	shl 	eax, cl							// left justify bitstream buffer
											// *** NOT PAIRABLE ***
											// *** 4 CYCLES ***

	shr 	eax, 21							// top 11 bits to the bottom
 	 mov 	ecx, [L_Bits]					// ecx = L_Bits

	and 	eax, 07f8h						// mask last 3 bits
	 add 	ecx, 8							// bits used += 8 for INTRADC

	cmp 	eax, 07f8h						// check for 11111111 codeword
	 jne 	skipa

	mov 	eax, 0400h						// 11111111 decodes to 400h = 1024 

skipa:
	mov 	[L_Bits], ecx					//  update bits used
	 xor 	ebx, ebx

	mov 	[L_CumRun], ebx					// save total run (starts with zero)
	 mov 	[edi], eax						// save decoded DC coefficient

	mov 	[edi+4], ebx					// save 0 index
	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for input
	 add 	edi, 8							// update coefficient pointer

//  check for last
	test 	dl, dl							// check for INTRA-DC (block type=0)
	 jz		finish							// if only the INTRADC present


//
// Get Next Coefficient
//
//	prior codes prepares ebx and ecx as follows:
//		ebx = L_Bits>>3
//		ecx = L_Bits
//

get_next_coefficient:
//  use dword load & bitswap to achieve big endian ordering
	mov 	eax, [esi+ebx]					// *** PROBABLE MALALIGNMENT ***
	 and 	ecx, 7							// shift value

	bswap	eax								// big endian order
											// *** NOT PAIRABLE ***

	shl 	eax, cl							// left justify buffer
											// *** NOT PAIRABLE ***
											// *** 4 CYCLES ***
 	
//  do table lookups
	mov 	ebx, eax						// ebx for major table
	 mov 	ecx, eax						// ecx for minor table

	shr 	ebx, 24							// major table lookup

	shr 	ecx, 17							// minor table lookup in bits with garbage
	 mov 	ebx, [gTAB_TCOEFF_MAJOR+4*ebx]	// get the major table value
											// ** AGI **

	shr 	ebx, 1							// test major hit ?
	 jnc 	skipb							// if hit major

	and 	ecx, 0ffch						// mask off garbage for minor table
	 test 	ebx, ebx						// escape code value was 0x00000001

	jz 		escape_code						// handle escape by major table.

	mov 	ebx, [gTAB_TCOEFF_MINOR+ecx]	// use minor table
											 
//
//  input is ebx = event.  See function header for the meaning of its fields
//  now we decode the event, extracting the run, value, last.
//  The table value moves to ecx and is shifted downward as portions
//  are extracted to ebx. 
//
skipb:	
	mov 	ecx, ebx						// ecx = table value
	 and 	ebx, 0ffh						// ebx = 2*abs(level) + sign

	shr 	ecx, 8							// run to bottom
	 mov 	edx, [L_Quantizer64]			// edx = 64*quant

											//  ** PREFIX DELAY **
											//  ** AGI **
	mov 	ax, [gTAB_INVERSE_Q+edx+2*ebx]	// ax = dequantized value (I16)
	 mov 	ebx, ecx						// ebx = table value

	shl 	eax, 16							// shift value until sign bit is on top
	 and 	ebx, 0ffh						// ebx = run + 1

	sar 	eax, 16							// arithmetic shift extends value's sign
	 mov 	edx, [L_CumRun]					// edx = (old) cumulative run

	add 	edx, ebx						// cumulative run += run + 1
	 mov 	[edi], eax						// save coefficient's signed value

	cmp 	edx, 03fh						// check run for bitstream error
	 jg 	error

	mov 	[L_CumRun], edx					// update the cumulative run
	 inc 	ebp								// increment number of coefficients read

											//  ** AGI **
	mov 	edx, [gTAB_ZZ_RUN+4*edx]		// edx = index of the current coefficient
 	 mov 	ebx, ecx						// ebx:  bit 8 = last flag

	mov 	[edi+4], edx					// save coefficient's index
	 add 	edi, 8							// increment coefficient pointer

	shr 	ecx, 9							// ecx = bits decoded
 	 mov 	edx, [L_Bits]					// edx = L_Bits

	add 	ecx, edx						// L_Bits += bits decoded
	 mov 	edx, ebx						// ebx:  bit 8 = last flag

	mov 	[L_Bits], ecx					// update L_Bits
	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for bitstream load
	 test	edx, 100h						// check for last

	jz  	get_next_coefficient	 	
			

finish:
	mov 	ecx, [P_num]   					// pointer to number of coeffients read
	 mov 	eax, [L_Bits]					// return total bits used

	pop 	ebx								
	 pop 	edi

	mov 	[ecx], ebp						// store number of coefficients read
	 pop 	esi

	pop 	ebp
	 ret


//
// process escape code separately
//
//	we have the following 4 cases to compute the reconstructed value
//	depending on the sign of L=level and the parity of Q=quantizer:
//
//				L pos		L neg
//	Q even		2QL+(Q-1)	2QL-(Q-1)
//	Q odd		2QL+(Q)		2QL-(Q)
//
//	The Q or Q-1 term is formed by adding Q to its parity bit 
//	and then subtracting 1.
//	The + or - on this term is gotten by anding the term with a
//	mask (=0 or =-1) formed from the sign bit of Q*L,
//	doubling the result, then subtracting it from the term.
//	This will negate the term when L is negative and leave
//	it unchanged when L is positive.
//	
//	Register usages:
//		eax		starts with bitstream, later L, finally result
//		ebx		starts with Q, later is the Q or Q-1 term
//		ecx		startw with mask, later 2*term
//		edx		bitstream
//
escape_code:								
	mov 	edx, eax						// edx = bitstream buffer

	shl 	eax, 14							// signed 8-bit level to top

	sar 	eax, 24							// eax = L (signed level)
	 mov 	ebx, [L_Quantizer]

	test	eax, 7fh						// test for invalid codes
	 jz  	error

	imul	eax, ebx						// eax = Q*L
											// *** NOT PAIRABLE ***
											// *** 10 cycles ***

	dec 	ebx								// term = Q-1
	 mov 	ecx, eax						// mask = QL

	or  	ebx, 1							// term = Q-1 if Q even, else = Q
	 sar 	ecx, 31							// mask = -1 if L neg, else = 0

	xor 	ebx, ecx						// term = ~Q[-1] if L neg, else = Q[-1]
	 add 	eax, eax						// result = 2*Q*L

	sub 	ebx, ecx						// term = -(Q[-1]) if L neg, else = Q[-1]
	 mov 	ecx, edx						// bitstream to ecx to get run

	add 	eax, ebx						// result = 2QL +- Q[-1]

//  now clip to -2048 ... +2047 (12 bits:  0xfffff800 <= res <= 0x000007ff)
	cmp 	eax, -2048
	 jge 	skip1

	mov 	eax, -2048
	 jmp	skip2

skip1:
	cmp 	eax, +2047
	 jle  	skip2

	mov 	eax, 2047

skip2:
//  update run and compute index

	shr 	ecx, 18							// run to bottom
 	 mov 	ebx, [L_CumRun]					// ebx = old total run

	and 	ecx, 3fh						// mask off bottom 6 bits for run
	 inc 	ebx								// old run ++

	add 	ebx, ecx						// ebx = new cumulative run
 	 mov 	[edi], eax						// save coefficient's signed value

	cmp 	ebx, 03fh						// check run for bitstream error
	 jg 	error

  	mov 	[L_CumRun], ebx					// update the cumulative run
	 mov 	ecx, [L_Bits]					// ebx = number of bits used

	mov 	ebx, [gTAB_ZZ_RUN+4*ebx]		// ebx = index of the current coefficient
	add 	ecx, 22							// escape code uses 22 bits

	mov 	[edi+4], ebx					// save coefficient's index
	 add 	edi, 8							// increment coefficient pointer

	mov 	[L_Bits], ecx					// update number of bits used
 	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for bitstream load
	 inc 	ebp								// increment number of coefficients read

	test 	edx, 01000000h					// check last bit
	 jz  	get_next_coefficient	 	

	jmp 	finish

				
error:
	pop		ebx								
	 pop 	edi

	pop		esi
	 pop 	ebp

	xor 	eax, eax						// zero bits used indicates ERROR
	 ret

 }

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3coltbl.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// D3COLTBL.C - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.  This file was
//			    taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d3coltbl.c_v   1.3   27 Dec 1995 14:36:04   RMCKENZX  $
//
// $Log:   S:\h26x\src\dec\d3coltbl.c_v  $
;// 
;//    Rev 1.3   27 Dec 1995 14:36:04   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   03 Nov 1995 11:49:44   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.1   30 Oct 1995 17:15:42   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.0   23 Aug 1995 12:22:28   DBRUCKS
// Initial revision.

#include "precomp.h"

#pragma data_seg ("H26xColorConvertorTbl")
#ifdef WIN32
extern
#endif

T_H26xColorConvertorTables H26xColorConvertorTables = {

{ // UVDitherLine01 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00001A00, 0x00001A00, 0x1A001A00,
  0x1A001A00, 0x1A1A1A00, 0x1A1A1A00, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A341A, 0x1A1A341A, 0x341A341A,
  0x341A341A, 0x3434341A, 0x3434341A, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // UVDitherLine23 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x0000001A, 0x0000001A, 0x001A001A,
  0x001A001A, 0x1A1A001A, 0x1A1A001A, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A1A34, 0x1A1A1A34, 0x1A341A34,
  0x1A341A34, 0x34341A34, 0x34341A34, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // YDither (for CLUT8)
  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25
},
{ 0 }, // Padding1
{ // YDitherZ2 (for CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00010000, 0x00010000, 0x00010001,
  0x00010001, 0x00010101, 0x00010101, 0x01010101,
  0x01010101, 0x01020101, 0x01020101, 0x01020102,
  0x01020102, 0x01020202, 0x01020202, 0x02020202,
  0x02020202, 0x02030202, 0x02030202, 0x02030203,
  0x02030203, 0x02030303, 0x02030303, 0x03030303,
  0x03030303, 0x03040303, 0x03040303, 0x03040304,
  0x03040304, 0x03040404, 0x03040404, 0x04040404,
  0x04040404, 0x04050404, 0x04050404, 0x04050405,
  0x04050405, 0x04050505, 0x04050505, 0x05050505,
  0x05050505, 0x05060505, 0x05060505, 0x05060506,
  0x05060506, 0x05060606, 0x05060606, 0x06060606,
  0x06060606, 0x06070606, 0x06070606, 0x06070607,
  0x06070607, 0x06070707, 0x06070707, 0x07070707,
  0x07070707, 0x07080707, 0x07080707, 0x07080708,
  0x07080708, 0x07080808, 0x07080808, 0x08080808,
  0x08080808, 0x08090808, 0x08090808, 0x08090809,
  0x08090809, 0x08090909, 0x08090909, 0x09090909,
  0x09090909, 0x090A0909, 0x090A0909, 0x090A090A,
  0x090A090A, 0x090A0A0A, 0x090A0A0A, 0x0A0A0A0A,
  0x0A0A0A0A, 0x0A0B0A0A, 0x0A0B0A0A, 0x0A0B0A0B,
  0x0A0B0A0B, 0x0A0B0B0B, 0x0A0B0B0B, 0x0B0B0B0B,
  0x0B0B0B0B, 0x0B0C0B0B, 0x0B0C0B0B, 0x0B0C0B0C,
  0x0B0C0B0C, 0x0B0C0C0C, 0x0B0C0C0C, 0x0C0C0C0C,
  0x0C0C0C0C, 0x0C0D0C0C, 0x0C0D0C0C, 0x0C0D0C0D,
  0x0C0D0C0D, 0x0C0D0D0D, 0x0C0D0D0D, 0x0D0D0D0D,
  0x0D0D0D0D, 0x0D0E0D0D, 0x0D0E0D0D, 0x0D0E0D0E,
  0x0D0E0D0E, 0x0D0E0E0E, 0x0D0E0E0E, 0x0E0E0E0E,
  0x0E0E0E0E, 0x0E0F0E0E, 0x0E0F0E0E, 0x0E0F0E0F,
  0x0E0F0E0F, 0x0E0F0F0F, 0x0E0F0F0F, 0x0F0F0F0F,
  0x0F0F0F0F, 0x0F100F0F, 0x0F100F0F, 0x0F100F10,
  0x0F100F10, 0x0F101010, 0x0F101010, 0x10101010,
  0x10101010, 0x10111010, 0x10111010, 0x10111011,
  0x10111011, 0x10111111, 0x10111111, 0x11111111,
  0x11111111, 0x11121111, 0x11121111, 0x11121112,
  0x11121112, 0x11121212, 0x11121212, 0x12121212,
  0x12121212, 0x12131212, 0x12131212, 0x12131213,
  0x12131213, 0x12131313, 0x12131313, 0x13131313,
  0x13131313, 0x13141313, 0x13141313, 0x13141314,
  0x13141314, 0x13141414, 0x13141414, 0x14141414,
  0x14141414, 0x14151414, 0x14151414, 0x14151415,
  0x14151415, 0x14151515, 0x14151515, 0x15151515,
  0x15151515, 0x15161515, 0x15161515, 0x15161516,
  0x15161516, 0x15161616, 0x15161616, 0x16161616,
  0x16161616, 0x16171616, 0x16171616, 0x16171617,
  0x16171617, 0x16171717, 0x16171717, 0x17171717,
  0x17171717, 0x17181717, 0x17181717, 0x17181718,
  0x17181718, 0x17181818, 0x17181818, 0x18181818,
  0x18181818, 0x18191818, 0x18191818, 0x18191819,
  0x18191819, 0x18191919, 0x18191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919
},
#if WIN32
{ 0 }, // RValLo       (for RGB16)
{ 0 }, // GValLo       (for RGB16)
{ 0 }, // BValLo       (for RGB16)
{ 0 }, // RValHi       (for RGB16)
{ 0 }, // GValHi       (for RGB16)
{ 0 }, // BValHi       (for RGB16)
{ 0 }, // Padding2
{ 0 }, // UVContrib    (for RGB16)
{ 0 }, // RValZ2       (for RGB16ZoomBy2)
{ 0 }, // GValZ2       (for RGB16ZoomBy2)
{ 0 }, // BValZ2       (for RGB16ZoomBy2)
{ 0 }, // Padding3
{ 0 }, // B24Value     (for RGB24)
{ 0 }, // Padding4
{ 0 }, // UV24Contrib  (for RGB24)
#endif
0 };

#pragma data_seg ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\ctiming.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * ctiming.h
 *
 * DESCRIPTION:
 *		Common timing functions.  
 *
 *		I extracted this code from meantime.h in HQV's decode directory.
 */

// $Header:   S:\h26x\src\common\ctiming.h_v   1.2   26 Dec 1995 17:43:06   DBRUCKS  $
// $Log:   S:\h26x\src\common\ctiming.h_v  $
;// 
;//    Rev 1.2   26 Dec 1995 17:43:06   DBRUCKS
;// changed bTimerIsOn to bTimerIsActive
;// 
;//    Rev 1.1   26 Dec 1995 12:40:54   DBRUCKS
;// added higher level macros to simplify use
;// 
;//    Rev 1.0   20 Dec 1995 15:06:14   DBRUCKS
;// Initial revision.

#ifndef __CTIMING_H__
#define __CTIMING_H__

/* The following timing overhead numbers were generated by Tom Walsh
 * based on static variables for startlow, starthigh, and elapsed.
 * 
 * When timing sections of code with low clock numbers be careful to
 * minimize the timing overhead.  Store the sub totals to a stack variable
 * instead of to the instance via a pointer indirection and offset.
 */
#define P5TIMING_OVERHEAD 13
#define P6TIMING_OVERHEAD 33

/* Low Level Macros
 */
#define __RDTSC__ __asm { __asm __emit 0Fh __asm __emit 31h }

#define STARTCLOCK(startlow,starthigh) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm mov	startlow,	eax	\
		__asm mov	starthigh,	edx	\
	} \
}

#define STOPCLOCKP5(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P5TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

#define STOPCLOCKP6(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P6TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

/* High Level Macros
 *
 * Call TIMER_START and TIMER_STOP in the main function that you wish to time.
 * TIMER_BEFORE and TIMER_AFTER should be used inside of that main function.
 * Fo example:
 *
 *		TIMER_START
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *		TIMER_STOP
 * 
 * Variable Definitions
 *		U32 uStartLow;		 // temporary set in TIMER_START 
 *		U32 uStartHigh;		 // temporary set in TIMER_START
 *		U32 uElapsed;		 // temporary used in TIMER_AFTER_*
 *		U32 uBefore;		 // temporary used in TIMER_BEFORE and TIMER_AFTER_*
 *		U32 uResult;		 // result variable
 * 		int bTimerIsActive   // boolean - true if timing this frame
 *
 * WARNING: TIMER_AFTER_P5 and TIMER_AFTER_P6 add to the result variable.
 */
#define	TIMER_START(bTimerIsActive,uStartLow,uStartHigh) \
{ \
	bTimerIsActive = 1; \
	STARTCLOCK(uStartLow,uStartHigh); \
}

#define TIMER_BEFORE(bTimerIsActive,uStartLow,uStartHigh,uBefore) \
{ \
	if (bTimerIsActive)	\
	{	\
		STOPCLOCKP5(uStartLow,uStartHigh,uBefore); \
	} \
}

#define TIMER_AFTER_P5(bTimerIsActive,uStartLow,uStartHigh,uBefore,uElapsed,uResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(uStartLow,uStartHigh,uElapsed); \
		uResult += uElapsed - uBefore;	    \
	} \
}

#define TIMER_STOP(bTimerIsActive,uStartLow,uStartHigh,uResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(uStartLow,uStartHigh,uResult);	\
	} \
}

#endif /* __CTIMING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3color.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
//  D3COLOR.CPP - the color conveter interface routines.  This code was
//                copied from COLOR.C in MRV.

// $Header:   S:\h26x\src\dec\d3color.cpv   1.30   16 Dec 1996 13:52:50   MDUDA  $
//
// $Log:   S:\h26x\src\dec\d3color.cpv  $
// 
//    Rev 1.30   16 Dec 1996 13:52:50   MDUDA
// Adjusted output color convertor table to account for H263' problem
// with MMX output color convertors (MMX width must be multiple of 8).
// 
//    Rev 1.29   09 Dec 1996 18:01:54   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.28   06 Dec 1996 09:25:20   BECHOLS
// Mike fixed bug where CCOffsetToLine0 was unitialized.
// 
//    Rev 1.27   29 Oct 1996 13:37:22   MDUDA
// Provided MMX YUY2 output color converter support.
// 
//    Rev 1.26   20 Oct 1996 13:20:04   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.25   10 Sep 1996 10:31:42   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.24   06 Sep 1996 16:09:30   BNICKERS
// Added Pentium Pro functions to list of color convertors.
// 
//    Rev 1.23   18 Jul 1996 09:26:58   KLILLEVO
// 
// implemented YUV12 color convertor (pitch changer) as a normal
// color convertor function (in assembly), via the 
// ColorConvertorCatalog() call.
// 
//    Rev 1.22   19 Jun 1996 14:29:24   RHAZRA
// 
// Added the YUY2 color convertor init function and the YUV12ToYUY2 
// function pointer to the color convertor catalog
// 
//    Rev 1.21   14 Jun 1996 17:26:50   AGUPTA2
// Updated the color convertor table.
// 
//    Rev 1.20   30 May 1996 15:16:42   KLILLEVO
// added YUV12 output
// 
//    Rev 1.19   30 May 1996 11:26:24   AGUPTA2
// Added support for MMX color convertors.
// 
//    Rev 1.18   01 Apr 1996 10:26:12   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.17   16 Feb 1996 15:12:24   BNICKERS
// Correct color shift.
// 
//    Rev 1.16   05 Feb 1996 13:35:42   BNICKERS
// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
// 
//    Rev 1.15   11 Jan 1996 14:04:30   RMCKENZX
// Added support for stills - in particular computations
// for the Offset To Line Zero for the 320x240 still frame size.
// 
//    Rev 1.14   08 Jan 1996 11:01:52   RMCKENZX
// Axed the warning messages:
//   -9999 is now 0xdead,
//   -9999*2 is now 0xbeef.
// 
//    Rev 1.13   27 Dec 1995 14:36:02   RMCKENZX
// Added copyright notice
// 
//    Rev 1.12   10 Nov 1995 15:05:54   CZHU
// 
// increased the table size of CLUT8 tables for active palette
// 
//    Rev 1.11   10 Nov 1995 14:44:28   CZHU
// 
// Moved functions computing dynamic CLUT table for Active 
// Palette into file dxap.cpp
// 
//    Rev 1.10   03 Nov 1995 11:49:42   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.9   31 Oct 1995 11:48:42   TRGARDOS
// 
// Fixed exception by not trying to free a zero handle.
// 
//    Rev 1.8   30 Oct 1995 17:15:36   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.7   27 Oct 1995 17:30:56   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.6   26 Oct 1995 18:54:38   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.5   26 Oct 1995 11:24:34   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.4   25 Oct 1995 18:05:30   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.3   19 Sep 1995 16:04:08   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.2   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.1   25 Aug 1995 13:58:04   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.0   23 Aug 1995 12:21:48   DBRUCKS
// Initial revision.

// Notes:
// * The H26X decoders use the MRV color converters.  In order to avoid 
//   unnecessary modification the function names were not changed.

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
char gsz4[32];
char gsz5[32];
char gsz6[32];
char gsz7[32];
#endif

extern LRESULT CustomChangeBrightness(LPDECINST, BYTE);
extern LRESULT CustomChangeContrast(LPDECINST, BYTE);
extern LRESULT CustomChangeSaturation(LPDECINST, BYTE);

/***********************************************************************
 *  Note: The YVU12ForEnc color converter is special as it needs different 
 *        parameters.  YUV12Enc, CLUT8AP, and IFO9 use IA version of color 
 *        convertors (marked by *****) either because they have not been written 
 *        or tested.  Entries for DCI color convertors is legacy code.  DCI and
 *        non-DCI color convertors are the same but they used to be different.
 *        In each table entry, the first ptr is to the init function, and the
 *        struc has three ptrs to three processor specific implementations -
 *        Pentium, PentiumPro, and MMX in that order - of the color convertor.
 **********************************************************************/
#ifdef USE_MMX // { USE_MMX
#ifdef H263P // { H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
	//  YUV12Enc  *****
	{ &H26X_YVU12ForEnc_Init,
		{	NULL,					NULL,					NULL,
			NULL,					NULL,					NULL							}},
	//  CLUT8
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&MMX_YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
	//  CLUT8DCI
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&MMX_YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
    //  CLUT8ZoomBy2
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2	}},
    //  CLUT8ZoomBy2DCI
	{ &H26X_CLUT8_Init,  
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2	}},
	//  RGB24
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&MMX_YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&MMX_YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24ZoomBy2
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2	}},
    //  RGB24ZoomBy2DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2	}},
    //  RGB16555
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16555ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  IF09  *****
	{ &H26X_CLUT8_Init,
		{	&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09,
			&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09				}},
    //  RGB16664
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16664ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16565
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16565ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16655
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16655ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  CLUT8APDCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP,
			&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP				}},
    //  CLUT8APZoomBy2DCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2,
			&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2			}},
    //  RGB32
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&MMX_YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&MMX_YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32ZoomBy2
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2	}},
    //  RGB32ZoomBy2DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2	}},
	// YUV12 Color Convertor
	{ &H26X_YUV_Init,  
		{	&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV,
			&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV					}},
	// YUY2 Color Convertor
	{ &H26X_YUY2_Init,
		{	&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&MMX_YUV12ToYUY2,
			&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&MMX_YUV12ToYUY2			}}
};
#else // }{ H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
    //  YUV12Enc  *****
  { &H26X_YVU12ForEnc_Init,
    { NULL,              NULL,               NULL                  }},
    //  CLUT8
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &MMX_YUV12ToCLUT8      }},
    //  CLUT8DCI
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &MMX_YUV12ToCLUT8      }},
    //  CLUT8ZoomBy2
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &MMX_YUV12ToCLUT8ZoomBy2  }},
    //  CLUT8ZoomBy2DCI
  { &H26X_CLUT8_Init,  
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &MMX_YUV12ToCLUT8ZoomBy2  }},
    //  RGB24
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &MMX_YUV12ToRGB24      }},
    //  RGB24DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &MMX_YUV12ToRGB24      }},
    //  RGB24ZoomBy2
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &MMX_YUV12ToRGB24ZoomBy2  }},
    //  RGB24ZoomBy2DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &MMX_YUV12ToRGB24ZoomBy2  }},
    //  RGB16555
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16555DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16555ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16555ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  IF09  *****
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
    //  RGB16664
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16664DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16664ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16664ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16565
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16565DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16565ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16565ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16655
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &MMX_YUV12ToRGB16 }},
    //  RGB16655DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &MMX_YUV12ToRGB16 }},
    //  RGB16655ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16655ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  CLUT8APDCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
    //  CLUT8APZoomBy2DCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2 }},
    //  RGB32
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &MMX_YUV12ToRGB32      }},
    //  RGB32DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &MMX_YUV12ToRGB32      }},
    //  RGB32ZoomBy2
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &MMX_YUV12ToRGB32ZoomBy2  }},
    //  RGB32ZoomBy2DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &MMX_YUV12ToRGB32ZoomBy2  }},
  { &H26X_YUV_Init,  
    { &YUV12ToYUV,          &YUV12ToYUV,            &YUV12ToYUV             }},
	// YUY2 Color Convertor
  {	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &MMX_YUV12ToYUY2           }}
};
#endif // } H263P
#else // }{ USE_MMX
#ifdef H263P // { H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
	//  YUV12Enc  *****
	{ &H26X_YVU12ForEnc_Init,
		{	NULL,					NULL,					NULL,
			NULL,					NULL,					NULL							}},
	//  CLUT8
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
	//  CLUT8DCI
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
    //  CLUT8ZoomBy2
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2	}},
    //  CLUT8ZoomBy2DCI
	{ &H26X_CLUT8_Init,  
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2	}},
	//  RGB24
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24ZoomBy2
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2	}},
    //  RGB24ZoomBy2DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2	}},
    //  RGB16555
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16555ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  IF09  *****
	{ &H26X_CLUT8_Init,
		{	&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09,
			&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09				}},
    //  RGB16664
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16664ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16565
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16565ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16655
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16655ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  CLUT8APDCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP,
			&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP				}},
    //  CLUT8APZoomBy2DCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2,
			&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2			}},
    //  RGB32
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32ZoomBy2
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2	}},
    //  RGB32ZoomBy2DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2	}},
	// YUV12 Color Convertor
	{ &H26X_YUV_Init,  
		{	&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV,
			&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV					}},
	// YUY2 Color Convertor
	{ &H26X_YUY2_Init,
		{	&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&YUV12ToYUY2,
			&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&YUV12ToYUY2			}}
};
#else // }{ H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
    //  YUV12Enc  *****
  { &H26X_YVU12ForEnc_Init,
    { NULL,              NULL,               NULL                  }},
    //  CLUT8
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &YUV12ToCLUT8      }},
    //  CLUT8DCI
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &YUV12ToCLUT8      }},
    //  CLUT8ZoomBy2
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2  }},
    //  CLUT8ZoomBy2DCI
  { &H26X_CLUT8_Init,  
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2  }},
    //  RGB24
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &YUV12ToRGB24      }},
    //  RGB24DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &YUV12ToRGB24      }},
    //  RGB24ZoomBy2
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2  }},
    //  RGB24ZoomBy2DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2  }},
    //  RGB16555
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16555DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16555ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16555ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  IF09  *****
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
    //  RGB16664
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16664DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16664ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16664ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16565
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16565DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16565ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16565ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16655
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16 }},
    //  RGB16655DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16 }},
    //  RGB16655ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16655ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  CLUT8APDCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
    //  CLUT8APZoomBy2DCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2 }},
    //  RGB32
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &YUV12ToRGB32      }},
    //  RGB32DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &YUV12ToRGB32      }},
    //  RGB32ZoomBy2
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2  }},
    //  RGB32ZoomBy2DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2  }},
  { &H26X_YUV_Init,  
    { &YUV12ToYUV,          &YUV12ToYUV,            &YUV12ToYUV             }},
	// YUY2 Color Convertor
  {	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &YUV12ToYUY2           }}
};
#endif // } H263P
#endif // } USE_MMX

/*******************************************************************************
 *  H263InitColorConvertorGlobal
 *    This function initializes the global tables used by the MRV color 
 *    convertors.
 *******************************************************************************/
LRESULT H263InitColorConvertorGlobal ()
{
	return ICERR_OK;
}


/******************************************************************************
 *  H26X_Adjust_Init
 *    This function builds the adjustment tables for a particular instance of 
 *    a color convertor based on values in the decoder instance to which this 
 *    color convertor instance is attached. The external functions are located 
 *    in CONTROLS.C. -BEN-
 *****************************************************************************/
LRESULT H26X_Adjust_Init(LPDECINST lpInst, T_H263DecoderCatalog FAR *DC)
{
	LRESULT lRet=ICERR_OK;

	lRet = CustomChangeBrightness(lpInst, (BYTE)DC->BrightnessSetting);
	lRet |= CustomChangeContrast(lpInst, (BYTE)DC->ContrastSetting);
	lRet |= CustomChangeSaturation(lpInst, (BYTE)DC->SaturationSetting);

	return(lRet);
}

/******************************************************************************
 *  H263InitColorConvertor
 *    This function initializes a color convertor.
 *****************************************************************************/
LRESULT H263InitColorConvertor(LPDECINST lpInst, UN ColorConvertor)
{    
	LRESULT                    ret = ICERR_OK;
	T_H263DecoderCatalog FAR * DC;

#ifdef H263P
	U32 uTmpFrameWidth;
	U32 uTmpFrameHeight;
#endif

	FX_ENTRY("H263InitColorConvertor")

	DEBUGMSG (ZONE_INIT, ("%s()...\r\n", _fx_));

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: return ICERR_BADPARAM\r\n", _fx_));
		return ICERR_BADPARAM;
	}
	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		return ICERR_ERROR;
	}

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

#ifdef H263P
	// DC->uFrameWidth and DC->uFrameHeight are the padded frame dimensions
	// to multiples of 16 (padding done to the right and bottom). The padded
	// dimensions correspond to the size of the image actually encoded.
	// The color converters need to use the non-padded frame dimensions instead,
	// since the application based a buffer equal to the active frame size.

	// We set these values to the active frame dimensions here instead of
	// altering all of the references to DC->uFrameWidth and DC->uFrameHeight
	// in the (many!) color converters.
	uTmpFrameWidth = DC->uFrameWidth;
	uTmpFrameHeight = DC->uFrameHeight;
	DC->uFrameWidth = DC->uActualFrameWidth;
	DC->uFrameHeight = DC->uActualFrameHeight;
#endif

	// trick the compiler to pass instance info to the color convertor catalog.
	if (ColorConvertor== CLUT8APDCI || ColorConvertor== CLUT8APZoomBy2DCI) 
	{
		// check whether this AP instance is the previous 
		if ((ColorConvertor == DC->iAPColorConvPrev) 
		&& (DC->pAPInstPrev !=NULL) && lpInst->InitActivePalette)
		{ 
			//  ??? check whether the palette is still the same;
			//  DC->h16InstPostProcess = DC->hAPInstPrev;
			ret = H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, TRUE); 
			DEBUGMSG (ZONE_INIT, ("%s: Decided to use previous AP Instance...\r\n", _fx_));
		}
	else
		ret = H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, FALSE); 
	}
	else
	{  
		//  There is a single initializer funtion for Pentium, PentiumPro and 
		//  MMX machines.  The downside is that some data structures that will
		//  not be  referenced are initialized also.
		ret = ColorConvertorCatalog[ColorConvertor].Initializer (DC, ColorConvertor);
	}

	if (ColorConvertor != YUV12ForEnc)
		ret |= H26X_Adjust_Init(lpInst, DC);
	DC->ColorConvertor = ColorConvertor;

#ifdef H263P
	// Revert back to the padded dimensions.
	DC->uFrameWidth = uTmpFrameWidth;
	DC->uFrameHeight = uTmpFrameHeight;
#endif

	return ret;
}


/******************************************************************************
 *  H263TermColorConvertor
 *    This function deallocates a color convertor.
 *****************************************************************************/
LRESULT H263TermColorConvertor(LPDECINST lpInst)
{    
	T_H263DecoderCatalog FAR * DC;

	FX_ENTRY("H263TermColorConvertor")

	DEBUGMSG (ZONE_INIT, ("%s().....TERMINATION...\r\n", _fx_));

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: return ICERR_BADPARAM\r\n", _fx_));
		return ICERR_BADPARAM;
	}
	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		return ICERR_ERROR;
	}

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	// save the active palette instance for future use
	if ((DC->ColorConvertor == CLUT8APDCI) 
	|| (DC->ColorConvertor ==  CLUT8APZoomBy2DCI))
	{
		DC->iAPColorConvPrev=DC->ColorConvertor;
		DC->pAPInstPrev = DC->_p16InstPostProcess;
		DEBUGMSG (ZONE_INIT, ("%s: Saved Previous AP instance...\r\n", _fx_));
	}
	else
	{
		if(DC->_p16InstPostProcess != NULL)
		{
			HeapFree(GetProcessHeap(),0,DC->_p16InstPostProcess);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)DC->_p16InstPostProcess);
#endif
			DC->_p16InstPostProcess = NULL;
		}
	}    

	DC->ColorConvertor = 0;  
	DC->p16InstPostProcess = NULL;
	return ICERR_OK;
}

/***********************************************************************
 *  H26x_YUY2_Init function
 **********************************************************************/
LRESULT H26X_YUY2_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  i;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_YUY2_Init")

	switch (ColorConvertor)
	{
	case YUY2DDRAW:
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
		// This offset not used.  But if it was...  This first entry will not invert.
		DC->CCOffsetToLine0 = 0;
		// this second entry will invert the image.
		/*DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L; */
		DC->CCOutputPitch = 0;
		DC->CCOffset320x240 = 305920/2;		// (240-1) * 320 * 2;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz1);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	// Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	// Space for post processing Y, U, and V frames.

	DC->PostFrame.X32_YPlane = Offset +
	(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	Sz_SpaceBeforeYPlane :
	Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

    DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}

/***********************************************************************
 *  H26x_YUV_Init function
 ***********************************************************************/
LRESULT H26X_YUV_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	FX_ENTRY("H26X_YUV_Init")

	//int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  i;
	U8   FAR  * InitPtr;

	switch (ColorConvertor)
	{
	case YUV12NOPITCH:
		//IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOffset320x240 = 305920/2;		// (240-1) * 320 * 2;
		DC->CCOffsetToLine0 = 0;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz2);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_CLUT8_Init
 *    This function initializes for the CLUT8 color convertors.
 *****************************************************************************/
LRESULT H26X_CLUT8_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
	LRESULT ret;
	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	int  i;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_CLUT8_Init")

	switch (ColorConvertor)
	{
	case CLUT8:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;       // (240-1) * 320;
		break;

	case CLUT8DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;      // (240-1) * 320;
		break;

	case CLUT8ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;     // (2*240-1) * (2*320);
		break;

	case CLUT8ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef; /* ??? */
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;     // (2*240-1) * (2*320);
		break;

	case IF09:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;     // (240-1) * 320;
		break; 

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + /* brightness, contrast, saturation */
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? //fixfix
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz3);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with one extra max-width 
	//  line  above for color conversion's scratch space for UVDitherPattern 
	//  indices.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB32_Init
 *    This function initializes for the RGB32 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB32_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	U8   FAR  * PRGBValue;
	U32  FAR  * PUVContrib;
	int   i;
	I32  ii,jj;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_RGB32_Init")

	switch (ColorConvertor)
	{
	case RGB32:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
		DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
		break;

	case RGB32DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; // ??? 
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
		DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
		break;

	case RGB32ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 12;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 4L;
		DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
		break;

	case RGB32ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) (0xbeef);
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 4L;
		DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz4, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz4);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with four extra 
	//  max-width lines  above for color conversion's scratch space for 
	//  preprocessed chroma data.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	// Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	//  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRGBValue    = H26xColorConvertorTables.B24Value;
	PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */

	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;// biased U contribution to G
		if (ii < 1) ii = 1;
		if (ii > 83) ii = 83;
		jj = ((113562L*(i-128L))>>17L)+111L + 1L;// biased U contribution to B
		*PUVContrib++ = (ii << 16L) + (jj << 24L);
		ii = ((-45774L*(i-128L))>>16L)+86L;      // biased V contribution to G
		if (ii < 0) ii = 0;
		if (ii > 172) ii = 172;
		jj = (( 89858L*(i-128L))>>16L)+176L + 1L;// biased V to contribution R
		*PUVContrib++ = (ii << 16L) + jj;
	}

	for (i = 0; i < 701; i++)
	{
		ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		PRGBValue[i] = (U8) ii;
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB24_Init
 *    This function initializes for the RGB24 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB24_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	U8   FAR  * PRGBValue;
	U32  FAR  * PUVContrib;
	int   i;
	I32  ii,jj;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_RGB24_Init")

	switch (ColorConvertor)
	{
	case RGB24:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 3;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
		DC->CCOffset320x240 = 229440;     // (240-1) * 320 * 3;
		break;

	case RGB24DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
		DC->CCOffset320x240 = 229440;     // (240-1) * 320 * 3;
		break;

	case RGB24ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 9;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 3L;
		DC->CCOffset320x240 = 919680;     // (2*240-1) * (2*320) * 3;
		break;

	case RGB24ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) (0xbeef);
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 3L;
		DC->CCOffset320x240 = 919680;     // (2*240-1) * (2*320) * 3;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream

	DC->_p16InstPostProcess =	
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz5, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz5);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with four extra max-width
	//  lines above for color conversion's scratch space for preprocessed 
	//  chroma data.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	//  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRGBValue    = H26xColorConvertorTables.B24Value;
	PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */

	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;// biased U contribution to G
		if (ii < 1) ii = 1;
		if (ii > 83) ii = 83;
		jj = ((113562L*(i-128L))>>17L)+111L + 1L;// biased U contribution to B
		*PUVContrib++ = (ii << 16L) + (jj << 24L);
		ii = ((-45774L*(i-128L))>>16L)+86L;      // biased V contribution to G
		if (ii < 0) ii = 0;
		if (ii > 172) ii = 172;
		jj = (( 89858L*(i-128L))>>16L)+176L + 1L;// biased V to contribution R
		*PUVContrib++ = (ii << 16L) + jj;
	}

	for (i = 0; i < 701; i++)
	{
		ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		PRGBValue[i] = (U8) ii;
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB16_Init
 *    This function initializes for the RGB16 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB16_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	int  RNumBits;
	int  GNumBits;
	int  BNumBits;
	int  RFirstBit;
	int  GFirstBit;
	int  BFirstBit;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  TableNumber;

	U8   FAR  * PRValLo;
	U8   FAR  * PGValLo;
	U8   FAR  * PBValLo;
	U8   FAR  * PRValHi;
	U8   FAR  * PGValHi;
	U8   FAR  * PBValHi;
	U32  FAR  * PUVContrib;
	U32  FAR  * PRValZ2;
	U32  FAR  * PGValZ2;
	U32  FAR  * PBValZ2;
	U8   FAR  * InitPtr;
	int  i;
	I32  ii, jj;

	FX_ENTRY("H26X_RGB16_Init")

	switch (ColorConvertor)
	{
	case RGB16555:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16565:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16664:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;   

	case RGB16655:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
         DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) 
                               * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) 
                              * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;   

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList + 
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz6, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz6);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

    /*
     *  Space for post processing Y, U, and V frames, with four extra 
     *  max-width lines above for color conversion's scratch space for 
     *  preprocessed chroma data.
     */

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList =DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	// Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRValLo      = H26xColorConvertorTables.RValLo555;
	PGValLo      = H26xColorConvertorTables.GValLo555;
	PBValLo      = H26xColorConvertorTables.BValLo555;
	PRValHi      = H26xColorConvertorTables.RValHi555;
	PGValHi      = H26xColorConvertorTables.GValHi555;
	PBValHi      = H26xColorConvertorTables.BValHi555;
	PUVContrib   = H26xColorConvertorTables.UVContrib;
	PRValZ2      = H26xColorConvertorTables.RValZ2555;
	PGValZ2      = H26xColorConvertorTables.GValZ2555;
	PBValZ2      = H26xColorConvertorTables.BValZ2555;
	PRValLo      += TableNumber*2048;
	PGValLo      += TableNumber*2048;
	PBValLo      += TableNumber*2048;
	PRValHi      += TableNumber*2048;
	PGValHi      += TableNumber*2048;
	PBValHi      += TableNumber*2048;
	PRValZ2      += TableNumber*1024;
	PGValZ2      += TableNumber*1024;
	PBValZ2      += TableNumber*1024;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */


	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>17L)+22L  + 1L; // biased U contribution to G
		jj = ((113562L*(i-128L))>>17L)+111L + 1L; // biased U contribution to B
		*PUVContrib++ = (ii << 8L) + jj;
		ii = ((-45774L*(i-128L))>>17L)+45L;       // biased V contribution to G
		jj = (( 89858L*(i-128L))>>17L)+88L  + 1L; // biased V to contribution R
		*PUVContrib++ = (ii << 8L) + (jj << 16L);
	}

	for (i = 0; i < 304; i++)
	{
		ii = (((I32) i - 88L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - RNumBits));
		if (jj > 255L) jj = 255L;
		PRValLo[i] = ((U8) ((ii >> (8-RNumBits)) << (RFirstBit-8)));
		PRValHi[i] = ((U8) ((jj >> (8-RNumBits)) << (RFirstBit-8)));
        PRValZ2[i] = ((ii >> (8-RNumBits)) << (RFirstBit   )) |
            ((jj >> (8-RNumBits)) << (RFirstBit+16));
	}

	for (i = 0; i < 262; i++)
	{
		ii = (((I32) i - 67L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - GNumBits));
		if (jj > 255L) jj = 255L;
		PGValLo[i] = ((U8) ((ii >> (8-GNumBits)) << (GFirstBit-4)));
		PGValHi[i] = ((U8) ((jj >> (8-GNumBits)) << (GFirstBit-4)));
        PGValZ2[i] = ((jj >> (8-GNumBits)) << (GFirstBit   )) |
            ((ii >> (8-GNumBits)) << (GFirstBit+16));
	}

	for (i = 0; i < 350; i++)
	{
		ii = (((I32) i - 111L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - BNumBits));
		if (jj > 255L) jj = 255L;
		PBValLo[i] = ((U8) ((ii >> (8-BNumBits)) << (BFirstBit  )));
		PBValHi[i] = ((U8) ((jj >> (8-BNumBits)) << (BFirstBit  )));
        PBValZ2[i] = ((ii >> (8-BNumBits)) << (BFirstBit   )) |
                 ((jj >> (8-BNumBits)) << (BFirstBit+16));
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/****************************************************************************
 *  H26X_YVU12ForEnc_Init
 *    This function initializes for the "color convertor" that provides a 
 *    reconstructed YVU12 image back to the encode
 *****************************************************************************/
LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
  LRESULT ret;

  DC->p16InstPostProcess     = NULL;
  DC->PostFrame.X32_YPlane   = 0xDEADBEEF;
  DC->X32_BEFDescrCopy       =  0xDEADBEEF;
  DC->X32_BEFApplicationList = 0xDEADBEEF;
  DC->PostFrame.X32_VPlane   = 0xDEADBEEF;
  DC->PostFrame.X32_UPlane   = 0xDEADBEEF;

  ret = ICERR_OK;

  return ret;

}

/****************************************************************************
 *  H26X_CLUT8AP_Init
 *    this is just a place holder, the real work is done in H26X_CLUT8AP_InitReal()
 ****************************************************************************/
LRESULT H26X_CLUT8AP_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  return ICERR_OK;
}


LRESULT H26X_CLUT8AP_InitReal(
    LPDECINST lpInst,T_H263DecoderCatalog FAR * DC, 
    UN ColorConvertor, BOOL bReuseAPInst)
{    
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_AdjustmentTables;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_BEFDescrCopy;
	U32  Sz_BEFApplicationList;
	//U32  Sz_UVDitherPattern; 
	U32  Sz_ClutIdxTable;     /* for Active Palette */
	U32  Offset;
	//X32  X32_UVDitherPattern;
	int  i;
	U8   FAR  * InitPtr;
	U8   BIGG * lpClutIdxTable;

	FX_ENTRY("H26X_CLUT8AP_InitReal")

	switch (ColorConvertor)
	{
	/*
	case CLUT8APZoomBy2:
		IsDCI = TRUE; 
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		break;

	case CLUT8AP:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		break;   
	*/
	case CLUT8APZoomBy2DCI:
		IsDCI = TRUE; 
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;		// (2*240-1) * (2*320);
	break;

	case CLUT8APDCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
        DC->CCOffsetToLine0 =  ((U32) (DC->uFrameHeight - 1)) 
                               * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;		// (240-1) * (320);
		break; 

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

    if (((DC->uYActiveWidth > 352) || (DC->uYActiveHeight > 288)) 
        && (DC->DecoderType != YUV12_CODEC))
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		return ICERR_MEMORY;
	}
	else
	{
		Sz_FixedSpace = 0L;       // Locals go on stack; tables staticly alloc
		Sz_AdjustmentTables = 1056L; // Adjustment tables are instance specific
        Sz_ClutIdxTable=65536L+256*2*4; // dynamic CLUT8 tables, 2**14
                                    // and UDither (128*4), VDither(512) tables
        Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
		Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream
		if (!bReuseAPInst ) 
		{
			DC->_p16InstPostProcess =	 
			HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_ClutIdxTable+
			Sz_AdjustmentTables +   
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList+
			31)
			);
			if (DC->_p16InstPostProcess == NULL)
			{
				ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
				ret = ICERR_MEMORY;
				goto  done;
			}

#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			wsprintf(gsz7, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_ClutIdxTable+ Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList+ 31), __LINE__);
			AddName((unsigned int)DC->_p16InstPostProcess, gsz7);
#endif

		}
		else //reuse AP instance
			DC->_p16InstPostProcess = DC->pAPInstPrev;

        DC->p16InstPostProcess =
            (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

		//  Space for tables to adjust brightness, contrast, and saturation.

		Offset = Sz_FixedSpace; 
		//  space for Dynamic CLUT8 tables
		lpClutIdxTable = ( U8 BIGG * ) (DC->p16InstPostProcess + Offset);  
		Offset += Sz_ClutIdxTable; 

		DC->X16_LumaAdjustment   = ((U16) Offset);
		DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
		Offset += Sz_AdjustmentTables;  

		//  Space for post processing Y, U, and V frames, with one extra 
		//  max-width line above for color conversion's scratch space for 
		//  UVDitherPattern indices.
		DC->PostFrame.X32_YPlane = Offset +  
		                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
		                            Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy);
		//   Offset + (Sz_BEFDescrCopy < 648L*4L ? 648L*4L : Sz_BEFDescrCopy);
		Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
		if (DC->DecoderType == H263_CODEC)
		{
			DC->PostFrame.X32_VPlane = Offset;
			DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
		}
		else
		{
			DC->PostFrame.X32_UPlane = Offset;
            DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                       + DC->uSz_VUPlanes/2;
		}
		Offset += DC->uSz_VUPlanes;

		//  Space for copy of BEF Descriptor.

		DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

		//  Space for BEFApplicationList.

		//Offset += DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
		DC->X32_BEFApplicationList = DC->X16_BlkActionStream;
	}

	if (!bReuseAPInst)
	{  
		//  Init tables to adjust brightness, contrast, and saturation.
		DC->bAdjustLuma   = FALSE;
		DC->bAdjustChroma = FALSE;
		InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		InitPtr += 16;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		InitPtr += 16;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;       

		/*
		 * compute the dynamic ClutIdxTable
		 * ComputeDynamicClut(lpClutIdxTable, pInst->ActivePalette,256);  
		 */                                  
        ComputeDynamicClutNew(lpClutIdxTable,(U8 FAR *)(lpInst->ActivePalette),
                              sizeof(lpInst->ActivePalette));
	}


	ret = ICERR_OK;
done:  
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3bef.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

/* map of coded and not-coded blocks */
extern char coded_map[][22+1]; 
/* QP map */
extern char QP_map[][22];

#if defined(H263P) // { if defined(H263P)
/* table for de-blocking filter */
/* currently requires 2048 bytes */ 
signed char dxQP[64][32];

#if 0 // { 0

static void HorizEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

int i, j, k;
int d, delta;
int mbc;
int mod_div = 1 << shift;
unsigned char *r = rec + (pitch << 3);
unsigned char *r_2 = r - (pitch << 1);
unsigned char *r_1 = r - pitch;
unsigned char *r1 = r + pitch;
char *pcoded_row0 = &coded_map[8>>shift][0];
char *pcoded_row1 = pcoded_row0 + sizeof(coded_map[0]);
char *pQP_map = &QP_map[0][0];

	for (j = 8; j < height; ) {
		for (i = 0; i < width; i += 8) {
			mbc = i >> shift;
			if (pcoded_row0[mbc+1] || pcoded_row1[mbc+1]) {
				for (k = i; k < i+8; k++) {
					d = (r_2[k]+(r_2[k]<<1)-(r_1[k]<<3)+(r[k]<<3)-(r1[k]+(r1[k]<<1)))>>4;
					if (d && (d >= -32) && (d < 32)) {
						delta = dxQP[d+32][pQP_map[mbc]];
						r[k] = ClampTbl[r[k]-delta+CLAMP_BIAS];
						r_1[k] = ClampTbl[r_1[k]+delta+CLAMP_BIAS];
					}
				}
			}
		}
		r_2  += (pitch<<3);
		r_1  += (pitch<<3);
		r    += (pitch<<3);
		r1   += (pitch<<3);
		if (0 == ((j+=8)%mod_div)) {
			pcoded_row0 += sizeof(coded_map[0]);
			pcoded_row1 += sizeof(coded_map[0]);
			pQP_map += sizeof(QP_map[0]);
		}
	}
}

static void VertEdgeFilter(unsigned char *rec,
                           int width,
                           int height,
                           int pitch,
						   int shift) {

unsigned char *r = rec;
int i, j, k;
int mbc;
int d, delta;
int mod_div = 1 << shift;
char *pcoded_row1 = &coded_map[1][0];
char *pQP_map = &QP_map[0][0];

	for (j = 0; j < height; ) {
		for (i = 8; i < width; i += 8) {
			mbc = i >> shift;
			if (pcoded_row1[mbc] || pcoded_row1[mbc+1]) {
				for (k = 0; k < 8; k++) {
					d = (r[i-2]+(r[i-2]<<1)-(r[i-1]<<3)+(r[i]<<3)-(r[i+1]+(r[i+1]<<1)))>>4;
					if (d && (d > -32) && (d < 32)) {
						delta = dxQP[d+32][pQP_map[mbc]];
						r[i] = ClampTbl[r[i]-delta+CLAMP_BIAS];
						r[i-1] = ClampTbl[r[i-1]+delta+CLAMP_BIAS];
					}
					r += pitch;
				}
				r -= pitch<<3;
			}
		}
		r += pitch<<3;
		if (0 == ((j+=8)%mod_div)) {
			pcoded_row1 += sizeof(coded_map[0]);
			pQP_map += sizeof(QP_map[0]);
		}
	}
}

#else // }{ 0

__declspec(naked)
static void HorizEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | shift			|  +  68
//    | pitch           |  +  64
//    | height          |  +  60
//    | width           |  +  56
//    | rec		        |  +  52
//  -----------------------------
//    | return addr     |  +  48
//    | saved ebp       |  +  44
//    | saved ebx       |  +  40
//    | saved esi       |  +  36
//    | saved edi       |  +  32

#define LOCALSIZE        32

#define SHIFT			 68
#define PITCH_PARM       64
#define HEIGHT           60
#define WIDTH			 56
#define REC				 52

#define LOOP_I			 28
#define LOOP_J			 24  
#define LOOP_K			 20 
#define PCODED_ROW0		 16  
#define PCODED_ROW1		 12  
#define PQP_MAP			  8
#define MBC				  4
#define LOOP_K_LIMIT	  0

_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// r   = rec + (pitch << 3)
// r_2 = r - (pitch << 1)
// r_1 = r - pitch
// r1  = r + pitch
// assign(esi, r_2)
// assign(edi, r1)
// assign(ebp, pitch)
	mov		ebp, [esp + PITCH_PARM]
	mov		esi, [esp + REC]
	lea		esi, [esi + ebp*4]
	lea		esi, [esi + ebp*2]
	lea		edi, [esi + ebp*2]
	lea		edi, [edi + ebp]
// pcoded_row0 = &coded_map[8>>shift][0]
// pcoded_row1 = pcoded_row0 + sizeof(coded_map[0])
// pQP_map = &QP_map[0][0]
	mov		eax, 8
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	mov		ebx, TYPE coded_map[0]
	imul	eax, ebx
	lea		eax, [coded_map + eax]
	mov		[esp + PCODED_ROW0], eax
	add		eax, ebx
	mov		[esp + PCODED_ROW1], eax
	lea		eax, [QP_map]
	mov		[esp + PQP_MAP], eax

// for (j = 8; j < height; )
	mov		DWORD PTR [esp + LOOP_J], 8
L1:
// for (i = 0; i < width; i += 8)
	mov		DWORD PTR [esp + LOOP_I], 0
L2:
// mbc = i >> shift
// if (pcoded_row0[mbc+1] || pcoded_row1[mbc+1])
	mov		eax, [esp + LOOP_I]
	 mov	ecx, [esp + SHIFT]
	shr		eax, cl
	mov		ebx, [esp + PCODED_ROW0]
	 mov	[esp + MBC], eax
	mov		cl,	[ebx+eax+1]
	 mov	ebx, [esp + PCODED_ROW1]
	test	ecx, ecx
	 jnz	L3
	mov		cl, [ebx+eax+1]
	 test	ecx, ecx
	 jz		L4
L3:
// for (k = i; k < i+8; k++)
	mov		eax, [esp + LOOP_I]
	 xor	ebx, ebx
	add		eax, 8
// read r_1[k]
	 mov	bl, [esi+ebp]
	mov		[esp + LOOP_K_LIMIT], eax
	 xor	eax, eax
L5:
// d = (r_2[k]+(r_2[k]<<1)-(r_1[k]<<3)+(r[k]<<3)-(r1[k]+(r1[k]<<1)))>>4
// read r_2[k]
	mov		al, [esi]
	 xor	ecx, ecx
// read r[k]
	mov		cl, [esi+ebp*2]
	 xor	edx, edx
// read r1[k] and compute r_2[k]*3
	mov		dl, [edi]
	 lea	eax,[eax+eax*2]
// compute r_1[k]*8 and r[k]*8
	lea		ebx, [ebx*8]
	 lea	ecx, [ecx*8]
//  compute r1[k]*3 and (r_2[k]*3 - r_1[k]*8)
	lea		edx, [edx+edx*2]
	 sub	eax, ebx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8) 
	add		eax, ecx
	 xor	ecx, ecx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8 - r1[k]*3)
	sub		eax, edx
	 xor	edx, edx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8 - r1[k]*3) >> 4
	sar		eax, 4
	 mov	ebx, [esp + PQP_MAP]
// if (d && (d >= -32) && (d < 32))
	add		ebx, [esp + MBC]
	test	eax, eax
	jz		L6
	cmp		eax, -32
	jl		L6
	cmp		eax, 32
	jge		L6
// delta = dxQP[d+32][pQP_map[mbc]]
// r[k] = ClampTbl[r[k]-delta+CLAMP_BIAS]
// r_1[k] = ClampTbl[r_1[k]+delta+CLAMP_BIAS]
	lea		eax, [eax + 32]
	 mov	cl, [ebx]
	shl		eax, 5
	 mov	dl, [esi+ebp]
	mov		al, dxQP[eax+ecx]
	 mov	cl, [esi+ebp*2]
	movsx	eax, al
	sub		ecx, eax
	 mov	dl, ClampTbl[edx + eax + CLAMP_BIAS]
	mov		cl, ClampTbl[ecx + CLAMP_BIAS]
	 mov	[esi+ebp], dl
	mov		[esi+ebp*2], cl
	 nop
L6:
	mov		edx, [esp + LOOP_I]
	 inc	esi
	inc		edx
	 inc	edi
	xor		eax, eax
	 xor	ebx, ebx
	mov		[esp + LOOP_I], edx
	 mov	bl, [esi+ebp]
	cmp		edx, [esp + LOOP_K_LIMIT]
	 jl		L5
	jmp		L4a
L4:
	mov		eax, [esp + LOOP_I]
	 lea	esi, [esi+8]
	add		eax, 8
	 lea	edi, [edi+8]
	mov		[esp + LOOP_I],eax
	 nop
L4a:
	mov		eax, [esp + LOOP_I]
	cmp		eax, [esp + WIDTH]
	jl		L2
// r_2 += (pitch<<3)
// r_1 += (pitch<<3)
// r   += (pitch<<3)
// r1  += (pitch<<3)
	mov		eax, ebp
	shl		eax, 3
	sub		eax, [esp + WIDTH]
	lea		esi, [esi + eax]
	lea		edi, [edi + eax]
// if (0 == ((j+=8)%mod_div))
	mov		eax, [esp + LOOP_J]
	add		eax, 8
	mov		[esp + LOOP_J], eax
	mov		ebx, eax
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	shl		eax, cl
	sub		ebx, eax
	jnz		L7
// pcoded_row0 += sizeof(coded_map[0])
// pcoded_row1 += sizeof(coded_map[0])
// pQP_map += sizeof(QP_map[0])
	mov		eax, [esp + PCODED_ROW0]
	mov		ebx, [esp + PCODED_ROW1]
	mov		ecx, [esp + PQP_MAP]
	add		eax, TYPE coded_map[0]
	add		ebx, TYPE coded_map[0]
	add		ecx, TYPE QP_map[0]
	mov		[esp + PCODED_ROW0], eax
	mov		[esp + PCODED_ROW1], ebx
	mov		[esp + PQP_MAP], ecx
L7:
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + HEIGHT]
	jl		L1

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SHIFT
#undef PITCH_PARM
#undef HEIGHT
#undef WIDTH
#undef REC

#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef PCODED_ROW0
#undef PCODED_ROW1
#undef PQP_MAP
#undef MBC
#undef LOOP_K_LIMIT

__declspec(naked)
static void VertEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | shift			|  +  56
//    | pitch           |  +  52
//    | height          |  +  48
//    | width           |  +  44
//    | rec		        |  +  40
//  -----------------------------
//    | return addr     |  +  36
//    | saved ebp       |  +  32
//    | saved ebx       |  +  28
//    | saved esi       |  +  24
//    | saved edi       |  +  20

#define LOCALSIZE        20

#define SHIFT			 56
#define PITCH_PARM       52
#define HEIGHT           48
#define WIDTH			 44
#define REC				 40

#define LOOP_K			 16
#define LOOP_J			 12  
#define PCODED_ROW1		  8  
#define PQP_MAP			  4
#define MBC				  0

_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign(esi, r)
	mov		esi, [esp + REC]
// assign(edi, pitch)
	mov		edi, [esp + PITCH_PARM]
// pcoded_row1 = &coded_map[1][0]
	mov		eax, TYPE coded_map[0]
	lea		eax, [coded_map + eax]
	mov		[esp + PCODED_ROW1], eax
// pQP_map = &QP_map[0][0]
	lea		eax, [QP_map]
	mov		[esp + PQP_MAP], eax
// for (j = 0; j < height; )
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L1:
// for (i = 8; i < width; i += 8)
// assign(ebp,i)
	mov		ebp, 8
// mbc = i >> shift
L2:
	mov		eax, ebp
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	mov		[esp + MBC], eax
// if (pcoded_row1[mbc] || pcoded_row1[mbc+1])
	xor		ecx, ecx
	mov		ebx, [esp + PCODED_ROW1]
	mov		cl, [ebx+eax]
	test	ecx, ecx
	jnz		L3
	mov		cl, [ebx+eax+1]
	test	ecx, ecx
	jz		L4
L3:
// for (k = 0; k < 8; k++)
	mov		DWORD PTR [esp + LOOP_K], 8
	xor		eax, eax
	xor		ebx, ebx
	xor		ecx, ecx
	xor		edx, edx
L5:
// d = (r[i-2]+(r[i-2]<<1)-(r[i-1]<<3)+(r[i]<<3)-(r[i+1]+(r[i+1]<<1)))>>4
// read r[i-2] and r[i]
	mov		al, [esi+ebp-2]
	 mov	bl, [esi+ebp]
// read r[i-1] and r[i+1]
	mov		cl, [esi+ebp-1]
	 mov	dl, [esi+ebp+1]
// compute r[i-2]*3 and r[i]*8
	lea		eax, [eax+eax*2]
	 lea	ebx, [ebx*8]
// compute r[i-1]*8 and r[i+1]*3
	lea		ecx, [ecx*8]
	 lea	edx, [edx+edx*2]
// compute (r[i-2]*3 + r[i]*8) and (r[i-1]*8 + r[i+1]*3)
	add		eax, ebx
	 add	ecx, edx
// compute (r[i-2]*3 - r[i-1]*8 + r[i]*8 - r[i+1]*3)
	sub		eax, ecx
	 xor	ecx, ecx
// compute ((r[i-2]*3 - r[i-1]*8 + r[i]*8 - r[i+1]*3) >> 4)
	sar		eax, 4
	 xor	edx, edx
// if (d && (d >= -32) && (d < 32))
	test	eax, eax
	jz		L6
	cmp		eax, -32
	jl		L6
	cmp		eax, 32
	jge		L6
// delta = dxQP[d+32][pQP_map[mbc]]
// r[i] = ClampTbl[r[i]-delta+CLAMP_BIAS]
// r[i-1] = ClampTbl[r[i-1]+delta+CLAMP_BIAS]
	lea		eax, [eax + 32]
	 mov	ebx, [esp + PQP_MAP]
	shl		eax, 5
	 add	ebx, [esp + MBC]
	mov		cl, [ebx]
	 xor	ebx, ebx
	mov		al, dxQP[eax+ecx]
	 mov	bl, [esi+ebp]
	movsx	eax, al
	sub		ebx, eax
	 mov	cl, [esi+ebp-1]
	mov		bl, ClampTbl[ebx + CLAMP_BIAS]
	 mov	cl, ClampTbl[ecx + eax + CLAMP_BIAS]
	mov		[esi+ebp], bl
	 mov	[esi+ebp-1], cl
L6:
	add		esi, edi
	 mov	eax, [esp + LOOP_K]
	xor		ebx, ebx
	 dec	eax
	mov		[esp + LOOP_K], eax
	 jnz	L5
// r -= (pitch<<3)
	mov		eax, edi
	shl		eax, 3
	sub		esi, eax
L4:
	add		ebp, 8
	cmp		ebp, [esp + WIDTH]
	jl		L2
// r   += (pitch<<3)
	mov		eax, edi
	shl		eax, 3
	lea		esi, [esi + eax]
// if (0 == ((j+=8)%mod_div))
	mov		eax, [esp + LOOP_J]
	add		eax, 8
	mov		[esp + LOOP_J], eax
	mov		ebx, eax
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	shl		eax, cl
	sub		ebx, eax
	jnz		L7
// pcoded_row1 += sizeof(coded_map[0])
// pQP_map += sizeof(QP_map[0])
	mov		eax, [esp + PCODED_ROW1]
	mov		ebx, [esp + PQP_MAP]
	add		eax, TYPE coded_map[0]
	add		ebx, TYPE QP_map[0]
	mov		[esp + PCODED_ROW1], eax
	mov		[esp + PQP_MAP], ebx
L7:
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + HEIGHT]
	jl		L1

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SHIFT
#undef PITCH_PARM
#undef HEIGHT
#undef WIDTH
#undef REC

#undef LOOP_K
#undef LOOP_J
#undef PCODED_ROW1
#undef PQP_MAP
#undef MBC

#endif // } 0

#define abs(x)    (((x)>0)?(x):(-(x)))
#define sign(x)   (((x)<0)?(-1):(1))

void InitEdgeFilterTab()   
{
	int d,QP;

	for (d = 0; d < 64; d++) {          // -32 <=  d < 32
		for (QP = 0; QP < 32; QP++) {    //   0 <= QP < 32
			dxQP[d][QP] = sign(d-32)*(max(0,(abs(d-32)-max(0,((2*abs(d-32))-QP)))));
		}
	}
}

/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/
// C version of block edge filter functions
// takes about 3 ms for QCIF and 12 ms for CIF on a Pentium 120.
void EdgeFilter(unsigned char *lum, 
                unsigned char *Cb, 
                unsigned char *Cr, 
                int width, int height, int pitch) {

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 4);
    VertEdgeFilter (lum, width, height, pitch, 4);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 3);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 3);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 3);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 3);

    return;
}

#else // Karl's original version }{

/* currently requires 11232 bytes */ 
signed char dtab[352*32];

/***********************************************************************/
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr)
{
  int i,j,k;    
  int delta;
  int mbc, mbr, do_filter;
  unsigned char *r_2, *r_1, *r, *r1;
  signed char *deltatab;

  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  for (j = 8; j < height; j += 8) {
    for (i = 0; i < width; i += 8) {

      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }

      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr][mbc+1];

      if (do_filter) {
        for (k = i; k < i+8; k++) {
          delta = (int)deltatab[ (( (int)(*(r_2 + k) * 3) -
                                    (int)(*(r_1 + k) * 8) +
                                    (int)(*(r   + k) * 8) -
                                    (int)(*(r1  + k) * 3)) >>4)];
                        
          *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
          *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

        }
      }
    }
    r   += (pitch<<3);
    r1  += (pitch<<3);
    r_1 += (pitch<<3);
    r_2 += (pitch<<3);
  }
  return;
}

static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter;
  signed char *deltatab;
  unsigned char *r;

  /* vertical edges */
  for (i = 8; i < width; i += 8) 
  {
    r = rec;
    for (j = 0; j < height; j +=8) 
    {
      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }
        
      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr+1][mbc];

      if (do_filter) {
        for (k = 0; k < 8; k++) {
          delta = (int)deltatab[(( (int)(*(r + i-2 ) * 3) - 
                                   (int)(*(r + i-1 ) * 8) + 
                                   (int)(*(r + i   ) * 8) - 
                                   (int)(*(r + i+1 ) * 3)  ) >>4)];

          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}

  /**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/

void EdgeFilter(unsigned char *lum, 
                unsigned char *Cb, 
                unsigned char *Cr, 
                int width, int height, int pitch)
{

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 0);
    VertEdgeFilter (lum, width, height, pitch, 0);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 1);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 1);

    return;
}

#define sign(a)        ((a) < 0 ? -1 : 1)

void InitEdgeFilterTab()   
{
  int i,QP;
  
  for (QP = 1; QP <= 31; QP++) {
    for (i = -176; i <= 175; i++) {
      dtab[i+176 +(QP-1)*351] = sign(i) * (max(0,abs(i)-max(0,2*abs(i) - QP)));
    }
  }
}

#endif // } if defined(H263P)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3coltbl.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// D3COLTBL.H - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.   This table was
//				taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d3coltbl.h_v   1.7   05 Feb 1996 13:35:44   BNICKERS  $
//
// $Log:   S:\h26x\src\dec\d3coltbl.h_v  $
;// 
;//    Rev 1.7   05 Feb 1996 13:35:44   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.6   27 Dec 1995 14:36:12   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.5   03 Nov 1995 11:49:46   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.4   30 Oct 1995 17:15:40   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.3   27 Oct 1995 17:30:58   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.2   26 Oct 1995 18:54:40   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.1   25 Oct 1995 18:05:46   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.0   23 Aug 1995 12:35:12   DBRUCKS
// Initial revision.

#ifndef __D3COLTBL_H__
#define __D3COLTBL_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	   
U32 UVDitherLine01[64];
U32 UVDitherLine23[64];
U8  YDither[262];
U8  Padding1[26];
U32 YDitherZ2[256];
#ifdef WIN32
U8  RValLo555[304];
U8  GValLo555[262];
U8  BValLo555[350];
U8  RValHi555[304];
U8  GValHi555[262];
U8  BValHi555[350];
U8  Padding2[216];
U8  RValLo565[304];
U8  GValLo565[262];
U8  BValLo565[350];
U8  RValHi565[304];
U8  GValHi565[262];
U8  BValHi565[350];
U8  Padding3[216];
U8  RValLo655[304];
U8  GValLo655[262];
U8  BValLo655[350];
U8  RValHi655[304];
U8  GValHi655[262];
U8  BValHi655[350];
U8  Padding4[216];
U8  RValLo664[304];
U8  GValLo664[262];
U8  BValLo664[350];
U8  RValHi664[304];
U8  GValHi664[262];
U8  BValHi664[350];
U8  Padding5[24];
U32 UVContrib[512];
U32 RValZ2555[304];
U32 GValZ2555[262];
U32 BValZ2555[350];
U32 Padding6[108];
U32 RValZ2565[304];
U32 GValZ2565[262];
U32 BValZ2565[350];
U32 Padding7[108];
U32 RValZ2655[304];
U32 GValZ2655[262];
U32 BValZ2655[350];
U32 Padding8[108];
U32 RValZ2664[304];
U32 GValZ2664[262];
U32 BValZ2664[350];
U8  Padding9[16];
U8  B24Value[701];
U8  Padding10[3];
U32 UV24Contrib[512];
#endif
int dummy;

} T_H26xColorConvertorTables;

extern T_H26xColorConvertorTables H26xColorConvertorTables;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3const.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:36:12  $
// $Archive:   S:\h26x\src\dec\d3const.h_v  $
// $Header:   S:\h26x\src\dec\d3const.h_v   1.2   27 Dec 1995 14:36:12   RMCKENZX  $
// $Log:   S:\h26x\src\dec\d3const.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:12   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.1   25 Oct 1995 18:08:42   BNICKERS
// clean up archival stuff
// 
//    Rev 1.0   31 Jul 1995 13:00:02   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:20   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////

#ifndef __DECCONST_H__
#define __DECCONST_H__

/*
  This file declares symbolic constants used by the MRV decoder, post filtering
  functions, and color convertors.
*/

#define BEFTRIGGER       143 /* See bef.asm for the magic behind these values.*/
#define BEFWILLING       125
#define BEFUNWILLING      10
#define BEFENDOFLINE      21
#define BEFENDOFFRAME    246

#define INVALIDINTERBLOCK 0
#define INVALIDCOPYBLOCK  1
#define NOMOREBLOCKS      2
// Already defined in e3enc.h
//#define INTRABLOCK        3
//#define INTERBLOCK        4
#define COPYBLOCK         5

#define VPITCH 336               /* U & V interleaved, with constant pitch of */
                                 /* 336.  This makes color conversion easier. */
#define OFFSETV2U 168            /* Distance from V pel to corresponding U    */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3dec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;//
;// $Author:   JMCVEIGH  $
;// $Date:   05 Feb 1997 12:24:16  $
;// $Archive:   S:\h26x\src\dec\d3dec.h_v  $
;// $Header:   S:\h26x\src\dec\d3dec.h_v   1.40   05 Feb 1997 12:24:16   JMCVEIGH  $
;//	$Log:   S:\h26x\src\dec\d3dec.h_v  $
;// 
;//    Rev 1.40   05 Feb 1997 12:24:16   JMCVEIGH
;// Support for latest H.263+ draft bitstream spec.
;// 
;//    Rev 1.39   16 Dec 1996 17:42:44   JMCVEIGH
;// Flag for improved PB-frame mode.
;// 
;//    Rev 1.38   09 Dec 1996 18:02:08   JMCVEIGH
;// Added support for arbitrary frame sizes.
;// 
;//    Rev 1.37   26 Sep 1996 09:40:54   BECHOLS
;// Added Snapshot fields to the Decoder Catalog, and Snapshot constants.
;// 
;//    Rev 1.36   10 Sep 1996 10:31:46   KLILLEVO
;// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
;// 
;//    Rev 1.35   03 May 1996 13:08:06   CZHU
;// 
;// Added fields in decoder catalog for RTP packet loss recovery
;// 
;//    Rev 1.34   22 Mar 1996 17:21:40   AGUPTA2
;// Added bMMXDecoder field in the decoder catalog.
;// 
;//    Rev 1.33   23 Feb 1996 09:46:28   KLILLEVO
;// fixed decoding of Unrestricted Motion Vector mode
;// 
;//    Rev 1.32   12 Jan 1996 15:00:14   TRGARDOS
;// Added aspect ration correction logic and code to force
;// aspect ration correction on based on INI file settings.
;// 
;//    Rev 1.31   11 Jan 1996 14:06:22   RMCKENZX
;// Added CCOffset320x240 member to the decoder catalog to support stills.
;// 
;//    Rev 1.30   06 Jan 1996 18:39:54   RMCKENZX
;// Updated copyright
;// 
;//    Rev 1.29   06 Jan 1996 18:35:08   RMCKENZX
;// Added uIs320x240 to Decoder Catalog to support still frames at
;// 320x240 resolution
;// 
;//    Rev 1.28   20 Dec 1995 15:59:14   RMCKENZX
;// Added prototype for FrameMirror to support mirror imaging
;// 
;//    Rev 1.27   18 Dec 1995 12:45:28   RMCKENZX
;// added copyright notice
;// 
;//    Rev 1.26   13 Dec 1995 11:00:46   RHAZRA
;// No change.
;// 
;//    Rev 1.25   11 Dec 1995 11:32:06   RHAZRA
;// 12-10-95 changes: added AP stuff
;// 
;//    Rev 1.24   09 Dec 1995 17:23:44   RMCKENZX
;// updated to support decoder re-architecture
;// added X32_uMBInfoStream to decoder catalog &
;// T_MBInfo structure for PB Frames.
;// added X32_pN & X32_InverseQuant to catalog for 2nd pass.
;// 
;//    Rev 1.22   26 Oct 1995 11:21:52   CZHU
;// Added uTempRefPrev to save TR for previous frame
;// 
;//    Rev 1.21   25 Oct 1995 18:09:34   BNICKERS
;// 
;// Switch to YUV12 color convertors.  Clean up archival stuff.
;// 
;//    Rev 1.20   13 Oct 1995 16:05:32   CZHU
;// First version that supports PB frames. Display B or P frames under
;// VfW for now. 
;// 
;//    Rev 1.19   11 Oct 1995 13:25:50   CZHU
;// Added code to support PB frame
;// 
;//    Rev 1.18   26 Sep 1995 15:32:36   CZHU
;// 
;// Adjust tempory buffers for motion compensation
;// 
;//    Rev 1.17   20 Sep 1995 14:47:42   CZHU
;// Added iNumberOfMBsPerGOB in decoder catalog
;// 
;//    Rev 1.16   11 Sep 1995 16:42:52   CZHU
;// Added uMBBuffer for storage used for motion compensation
;// 
;//    Rev 1.15   11 Sep 1995 14:31:12   CZHU
;// Name and type change for MV info
;// 
;//    Rev 1.14   08 Sep 1995 11:47:50   CZHU
;// 
;// Added MV info, and changed the name for motion vectors
;// 
;//    Rev 1.13   01 Sep 1995 09:49:12   DBRUCKS
;// checkin partial ajdust pels changes
;// 
;//    Rev 1.12   29 Aug 1995 16:48:12   DBRUCKS
;// add YVU9_VPITCH
;// 
;//    Rev 1.11   28 Aug 1995 10:15:04   DBRUCKS
;// update to 5 July Spec and 8/25 Errata
;// 
;//    Rev 1.10   23 Aug 1995 12:25:10   DBRUCKS
;// Turn on the color converters
;// 
;//    Rev 1.9   14 Aug 1995 16:38:30   DBRUCKS
;// add hung type and clarify pCurBlock
;// 
;//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
;// copy source to bitstream
;// 
;//    Rev 1.7   11 Aug 1995 15:13:00   DBRUCKS
;// ready to integrate block level
;// 
;//    Rev 1.6   04 Aug 1995 15:56:32   TRGARDOS
;// 
;// Put definition of PITCH into CDRVDEFS.H so that encoder
;// doesn't get a redefinition of MACRO warning.
;// 
;//    Rev 1.5   03 Aug 1995 10:37:54   TRGARDOS
;// 
;// Moved picture header structure definition to cdrvsdef.h.
;// 
;//    Rev 1.4   02 Aug 1995 15:31:02   DBRUCKS
;// added GOB header fields and cleaned up comments
;// 
;//    Rev 1.3   01 Aug 1995 16:24:58   DBRUCKS
;// add the picture header fields
;// 
;//    Rev 1.2   31 Jul 1995 16:28:12   DBRUCKS
;// move loacl BITS defs to D3DEC.CPP
;// 
;//    Rev 1.1   31 Jul 1995 15:51:12   CZHU
;// 
;// added quant field in the BlockActionStream structure.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:06   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.2   28 Jul 1995 13:59:54   CZHU
;// 
;// Added block action stream definition and defines for constants
;// 
;//    Rev 1.1   24 Jul 1995 14:59:30   CZHU
;// 
;// Defined decoder catalog for H.263. Also defined block action stream
;// 
;//    Rev 1.0   17 Jul 1995 14:46:24   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECLOCS_H__
#define __DECLOCS_H__

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 decoder.
*/
//#define PITCH         384
#define YVU9_VPITCH	  336 
#define U_OFFSET      192 
#define UMV_EXPAND_Y  16
#define UMV_EXPAND_UV 8		   //expanding for Unrestricted MV in each direction
#define Y_START		(UMV_EXPAND_Y * PITCH + UMV_EXPAND_Y)
#define UV_START	(UMV_EXPAND_UV * PITCH + UMV_EXPAND_UV)
#define INSTANCE_DATA_FIXED_SIZE  512
//#define BLOCK_BUFFER_SIZE	 8*8*4*6
//Block stores for the MB are included in MB_MC_BUFFER
#define MB_MC_BUFFER_SIZE    PITCH*8
#define BLOCK_BUFFER_OFFSET  6*8

#define LEFT_EDGE   0x1
#define RIGHT_EDGE  0x2
#define TOP_EDGE    0x4
#define BOTTOM_EDGE 0x8

typedef struct {

    U32 X32_YPlane;              /* X32_-pointer to Y, V, and U planes.       */
    U32 X32_VPlane;              /* Base plus offset is 32-bit aligned  for   */
    U32 X32_UPlane;              /* all planes.                               */

} YUVFrame;

#define SRC_FORMAT_FORBIDDEN 0
#define SRC_FORMAT_SQCIF 	 1
#define SRC_FORMAT_QCIF  	 2
#define SRC_FORMAT_CIF		 3 
#define SRC_FORMAT_4CIF		 4
#define SRC_FORMAT_16CIF	 5
#define SRC_FORMAT_RES_1	 6
#define SRC_FORMAT_RES_2	 7

#ifdef H263P
// H.263+ draft, document LBC-96-358
#define SRC_FORMAT_CUSTOM    6		// Replaces SRC_FORMAT_RES_1
#define SRC_FORMAT_EPTYPE    7		// Replaces SRC_FORMAT_RES_2
#define SRC_FORMAT_RESERVED  7		// Reserved value in extened PTYPE

#define PARC_SQUARE          1
#define PARC_CIF             2
#define PARC_10_11           3
#define PARC_16_11           4
#define PARC_40_33           5
#define PARC_EXTENDED        16
#endif

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Decoder Timing Data - per frame
*/
typedef struct {
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	U32	uDecodeFrame;
	U32 uBEF;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	U32	uHeaders;
	U32	uMemcpy;
	U32	uFrameCopy;
	U32	uOutputCC;
	U32	uIDCTandMC;
	U32	uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
} DEC_TIMING_INFO;
#endif // } LOG_DECODE_TIMINGS_ON

typedef struct {
    /* Here's the data about the frame shape and location.                    */

    YUVFrame CurrFrame;  		 /* Current frame.                            */
    YUVFrame PrevFrame;  		 /* Previous frame.                           */
    YUVFrame PBFrame;	 		 /* frame to hold B blocks for H.263          */
	YUVFrame DispFrame;			 /* current frame being displayed             */

    YUVFrame PostFrame;          /* Buffer for post process and color convert.*/

    LPVOID  _p16InstPostProcess;  /* Segment containing PostFrm.               */
    U8 *     p16InstPostProcess;  /* Segment containing PostFrm (aligned)       */

    U32 uFrameHeight;            /* Actual dimensions of image.               */
    U32 uFrameWidth;			 
    U32 uYActiveHeight;          /* Dimensions of image for which blocks are  */
    U32 uYActiveWidth;           /* actually encoded.  I.e. height and width  */
    U32 uUVActiveHeight;         /* padded to multiple of eight.              */
    U32 uUVActiveWidth;

#ifdef H263P
	U32 uActualFrameHeight;		 /* Actual frame dimensions used for display  */
	U32 uActualFrameWidth;		 /* purposes one.                             */
#endif

    U32 uSz_VUPlanes;            /* Space allocated for V and U planes.       */
    U32 uSz_YPlane;              /* Space allocated for Y plane.              */
    U32 uSz_YVUPlanes;           /* Space allocated for all planes.           */
	U32 uIs320x240;				 /* Flag to indicate 320x240 frames (padded
	                                to CIF, used for stills                   */
    
    /* The data pointed to below is NOT instance specific.  On 16-bit Windows
       it is copied to the per-instance data segment.  On 32-bit Windows, it
       is in the one and only data segment, and is just pointed to here.      */
	
	U32 uMBBuffer;				 /* storage for a block                       */
    U32 X16_BlkDir;              /* Ptr array of type T_BlkDir                */
    U32 X16_BlkActionStream;     /* Params for each block                     */
    
    X32 X32_BEFDescr;            /* Catalogs eagerness & willingness to BEF   */
    X32 X32_BEFDescrCopy;        /* Address of copy of BEFDescr in BEF seg.   */
    X32 X32_BEFApplicationList;  /* List of blocks to do Block Edge Filter    */

    U32 X32_BitStream;           /* Huffman encoded bitstream for one frame.  */
	U32 uSizeBitStreamBuffer;	 /* Number of bytes allocated for this frame. */

	U32 uSrcFormat;				 /* Picture header information				  */
	U32 uPrevSrcFormat;
	U32 uTempRef;	
	U32 uTempRefPrev;
	U32 uBFrameTempRef;	 
	U32 uPQuant;
	U32 uDBQuant;
    U16 bCameraOn;
    U16 bSplitScreen;				 
	U16 bFreezeRelease;
	U16 bKeyFrame;
	U16 bUnrestrictedMotionVectors;
	U16 bArithmeticCoding;
	U16 bAdvancedPrediction;
	U16 bPBFrame;

#ifdef H263P
	// H.263+ draft, document LBC-96-358

	U16 bImprovedPBFrames;
	U16 bAdvancedIntra;
	U16 bDeblockingFilter;
	U16 bSliceStructured;
	U16 bCustomPCF;
	U16 bBackChannel;
	U16 bScalability;
	U16 bTrueBFrame;
	U16 bResampling;
	U16 bResUpdate;

	U32 uPARWidth;
	U32 uPARHeight;
#endif

	U16 bCPM;
	U16 bReadSrcFormat;

	I32 iNumberOfMBsPerGOB;
	U32 uGroupNumber;			 /* GOB header information                    */
	U32 uGOBFrameID;
	U32 uGQuant;
	U16 bFoundGOBFrameID;
	
	U16 bCoded;					 /* MB header information                     */
	U32 uMBType;

	U32  uCBPC;
	U32  uCBPY;
	U32  uDQuant;

    U8  u8CBPB;					/* 6 bit to hold CBP for 6 B blocks           */
	U8  u8Pad;
	U16 u16Pad;

	I8  i8MVDBx2;
	I8  i8MVDBy2;
	I8  i8MVD2x2;
	I8  i8MVD2y2;

	I8  i8MVD3x2;
	I8  i8MVD3y2;
	I8  i8MVD4x2;
	I8  i8MVD4y2;

    I8  i8MVDx2; 				 /* horizontal motion- mult by two             */
    I8  i8MVDy2;				 /* vertical motion - mult by two for half pel */
    U16 bPrevFrameLost;          /* Flag affecting temporal filter.           */
	
	U32 bGOBHeaderPresent;
		
    U32 Sz_BitStream;            /* Space allocated for copy of BitStream.    */
    U32 Ticker;                  /* Frame counter.                            */
    
	U32 bDisplayBFrame;          /* flag indicates that B frame displayed     */
    U16 ColorConvertor;          /* Index of color convertor to use.          */
    U16 CCOutputPitch;           /* Pitch for color converted output frame.   */
    U32 CCOffsetToLine0;         /* Offest to first line of color conv frame. */
	U32 CCOffset320x240;		 /* Color Convertor Offset to line 0
										for special Still Frame size   		  */
    
    U16 DecoderType;             /* Pick from H263, YUV9.                     */

    X16 X16_LumaAdjustment;      /* Table to adjust brightness and contrast.  */
    X16 X16_ChromaAdjustment;    /* Table to adjust saturation.               */
	/* The control code points to the flags with pointer to a BOOL
	 */
    BOOL bAdjustLuma;            /* Set if adjusting brightness and contrast. */
    BOOL bAdjustChroma;          /* Set if adjusting saturation.              */
    U16 BrightnessSetting;       /* Value used to build adjustment tables.    */
    U16 ContrastSetting;         /* Value used to build adjustment tables.    */
    U16 SaturationSetting;       /* Value used to build adjustment tables.    */
    U16 SuppressChecksum;        /* Flag indicates if should skip checksum.   */
    U16 iAPColorConvPrev;
    LPVOID pAPInstPrev;          /* Pointer  PostFrm for prev AP               */

	X32 X32_InverseQuant;               //  NEW
	X32 X32_pN;					        //  NEW
    X32 X32_uMBInfoStream;              //  PB-NEW

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	/* Timing Statistics Variables */
	X32 X32_DecTimingInfo;		 		/* Offset to */
	DEC_TIMING_INFO * pDecTimingInfo;	/* pointer, set after locking catalog */
	U32 uStatFrameCount;				/* statistics frame counter */
	/* The following are needed in lower level routines */
	int bTimingThisFrame;						
	U32 uStartLow;
	U32 uStartHigh;		
#endif // } LOG_DECODE_TIMINGS_ON

//#ifdef LOSS_RECOVERY
    I32  iVerifiedBsExt; //flat indicating whether verification is performed
	I32  iValidBsExt;    //flag indicating valid extension of bitstream
	void *pBsTrailer;    //point to the trailer of the extended bs
	void *pBsInfo;	     //point to the beginning of the BSINFO stream
	U32  uNumOfPackets;  //Number of Packets for this frame;
//#endif 
	/* Options */
	int bForceOnAspectRatioCorrection;
	int bUseBlockEdgeFilter;
#ifdef USE_MMX // { USE_MMX
    BOOL bMMXDecoder;
#endif // } USE_MMX
	
} T_H263DecoderCatalog;

typedef struct {                           // NEW
	U32   dInverseQuant;                   // NEW
    U32   dTotalRun;                       // NEW
} T_IQ_INDEX;							   // NEW

/* MBInfo
 *
 * A stream of T_MBInfo structs provides a place to hold information 
 * about the macroblocks gathered during the first pass so it can
 * be used during the second pass for B-frame bi-directional motion
 * prediction.  Each struct deals with one macroblock.
 */
typedef struct {                            // PB-NEW
    I8  i8MBType;                           // AP-NEW added by Raj
	I8  i8MVDBx2;
	I8  i8MVDBy2;
#ifdef H263P
	U8  bForwardPredOnly;		/* Flag indicating only forward prediction of B-block */
#endif
} T_MBInfo;                                 // PB-NEW


/* Block Type defines
 */
#define BT_INTRA_DC		0	// Intra block without TCOEFF
							// assembly code assumes INTRA_DC is zero
#define BT_INTRA		1  	// Intra block
#define BT_INTER		2	// Inter block
#define BT_EMPTY		3	// Inter block without TCOEFF
#define BT_ERROR		4


/* T_BlkAction
 * 
 * A stream of T_BlkAction structs provides information about the blocks to
 * be processed for a slice.  Each struct deals with one block.
 */
typedef struct {
    U8 	u8BlkType;			/* block type */ 
    I8  i8MVx2; 		    /* horizontal motion - mult by two for half pel */
    I8  i8MVy2;				/* vertical motion - mult by two for half pel */
	U8  u8Quant;		    /* quantization level for this block */
    U32 pCurBlock;			/* current image. */
    U32 pRefBlock;			/* reference image. */
	U32 pBBlock;		  	/* B block image */
	U32 uBlkNumber;			/* for debugging */
 } T_BlkAction;


typedef struct {

    X32 X32_BlkAddr;               /* Addr of block in current frame buffer. */
    
} T_BlkDir;

#ifdef WIN32
#else

/* Return offsets for these structures. */

U32 FAR H263DOffset_DequantizerTables ();

/* Return size of fixed-size tables at start of instance data. */

U32 FAR H263DSizeOf_FixedPart();

#endif

extern "C" {
void FAR ASM_CALLTYPE FrameCopy (
              HPBYTE InputPlane,	    /* Address of input data.          */
		      HPBYTE OuptutPlane,       /* Address of output data.         */
              UN FrameHeight,           /* Lines to copy.                  */
              UN FrameWidth,            /* Columns to copy.                */
			  UN Pitch);                /* Pitch.                          */

void FAR ASM_CALLTYPE FrameMirror (
              HPBYTE InputPlane,	    /* Address of input data.          */
		      HPBYTE OuptutPlane,       /* Address of output data.         */
              UN FrameHeight,           /* Lines to copy.                  */
              UN FrameWidth,            /* Columns to copy.                */
			  UN Pitch);                /* Pitch.                          */
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3dec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Author:   JMCVEIGH  $
;// $Date:   11 Dec 1996 14:59:36  $
;// $Archive:   S:\h26x\src\dec\d3dec.cpv  $
;// $Header:   S:\h26x\src\dec\d3dec.cpv   1.119   11 Dec 1996 14:59:36   JMCVEIGH  $
;// $Log:   S:\h26x\src\dec\d3dec.cpv  $
// 
//    Rev 1.119   11 Dec 1996 14:59:36   JMCVEIGH
// 
// Moved deblocking filter within the loop and fixed bug for YUV12
// input and arbitrary frame sizes (must use actual dimensions for
// YUV12, not padded sizes).
// 
//    Rev 1.118   09 Dec 1996 18:02:06   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.117   09 Dec 1996 09:35:14   MDUDA
// Put new version of block edge filter under H263P.
// 
//    Rev 1.116   27 Nov 1996 15:24:34   BECHOLS
// Added check for NULL ptr around EMMS at end of decompress.
// 
//    Rev 1.115   26 Nov 1996 09:05:22   KLILLEVO
// changed allocation of dtab to array
// 
//    Rev 1.114   25 Nov 1996 15:23:40   KLILLEVO
// changed filter coefficients and table size for deblocking filter
// 
//    Rev 1.113   25 Nov 1996 14:11:14   KLILLEVO
// updated de-blocking filter to latest version of annex J
// 
//    Rev 1.112   19 Nov 1996 15:05:32   MDUDA
// For YUV12 I420 output color conversion, copy at least the V plane
// to prevent assembler code from reading beyond end of buffer.
// 
//    Rev 1.111   07 Nov 1996 08:31:04   CZHU
// Fixed bugs in Mode C recovery.
// 
//    Rev 1.110   06 Nov 1996 16:37:00   CZHU
// Moved initialization for BlockAction earlier
// 
//    Rev 1.109   06 Nov 1996 15:47:10   CZHU
// 
// Added mode C support, replacing zero size r1.108
// 
//    Rev 1.107   31 Oct 1996 10:50:44   KLILLEVO
// changed one debug message
// 
//    Rev 1.106   31 Oct 1996 10:17:56   KLILLEVO
// changed the last DBOUTs to DbgLog
// 
//    Rev 1.105   25 Oct 1996 15:20:30   KLILLEVO
// changed debug-message for Block Edge Filter initialization 
// in GetDecoderOptions() to be more informatice
// 
//    Rev 1.104   25 Oct 1996 15:01:56   KLILLEVO
// null frame warning should have level 4, not 2
// 
//    Rev 1.103   25 Oct 1996 09:13:40   KLILLEVO
// changed an error message about null frame received after non-PB frame
// to trace message and level 2.
// 
//    Rev 1.102   20 Oct 1996 18:10:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.101   16 Oct 1996 17:17:52   MDUDA
// Added initialization for DC->bReadSrcFormat to fix a capture bug.
// 
//    Rev 1.100   11 Oct 1996 16:08:30   MDUDA
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.99   26 Sep 1996 10:35:14   KLILLEVO
// need to ExplandPlane for bUnrestrictedMotionVectors in addition to
// bAdvancedPrediction
// 
//    Rev 1.98   26 Sep 1996 09:42:18   BECHOLS
// 
// Added Snapshot Event for synchronization and code to copy the Snapshot
// just prior to color conversion.
// 
//    Rev 1.97   25 Sep 1996 08:05:10   KLILLEVO
// initial extended motion vectors support 
// does not work for AP yet
// 
//    Rev 1.96   20 Sep 1996 09:36:04   MDUDA
// Fixed problem with video effects on YUV12 input images.
// Need to copy frame in this case.
// 
//    Rev 1.95   19 Sep 1996 19:40:40   MDUDA
// Fixed problem with calling AdjustPels - performed frame copy
// and set pFrame to correct location.
// 
//    Rev 1.94   16 Sep 1996 16:44:40   CZHU
// Fixed buffer overflow problem to support RTP MTU down to 128
// 
//    Rev 1.93   11 Sep 1996 15:12:26   CZHU
// Tuned off deblocking filter by default.
// 
//    Rev 1.92   10 Sep 1996 16:10:20   KLILLEVO
// added custom message to turn block edge filter on or off
// 
//    Rev 1.91   10 Sep 1996 14:15:24   BNICKERS
// Select Pentium Pro color convertors, when running on that processor.
// 
//    Rev 1.90   10 Sep 1996 10:31:04   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.89   06 Sep 1996 14:21:38   BECHOLS
// 
// Removed code that was wrapped by RTP_HEADER, and removed the wrapping too.
// 
//    Rev 1.88   30 Aug 1996 08:37:58   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.87   29 Aug 1996 09:29:08   CZHU
// 
// Fixed another bug in recovering lost packets followed by MODE M packet.
// 
//    Rev 1.86   27 Aug 1996 16:17:00   CZHU
// Commented out previous code to turn on MMX with RTP
// 
//    Rev 1.85   23 Jul 1996 11:20:56   CZHU
// Fixed two bugs related to packet loss recovery, one for the last packet los
// in current frame, the other in mode B packets.
// Also added motion vector adjustment for lost MBs
// 
//    Rev 1.84   18 Jul 1996 09:23:12   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.83   11 Jul 1996 15:12:40   AGUPTA2
// Changed assertion failures into errors when decoder goes past end of 
// the bitstream.
// 
//    Rev 1.82   01 Jul 1996 10:04:12   RHAZRA
// Force shaping flag to false for YUY2 color conversion
// .
// 
//    Rev 1.81   25 Jun 1996 14:27:20   BECHOLS
// Set ini file variables for use with RTP stuff.
// 
//    Rev 1.80   19 Jun 1996 14:30:12   RHAZRA
// 
// Added code to deal with pitch and output buffer offset & pitch
// setting for YUY2 output format.
// 
//    Rev 1.79   14 Jun 1996 17:27:44   AGUPTA2
// Updated the color convertor table.
// 
//    Rev 1.77   30 May 1996 17:04:54   RHAZRA
// Added SQCIF support.
// 
//    Rev 1.76   30 May 1996 15:16:32   KLILLEVO
// added YUV12 output
// 
//    Rev 1.75   30 May 1996 12:45:12   KLILLEVO
// fixed debug warning message in PB-frames mode
// 
//    Rev 1.74   30 May 1996 11:26:38   AGUPTA2
// Added support for MMX color convertors.
// 
//    Rev 1.73   29 May 1996 14:11:14   RHAZRA
// Changes made to use MMxVersion set in ccpuvsn.cpp.
// 
//    Rev 1.72   24 May 1996 10:04:20   KLILLEVO
// does not need to assert out if a null frame is received when
// the previous frame was not a PB. This will often happen
// with the new MMX PB switch
// 
//    Rev 1.71   03 May 1996 13:08:28   CZHU
// 
// Added checking of packet fault after picture header decoding, and 
// change pass1 loop control to recover from packe loss. Checking packet
// fault after MB header decoding.
// 
//    Rev 1.70   12 Apr 1996 14:16:40   RHAZRA
// Added paranthesis to make ifdef SUPPORT_SQCIF work properly
// 
//    Rev 1.69   12 Apr 1996 13:32:22   RHAZRA
// 
// Added SQCIF support with #ifdef SUPPORT_SQCIF.
// 
//    Rev 1.68   10 Apr 1996 16:28:20   RHAZRA
// Added a check to make sure that the input bitstream buffer does
// not exceed the H263 spec mandated size. If it does, the decoder
// now returns ICERR_ERROR.
// 
//    Rev 1.67   04 Apr 1996 13:32:02   RHAZRA
// Changed bitstream buffer allocation as per H.263 spec
// 
//    Rev 1.66   03 Apr 1996 09:06:06   RMCKENZX
// Moved "emms" to end of decoder.
// 
//    Rev 1.65   26 Mar 1996 16:43:38   AGUPTA2
// Corrected opcode for emms.
// 
//    Rev 1.64   22 Mar 1996 17:49:48   AGUPTA2
// MMX support.  Added emms around pass1 and pass2 calls.
// 
//    Rev 1.63   18 Mar 1996 09:58:48   bnickers
// Make color convertors non-destructive.
// 
//    Rev 1.62   12 Mar 1996 20:15:04   RHAZRA
// Fixed still-mode. Use framecopy() in 320x240 mode to copy display frame
// to post frame.
// 
//    Rev 1.61   08 Mar 1996 16:46:12   AGUPTA2
// Added pragma code_seg.
// Created three new routines: IAPass1ProcessFrame(), IAPass2ProcessFrame(),
// and H263InitializeGOBBlockActionStream().  H263InitializeGOB.. rtn. is
// called once for each block after decoding the GOB header; this is good for
// the data cache.  H263InitializeBlockActionStream() is not needed now.
// ExpandPlane() is called only when needed; it is called just before its
// results are needed : before Pass2 call (improves DCache util.).  Decoder
// does not copy current frame to previous frame after decoding; it just swaps
// the pointers.  Made changes to call the new non-destructive color convertor;
// this avoids a frame copy if mirroring is not needed.  I DON"T THINK ADJUST
// PELS FUNCTIONALITY WORKS.
// 
// 
// 
//    Rev 1.59   23 Feb 1996 09:46:52   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.58   05 Feb 1996 13:35:46   BNICKERS
// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
// 
//    Rev 1.57   17 Jan 1996 18:55:10   RMCKENZX
// more clean up from pb null frame bug
// 
//    Rev 1.56   17 Jan 1996 17:56:04   sing
// moved memcopy past the null P frame hack to avoid GPF 
// 
//    Rev 1.55   12 Jan 1996 14:59:42   TRGARDOS
// Added aspect ration correction logic and code to force
// aspect ration correction on based on INI file settings.
// 
//    Rev 1.54   11 Jan 1996 14:05:10   RMCKENZX
// Made changes to support stills.  In initialization set a local
// flag (as DC hasn't been created yet).  In frame handling, restore
// the CIF size and use the new 320x240 Offset To Line Zero figure.
// 
//    Rev 1.53   09 Jan 1996 10:44:38   RMCKENZX
// More revisions to support frame mirroring.  Added
// absolute value to references to destination width.
// 
//    Rev 1.52   08 Jan 1996 17:45:12   unknown
// Check destination pointer before using it
// 
//    Rev 1.51   08 Jan 1996 12:18:20   RMCKENZX
// Added logic to implement frame-mirroring and 
// 320x240 still frames.
// 
//    Rev 1.50   06 Jan 1996 18:39:46   RMCKENZX
// Updated copyright
// 
//    Rev 1.49   06 Jan 1996 18:34:28   RMCKENZX
// Made changes to support still frame at 320x240 resolution
// 
//    Rev 1.48   03 Jan 1996 16:52:40   TRGARDOS
// Added code to set a boolean, bMirror, when destination 
// frame width is the negative of the source frame width.
// Added if statement so that FrameMirror is called instead
// of FrameCopy when bMirror is set. This only works for
// H.263 bit streams. A new function has to be written for
// YUV12 data.
// 
//    Rev 1.47   18 Dec 1995 12:44:28   RMCKENZX
// added copyright notice
// 
//    Rev 1.46   15 Dec 1995 13:51:56   RHAZRA
// 
// Added code to force fpBlockAction->u8BlkType = BT_EMPTY in
// block action stream initialization
// 
//    Rev 1.45   13 Dec 1995 11:00:42   RHAZRA
// No change.
// 
//    Rev 1.44   11 Dec 1995 11:31:22   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.43   09 Dec 1995 17:26:36   RMCKENZX
// Re-architected the decoder, splitting into a 2-pass
// approach.  See comments in the code.
// 
//    Rev 1.41   09 Nov 1995 14:09:18   AGUPTA2
// Changes for PB-frame (call new ExpandYPlane, ExpandUVPlane rtns.)
// 
//    Rev 1.40   30 Oct 1995 14:08:00   TRGARDOS
// Second attempt - turn off aspect ration correction.
// 
//    Rev 1.39   30 Oct 1995 13:25:14   TRGARDOS
// Turned off aspect ration correction in color convertor.
// 
//    Rev 1.38   27 Oct 1995 16:21:56   CZHU
// Added support to return P frame in the PB pair if the bitstream is
// encoder with special null frame following previous PB frame
// 
//    Rev 1.37   26 Oct 1995 11:25:16   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.36   25 Oct 1995 18:09:02   BNICKERS
// 
// Switch to YUV12 color convertors.  Clean up archival stuff.
// 
//    Rev 1.35   13 Oct 1995 16:06:16   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.34   08 Oct 1995 13:45:56   CZHU
// 
// Added debug session to output reconstructed pels in YUV12 to a file
// 
//    Rev 1.33   27 Sep 1995 16:24:00   TRGARDOS
// 
// Added debug print statements.
// 
//    Rev 1.32   26 Sep 1995 15:32:12   CZHU
// Added expand y, u, v planes.
// 
//    Rev 1.31   26 Sep 1995 10:53:26   CZHU
// 
// Call ExpandPlane to expand each plane before half pel MC.
// 
//    Rev 1.30   25 Sep 1995 11:07:56   CZHU
// Added debug message
// 
//    Rev 1.29   21 Sep 1995 12:04:26   DBRUCKS
// fix assert
// 
//    Rev 1.28   20 Sep 1995 14:47:26   CZHU
// Added iNumberOfMBsPerGOB in decoder catalog
// 
//    Rev 1.27   19 Sep 1995 16:04:10   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.26   19 Sep 1995 11:13:16   DBRUCKS
// clarify the code that orders the YYYYCbCr data (YYYYUV) data into 
// YYYYVU in the decoder's internal memory.  The variable names were 
// incorrect in one place.  The reordering is necessary to simplify
// later conversion to YVU9.
// 
//    Rev 1.25   19 Sep 1995 10:36:46   CZHU
// Added comments to the codes added for YUV12 decoder
// 
//    Rev 1.24   18 Sep 1995 08:41:54   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.23   12 Sep 1995 11:13:00   CZHU
// 
// Copy the decoded YUV12 from Current frame to Previous frame
// to prepare for P frames
// 
//    Rev 1.22   11 Sep 1995 16:42:36   CZHU
// P frames
// 
//    Rev 1.21   11 Sep 1995 14:33:10   CZHU
// 
// Refresh MV info in BlockAction stream, needed for P frames
// 
//    Rev 1.20   08 Sep 1995 11:49:52   CZHU
// Added support for P frames and  more debug info
// 
//    Rev 1.19   07 Sep 1995 10:48:10   DBRUCKS
// added OUTPUT_MBDATA_ADDRESS option
// 
//    Rev 1.18   05 Sep 1995 17:22:12   DBRUCKS
// u & v are offset by 8 from Y in YVU12ForEnc
// 
//    Rev 1.17   01 Sep 1995 17:13:52   DBRUCKS
// add adjustpels
// 
//    Rev 1.16   01 Sep 1995 09:49:34   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.15   29 Aug 1995 16:50:40   DBRUCKS
// add support for YVU9 playback
// 
//    Rev 1.14   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.13   28 Aug 1995 10:15:14   DBRUCKS
// update to 5 July Spec and 8/25 Errata
// 
//    Rev 1.12   24 Aug 1995 08:51:30   CZHU
// Turned off apsect ratio correction. 
// 
//    Rev 1.11   23 Aug 1995 12:25:10   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.10   14 Aug 1995 16:40:34   DBRUCKS
// initialize block action stream
// 
//    Rev 1.9   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
// copy source to bitstream
// 
//    Rev 1.7   11 Aug 1995 16:12:14   DBRUCKS
// add ptr check to MB data and add #ifndef early exit
// 
//    Rev 1.6   11 Aug 1995 15:10:18   DBRUCKS
// get ready to integrate with block level code and hook up macro block level code
// 
//    Rev 1.5   03 Aug 1995 14:57:56   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.4   02 Aug 1995 15:31:34   DBRUCKS
// added GOB header parsing
// 
//    Rev 1.3   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.2   31 Jul 1995 16:28:00   DBRUCKS
// move loacl BITS defs to D3DEC.CPP
// 
//    Rev 1.1   31 Jul 1995 15:32:22   CZHU
// Moved global tables to d3tables.h
// 
//    Rev 1.0   31 Jul 1995 13:00:04   DBRUCKS
// Initial revision.
// 
//    Rev 1.3   28 Jul 1995 13:57:36   CZHU
// Started to add picture level decoding of fixed length codes.
// 
//    Rev 1.2   24 Jul 1995 14:57:52   CZHU
// Added global tables for VLD decoding. Also added instance initialization
// and termination. Several data structures are updated for H.263.
// 
//    Rev 1.1   17 Jul 1995 14:46:20   CZHU
// 
// 
//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
#endif

extern BYTE PalTable[236*4];

#if defined(H263P)
extern void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      );
extern void InitEdgeFilterTab();

/* map of coded and not-coded blocks */
char coded_map[18+1][22+1]; 
/* QP map */
char QP_map[18][22];
#else
#ifdef NEW_BEF // { NEW_BEF
// C version of block edge filter functions
// takes about 3 ms for QCIF and 12 ms for CIF on a Pentium 120. 
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr);
static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr);
static void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      );
static void InitEdgeFilterTab();
static void FreeEdgeFilterTab();
/* map of coded and not-coded blocks */
static char coded_map[18+1][22+1]; 
/* QP map */
static char QP_map[18][22];
/* table for de-blocking filter */
/* currently requires 11232 bytes */ 
signed char dtab[352*32];
#else // }{ NEW_BEF
// C version of block edge filter functions
// takes about 4 ms for QCIF and 16 ms for CIF. This is a large percentage
// of the decoding time, so we need to implement these in assembly before
// the next big release
void EdgeFilter(unsigned char *lum, unsigned char *Cb, unsigned char *Cr, 
                int pels, int lines, int pitch, int QP);
void HorizEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                     int chr, int *deltatab);
void VertEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                    int chr, int *deltatab);
/* stores information about coded and not-coded blocks */
static char coded_map[44][36]; // memory for this should probably be allocated somewhere else
#endif // } NEW_BEF
#endif
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Decoder Timing Data - per frame
*/
#define DEC_TIMING_INFO_FRAME_COUNT 105
#pragma message ("Current log decode timing computations handle 105 frames max")
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, U32 uStatFrameCount);
void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo);
#endif // } LOG_DECODE_TIMINGS_ON

extern "C" {
  void ExpandPlane(U32, U32, U32, U32);
}

static I32 iNumberOfGOBsBySourceFormat[8] = {
     0, /* FORBIDDEN */
     6, /* SQCIF */
     9, /* QCIF */
    18, /* CIF */
     0, /* 4CIF - Not supported */
     0, /* 16CIF - Not supported */
#ifdef H263P
	 0, /* Custom */
	 0  /* Extended PTYPE */
#else
     0, /* Reserved */
     0  /* Reserved */
#endif
};

static I32 iNumberOfMBsInAGOBBySourceFormat[8] = {
     0, /* FORBIDDEN */
     8, /* SQCIF */
    11, /* QCIF */
    22, /* CIF */
     0, /* 4CIF - Not supported */
     0, /* 16CIF - Not supported */
#ifdef H263P
	 0, /* Custom */
	 0  /* Extended PTYPE */
#else
     0, /* Reserved */
     0  /* Reserved */
#endif
};

//#pragma warning(disable:4101)
//#pragma warning(disable:4102)
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start);

static void H263InitializeGOBBlockActionStream(
    T_H263DecoderCatalog *DC,
    const I32             iGOBno,
    const T_BlkAction FAR *fpStartGOBBlockActionStream
);

static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
);

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale);

static void GetDecoderOptions(T_H263DecoderCatalog *);

static void ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight);

#define REUSE_DECODE    1
#define DEFAULT_BUFFER_SIZE  32768L

#if REUSE_DECODE
struct {             // Communicate Encoder's decode to display decode.
    U8 FAR * Address;                    // Addr at which encoded frame is placed.
    DECINSTINFO BIGG * PDecoderInstInfo; // Encoder's decoder instance.
    unsigned int  FrameNumber;           // Frame number last encoded, mod 128.
} CompandedFrame;
#endif


/**********************************************************************
 *  H263InitDeocderGlobal
 **********************************************************************/
LRESULT H263InitDecoderGlobal(void)
{

    return ICERR_OK;
}


/***********************************************************************
 *  Description:
 *    Initialize the MB action stream for GOB 'iGOBno'.
 *  Parameters:
 *    DC:
 *    iGOBno: GOB no counting from one;i.e. the first GOB in the frame is 1.
 *    fpStartGOBBlockActionStream: Pointer to start of the block action stream 
 *      for iGOBno.
 *  Note:
 *    This routine needs to change for picture sizes larger than CIF
 ***********************************************************************/
#pragma code_seg("IACODE1")
static void H263InitializeGOBBlockActionStream(
    T_H263DecoderCatalog *DC,
    const I32             iGOBno,
    T_BlkAction FAR      *fpStartGOBBlockActionStream
)
{
    const U32 uFrameHeight = DC->uFrameHeight;
    const U32 uFrameWidth = DC->uFrameWidth;
    const U32 uCurBlock = (U32) ((U8 FAR *)DC + DC->CurrFrame.X32_YPlane); 
    const U32 uRefBlock = (U32) ((U8 FAR *)DC + DC->PrevFrame.X32_YPlane);
    const U32 uBBlock = (U32) ((U8 FAR *)DC + DC->PBFrame.X32_YPlane);
    U32       uYOffset;
    U32       uUOffset;
    U32       uVOffset;
    U32       uYUpdate;
    U32       uUVUpdate;
    U32       uBlkNumber;
    T_BlkAction *fpBlockAction = fpStartGOBBlockActionStream;

    // assume that the width and height are multiples of 16
    ASSERT((uFrameHeight & 0xF) == 0);
    ASSERT((uFrameWidth & 0xF) == 0);

    // calculate distance to the next row.
    uYUpdate = (16 * PITCH)*(iGOBno - 1);
    uUVUpdate = (8 * PITCH)*(iGOBno - 1);

    // skip the padding used for unconstrained motion vectors
    uYOffset = Y_START + uYUpdate;
    uVOffset = DC->uSz_YPlane + UV_START + uUVUpdate;
    uUOffset = uVOffset + (PITCH >> 1);
    
    // Start with the first block of the GOB
    uBlkNumber = (iGOBno -1)*((uFrameWidth>>4)*6);

    // Initialize the array
    for (U32 xpos = 0 ; xpos < uFrameWidth ; xpos += 16) {
        U8 loadcacheline;
        // Four Y Blocks
        //     Y0 Y1
        //     Y2 Y3
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset += 8;
        fpBlockAction++;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset = uYOffset - 8 + (8 * PITCH);
        fpBlockAction++;
        
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset += 8;
        fpBlockAction++;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset = uYOffset + 8 - (8 * PITCH);
        fpBlockAction++;
        
        // Notice: although the blocks are read in YYYYUV order we store the 
        //         data in memory in Y V U order. This is accomplished because 
        //         block 5 (U) is written to the right of block 6 (V). 
        //         One Cb (U) Block
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uUOffset;
        fpBlockAction->pRefBlock = uRefBlock + uUOffset;
        fpBlockAction->pBBlock = uBBlock + uUOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uUOffset += 8;
        fpBlockAction++;
        
        // One Cr (V) Block
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uVOffset;
        fpBlockAction->pRefBlock = uRefBlock + uVOffset;
        fpBlockAction->pBBlock = uBBlock + uVOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uVOffset += 8;
        fpBlockAction++;
        
    }
} // end H263InitializeGOBBlockActionStream() 
#pragma code_seg()


/**********************************************************************
 *  H263InitDecoderInstance 
 *    This function allocates and initializes the per-instance tables used by 
 *    the H263 decoder. Note that in 16-bit Windows, the non-instance-specific
 *    global tables are copied to the per-instance data segment, so that they 
 *    can be used without segment override prefixes.
 ***********************************************************************/
LRESULT H263InitDecoderInstance(
    LPDECINST lpInst, 
    int       CodecID)
{ 
    U32 u32YActiveHeight, u32YActiveWidth;
    U32 u32UVActiveHeight, u32UVActiveWidth;
    U32 u32YPlane, u32VUPlanes ,u32YVUPlanes,u32SizeBlkActionStream;
    U32 uSizeBitStreamBuffer;
    U32 u32SizeT_IQ_INDEXBuffer, u32SizepNBuffer, u32SizeMBInfoStream;    // NEW
    U32 lOffset=0;
    U32 u32TotalSize;
    LRESULT iReturn= ICERR_OK;
    LPVOID pDecoderInstance;
    U32 * pInitLimit;
    U32 * pInitPtr;
    I32 i32xres, i32yres;

#ifdef H263P
	I32 i32xresActual, i32yresActual;	// i32xres and i32yres are padded to multiples of 16
#endif

    BOOL bIs320x240;
    T_H263DecoderCatalog * DC;
    U8                   * P32Inst;

	FX_ENTRY("H263InitDecoderInstance");

    if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
        goto done;
    }

    lpInst->Initialized = FALSE;
    
#ifdef NO_BEF // { NO_BEF
	// default block edge filter
	lpInst->bUseBlockEdgeFilter = 0;
#else // }{ NO_BEF
	// default block edge filter
	lpInst->bUseBlockEdgeFilter = 1;
#endif // } NO_BEF

#if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL) // { #if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL)
	lpInst->UseActivePalette = TRUE;
	lpInst->InitActivePalette = TRUE;
	CopyMemory((PVOID)&lpInst->ActivePalette[10], (CONST VOID *)PalTable, (DWORD)sizeof(PalTable));
#endif // } #if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL)

    // Peel off special cases here
    i32xres = lpInst->xres;
    i32yres = lpInst->yres;
    
    // use positive frame size{s}
    // (may be negative to signal frame mirroring or inverted video)
    if (i32xres < 0) i32xres = -i32xres;
    if (i32yres < 0) i32yres = -i32yres;

#ifdef H263P
	// Need to use the padded dimensions for decoding since H.263+ supports
	// custom picture formats, which are padded to multiples of 16 for encoding
	// and decoding. The actual dimensions are used for display only
	i32xresActual = i32xres;
	i32yresActual = i32yres;
	i32xres = (i32xresActual + 0xf) & ~0xf;
	i32yres = (i32yresActual + 0xf) & ~0xf;
#endif

    // Next check for 320x240 still
    if ( (CodecID == H263_CODEC) && (i32xres == 320) && (i32yres == 240) ) {
        i32xres = 352;
        i32yres = 288;
        bIs320x240 = TRUE;
    } else {
        bIs320x240 = FALSE;
    } 


#ifdef H263P
	// Add lower bounds and multiples of 4
	if ((CodecID == H263_CODEC && 
		(i32yresActual > 288 || i32yresActual < 4 || 
		 i32xresActual > 352 || i32xresActual < 4 ||
		 (i32yres & ~0x3) != i32yres || (i32xres & ~0x3) != i32xres)) ||
#else
    if ((CodecID ==  H263_CODEC && (i32yres > 288 || i32xres > 352)) ||
#endif
        (CodecID == YUV12_CODEC && (i32yres > 480 || i32xres > 640)) )
    {
		ERRORMESSAGE(("%s: Bad input image size!\r\n", _fx_));
        iReturn = ICERR_BADSIZE;
        goto done;
    }

    if (CodecID == YUV12_CODEC) 
    {
        /* The active height and width must be padded to a multiple of 8
         * since the adjustpels routine relies on it.
         */
        u32YActiveHeight  = ((i32yres + 0x7) & (~ 0x7));
        u32YActiveWidth   = ((i32xres + 0x7) & (~ 0x7));
        u32UVActiveHeight = ((i32yres + 0xF) & (~ 0xF)) >> 1;
        u32UVActiveWidth  = ((i32xres + 0xF) & (~ 0xF)) >> 1;

        u32YPlane         = u32YActiveWidth  * u32YActiveHeight;
        u32VUPlanes       = u32UVActiveWidth * u32UVActiveHeight * 2;
        u32YVUPlanes      = u32YPlane + u32VUPlanes;

        u32TotalSize = 512L + 0x1FL;   /* Just enough space for Decoder Catalog. */

    }
    else
    {
        ASSERT(CodecID == H263_CODEC);
        
        u32YActiveHeight  = i32yres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
        u32YActiveWidth   = i32xres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
        u32UVActiveHeight = u32YActiveHeight/2;
        u32UVActiveWidth  = u32YActiveWidth /2;
       
        u32YPlane         = PITCH * u32YActiveHeight;
        u32VUPlanes       = PITCH * u32UVActiveHeight;
        u32YVUPlanes      = u32YPlane + u32VUPlanes;

        // calculate the block action stream size.  The Y portion has one block 
        // for every 8x8 region.  The U and V portion has one block for every 
        // 16x16 region. We also want to make sure that the size is aligned to 
        // a cache line.
        u32SizeBlkActionStream = (i32xres >> 3) * (i32yres >> 3);
        u32SizeBlkActionStream += ((i32xres >> 4) * (i32yres >> 4)) * 2;
        u32SizeBlkActionStream *= sizeof (T_BlkAction);
        u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;
        
        // calculate sizes of NEW data structures     
        u32SizeT_IQ_INDEXBuffer = (i32xres)*(i32yres*3)*sizeof(T_IQ_INDEX);
        u32SizepNBuffer = (i32xres>>4)*(i32yres>>4)*sizeof(U32)*12;
        u32SizeMBInfoStream = (i32xres>>4)*(i32yres>>4)*sizeof(T_MBInfo);

        // calculate the bitstream buffer size.  We copy the input data to a 
        // buffer in our space because we read ahead up to 4 bytes beyond the 
        // end of the input data.  The input data size changes for each frame.  
        // So the following is a very safe upper bound estimate.    I am using 
        // the same formula as in CompressGetSize().
        
        uSizeBitStreamBuffer = i32yres * i32xres;
        // RH:  allocate bit-stream buffer according to the max size
        //      specified in the spec.
		/*
        if ( 
            ((i32xres == 176) && (i32yres == 144)) 
            ||
            ((i32xres == 128) && (i32yres == 96))             
           )
           uSizeBitStreamBuffer = 8 * 1024;
        else 
        {
           if ( (i32xres == 352) && (i32yres == 288) )
              uSizeBitStreamBuffer = 32 * 1024;
           else    
           { // Should never happen
               DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADSIZE");
               iReturn = ICERR_BADSIZE;
               goto done;
           } 
        }
        */
        u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
                       u32SizeBlkActionStream +
                       u32YVUPlanes +            // current frame
                       u32YVUPlanes +            // prev frame
                       u32YVUPlanes +            // B frame
                       uSizeBitStreamBuffer +    // input data
                       MB_MC_BUFFER_SIZE +
                       u32SizeT_IQ_INDEXBuffer + // NEW
                       u32SizepNBuffer         + // NEW
                       u32SizeMBInfoStream     + // PB-NEW
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
                       (DEC_TIMING_INFO_FRAME_COUNT+4) * sizeof (DEC_TIMING_INFO)     + // Timing infos
#endif // } LOG_DECODE_TIMINGS_ON
                       0x1F;
    }

    // allocate the memory for the instance
	lpInst->pDecoderInst = HeapAlloc(GetProcessHeap(), 0, u32TotalSize);
    if (lpInst->pDecoderInst == NULL)
    {
		ERRORMESSAGE(("%s: Can't allocate %ld bytes!\r\n", _fx_, u32TotalSize));
        iReturn = ICERR_MEMORY;
        goto  done;
    }

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "D3DEC: %7ld Ln %5ld\0", u32TotalSize, __LINE__);
	AddName((unsigned int)lpInst->pDecoderInst, gsz1);
#endif

	pDecoderInstance = lpInst->pDecoderInst;

    //build the decoder catalog 
    P32Inst = (U8 *) pDecoderInstance;
    P32Inst = (U8 *) ((((U32) P32Inst) + 31) & ~0x1F);
 
    //  The catalog of per-instance data is at the start of the per-instance data.
    DC = (T_H263DecoderCatalog *) P32Inst;

    DC->DecoderType       = CodecID;
    DC->uFrameHeight      = i32yres;
    DC->uFrameWidth       = i32xres;

#ifdef H263P
	DC->uActualFrameHeight = i32yresActual;
	DC->uActualFrameWidth  = i32xresActual;

    if (CodecID == YUV12_CODEC) {
		// YUV12 data is not padded out to multiples of 16 as H.263+ frames are
		// Therefore, only use the actual frame dimensions!
		DC->uFrameHeight = DC->uActualFrameHeight;
		DC->uFrameWidth = DC->uActualFrameWidth;
	}
#endif

    DC->uYActiveHeight    = u32YActiveHeight;
    DC->uYActiveWidth     = u32YActiveWidth;
    DC->uUVActiveHeight   = u32UVActiveHeight;
    DC->uUVActiveWidth    = u32UVActiveWidth;
    DC->uSz_YPlane        = u32YPlane;
    DC->uSz_VUPlanes      = u32VUPlanes;
    DC->uSz_YVUPlanes     = u32YVUPlanes;
    DC->BrightnessSetting = H26X_DEFAULT_BRIGHTNESS;
    DC->ContrastSetting   = H26X_DEFAULT_CONTRAST;
    DC->SaturationSetting = H26X_DEFAULT_SATURATION;
    DC->iAPColorConvPrev  = 0;
    DC->pAPInstPrev       = NULL; // assume no previous AP instance.
    DC->p16InstPostProcess = NULL;
    DC->_p16InstPostProcess = (void *)NULL;
    DC->uIs320x240 = bIs320x240;
    DC->bReadSrcFormat = FALSE;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    DC->uStatFrameCount = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

    /* Get the Options
     */
    GetDecoderOptions(DC);

    if (CodecID == H263_CODEC)
    {
        // Notice: Decoder memory is stored in YVU order.  This simplifies 
        //         working with the color converters which use YVU12.  
        // LONG TERM: We may want to change this someday because the encoder 
        //            stores data in YUV order.  Or perhaps the encoder should 
        //            change?

        lOffset =  INSTANCE_DATA_FIXED_SIZE;
        DC->Ticker = 127;

        //instance dependent table here
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X16_BlkActionStream = lOffset;
        lOffset += u32SizeBlkActionStream;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->CurrFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->CurrFrame.X32_VPlane = lOffset;
        DC->CurrFrame.X32_UPlane = DC->CurrFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->CurrFrame.X32_UPlane & 0x7) == 0);  // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        //no padding is needed 
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PrevFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PrevFrame.X32_VPlane = lOffset;
        DC->PrevFrame.X32_UPlane = DC->PrevFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->PrevFrame.X32_UPlane & 0x7) == 0);  // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        // B Frame
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PBFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;
                   
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PBFrame.X32_VPlane = lOffset;
        DC->PBFrame.X32_UPlane = DC->PBFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->PBFrame.X32_UPlane & 0x7) == 0);    // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        // Bitstream
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_BitStream = lOffset;
        lOffset += uSizeBitStreamBuffer;
        DC->uSizeBitStreamBuffer = uSizeBitStreamBuffer;

        DC->uMBBuffer = lOffset;
        // MMX IDCT writes its output to (DC->uMBBuffer + BLOCK_BUFFER_OFFSET)
        // and so it must be aligned at QWORD
        ASSERT((( (U32)DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET) & 0x7) == 0);
        lOffset += MB_MC_BUFFER_SIZE;

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_InverseQuant = lOffset; 
        lOffset += u32SizeT_IQ_INDEXBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_pN = lOffset; 
        lOffset += u32SizepNBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_uMBInfoStream = lOffset; 
        lOffset += u32SizeMBInfoStream; 

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		// Decode Timing Info
		DC->X32_DecTimingInfo = lOffset;
		lOffset += (DEC_TIMING_INFO_FRAME_COUNT+4) * sizeof (DEC_TIMING_INFO);
#endif // } LOG_DECODE_TIMINGS_ON

        // init the data
        
        ASSERT((U32)lOffset <= u32TotalSize);
        pInitLimit = (U32  *) (P32Inst + lOffset);
        pInitPtr = (U32  *) (P32Inst + DC->CurrFrame.X32_YPlane);
        for (;pInitPtr < pInitLimit;pInitPtr++)    *pInitPtr =0;

		// Fill the Y,U,V Previous Frame space with black, this way
		// even if we lose an I frame, the background will remain black
		ZeroFill((HPBYTE)P32Inst + DC->PrevFrame.X32_YPlane + Y_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_UPlane + UV_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_VPlane + UV_START,           
				PITCH,
				DC->uFrameWidth,
				DC->uFrameHeight);

        // H263InitializeBlockActionStream(DC);

    } // H263

#ifdef NEW_BEF // { NEW_BEF
	// Initialize de-blocking filter
	{
		int i,j;

		for (j = 0; j < 19; j++) {
			for (i = 0; i < 23; i++) {
				coded_map[j][i] = 0;
			}
		}
		InitEdgeFilterTab();
	}	 
#endif // } NEW_BEF

    lpInst->Initialized = TRUE;
    iReturn = ICERR_OK;

done:
    return iReturn;
}

/***********************************************************************
 *  ZeroFill
 *    Fill the YVU data area with black.
 ***********************************************************************/
static void	ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8)16;
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8)128;
            *hpbU++ = (U8)128;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
}

/***********************************************************************
 *  TestFill
 *    Fill the YVU data area with a test pattern.
 ***********************************************************************/
#if 0
static void
TestFill(
    HPBYTE hpbY,
    HPBYTE hpbU,
    HPBYTE hpbV,
    int    iPitch,
    U32    uWidth,
    U32    uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8) (y + (w & ~0xF));
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    u = 0x4e * 2;
    v = 44;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8) v;
            *hpbU++ = (U8) u;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
} /* end TestFill */
static void
TestFillUV(
    HPBYTE hpbU,
    HPBYTE hpbV,
    int iPitch,
    U32 uWidth,
    U32 uHeight)
{
    U32 w,h;
    int u,v;
    U32 uNext;
    HPBYTE pU, pV;

    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    u = 128;
    v = 128;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8) v;
            *hpbU++ = (U8) u;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
} // end TestFill
#endif


/*********************************************************************
 *  H263Decompress
 *    This function drives the decompress and display of one frame
 *********************************************************************/
LRESULT H263Decompress(
    LPDECINST            lpInst, 
    ICDECOMPRESSEX FAR * lpicDecEx, 
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    BOOL                 bIsDCI,
	BOOL				 bRealDecompress)
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    BOOL                 bIsDCI)
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

{
    LRESULT                iReturn = ICERR_ERROR;
    U8 FAR               * fpSrc;
    U8 FAR               * P32Inst;
    U8 FAR               * fpu8MaxPtr;
    LPVOID                 pDecoderInstance = NULL;
    T_H263DecoderCatalog * DC = NULL;
    I32                    iNumberOfGOBs, iNumberOfMBs, iBlockNumber = 0;
    T_BlkAction FAR      * fpBlockAction;
    LONG                   lOutput;
    int                    intPitch; 
    U32                    uNewOffsetToLine0, uNewFrameHeight;
    BOOL                   bShapingFlag, bMirror;
    U32                    uYPitch, uUVPitch;

    T_IQ_INDEX           * pRUN_INVERSE_Q;  
    U32                  * pN;                     
    T_MBInfo FAR         * fpMBInfo;      
    
    U32                    uSaveHeight, uSaveWidth, utemp, uYPlane, uUPlane;
	I32                    uVPlane;
    U8                   * pFrame;

    U32                   uWork;                 //  variables for reading bits
    U32                   uBitsReady; 
    BITSTREAM_STATE       bsState;
    BITSTREAM_STATE FAR * fpbsState = &bsState;
    I32                   gob_start = 1, mb_start = 1, b_skip;
	I8                    p8MVs[4]={0,0,0,0};
#ifdef H263P
	BOOL bTmpPostProcessBEF;
#endif

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uDecodeTime = 0;
	U32 uBEFTime = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	U32 uDecIDCTCoeffs = 0;
	U32 uHeaders = 0;
	U32 uMemcpy = 0;
	U32 uFrameCopy = 0;
	U32 uOutputCC = 0;
	U32 uIDCTandMC = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
#endif // } LOG_DECODE_TIMINGS_ON

	FX_ENTRY("H263Decompress");

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (bRealDecompress)
	{
		TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

    // check the input pointers
    if (IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))||
        IsBadReadPtr((LPVOID)lpicDecEx, sizeof(ICDECOMPRESSEX)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
        goto done;
    }
    
    // Check for a bad length
    if (lpicDecEx->lpbiSrc->biSizeImage == 0) {
		ERRORMESSAGE(("%s: Bad image size!\r\n", _fx_));
        iReturn = ICERR_BADIMAGESIZE;    
        goto done;
    }

    // set local pointer to global memory
    pDecoderInstance = lpInst->pDecoderInst;

    // Set the frame mirroring flag
    bMirror = FALSE;
    if (lpicDecEx->lpbiDst != 0)
    {
        if(lpicDecEx->lpbiSrc->biWidth * lpicDecEx->lpbiDst->biWidth < 0)
            bMirror = TRUE;
    }

    // Build the decoder catalog pointer 
    P32Inst = (U8 FAR *) pDecoderInstance;
    P32Inst = (U8 FAR *) ((((U32) P32Inst) + 31) & ~0x1F);
    DC = (T_H263DecoderCatalog FAR *) P32Inst;

    if (DC->DecoderType == H263_CODEC)
    {

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		if (bRealDecompress)
		{
			if ((DC->uStatFrameCount <= DEC_TIMING_INFO_FRAME_COUNT) && (DC->ColorConvertor != YUV12ForEnc))
			{
				if (DC->X32_DecTimingInfo > 0)
					DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)P32Inst) + DC->X32_DecTimingInfo );
				DC->uStartLow = uStartLow;
				DC->uStartHigh = uStartHigh;
			}
			else
			{	
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *) NULL;
			}
			DC->bTimingThisFrame = bTimingThisFrame;
		}
#endif // } LOG_DECODE_TIMINGS_ON

		// Check if h263test.ini has been used to override custom message
		// for block edge filter. If BlockEdgeFilter is not specified in
		// the [Decode] section of h263test.ini, DC->bUseBlockEdgeFilter 
		// will be set to 2, and the value specified in a custom message
		// will be chosen.
		if (DC->bUseBlockEdgeFilter == 2) {	 
			DC->bUseBlockEdgeFilter = lpInst->bUseBlockEdgeFilter;
		}


        // First check to see if we are just going to return the P frame
        // which we have already decoded.
        
        /*********************************************************************
         *
         *  Hack for the special "Null" P frames for Windows
         *
         *********************************************************************/
        if (lpicDecEx->lpbiSrc->biSizeImage != 8)
        {

            /* Is there room to copy the bitstream data? */
            // OLD: ASSERT(lpicDecEx->lpbiSrc->biSizeImage <= DC->uSizeBitStreamBuffer);
            // RH:  Make sure that the bitstream can be fit in our allocated buffer. If
            // not, return an error.
            
            if ( lpicDecEx->lpbiSrc->biSizeImage > DC->uSizeBitStreamBuffer) {
				ERRORMESSAGE(("%s: Internal buffer (%ld bytes) too small for input data (%ld bytes)!\r\n", _fx_, DC->uSizeBitStreamBuffer, lpicDecEx->lpbiSrc->biSizeImage));
				if (!H263RTP_VerifyBsInfoStream(DC,
					                           (U8 *) lpicDecEx->lpSrc,
					                            lpicDecEx->lpbiSrc->biSizeImage)) 
				{
					ERRORMESSAGE(("%s: Input buffer too big without RTP extention!\r\n", _fx_));
					iReturn = ICERR_ERROR;
                    goto done;
				}
				else
				 lpicDecEx->lpbiSrc->biSizeImage= DC->uSizeBitStreamBuffer;
            }

            // Copy the source data to the bitstream region.
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            fpSrc = (U8 FAR *)(P32Inst + DC->X32_BitStream);
            memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, 
                   lpicDecEx->lpbiSrc->biSizeImage);  

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMemcpy)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            // Initialize the bit stream reader 
            GET_BITS_INIT(uWork, uBitsReady);

//#ifdef LOSS_RECOVERY
            DC->Sz_BitStream = lpicDecEx->lpbiSrc->biSizeImage;
            // H263RTP_VerifyBsInfoStream(DC,fpSrc,DC->Sz_BitStream);
            //RtpForcePacketLoss(fpSrc,lpicDecEx->lpbiSrc->biSizeImage,0);
//#endif    
            //  Initialize pointers to data structures which carry info 
            //  between passes
            pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);
            pN             = (U32 *)(P32Inst + DC->X32_pN);
            fpMBInfo       = (T_MBInfo FAR *) (P32Inst + DC->X32_uMBInfoStream);

            // Initialize block action stream  pointer
            iBlockNumber = 0;
            fpBlockAction = (T_BlkAction FAR *)(P32Inst + DC->X16_BlkActionStream);

            // Decode the Picture Header
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, 
                                              fpbsState);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeaders)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (iReturn == PACKET_FAULT) 
            {
				ERRORMESSAGE(("%s: PSC lost!\r\n", _fx_));
                iReturn = RtpGetPicHeaderFromBsExt(DC);
                if (iReturn != ICERR_OK)
                    goto done;

                iReturn = RtpH263FindNextPacket(DC, fpbsState, &pN, 
                              &DC->uPQuant, (int *)&mb_start, (int *)&gob_start,p8MVs);
                if (iReturn == NEXT_MODE_A) 
                {    
                    //trick it for now, do not change without consulting Chad
                    gob_start++;
					mb_start++;  
                    ERRORMESSAGE(("%s: Next packet following lost PSC is in MODE A\r\n", _fx_));
                }
                else if ((iReturn == NEXT_MODE_B) || (iReturn == NEXT_MODE_C))
                {
					int k;
  					if (iReturn == NEXT_MODE_B) 
					{
						k=1;
						ERRORMESSAGE(("%s: Next packet in MODE B\r\n", _fx_));
					}
					else
					{
						ERRORMESSAGE(("%s: Next packet in MODE C\r\n", _fx_));
						k=2;
					}

#ifdef H263P
					// The number of MB's is merely (width / 16)
					iNumberOfMBs = DC->uFrameWidth >> 4;
#else
                    iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];
#endif

                    b_skip = (gob_start* iNumberOfMBs + mb_start)*6*k;
                    for ( k=0; k < b_skip; k++)  *pN++=0;
                    fpBlockAction += b_skip;
                    iBlockNumber  += b_skip;
                    fpMBInfo  += b_skip/6;
                    mb_start++;
                    gob_start++;
					/*for (k=0;k<6;k++)
					{
						fpBlockAction[k].i8MVx2 = p8MVs[0];
						fpBlockAction[k].i8MVy2 = p8MVs[1];
					} */

                }
                else 
                {
                    iReturn = ICERR_UNSUPPORTED;
                    goto done;
                }
            }
            else
            //old code before merging
            if (iReturn != ICERR_OK)
            {
				ERRORMESSAGE(("%s: Error reading the picture header!\r\n", _fx_));
                goto done;
            }
    
            // Set a limit for testing for bitstream over-run
            fpu8MaxPtr = fpSrc;
            fpu8MaxPtr += (lpicDecEx->lpbiSrc->biSizeImage - 1);  
            
            // Initialize some constants
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
			if (DC->uFrameHeight < 500)
				// Each GOB consists of 16 lines
				iNumberOfGOBs = DC->uFrameHeight >> 4;
			else if (DC->uFrameHeight < 996)
				// Each GOB consists of 32 lines
				iNumberOfGOBs = DC->uFrameHeight >> 5;
			else
				// Each GOB consists of 64 lines
				iNumberOfGOBs = DC->uFrameHeight >> 6;

			iNumberOfMBs = DC->uFrameWidth >> 4;
#else
            iNumberOfGOBs = iNumberOfGOBsBySourceFormat[DC->uSrcFormat];
            iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];
#endif
            DC->iNumberOfMBsPerGOB = iNumberOfMBs;
            
            /* 
             * Check dimensions:
             *  In H263 a GOB is a single row of MB, and a MB is 16x16 
             */
            ASSERT(((U32)iNumberOfGOBs * 16) == DC->uFrameHeight);
            ASSERT(((U32)iNumberOfMBs * 16) == DC->uFrameWidth);
            
            /*****************************************************************
              FIRST PASS - bitream parsing and IDCT prep work
              ***************************************************************/
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
            {
                __asm {
                    _emit 0x0f 
                    _emit 0x77  //  emms
                }
            }
#endif // } USE_MMX
            iReturn = IAPass1ProcessFrame(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
                // decode and inverse quantize the transform coefficients
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecIDCTCoeffs)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (iReturn != ICERR_OK) {
				ERRORMESSAGE(("%s: Error during first pass - bitream parsing and IDCT prep work!\r\n", _fx_));
                goto done;
            }
            
            /*****************************************************************
              SECOND PASS - IDCT and motion compensation (MC)
              ***************************************************************/
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (DC->bAdvancedPrediction || DC->bUnrestrictedMotionVectors)
            {
                //  Change parameter profile once Bob is finished making
                //  changes to ExpandPlane routine : AG
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_YPlane + Y_START),
                            (U32) (DC->uFrameWidth),
                            (U32) (DC->uFrameHeight), 
                            16); // TODO 16  number of pels to expand by
                
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_VPlane + UV_START),
                            (U32) (DC->uFrameWidth>>1), 
                            (U32) (DC->uFrameHeight>>1), 
                            8); // TODO 8
                
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_UPlane + UV_START),
                            (U32) (DC->uFrameWidth>>1), 
                            (U32) (DC->uFrameHeight>>1), 
                            8);  // TODO 8
            }

            fpBlockAction  = (T_BlkAction FAR *) (P32Inst + DC->X16_BlkActionStream);
            pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);  
            pN             = (U32 *)(P32Inst + DC->X32_pN);                               
            fpMBInfo       = (T_MBInfo FAR *)(P32Inst + DC->X32_uMBInfoStream);

            IAPass2ProcessFrame(DC,
                                fpBlockAction,
                                fpMBInfo,
                                pN,
                                pRUN_INVERSE_Q,
                                iNumberOfGOBs,
                                iNumberOfMBs);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uIDCTandMC)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef H263P
            if (DC->bDeblockingFilter) {
				// In the loop deblocking filter.
				// Annex J, document LBC-96-358
				// If the filtering is performed inside the loop, we
				// do not also perform a post-process block edge filter.

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
				if (bRealDecompress)
				{
					TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
				}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

				bTmpPostProcessBEF = DC->bUseBlockEdgeFilter;
				DC->bUseBlockEdgeFilter = FALSE;

				EdgeFilter((U8 *)DC + DC->CurrFrame.X32_YPlane + Y_START,
                           (U8 *)DC + DC->CurrFrame.X32_VPlane + UV_START,
                           (U8 *)DC + DC->CurrFrame.X32_UPlane + UV_START,
                           DC->uFrameWidth,
                           DC->uFrameHeight,
                           PITCH);

	            if (DC->bPBFrame) 
				{
					// Filtering of B frames is not a manner of standardization.
					// We do it since we assume that it will yield improved
					// picture quality.
					// TODO, verify this assumption.
					EdgeFilter((U8 *)DC + DC->PBFrame.X32_YPlane + Y_START,
							   (U8 *)DC + DC->PBFrame.X32_VPlane + UV_START,
							   (U8 *)DC + DC->PBFrame.X32_UPlane + UV_START,
							   DC->uFrameWidth,
							   DC->uFrameHeight,
							   PITCH);
				}

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
				if (bRealDecompress)
				{
					TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFTime)
				}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

			} // if (DC->bDeblockingFilter)
#endif // H263P

            //copy to the reference frame to prepare for the next frame
            // Decide which frame to display
            if (DC->bPBFrame)
            {    // Set pointers to return B frame for PB pair
                DC->DispFrame.X32_YPlane = DC->PBFrame.X32_YPlane;
                DC->DispFrame.X32_VPlane = DC->PBFrame.X32_VPlane;
                DC->DispFrame.X32_UPlane = DC->PBFrame.X32_UPlane;
            }
            else 
            { // Set pointers to return future P of PB pair
                DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
                DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
                DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;
            }
            
            utemp                    = DC->CurrFrame.X32_YPlane;
            DC->CurrFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
            DC->PrevFrame.X32_YPlane = utemp;
            
            utemp                    = DC->CurrFrame.X32_VPlane ;
            DC->CurrFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
            DC->PrevFrame.X32_VPlane = utemp;
            
            utemp                    = DC->CurrFrame.X32_UPlane ;
            DC->CurrFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
            DC->PrevFrame.X32_UPlane = utemp;
        }
        /*********************************************************************
         *
         *  Hack for the special "Null" P frames for Windows
         *
         *********************************************************************/
        else  //  lpicDecEx->lpbiSrc->biSizeImage == 8
        { // Set pointers to return P frame for PB pair
#ifdef _DEBUG
            if (!DC->bPBFrame)
			{
                ERRORMESSAGE(("%s: Null frame received even though previous was not PB\r\n", _fx_));
            }
#endif
            DC->DispFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
            DC->DispFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
            DC->DispFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
        }
    }  // end of H263_CODEC
    else
    {    // why is this here???  Is it really needed for YUV12 display? 
        DC->DispFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
        DC->DispFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
        DC->DispFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
    }
    
    // Return if there is no need to update screen yet.
    if(lpicDecEx->dwFlags & ICDECOMPRESS_HURRYUP) {
        iReturn = ICERR_DONTDRAW;
        goto done;
    }

    if (DC->ColorConvertor == YUV12ForEnc) 
    {
        /* NOTICE: This color converter reverses the order of the data in 
         *         memory.  The decoder uses YVU order and the encoder uses 
         *         YUV order.
         */
        //  TODO can this be DispFrame ????  Trying to get rid of 
        //  references to PrevFrame and CurrFrame after this point  
        H26x_YUV12ForEnc ((HPBYTE)P32Inst,
                          DC->PrevFrame.X32_YPlane + Y_START,
                          DC->PrevFrame.X32_VPlane + UV_START,
                          DC->PrevFrame.X32_UPlane + UV_START,
                          DC->uFrameWidth,
                          DC->uFrameHeight,
                          PITCH,
                          (HPBYTE)lpicDecEx->lpDst,
                          (DWORD)Y_START,
                          (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START + PITCH / 2,
                          (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START);
        iReturn = ICERR_OK;
        goto done;
    }

#if 0
    // Fill the Y,U,V Current Frame space with a test pattern
    TestFill((HPBYTE)P32Inst + DC->DispFrame.X32_YPlane + Y_START,
             (HPBYTE)P32Inst + DC->DispFrame.X32_UPlane + UV_START,
             (HPBYTE)P32Inst + DC->DispFrame.X32_VPlane + UV_START,           
                 PITCH,
             DC->uFrameWidth,
             DC->uFrameHeight);
#endif

#if MAKE_GRAY
    // Fill the U,V Current Frame space with a test pattern
    TestFillUV((HPBYTE)P32Inst + DC->DispFrame.X32_UPlane + UV_START,
               (HPBYTE)P32Inst + DC->DispFrame.X32_VPlane + UV_START,           
                   PITCH,
               DC->uFrameWidth,
               DC->uFrameHeight);
#endif

    /* Special case the YVU12 for the encoder because it should not include 
     * BEF, Shaping or aspect ratio correction...
     */

    // Copy Planes to Post Processing area, and block edge filter.
    if (DC->DecoderType == H263_CODEC)
    {
        //  3/5/96: Steve asserted that mirroring is not needed for the remote 
        //  stream (i.e. H263_CODEC)  -a.g.
        //  But I will leave this code in.
        uYPitch  = PITCH;
        uUVPitch = PITCH;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		if (bRealDecompress)
		{
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		}
#endif // } DETAILED_DECODE_TIMINGS_ON

        if(bMirror) 
        {
            // copy with mirroring
            pFrame  = (U8 *)DC->p16InstPostProcess;
            uYPlane = DC->PostFrame.X32_YPlane;
            uUPlane = DC->PostFrame.X32_UPlane;
            uVPlane = DC->PostFrame.X32_VPlane;

            FrameMirror((U8 *)DC + DC->DispFrame.X32_YPlane + Y_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
#ifdef H263P
				DC->uActualFrameHeight,
				DC->uActualFrameWidth,
#else
                DC->uFrameHeight,
                DC->uFrameWidth,
#endif
                PITCH);
            FrameMirror((U8 *)DC + DC->DispFrame.X32_UPlane + UV_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
#ifdef H263P
				DC->uActualFrameHeight/2,
				DC->uActualFrameWidth/2,
#else
                DC->uFrameHeight/2,
                DC->uFrameWidth/2,
#endif
                PITCH);
            FrameMirror((U8 *)DC + DC->DispFrame.X32_VPlane + UV_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
#ifdef H263P
				DC->uActualFrameHeight/2,
				DC->uActualFrameWidth/2,
#else
                DC->uFrameHeight/2,
                DC->uFrameWidth/2,
#endif
                PITCH);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

        }
        else 
        { // no mirroring

            // check for 320x240 still
            if (DC->uIs320x240) {
                // save frame size, set 320 x 240 size, then copy as normal
                uSaveWidth = DC->uFrameWidth;
                uSaveHeight = DC->uFrameHeight;
                DC->uFrameWidth = 320;
                DC->uFrameHeight = 240;

                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
                    ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
                   DC->uFrameHeight,
                   DC->uFrameWidth,
                   PITCH);
                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_UPlane + UV_START,
                   ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
                   DC->uFrameHeight/2,
                   DC->uFrameWidth/2,
                   PITCH);
                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_VPlane + UV_START,
                   ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
                   DC->uFrameHeight/2,
                   DC->uFrameWidth/2,
                   PITCH);

                pFrame  = (U8 *)DC->p16InstPostProcess;
                uYPlane = DC->PostFrame.X32_YPlane;
                uUPlane = DC->PostFrame.X32_UPlane;
                uVPlane = DC->PostFrame.X32_VPlane;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
				if (bRealDecompress)
				{
					TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
				}
#endif // } DETAILED_DECODE_TIMINGS_ON

            }
            else
            {
				// Added checks for adjusting video effects. Since pFrame must be
				// set to DC->p16InstPostProcess to call AdjustPels, the FrameCopy
				// must be done.
				if (!(DC->bUseBlockEdgeFilter || DC->bAdjustLuma || DC->bAdjustChroma)) 
				{
					//  New color convertors do not destroy Y plane input and so
					//  we do not have to do a frame copy
	            	pFrame  = (U8 *)DC;
	            	uYPlane = DC->DispFrame.X32_YPlane + Y_START;
	            	uUPlane = DC->DispFrame.X32_UPlane + UV_START;
	            	uVPlane = DC->DispFrame.X32_VPlane + UV_START;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
					if (bRealDecompress)
					{
						TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
					}
#endif // } DETAILED_DECODE_TIMINGS_ON

				}
				else
				{
					// The block edge filtered frame can not be used as a reference
					// and we need to make a copy of the frame before doing the
					// block edge filtering.
					// This is also true for adjusting pels.
			    	FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
						   DC->uFrameHeight,
						   DC->uFrameWidth,
						   PITCH);
		            FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_UPlane + UV_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
			               DC->uFrameHeight/2,
						   DC->uFrameWidth/2,
						   PITCH);
			    	FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_VPlane + UV_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
			               DC->uFrameHeight/2,
						   DC->uFrameWidth/2,
						   PITCH);
					pFrame  = (U8 *)DC->p16InstPostProcess;
	            	uYPlane = DC->PostFrame.X32_YPlane;
	            	uUPlane = DC->PostFrame.X32_UPlane;
	            	uVPlane = DC->PostFrame.X32_VPlane;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
					if (bRealDecompress)
					{
						TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
					}
#endif // } DETAILED_DECODE_TIMINGS_ON

					if (DC->bUseBlockEdgeFilter) {
						// C version of block edge filter
						// should this be added to the mirrored case?
						// it should not be added to the b320x240 case
						// since we want that to be as sharp as possible
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
						if (bRealDecompress)
						{
							TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
						}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

						EdgeFilter((unsigned char *)(pFrame + uYPlane),
								   (unsigned char *)(pFrame + uUPlane),
								   (unsigned char *)(pFrame + uVPlane),
#ifndef NEW_BEF // { NEW_BEF
								   DC->uPQuant,
#endif // } NEW_BEF
								   DC->uFrameWidth,
								   DC->uFrameHeight,
								   PITCH);

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
						if (bRealDecompress)
						{
							TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFTime)
						}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
					}
				}
			}
		} // end no mirroring case
#ifdef H263P
		if (DC->bDeblockingFilter) {
			// Restore post-process (i.e., outside of loop) block edge filter flag
			DC->bUseBlockEdgeFilter = bTmpPostProcessBEF;
		}
#endif
    }
    else   // YUV12
    {
        const U32 uHeight = DC->uFrameHeight;
        const U32 uWidth  = DC->uFrameWidth;
        const U32 uYPlaneSize = uHeight*uWidth;

        uYPitch  = uWidth;
        uUVPitch = uWidth >> 1;

        if(bMirror) // mirroring and YUV12
        {
            HPBYTE pSource, pDestination;

            pFrame  = DC->p16InstPostProcess;
            uYPlane = DC->PostFrame.X32_YPlane;
            uUPlane = uYPlane + uYPlaneSize;
            uVPlane = uUPlane + (uYPlaneSize>>2);

            pSource = (HPBYTE)lpicDecEx->lpSrc;
            pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
            FrameMirror (pSource, pDestination, uHeight, uWidth, uWidth);

            pSource      += uYPlaneSize;
            pDestination += uYPlaneSize;
            FrameMirror (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);

            pSource += (uYPlaneSize>>2);
            pDestination += (uYPlaneSize>>2);
            FrameMirror (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
        }
        else // no mirroring
        {
            HPBYTE pSource, pDestination;
            if (DC->bAdjustLuma || DC->bAdjustChroma) {

				pFrame  = DC->p16InstPostProcess;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				pSource = (HPBYTE)lpicDecEx->lpSrc;
				pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
				FrameCopy (pSource, pDestination, uHeight, uWidth, uWidth);

				pSource      += uYPlaneSize;
				pDestination += uYPlaneSize;
				FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);

				pSource += (uYPlaneSize>>2);
				pDestination += (uYPlaneSize>>2);
				FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
			} else {
				// Copy the V plane from the source buffer into DC because the
				// input buffer may end at the end of a section. The assembler versions
				// of the color convertors are optimized to read ahead, in which case
				// a GPF occurs if the buffer is at the end of a section.
				pFrame  = (HPBYTE)lpicDecEx->lpSrc;
				uYPlane = 0;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

                pSource = (HPBYTE)lpicDecEx->lpSrc + uYPlane + uYPlaneSize + (uYPlaneSize >> 2);
                pDestination = (HPBYTE)DC->p16InstPostProcess + DC->PostFrame.X32_YPlane +
					uYPlaneSize + (uYPlaneSize >> 2);
                FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
				uVPlane += (pDestination - pSource);
			}
        }
         
    }  //  else YUV12

    // Check if we are to do aspect ration correction on this frame.
    if (DC->bForceOnAspectRatioCorrection || lpInst->bCorrectAspectRatio) {
        bShapingFlag = 1;
        uNewFrameHeight = (DC->uFrameHeight * 11 / 12);
    } else {
        bShapingFlag = 0;
        uNewFrameHeight = DC->uFrameHeight;
    }

    // Do the PEL color adjustments if necessary.
    if(DC->bAdjustLuma) 
    {
        // width is rounded up to a multiple of 8
        AdjustPels(pFrame,
                   uYPlane,
                   DC->uFrameWidth,
                   uYPitch,
                   DC->uFrameHeight,
                   (U32) DC->X16_LumaAdjustment);
    }
    if(DC->bAdjustChroma) 
    {
        // width = Y-Width / 4 and then rounded up to a multiple of 8
        AdjustPels(pFrame,
                   uUPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                  (U32) DC->X16_ChromaAdjustment);
        AdjustPels(pFrame,
                   uVPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
    }

    // Determine parameters need for color conversion.
    if(lpicDecEx->lpbiDst->biCompression == FOURCC_YUY2)  /* output pitch, offset */
    {
		intPitch = (lpicDecEx->lpbiDst->biBitCount >> 3) * abs ((int)(lpicDecEx->lpbiDst->biWidth));
		lOutput = 0;                                       /* for YUY2 format */
		uNewOffsetToLine0 = DC->CCOffsetToLine0;
		bShapingFlag=FALSE;
    }
    else if ((lpicDecEx->lpbiDst->biCompression == FOURCC_YUV12) || (lpicDecEx->lpbiDst->biCompression == FOURCC_IYUV))  /* output pitch, offset */
    {
		intPitch = 0xdeadbeef;  // should not be used
		lOutput = 0;                                       /* for YUV format */
		uNewOffsetToLine0 = DC->CCOffsetToLine0;
		bShapingFlag=FALSE;
    }
    else  // not YUY2
    {
        // this call also sets intPitch
        lOutput = DibXY(lpicDecEx, &intPitch, lpInst->YScale);

        if (DC->uIs320x240)
            uNewOffsetToLine0 = DC->CCOffset320x240;
        else
            uNewOffsetToLine0 = DC->CCOffsetToLine0;

        if (!bIsDCI)
        {
             uNewOffsetToLine0 += 
                ( (U32)DC->uFrameHeight - (U32)uNewFrameHeight ) * (U32)intPitch;

            if(lpInst->YScale == 2)
                 uNewOffsetToLine0 += 
                    ( (U32)DC->uFrameHeight - (U32)uNewFrameHeight ) * (U32)intPitch;

        }  // end if (!bIsDCI)

    } // end if (YUY2) ... else ...

    // Call the H26x color convertors 
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef USE_MMX // { USE_MMX
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[DC->bMMXDecoder ? MMX_CC : PENTIUM_CC](
#else // }{ USE_MMX
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[PENTIUM_CC](
#endif // } USE_MMX
        (LPSTR) pFrame+uYPlane,                  // Y plane
        (LPSTR) pFrame+uVPlane,                  // V plane
        (LPSTR) pFrame+uUPlane,                  // U plane
#ifdef H263P
		// The actual frame dimensions are needed for the color conversion
		(UN) DC->uActualFrameWidth,
		(UN) DC->uActualFrameHeight,
#else
        (UN) DC->uFrameWidth,
        (UN) DC->uFrameHeight,
#endif
        (UN) uYPitch,
        (UN) uUVPitch,
        (UN) (bShapingFlag ? 12 : 9999),         // Aspect Adjustment Counter
        (LPSTR) lpicDecEx->lpDst,                // Color Converted Frame
        (U32) lOutput,                           // DCI offset
        (U32) uNewOffsetToLine0,                 // Color converter offset to line 0
        (int) intPitch,                          // Color converter pitch
        DC->ColorConvertor);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uOutputCC);
#endif // } DETAILED_DECODE_TIMINGS_ON

    // check for 320x240 still
    if (DC->uIs320x240) {
        // restore frame size for next frame
        DC->uFrameWidth = uSaveWidth;
        DC->uFrameHeight = uSaveHeight;
    }

    iReturn = ICERR_OK;

done:
#ifdef USE_MMX // { USE_MMX
	if(NULL != DC)
	{
		if (DC->bMMXDecoder)
		{
			__asm {
				_emit 0x0f 
				_emit 0x77  //  emms
			}
		}
	}
#endif // } USE_MMX

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (bRealDecompress)
	{
		TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uDecodeTime);
		if (bTimingThisFrame)
		{
			// Update the decompression timings counter
			#pragma message ("Current decode timing computations assume P5/90Mhz")
			UPDATE_COUNTER(g_pctrDecompressionTimePerFrame, (uDecodeTime + 45000UL) / 90000UL);
			UPDATE_COUNTER(g_pctrBEFTimePerFrame, (uBEFTime + 45000UL) / 90000UL);

			DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Decompression time: %ld\r\n", _fx_, (uDecodeTime + 45000UL) / 90000UL));
			DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Block Edge Filtering time: %ld\r\n", _fx_, (uBEFTime + 45000UL) / 90000UL));
		}
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bRealDecompress)
	{
		if (bTimingThisFrame)
		{
			pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount;
			pDecTimingInfo->uDecodeFrame = uDecodeTime;
			pDecTimingInfo->uBEF = uBEFTime;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			pDecTimingInfo->uHeaders = uHeaders;
			pDecTimingInfo->uMemcpy = uMemcpy;
			pDecTimingInfo->uFrameCopy = uFrameCopy;
			pDecTimingInfo->uIDCTandMC = uIDCTandMC;
			pDecTimingInfo->uOutputCC = uOutputCC;
			pDecTimingInfo->uDecIDCTCoeffs = uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
			DC->uStatFrameCount++;
		}
	}
#endif // } LOG_DECODE_TIMINGS_ON

    return iReturn;
}


/************************************************************************
 *  H263TermDecoderInstance
 *    This function frees the space allocated for an instance of the H263 
 *    decoder.
 ************************************************************************/
LRESULT H263TermDecoderInstance(
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    LPDECINST lpInst,
	BOOL bRealDecompress)
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    LPDECINST lpInst)
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
{ 
    LRESULT iReturn=ICERR_OK;
    T_H263DecoderCatalog * DC;

	FX_ENTRY("H263TermDecoderInstance");
    
    if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
    }
    if(lpInst->Initialized == FALSE)
    {
		ERRORMESSAGE(("%s: Uninitialized instance!\r\n", _fx_));
        return(ICERR_OK);
    }
    
    lpInst->Initialized = FALSE;
    
    DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
    
    if (DC->_p16InstPostProcess != NULL)
    {
		HeapFree(GetProcessHeap(), 0, DC->_p16InstPostProcess);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)DC->_p16InstPostProcess);
#endif
		// PhilF: Also freed in H263TerminateDecoderInstance! For now set to NULL to avoid second HeapFree.
		// Investigate reason for 2nd call later...
		DC->_p16InstPostProcess = NULL;
    }  
    
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bRealDecompress && DC->X32_DecTimingInfo)
	{
		DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)DC) + DC->X32_DecTimingInfo );
		OutputDecodeTimingStatistics("c:\\decode.txt", DC->pDecTimingInfo, DC->uStatFrameCount);
	}
#endif // } LOG_DECODE_TIMINGS_ON

    HeapFree(GetProcessHeap(), 0, lpInst->pDecoderInst);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst->pDecoderInst);
#endif

    return iReturn;
}

/***********************************************************************
 *  Description:
 *    This routine parses the bit-stream and initializes two major streams:
 *      1) pN: no of coefficients in each of the block (biased by 65 for INTRA)
 *      2) pRun_INVERSE_Q: de-quantized coefficient stream for the frame;
 *           MMX stream is scaled because we use scaled IDCT.
 *    Other information (e.g. MVs) is kept in decoder catalog, block action 
 *    stream, and MB infor stream.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    fpbsState:     bit-stream state pointer
 *    fpu8MaxPtr:    sentinel value to check for bit-stream overruns
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *    iGOB_start:    
 *    iMB_start:     
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE1")
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start)
{
    I32 g, m, gg, mm, iReturn, iBlockNumber = 0 ;
#if 1  
    I32 mb_start = iMB_start;
    I32 old_g, old_m, b_skip;
    U32 *pNnew;
	I8  p8MVs[4]={0,0,0,0};

	FX_ENTRY("IAPass1ProcessFrame");

    //  In case of H.263, iGOB_start will be 1; H.263RTP may have value
    //  larger than 1

    for (g = 1; g < iGOB_start; g++, fpBlockAction += iNumberOfMBs*6)
        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        

    for (g = iGOB_start; g <= iNumberOfGOBs; g++) 
    {
        iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        if (iReturn != ICERR_OK) 
        {
			ERRORMESSAGE(("%s: Error reading GOB header!\r\n", _fx_));
            goto error;
        }

        if (g != 1) g = DC->uGroupNumber + 1;
         
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
		fpBlockAction += (g - 1)* iNumberOfMBs*6;

        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        
        //  re-sync uBlockNum fpBlockAction, fpMBInfo at this point
        iBlockNumber  = (g - 1)* iNumberOfMBs*6+(mb_start-1)*6;
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        if (DC->bPBFrame)
		 pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber*2;
        else
		 pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;

        while (pN < pNnew ) *pN++ = 0;
        
        // For each MB do ...
        for (m = mb_start; m <= iNumberOfMBs; m++, iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            if (mb_start != 1) mb_start = 1;     //use it only once     ?
            
            iReturn = H263DecodeMBHeader(DC, fpbsState, &pN, fpMBInfo);   // NEW - added pN

            if (iReturn == PACKET_FAULT)
            {
				ERRORMESSAGE(("%s: H263DecodeMBHeader() failed!\r\n", _fx_));

                old_g = g;
                old_m = m;
                //Find the next good packet and find GOB and MB lost
                iReturn = RtpH263FindNextPacket(DC, fpbsState, &pN, 
					                            &DC->uPQuant,(int *)&m, (int *)&g,
												p8MVs);
                if (iReturn == NEXT_MODE_A) 
                {
					ERRORMESSAGE(("%s: Next packet in MODE A\r\n", _fx_));
					MVAdjustment(fpBlockAction, iBlockNumber, old_g-1, old_m-1, g, m,iNumberOfMBs); //Chad,7/22/96
                    break;
                }
                else if ((iReturn == NEXT_MODE_B) ||(iReturn == NEXT_MODE_C) ) 
                {//lost multiple of MBs, could belong to more than one GOB
  					if (iReturn == NEXT_MODE_B) 
					{
					ERRORMESSAGE(("%s: Next packet in MODE B\r\n", _fx_));
					  b_skip = ((g - old_g+1)* iNumberOfMBs + m - old_m + 1)*6;
                      for (int k = 0; k < b_skip; k++)  *pN++ = 0;
					}
					else
					{
					ERRORMESSAGE(("%s: Next packet in MODE C\r\n", _fx_));
					  b_skip = ((g - old_g+1)* iNumberOfMBs + m - old_m + 1)*6*2;
                      for (int k = 0; k < b_skip; k++)  *pN++ = 0;
					  b_skip = b_skip /2;
                    }
					
                    for (int k=0;k< b_skip /6;k++)
					{
						fpMBInfo->i8MVDBx2=0;
						fpMBInfo->i8MVDBy2=0;
						fpMBInfo->i8MBType =0;
						fpMBInfo++;
                    }
					fpMBInfo--;
                    b_skip -= 6;     //this is a tricky one since the parameter 
                                     //below will be adjust again later
                                     //Chad, 8/28/96
                    fpBlockAction += b_skip;
                    iBlockNumber  += b_skip;
					g++;    //because g start with 1 instead of 0 as specified by H.263
					for (k=0;k<6;k++)
					{
						fpBlockAction[k].i8MVx2 = p8MVs[0];
						fpBlockAction[k].i8MVy2 = p8MVs[1];
					}

                }
                else //Added by Chad.
                if (iReturn == NEXT_MODE_LAST)
                { 
                    int ii, jj, kk;   //last packet found
                                    //set all the rest of MB and GOB to NOT CODED.
					ERRORMESSAGE(("%s: Last packet lost\r\n", _fx_));
                    for ( ii = m;ii <= iNumberOfMBs; ii++) 
                        for (kk = 0; kk < 6; kk++) 
                            *pN++ = 0;
                    for ( jj = g; jj <= iNumberOfGOBs; jj++)
                        for (ii = 0; ii <= iNumberOfMBs; ii++)
                            for (kk = 0; kk<6; kk++) 
                                *pN++ = 0;
                    m = iNumberOfMBs;
                    g = iNumberOfMBs;
                }
			    DC->bCoded = FALSE;
			}
            else if (iReturn != ICERR_OK) 
            {
				ERRORMESSAGE(("%s: Error reading MB header!\r\n", _fx_));
                goto error;
            }
            
#ifdef NEW_BEF // { NEW_BEF
            gg = (g - 1);
            mm = (m - 1);
#else // }{ NEW_BEF
			gg = (g-1)<<1;
			mm = (m-1)<<1;
#endif // } NEW_BEF
            if (DC->bCoded) 
            {
				// coded_map is used by the block edge filter to indicate
				// which blocks are coded, and which are not coded.
#ifdef NEW_BEF // { NEW_BEF
                coded_map[gg+1][mm+1]   = 1;
				QP_map[gg][mm] = (char)DC->uGQuant;
#else // }{ NEW_BEF
				coded_map[gg]  [mm]   = 1;
				coded_map[gg+1][mm]   = 1;
				coded_map[gg]  [mm+1] = 1;
				coded_map[gg+1][mm+1] = 1;
#endif // } NEW_BEF

                // decode and inverse quantize the transform coefficients
                iReturn = H263DecodeIDCTCoeffs(DC, 
                                               fpBlockAction, 
                                               iBlockNumber, 
                                               fpbsState, 
                                               fpu8MaxPtr,
                                               &pN,
                                               &pRUN_INVERSE_Q);
                
                if (iReturn != ICERR_OK) {
					ERRORMESSAGE(("%s: Error parsing MB data!\r\n", _fx_));
                    goto error;
                }
            }  //  end if DC->bCoded
			else
			{
#ifdef NEW_BEF // { NEW_BEF
                coded_map[gg+1][mm+1]   = 0;
#else // }{ NEW_BEF
				coded_map[gg]  [mm]   = 0;
				coded_map[gg+1][mm]   = 0;
				coded_map[gg]  [mm+1] = 0;
				coded_map[gg+1][mm+1] = 0;
#endif // } NEW_BEF
			}

        } // end for each MB
        
        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        if (fpbsState->fpu8 > fpu8MaxPtr+4)
            goto error;
        //  The test matrix includes the debug version of the driver.  The 
        //  following assertion creates a problem when testing with VideoPhone
        //  and so please do not check-in a version with the assertion 
        //  uncommented.
        // ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);
        
    } // End for each GOB
    DC->iVerifiedBsExt=FALSE;

#else
//old code  
    for (g = 1; g <= iNumberOfGOBs; g++) 
    {
        iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        if (iReturn != ICERR_OK) {
			ERRORMESSAGE(("%s: Error reading GOB header!\r\n", _fx_));
            goto error;
        }
        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        
        
        /* For each MB do ...
         */
        for (m = 1; m <= iNumberOfMBs; 
             m++, iBlockNumber+=6, fpBlockAction += 6, fpMBInfo++) 
        {
            iReturn = H263DecodeMBHeader(DC, fpbsState, &pN, fpMBInfo);
            
            if (iReturn != ICERR_OK) {
				ERRORMESSAGE(("%s: Error reading MB header!\r\n", _fx_));
                goto error;
            }
            
            if (DC->bCoded) {
                // decode and inverse quantize the transform coefficients
                iReturn = H263DecodeIDCTCoeffs(DC, 
                                               fpBlockAction, 
                                               iBlockNumber, 
                                               fpbsState, 
                                               fpu8MaxPtr,
                                               &pN,
                                               &pRUN_INVERSE_Q);
                if (iReturn != ICERR_OK) 
                {
					ERRORMESSAGE(("%s: Error parsing MB data!\r\n", _fx_));
                    goto error;
                }
            }  //  end if DC->bCoded
        } // end for each MB
        
        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);
        
    } // End for each GOB
#endif

    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#pragma code_seg()


/***********************************************************************
 *  Description:
 *    This routines does IDCT and motion compensation.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE2")
static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
)
{
    I32 g, m, b, uBlockNumber = 0, iEdgeFlag=0;
    U32 pRef[6];

    // for each GOB do
    for (g = 1 ; g <= iNumberOfGOBs; g++) 
    {
        // for each MB do
        for (m = 1; m <= iNumberOfMBs; m++, fpBlockAction+=6, fpMBInfo++) 
        {
            //  Motion Vectors need to be clipped if they point outside the 
            //  16 pels wide edge
            if (DC->bUnrestrictedMotionVectors)   
            {
                iEdgeFlag = 0;
                if (m == 1)
                    iEdgeFlag |= LEFT_EDGE;
                if (m == DC->iNumberOfMBsPerGOB)
                    iEdgeFlag |= RIGHT_EDGE;
                if (g == 1)
                    iEdgeFlag |= TOP_EDGE;
                if (g == iNumberOfGOBsBySourceFormat[DC->uSrcFormat])
                    iEdgeFlag |= BOTTOM_EDGE;
            }
            // for each block do
            for (b = 0; b < 6; b++) 
            {     // AP-NEW
                // do inverse transform & motion compensation for the block
                H263IDCTandMC(DC, fpBlockAction, b, m, g, pN, pRUN_INVERSE_Q, 
                              fpMBInfo, iEdgeFlag); // AP-NEW
                // Adjust pointers for next block     
                if ( *pN >= 65 )
                    pRUN_INVERSE_Q += *pN - 65;
                else
                    pRUN_INVERSE_Q += *pN;
                pN++;
            }  // end for each block
            
            // if this is a PB Frame
            if (DC->bPBFrame) 
            {
                // Compute the B Frame motion vectors
                H263BBlockPrediction(DC, fpBlockAction, pRef, fpMBInfo, 
                                     iEdgeFlag);  // AP-NEW
                // For each B block
                for (b = 0; b < 6; b++) 
                {
                    //  perform inverse transform & bi-directional motion 
                    //  compensation
                    H263BFrameIDCTandBiMC(DC, fpBlockAction, b, pN, 
                                          pRUN_INVERSE_Q, pRef);
                    // Adjust pointers for next block     
                    pRUN_INVERSE_Q += *pN;
                    pN++;
                }  // end for each B block
            }  // end if PB Frame
        }  // end for each MB
    }  // End for each GOB
}
#pragma code_seg()


/****************************************************************************
 *  DibXY
 *    This function is used to map color converted output to the screen.
 *    note: this function came from the H261 code base.
 ****************************************************************************/
static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale)
{
    int                 iPitch;             /* width of DIB                */
    long                lOffset = 0;
    LPBITMAPINFOHEADER  lpbi = lpicDecEx->lpbiDst;

    iPitch = ( ( (abs((int)lpbi->biWidth) * (int)lpbi->biBitCount) >> 3) + 3) & ~3;

    if(lpicDecEx->xDst > 0)                 /* go to proper X position     */
        lOffset += ((long)lpicDecEx->xDst * (long)lpbi->biBitCount) >> 3;

    if(lpbi->biHeight * lpicDecEx->dxSrc < 0) { /* DIB is bottom to top    */
        lOffset +=  (long) abs((int)lpbi->biWidth) * 
                    (long) abs((int)lpbi->biHeight) *
                    ((long) lpbi->biBitCount >> 3) - 
                    (long) iPitch;

    /************************************************************************
     *  This next line is used to subtract the amount that Brian added
     *  to CCOffsetToLine0 in COLOR.C during initialization.  This is 
     *  needed because, for DCI, the pitch he used is incorrect. 
     ***********************************************************************/

        lOffset -=    ((long) yScale * (long) lpicDecEx->dySrc - 1) *     
                    (long) lpicDecEx->dxDst * ((long) lpbi->biBitCount >> 3);  

        iPitch *= -1;
    }

    if(lpicDecEx->yDst > 0)                 /* go to proper Y position     */
        lOffset += ((long)lpicDecEx->yDst * (long)iPitch);

    if(lpicDecEx->dxSrc > 0) {
        lOffset += ((long)lpicDecEx->dyDst * (long)iPitch) - (long)iPitch;
        iPitch *= -1;
    }

    if( (lpicDecEx->dxDst == 0) && (lpicDecEx->dyDst == 0) )
        *lpiPitch = -iPitch;
    else
        *lpiPitch = iPitch;
  
    return(lOffset);
}


/************************************************************************
 *  GetDecoderOptions:
 *    Get the options, saving them in the catalog
 ***********************************************************************/
static void GetDecoderOptions(
    T_H263DecoderCatalog * DC)
{
    /* Default Options
     */
#ifdef NO_BEF // { NO_BEF
    DC->bUseBlockEdgeFilter = 0;
#else // }{ NO_BEF
    DC->bUseBlockEdgeFilter = 1;
#endif // } NO_BEF
    DC->bForceOnAspectRatioCorrection = 0;
#ifdef USE_MMX // { USE_MMX
    DC->bMMXDecoder = MMxVersion;
#endif // } USE_MMX

	FX_ENTRY("GetDecoderOptions");

    /* Can only use force aspect ratio correction on if SQCIF, QCIF, or CIF
     */
    if (DC->bForceOnAspectRatioCorrection)
    {
        if (! ( ((DC->uFrameWidth == 128) && (DC->uFrameHeight ==  96)) ||
                ((DC->uFrameWidth == 176) && (DC->uFrameHeight == 144)) ||
                ((DC->uFrameWidth == 352) && (DC->uFrameHeight == 288)) ) )
        {
			ERRORMESSAGE(("%s: Aspect ratio correction can not be forced on unless the dimensions are SQCIF, QCIF, or CIF!\r\n", _fx_));
            DC->bForceOnAspectRatioCorrection = 0;
        }
    }

    /* Display the options
     */
    if (DC->bUseBlockEdgeFilter)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (BlockEdgeFilter) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (BlockEdgeFilter) is OFF\r\n", _fx_));
    }
    if (DC->bForceOnAspectRatioCorrection)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (ForceOnAspectRatioCorrection) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (ForceOnAspectRatioCorrection) is OFF\r\n", _fx_));
    }
#ifdef USE_MMX // { USE_MMX
    if (DC->bMMXDecoder)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is OFF\r\n", _fx_));
    }
#else // }{ USE_MMX
	DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is OFF\r\n", _fx_));
#endif // } USE_MMX
} /* end GetDecoderOptions() */


#if !defined(H263P)
#ifdef NEW_BEF // { NEW_BEF
/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/
static void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      )
{

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 0);
    VertEdgeFilter (lum, width, height, pitch, 0);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 1);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 1);

    return;
}

/***********************************************************************/
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr)
{
  int i,j,k;    
  int delta;
  int mbc, mbr, do_filter;
  unsigned char *r_2, *r_1, *r, *r1;
  signed char *deltatab;

  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  for (j = 8; j < height; j += 8) {
    for (i = 0; i < width; i += 8) {

      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }

      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr][mbc+1];

      if (do_filter) {
        for (k = i; k < i+8; k++) {
          delta = (int)deltatab[ (( (int)(*(r_2 + k) * 3) -
                                    (int)(*(r_1 + k) * 8) +
                                    (int)(*(r   + k) * 8) -
                                    (int)(*(r1  + k) * 3)) >>4)];
                        
          *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
          *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

        }
      }
    }
    r   += (pitch<<3);
    r1  += (pitch<<3);
    r_1 += (pitch<<3);
    r_2 += (pitch<<3);
  }
  return;
}

/***********************************************************************/
static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter;
  signed char *deltatab;
  unsigned char *r;

  /* vertical edges */
  for (i = 8; i < width; i += 8) 
  {
    r = rec;
    for (j = 0; j < height; j +=8) 
    {
      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }
        
      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr+1][mbc];

      if (do_filter) {
        for (k = 0; k < 8; k++) {
          delta = (int)deltatab[(( (int)(*(r + i-2 ) * 3) - 
                                   (int)(*(r + i-1 ) * 8) + 
                                   (int)(*(r + i   ) * 8) - 
                                   (int)(*(r + i+1 ) * 3)  ) >>4)];

          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}

#define sign(a)        ((a) < 0 ? -1 : 1)

static void InitEdgeFilterTab()   
{
  int i,QP;
  
  for (QP = 1; QP <= 31; QP++) {
    for (i = -176; i <= 175; i++) {
      dtab[i+176 +(QP-1)*351] = sign(i) * (max(0,abs(i)-max(0,2*abs(i) - QP)));
    }
  }
}

#else // }{ NEW_BEF

/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs in the loop edge-filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *
 ***********************************************************************/
void EdgeFilter(unsigned char *lum, unsigned char *Cb, unsigned char *Cr, int QP, int pels, int lines, int pitch)
{

  int dtab[512];
  int *deltatab;
  int i;

  deltatab = &dtab[0] + 256;

  for (i=-256; i < 0; i++)
    deltatab[i] = min(0,i-min(0,((i + (QP>>1))<<1)));   
  for (i=0; i < 256; i++)
    deltatab[i] = max(0,i-max(0,((i - (QP>>1))<<1)));

  /* Luma */
  HorizEdgeFilter(lum, pels, lines, pitch, QP, 0, deltatab);
  VertEdgeFilter (lum, pels, lines, pitch, QP, 0, deltatab);

  /* Chroma */
  HorizEdgeFilter(Cb,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  VertEdgeFilter (Cb,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  HorizEdgeFilter(Cr,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  VertEdgeFilter (Cr,  pels>>1, lines>>1, pitch, QP, 1, deltatab);

  /* that's it */
  return;
}

/***********************************************************************/
void HorizEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                     int chr, int *deltatab)
{
  int i,j,k;
  int delta;
  int mbc, mbr, do_filter;
  int coded1, coded2;
  unsigned char *r_2, *r_1, *r, *r1;


  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  if (!chr) {
    for (j = 8; j < height; j += 8) {
      for (i = 0; i < width; i += 8) {

        mbr = (j >> 3); 
        mbc = (i >> 3);

          do_filter = coded_map[mbr][mbc] | coded_map[mbr-1][mbc];

        if (do_filter) {
          for (k = i; k < i+8; k++) {
              delta = deltatab[ (( (int)(*(r_2 + k)) +
                                   (int)(*(r_1 + k) * (-3)) +
                                   (int)(*(r   + k) * ( 3)) -
                                   (int)(*(r1  + k) )) >>3)];

              *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
              *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

          }
        }
      }
      r   += (pitch<<3);
      r1  += (pitch<<3);
      r_1 += (pitch<<3);
      r_2 += (pitch<<3);
    }
  }
  else { /* chr */
    for (j = 8; j < height; j += 8) {
      for (i = 0; i < width; i += 8) {

        mbr = (j >> 3); 
        mbc = (i >> 3);

          coded1 = 
            coded_map[2*mbr][2*mbc] |
            coded_map[2*mbr][2*mbc+1] |
            coded_map[2*mbr+1][2*mbc] |
            coded_map[2*mbr+1][2*mbc+1];
          coded2 = 
            coded_map[2*(mbr-1)][2*mbc] |
            coded_map[2*(mbr-1)][2*mbc+1] |
            coded_map[2*(mbr-1)+1][2*mbc] |
            coded_map[2*(mbr-1)+1][2*mbc+1];
          do_filter = coded1 | coded2;

        if (do_filter) {
          for (k = i; k < i+8; k++) {
              delta = deltatab[ (( (int)(*(r_2 + k)) +
                                   (int)(*(r_1 + k) * (-3)) +
                                   (int)(*(r   + k) * ( 3)) -
                                   (int)(*(r1  + k) )) >>3)];

              *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
              *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

          }
        }
      }
      r   += (pitch<<3);
      r1  += (pitch<<3);
      r_1 += (pitch<<3);
      r_2 += (pitch<<3);
    }
  }
  return;
}

/***********************************************************************/
void VertEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                    int chr, int *deltatab)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter, coded1, coded2;
  unsigned char *r;
  extern const U8 ClampTbl[CLAMP_BIAS+256+CLAMP_BIAS];

  /* vertical edges */
  for (i = 8; i < width; i += 8) {
    r = rec;
    for (j = 0; j < height; j +=8) {
      mbr = (j >> 3); 
      mbc = (i >> 3);

      if (!chr) {
        do_filter = coded_map[mbr][mbc] | coded_map[mbr][mbc-1];
      }
      else {
        coded1 = 
          coded_map[2*mbr][2*mbc] |
          coded_map[2*mbr][2*mbc+1] |
          coded_map[2*mbr+1][2*mbc] |
          coded_map[2*mbr+1][2*mbc+1];
        coded2 = 
          coded_map[2*mbr][2*(mbc-1)] |
          coded_map[2*mbr][2*(mbc-1)+1] |
          coded_map[2*mbr+1][2*(mbc-1)] |
          coded_map[2*mbr+1][2*(mbc-1)+1];
        do_filter = coded1 | coded2;
      }
      if (do_filter) {
        for (k = 0; k < 8; k++) {

          delta = deltatab[(( (int)(*(r + i-2 )       ) + 
                              (int)(*(r + i-1 ) * (-3)) + 
                              (int)(*(r + i   ) * ( 3)) - 
                              (int)(*(r + i+1 ) )  ) >>3)];


          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}
#endif // } NEW_BEF
#endif

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
void OutputDecodeTimingStatistics( char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, U32 uStatFrameCount)
{
	FILE * pFile;
	DEC_TIMING_INFO * pTempDecTimingInfo;
	DEC_TIMING_INFO dtiTemp;
	int i;
	int iCount;

	FX_ENTRY("OutputDecodeTimingStatistics")

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
		ERRORMESSAGE("%s: Error opening decode stat file\r\n", _fx_));
		goto done;
	}

	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	// for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < uStatFrameCount ; i++, pTempDecTimingInfo++ )
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < DEC_TIMING_INFO_FRAME_COUNT ; i++, pTempDecTimingInfo++ )
	{
		if (pTempDecTimingInfo->uDecodeFrame != 0)
		{
			fprintf(pFile, "Frame %d Detail Timing Information\n", i);
			OutputDecTimingDetail(pFile, pTempDecTimingInfo);
		}
	}

	/* Compute the total information
	 */
	memset(&dtiTemp, 0, sizeof(DEC_TIMING_INFO));
	iCount = 0;

	// for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < uStatFrameCount ; i++, pTempDecTimingInfo++ )
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < DEC_TIMING_INFO_FRAME_COUNT ; i++, pTempDecTimingInfo++ )
	{
		if (pTempDecTimingInfo->uDecodeFrame != 0)
		{
			iCount++;

			dtiTemp.uDecodeFrame  += pTempDecTimingInfo->uDecodeFrame;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			dtiTemp.uHeaders	  += pTempDecTimingInfo->uHeaders;
			dtiTemp.uMemcpy       += pTempDecTimingInfo->uMemcpy;
			dtiTemp.uFrameCopy    += pTempDecTimingInfo->uFrameCopy;
			dtiTemp.uOutputCC     += pTempDecTimingInfo->uOutputCC;
			dtiTemp.uIDCTandMC    += pTempDecTimingInfo->uIDCTandMC;
			dtiTemp.uDecIDCTCoeffs+= pTempDecTimingInfo->uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
			dtiTemp.uBEF          += pTempDecTimingInfo->uBEF;
		}
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);

		/* Compute the average
		*/
		dtiTemp.uDecodeFrame  = (dtiTemp.uDecodeFrame + (iCount / 2)) / iCount;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.uHeaders	  = (dtiTemp.uHeaders + (iCount / 2)) / iCount;
		dtiTemp.uMemcpy       = (dtiTemp.uMemcpy + (iCount / 2)) / iCount;
		dtiTemp.uFrameCopy    = (dtiTemp.uFrameCopy + (iCount / 2)) / iCount;
		dtiTemp.uOutputCC     = (dtiTemp.uOutputCC + (iCount / 2)) / iCount;
		dtiTemp.uIDCTandMC    = (dtiTemp.uIDCTandMC+ (iCount / 2)) / iCount;
		dtiTemp.uDecIDCTCoeffs= (dtiTemp.uDecIDCTCoeffs+ (iCount / 2)) / iCount;
#endif // } DETAILED_DECODE_TIMINGS_ON
		dtiTemp.uBEF          = (dtiTemp.uBEF + (iCount / 2)) / iCount;

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tDecode Frame =      %10d (%d milliseconds at 90Mhz)\n", pDecTimingInfo->uDecodeFrame,
			(pDecTimingInfo->uDecodeFrame + 45000) / 90000);
	uOther = pDecTimingInfo->uDecodeFrame;
	
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pDecTimingInfo->uDecodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	fprintf(pFile, "\tmemcpy =            %10d (%2d%%)\n", pDecTimingInfo->uMemcpy, 
			(pDecTimingInfo->uMemcpy + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uMemcpy;
								   
	fprintf(pFile, "\tHeaders =           %10d (%2d%%)\n", pDecTimingInfo->uHeaders, 
			(pDecTimingInfo->uHeaders + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uHeaders;
								   
	fprintf(pFile, "\tFrameCopy =         %10d (%2d%%)\n", pDecTimingInfo->uFrameCopy, 
			(pDecTimingInfo->uFrameCopy + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uFrameCopy;

	fprintf(pFile, "\tDecode DCT Coeffs = %10d (%2d%%)\n", pDecTimingInfo->uDecIDCTCoeffs, 
			(pDecTimingInfo->uDecIDCTCoeffs + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uDecIDCTCoeffs;

	fprintf(pFile, "\tIDCT and MC       = %10d (%2d%%)\n", pDecTimingInfo->uIDCTandMC, 
			(pDecTimingInfo->uIDCTandMC + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uIDCTandMC;
#endif // } DETAILED_DECODE_TIMINGS_ON

	fprintf(pFile, "\tBlock Edge Filter = %10d (%2d%%)\n", pDecTimingInfo->uBEF, 
			(pDecTimingInfo->uBEF + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uBEF;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	fprintf(pFile, "\tOutput CC =         %10d (%2d%%)\n", pDecTimingInfo->uOutputCC, 
			(pDecTimingInfo->uOutputCC + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uOutputCC;
#endif // } DETAILED_DECODE_TIMINGS_ON

	fprintf(pFile, "\tOther =             %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);

}
#endif // } LOG_DECODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3gob.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3gob.cpp
 *
 *  Description:
 *		This modules contains the GOB header support routines
 *
 *	Routines:
 *		H263SetGOBHeaderInfo
 *		
 *  Data:
 */

/*
 * $Header:   S:\h26x\src\dec\d3gob.cpv   1.13   20 Oct 1996 15:51:00   AGUPTA2  $
 * $Log:   S:\h26x\src\dec\d3gob.cpv  $
// 
//    Rev 1.13   20 Oct 1996 15:51:00   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.12   20 Oct 1996 13:21:00   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.11   03 May 1996 13:07:26   CZHU
// 
// Remove assertion of GOB number because of packet loss
// 
//    Rev 1.10   28 Apr 1996 17:34:12   BECHOLS
// Fixed warning due to iLength declaration.  This variable was only used
// by a piece of code that was wrapped with IFDEF DEBUG_GOB, so I wrapped
// it with the same define.
// 
//    Rev 1.9   08 Mar 1996 16:46:14   AGUPTA2
// Changed defines to const int declarations.  Added pragmas code_seg and
// data_seg.  ifdef'd wsprintf call.
// 
// 
//    Rev 1.8   27 Dec 1995 14:36:04   RMCKENZX
// Added copyright notice
 */

#include "precomp.h"

/* BIT field Constants
 */

#define BITS_GOB_STARTCODE         17
#define BITS_GROUP_NUMBER          5
#define BITS_GFID                  2
#define BITS_GQUANT                5
#define MAX_GBSC_LOOKAHEAD_NUMBER  7

/* GBSC_VALUE - 0000 0000 0000 0000 - 1xxx xxxx xxxx xxxx 
 */
#define GBSC_VALUE  (0x00008000 >> (32-BITS_GOB_STARTCODE))

/*****************************************************************************
 *
 * 	H263DecodeGOBHeader
 *
 *  Set the GOB header information in the decoder catalog.  GOB numbers 2 thru
 *  N may have a GOB header.  Look for one if it is there read it storing the
 *  information in the catalog.  If a GOB header is not there set the information
 *  to default values.
 *
 *  Returns an ICERR_STATUS
 */
#pragma data_seg("IADATA1")

#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBHeader(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState,
	U32 uAssumedGroupNumber)
{
	U8 FAR * fpu8;
	U32 uBitsReady = 0;
	U32 uWork = 0;
	I32 iReturn;
	U32 uResult;
	int iLookAhead;
	U32 uData;

	FX_ENTRY("H263DecodeGOBHeader")

	// Decrement group number since the standard counts from 0
	// but this decoder counts from 1.
	--uAssumedGroupNumber;
    DC->bGOBHeaderPresent=0;

	if (uAssumedGroupNumber == 0) {
		//  Initialize the flag
		DC->bFoundGOBFrameID = 0;
	} 
    else 
    {
		//  Look for the GOB header Start Code
		GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
		GET_FIXED_BITS((U32) BITS_GOB_STARTCODE, fpu8, uWork, uBitsReady, 
					   uResult);
		iLookAhead = 0;
		while (uResult != GBSC_VALUE) 
        {
			uResult = uResult << 1;
			uResult &= GetBitsMask[BITS_GOB_STARTCODE];
			GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
			uResult |= uData;
			iLookAhead++;
			if (iLookAhead >= MAX_GBSC_LOOKAHEAD_NUMBER) {
				break;	// only look ahead so far
			}
		}
		if (uResult == GBSC_VALUE)
		{
		    DC->bGOBHeaderPresent=1;
		}
	}
	
	if (DC->bGOBHeaderPresent) 
    {
		//  GN
		GET_FIXED_BITS((U32) BITS_GROUP_NUMBER, fpu8, uWork, uBitsReady,
				       uResult);
//		ASSERT(uResult == uAssumedGroupNumber);
		DC->uGroupNumber = uResult;
		/* I am assuming that GOB numbers start at 1 because if it starts at 
         * zero it makes the GOB start code look like a picture start code.
		 * Correction by TRG: GOB numbers start at 0, but there can't be a
		 * GOB header for the 0th GOB.
		 */
		// ASSERT(DC->uGroupNumber > 0);
		if (DC->uGroupNumber == 0) 
        {
			ERRORMESSAGE(("%s: There can't be a GOB header for the 0th GOB\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		//  GLCI
		if (DC->bCPM) 
        {
			ERRORMESSAGE(("%s: CPM is not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		//  GFID
		GET_FIXED_BITS((U32) BITS_GFID, fpu8, uWork, uBitsReady, uResult);
		if (DC->bFoundGOBFrameID) 
        {
			if (uResult != DC->uGOBFrameID) 
            {
				ERRORMESSAGE(("%s: GOBFrameID mismatch\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			/* Should we also check it against the GOBFrameID of the previous
			 * picture when the PTYPE has not changed?
			 */
		}
		DC->uGOBFrameID = uResult;
		DC->bFoundGOBFrameID = 1;

		//  GQUANT
		GET_FIXED_BITS((U32) BITS_GQUANT, fpu8, uWork, uBitsReady, uResult);
		DC->uGQuant = uResult;
		DC->uPQuant = uResult;
		//  Save the modified bitstream state
		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	} 
	else 
	{
		//  We can only assume
		DC->uGroupNumber = uAssumedGroupNumber;
		/* If we already found the GOBFrameID leave it alone.  Otherwise
		 * clear it using a value indicating that it is not valid.
		 */ 
		if (! DC->bFoundGOBFrameID)
			DC->uGOBFrameID = 12345678;
		//  Default the group Quantization to the picture Quant
		DC->uGQuant = DC->uPQuant;
	}	

	DEBUGMSG(ZONE_DECODE_GOB_HEADER, (" %s: HeaderPresent=%ld GN=%ld GFID=%ld GQ=%ld\r\n", _fx_, DC->bGOBHeaderPresent, DC->uGroupNumber, DC->uGOBFrameID, DC->uGQuant));

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeGOBHeader() */
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3halfmc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:57:40  $
// $Archive:   S:\h26x\src\dec\d3halfmc.h_v  $
// $Header:   S:\h26x\src\dec\d3halfmc.h_v   1.4   14 Mar 1996 14:57:40   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3halfmc.h_v  $
;// 
;//    Rev 1.4   14 Mar 1996 14:57:40   AGUPTA2
;// Added decls for MMX rtns.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   08 Oct 1995 13:44:40   CZHU
// 
// Declare the C versions of interpolation for debugging
// 
//    Rev 1.1   27 Sep 1995 11:55:50   CZHU
// 
// Changed UINT backto U32
// 
//    Rev 1.0   26 Sep 1995 11:09:38   CZHU
// Initial revision.
// 

#ifndef __D3HALFMC_H__
#define __D3HALFMC_H__

extern void Interpolate_Half_Int (U32 pRef,U32 pNewRef);
extern void Interpolate_Int_Half (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Half (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Half_Int (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Int_Half (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Half_Half (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Half_C (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Int_C (U32 pRef,U32 pNewRef);
extern void Interpolate_Int_Half_C (U32 pRef,U32 pNewRef);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3halfmc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:18  $
// $Archive:   S:\h26x\src\dec\d3halfmc.cpv  $
// $Header:   S:\h26x\src\dec\d3halfmc.cpv   1.15   08 Mar 1996 16:46:18   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3halfmc.cpv  $
// 
//    Rev 1.15   08 Mar 1996 16:46:18   AGUPTA2
// Added pragma code_seg.
// 
// 
//    Rev 1.14   29 Jan 1996 17:53:56   RMCKENZX
// Completely re-wrote all 3 routines.  The loops no longer use pseudo
// SIMD logic and have been tightened to 256, 169, and 169 cycles
// for half-half, half-int, and int-half respectively.
// 
//    Rev 1.13   19 Jan 1996 17:40:36   RMCKENZX
// fixed half-int so it will correctly round
// 
//    Rev 1.12   19 Jan 1996 13:29:32   RHAZRA
// Fixed halfpixel prediction by bilinear interpolation in ASM code
// 
//    Rev 1.11   27 Dec 1995 14:36:06   RMCKENZX
// Added copyright notice
// 
//    Rev 1.10   09 Oct 1995 09:43:36   CZHU
// Fixed bug in (half,half) interpolation optimization
// 
//    Rev 1.9   08 Oct 1995 13:40:14   CZHU
// Added C version of (half,half) and use it for now until we fix the bug
// in the optimized version
// 
//    Rev 1.8   03 Oct 1995 15:06:30   CZHU
// 
// Adding debug assistance
// 
//    Rev 1.7   28 Sep 1995 15:32:22   CZHU
// Fixed bugs mast off bits after shift
// 
//    Rev 1.6   26 Sep 1995 11:13:36   CZHU
// 
// Adjust pitch back to normal, and changed UINT to U32
// 
//    Rev 1.5   25 Sep 1995 09:04:14   CZHU
// Added and cleaned some comments 
// 
//    Rev 1.4   22 Sep 1995 16:42:00   CZHU
// 
// improve pairing
// 
//    Rev 1.3   22 Sep 1995 15:59:48   CZHU
// finished first around coding of half pel interpolation and tested
// with the standalone program
// 
//    Rev 1.2   21 Sep 1995 16:56:28   CZHU
// Unit tested (half, int) case
// 
//    Rev 1.1   21 Sep 1995 12:06:22   CZHU
// More development
// 
//    Rev 1.0   20 Sep 1995 16:27:56   CZHU
// Initial revision.
// 

#include "precomp.h"

#define FRAMEPOINTER		esp

//Interpolat_Int_half interpolated the pels from the pRef block 
//Write to pNewRef.
//Assumes that pRef area has been expanded
// Todo: Loop control and setup the stack for locals,CZHU,9/20/95
//       preload output cache lines, 9/21
//       Cache preload is no longer needed, 9/21/95
// Cycles count: 50*4 =200 cycles

#pragma code_seg("IACODE2")
__declspec(naked)
void Interpolate_Half_Int (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	sub 	edi, PITCH			// pre-decrement destination
	 mov	ebp, 8				// loop counter
	xor 	eax, eax			// clear registers
	 xor 	ebx, ebx
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 4 instruction, 2 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	2 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1      2       3
//	cycle	
//	  1     load |       | shift
//	      -----------------------
//	  2          |  add  | store 
//
//	This assumes that the prior pell's value was loaded and 
//	preserved from the prior result's calculation.  Therefore
//	each result uses 2 registers -- one to load (and preserve)
//	the right-hand pell, and the other (overwriting the previous
//	result's stored pell value) to add into, shift, and store out
//	of.  The add is accomplished with the lea instruction, allowing
//	a round bit to be added in without using a separate instruction.
//	
//	The preamble loads & adds for the first result, and loads 
//	for the second.  The body executes the basic pattern six times.
//	The postamble shifts and stores for the seventh result and 
//	adds, shifts, and stores for the eighth.
//
//	Timing:
//		  4	preamble (including bank conflict)
//		 12	body
//		  4	postamble
//		----------------
//		 20	per loop
//		x 8	loops
//		----------------
//		160 subtotal
//		  6	initialize
//	 	  3	finalize
//		================
//		169 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	al, 0[esi]
	 mov	bl, 1[esi]			// probable BANK CONFLICT
	mov 	dl, 0[edi]			// heat the cache
	 add	edi, PITCH			// increment destination at top
	lea 	eax, [1+eax+ebx]	// use a regular add in the preamble
	 mov	cl, 2[esi]

// body (6 pels)
	shr 	eax, 1
	 mov	dl, 3[esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	0[edi], al

	shr 	ebx, 1
	 mov	al, 4[esi]
	lea 	ecx, [ecx+edx+1]
	 mov	1[edi], bl

	shr 	ecx, 1
	 mov	bl, 5[esi]
	lea 	edx, [edx+eax+1]
	 mov	2[edi], cl

	shr 	edx, 1
	 mov	cl, 6[esi]
	lea 	eax, [eax+ebx+1]
	 mov	3[edi], dl

	shr 	eax, 1
	 mov	dl, 7[esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	4[edi], al

	shr 	ebx, 1
	 mov	al, 8[esi]
	lea 	ecx, [ecx+edx+1]
	 mov	5[edi], bl

// postamble
	shr 	ecx, 1
	 lea 	edx, [edx+eax+1]
	shr 	edx, 1
	 mov	6[edi], cl
	add 	esi, PITCH			// increment source pointer
	 mov	7[edi], dl
	dec 	ebp					// loop counter
	 jne	main_loop

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 //end of asm
}
// end Interpolate_Half_Int()
//--------------------------------------------------------------------------//


__declspec(naked)
void Interpolate_Int_Half (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	dec 	edi					// pre-decrement destination
	 mov	ebp, 8				// loop counter
	xor 	eax, eax			// clear registers
	 xor 	ebx, ebx
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 4 instruction, 2 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	2 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1      2       3
//	cycle	
//	  1     load |       | shift
//	      -----------------------
//	  2          |  add  | store 
//
//	This assumes that the prior pell's value was loaded and 
//	preserved from the prior result's calculation.  Therefore
//	each result uses 2 registers -- one to load (and preserve)
//	the right-hand pell, and the other (overwriting the previous
//	result's stored pell value) to add into, shift, and store out
//	of.  The add is accomplished with the lea instruction, allowing
//	a round bit to be added in without using a separate instruction.
//	
//	The preamble loads & adds for the first result, and loads 
//	for the second.  The body executes the basic pattern six times.
//	The postamble shifts and stores for the seventh result and 
//	adds, shifts, and stores for the eighth.
//
//	Timing:
//		  4	preamble (including bank conflict)
//		 12	body
//		  4	postamble
//		----------------
//		 20	per loop
//		x 8	loops
//		----------------
//		160 subtotal
//		  6	initialize
//	 	  3	finalize
//		================
//		169 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	al, [esi]
	 mov	bl, PITCH[esi]		// probable BANK CONFLICT
	mov 	dl, [edi]			// heat the cache
	 inc	edi					// increment destination at top
	lea 	eax, [1+eax+ebx]	// use a regular add in the preamble
	 mov	cl, [2*PITCH+esi]

// body (6 pels)
	shr 	eax, 1
	 mov	dl, [3*PITCH+esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	[edi], al

	shr 	ebx, 1
	 mov	al, [4*PITCH+esi]
	lea 	ecx, [ecx+edx+1]
	 mov	[PITCH+edi], bl

	shr 	ecx, 1
	 mov	bl, [5*PITCH+esi]
	lea 	edx, [edx+eax+1]
	 mov	[2*PITCH+edi], cl

	shr 	edx, 1
	 mov	cl, [6*PITCH+esi]
	lea 	eax, [eax+ebx+1]
	 mov	[3*PITCH+edi], dl

	shr 	eax, 1
	 mov	dl, [7*PITCH+esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	[4*PITCH+edi], al

	shr 	ebx, 1
	 mov	al, [8*PITCH+esi]
	lea 	ecx, [ecx+edx+1]
	 mov	[5*PITCH+edi], bl

// postamble
	shr 	ecx, 1
	 lea 	edx, [edx+eax+1]
	shr 	edx, 1
	 mov	[6*PITCH+edi], cl
	inc 	esi					// increment source pointer
	 mov	[7*PITCH+edi], dl
	dec 	ebp					// loop counter
	 jne	main_loop

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 // end of asm
}
// end Interpolate_Int_Half()
//--------------------------------------------------------------------------//


__declspec(naked)
void Interpolate_Half_Half (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	mov		ebp, 8				// loop counter
	 sub 	edi, PITCH			// pre-decrement destination pointer
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 6 instruction, 3 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	3 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1        2        3
//	cycle	
//	  1     load | add left | 
//	      ----------------------------
//	  2     load |          | shift
//	      ----------------------------
//	  3          | add  all | store 
//
//	Five registers are used to preserve values from one pass to the next: 
//	  cl & dl		hold the last two pell values
//	  ebp or ebx	holds the sum of the two left-hand pells + 1
//	  eax			holds the sum of all four pells
//	Both adds are accomplished with the lea instruction.  For the sum
//	of the two left-hand pells, this allows a rounding bit to be added
//	in without using a separate instruction.  For both sums it allows
//	the result to be placed into a register independent of the sources'.
//	Since the sum of the two left-hand pells is used twice, it is place
//	alternately into ebx and ebp.
//	
//	The preamble does two preliminary loads plus passes 1 & 2 for the
//   first result, and pass 1 for the second.  The body executes the basic 
//	pattern six times.  The postamble does pass 3 for the  
//	seventh result and passes 2 & 3 for the eighth.
//
//	Due to the need for five registers, the loop counter is kept on
//	the stack.
//
//	Timing:
//		  8	preamble
//		 18	body
//		  5	postamble
//		----------------
//		 31	per loop
//		x 8	loops
//		----------------
//		248 subtotal
//		  5	initialize
//	 	  3	finalize
//		================
//		256 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	cl, [esi]					// pell 0
	 xor	eax, eax
	mov 	al, [esi+PITCH]				// pell 0
	 xor	ebx, ebx
	mov 	dl, [esi+1]					// pell 1
	 add 	eax, ecx					// partial sum 0 sans round
	mov 	bl, [esi+PITCH+1]			// pell 1
	 inc 	eax							// partial sum 0
	mov 	cl, [esi+2]					// pell 2
	 add	ebx, edx					// partial sum 1 sans round
	mov 	dl, [esi+PITCH+2]			// pell 2
	 inc	ebx							// partial sum 1
	add 	eax, ebx					// full sum 0
	 push	ebp							// save loop counter on stack
 	mov 	ebp, [edi+PITCH]			// heat the cache
	 add 	edi, PITCH					// increment dst. pointer at top of loop

// body (x 6)
	lea 	ebp, [ecx+edx+1]			// partial sum 2 with round
	 mov	cl, [esi+3]					// pell 3
	shr 	eax, 2						// value 0
	 mov	dl, [esi+PITCH+3]			// pell 3
	mov 	[edi], al					// write value 0
	 lea	eax, [ebx+ebp]				// full sum 1

	lea 	ebx, [ecx+edx+1]			// partial sum 3 with round
	 mov	cl, [esi+4]					// pell 4
	shr 	eax, 2						// value 1
	 mov	dl, [esi+PITCH+4]			// pell 4
	mov 	[edi+1], al					// write value 1
	 lea	eax, [ebx+ebp]				// full sum 2

	lea 	ebp, [ecx+edx+1]			// partial sum 4 with round
	 mov	cl, [esi+5]					// pell 5
	shr 	eax, 2						// value 2
	 mov	dl, [esi+PITCH+5]			// pell 5
	mov 	[edi+2], al					// write value 2
	 lea	eax, [ebx+ebp]				// full sum 3

	lea 	ebx, [ecx+edx+1]			// partial sum 5 with round
	 mov	cl, [esi+6]					// pell 6
	shr 	eax, 2						// value 3
	 mov	dl, [esi+PITCH+6]			// pell 6
	mov 	[edi+3], al					// write value 3
	 lea	eax, [ebx+ebp]				// full sum 4

	lea 	ebp, [ecx+edx+1]			// partial sum 6 with round
	 mov	cl, [esi+7]					// pell 7
	shr 	eax, 2						// value 4
	 mov	dl, [esi+PITCH+7]			// pell 7
	mov 	[edi+4], al					// write value 4
	 lea	eax, [ebx+ebp]				// full sum 5

	lea 	ebx, [ecx+edx+1]			// partial sum 7 with round
	 mov	cl, [esi+8]					// pell 8
	shr 	eax, 2						// value 5
	 mov	dl, [esi+PITCH+8]			// pell 8
	mov 	[edi+5], al					// write value 5
	 lea	eax, [ebx+ebp]				// full sum 6

// postamble
	shr 	eax, 2						// value 6
	 lea 	ebp, [ecx+edx+1]			// partial sum 8 with round
	mov 	[edi+6], al					// write value 6
	 add	esi, PITCH					// increment read pointer
	lea		eax, [ebx+ebp]				// full sum 7
	 pop	ebp							// restore loop counter
	shr 	eax, 2						// value 7
	 dec	ebp							// decrement loop counter
	mov 	[edi+7], al					// write value 7
	 jne	main_loop					// loop if not done

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 //end of asm
}
#pragma code_seg()
// end Interpolate_Half_Half()
//--------------------------------------------------------------------------//


/*
void Interpolate_Half_Half_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[j+1] + pSrc[PITCH+j] + pSrc[PITCH+j+1] + 2) >> 2;
}

void Interpolate_Int_Half_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[PITCH+j] + 1) >> 1;
}

void Interpolate_Half_Int_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[j+1] + 1) >> 1;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3idct.cpp ===
//  version 003; everything except 1) segment
//                                                                         
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   25 Oct 1996 13:32:28  $
// $Archive:   S:\h26x\src\dec\d3idct.cpv  $
// $Header:   S:\h26x\src\dec\d3idct.cpv   1.11   25 Oct 1996 13:32:28   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.cpv  $
// 
//    Rev 1.11   25 Oct 1996 13:32:28   AGUPTA2
// Re-scheduled butterfky code; re-arranged local var declarations.
// 
//    Rev 1.10   30 Aug 1996 08:39:56   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.9   17 Jul 1996 15:33:18   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.8   08 Mar 1996 16:46:20   AGUPTA2
// Added pragma code_seg.  Rolled the initialization code.  Got rid of most
// of 32-bit displacements in instructions.  Aligned frequently executed loops
// at 4-byte boundary.  Made changes to reflect new size of MapMatrix.  Removed
// nop instructions.  Deleted code that prefetches output lines in case of
// INTRA blocks. Use ClampTbl instead of ClipPixIntra.  Do not clip output
// of INTER blocks; clipping is done in dxblkadd().  
// 
// 
//    Rev 1.7   27 Dec 1995 14:36:06   RMCKENZX
// Added copyright notice
// 
//    Rev 1.6   09 Dec 1995 17:33:20   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.4   30 Nov 1995 18:02:14   CZHU
// Save and restore register before and after idct_acc
// 
//    Rev 1.1   27 Nov 1995 13:13:28   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:24   CZHU
// Initial revision.
// 
//Block level decoding for H.26x decoder
#include "precomp.h"

/////////////////////////////////////////////////////////////////////////
// Decode each none-empty block
// Input:  lpInst:       decoder instance,
//         lpSrc:        input bitstream,
//         lpBlockAction:
//                       the pointer to the block action stream structure
//         bitsread:     number of bits in the buffer already,
/////////////////////////////////////////////////////////////////////////

// local variable definitions
#define FRAMEPOINTER		esp
//////////////////////////////////////////////////////////////
//  L_ACCUM MUST BE LAST 256 BYTES OF A PAGE
/////////////////////////////////////////////////////////////
#define L_PRODUCT           FRAMEPOINTER    + 0 // 20 DWORD  
#define L_INPUT_INTER       L_PRODUCT       + 20*4 // DWORD
#define L_esi           	L_INPUT_INTER   + 1*4  // DWORD
#define L_NO_COEFF          L_esi           + 1*4  // DWORD
#define L_DESTBLOCK         L_NO_COEFF      + 1*4  // DWORD
#define L_LOOPCOUNTER       L_DESTBLOCK     + 1*4  // DWORD
#define L_STASHESP          L_LOOPCOUNTER   + 1*4  // DWORD
#define L_dummy             L_STASHESP      + 1*4  // 6 DWORDS
#define L_ACCUM             L_dummy         + 6*4  // 64 DWORD
#define LOCALSIZE		    (96*4)  // 96 DWORDS;multiple of cache line size

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#pragma code_seg("IACODE2")
__declspec(naked)
U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                       U32 No_Coeff, 
                       U32 pIntraBuf, 
                       U32 pInterBuf)
{		
__asm 
 {
////////////////////////////////////////////////////////////////
//  DON'T CHANGE LOCAL DECLARATIONS OR STACK POINTER ADJUSTMENT 
//  CODE WITHOUT TALKING TO ATUL
////////////////////////////////////////////////////////////////
    push    ebp                     // save callers frame pointer
      mov	ebp, esp                // make parameters accessible 
    push    esi			            // assumed preserved 
      push  edi			
    push    ebx
      mov   eax, pInterBuf			
	mov     edx, esp                // Save old ESP in edx
	  and   esp, -4096              // align at page boundary
    xor     esi, esi                // loop init
	  sub   esp, LOCALSIZE			// last 96 DWORDS of page
    lea     edi, [L_ACCUM]
      mov   ebx, 64                 // loop init
	mov     [L_STASHESP], edx       // Save old esp
      mov   edx, No_Coeff
    mov     [L_INPUT_INTER], eax
      mov   eax, ROUNDER            // loop init
	;
/////////////////////////////////////////////////////////////////
//  There is no point in pre-loading the cache.  That is because
//  after the first block it is likely to be in the cache.
//  
loop_for_init:
    mov     [edi], eax
      mov   [edi+4], eax
    mov     [edi+ebx], esi
      mov   [edi+ebx+4], esi
    mov     [edi+ebx+8], esi
      mov   [edi+ebx+12], esi
    mov     [edi+ebx+16], esi
      mov   [edi+ebx+20], esi
    add     edi, 8
      add   ebx, 16
    cmp     ebx, 192
      jl    loop_for_init

/////////////////////////////////////////////////////////////////////
// end of new init code

//end of IDCT init.
    
	cmp     edx, 65
	  jg    intra_block

    mov     ebx, pInterBuf
      jmp   pre_acc_loop

intra_block:
    mov     ebx, pIntraBuf
	  sub   edx, 65

// register:
// ebp: loop counter
// ebx: inverse quant
// ecx: index [0,63]

pre_acc_loop:
	mov     esi, pIQ_INDEX
	  mov   [L_DESTBLOCK], ebx
    mov     [L_esi], esi

ALIGN 4
acc_loop:
    mov     ebx,[esi+edx*8-8]           //Invserse Quant
	  mov   ecx,[esi+edx*8-4]           //Coeff index
    mov     [L_NO_COEFF], edx
	  call  idct_acc
	mov     esi, [L_esi]
	  mov   edx, [L_NO_COEFF]
	dec     edx
      jnz   acc_loop

	mov     edx, [L_DESTBLOCK]
	  mov   ecx, [L_INPUT_INTER]
	cmp     edx, ecx
	  jnz   call_intra_bfly

	call    idct_bfly_inter

	mov     esp, [L_STASHESP]	            // free locals  		
	  add   eax, edi 
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret

 
call_intra_bfly:
    call    idct_bfly_intra

	mov	    esp, [L_STASHESP]	            // free locals  		
	  add   eax, edi 
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret
     
///////////////////////////////////////////////////////////////
// assume parameter passed in by registers
// ebx, inverse quant
// ecx, index [0,63]
idct_acc:
       
;   For every non-zero coefficient:
;     LoopCounter, on local stack, has index
;     ecx = index (0-63)
;     ebx = non-zero input
;   Note i = index
; 	 	   	 
    and ecx, 03fh				    ; Chad added to prevent GPF
     mov   [L_LOOPCOUNTER+4], ecx   ; Store Loop counter
    xor     edx, edx                ; zero out for byte read, use as dword
      mov   esi, ecx                ; move index to esi
    lea     eax, Unique             ; eax = Address of Unique[0]
      mov   ebp, ecx                ; move index to ebp
    shl     esi, 3                  ; index*8
      add   ecx, ecx                ; index*2
    add     esi, ecx                ; index*10
      lea   ecx, KernelCoeff        ; get KernelCoeff[0][0]
    lea     edi, [L_PRODUCT+4]      ; edi = address of product[0]
      mov   dl,  [eax+ebp]          ; get Unique[i]
    lea     esi, [ecx+4*esi]        ; address of KernelCoeff[i][0]
      mov   ebp, edx                ; ebp = Unique[i]
    lea     eax, [edi+edx*4]        ; eax = address of product[totalU]
      nop

;   ----------------------------------------------------------------------

;   Register usage
;     eax = addr of product[Unique[i]]
;     ebx = input[i]
;     ecx = 0, -product[x]
;     edx = KernelCoeff[i][x], product[x]= KernelCoeff[i][x] * input[i]
;     ebp = x
;     edi = addr of product[0]
;     esi = addr of KernelCoeff[i][x]
ALIGN 4
loop_for_x:
    xor     ecx, ecx
      mov   edx, [esi+ebp*4-4]      ; read KernelCoeff[i][x]
    imul    edx, ebx                ; KernelCoeff[i][x] * input[i]
    mov     [edi+ebp*4-4], edx      ; product[x] = result of imul
      sub   ecx, edx          
    mov     [eax+ebp*4-4], ecx      ; product[totalU+x] = -product[x]
     dec    ebp                       ; decrement x
    jnz    loop_for_x

;   ----------------------------------------------------------------------

;   Register usage
;     eax = MapMatrix[0][0]
;     ebx = PClass[0], accum[xxx]
;     ecx = LoopCounter, addr of MapMatrix[i][0]
;     edx = product[0], accum[PClass[i][0-15]]
;     ebp = addr of accum[0], product[MapMatrix[i][0-15]]
;     edi = addr of product[0]
;     esi = PClass[i], address of accum[PClass[i]]

    mov     ecx, [L_LOOPCOUNTER+4]   ; get i
   	 and ecx, 0ffh				    ; Chad added to prevent GPF
    lea     ebx, PClass         ; get addr of PClass[0]
      mov   esi, ecx
    shl     ecx, 4
      lea   eax, MapMatrix      ; get addr of MapMatrix[0][0]
    xor     edx, edx
      nop
    mov     dl,  [ebx+esi]          ; get PClass[i]
      lea   ecx, [eax+1*ecx]        ; get addr of MapMatrix[i][0]
    shl     edx, 2                  ; esi*4
      lea   esi, [L_ACCUM+4]          ; get addr of accum[0]
;   ----------------------------------------------------------------------
    xor     eax, eax                ; get MapMatrix[i][0]
      add   esi, edx                ; esi = address of accum[PClass[i]]
    mov     al,  [ecx]
      mov   ebx, [esi]              ; get accum[PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[0]]
      mov   al,  [ecx+1]            ; get pNKernel->matrix[1]
    add     ebx, ebp                ; accum[pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[0]]
      mov   edx, [esi+4]            ; get accum[1+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[1]]
      mov   al,  [ecx+2]            ; get pNKernel->matrix[2]
    add     edx, ebp                ; accum[1+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[1]] 
      mov   [esi], ebx              ; store accum[pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[0]]
    mov     [esi+4], edx            ; store accum[1+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[1]]
      mov   ebx, [esi+8]            ; get accum[2+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[2]]
      mov   al,  [ecx+3]           ; get pNKernel->matrix[3]
    add     ebx, ebp                ; accum[2+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[2]]
      mov   edx, [esi+12]           ; get accum[3+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[3]]
      mov   al,  [ecx+4]           ; get pNKernel->matrix[4]
    add     edx, ebp                ; accum[3+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[3]]
      mov   [esi+8], ebx            ; store accum[2+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[2]]
    mov     [esi+12], edx           ; store accum[3+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[3]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+16]           ; get accum[4+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[4]]
      mov   al,  [ecx+5]           ; get pNKernel->matrix[5]
    add     ebx, ebp                ; accum[4+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[4]]
      mov   edx, [esi+20]           ; get accum[5+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[5]]
      mov   al,  [ecx+6]           ; get pNKernel->matrix[6]
    add     edx, ebp                ; accum[5+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[5]] 
      mov   [esi+16], ebx           ; store accum[4+pNKernel->PClass] += 
                                    ;       product[pNKernel->matrix[4]]
    mov     [esi+20], edx           ; store accum[5+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[5]]
      mov   ebx, [esi+24]           ; get accum[6+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[6]]
      mov   al,  [ecx+7]           ; get pNKernel->matrix[7]
    add     ebx, ebp
      mov   edx, [esi+28]           ; get accum[7+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[7]]
      mov   al,  [ecx+8]           ; get pNKernel->matrix[8]
    add     edx, ebp                ; accum[7+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[7]]   
      mov   [esi+24], ebx           ; store accum[6+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[6]]
    mov     [esi+28], edx           ; store accum[7+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[7]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+32]           ; get accum[8+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[8]]
      mov   al,  [ecx+9]           ; get pNKernel->matrix[9]
    add     ebx, ebp                ; accum[8+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[8]]
      mov   edx, [esi+36]           ; get accum[9+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[9]]
      mov   al,  [ecx+10]           ; get pNKernel->matrix[10]
    add     edx, ebp                ; accum[9+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[9]] 
      mov   [esi+32], ebx           ; store accum[8+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[8]]
    mov     [esi+36], edx           ; store accum[9+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[9]]
      mov   ebx, [esi+40]           ; get accum[10+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[10]]
      mov   al,  [ecx+11]           ; get pNKernel->matrix[11]
    add     ebx, ebp
      mov   edx, [esi+44]           ; get accum[11+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[11]]
                                    ;       product[pNKernel->matrix[11]]
      mov   al,  [ecx+12]           ; get pNKernel->matrix[12]
    add     edx, ebp                ; accum[11+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[11]]
      mov   [esi+40], ebx           ; store accum[10+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[10]]
    mov     [esi+44], edx           ; store accum[11+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[11]]
;   ----------------------------------------------------------------------
      mov   ebx, [esi+48]           ; get accum[12+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[12]]
      mov   al,  [ecx+13]           ; get pNKernel->matrix[13]
    add     ebx, ebp                ; accum[12+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[12]]
      mov   edx, [esi+52]           ; get accum[13+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[13]]
      mov   al,  [ecx+14]           ; get pNKernel->matrix[14]
    add     edx, ebp                ; accum[13+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[13]] 
      mov   [esi+48], ebx           ; store accum[pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[13]]
    mov     [esi+52], edx           ; store accum[13+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[13]]
      mov   ebx, [esi+56]           ; get accum[14+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[14]]
      mov   al,  [ecx+15]           ; get pNKernel->matrix[15]
    add     ebx, ebp
      mov   edx, [esi+60]           ; get accum[15+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[15]]
      mov   [esi+56], ebx           ; store accum[14+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[14]]
    add     edx, ebp                ; accum[15+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[15]]
      mov   [esi+60], edx           ; store accum[15+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[15]]
	ret
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers


idct_bfly_intra:
   
;   ----------------------------------------------------------------------
;   INTRA ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Output matrix of BYTES, OutputCoeff
;
;   Process 4 outputs per group, 0-15
;   0

    lea     esi, [L_ACCUM+4]        ; get addr of accum[0]
      mov   edi, [L_DESTBLOCK+4]    ; edi gets Base addr of OutputCoeff
    add     esi, 128
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi+64-128]       ; get acc[16]
    mov     ebp, [esi+128-128]      ; get acc[32]
      mov   edx, [esi+192-128]      ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi], dl      ; output[0][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+7], cl    ; output[0][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH], bl  ; output[7][0] = tmp3
      mov   ebx, [esi+68-128]       ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     BYTE PTR [edi+7*PITCH+7], al  ; output[7][7] = tmp4
      mov   eax, [esi+4-128]        ; get acc[1]
    mov     ebp, [esi+132-128]      ; get acc[33]
      mov   edx, [esi+196-128]      ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+1], dl    ; output[0][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+6], cl    ; output[0][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+1], bl  ; output[7][1] = tmp3
      mov   ebx, [esi+72-128]       ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     BYTE PTR [edi+7*PITCH+6], al  ; output[7][6] = tmp4
      mov   eax, [esi+8-128]        ; get acc[2]
    mov     ebp, [esi+136-128]      ; get acc[34]
      mov   edx, [esi+200-128]      ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    nop
      nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2], dl    ; output[0][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+5], cl    ; output[0][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+2], bl  ; output[7][2] = tmp3
      mov   ebx, [esi+76-128]       ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     BYTE PTR [edi+7*PITCH+5], al  ; output[7][5] = tmp4
      mov   eax, [esi+12-128]       ; get acc[3]
    mov     ebp, [esi+140-128]      ; get acc[35]
      mov   edx, [esi+204-128]      ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3], dl    ; output[0][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+4], cl    ; output[0][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+3], bl  ; output[7][3] = tmp3
      mov   ebx, [esi+80-128]       ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     BYTE PTR [edi+7*PITCH+4], al  ; output[7][4] = tmp4
      mov   eax, [esi+16-128]       ; get acc[4]
    mov     ebp, [esi+144-128]      ; get acc[36]
      mov   edx, [esi+208-128]      ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH], dl   ; output[1][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+7], cl   ; output[1][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH], bl   ; output[6][0] = tmp3
      mov   ebx, [esi+84-128]       ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     BYTE PTR [edi+6*PITCH+7], al  ; output[6][7] = tmp4
      mov   eax, [esi+20-128]       ; get acc[5]
    mov     ebp, [esi+148-128]      ; get acc[37]
      mov   edx, [esi+212-128]      ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+1], dl   ; output[1][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+6], cl   ; output[1][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+1], bl   ; output[6][1] = tmp3
      mov   ebx, [esi+88-128]       ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     BYTE PTR [edi+6*PITCH+6], al  ; output[6][6] = tmp4
      mov   eax, [esi+24-128]       ; get acc[6]
    mov     ebp, [esi+152-128]      ; get acc[38]
      mov   edx, [esi+216-128]      ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+2], dl   ; output[1][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+5], cl   ; output[1][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+2], bl  ; output[6][2] = tmp3
      mov   ebx, [esi+92-128]       ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     BYTE PTR [edi+6*PITCH+5], al  ; output[6][5] = tmp4
      mov   eax, [esi+28-128]       ; get acc[7]
    mov     ebp, [esi+156-128]      ; get acc[39]
      mov   edx, [esi+220-128]      ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+3], dl   ; output[1][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+4], cl   ; output[1][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+3], bl  ; output[6][3] = tmp3
      mov   ebx, [esi+96-128]       ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     BYTE PTR [edi+6*PITCH+4], al  ; output[6][4] = tmp4
      mov   eax, [esi+32-128]       ; get acc[8]
    mov     ebp, [esi+160-128]      ; get acc[40]
      mov   edx, [esi+224-128]      ; get acc[56]
    lea     ecx, [eax+ebx]          ; acc[8]+acc[24]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH], dl   ; output[2][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+7], cl   ; output[2][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH], bl   ; output[5][0] = tmp3
      mov   ebx, [esi+100-128]      ; get acc[25]

;   -------------------------------------------------------------------------
;   9
    mov     BYTE PTR [edi+5*PITCH+7], al   ; output[5][7] = tmp4
      mov   eax, [esi+36-128]       ; get acc[9]
    mov     ebp, [esi+164-128]      ; get acc[41]
      mov   edx, [esi+228-128]      ; get acc[57]
    lea     ecx, [eax+ebx]          ; acc[9]+acc[25]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+1], dl   ; output[2][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+6], cl   ; output[2][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+1], bl   ; output[5][1] = tmp3
      mov   ebx, [esi+104-128]      ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     BYTE PTR [edi+5*PITCH+6], al   ; output[5][6] = tmp4
      mov   eax, [esi+40-128]       ; get acc[10]
    mov     ebp, [esi+168-128]      ; get acc[42]
      mov   edx, [esi+232-128]      ; get acc[58]
    lea     ecx, [eax+ebx]          ; acc[10]+acc[26]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+2], dl   ; output[2][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+5], cl   ; output[2][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+2], bl   ; output[5][2] = tmp3
      mov   ebx, [esi+108-128]      ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     BYTE PTR [edi+5*PITCH+5], al   ; output[5][5] = tmp4
      mov   eax, [esi+44-128]       ; get acc[11]
    mov     ebp, [esi+172-128]      ; get acc[43]
      mov   edx, [esi+236-128]      ; get acc[59]
    lea     ecx, [eax+ebx]          ; acc[11]+acc[27]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+3], dl   ; output[2][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+4], cl   ; output[2][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+3], bl   ; output[5][3] = tmp3
      mov   ebx, [esi+112-128]      ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     BYTE PTR [edi+5*PITCH+4], al   ; output[5][4] = tmp4
      mov   eax, [esi+48-128]       ; get acc[12]
    mov     ebp, [esi+176-128]      ; get acc[44]
      mov   edx, [esi+240-128]      ; get acc[60]
    lea     ecx, [eax+ebx]          ; acc[12]+acc[28]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH], dl   ; output[3][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+7], cl   ; output[3][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH], bl   ; output[4][0] = tmp3
      mov   ebx, [esi+116-128]      ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     BYTE PTR [edi+4*PITCH+7], al   ; output[4][7] = tmp4
      mov   eax, [esi+52-128]       ; get acc[13]
    mov     ebp, [esi+180-128]      ; get acc[45]
      mov   edx, [esi+244-128]      ; get acc[61]
    lea     ecx, [eax+ebx]          ; acc[13]+acc[29]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+1], dl   ; output[3][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+6], cl   ; output[3][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+1], bl   ; output[4][1] = tmp3
      mov   ebx, [esi+120-128]      ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     BYTE PTR [edi+4*PITCH+6], al   ; output[4][6] = tmp4
      mov   eax, [esi+56-128]       ; get acc[14]
    mov     ebp, [esi+184-128]      ; get acc[46]
      mov   edx, [esi+248-128]      ; get acc[62]
    lea     ecx, [eax+ebx]          ; acc[14]+acc[30]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+2], dl   ; output[3][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+5], cl   ; output[3][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+2], bl   ; output[4][2] = tmp3
      mov   ebx, [esi+124-128]      ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     BYTE PTR [edi+4*PITCH+5], al   ; output[4][5] = tmp4
      mov   eax, [esi+60-128]       ; get acc[15]
    mov     ebp, [esi+188-128]      ; get acc[47]
      mov   edx, [esi+252-128]      ; get acc[63]
    lea     ecx, [eax+ebx]          ; acc[15]+acc[31]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+3], dl   ; output[3][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+4], cl   ; output[3][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+3], bl   ; output[4][3] = tmp3
      mov   BYTE PTR [edi+4*PITCH+4], al   ; output[4][4] = tmp4
    ret

////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_inter:

;   ----------------------------------------------------------------------
;   INTER ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Intermediate matrix [8][8] of DWORDS, Intermediate
;   NOTE:
;     Code assumes that Intermediate and accumulator arrays are aligned at
;     cache-line boundary
;   Process 4 outputs per group, 0-15
;   0

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
      lea   esi, [L_ACCUM+4+128]    ; get addr of accum[0] biased by 128
    add     edi, 128
	  nop
    mov     ebx, [esi+64-128]       ; get acc[16]
      mov   eax, [esi-128]          ; get acc[0]  bank conflict
;	mov     edx, [edi-128]          ; pre-fetch line 0; 4 to avoid bank conflict
;	  mov   ecx, [edi+1*32-128+4]   ; pre-fetch line 1
;	mov     edx, [edi+2*32-128]     ; pre-fetch line 2
;	  mov   ecx, [edi+3*32-128+4]   ; pre-fetch line 3
;	mov     edx, [edi+4*32-128]     ; pre-fetch line 4
;	  mov   ecx, [edi+5*32-128+4]   ; pre-fetch line 5
;	mov     edx, [edi+6*32-128]     ; pre-fetch line 6
;	  mov   ecx, [edi+7*32-128+4]   ; pre-fetch line 7
	mov     ebp, [esi+128-128]      ; get acc[32]
     lea    ecx, [eax+ebx]          ; acc[0]+acc[16]
    mov     edx, [esi+192-128]      ; get acc[48]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]
	lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi-128], edx           ; Intermediate[0][0] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+7*4-128], ecx       ; Intermediate[0][7] = tmp2
    mov     DWORD PTR [edi+7*32-128], ebx      ; Intermediate[7][0] = tmp3
      mov   ebx, [esi+68-128]                  ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     DWORD PTR [edi+7*32+7*4-128], eax  ; Intermediate[7][7] = tmp4
      mov   eax, [esi+4-128]        ; get acc[1]
    mov     ebp, [esi+132-128]      ; get acc[33]
      lea   ecx, [eax+ebx]          ; acc[1]+acc[17]
    mov     edx, [esi+196-128]      ; get acc[49]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+1*4-128], edx       ; Intermediate[0][1] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+6*4-128], ecx       ; Intermediate[0][6] = tmp2
    mov   DWORD PTR [edi+7*32+1*4-128], ebx    ; Intermediate[7][1] = tmp3
      mov   ebx, [esi+72-128]                  ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     DWORD PTR [edi+7*32+6*4-128], eax  ; Intermediate[7][6] = tmp4
      mov   eax, [esi+8-128]        ; get acc[2]
    mov     ebp, [esi+136-128]      ; get acc[34]
      lea   ecx, [eax+ebx]          ; acc[2]+acc[18]
    mov     edx, [esi+200-128]      ; get acc[50]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+2*4-128], edx       ; Intermediate[0][2] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+5*4-128], ecx       ; Intermediate[0][5] = tmp2
    mov     DWORD PTR [edi+7*32+2*4-128], ebx  ; Intermediate[7][2] = tmp3
      mov   ebx, [esi+76-128]                  ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     DWORD PTR [edi+7*32+5*4-128], eax  ; Intermediate[7][5] = tmp4
      mov   eax, [esi+12-128]       ; get acc[3]
    mov     ebp, [esi+140-128]      ; get acc[35]
      lea   ecx, [eax+ebx]          ; acc[3]+acc[19]
    mov     edx, [esi+204-128]      ; get acc[51]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+3*4-128], edx       ; Intermediate[0][3] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+4*4-128], ecx       ; Intermediate[0][4] = tmp2
    mov     DWORD PTR [edi+7*32+3*4-128], ebx  ; Intermediate[7][3] = tmp3
      mov   ebx, [esi+80-128]                  ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     DWORD PTR [edi+7*32+4*4-128], eax  ; Intermediate[7][4] = tmp4
      mov   eax, [esi+16-128]       ; get acc[4]
    mov     ebp, [esi+144-128]      ; get acc[36]
      lea   ecx, [eax+ebx]          ; acc[4]+acc[20]
    mov     edx, [esi+208-128]      ; get acc[52]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     ebx, SCALER                     ; tmp3 >> 13
      mov   DWORD PTR [edi+32-128], edx     ; Intermediate[1][0] = tmp1
    sar     eax, SCALER                     ; tmp4 >> 13
      mov   DWORD PTR [edi+32+7*4-128], ecx ; Intermediate[1][7] = tmp2
    mov     DWORD PTR [edi+6*32-128], ebx   ; Intermediate[6][0] = tmp3
      mov   ebx, [esi+84-128]               ; get acc[21]
;   -------------------------------------------------------------------------
;   5
    mov     DWORD PTR [edi+6*32+7*4-128], eax ; Intermediate[6][7] = tmp4
      mov   eax, [esi+20-128]       ; get acc[5]
    mov     ebp, [esi+148-128]      ; get acc[37]
      lea   ecx, [eax+ebx]          ; acc[5]+acc[21]
    mov     edx, [esi+212-128]      ; get acc[53]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+1*4-128], edx   ; Intermediate[1][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+6*4-128], ecx   ; Intermediate[1][6] = tmp2
    mov     DWORD PTR [edi+6*32+1*4-128], ebx ; Intermediate[6][1] = tmp3
      mov   ebx, [esi+88-128]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     DWORD PTR [edi+6*32+6*4-128], eax ; Intermediate[6][6] = tmp4
      mov   eax, [esi+24-128]       ; get acc[6]  Bank conflict
    mov     ebp, [esi+152-128]      ; get acc[38]
      lea   ecx, [eax+ebx]          ; acc[6]+acc[22]
    mov     edx, [esi+216-128]      ; get acc[54]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+2*4-128], edx   ; Intermediate[1][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+5*4-128], ecx   ; Intermediate[1][5] = tmp2
    mov     DWORD PTR [edi+6*32+2*4-128], ebx ; Intermediate[6][2] = tmp3
      mov   ebx, [esi+92-128]                 ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     DWORD PTR [edi+6*32+5*4-128], eax ; Intermediate[6][5] = tmp4
      mov   eax, [esi+28-128]       ; get acc[7]
    mov     ebp, [esi+156-128]      ; get acc[39]
      lea   ecx, [eax+ebx]          ; acc[7]+acc[23]
    mov     edx, [esi+220-128]      ; get acc[55]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+3*4-128], edx   ; Intermediate[1][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+4*4-128], ecx   ; Intermediate[1][4] = tmp2
    mov     DWORD PTR [edi+6*32+3*4-128], ebx ; Intermediate[6][3] = tmp3
      mov   ebx, [esi+96-128]                 ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     DWORD PTR [edi+6*32+4*4-128], eax ; Intermediate[6][4] = tmp4
      mov   eax, [esi+32-128]       ; get acc[8]
    mov     ebp, [esi+160-128]      ; get acc[40]
      lea   ecx, [eax+ebx]          ; acc[8]+acc[24]
    mov     edx, [esi+224-128]      ; get acc[56]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32-128], edx     ; Intermediate[2][0] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+7*4-128], ecx ; Intermediate[2][7] = tmp2
    mov     DWORD PTR [edi+5*32-128], ebx     ; Intermediate[5][0] = tmp3
      mov   ebx, [esi+100-128]                ; get acc[25]
;   -------------------------------------------------------------------------
;   9
    mov     DWORD PTR [edi+5*32+7*4-128], eax ; Intermediate[5][7] = tmp4
      mov   eax, [esi+36-128]       ; get acc[9]
    mov     ebp, [esi+164-128]      ; get acc[41]
      lea   ecx, [eax+ebx]          ; acc[9]+acc[25]
    mov   edx, [esi+228-128]        ; get acc[57]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+1*4-128], edx ; Intermediate[2][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+6*4-128], ecx ; Intermediate[2][6] = tmp2
    mov     DWORD PTR [edi+5*32+1*4-128], ebx ; Intermediate[5][1] = tmp3
      mov   ebx, [esi+104-128]                ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     DWORD PTR [edi+5*32+6*4-128], eax ; Intermediate[5][6] = tmp4
      mov   eax, [esi+40-128]       ; get acc[10]
    mov     ebp, [esi+168-128]      ; get acc[42]
      lea   ecx, [eax+ebx]          ; acc[10]+acc[26]
    mov     edx, [esi+232-128]      ; get acc[58]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+2*4-128], edx ; Intermediate[2][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+5*4-128], ecx ; Intermediate[2][5] = tmp2
    mov     DWORD PTR [edi+5*32+2*4-128], ebx ; Intermediate[5][2] = tmp3
      mov   ebx, [esi+108-128]                ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     DWORD PTR [edi+5*32+5*4-128], eax ; Intermediate[5][5] = tmp4
      mov   eax, [esi+44-128]       ; get acc[11]
    mov     ebp, [esi+172-128]      ; get acc[43]
      lea   ecx, [eax+ebx]          ; acc[11]+acc[27]
    mov   edx, [esi+236-128]        ; get acc[59]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+3*4-128], edx ; Intermediate[2][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+4*4-128], ecx ; Intermediate[2][4] = tmp2
    mov     DWORD PTR [edi+5*32+3*4-128], ebx ; Intermediate[5][3] = tmp3
      mov   ebx, [esi+112-128]                ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     DWORD PTR [edi+5*32+4*4-128], eax ; Intermediate[5][4] = tmp4
      mov   eax, [esi+48-128]       ; get acc[12] Bank conflict
    mov     ebp, [esi+176-128]      ; get acc[44]
      lea   ecx, [eax+ebx]          ; acc[12]+acc[28]
    mov     edx, [esi+240-128]      ; get acc[60]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32-128], edx     ; Intermediate[3][0] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+7*4-128], ecx ; Intermediate[3][7] = tmp2
    mov     DWORD PTR [edi+4*32-128], ebx     ; Intermediate[4][0] = tmp3
      mov   ebx, [esi+116-128]                ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     DWORD PTR [edi+4*32+7*4-128], eax ; Intermediate[4][7] = tmp4
      mov   eax, [esi+52-128]       ; get acc[13]
    mov     ebp, [esi+180-128]      ; get acc[45]
      lea   ecx, [eax+ebx]          ; acc[13]+acc[29]
    mov     edx, [esi+244-128]      ; get acc[61]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+1*4-128], edx ; Intermediate[3][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+6*4-128], ecx ; Intermediate[3][6] = tmp2
    mov     DWORD PTR [edi+4*32+1*4-128], ebx ; Intermediate[4][1] = tmp3
      mov   ebx, [esi+120-128]                ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     DWORD PTR [edi+4*32+6*4-128], eax ; Intermediate[4][6] = tmp4
      mov   eax, [esi+56-128]       ; get acc[14]  Bank conflict
    mov     ebp, [esi+184-128]      ; get acc[46]
      lea   ecx, [eax+ebx]          ; acc[14]+acc[30]
    mov     edx, [esi+248-128]      ; get acc[62]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+2*4-128], edx ; Intermediate[3][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+5*4-128], ecx ; Intermediate[3][5] = tmp2
    mov     DWORD PTR [edi+4*32+2*4-128], ebx ; Intermediate[4][2] = tmp3
      mov   ebx, [esi+124-128]                ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     DWORD PTR [edi+4*32+5*4-128], eax ; Intermediate[4][5] = tmp4
      mov   eax, [esi+60-128]       ; get acc[15]
    mov     ebp, [esi+188-128]      ; get acc[47]
      lea   ecx, [eax+ebx]          ; acc[15]+acc[31]
    mov     edx, [esi+252-128]      ; get acc[63]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+3*4-128], edx ; Intermediate[3][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+4*4-128], ecx ; Intermediate[3][4] = tmp2
    mov     DWORD PTR [edi+4*32+3*4-128], ebx ; Intermediate[4][3] = tmp3
      mov   DWORD PTR [edi+4*32+4*4-128], eax ; Intermediate[4][4] = tmp4
    ret
	} //end of asm

}
 
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3idct.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:56:42  $
// $Archive:   S:\h26x\src\dec\d3idct.h_v  $
// $Header:   S:\h26x\src\dec\d3idct.h_v   1.5   14 Mar 1996 14:56:42   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.h_v  $
;// 
;//    Rev 1.5   14 Mar 1996 14:56:42   AGUPTA2
;// 
;//    Rev 1.4   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:34:26   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.1   27 Nov 1995 13:13:32   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:34   CZHU
// Initial revision.

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#ifndef _DECODE_BLOCK_IDCT_INC
#define _DECODE_BLOCK_IDCT_INC

extern U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pIntraBuf, 
                                 U32 pInterBuf);

#ifdef USE_MMX // { USE_MMX
extern "C" void _fastcall MMX_DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pInterBuf);
#endif // } USE_MMX
		
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3gob.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3gob.h
 *
 *  Description:
 *		Interface to GOB header processing.  
 */

/*
 * $Header:   S:\h26x\src\dec\d3gob.h_v   1.2   27 Dec 1995 14:36:14   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\d3gob.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
 */

#ifndef __D3GOB_H__
#define __D3GOB_H__

extern I32 H263DecodeGOBHeader(T_H263DecoderCatalog FAR * DC, 
							   BITSTREAM_STATE FAR * fpbsState,
							   U32 uAssumedGroupNumber);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3mblk.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3mblk.h
 *
 *  Description:
 *		Interface to macro block header processing.  
 */

/*
 * $Header:   S:\h26x\src\dec\d3mblk.h_v   1.11   25 Sep 1996 08:05:36   KLILLEVO  $
 * $Log:   S:\h26x\src\dec\d3mblk.h_v  $
;// 
;//    Rev 1.11   25 Sep 1996 08:05:36   KLILLEVO
;// initial extended motion vectors support 
;// does not work for AP yet
;// 
;//    Rev 1.10   09 Jul 1996 16:47:26   AGUPTA2
;// MMX_ClipAndMove now addas DC value to the result; IDCT for INTRA blocks
;// works with DC value set to zero.  Also, BlockCopy is done in chunks of
;// 4 loads followed by 4 stores.
;// Changed code to adhere to coding convention in the decoder.
;// 
;//    Rev 1.9   04 Apr 1996 11:05:56   AGUPTA2
;// Added decl for MMX_BlockCopy().
;// 
;//    Rev 1.8   14 Mar 1996 17:03:10   AGUPTA2
;// Added decls for MMX rtns.
;// 
;//    Rev 1.7   08 Mar 1996 16:46:24   AGUPTA2
;// Changed function declarations.
;// 
;// 
;//    Rev 1.6   23 Feb 1996 09:46:50   KLILLEVO
;// fixed decoding of Unrestricted Motion Vector mode
;// 
;//    Rev 1.5   18 Dec 1995 12:47:52   RMCKENZX
;// added copyright notice and header & log keywords
 */

#ifndef __D3MB_H__
#define __D3MB_H__

extern void H263IDCTandMC(T_H263DecoderCatalog FAR *DC,	   // NEW function
				T_BlkAction FAR * fpBlockAction,
				int b,
				int m,
				int g,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				T_MBInfo *fpMBInfo,
				int iEdgeFlag);


extern void H263BFrameIDCTandBiMC(                           // PB-NEW function
				T_H263DecoderCatalog FAR *DC,
				T_BlkAction FAR * fpBlockAction,
				int b,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				U32 *pRef);

extern void H263BBlockPrediction(
				T_H263DecoderCatalog FAR *DC,
				T_BlkAction FAR *fpBlockAction,
				U32 *pRef,
				T_MBInfo FAR *fpMBInfo,
				int iEdgeFlag);

extern void __fastcall BlockCopy(U32 uDstBlock, U32 uSrcBlock);
#ifdef USE_MMX // { USE_MMX
extern "C" void __fastcall MMX_BlockCopy(U32 uDstBlock, U32 uSrcBlock);
#endif // } USE_MMX
extern void BlockAdd(
      U32 uResidual, 
      U32 uRefBlock, 
      U32 uDstBlock);
#ifdef USE_MMX // { USE_MMX
extern "C" void __fastcall MMX_BlockAdd(
      U32 uResidual,   // pointer to IDCT output
      U32 uRefBlock,   // pointer to predicted values
      U32 uDstBlock);  // pointer to destination

extern "C" void __fastcall MMX_ClipAndMove(
      U32 uResidual,   // pointer to IDCT output
      U32 uDstBlock,   // pointer to destination
      U32 ScaledDC);   // Scaled DC
#endif // } USE_MMX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3mvdec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 17:29:46  $
// $Archive:   S:\h26x\src\dec\d3mvdec.h_v  $
// $Header:   S:\h26x\src\dec\d3mvdec.h_v   1.8   08 Mar 1996 17:29:46   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3mvdec.h_v  $
;// 
;//    Rev 1.8   08 Mar 1996 17:29:46   AGUPTA2
;// Changed BlockCopy interface.
;// 
;//    Rev 1.7   18 Dec 1995 12:43:10   RMCKENZX
;// added copyright notice
;// 
;//    Rev 1.6   13 Dec 1995 11:00:22   RHAZRA
;// No change.
;// 
;//    Rev 1.5   11 Dec 1995 11:34:40   RHAZRA
;// No change.
;// 
;//    Rev 1.4   09 Dec 1995 17:30:58   RMCKENZX
;// Gutted and re-built file to support decoder re-architecture.
;// New modules are:
;// H263ComputeMotionVectors
;// H263DecodeMBHeader
;// H263DecodeIDCTCoeffs
;// This module now contains code to support the first pass of the decoder
;// 
;//    Rev 1.3   11 Oct 1995 13:26:04   CZHU
;// Added code to support PB frame
;// 
;//    Rev 1.2   03 Oct 1995 12:22:14   CZHU
;// Fixed bug found by Tom in GetVariableBits for Code 0xC0
;// 
;//    Rev 1.1   11 Sep 1995 17:21:34   CZHU
;// Changed the interface
;// 
;//    Rev 1.0   08 Sep 1995 11:46:02   CZHU
;// Initial revision.

/////////////////////////////////////////////////////////////////////////// 
//  d3mvdec.h
//
//  Description:
//		Interface to motion vector decoding.  
//
// 


#ifndef __D3MVD_H__
#define __D3MVD_H__

#define GET_VARIABLE_BITS_MV(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpMajorTable, fpMinorTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	if (uCode >= 0xc0)						\
	{ uCode = uCode >> 5 ;                   \
	  uResult = fpMajorTable[uCode];		\
	}										\
	else									\
	  uResult = fpMinorTable[uCode];        \
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

extern 	I32 H263ComputeMotionVectors(
			T_H263DecoderCatalog FAR * DC,
			T_BlkAction FAR * fpBlockAction);

extern I32 H263DecodeMBHeader(
			T_H263DecoderCatalog FAR * DC, 
			BITSTREAM_STATE FAR * fpbsState,
			U32 **pN,                         // NEW
			T_MBInfo FAR * fpMBInfo);         // PB-New

extern I32 H263DecodeIDCTCoeffs(
			T_H263DecoderCatalog FAR * DC,	  // Old function munged
			T_BlkAction FAR * fpBlockAction, 
			U32 uBlockNumber,
			BITSTREAM_STATE FAR * fpbsState,
			U8 FAR * fpu8MaxPtr,
			U32 **pN,
			T_IQ_INDEX **pRUN_INVERSE_Q); // NEW 

// extern void BlockCopy(U32 uDstBlock, U32 uSrcBlock);

// select the medium value
#define MEDIAN(x,y,z,a) {if (y < x) {a=y;y=x;x=a;} if (y > z) { y= (x < z)? z:x;}}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\dec\d3rtp.cpv   1.6   06 Nov 1996 15:23:02   CZHU  $
// $Log:   S:\h26x\src\dec\d3rtp.cpv  $
// 
//    Rev 1.6   06 Nov 1996 15:23:02   CZHU
// 
// Returning MVs in FindNextPacket()
// 
//    Rev 1.5   03 Nov 1996 18:41:40   gmlim
// Modified RTPH263FindNextPacket() to support mode c.
// 
//    Rev 1.4   23 Jul 1996 11:22:16   CZHU
// 
// Added a MV recovery. Hursitic will be added in later.
// 
//    Rev 1.3   15 Jul 1996 16:22:42   CZHU
// Added checking bitstream extension when PSC is lost.
// 
//    Rev 1.2   03 May 1996 13:04:22   CZHU
// Change logic such that bitstream verification is invoked only when bit erro
// is encountered.
// 
//    Rev 1.1   28 Apr 1996 21:18:58   BECHOLS
// Removed ifdef RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:08   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:35:58   CZHU
// 
// Added subroutine to recover picture header information from extended bitstr
// 
//    Rev 1.6   29 Mar 1996 14:39:56   CZHU
// 
// cleaning 
// 
//    Rev 1.5   29 Mar 1996 13:39:16   CZHU
// 
// Moved bs verification to c3rtp.cpp
// 
//    Rev 1.4   28 Mar 1996 18:40:28   CZHU
// Support packet loss recovery
// 
//    Rev 1.3   23 Feb 1996 16:21:22   CZHU
// No change.
// 
//    Rev 1.2   15 Feb 1996 12:01:50   CZHU
// 
// More clean up
// 
//    Rev 1.1   14 Feb 1996 15:00:10   CZHU
// Added support Mode A and Mode B
// 
//    Rev 1.0   12 Feb 1996 17:05:56   CZHU
// Initial revision.
// 
//    Rev 1.2   25 Jan 1996 16:13:54   CZHU
// changed name to the spec
// 
//    Rev 1.1   15 Dec 1995 13:07:30   CZHU
// 
//  
// 
//    Rev 1.0   11 Dec 1995 14:54:22   CZHU
// Initial revision.
*/

#include "precomp.h"

/*
 * RtpH263FindNextPacket() look through the extended bitstream and
 * find the next BITSTREAM_INFO structure that point to a valid packet
 * return indicates what mode the next packet is in mode A, or mode B,
 * mode C is not supported at this point.Chad, 3/28/96
 * 
 * Mode C is supported now. And a special case LAST packet is lost is also
 * covered. Chad, 11/6/96
 *
 */

I32 RtpH263FindNextPacket( //DC, fpbsState, &pN, fpMBInfo, &uNewMB, &uNewGOB)
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32 **pN,
	U32 *pQuant,
	int *pMB,
	int *pGOB,
	I8 MVs[4]
	)                      

{  I32 iret=ICERR_OK; 
//#ifdef LOSS_RECOVERY
   U32 u; 
   U32 uBitOffset;
   U32 uBitstream = (U32)((U32)DC + DC->X32_BitStream);
   T_RTP_H263_BSINFO *pBsInfo;
   U32 mask[]={0xff,0x7f, 0x3f, 0x1f,0x0f, 0x07, 0x03,0x01};
     //verify bitstream extension first

   if (!DC->iVerifiedBsExt)
   	 H263RTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);

   if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
   }

   uBitOffset =  ((U32)fpbsState->fpu8 - uBitstream)*8 - 8 + fpbsState->uBitsReady;
   //travser through the BITSTREAM_INFO to find the next PACKET.
   //update pNewMB and pNewGOB if succeed, return Ok otherwise return error
   pBsInfo=(T_RTP_H263_BSINFO*)DC->pBsInfo;
   for ( u=0; u<DC->uNumOfPackets;u++)
   {
	 if (!(pBsInfo->uFlags & RTP_H26X_PACKET_LOST))
	 {
	   if (uBitOffset < pBsInfo->uBitOffset) break;
	 }
	 pBsInfo++;
   }
   //find it?
   if (u<DC->uNumOfPackets) //find next packet
   {
    if (pBsInfo->u8Mode == RTP_H263_MODE_A) 
    {	//adjust bit stream pointer according to received packet
		fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;
			   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

		iret = NEXT_MODE_A;

    }
	else //read Quant, GOB, MBA, MVs, from Payload Header
	{  
	   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;
	   //update the bit pointer and offset 
	   	fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;

		//recovery MVs depending on AP, 
		MVs[0] = pBsInfo->i8HMV1;
		MVs[1] = pBsInfo->i8VMV1;
		MVs[2] = pBsInfo->i8HMV2;
		MVs[3] = pBsInfo->i8VMV2;

		iret = pBsInfo->u8Mode == RTP_H263_MODE_B ? NEXT_MODE_B :
                                                    NEXT_MODE_C;
	   //file MV indexed by fpBlockAction,
	}

   }
   else // no more valid packet in this frame
   {	// need to set all the rest of MB to be not coded
	   iret = NEXT_MODE_LAST;
   }
done:
//#endif
   return iret;
}

/*
 * Use the extended bitstream to get the information lost
 * in the picture header
 */

I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * DC)
{I32 iret = ICERR_OK;
//#ifdef LOSS_RECOVERY
 T_H263_RTP_BSINFO_TRAILER *pTrailer;

 if (!DC->iVerifiedBsExt)
 {
  H263RTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);
 }

 if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
 }
 pTrailer = ( T_H263_RTP_BSINFO_TRAILER *)DC->pBsTrailer;
 //update DC info for Pict header.Src, INTRA, TR, etc.
 DC->uTempRef   = pTrailer->u8TR;
 DC->uSrcFormat = pTrailer->u8Src;
 DC->bFreezeRelease = 0;
 DC->bCameraOn = 0;
 DC->bSplitScreen = 0;
 DC->bKeyFrame = (U16) (pTrailer->uFlags & RTP_H26X_INTRA_CODED) ;//(U16) !uResult;
 //DC->bUnrestrictedMotionVectors = pTrailer->uFlags & ;
 DC->bArithmeticCoding = (U16)(pTrailer->uFlags & RTP_H263_SAC);
 DC->bAdvancedPrediction = (U16)(pTrailer->uFlags & RTP_H263_AP);
 DC->bPBFrame = (U16)(pTrailer->uFlags & RTP_H263_PB);
 //Mode C reovery PB related header info.
 // to be added for TRB,u8DBQ,
 DC->uBFrameTempRef=(U32)pTrailer->u8TRB;	 
 DC->uDBQuant      =(U32)pTrailer->u8DBQ;

done:
//#endif
return iret;
}

/*
 * MVAdjustment(pBlackAction, iBlock, old_g, old_m, new_g, new_m)
 * reuse the motion vector from the GOB above, when current is lost
 * EXPERIMENTAL
 */
void MVAdjustment(
T_BlkAction  *fpBlockAction,
int iBlockNum, //block number
int iOld_gob,
int iOld_mb,
int iNew_gob,
int iNew_mb,
const int iNumberOfMBs
)
{ int i,j;
  T_BlkAction *pBA=fpBlockAction;
  int iAbove = -6 * iNumberOfMBs;

  for (i=iOld_gob*iNumberOfMBs+iOld_mb;i<iNew_gob*iNumberOfMBs+iNew_mb; i++,pBA += 6)
  {
   if ((i+iAbove) >= 0) 
	 for (j=0;j<6;j++)
     {   pBA[i+j].i8MVx2 = pBA[iAbove+i+j].i8MVx2;
	     pBA[i+j].i8MVy2 = pBA[iAbove+i+j].i8MVy2;
     }
  }
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3pict.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/


/*****************************************************************************
 * 
 *  d3pict.h
 *
 *  Description:
 *		Interface to the picture header reader
 */

/*
 * $Header:   S:\h26x\src\dec\d3pict.h_v   1.3   27 Dec 1995 14:36:16   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\d3pict.h_v  $
;// 
;//    Rev 1.3   27 Dec 1995 14:36:16   RMCKENZX
;// Added copyright notice
 */

#ifndef __D3PICT_H__
#define __D3PICT_H__

extern I32 H263DecodePictureHeader(T_H263DecoderCatalog FAR * DC, 
								   U8 FAR * fpu8, 
								   U32 uBitsReady,
								   U32 uWork, 
								   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3mvdec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   CZHU  $
// $Date:   06 Feb 1997 15:35:30  $
// $Archive:   S:\h26x\src\dec\d3mvdec.cpv  $
// $Header:   S:\h26x\src\dec\d3mvdec.cpv   1.47   06 Feb 1997 15:35:30   CZHU  $
// $Log:   S:\h26x\src\dec\d3mvdec.cpv  $
// 
//    Rev 1.47   06 Feb 1997 15:35:30   CZHU
// Changed | to ||
// 
//    Rev 1.46   24 Jan 1997 13:32:56   CZHU
// 
// Added fix to check uBitsReady when return from DecodingMB header for 
// packet loss detection.
// 
//    Rev 1.45   19 Dec 1996 16:07:44   JMCVEIGH
// 
// Added initialization of forward-prediction-only flag if a block
// is not coded. This is used in H.263+ only.
// 
//    Rev 1.44   16 Dec 1996 17:44:00   JMCVEIGH
// Allow 8x8 motion vectors if deblocking filter selected and
// support for decoding of improved PB-frame MODB.
// 
//    Rev 1.43   20 Oct 1996 15:51:06   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.42   20 Oct 1996 13:21:20   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.41   11 Jul 1996 15:13:16   AGUPTA2
// Changed assertion failures into errors when decoder goes past end of 
// the bitstream.
// 
//    Rev 1.40   03 May 1996 13:05:34   CZHU
// 
// Check errors at MB header for packet faults and return PACKET_FAULT
// 
//    Rev 1.39   22 Mar 1996 17:25:18   AGUPTA2
// Changes to accomodate MMX rtns.
// 
//    Rev 1.38   08 Mar 1996 16:46:28   AGUPTA2
// Added pragmas code_seg and data_seg.  Changed the size of some of local data.
// 
// 
//    Rev 1.37   23 Feb 1996 09:46:56   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.36   17 Jan 1996 12:44:26   RMCKENZX
// Added support for decoding motion vectors for UMV
// Reorganized motion vector decoding processes, especially
// for AP and eliminating the large HALF_PEL conversion tables.
// 
//    Rev 1.35   02 Jan 1996 17:55:50   RMCKENZX
// 
// Updated copyright notice
// 
//    Rev 1.34   02 Jan 1996 15:48:54   RMCKENZX
// Added code to preserve the Block Type in the block action stream
// for P blocks when PB frames is on.  This is read in H263IDCTandMC
// when AP is on.
// 
//    Rev 1.33   18 Dec 1995 12:42:12   RMCKENZX
// added copyright notice
// 
//    Rev 1.32   13 Dec 1995 22:10:06   RHAZRA
// AP bug fix
// 
//    Rev 1.31   13 Dec 1995 22:01:26   TRGARDOS
// 
// Added more parentheses to a logical statement.
// 
//    Rev 1.30   13 Dec 1995 15:10:08   TRGARDOS
// Changed MV assert to be -32 <= MV <= 31, instead of strict
// inequalities.
// 
//    Rev 1.29   13 Dec 1995 10:59:58   RHAZRA
// 
// AP+PB changes
// 
//    Rev 1.28   11 Dec 1995 11:34:20   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.27   09 Dec 1995 17:28:38   RMCKENZX
// Gutted and re-built file to support decoder re-architecture.
// New modules are:
// H263ComputeMotionVectors
// H263DecodeMBHeader
// H263DecodeIDCTCoeffs
// This module now contains code to support the first pass of the decoder
// 
//    Rev 1.26   05 Dec 1995 09:12:28   CZHU
// Added fixes for proper MV prediction when GOB header is present
// 
//    Rev 1.25   22 Nov 1995 13:43:42   RMCKENZX
// 
// changed calls to utilize assembly modules for bi-directional
// motion compensation & removed corresponding C modules
// 
//    Rev 1.24   17 Nov 1995 12:58:22   RMCKENZX
// added missing ()s to adjusted_mvx & adjusted_mvy in H263BiMotionCompLuma
// 
//    Rev 1.23   07 Nov 1995 11:01:10   CZHU
// Include Fixes for boundary of bi-directional predictions
// 
//    Rev 1.22   26 Oct 1995 11:22:10   CZHU
// Compute backward MV based on TRD, not TR
// 
//    Rev 1.21   13 Oct 1995 16:06:22   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.20   13 Oct 1995 13:42:46   CZHU
// Added back the #define for debug messages.
// 
//    Rev 1.19   11 Oct 1995 17:51:00   CZHU
// 
// Fixed bugs in passing MV back with DC.
// 
//    Rev 1.18   11 Oct 1995 13:26:08   CZHU
// Added code to support PB frame
// 
//    Rev 1.17   09 Oct 1995 09:44:04   CZHU
// 
// Use the optimized version of (half,half) interpolation
// 
//    Rev 1.16   08 Oct 1995 13:45:10   CZHU
// 
// Optionally use C version of interpolation
// 
//    Rev 1.15   03 Oct 1995 15:05:26   CZHU
// Cleaning up.
// 
//    Rev 1.14   02 Oct 1995 09:58:56   TRGARDOS
// Added #ifdef to debug print statement.
// 
//    Rev 1.13   29 Sep 1995 16:22:06   CZHU
// 
// Fixed the bug in GOB 0 when compute MV2
// 
//    Rev 1.12   29 Sep 1995 09:02:56   CZHU
// Rearrange Chroma blocks processing
// 
//    Rev 1.11   28 Sep 1995 15:33:04   CZHU
// 
// Call the right version of interpolation based on MV
// 
//    Rev 1.10   27 Sep 1995 11:54:50   CZHU
// Integrated half pel motion compensation
// 
//    Rev 1.9   26 Sep 1995 15:33:06   CZHU
// 
// Put place holder in for half pel interpolation
// 
//    Rev 1.8   20 Sep 1995 14:47:50   CZHU
// Made the number of MBs in GOB a variableD
// 
//    Rev 1.7   19 Sep 1995 13:53:34   CZHU
// Added assertion for half-pel motion vectors
// 
//    Rev 1.6   18 Sep 1995 10:20:58   CZHU
// Scale the motion vectors for UV planes too. 
// 
//    Rev 1.5   14 Sep 1995 10:12:36   CZHU
// 
// Cleaning
// 
//    Rev 1.4   13 Sep 1995 11:56:30   CZHU
// Fixed bugs in finding the predictors for motion vector.
// 
//    Rev 1.3   12 Sep 1995 18:18:58   CZHU
// 
// Modified table for looking up UV MV's
// 
//    Rev 1.2   11 Sep 1995 16:41:14   CZHU
// Added reference block address calculation
// 
//    Rev 1.1   11 Sep 1995 14:31:30   CZHU
// Started to add function to calculate MVs and Reference block addresses.
// 
//    Rev 1.0   08 Sep 1995 11:45:56   CZHU
// Initial revision.

#include "precomp.h"

/* MCBPC table format
 *
 * layout     
 *
 *     unused   mbtype  cbpc  bits
 *     15-13   	12-10   9-8   7-0
 */
#pragma data_seg("IADATA1")

#define MCBPC_MBTYPE(d) ((d>>10) & 0x7)
#define MCBPC_CBPC(d) ((d>>8) & 0x3)
#define MCBPC_BITS(d) (d & 0xFF)
#define MCBPC_ENTRY(m,c,b) \
	( ((m & 0x7) <<10) | ((c & 0x3) << 8) | (b & 0xFF) )

U16 gNewTAB_MCBPC_INTRA[64] = {
	/* index 8 - stuffing */
	MCBPC_ENTRY(0,0,9),
	/* index 5 */ 
	MCBPC_ENTRY(4,1,6),
	/* index 6 */ 
	MCBPC_ENTRY(4,2,6),
	/* index 7 */ 
	MCBPC_ENTRY(4,3,6), 

	/* index 4; 0001XX */
	MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4),

	/* index 1; 001XXX */
	MCBPC_ENTRY(3,1,3), MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),
	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),

	/* index 2; 010XXX */
	MCBPC_ENTRY(3,2,3), MCBPC_ENTRY(3,2,3), MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),
	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),

	/* index 3; 011XXX */
	MCBPC_ENTRY(3,3,3), MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),
	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),

	/* index 0; 1XXXXX */
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1) 
};

/* MCBPC table for INTER frame
 *
 * Format same as MCBPC for INTRA
 * layout     
 *
 *     unused   mbtype  cbpc  bits
 *     15-13   	12-10   9-8   7-0 
 *
 */

U16 gNewTAB_MCBPC_INTER[512] = {
	/* invalid code */
	MCBPC_ENTRY(0,0,0),
	MCBPC_ENTRY(0,0,9), //index 20, stuffing
	MCBPC_ENTRY(4,3,9), //19,
	MCBPC_ENTRY(4,2,9), //18
	MCBPC_ENTRY(4,1,9), //17
	MCBPC_ENTRY(1,3,9), //7
	//2 index 14
	MCBPC_ENTRY(3,2,8),MCBPC_ENTRY(3,2,8), //14
	//2 index 13
	MCBPC_ENTRY(3,1,8),MCBPC_ENTRY(3,1,8), //13
	//2 index 11
	MCBPC_ENTRY(2,3,8),MCBPC_ENTRY(2,3,8), //11
	//4 index 15
	MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7), //15
	//4 index 10
	MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7), //10
	//4 index 9
	MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7), //9
	//4 index 6
	MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7), //6
	//4 index 5
	MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7), //5
	//8 index 16
	MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),//16
	MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),
	//8 index 3
	MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),//3
	MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),//3
	//16 index 12
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),//12
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	//32 INDEX 2
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),

	//32 index 1
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
 

	//64 index 8
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),

	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),



	//64 index 4
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),

	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),


	//256 index 0
	//0--63
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//64--127
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//128--128+64=192
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//192--255
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1)
};

/* CBPY table format
 *
 * layout     
 *
 *     intra  inter  bits
 *     15-12  11-8   7-0
 *
 * unused entries should have zero data
 */
#define CBPY_INTRA(d) ((d>>12) & 0xf)
#define CBPY_INTER(d) ((d>>8) & 0xf)
#define CBPY_BITS(d) (d & 0xff)
#define CBPY_ENTRY(a,r,b) \
	( ((a & 0xf) <<12) | ((r & 0xf) << 8) | (b & 0xFF) )
#define CBPY_NOT_USED() CBPY_ENTRY(0,0,0)

U16 gNewTAB_CBPY[64] = {
	/* NotUsed - 0000 0X */
	CBPY_NOT_USED(), CBPY_NOT_USED(),

	/* Index 6 - 0000 10 */
	CBPY_ENTRY(6,9,6),

	/* Index 9 - 0000 11 */
	CBPY_ENTRY(9,6,6),

	/* Index 8 - 0001 0x */
	CBPY_ENTRY(8,7,5), CBPY_ENTRY(8,7,5),

	/* Index 4 - 0001 1x */
	CBPY_ENTRY(4,11,5),	CBPY_ENTRY(4,11,5),

	/* Index 2 - 0010 0x */
	CBPY_ENTRY(2,13,5),	CBPY_ENTRY(2,13,5),

	/* Index 1 - 0010 1x */
	CBPY_ENTRY(1,14,5),	CBPY_ENTRY(1,14,5),

	/* Index 0 - 0011 xx */
	CBPY_ENTRY(0,15,4),	CBPY_ENTRY(0,15,4), CBPY_ENTRY(0,15,4), CBPY_ENTRY(0,15,4),

	/* Index 12- 0100 xx */
	CBPY_ENTRY(12,3,4),	CBPY_ENTRY(12,3,4), CBPY_ENTRY(12,3,4), CBPY_ENTRY(12,3,4),

	/* Index 10- 0101 xx */
	CBPY_ENTRY(10,5,4),	CBPY_ENTRY(10,5,4), CBPY_ENTRY(10,5,4), CBPY_ENTRY(10,5,4),

	/* Index 14- 0110 xx */
	CBPY_ENTRY(14,1,4),	CBPY_ENTRY(14,1,4), CBPY_ENTRY(14,1,4), CBPY_ENTRY(14,1,4),

	/* Index 5 - 0111 xx */
	CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4),

	/* Index 13- 1000 xx */
	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),

	/* Index 3 - 1001 xx */
	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),

	/* Index 11- 1010 xx */
	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),

	/* Index 7 - 1011 xx */
	CBPY_ENTRY(7,8,4),	CBPY_ENTRY(7,8,4), CBPY_ENTRY(7,8,4), CBPY_ENTRY(7,8,4),

	/* Index 15- 11xx xx */
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2)
};

I16 gNewTAB_DQUANT[4] = { -1, -2, 1, 2 };

#ifdef USE_MMX // { USE_MMX
T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block, MMX_VLD_RLD_IQ_Block};
#endif // } USE_MMX

#pragma data_seg(".data")
/*****************************************************************************
 *
 *  H263DecodeMBHeader
 *
 *  Decode the MB header
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBHeader(
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32                     **pN,
	T_MBInfo FAR * fpMBInfo)
{
	I32 iReturn = ICERR_ERROR;
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	U32 uResult;
	U32 uCode;
	U32 uBitCount;
	U32 uMBType;
	U32 bCoded;
	U32 bStuffing;
	U32 bGetCBPB;
	U32 bGetMVDB;
	U32 i;

	FX_ENTRY("H263DecodeMBHeader");

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	// COD -----------------------------------------------------
ReadCOD:
	if (! DC->bKeyFrame) 
	{
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		bCoded = !uResult; /* coded when bit is set to zero */
	} 
	else
		bCoded = 1;
	DC->bCoded = (U16) bCoded;

	if (!bCoded) 
	{
		/* when a block is not coded, "the remaining part of the macroblock
		 * layer is empty; in that case the decoder shall treat the macroblock
		 * as in INTER block with motion vector for the whole block equal to 
		 * zero and with no coefficient data" (5.3.1 p 16).
		 */
		DC->uMBType = 0;

		fpMBInfo->i8MBType = 0;       // AP-NEW

		DC->uCBPC = 0;
		DC->uCBPY = 0;

		/* Now update the pN array. Since the block is not coded, write 0
		 *  for all blocks in the macroblock.
		 */
		if (DC->bPBFrame) 
		{	 // 12 blocks for a PB frame
			fpMBInfo->i8MVDBx2 = fpMBInfo->i8MVDBy2 = 0;
			for (i=0; i<12; i++)
			{ // PB-NEW
				**pN = 0;
				(*pN)++;
			}
		}
		else 
		{  // only 6 blocks for non PB frame
			for (i=0; i<6; i++)
			{ // NEW
				**pN = 0;
				(*pN)++;
			}
		}

#ifdef H263P
		// If block is not coded, we use the original PB-frame method in Annex G.
		// In other words, use bidirectional prediction (not forward only)
		fpMBInfo->bForwardPredOnly = FALSE;		 
#endif

		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
		iReturn = ICERR_OK;
		goto done;
	}

	//  MCBPC ---------------------------------------------------
	bStuffing = 0;
	if (DC->bKeyFrame) 
	{
		GET_VARIABLE_BITS(6, fpu8, uWork, uBitsReady, uResult, 
						  uCode, uBitCount, gNewTAB_MCBPC_INTRA);
		if (uCode == 0) 
		{
			/* start of the stuffing code - read the next 3-bits
			*/
			GET_FIXED_BITS(3, fpu8, uWork, uBitsReady, uResult);
			if (uResult == 1)
				bStuffing = 1;
			else 
			{
				ERRORMESSAGE(("%s: Incorrect key frame stuffing bits!\r\n", _fx_));
				//#ifdef LOSS_RECOVERY
// Always True				if (uBitsReady <0) uBitsReady += 9;//trick and trap, do not change it without consulting Chad
				GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
				iReturn = PACKET_FAULT;
				//#else
				//			    iReturn = ICERR_ERROR;
				//#endif
				goto done;
			}
		}
	} 
	else 
	{
		//  Delta Frame
		//  mcpbc, VLD
		GET_VARIABLE_BITS(9, fpu8, uWork, uBitsReady, uResult, 
		uCode, uBitCount, gNewTAB_MCBPC_INTER);

		if (uCode == 1) 
			bStuffing = 1;
		//#ifdef LOSS_RECOVERY
		else if (uCode == 0)	   //catch the illegal code
		{
			ERRORMESSAGE(("%s: Incorrect stuffing bits!\r\n", _fx_));
// Always True			if (uBitsReady <0) uBitsReady += 9;//trick and trap, do not change it without consulting Chad
			GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
			iReturn = PACKET_FAULT;
			goto done;
		}
		//#endif

	}

	/*  When MCBPC==Stuffing, the remaining part of the macroblock layer is
	*  skipped and the macroblock number is not incremented (5.3.2 p18)"
	*  We support this by jumping to the start - to look for COD 
	*/
	if (bStuffing)
		goto ReadCOD;

	uMBType = MCBPC_MBTYPE(uResult);
	if (DC->bKeyFrame && (uMBType != 3 && uMBType != 4)) 
	{
		ERRORMESSAGE(("%s: Bad key frame MBType!\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	DC->uMBType = uMBType;

	fpMBInfo->i8MBType = (I8) uMBType;

	DC->uCBPC = MCBPC_CBPC(uResult);

	//  MODB ----------------------------------------------------
	bGetCBPB = 0;
	bGetMVDB = 0;

	if (DC->bPBFrame) 
    {
	    ASSERT( !DC->bKeyFrame);

#ifdef H263P
		// Default is to use original PB-frame method in Annex G.
		fpMBInfo->bForwardPredOnly = FALSE;		 

		if (DC->bImprovedPBFrames)
		{
			// See modified TABLE 8/H.263, Annex M, document LBC-96-358
			GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
			if (uResult)
			{
				// 1xx
				GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
				bGetCBPB = uResult;
				if (!uResult) 
					// 10x
					bGetMVDB = 1;
				else 
				{
					// 11x
					GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
					bGetMVDB = !uResult;
				}
			}
			if (bGetMVDB)
				// B-block is forward predicted (otherwise it is bidirectionally predicted)
				fpMBInfo->bForwardPredOnly = TRUE;		 
		}
		else 
#endif // H263P
		{
			GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
			bGetCBPB = uResult;			// see section 5.3.3 table 7/H.263
			if (bGetCBPB) 
			{
				bGetMVDB = 1;
				GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
				bGetCBPB = uResult;
			}
		}
	} 

	// CBPB ----------------------------------------------------
	DC->u8CBPB = 0;
	if (bGetCBPB) 
	{
		ASSERT(!DC->bKeyFrame);
		GET_FIXED_BITS(6, fpu8, uWork, uBitsReady, uResult);
		DC->u8CBPB = (U8)uResult;
	}

	// CBPY ----------------------------------------------------
	GET_VARIABLE_BITS(6, fpu8, uWork, uBitsReady, uResult, 
					  uCode, uBitCount, gNewTAB_CBPY);
	if (uResult == 0) 
	{
		ERRORMESSAGE(("%s:  Undefined CBPY variable code!\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
	if (DC->uMBType > 2)		//INTRA MB, not intra frame
		DC->uCBPY = CBPY_INTRA(uResult); 
	else
		DC->uCBPY = CBPY_INTER(uResult);

	// DQUANT --------------------------------------------------
	if (DC->uMBType == 1 || DC->uMBType == 4) 
	{
		GET_FIXED_BITS(2, fpu8, uWork, uBitsReady, uResult);
		DC->uDQuant = gNewTAB_DQUANT[uResult];
		DC->uGQuant += DC->uDQuant;
		DC->uPQuant =  DC->uGQuant;
	} else
		DC->uDQuant = 0;

	DEBUGMSG(ZONE_DECODE_MB_HEADER, ("  %s: MBType = %ld, MCBPC = 0x%lX, CBPY = 0x%lX, DQuant = 0x%lX\r\n", _fx_, DC->uMBType, DC->uCBPC, DC->uCBPY, DC->uDQuant));

	// MVD -----------------------------------------------------
	DC->i8MVDx2=DC->i8MVDy2=0;	 //Zero init it anyway.

	if ( DC->bPBFrame || DC->uMBType <= 2) 
	{
	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Undefined Motion Vector code!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVDx2 = (I8)(uResult>>8);

	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVDy2 = (I8)(uResult>>8);
	}

	// MVD 2-4 -------------------------------------------------
#ifdef H263P
	// In H.263+, 8x8 motion vectors are possible if the deblocking
	// filter is selected.
	if ((DC->bAdvancedPrediction || DC->bDeblockingFilter)
		&& (DC->uMBType == 2) ) 
#else
	if (DC->bAdvancedPrediction && (DC->uMBType == 2) ) 
#endif
	{
		DC->i8MVD2x2 = DC->i8MVD2y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD2x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD2y2 = (I8)(uResult>>8);

		DC->i8MVD3x2 = DC->i8MVD3y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD3x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD3y2 = (I8)(uResult>>8);

		DC->i8MVD4x2 = DC->i8MVD4y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD4x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD4y2 = (I8)(uResult>>8);

		DEBUGMSG(ZONE_DECODE_MB_HEADER, ("  %s: MVD2x2 = %d, MVD2y2 = %d, MVD3x2 = %d, MVD3y2 = %d, MVD4x2 = %d, MVD4y2 = %d\r\n", _fx_, DC->i8MVD2x2, DC->i8MVD2y2, DC->i8MVD3x2, DC->i8MVD3y2, DC->i8MVD4x2, DC->i8MVD4y2));
	}

	// MVDB ----------------------------------------------------
	DC->i8MVDBx2 = DC->i8MVDBy2 = 0;	 //Zero init it anyway.
	fpMBInfo->i8MVDBx2 = fpMBInfo->i8MVDBy2 = 0;
	if (bGetMVDB) 
	{
		ASSERT(DC->bPBFrame);
		ASSERT(!DC->bKeyFrame);
        GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector MVDB!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		fpMBInfo->i8MVDBx2 = DC->i8MVDBx2 = (I8)(uResult>>8);

	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector MVDB!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		fpMBInfo->i8MVDBy2 = DC->i8MVDBy2 = (I8)(uResult>>8);
	}

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeMBHeader() */
#pragma code_seg()


/*****************************************************************************
 *
 *  H263DecodeIDCTCoeffs
 *
 *  Decode each of the blocks in this macro block
 */
#pragma code_seg("IACODE1")
I32 H263DecodeIDCTCoeffs(
	T_H263DecoderCatalog FAR * DC,
	T_BlkAction FAR * fpBlockAction, 
	U32 uBlockNumber,
	BITSTREAM_STATE FAR * fpbsState,
	U8 FAR * fpu8MaxPtr,
	U32 **pN,                           // NEW
	T_IQ_INDEX **pRUN_INVERSE_Q)        // NEW
{
	I32 iResult = ICERR_ERROR;
	int iBlockPattern;
	int i;
	U8 u8PBlkType;
	U32 uBitsReady;
	U32 uBitsReadIn;
	U32 uBitsReadOut;
	U8  u8Quant;				// quantization level for this Mblock 
	U8 FAR * fpu8;
	U32 uByteCnt;
	T_BlkAction FAR * pActionStream;
#ifdef USE_MMX // { USE_MMX
    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD = pFunc_VLD_RLD_IQ_Block[DC->bMMXDecoder];
#else // }{ USE_MMX
    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD = VLD_RLD_IQ_Block;
#endif // } USE_MMX

	pActionStream = fpBlockAction;

	FX_ENTRY("H263DecodeIDCTCoeffs");

	/* On input the pointer points to the next byte.  We need to change it to 
	 * point to the current word on a 32-bit boundary.  
	 */

	fpu8 = fpbsState->fpu8 - 1;				/* point to the current byte */
	uBitsReady = fpbsState->uBitsReady;

	while (uBitsReady >= 8) 
	{
		fpu8--;
		uBitsReady -= 8;
	}

	uBitsReadIn = 8 - uBitsReady;
	u8Quant = (U8) (DC->uGQuant); 	

	if ( (DC->bPBFrame) || ((!DC->bKeyFrame) && (DC->uMBType <= 2))) 
	{
		// calculate motion vectors for the 6 blocks in this MB
		iResult = H263ComputeMotionVectors(DC, fpBlockAction);         // NEW

		if (iResult != ICERR_OK) 
		{ 
			ERRORMESSAGE(("%s: Error decoding MV!\r\n", _fx_));
			goto done;
		}

	} // endif PB or (inter and not key)

    // create block pattern from CBPY & CBPC
    iBlockPattern = ( (int) DC->uCBPY ) << 2;
    iBlockPattern |=  (int) DC->uCBPC;

	// Decode all 6 blocks up to, but not including, IDCT.
	for (i=0; i<6; i++) 
	{
		if (iBlockPattern & 0x20) 
		{
			if (DC->uMBType >= 3)  
				fpBlockAction->u8BlkType = BT_INTRA;
			else
				fpBlockAction->u8BlkType = BT_INTER;
		}
		else 
		{
			if (DC->uMBType >= 3)  
				fpBlockAction->u8BlkType = BT_INTRA_DC;
			else
				fpBlockAction->u8BlkType = BT_EMPTY;
		}

		if (fpBlockAction->u8BlkType != BT_EMPTY) 
		{
			fpBlockAction->u8Quant = u8Quant;
			ASSERT(fpBlockAction->pCurBlock != NULL);
			ASSERT(fpBlockAction->uBlkNumber == uBlockNumber);

			uBitsReadOut = (*pFunc_VLD)(
										fpBlockAction,
										fpu8,
										uBitsReadIn,
										(U32 *) *pN,
										(U32 *) *pRUN_INVERSE_Q);


			if (uBitsReadOut == 0) 
			{
				ERRORMESSAGE(("%s: Error decoding P block: VLD_RLD_IQ_Block return 0 bits read...\r\n", _fx_));
				goto done;
			}

			ASSERT( **pN < 65);		

			*pRUN_INVERSE_Q += **pN;                       // NEW
			if (fpBlockAction->u8BlkType != BT_INTER)      // NEW
				**pN += 65;								   // NEW
			(*pN)++;

			uByteCnt = uBitsReadOut >> 3; 		/* divide by 8 */
			uBitsReadIn = uBitsReadOut & 0x7; 	/* mod 8 */
			fpu8 += uByteCnt;      		

			//  allow the pointer to address up to four beyond the end - reading
			//  by DWORD using postincrement; otherwise we have bitstream error.
			if (fpu8 > fpu8MaxPtr+4)
				goto done;

			//  The test matrix includes the debug version of the driver.  The 
			//  following assertion creates a problem when testing with VideoPhone
			//  and so please do not check-in a version with the assertion 
			//  uncommented.
			// ASSERT(fpu8 <= fpu8MaxPtr+4);

		}
		else 
		{ // block type is empty 
			**pN = 0;	                // NEW
			(*pN)++;
		}

		fpBlockAction++;
		iBlockPattern <<= 1;
		uBlockNumber++;

	} // end for (i=0; i<6; i++)


	//--------------------------------------------------------------------
	//
	//      Now do the 6 B-blocks -- if needed
	//
	//--------------------------------------------------------------------
	if (DC->bPBFrame) 
	{ // we are doing PB frames
		fpBlockAction = pActionStream;    // recover the block action stream pointer
		uBlockNumber -= 6;
		iBlockPattern = (int) DC->u8CBPB; // block pattern
		u8Quant = (U8) ( DC->uPQuant * (5 + DC->uDBQuant) / 4 );
		if (u8Quant > 31) u8Quant = 31;
		if (u8Quant <  1) u8Quant =  1;

		// Decode all 6 blocks up to, but not including, IDCT.
		for (i=0; i<6; i++) 
		{
			// if the block is coded
            if (iBlockPattern & 0x20) {
				// preserve the block type of the P-frame block
				u8PBlkType = fpBlockAction->u8BlkType;

				fpBlockAction->u8BlkType = BT_INTER;
				fpBlockAction->u8Quant = u8Quant;

				ASSERT(fpBlockAction->pBBlock != NULL);
				ASSERT(fpBlockAction->uBlkNumber == uBlockNumber);

				uBitsReadOut = (*pFunc_VLD)(
											fpBlockAction,
											fpu8,
											uBitsReadIn,
											(U32 *) *pN,
											(U32 *) *pRUN_INVERSE_Q);

                if (uBitsReadOut == 0) {
					ERRORMESSAGE(("%s: Error decoding B block: VLD_RLD_IQ_Block return 0 bits read...\r\n", _fx_));
					goto done;
				}

				ASSERT( **pN < 65);			// no B-frame Intra blocks		
				*pRUN_INVERSE_Q += **pN;							// NEW
				(*pN)++;

				uByteCnt = uBitsReadOut >> 3; 		// divide by 8
				uBitsReadIn = uBitsReadOut & 0x7; 	// mod 8
				fpu8 += uByteCnt;      		

				// allow the pointer to address up to four beyond the 
				// end - reading  by DWORD using postincrement; otherwise we 
				// have bitstream error.
				if (fpu8 > fpu8MaxPtr+4)
					goto done;

				//  The test matrix includes the debug version of the driver.  
				//  The following assertion creates a problem when testing with
				// VideoPhone and so please do not check-in a version with the 
				// assertion uncommented.
				// ASSERT(fpu8 <= fpu8MaxPtr+4);

				// restore the block type of the P-frame block
				fpBlockAction->u8BlkType = u8PBlkType;

			}
			else 
			{ // block is not coded
				**pN = 0;	                // NEW
				(*pN)++;
			}  // end if block is coded ... else ...

			fpBlockAction++;
			iBlockPattern <<= 1;
			uBlockNumber++;

		} // end for (i=0; i<6; i++)

	}  // end if (DC->bPBFrame)


	/* restore the scanning pointers to point to the next byte and set the 
	 * uWork and uBitsReady values.
	 */

	while (uBitsReadIn > 8)
	{
		fpu8++;
		uBitsReadIn -= 8;
	}
	fpbsState->uBitsReady = 8 - uBitsReadIn;
	fpbsState->uWork = *fpu8++;	   /* store the data and point to next byte */
	fpbsState->uWork &= GetBitsMask[fpbsState->uBitsReady];
	fpbsState->fpu8 = fpu8; 

	iResult = ICERR_OK;

done:
	return iResult;

} /* END H263DecodeIDCTCoeffs() */
#pragma code_seg()

#pragma code_seg("IACODE1")
I32 H263ComputeMotionVectors(T_H263DecoderCatalog FAR * DC,
	                         T_BlkAction FAR * fpBlockAction)
	       
{ 
	I32 mvx1, mvy1, mvx2, mvy2, mvx3, mvy3;  //predictors
	// motion vector predictors for AP
	I32 mvxp[3], mvyp[3];
	// motion vector differences for AP
	I32 mvxd[4], mvyd[4];
	int iAbove;       // takes you up one GOB (-1 * # of blocks in a GOB)
	I32 iMBNum;
	I32 iMBOffset;
	I32  mvx, mvy, scratch;
	int i;
	I32 iNumberOfMBsPerGOB;	  //assume QCIF for Now
	BOOL bNoAbove, bNoRight, bUMV;

	const char QuarterPelRound[] = {0, 1, 0, 0};
    const char SixteenthPelRound[] = 
        {0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1};

	FX_ENTRY("H263ComputeMotionVectors");

	DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: MB# = %d, BlockNumber = %d, (MVDx2,MVDy2) = (%d, %d)\r\n", _fx_, fpBlockAction->uBlkNumber/6, fpBlockAction->uBlkNumber, DC->i8MVDx2, DC->i8MVDy2));

#ifdef _DEBUG
	if (DC->uMBType == 2)
	{
		DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: (MVD2x2,MVD2y2) = (%d, %d), (MVD3x2,MVD3y2) = (%d, %d), (MVD4x2,MVD4y2) = (%d, %d)\r\n", _fx_, DC->i8MVD2x2, DC->i8MVD2y2, DC->i8MVD3x2, DC->i8MVD3y2, DC->i8MVD4x2, DC->i8MVD4y2));
	}
#endif

	iNumberOfMBsPerGOB = DC->iNumberOfMBsPerGOB;
	iMBNum             = fpBlockAction->uBlkNumber / 6;
	iMBOffset          = iMBNum % iNumberOfMBsPerGOB;
	iAbove			 = -6 * iNumberOfMBsPerGOB;
	bNoAbove           = (DC->bGOBHeaderPresent) || (iMBNum < iNumberOfMBsPerGOB);
	bNoRight			 = iMBOffset == (iNumberOfMBsPerGOB - 1);
	bUMV 				 = DC->bUnrestrictedMotionVectors;

	if (DC->uMBType != 2) 
	{    // One motion vector per macroblock
		// when either a GOB header is present or
		// we are on the first GOB, only look to the left
		if ( bNoAbove ) 
		{
			// only one predictor
			if (iMBOffset == 0)							// when on the left edge,
				mvx2 = mvy2 = 0;							// use 0, else
			else 
			{
				mvx2 = fpBlockAction[-6 + 1].i8MVx2;		// use upper right corner
				mvy2 = fpBlockAction[-6 + 1].i8MVy2;		// of MB to the left
			}
		}

		// no GOB header and not the first GOB
		// need all three predictors
		else 
		{ 
			// left predictor
			if (iMBOffset == 0)							// when on the left edge, 
				mvx1 = mvy1 = 0;							// use 0, else
			else 
			{ 
				mvx1 = fpBlockAction[-6 + 1].i8MVx2;		// use upper right corner
				mvy1 = fpBlockAction[-6 + 1].i8MVy2;		// of MB to the left
			}

			// above predictor
			// use lower left corner 
			// of MB directly above
			mvx2 = fpBlockAction[iAbove + 2].i8MVx2;
			mvy2 = fpBlockAction[iAbove + 2].i8MVy2;

			// upper right predictor
			if ( bNoRight )	// when on the right edge
				mvx3 = mvy3 = 0;							// use 0
			else
			{	// else use lower left corner
				// of MB above & to the right
				mvx3 = fpBlockAction[iAbove + 8].i8MVx2;
				mvy3 = fpBlockAction[iAbove + 8].i8MVy2;
			}

			// select the medium value and place it in mvx2 & mvy2
			MEDIAN(mvx1, mvx2, mvx3, scratch);
			MEDIAN(mvy1, mvy2, mvy3, scratch);

		}  // end if (header or 1st GOB) ... else ...

		//  mvx2 and mvy2 have the medium predictors compute the motion vector 
		//  by adding in the difference
		mvx = DC->i8MVDx2 + mvx2;
		mvy = DC->i8MVDy2 + mvy2; 

		//  check for Unrestricted Motion Vector mode and adjust the motion 
		//  vector if necessary using the appropriate strategy, finishing
		//  the decoding process.
		if (bUMV) 
		{
			if (mvx2 > 32) 
			{
				if (mvx > 63) mvx -=64;
			}  
			else if (mvx2 < -31) 
			{
				if (mvx < -63) mvx +=64;
			}  

			if (mvy2 > 32) 
			{
				if (mvy > 63) mvy -=64;
			}  
			else if (mvy2 < -31) 
			{
				if (mvy < -63) mvy +=64;
			}
		}
		else 
		{  // UMV off
			if (mvx > 31)	  mvx -= 64;
			else if (mvx < -32)  mvx += 64;
			if (mvy > 31)  mvy -= 64;
			else if (mvy < -32) mvy += 64;
		}

		// save into the block action stream,
		// duplicating for the other 3 Y blocks.
		fpBlockAction[0].i8MVx2 = 
		fpBlockAction[1].i8MVx2 = 
		fpBlockAction[2].i8MVx2 = 
		fpBlockAction[3].i8MVx2 = (I8)mvx;

		fpBlockAction[0].i8MVy2 =
		fpBlockAction[1].i8MVy2 = 
		fpBlockAction[2].i8MVy2 = 
		fpBlockAction[3].i8MVy2 = (I8)mvy;


		// Chroma motion vectors
		// divide by 2 and round according to spec
		fpBlockAction[4].i8MVx2 = 
		fpBlockAction[5].i8MVx2 = 
		(mvx >> 1) + QuarterPelRound[mvx & 0x03];
		fpBlockAction[4].i8MVy2 = 
		fpBlockAction[5].i8MVy2 =
		(mvy >> 1) + QuarterPelRound[mvy & 0x03];

	} // end one motion vector per macroblock
	else 
	{
		// fpBlockAction[iNext[i][j]] points to block #i's (j+1)th predictor
		int iNext[4][3] = {-5,2,8, 0,3,8, -3,0,1, 2,0,1};

		// adjust iNext pointers which need to point to the GOB above
		iNext[0][1] += iAbove;		// block 0, mv2 -- block 2 of above MB
		iNext[0][2] += iAbove;		// block 0, mv3	-- block 2 of above-right MB
		iNext[1][1] += iAbove;		// block 1, mv2 -- block 3 of above MB
		iNext[1][2] += iAbove;		// block 1, mv3	-- block 2 of above-right MB

		// fetch motion vector differences
		mvxd[0] = DC->i8MVDx2;
		mvyd[0] = DC->i8MVDy2;
		mvxd[1] = DC->i8MVD2x2;
		mvyd[1] = DC->i8MVD2y2;
		mvxd[2] = DC->i8MVD3x2;
		mvyd[2] = DC->i8MVD3y2;
		mvxd[3] = DC->i8MVD4x2;
		mvyd[3] = DC->i8MVD4y2;

		// loop on Lumina blocks in this MB
		for (i=0, mvx=0, mvy=0; i<4; i++) 
		{
			// get predictor 1
			if ( (i&1) || (iMBOffset) ) 
			{ // not on left edge
				mvxp[0] = fpBlockAction[iNext[i][0]].i8MVx2; 
				mvyp[0] = fpBlockAction[iNext[i][0]].i8MVy2;
			}
			else 
			{ // on left edge, zero the predictor
				mvxp[0] = mvyp[0] = 0;
			}

			// for predictors 2 and 3, check if we can 
			// look above and that we are on blocks 0 or 1
			if ( (bNoAbove) && (i < 2) ) 
			{
				// set predictor 2 equal to predictor 1
				mvxp[1] = mvxp[0]; 
				mvyp[1] = mvyp[0];

				if (bNoRight) 
				{
					// if on the right edge, zero predictor 3
					mvxp[2] = mvyp[2] = 0;
				}
				else 
				{ // else set predictor 3 equal to predictor 1
					mvxp[2] = mvxp[0]; 
					mvyp[2] = mvyp[0];
				} // end predictor 3

			}
			else 
			{ // okay to look up
				// get predictor 2
				mvxp[1] = fpBlockAction[iNext[i][1]].i8MVx2;
				mvyp[1] = fpBlockAction[iNext[i][1]].i8MVy2;

				// get predictor 3
                if ( (bNoRight) && (i < 2) ) { 
					// if on the right edge, zero predictor 3
					mvxp[2] = mvyp[2] = 0;
				}
				else 
				{ // else fetch it from the block action stream
					mvxp[2] = fpBlockAction[iNext[i][2]].i8MVx2;
					mvyp[2] = fpBlockAction[iNext[i][2]].i8MVy2;
				} // end predictor 3

			} // end predictors 2 & 3

			// got all of the candidate predictors now get the median
			// output in mv-p[1]
			MEDIAN( mvxp[0], mvxp[1], mvxp[2], scratch);
			MEDIAN( mvyp[0], mvyp[1], mvyp[2], scratch);

			// add in the difference,
			// put the freshly constructed motion vector in mv-p[0]
			// leaving the predictors in mv-p[1] for use if UMV is on.
			mvxp[0] = mvxp[1] + mvxd[i];
			mvyp[0] = mvyp[1] + mvyd[i]; 

			// check for Unrestricted Motion Vector mode
			// and, if necessary, adjust the motion vector according
			// to the appropriate decoding strategy, thereby
			// finishing the decoding process.
			if ( bUMV ) 
			{
				if (mvxp[1] > 32) 
				{
					if (mvxp[0] > 63) mvxp[0] -=64;
				}  
				else if (mvxp[1] < -31) 
				{
					if (mvxp[0] < -63) mvxp[0] +=64;
				}  

				if (mvyp[1] > 32) 
				{
					if (mvyp[0] > 63) mvyp[0] -=64;
				}  
				else if (mvyp[1] < -31) 
				{
					if (mvyp[0] < -63) mvyp[0] +=64;
				}
			}
			else 
			{  // UMV off
				if (mvxp[0] > 31)	  mvxp[0] -= 64;
				else if (mvxp[0] < -32)  mvxp[0] += 64;

				if (mvyp[0] > 31)  mvyp[0] -= 64;
				else if (mvyp[0] < -32) mvyp[0] += 64;
			}

			// finally store the result in the block action stream and
			// accumulate the sum of Lumina for the Chroma 
			mvx += (fpBlockAction[i].i8MVx2 = (I8)mvxp[0]);
			mvy += (fpBlockAction[i].i8MVy2 = (I8)mvyp[0]);

		} // end Lumina vectors

		// Compute the Chroma vectors
		// divide sum of Lumina by 8 and round according to spec
		fpBlockAction[4].i8MVx2 = 
		fpBlockAction[5].i8MVx2 = 
		(mvx >> 3) + SixteenthPelRound[mvx & 0x0f];
		fpBlockAction[4].i8MVy2 = 
		fpBlockAction[5].i8MVy2 = 
		(mvy >> 3) + SixteenthPelRound[mvy & 0x0f];

	} // end 4 motion vectors per macroblock


	DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: Motion vector = (%d, %d)\r\n", _fx_, fpBlockAction->i8MVx2, fpBlockAction->i8MVy2));

#ifdef _DEBUG
	if (DC->uMBType == 2)
	{
		for (int iVector = 1; iVector < 6; iVector++)
		{
			DEBUGMSG(
			    ZONE_DECODE_COMPUTE_MOTION_VECTORS, 
			    ("   %s: Motion vector %d = (%d, %d)\r\n", 
			        _fx_, iVector, fpBlockAction[iVector].i8MVx2, fpBlockAction[iVector].i8MVy2));
		}
	}
#endif

	return ICERR_OK;
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Header:   S:\h26x\src\dec\d3rtp.h_v   1.4   06 Nov 1996 16:27:40   gmlim  $
;// $Log:   S:\h26x\src\dec\d3rtp.h_v  $
;// 
;//    Rev 1.4   06 Nov 1996 16:27:40   gmlim
;// Removed H263ModeC.
;// 
;//    Rev 1.3   06 Nov 1996 15:17:16   CZHU
;// changed FindNextPacket interface to return MVs.
;// 
;//    Rev 1.2   03 Nov 1996 18:39:08   gmlim
;// Added NEXT_MODE_C.
;// 
;//    Rev 1.1   23 Jul 1996 11:22:42   CZHU
;// 
;// Added a MV recovery. Hursitic will be added in later.
;// 
;//    Rev 1.0   22 Apr 1996 16:44:06   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.7   10 Apr 1996 13:35:30   CZHU
;// 
;// Added subroutine to recover picture header information from extended bitstr
;// 
;//    Rev 1.6   29 Mar 1996 14:40:00   CZHU
;// 
;// cleaning 
;// 
;//    Rev 1.5   29 Mar 1996 13:39:00   CZHU
;// 
;// Moved bs verification to c3rtp.cpp
;// 
;//    Rev 1.4   28 Mar 1996 18:40:18   CZHU
;// Support packet loss recovery
;// 
;//    Rev 1.3   23 Feb 1996 16:21:26   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:01:56   CZHU
;// 
;// More clean up
;// 
;//    Rev 1.1   14 Feb 1996 15:00:20   CZHU
;// Added support Mode A and Mode B
;// 
;//    Rev 1.0   12 Feb 1996 17:05:58   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   11 Dec 1995 14:54:26   CZHU
;// Initial revision.

#ifndef _H263_D3RTP_H_
#define _H263_D3RTP_H_

const long PACKET_FAULT     = ICERR_CUSTOM -1;
const long NEXT_MODE_A      = ICERR_CUSTOM -2;
const long NEXT_MODE_B      = ICERR_CUSTOM -3;
const long NEXT_MODE_C      = ICERR_CUSTOM -4;
const long NEXT_MODE_LAST   = ICERR_CUSTOM -5;

extern  I32 RtpH263FindNextPacket( 
          T_H263DecoderCatalog FAR * , BITSTREAM_STATE FAR * , U32 **, U32 *, int *, int *,I8 *
	    );                      
extern I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * );
void MVAdjustment(T_BlkAction *,int ,int,  int ,int , int , const int );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3mblk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   JMCVEIGH  $
// $Date:   21 Jan 1997 08:53:16  $
// $Archive:   S:\h26x\src\dec\d3mblk.cpv  $
// $Header:   S:\h26x\src\dec\d3mblk.cpv   1.60   21 Jan 1997 08:53:16   JMCVEIGH  $
// $Log:   S:\h26x\src\dec\d3mblk.cpv  $
// 
//    Rev 1.60   21 Jan 1997 08:53:16   JMCVEIGH
// Before we calculated the interpolated index for MC prior to 
// clipping for UMV. We might then reference outside of the 16 pel
// wide padded border. Moved calculation of interp_index to after
// UMV clipping.
// 
//    Rev 1.59   16 Dec 1996 17:45:26   JMCVEIGH
// Proper motion vector decoding and prediction for forward prediction
// in B portion of improved PB-frame.
// 
//    Rev 1.58   09 Dec 1996 15:54:10   GMLIM
// 
// Added a debug message in H263BBlockPrediction() for the case where
// TR == TR_Prev.  Set iTRD = 256 to avoid divide by 0.
// 
//    Rev 1.57   27 Sep 1996 17:29:24   KLILLEVO
// 
// added clipping of extended motion vectors for MMX
// 
//    Rev 1.56   26 Sep 1996 13:56:52   KLILLEVO
// 
// fixed a totally bogus version of the extended motion vectors
// 
//    Rev 1.55   26 Sep 1996 11:32:16   KLILLEVO
// extended motion vectors now work for AP on the P54C chip
// 
//    Rev 1.54   25 Sep 1996 08:05:32   KLILLEVO
// initial extended motion vectors support 
// does not work for AP yet
// 
//    Rev 1.53   09 Jul 1996 16:46:00   AGUPTA2
// MMX code now clears DC value for INTRA blocks and adds it back during
// ClipANdMove; this is to solve overflow problem.
// 
//    Rev 1.52   29 May 1996 10:18:36   AGUPTA2
// MMX need not be defd to use MMX decoder.
// 
//    Rev 1.51   04 Apr 1996 11:06:16   AGUPTA2
// Added calls to MMX_BlockCopy().
// 
//    Rev 1.50   01 Apr 1996 13:05:28   RMCKENZX
// Added MMx functionality for Advance Prediction and PB Frames.
// 
//    Rev 1.49   22 Mar 1996 17:50:30   AGUPTA2
// MMX support.  MMX support is included only if MMX defined. MMX is
// not defined by default so that we do not impact IA code size.
// 
//    Rev 1.48   08 Mar 1996 16:46:22   AGUPTA2
// Added pragmas code_seg and data_seg to place code and data in appropriate 
// segments.  Created a function table of interpolation rtns.; interpolation
// rtns. are now called thru this function table.  Commented out the clipping of
// MV code.  It is not needed now and it needs to be re-written to be more
// efficient.
// 
// 
//    Rev 1.47   23 Feb 1996 09:46:54   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.46   29 Jan 1996 17:50:48   RMCKENZX
// Reorganized logic in H263IDCTandMC for AP, optimizing the changes 
// made for revision 1.42 and simplifying logic for determining iNext[i].
// Also corrected omission for UMV decoding in H263BBlockPrediction.
// 
//    Rev 1.0   29 Jan 1996 12:44:00   RMCKENZX
// Initial revision.
// 
//    Rev 1.45   24 Jan 1996 13:22:06   BNICKERS
// Turn OBMC back on.
// 
//    Rev 1.44   16 Jan 1996 11:46:22   RMCKENZX
// Added support for UMV -- to correctly decode B-block
// motion vectors when UMV is on
// 
//    Rev 1.43   15 Jan 1996 14:34:32   BNICKERS
// 
// Temporarily turn off OBMC until encoder can be changed to do it too.
// 
//    Rev 1.42   12 Jan 1996 16:29:48   BNICKERS
// 
// Correct OBMC to be spec compliant when neighbor is Intra coded.
// 
//    Rev 1.41   06 Jan 1996 18:36:58   RMCKENZX
// Simplified rounding logic for chroma motion vector computation
// using MUCH smaller tables (at the cost of a shift, add, and mask
// per vector).
// 
//    Rev 1.40   05 Jan 1996 15:59:12   RMCKENZX
// 
// fixed bug in decoding forward b-frame motion vectors
// so that they will stay within the legal ranges.
// re-organized the BBlockPredict function - using only
// one test for 4 motion vectors and a unified call to
// do the backward prediction for both lumina and chroma blocks.
// 
//    Rev 1.39   21 Dec 1995 17:05:24   TRGARDOS
// Added comments about descrepancy with H.263 spec.
// 
//    Rev 1.38   21 Dec 1995 13:24:28   RMCKENZX
// Fixed bug on pRefL, re-architected IDCTandMC 
// 
//    Rev 1.37   18 Dec 1995 12:46:34   RMCKENZX
// added copyright notice
// 
//    Rev 1.36   16 Dec 1995 20:34:04   RHAZRA
// 
// Changed declaration of pRefX to U32
// 
//    Rev 1.35   15 Dec 1995 13:53:32   RHAZRA
// 
// AP cleanup
// 
//    Rev 1.34   15 Dec 1995 10:51:38   RHAZRA
// 
// Changed reference block addresses in AP
// 
//    Rev 1.33   14 Dec 1995 17:04:16   RHAZRA
// 
// Cleanup in the if-then-else structure in the OBMC part
// 
//    Rev 1.32   13 Dec 1995 22:11:56   RHAZRA
// AP cleanup
// 
//    Rev 1.31   13 Dec 1995 10:59:26   RHAZRA
// More AP+PB fixes
// 
//    Rev 1.29   11 Dec 1995 11:33:12   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.28   09 Dec 1995 17:31:22   RMCKENZX
// Gutted and re-built file to support decoder re-architecture.
// New modules are:
// H263IDCTandMC
// H263BFrameIDCTandBiMC
// H263BBlockPrediction
// This module now contains code to support the second pass of the decoder.
// 
//    Rev 1.27   23 Oct 1995 13:28:42   CZHU
// Use the right quant for B blocks and call BlockAdd for type 3/4 too
// 
//    Rev 1.26   17 Oct 1995 17:18:24   CZHU
// Fixed the bug in decoding PB block CBPC 
// 
//    Rev 1.25   13 Oct 1995 16:06:20   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.24   11 Oct 1995 17:46:28   CZHU
// Fixed bitstream bugs
// 
//    Rev 1.23   11 Oct 1995 13:26:00   CZHU
// Added code to support PB frame
// 
//    Rev 1.22   27 Sep 1995 16:24:14   TRGARDOS
// 
// Added debug print statements.
// 
//    Rev 1.21   26 Sep 1995 15:33:52   CZHU
// 
// Adjusted buffers used for MB for inter frame motion compensation
// 
//    Rev 1.20   19 Sep 1995 10:37:04   CZHU
// 
// Cleaning up
// 
//    Rev 1.19   15 Sep 1995 09:39:34   CZHU
// 
// Update both GOB Quant and Picture Quant after DQUANT
// 
//    Rev 1.18   14 Sep 1995 10:11:48   CZHU
// Fixed bugs updating Quant for the picture
// 
//    Rev 1.17   13 Sep 1995 11:57:08   CZHU
// 
// Fixed bugs in calling Chroma BlockAdd parameters.
// 
//    Rev 1.16   12 Sep 1995 18:18:40   CZHU
// Call BlockAdd finally.
// 
//    Rev 1.15   12 Sep 1995 11:12:38   CZHU
// Call blockCopy for MB that is not coded.
// 
//    Rev 1.14   11 Sep 1995 16:43:26   CZHU
// Changed interface to DecodeBlock. Added interface calls to BlockCopy and Bl
// 
//    Rev 1.13   11 Sep 1995 14:30:12   CZHU
// MVs decoding.
// 
//    Rev 1.12   08 Sep 1995 11:48:12   CZHU
// Added support for Delta frames, also fixed early bugs regarding INTER CBPY
// 
//    Rev 1.11   25 Aug 1995 09:16:32   DBRUCKS
// add ifdef DEBUG_MBLK
// 
//    Rev 1.10   23 Aug 1995 19:12:02   AKASAI
// Fixed gNewTAB_CBPY table building.  Was using 8 as mask instead of 0xf.
// 
//    Rev 1.9   18 Aug 1995 15:03:22   CZHU
// 
// Output more error message when DecodeBlock returns error.
// 
//    Rev 1.8   16 Aug 1995 14:26:54   CZHU
// 
// Changed DWORD adjustment back to byte oriented reading.
// 
//    Rev 1.7   15 Aug 1995 09:54:18   DBRUCKS
// improve stuffing handling and add debug msg
// 
//    Rev 1.6   14 Aug 1995 18:00:40   DBRUCKS
// add chroma parsing
// 
//    Rev 1.5   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.4   11 Aug 1995 16:12:28   DBRUCKS
// add ptr check to MB data
// 
//    Rev 1.3   11 Aug 1995 15:10:58   DBRUCKS
// finish INTRA mb header parsing and callblock
// 
//    Rev 1.2   03 Aug 1995 14:30:26   CZHU
// Take block level operations out to d3block.cpp
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 
//    Rev 1.0   31 Jul 1995 13:00:08   DBRUCKS
// Initial revision.
// 
//    Rev 1.2   31 Jul 1995 11:45:42   CZHU
// changed the parameter list
// 
//    Rev 1.1   28 Jul 1995 16:25:52   CZHU
// 
// Added per block decoding framework.
// 
//    Rev 1.0   28 Jul 1995 15:20:16   CZHU
// Initial revision.

//Block level decoding for H.26x decoder

#include "precomp.h"

extern "C" {
    void H263BiMotionComp(U32, U32, I32, I32, I32);
    void H263OBMC(U32, U32, U32, U32, U32, U32);
}

#ifdef USE_MMX // { USE_MMX
extern "C" {
	void MMX_AdvancePredict(T_BlkAction FAR *, int *, U8 *, I8 *, I8 *);
	void MMX_BiMotionComp(U32, U32, I32, I32, I32);
}
#endif // } USE_MMX

void AdvancePredict(T_BlkAction FAR *fpBlockAction, int *iNext, U8 *pDst, int, int, BOOL);

#pragma data_seg("IARDATA2")
char QuarterPelRound[] =
    {0, 1, 0, 0};
char SixteenthPelRound[] =
    {0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1};
void (*Interpolate_Table[4])(U32, U32) = 
    {NULL, 
     Interpolate_Half_Int, 
     Interpolate_Int_Half, 
     Interpolate_Half_Half};
#ifdef USE_MMX // { USE_MMX
void (_fastcall *  MMX_Interpolate_Table[4])(U32, U32) = 
    {NULL, 
     MMX_Interpolate_Half_Int, 
     MMX_Interpolate_Int_Half, 
     MMX_Interpolate_Half_Half};
#endif // } USE_MMX

I8 i8EMVClipTbl_NoClip[128] = {
-64,-63,-62,-61,-60,-59,-58,-57,
-56,-55,-54,-53,-52,-51,-50,-49,
-48,-47,-46,-45,-44,-43,-42,-41,
-40,-39,-38,-37,-36,-35,-34,-33,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39,
 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55,
 56, 57, 58, 59, 60, 61, 62, 63,
}; 
I8 i8EMVClipTbl_HiClip[128] = {
-64,-63,-62,-61,-60,-59,-58,-57,
-56,-55,-54,-53,-52,-51,-50,-49,
-48,-47,-46,-45,-44,-43,-42,-41,
-40,-39,-38,-37,-36,-35,-34,-33,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
};
I8 i8EMVClipTbl_LoClip[128] = {
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39,
 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55,
 56, 57, 58, 59, 60, 61, 62, 63,
};

#pragma data_seg(".data")

#pragma code_seg("IACODE2")
// doing this as a function instead of a macro should save
// some codespace.
void UmvOnEdgeClipMotionVectors2(I32 *mvx, I32 *mvy, int EdgeFlag, int BlockNo) 
{   
	int MaxVec;

	if (BlockNo < 4)
		MaxVec = 32;
	else 
		MaxVec = 16;

	if (EdgeFlag & LEFT_EDGE)  
	{
		if (*mvx < -MaxVec) 
			*mvx = -MaxVec; 
	}
	if (EdgeFlag & RIGHT_EDGE) 
	{
		if (*mvx > MaxVec ) 
			*mvx = MaxVec ;
	}
	if (EdgeFlag & TOP_EDGE) 
	{
		if (*mvy < -MaxVec )
			*mvy = -MaxVec ; 
	}
	if (EdgeFlag & BOTTOM_EDGE)
	{
		if (*mvy > MaxVec )
			*mvy = MaxVec ;
	}
}
#pragma code_seg()

/*****************************************************************************
 *
 *  H263IDCTandMC
 *
 *  Inverse Discrete Cosine Transform and
 *  Motion Compensation for each block
 *
 */

#pragma code_seg("IACODE2")
void H263IDCTandMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    int                       iMBNum,     // AP-NEW
    int                       iGOBNum, // AP-NEW
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    T_MBInfo                 *fpMBInfo,      // AP-NEW
    int                       iEdgeFlag
)
{
    I32 pRef;
    int iNext[4];            // Left-Right-Above-Below
    I32 mvx, mvy;
    U32 pRefTmp;
    int i;

    ASSERT(*pN != 65);
    
    if (*pN < 65) // Inter block
    {
		int interp_index;

		// first do motion compensation
		// result will be pointed to by pRef

		pRef = (U32) DC + DC->uMBBuffer;
		mvx = fpBlockAction[iBlock].i8MVx2;
		mvy = fpBlockAction[iBlock].i8MVy2;

		// Clip motion vectors pointing outside active image area
		if (DC->bUnrestrictedMotionVectors)  
		{
			UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
		}

		pRefTmp = fpBlockAction[iBlock].pRefBlock +
				(I32) (mvx >> 1) +
				PITCH * (I32) (mvy >> 1); 

		// Must calculate AFTER UMV clipping
		interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);

		// Do non-OBMC prediction if this is a chroma block OR
		// a luma block in non-AP mode of operation
		if ( (!DC->bAdvancedPrediction) || (iBlock > 3) )
		{
			if (interp_index)
			{
			//  TODO
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
				(*MMX_Interpolate_Table[interp_index])(pRefTmp, pRef);
			else
				(*Interpolate_Table[interp_index])(pRefTmp, pRef);
#else // }{ USE_MMX
				(*Interpolate_Table[interp_index])(pRefTmp, pRef);
#endif // } USE_MMX
			}
			else
				pRef = pRefTmp;
		}
		else  // Overlapped block motion compensation
		{
      
			ASSERT (DC->bAdvancedPrediction);
			ASSERT ( (iBlock <= 3) );

			//  Compute iNext[i] which will point at the adjacent blocks.

			// Left & Right blocks
			if (iBlock & 1)    { // blocks 1 or 3, on right
				iNext[0] = -1;
				if ( iMBNum == DC->iNumberOfMBsPerGOB )
					iNext[1] = 0;
				else
					iNext[1] = 5;
			}
			else { // blocks 0 or 2, on left
				iNext[1] = 1;
				if (iMBNum == 1)
					iNext[0] = 0;
				else
					iNext[0] = -5;
			}

			// Above & Below blocks
			if (iBlock > 1)    { // blocks 2 or 3, on bottom
				iNext[2] = -2;
				iNext[3] = 0;
			}
			else { // blocks 0 or 1, on top
				iNext[3] = 2;
				if (iGOBNum == 1)
					iNext[2] = 0;
				else
					iNext[2] = -6*DC->iNumberOfMBsPerGOB + 2;
			}

			//  When PB frames are OFF
			//    if there is a neighbor and it is INTRA, use this block's vector instead.
			if (!DC->bPBFrame) 
				for (i=0; i<4; i++)
					// block types:  0=INTRA_DC, 1=INTRA, 2=INTER, 3=EMPTY, 4=ERROR
					if (iNext[i] && fpBlockAction[iBlock+iNext[i]].u8BlkType < 2) 
						iNext[i] = 0;
      
			// Now do overlapped motion compensation; output to pRef
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
			{

				I8 *pClipX, *pClipY;

				pClipY = pClipX = &i8EMVClipTbl_NoClip[0];
				if (DC->bUnrestrictedMotionVectors)
				{
					if (iEdgeFlag & TOP_EDGE)
						pClipY = &i8EMVClipTbl_LoClip[0];
					else if (iEdgeFlag & BOTTOM_EDGE)
						pClipY = &i8EMVClipTbl_HiClip[0];
					if (iEdgeFlag & LEFT_EDGE)
						pClipX = &i8EMVClipTbl_LoClip[0];
					else if (iEdgeFlag & RIGHT_EDGE)
						pClipX = &i8EMVClipTbl_HiClip[0];
				}
				MMX_AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, pClipX, pClipY);
			}
			else
				AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, iEdgeFlag, iBlock, DC->bUnrestrictedMotionVectors);
#else // }{ USE_MMX
				AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, iEdgeFlag, iBlock, DC->bUnrestrictedMotionVectors);
#endif // } USE_MMX

		} // end OBMC
                                                         
		// now do the inverse transform (where appropriate) & combine
		if (*pN > 0) // and, of course, < 65.
		{
		// Get residual block; output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
		// Finally add the residual to the reference block
		//  TODO
#ifdef USE_MMX // { USE_MMX
		if (DC->bMMXDecoder)
		{
			MMX_DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter  output
			MMX_BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // output
				pRef,                                            // prediction
				fpBlockAction[iBlock].pCurBlock);                // destination
		}
		else
		{
			DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				fpBlockAction[iBlock].pCurBlock,                // not used here
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output
			BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
				pRef,                                           // prediction
				fpBlockAction[iBlock].pCurBlock);               // destination
		}
#else // }{ USE_MMX
			DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				fpBlockAction[iBlock].pCurBlock,                // not used here
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output
			BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
				pRef,                                           // prediction
				fpBlockAction[iBlock].pCurBlock);               // destination
#endif // } USE_MMX
		}
		else  // *pN == 0, so no transform coefficients for this block
		{
		// Just copy motion compensated reference block
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
				MMX_BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                    // destination 
					pRef);                                              // prediction
			else
				BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                   // destination
					pRef);                                             // prediction
#else // }{ USE_MMX
				BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                   // destination
					pRef);                                             // prediction
#endif // } USE_MMX
		}
                                                               
    }
    else  // *pN >= 65, hence intRA
    {
      //  TODO
#ifdef USE_MMX // { USE_MMX
      if (DC->bMMXDecoder)
      {
        U32 ScaledDC = pRUN_INVERSE_Q->dInverseQuant;
       
        pRUN_INVERSE_Q->dInverseQuant = 0;
        MMX_DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q,  //
            *pN - 65,             //  No. of coeffs
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
        MMX_ClipAndMove((U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,
            fpBlockAction[iBlock].pCurBlock, (U32)ScaledDC);
      }
      else
        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // INTRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
#else // }{ USE_MMX
        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // INTRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
#endif // } USE_MMX
    }  // end if (*pN < 65) ... else ...
                         
}
//  End IDCTandMC
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()


/*****************************************************************************
 *
 *  AdvancePredict
 *
 *  Motion Compensation for Advance Prediction
 *    This module is only called in the non-MMx case.
 *    In the MMx case, MMX_AdvancePredict is called instead.
 *
 ****************************************************************************/

#pragma code_seg("IACODE2")
void AdvancePredict(
    T_BlkAction FAR          *fpBlockAction, 
    int                      *iNext,
    U8                       *pDst,
	int                      iEdgeFlag,
	int                      iBlock,
	BOOL                     bUnrestrictedMotionVectors
)
{

    U32 pRefC, pRefN[4];    // Left-Right-Above-Below
    I32 mvx, mvy;
    U32 pRefTmp;
    int i;
	int interp_index;
    
	mvx = fpBlockAction->i8MVx2;
	mvy = fpBlockAction->i8MVy2;

	// Clip motion vectors pointing outside active image area
	if (bUnrestrictedMotionVectors)  
	{
		UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
	}     

	interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);

	pRefTmp = fpBlockAction->pRefBlock +
	        (I32) (mvx >> 1) +
	        PITCH * (I32) (mvy >> 1); 

	pRefC    = (U32) pDst +  8;
	pRefN[0] = (U32) pDst + 16;
	pRefN[1] = (U32) pDst + 24;
	pRefN[2] = (U32) pDst + 32;
	pRefN[3] = (U32) pDst + 40;

	// Current block
	if (interp_index)
		(*Interpolate_Table[interp_index])(pRefTmp, pRefC);
	else
		pRefC = pRefTmp;
      
        //  Compute and apply motion vectors
        //  Prediction is placed at pRefN[i]
        for (i=0; i<4; i++) {

			if (iNext[i]) {

				// Get the motion vector components.
				// Note that for macroblocks that were not coded, THESE MUST BE 0!
				// (Which is what H263InitializeBlockActionStream sets them to.)
				mvx = fpBlockAction[iNext[i]].i8MVx2;
				mvy = fpBlockAction[iNext[i]].i8MVy2;
              
				// Clip motion vectors pointing outside active image area
				if (bUnrestrictedMotionVectors)  
				{
					UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
				}     
  
	            // apply motion vector to get reference block at pRefN[i]
	            pRefTmp = fpBlockAction->pRefBlock +
	                        (I32) (mvx >> 1) +
	                        PITCH * (I32) (mvy >> 1);
                         
				// do interpolation if needed
				interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);
				if (interp_index)
					(*Interpolate_Table[interp_index])(pRefTmp, pRefN[i]);
				else
					pRefN[i] = pRefTmp;

			}  // end if (iNext[i])
			else { // use this block's reference
				pRefN[i] = pRefC;
			} // end if (iNext[i] && ...) ... else ...

		}  // end for (i=0; i<4; i++) {}
      
		// Now do overlapped motion compensation.
		H263OBMC(pRefC, pRefN[0], pRefN[1], pRefN[2], pRefN[3], (U32)pDst);
                         
}
//  End AdvancePredict
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()



/*****************************************************************************
 *
 *  BBlockPrediction
 *
 *  Compute the predictions from the "forward" and "backward" motion vectors.
 *
 ****************************************************************************/
#pragma code_seg("IACODE2")    
void H263BBlockPrediction(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction,
    U32                       pRef[],
    T_MBInfo FAR             *fpMBInfo,
    int                       iEdgeFlag
)
{
    //find out the MVf and MVb first from TR

  	I32 mv_f_x[6], mv_b_x[6], mv_f_y[6], mv_b_y[6];
    I32 mvx_expectation, mvy_expectation;
    I32 iTRD, iTRB;
    I32 i;
    U32 pRefTmp;

    int mvfx, mvbx, mvfy, mvby;

	FX_ENTRY("H263BBlockPrediction")

    iTRB = DC->uBFrameTempRef;
    iTRD = DC->uTempRef - DC->uTempRefPrev;

    if (!iTRD)
    {
		DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Warning: given TR == last TR, set TRD = 256\r\n", _fx_));
        iTRD = 256;
    }
    else
    if (iTRD < 0) 
        iTRD += 256;

    // final MVD for P blocks is in 
    //    fpBlockAction[0].i8MVx2,... and fpBlockAction[3].i8MVx2, and
    //    fpBlockAction[0].i8MVy2,... and fpBlockAction[3].i8MVy2.

    // check for 4 motion vectors per macroblock
    //  TODO can motion vector calculation be done in the first pass
    if (fpMBInfo->i8MBType == 2) 
    {  // yep, we got 4 of 'em

#ifdef H263P
		// If H.263+, we can have 8x8 MV's if the deblocking filter 
		// was selected.
        ASSERT(DC->bAdvancedPrediction || DC->bDeblockingFilter);
#else
        ASSERT(DC->bAdvancedPrediction);
#endif

        // Do luma vectors first
        for (i=0; i<4; i++)
        {
#ifdef H263P
			// If we are using improved PB-frame mode (H.263+) and the B-block
			// was signalled to be predicted in the forward direction only,
			// the motion vector contained in MVDB is the actual forward MV -
			// no prediction is used.
			if (DC->bImprovedPBFrames == TRUE && 
				fpMBInfo->bForwardPredOnly == TRUE) 
			{
				// Zero-out the expectation (the motion vector prediction)
				mvx_expectation = 0;
				mvy_expectation = 0;
			} 
			else
#endif 
			{
				// compute forward expectation
				mvx_expectation = ( iTRB * (I32)fpBlockAction[i].i8MVx2 / iTRD ); 
				mvy_expectation = ( iTRB * (I32)fpBlockAction[i].i8MVy2 / iTRD );
			}
      
            // add in differential
            mv_f_x[i] = mvx_expectation + fpMBInfo->i8MVDBx2; 
            mv_f_y[i] = mvy_expectation + fpMBInfo->i8MVDBy2;

            // check to see if the differential carried us too far
            if (DC->bUnrestrictedMotionVectors) 
            {
                if (mvx_expectation > 32) 
                {
                    if (mv_f_x[i] > 63) mv_f_x[i] -=64;
                }  
                else if (mvx_expectation < -31) 
                {
                    if (mv_f_x[i] < -63) mv_f_x[i] +=64;
                } // always use "first column" when expectation lies in [-31, +32] 

                if (mvy_expectation > 32) 
                {
                    if (mv_f_y[i] > 63) mv_f_y[i] -=64;
                }  
                else if (mvy_expectation < -31) 
                {
                    if (mv_f_y[i] < -63) mv_f_y[i] +=64;
                }  
            }
            else  // UMV off
            {
                if (mv_f_x[i] >= 32) mv_f_x[i] -= 64;
                else if (mv_f_x[i] < -32) mv_f_x[i] += 64;

                if (mv_f_y[i] >= 32) mv_f_y[i] -= 64;
                else if (mv_f_y[i] < -32) mv_f_y[i] += 64;
            } // end if (UMV) ... else ...

            // Do backwards motion vectors
			// Backward vectors are not required if using improved PB-frame mode
			// and the B-block uses only forward prediction. We will keep the calculation
			// of mv_b_{x,y} here since it doesn't harm anything.
            //  TODO
            if (fpMBInfo->i8MVDBx2)
                mv_b_x[i] = mv_f_x[i] - fpBlockAction[i].i8MVx2;
            else
                mv_b_x[i] = ( (iTRB - iTRD) * (I32)fpBlockAction[i].i8MVx2 / iTRD );
            if (fpMBInfo->i8MVDBy2)
                mv_b_y[i] = mv_f_y[i] - fpBlockAction[i].i8MVy2;
            else
                mv_b_y[i] = ( (iTRB - iTRD) * (I32)fpBlockAction[i].i8MVy2 / iTRD );

        }  // end for(i=0; i<4; i++){}
      
        // Now do the chromas
        //   first get average times 4
        for (i=0, mvfx=mvbx=mvfy=mvby=0; i<4; i++) 
        {
            mvfx += mv_f_x[i];
            mvfy += mv_f_y[i];
            mvbx += mv_b_x[i];
            mvby += mv_b_y[i];
        }
   
        //   now interpolate
        mv_f_x[4] = mv_f_x[5] = (mvfx >> 3) + SixteenthPelRound[mvfx & 0x0f];
        mv_f_y[4] = mv_f_y[5] = (mvfy >> 3) + SixteenthPelRound[mvfy & 0x0f];
        mv_b_x[4] = mv_b_x[5] = (mvbx >> 3) + SixteenthPelRound[mvbx & 0x0f];
        mv_b_y[4] = mv_b_y[5] = (mvby >> 3) + SixteenthPelRound[mvby & 0x0f];
   
    }
    else  // only 1 motion vector for this macroblock
    {

#ifdef H263P
		// If we are using improved PB-frame mode (H.263+) and the B-block
		// was signalled to be predicted in the forward direction only,
		// the motion vector contained in MVDB is the actual forward MV -
		// no prediction is used.
		if (DC->bImprovedPBFrames == TRUE && 
			fpMBInfo->bForwardPredOnly == TRUE) 
		{
			// Zero-out the expectation (the motion vector prediction)
			mvx_expectation = 0;
			mvy_expectation = 0;
		} 
		else
#endif
		{
			// compute forward expectation
			mvx_expectation = ( iTRB * (I32)fpBlockAction[0].i8MVx2 / iTRD ); 
			mvy_expectation = ( iTRB * (I32)fpBlockAction[0].i8MVy2 / iTRD );
		}
      
        // add in differential
        mv_f_x[0] = mvx_expectation + fpMBInfo->i8MVDBx2; 
        mv_f_y[0] = mvy_expectation + fpMBInfo->i8MVDBy2;

        // check to see if the differential carried us too far
        // TODO: Clipping of motion vector needs to happen when decoder needs 
        //       to interoperate
        if (DC->bUnrestrictedMotionVectors) 
        {
            if (mvx_expectation > 32) 
            {
                if (mv_f_x[0] > 63) mv_f_x[0] -=64;
            }  
            else if (mvx_expectation < -31) 
            {
                if (mv_f_x[0] < -63) mv_f_x[0] +=64;
            } // always use "first column" when expectation lies in [-31, +32] 

            if (mvy_expectation > 32) 
            {
                if (mv_f_y[0] > 63) mv_f_y[0] -=64;
            }  
            else if (mvy_expectation < -31) 
            {
                if (mv_f_y[0] < -63) mv_f_y[0] +=64;
            }
        }
        else // UMV off, decode normally
        {
            if (mv_f_x[0] >= 32) mv_f_x[0] -= 64;
            else if (mv_f_x[0] < -32) mv_f_x[0] += 64;

            if (mv_f_y[0] >= 32) mv_f_y[0] -= 64;
            else if (mv_f_y[0] < -32) mv_f_y[0] += 64;
        } // finished decoding

        // copy for other 3 motion vectors
        mv_f_x[1] = mv_f_x[2] = mv_f_x[3] = mv_f_x[0];
        mv_f_y[1] = mv_f_y[2] = mv_f_y[3] = mv_f_y[0];

        // do backwards motion vectors
		// Backward vectors are not required if using improved PB-frame mode
		// and the B-block uses only forward prediction. We will keep the calculation
		// of mv_b_{x,y} here since it doesn't harm anything.
        // TODO
        if (fpMBInfo->i8MVDBx2)
            mv_b_x[0] = mv_f_x[0] - fpBlockAction[0].i8MVx2;
        else
            mv_b_x[0] = ( (iTRB - iTRD) * (I32)fpBlockAction[0].i8MVx2 / iTRD );

        if (fpMBInfo->i8MVDBy2)
            mv_b_y[0] = mv_f_y[0] - fpBlockAction[0].i8MVy2;
        else
            mv_b_y[0] = ( (iTRB - iTRD) * (I32)fpBlockAction[0].i8MVy2 / iTRD );

        // copy for other 3 motion vectors
        mv_b_x[1] = mv_b_x[2] = mv_b_x[3] = mv_b_x[0];
        mv_b_y[1] = mv_b_y[2] = mv_b_y[3] = mv_b_y[0];

        // interpolate for chroma
        mv_f_x[4] = mv_f_x[5] = (mv_f_x[0] >> 1) + QuarterPelRound[mv_f_x[0] & 0x03];
        mv_f_y[4] = mv_f_y[5] = (mv_f_y[0] >> 1) + QuarterPelRound[mv_f_y[0] & 0x03];
        mv_b_x[4] = mv_b_x[5] = (mv_b_x[0] >> 1) + QuarterPelRound[mv_b_x[0] & 0x03];
        mv_b_y[4] = mv_b_y[5] = (mv_b_y[0] >> 1) + QuarterPelRound[mv_b_y[0] & 0x03];

    }  // end else 1 motion vector per macroblock

    // Prediction from Previous decoder P frames, referenced by RefBlock
    // Note: The previous decoder P blocks in in RefBlock, and
    //       the just decoder P blocks are in CurBlock
    //       the target B blocks are in BBlock

    // translate MV into address of reference blocks.
    pRefTmp = (U32) DC + DC->uMBBuffer;
    for (i=0; i<6; i++) 
    {
        pRef[i] =  pRefTmp;
        pRefTmp += 8;
    }


    // Do the forward predictions
    for (i=0; i<6; i++)
    {
        int interp_index;
      
		// in UMV mode: clip MVs pointing outside 16 pels wide edge
		if (DC->bUnrestrictedMotionVectors) 
		{
			UmvOnEdgeClipMotionVectors2(&mv_f_x[i],&mv_f_y[i], iEdgeFlag, i);
			// no need to clip backward vectors
		}

        // Put forward predictions at addresses pRef[0], ..., pRef[5].
        pRefTmp = fpBlockAction[i].pRefBlock + (I32)(mv_f_x[i]>>1) +  
                  PITCH * (I32)(mv_f_y[i]>>1);
        // TODO
        interp_index = ((mv_f_y[i] & 0x1)<<1) | (mv_f_x[i] & 0x1);
        if (interp_index)
        {
#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
                (*MMX_Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
            else
                (*Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
#else // }{ USE_MMX
                (*Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
#endif // } USE_MMX
        }
        else
        {
#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
                MMX_BlockCopy(
                    pRef[i],     // destination 
                    pRefTmp);    // prediction
            else
                BlockCopy(pRef[i], pRefTmp);
#else // }{ USE_MMX
                BlockCopy(pRef[i], pRefTmp);
#endif // } USE_MMX
        }
        
#ifdef H263P
		// If we are using improved PB-frame mode (H.263+) and the B-block
		// was signalled to be predicted in the forward direction only,
		// we do not adjust with the backward prediction from the future.
		if (DC->bImprovedPBFrames == FALSE || 
			fpMBInfo->bForwardPredOnly == FALSE)
#endif
		{
#ifdef USE_MMX // { USE_MMX
        if (DC->bMMXDecoder)
    	    // adjust with bacward prediction from the future
    	    MMX_BiMotionComp(
                pRef[i],
                fpBlockAction[i].pCurBlock, 
                (I32) mv_b_x[i], 
                (I32) mv_b_y[i], 
                i);
        else
    	    // adjust with bacward prediction from the future
    	H263BiMotionComp(
            pRef[i],
            fpBlockAction[i].pCurBlock, 
            (I32) mv_b_x[i], 
            (I32) mv_b_y[i], 
            i);
#else // }{ USE_MMX
    	    // adjust with bacward prediction from the future
    	H263BiMotionComp(
            pRef[i],
            fpBlockAction[i].pCurBlock, 
            (I32) mv_b_x[i], 
            (I32) mv_b_y[i], 
            i);
#endif // } USE_MMX
		}

    } // end for (i=0; i<6; i++) {}
}
#pragma code_seg()

/*****************************************************************************
 *
 *  H263BFrameIDCTandBiMC
 *
 *  B Frame IDCT and 
 *  Bi-directional MC for B blocks
 */

#pragma code_seg("IACODE2")
void H263BFrameIDCTandBiMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    U32                      *pRef
)     
{
    ASSERT(*pN < 65);
                                                        
    // do the inverse transform (where appropriate) & combine
    if (*pN > 0) {

#ifdef USE_MMX // { USE_MMX
        if (DC->bMMXDecoder)
        {
            MMX_DecodeBlock_IDCT(
                (U32)pRUN_INVERSE_Q, 
                *pN,
                (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter  output

            MMX_BlockAdd(
                (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // output
                pRef[iBlock],                                    // prediction
                fpBlockAction[iBlock].pBBlock);                  // destination
        }
        else
        {
	      	// Get residual block; put output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
			DecodeBlock_IDCT(
	            (U32)pRUN_INVERSE_Q, 
	            *pN,
	            fpBlockAction[iBlock].pBBlock,                   // intRA not used here
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter output

	        // Add the residual to the reference block
			BlockAdd(
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // transform output 
	            pRef[iBlock],                                    // prediction
	            fpBlockAction[iBlock].pBBlock);                  // destination

        }
#else // }{ USE_MMX
	      	// Get residual block; put output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
			DecodeBlock_IDCT(
	            (U32)pRUN_INVERSE_Q, 
	            *pN,
	            fpBlockAction[iBlock].pBBlock,                   // intRA not used here
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter output

	        // Add the residual to the reference block
			BlockAdd(
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // transform output 
	            pRef[iBlock],                                    // prediction
	            fpBlockAction[iBlock].pBBlock);                  // destination
#endif // } USE_MMX

    }
    else 
    {
      	// No transform coefficients for this block,
      	// copy the prediction to the output.
#ifdef USE_MMX // { USE_MMX
      	if (DC->bMMXDecoder)
            MMX_BlockCopy(
          		fpBlockAction[iBlock].pBBlock,   // destination 
          		pRef[iBlock]);                   // prediction
      	else
      	  	BlockCopy(
 		  		fpBlockAction[iBlock].pBBlock,   // destination
            	pRef[iBlock]);                   // prediction
#else // }{ USE_MMX
      	  	BlockCopy(
 		  		fpBlockAction[iBlock].pBBlock,   // destination
            	pRef[iBlock]);                   // prediction
#endif // } USE_MMX
    }                       
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3pict.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3pict.cpp
 *
 *  Description:
 *		This modules contains the picture header parsing routines
 *
 *	Routines:
 *		H263ReadPictureHeader
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d3pict.cpv   1.21   05 Feb 1997 12:24:30   JMCVEIGH  $
 * $Log:   S:\h26x\src\dec\d3pict.cpv  $
// 
//    Rev 1.21   05 Feb 1997 12:24:30   JMCVEIGH
// Support for latest H.263+ draft bitstream spec.
// 
//    Rev 1.20   16 Dec 1996 17:42:56   JMCVEIGH
// Existence of extended PTYPE implies improved PB-frame mode if
// a PB-frame. Also, initialized H.263+ optional flags if EPTYPE not
// read.
// 
//    Rev 1.19   11 Dec 1996 14:59:12   JMCVEIGH
// 
// Allow deblocking filter in reading of picture header.
// 
//    Rev 1.18   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.17   31 Oct 1996 10:18:22   KLILLEVO
// changed one (commented out) DBOUT to DbgLog
// 
//    Rev 1.16   20 Oct 1996 15:49:50   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.15   20 Oct 1996 14:05:54   AGUPTA2
// Minor change in one of the DbgLog calls.
// 
// 
//    Rev 1.14   20 Oct 1996 13:21:44   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.13   30 May 1996 10:16:32   KLILLEVO
// removed to variables only needed for DEBUG_DECODER
// 
//    Rev 1.12   30 May 1996 10:14:44   KLILLEVO
// removed one debug statement
// 
//    Rev 1.11   24 May 1996 10:47:00   KLILLEVO
// added ifdef _DEBUG arounf wsprintf
// 
//    Rev 1.10   03 May 1996 13:06:36   CZHU
// 
// Check bit 2 for packet loss errors to trigger packet loss recovery
// 
//    Rev 1.9   18 Dec 1995 12:49:54   RMCKENZX
// added copyright notice & log stamp
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_PICTURE_STARTCODE = 22;
#ifdef SIM_OUT_OF_DATE
const int BITS_TR = 5;
#else
const int BITS_TR = 8;
#endif
const int BIT_ONE_VAL = 1;
const int BIT_TWO_VAL = 0;
const int BITS_PTYPE_SOURCE_FORMAT = 3;

#ifdef H263P
// H.263+ draft, document LBC-96-358R3
const int BITS_EPTYPE_RESERVED = 5;
const int EPTYPE_RESERVED_VAL = 1;

const int BITS_CSFMT_PARC  = 4;		// Custom source format pixel aspect ratio code
const int BITS_CSFMT_FWI   = 9;     // Custom source format frame width indication
const int BIT_CSFMT_14_VAL = 1;		// Prevents start code emulation
const int BITS_CSFMT_FHI   = 9;     // Custom source format frame height indication

const int BITS_PAR_WIDTH   = 8;     // Pixel aspect ratio width
const int BITS_PAR_HEIGHT  = 8;		// Pixel aspect ratio height
#endif

const int BITS_PQUANT = 5;
const int BITS_TRB = 3;
const int BITS_DBQUANT = 2;
const int BITS_PSPARE = 8; //not includeing the following PEI

/* PSC_VALUE - 0000 0000 0000 0000 - 1000 00xx xxxx xxxx 
 */
const U32 PSC_VALUE = (0x00008000 >> (32-BITS_PICTURE_STARTCODE));
/* We only want to search so far before it is considered an error 
 */
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */
  
/*****************************************************************************
 *
 * 	H263DecodePictureHeader
 *
 *  Read and parse the picture header - updating the fpbsState if the read
 *	succeeds.
 *
 *  Returns an ICERR_STATUS
 */
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState)
{
	I32 iReturn;
	int iLookAhead;
	U32 uResult;
	U32 uData;
	int iSpareCount;

	FX_ENTRY("H263DecodePictureHeader")

	//  PSC ----------------------------------------
	GET_FIXED_BITS((U32) BITS_PICTURE_STARTCODE, fpu8, uWork, uBitsReady, 
				   uResult);
	iLookAhead = 0;
	while (uResult != PSC_VALUE) 
	{
		uResult = uResult << 1;
		uResult &= GetBitsMask[BITS_PICTURE_STARTCODE];
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
		uResult |= uData;
		iLookAhead++;
		if (iLookAhead > MAX_LOOKAHEAD_NUMBER) 
		{
			ERRORMESSAGE(("%s: Missing PSC\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
	}

	GET_FIXED_BITS((U32) BITS_TR, fpu8, uWork, uBitsReady, uResult);
	DC->uTempRefPrev = DC->uTempRef;
	DC->uTempRef = uResult;

	// PTYPE ----------------------------------------
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult != BIT_ONE_VAL) 
	{
		ERRORMESSAGE(("%s: PTYPE bit 1 error\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult != BIT_TWO_VAL) 
	{
		ERRORMESSAGE(("%s: PTYPE bit 2 error\r\n", _fx_));
//#ifdef LOSS_RECOVERY
		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
		iReturn = PACKET_FAULT;
//#endif
		goto done;
	}

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bSplitScreen = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCameraOn = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bFreezeRelease = (U16) uResult;

	GET_FIXED_BITS((U32) BITS_PTYPE_SOURCE_FORMAT, fpu8, uWork, uBitsReady, 
                   uResult);

#ifdef H263P
	// We don't need to check that the frame dimensions are supported here. 
	// This is handled in DecompressQuery() 
	// Custom format is forbidden in PTYPE
	if (uResult == SRC_FORMAT_FORBIDDEN || uResult == SRC_FORMAT_CUSTOM)
	{
		ERRORMESSAGE(("%s: Forbidden src format\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
#else
#ifdef USE_BILINEAR_MSH26X
	if (uResult == SRC_FORMAT_FORBIDDEN) 
#else
	if (uResult == SRC_FORMAT_FORBIDDEN || uResult > SRC_FORMAT_CIF) 
#endif
	{
		ERRORMESSAGE(("%s: Src format not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
#endif

	DC->uPrevSrcFormat = DC->uSrcFormat; 
	DC->uSrcFormat = uResult;

#ifdef H263P
	// We don't support changes in the source format between frames. However,
	// if either the current or previous source format in PTYPE indicates
	// extended PTYPE, we do not know if the actual format (i.e., frame size)
	// has changed, yet
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat &&
		DC->uSrcFormat != SRC_FORMAT_EPTYPE)
#else
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat) 
#endif
	{
		ERRORMESSAGE(("%s: Src format not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

#ifdef H263P
	// The actual source format has not been read if this is the 
	// first frame and we detected an extended PTYPE
	if (DC->bReadSrcFormat || DC->uSrcFormat != SRC_FORMAT_EPTYPE)
		// We have read the actual source format, so mark flag as true.
		DC->bReadSrcFormat = 1;
#else
		DC->bReadSrcFormat = 1;
#endif

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bKeyFrame = (U16) !uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bUnrestrictedMotionVectors = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bArithmeticCoding = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bAdvancedPrediction = (U16) uResult;
	// If bit 12 is set to "1", bit 10 shall be set to "1" as well. (5.1.3 p14)
	/* if (DC->bAdvancedPrediction && !DC->bUnrestrictedMotionVectors) {
	ERRORMESSAGE(("%s: Warning: bit 12 is one and bit 10 is zero\r\n", _fx_));
	iReturn = ICERR_ERROR;
	goto done;
	} */

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bPBFrame = (U16) uResult;
	// If bit 9 is set to "0", bit 13 shall be set to "0" as well." (5.1.3 p11)
	if (DC->bKeyFrame && DC->bPBFrame) 
	{
		ERRORMESSAGE(("%s: A key frame can not be a PB frame\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

#ifdef H263P
	// EPTYPE --------------------------------------
	if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	{
		// Extended PTYPE detected in PTYPE. 

		// We need to read the source format (again) and the optional mode flags.
		GET_FIXED_BITS((U32) BITS_PTYPE_SOURCE_FORMAT, fpu8, uWork, uBitsReady,
					    uResult);
		if (uResult == SRC_FORMAT_FORBIDDEN || uResult == SRC_FORMAT_RESERVED)
		{
			ERRORMESSAGE(("%s: Forbidden or reserved src format\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		DC->uSrcFormat = uResult;		// DC->uPrevSrcFormat has already been saved

		// Check to make sure that the picture size has not changed between frames.
		if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
		{
			ERRORMESSAGE(("%s: Src format changed\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->bReadSrcFormat = 1;		// The actual source format has finally been read

		// Optional modes:

		// Custom PCF ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bCustomPCF = (U16) uResult;
		if (DC->bCustomPCF)
		{
			ERRORMESSAGE(("%s: Custom PCF not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Advanced intra coding ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bAdvancedIntra = (U16) uResult;
		if (DC->bAdvancedIntra)
		{
			ERRORMESSAGE(("%s: Advanced intra coding not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Deblocking filter ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bDeblockingFilter = (U16) uResult;

		// Slice structured ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bSliceStructured = (U16) uResult;
		if (DC->bSliceStructured)
		{
			ERRORMESSAGE(("%s: Slice structured mode not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Improved PB-frames ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bImprovedPBFrames = (U16) uResult;

		// Back channel operation ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bBackChannel = (U16) uResult;
		if (DC->bBackChannel)
		{
			ERRORMESSAGE(("%s: Back-channel operation not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Scalability ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bScalability = (U16) uResult;
		if (DC->bScalability)
		{
			ERRORMESSAGE(("%s: Scalability mode not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// True B-frame mode ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bTrueBFrame = (U16) uResult;
		if (DC->bTrueBFrame)
		{
			ERRORMESSAGE(("%s: True B-frames not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Reference-picture resampling ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bResampling = (U16) uResult;
		if (DC->bResampling)
		{
			ERRORMESSAGE(("%s: Reference-picture resampling not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Reduced-resolution update ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bResUpdate = (U16) uResult;
		if (DC->bResUpdate)
		{
			ERRORMESSAGE(("%s: Reduced resolution update not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Resevered bits
		GET_FIXED_BITS((U32) BITS_EPTYPE_RESERVED, fpu8, uWork, uBitsReady, uResult);
		if (uResult != EPTYPE_RESERVED_VAL)
		{
			ERRORMESSAGE(("%s: Invalid reserved code in EPTYPE\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
	} // end if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	else	// end if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	{
		// We might never read these optional flags, so set them to
		// false if not extended PTYPE
		DC->bImprovedPBFrames = FALSE;
		DC->bAdvancedIntra = FALSE;
		DC->bDeblockingFilter = FALSE;
		DC->bSliceStructured = FALSE;
		DC->bCustomPCF = FALSE;
		DC->bBackChannel = FALSE;
		DC->bScalability = FALSE;
		DC->bTrueBFrame = FALSE;
		DC->bResampling = FALSE;
		DC->bResUpdate = FALSE;
	}

	// CSFMT --------------------------------------
	if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)
	{
		// Custom source format detected. We need to read the aspect ratio
		// code and the frame width and height indications.

		// Pixel aspect ratio code
		GET_FIXED_BITS((U32) BITS_CSFMT_PARC, fpu8, uWork, uBitsReady, uResult);
		U16 uPARC = (U16)uResult;

		// Frame width indication
		GET_FIXED_BITS((U32) BITS_CSFMT_FWI, fpu8, uWork, uBitsReady, uResult);
		// The number of pixels per line is given by (FWI+1)*4. We do not
		// support cases where the picture width differs from that given in the
		// DC->uActualFrameWidth parameter.
		if (DC->uActualFrameWidth != ((uResult + 1) << 2))
		{
			ERRORMESSAGE(("%s: Frame width change not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Bit 13 must be "1" to prevent start code emulation
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		if (uResult != BIT_CSFMT_14_VAL)
		{
			ERRORMESSAGE(("%s: CSFMT bit 13 != 1\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Frame height indication
		GET_FIXED_BITS((U32) BITS_CSFMT_FHI, fpu8, uWork, uBitsReady, uResult);
		// The number of lines is given by (FHI+1)*4. We do not
		// support cases where the picture height differs from that given in the
		// DC->uActualFrameHeight parameter.
		if (DC->uActualFrameHeight != ((uResult + 1) << 2))
		{
			ERRORMESSAGE(("%s: Frame height change not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		switch (uPARC) {
		case PARC_SQUARE:
			DC->uPARWidth = 1;
			DC->uPARHeight = 1;
			break;
		case PARC_CIF:
			DC->uPARWidth = 12;
			DC->uPARHeight = 11;
			break;
		case PARC_10_11:
			DC->uPARWidth = 10;
			DC->uPARHeight = 11;
			break;
		case PARC_EXTENDED:
			GET_FIXED_BITS((U32) BITS_PAR_WIDTH, fpu8, uWork, uBitsReady, uResult);
			DC->uPARWidth = uResult;
			if (DC->uPARWidth == 0) 
			{
				ERRORMESSAGE(("%s: Forbidden pixel aspect ratio width\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			GET_FIXED_BITS((U32) BITS_PAR_HEIGHT, fpu8, uWork, uBitsReady, uResult);
			DC->uPARHeight = uResult;
			if (DC->uPARHeight == 0) 
			{
				ERRORMESSAGE(("%s: Forbidden pixel aspect ratio height\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			break;
		default:
			ERRORMESSAGE(("%s: Unsupported pixel aspect ratio code\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

	} // end if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)

#endif // H263P

	// PQUANT --------------------------------------
	GET_FIXED_BITS((U32) BITS_PQUANT, fpu8, uWork, uBitsReady, uResult);
	DC->uPQuant = uResult;

	// CPM -----------------------------------------
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCPM = (U16) uResult;
	if (DC->bCPM) 
	{
		ERRORMESSAGE(("%s: Continuous Presence Multipoint is not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	// PLCI ----------------------------------------
	if (DC->bCPM) 
	{
		//  TBD("TBD: PLCI");
		iReturn = ICERR_ERROR;
		goto done;
	}

	if (DC->bPBFrame) 
	{
		GET_FIXED_BITS((U32) BITS_TRB, fpu8, uWork, uBitsReady, uResult);
		DC->uBFrameTempRef = uResult;

		GET_FIXED_BITS((U32) BITS_DBQUANT, fpu8, uWork, uBitsReady, uResult);
		DC->uDBQuant = uResult;
	} 
	else 
	{
		DC->uBFrameTempRef = 12345678; /* clear the values */
		DC->uDBQuant = 12345678;
	}

	//  skip spare bits
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while (uResult) 
	{
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_PSPARE;
	}

	DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: TR=%ld SS=%d CAM=%d FRZ=%d SRC=%ld PCT=%d UMV=%d AC=%d AP=%d PB=%d CPM=%d PQ=%ld TRB=%ld DBQ=%ld Spare=%d\r\n", _fx_, DC->uTempRef, DC->bSplitScreen, DC->bCameraOn, DC->bFreezeRelease, DC->uSrcFormat, !DC->bKeyFrame, DC->bUnrestrictedMotionVectors, DC->bArithmeticCoding, DC->bAdvancedPrediction, DC->bPBFrame, DC->bCPM, DC->uPQuant, DC->uBFrameTempRef, DC->uDBQuant, iSpareCount));

#ifdef H263P
	DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: DF=%d TB=%d\r\n", _fx_, DC->bDeblockingFilter, DC->bTrueBFrame));

	if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)
	{
		DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: PARW=%ld PARH=%ld FWI=%ld FHI=%ld\r\n", _fx_, DC->uPARWidth, DC->uPARHeight, (DC->uActualFrameWidth >> 2) - 1, (DC->uActualFrameHeight >> 2) - 1));
	}
#endif // H263P

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodePictureHeader() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3tables.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:36:16  $
// $Archive:   S:\h26x\src\dec\d3tables.h_v  $
// $Header:   S:\h26x\src\dec\d3tables.h_v   1.4   27 Dec 1995 14:36:16   RMCKENZX  $
// $Log:   S:\h26x\src\dec\d3tables.h_v  $
;// 
;//    Rev 1.4   27 Dec 1995 14:36:16   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   16 Aug 1995 14:25:44   CZHU
// 
// Changed inverse quantization table to I16
// 
//    Rev 1.2   11 Aug 1995 15:50:26   CZHU
// Moved the tables to d3tables.cpp, leave only extern defs.
// 
//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
// 
// Added table for inverse quantization and RLD-ZZ
// 
//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here
#ifndef _GLOBAL_TABLES_
#define _GLOBAL_TABLES_

extern U16 gTAB_MCBPC_INTRA[512];   //total 1024

extern U16 gTAB_MCBPC_INTER[512];   //total 1024

extern U16 gTAB_CBPY_INTRA[64];		//total 128

extern U16 gTAB_CBPY_INTER[64];	    //total 128

extern U16 gTAB_MVD_MAJOR[256];     //total 512

extern U32 gTAB_TCOEFF_MAJOR[256];  //total 1024

extern U16 gTAB_MVD_MINOR[256];     //total 512

extern U32 gTAB_TCOEFF_MINOR[1024]; //total 4096

extern I16 gTAB_INVERSE_Q[1024] ;


extern U32 gTAB_ZZ_RUN[64]; //input is the cumulative run value
                     //returns the offset to the starting address of the block
					 //total at 256
  					   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxap.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Header:   S:\h26x\src\dec\dxap.h_v   1.2   27 Dec 1995 14:36:18   RMCKENZX  $
//
// $Log:   S:\h26x\src\dec\dxap.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.1   10 Nov 1995 14:45:10   CZHU
// 
// 
//    Rev 1.0   10 Nov 1995 13:56:14   CZHU
// Initial revision.


// ComputeDynamicClut8 Index and UV dither table
#ifndef _AP_INC_
#define _AP_INC_

#define NCOL 256
#define YSIZ   16
#define YSTEP  16
//#define USE_744
extern U8 gUTable[];
extern U8 gVTable[];

/* table index is uvuvuvuvxyyyyyyy */
#define UVSTEP  8
#define YGAP    1
//#define TBLIDX(y,u,v) (((v)>>3<<12) + ((u)>>3<<8) + (y))
#define TBLIDX(y,u,v) ( ((gVTable[v] + gUTable[u]) <<8) + (y>>1))

#if 1

#define YFROM(R, G, B) (U32)((( 16843 * R) + ( 33030 * G) + (  6423 * B) + 65536*16) /65536)
#define UFROM(R, G, B) (U32)((( -9699 * R) + (-19071 * G) + ( 28770 * B) + 65536*128)/65536)
#define VFROM(R, G, B) (U32)((( 28770 * R) + (-24117 * G) + ( -4653 * B) + 65536*128)/65536)

#else

#define YFROM(R, G, B) ( I32)(( 0.257 * R) + ( 0.504 * G) + ( 0.098 * B) + 16.)
#define UFROM(R, G, B) ( I32)((-0.148 * R) + (-0.291 * G) + ( 0.439 * B) + 128.)
#define VFROM(R, G, B) ( I32)(( 0.439 * R) + (-0.368 * G) + (-0.071 * B) + 128.)

#endif

#define CLAMP8(x) (U8)((x) > 255 ? 255 : ((x) < 0 ? 0 : (x)))

/* parameters for generating the U and V dither magnitude and bias */
#define MAG_NUM_NEAREST         6       /* # nearest neighbors to check */
#define MAG_PAL_SAMPLES         32      /* # random palette samples to check */
#define BIAS_PAL_SAMPLES        128     /* number of pseudo-random RGB samples to check */

#define Y_DITHER_MIN 0
#define Y_DITHER_MAX 14

#define RANDOM(x) (int)((((long)(x)) * (long)rand())/(long)RAND_MAX)

typedef struct {  int palindex; long  distance; } close_t;
typedef struct {  int y,u,v; } Color;
/* squares[] is constant values are filled in at run time, so can be global */
static U32 squares[512];
static struct { U8 Udither, Vdither; } dither[4] = {{2, 1}, {1, 2}, {0, 3}, {3, 0}};


;/***************************************************************************/
;/* ComputeDymanicClut() computes the clut tables on the fly, based on the  */
;/* current palette[];                                                      */
;/* called from InitColorConvertor, when CLUTAP is selected                 */
;/***************************************************************************/
LRESULT ComputeDynamicClutNew(unsigned char BIGG *table,
                              unsigned char FAR *APalette, 
                              int APaletteSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxap.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Header:   S:\h26x\src\dec\dxap.cpv   1.4   20 Oct 1996 13:22:12   AGUPTA2  $
//
// $Log:   S:\h26x\src\dec\dxap.cpv  $
// 
//    Rev 1.4   20 Oct 1996 13:22:12   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.3   27 Aug 1996 11:20:06   KLILLEVO
// changed GlobalAlloc/GLobalLock to HeapAlloc
// 
//    Rev 1.2   27 Dec 1995 14:36:10   RMCKENZX
// Added copyright notice
// 
//    Rev 1.1   10 Nov 1995 14:45:02   CZHU
// 
// 
//    Rev 1.0   10 Nov 1995 13:54:28   CZHU
// Initial revision.

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
char gsz4[32];
char gsz5[32];
#endif

U8 gUTable[256] =
{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,
128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,
136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,
138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,
160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,
162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,
168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,
170,170,170,170,170,170,170,170,170,170,170,170,170,170,170
};

U8 gVTable[256]=
{
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,
68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,
69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,
80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,
81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,
84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,
85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85

};

/***************************************************************************
 * ComputeDymanicClut() computes the clut tables on the fly, based on the  *
 * current palette[];                                                      *
 * called from InitColorConvertor, when CLUTAP is selected                 *
 ***************************************************************************/
LRESULT ComputeDynamicClutNew(U8 *pAPTable, 
                              U8 *pActivePalette, 
                              int iPalSize)
{  

	/* 
	* The dynamic clut consists of 4 entries which MUST be
	* contiguous in memory:
	*
	*    ClutTable: 65536 1-byte entries
	*               Each entry is the closest pPalette entry, as
	*               indexed by a 14 bit value: uvuvuvuv0yyyyyyy,
	*               dithered
	*
	*    TableU:    256   4-byte entries
	*               Each entry is u0u0u0u0:u0u0u0u0:u0u0u0u0:u0u0u0u0,
	*               each uuuu is a 4 bit dithered u value for the
	*               index, which is a u value in the range 8-120
	*
	*    TableV:    256   4-byte entries
	*               Same as TableU, except the values are arranged
	*               0v0v0v0v:0v0v0v0v:0v0v0v0v:0v0v0v0v.
	*/

	Color   *pPalette;
	U8 *pTmpPtr; 
	U8  pYSlice[YSIZ][256],  *pYYPtr;
	I32 *pYCnt;
	U32 *pDiff, *dptr, *delta, *deptr;
	I32 i,j,yseg,y,u,v,mini,yo,uo,vo,ycount,yi; 
	U32 addr1,addr2,ind;
	U32 d,min;     // since 3*128^2 = 49K
	PALETTEENTRY   *lpPal,   *palptr;
	Color   *colptr;
	I32 Y, U, V;
	I32 U_0, U_1, U_2, U_3;
	I32 V_0, V_1, V_2, V_3;
   
	I32 Umag, Vmag;
	/* dist max is 128*128*3 = 49152 */
	U32 dist;
	U32 close_dist[MAG_NUM_NEAREST];
	I32 palindex;
	I32 R, G, B;
	I32 k, p, tmp, iu, iv;
	/* Ubias and Vbias max is (128 * 4 * BIAS_PAL_SAMPLES) = 65536 */
	/* even the worst palette (all black except the reserved colors) */
	/* would not achieve this. */
	I32 Ubias, Vbias;
	U32 Udither, Vdither;
	U32 *TableUptr,  *TableVptr;

	FX_ENTRY("ComputeDynamicClutNew")	

	DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: ComputeDynamic CLUT8 index tables\r\n", _fx_));

	/* allocate some memory */
	pPalette = (Color *)HeapAlloc(GetProcessHeap(), NULL, sizeof(Color)*256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "DXAP: %7ld Ln %5ld\0", sizeof(Color)*256, __LINE__);
	AddName((unsigned int)pPalette, gsz1);
#endif

	pYCnt    = (I32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(I32)  *YSIZ);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "DXAP: %7ld Ln %5ld\0", sizeof(I32)  *YSIZ, __LINE__);
	AddName((unsigned int)pYCnt, gsz2);
#endif

	pDiff    = (U32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(U32)  *256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "DXAP: %7ld Ln %5ld\0", sizeof(U32)  *256, __LINE__);
	AddName((unsigned int)pDiff, gsz3);
#endif

	delta    = (U32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(U32)  *256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz4, "DXAP: %7ld Ln %5ld\0", sizeof(U32)  *256, __LINE__);
	AddName((unsigned int)delta, gsz4);
#endif

	lpPal    = (PALETTEENTRY *)HeapAlloc(GetProcessHeap(), NULL, sizeof(PALETTEENTRY)*256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz5, "DXAP: %7ld Ln %5ld\0", sizeof(PALETTEENTRY)*256, __LINE__);
	AddName((unsigned int)lpPal, gsz5);
#endif

	if (!pPalette || !pYCnt || !pDiff || !delta || !lpPal)
		return (ICERR_MEMORY);

	for (i=-256; i<256; i++)
		squares[256+i] = i*i;

	memcpy((U8 *)lpPal, pActivePalette, iPalSize);

    palptr = lpPal;
    colptr = pPalette;
    for (i = 0; i < 256; i++) {
		/* In BGR (RGBQuad) order. */
	 B = palptr->peRed;
	 G = palptr->peGreen;
	 R = palptr->peBlue; 
	 
	 colptr->y = YFROM(R, G, B);
	 colptr->u = UFROM(R, G, B);
	 colptr->v = VFROM(R, G, B);
	palptr++;
	colptr++;
    }

	for (i=0; i<YSIZ; i++)
		pYCnt[i] = 0;

	for (i=0; i<256; i++)
	{
		yseg = pPalette[i].y >> 4;
		pYSlice[yseg][ pYCnt[yseg]++ ] = (U8) i;
	}


// Do exhaustive search on all U,V points and a coarse grid in Y

	for (u=0; u<256; u+=UVSTEP)
	{
		for (v=0; v<256; v+=UVSTEP)
		{
			ind = TBLIDX(0,u,v);
			pTmpPtr = pAPTable+ind;
			for (y=0; y<256; y+=YSTEP)
			{
				colptr = pPalette;
				min = 0x0FFFFFFF;
				for (i=0; i<NCOL; i++, colptr++)
				{
					d = (3*squares[256+y - colptr->y])>>1;
					if (d > min)
						continue;
					
					d += squares[256+u - colptr->u];
					if (d > min)
						continue;

					d += squares[256+v - colptr->v];
					if (d < min)
					{
						min = d;
						mini = i;
					}
				}
				*pTmpPtr = (U8) mini;  
			    pTmpPtr += YSTEP;

			}
		}
	}
#ifdef STATISTICS
#if defined USE_STAT_BOARD
	dwStopTime = ReadElapsed()>>2;
#else
	dwStopTime = bentime();
#endif /* USE_STAT_BOARD */
	dwElapsedTime = dwStopTime - dwStartTime2 - dwOverheadTime;
	DPF("CoarseSearch() time = %lu microseconds",dwElapsedTime);
#endif

// Go thru points not yet done, and search
//  (1) The closest point to the prev and next Y in coarse grid
//  (2) All the points in this Y slice
//
// Also, take advantage of the fact that we can do distance computation
// incrementally.  Keep all N errors in an array, and update each
// time we change Y.


	for (u=0; u<256; u+=UVSTEP)
	{
		for (v=0; v<256; v+=UVSTEP)
		{
			for (y=YGAP; y<256; y+=YSTEP)
			{
				yseg = y >> 4;
				ycount = pYCnt[yseg] + 2;  // +2 is 'cause we add 2 Y endpoints

				pYYPtr = (U8   *)pYSlice[yseg];
				
				addr1 = TBLIDX(yseg*16,u,v);
				pYYPtr[ycount-2] = *(U8 *)(pAPTable +addr1);

				addr2 = TBLIDX((yseg+(yseg < (YSIZ -1)))*16,u,v);
				pYYPtr[ycount-1] = *(U8 *)(pAPTable +addr2);

				dptr  = pDiff;
				deptr = delta;
				for (i=0; i<ycount; i++, pYYPtr++, dptr++, deptr++)
				{
					j = *pYYPtr; /* pYSlice[yseg][i]; */
					colptr = pPalette+j;
					yo = colptr->y;
					uo = colptr->u;
					vo = colptr->v;
					*dptr = ( 3*squares[256+y-yo] + 2*(squares[256+u-uo] + squares[256+v-vo]));
					*deptr =( 3*(((y-yo)<<1) + 1));
				}

				ind = TBLIDX(y,u,v);
				pTmpPtr = pAPTable+ind;
				for (yi=0; yi<YSTEP-1; yi += YGAP)
				{
					min = 0x0FFFFFFF;
					pYYPtr = (U8 *)pYSlice[yseg];
					dptr  = pDiff;
					deptr = delta;
					for (i=0; i<ycount; i++, pYYPtr++, dptr++, deptr++)
					{
						if (*dptr < min)
						{
							min = *dptr;
							mini = *pYYPtr; /* pYSlice[yseg][i]; */
						}
						*dptr += *deptr;
						*deptr += 6;
					}
					*pTmpPtr = (U8) mini;
					pTmpPtr++;

				}
			}
		}
	}

       /* now do U and V dither tables and shift lookup table*/
       /* NOTE: All Y, U, V values are 7 bits */

	Umag = Vmag = 0;
	Ubias = Vbias = 0;

	/* use srand(0) and rand() to generate a repeatable series of */
	/* pseudo-random numbers */
	srand((unsigned)1);
	
	for (p = 0; p < MAG_PAL_SAMPLES; ++p)               // 32
	{
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)            // 6
	   {
	      close_dist[i] = 0x7FFFL;
	   }
	    
	   palindex = RANDOM(235) + 10; /* random palette index, unreserved colors */
	   colptr = &pPalette[palindex];
	   Y = colptr->y;
	   U = colptr->u;
	   V = colptr->v;
	    
	   colptr = pPalette;
	   for (i = 0; i < 255; ++i)
	   {
	      if (i != palindex)
	      {
		   dist = squares[256+(Y - colptr->y)] +
			      squares[256+(U - colptr->u)] +
			      squares[256+(V - colptr->v)];
	       
		 /* keep a sorted list of the nearest MAG_NUM_NEAREST entries */
		 for (j = 0; j < MAG_NUM_NEAREST; ++j)         //6
		 {
		    if (dist < close_dist[j])
		    {
		       /* insert new entry; shift others down */
		       for (k = (MAG_NUM_NEAREST-1); k > j; k--)
		       {
			      close_dist[k] = close_dist[k-1];
		       }
		       close_dist[j] = dist;
		       break; /* out of for j loop */
		    }
		 } /* for j */
	      } /* if i */
	      ++colptr;
	   } /* for i */
	   
	   /* now calculate Umag as the average of (U - U[1-6]) */
	   /* calculate Vmag in the same way */
	   
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)
	   {
	      /* there are (MAG_PAL_SAMPLES * MAG_NUM_NEAREST) sqrt() */
	      /* calls in this method */
	      Umag += (I32)sqrt((double)close_dist[i]);
	   }
	} /* for p */

	Umag /= (MAG_NUM_NEAREST * MAG_PAL_SAMPLES);
	Vmag = Umag;
	
	for (p = 0; p < BIAS_PAL_SAMPLES; ++p)            //132
	{

		/* now calculate the average bias (use random RGB points) */
		R = RANDOM(255);
		G = RANDOM(255);
		B = RANDOM(255);
	   
		Y = YFROM(R, G, B);
		U = UFROM(R, G, B);
		V = VFROM(R, G, B);
	   
		for (d = 0; d < 4; d++)   
		{
			U_0 = U + (dither[d].Udither*Umag)/3;
			V_0 = V + (dither[d].Vdither*Vmag)/3;
	      
			/* Clamp values */
			if (U_0 > 255) U_0 = 255;
			if (V_0 > 255) V_0 = 255;
					
			/* (Y, U_0, V_0) is the dithered YUV for the RGB point */
			/* colptr points to the closest palette entry to the dithered */
			/* RGB */
			/* colptr = &pPalette[pAPTable[TBLIDX(Y, U_0+(UVSTEP>>1), V_0+(UVSTEP>>1))]]; */
		    pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(Y, U_0, V_0)) ;
		    palindex=*pTmpPtr;
		    colptr = &pPalette[palindex];
      
			Ubias +=  (U - colptr->u);
			Vbias +=  (V - colptr->v);
		}
	} /* for p */
	
	Ubias =(I32) (Ubias+BIAS_PAL_SAMPLES*2)/(I32)(BIAS_PAL_SAMPLES * 4);
	Vbias =(I32) (Vbias+BIAS_PAL_SAMPLES*2)/(I32)(BIAS_PAL_SAMPLES * 4);
	


    U_0 = (2*(I32)Umag/3); V_0 = (1*(I32)Vmag/3);
    U_1 = (1*(I32)Umag/3); V_1 = (2*(I32)Vmag/3);
    U_2 = (0*(I32)Umag/3); V_2 = (3*(I32)Vmag/3);
    U_3 = (3*(I32)Umag/3); V_3 = (0*(I32)Vmag/3);

    TableUptr = (U32 *)(pAPTable+ (U32)65536L);
    TableVptr = TableUptr + 256;    
       
    iu = Ubias /* + (UVSTEP>>1) */;
    iv = Vbias /* + (UVSTEP>>1) */;

    for (i = 0; i < 256; i++, iu++, iv++)
    {
	 /* dither: u0u0u0u0, 0v0v0v0v */
	 tmp = iu + U_0; 
	 Udither  = gUTable[CLAMP8(tmp)]; 
	 Udither <<= 8; 
	 tmp = iu + U_1; 
	 Udither |= gUTable[CLAMP8(tmp)]; Udither <<= 8; tmp = iu      ; 
	 Udither |= gUTable[CLAMP8(tmp)]; Udither <<= 8; tmp = iu + U_3; 
	 Udither |= gUTable[CLAMP8(tmp)];
	 *TableUptr++ = Udither ; 
	  
	 tmp = iv + V_0; 
	 Vdither  = gVTable[CLAMP8(tmp)]; 
	 Vdither <<= 8;
	 tmp = iv + V_1; Vdither |= gVTable[CLAMP8(tmp)]; Vdither <<= 8;
	 tmp = iv + V_2; Vdither |= gVTable[CLAMP8(tmp)]; Vdither <<= 8;
	 tmp = iv      ; Vdither |= gVTable[CLAMP8(tmp)];                /* V_3 == 0 */ 
	 *TableVptr++ = Vdither; 

    }

	//adjust color for 0--8 and 120-128 for luma
	// 0--16, 241-255 plus dither for chroma

    TableUptr = (U32 *)(pAPTable+ (U32)65536L);
    TableVptr = TableUptr + 256;    
	for (i=0; i<16;i++)
	{
	  TableUptr[i]= TableUptr[16];
	  TableVptr[i]= TableVptr[16];
	}

	for (i=241;i<256;i++)
	{
	  TableUptr[i]= TableUptr[240];
	  TableVptr[i]= TableVptr[240];
	}

	for (u = 0; u < 256; u += UVSTEP) {
	 for (v = 0; v < 256; v += UVSTEP) {
		pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(16, u, v)) ;
		mini = *pTmpPtr;

		for (y = Y_DITHER_MIN; y < 16; y += 2) 
		{
			pTmpPtr--;
			*pTmpPtr = (U8)mini;
		}

		pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(240, u, v)) ;
		mini = *pTmpPtr;

		for (y = 241; y < 256+Y_DITHER_MAX; y +=2)
		{
			pTmpPtr++;
			*pTmpPtr = (U8)mini;
		}
	 } /* for v... */
	} /* for u... */


	/* free memory allocated */
	HeapFree(GetProcessHeap(), NULL, pPalette);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pPalette);
#endif
	HeapFree(GetProcessHeap(), NULL, pYCnt);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pYCnt);
#endif
	HeapFree(GetProcessHeap(), NULL, pDiff);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pDiff);
#endif
	HeapFree(GetProcessHeap(), NULL, delta);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)delta);
#endif
	HeapFree(GetProcessHeap(), NULL, lpPal);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpPal);
#endif

	return (ICERR_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\d3tables.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:30  $
// $Archive:   S:\h26x\src\dec\d3tables.cpv  $
// $Header:   S:\h26x\src\dec\d3tables.cpv   1.10   08 Mar 1996 16:46:30   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3tables.cpv  $
// 
//    Rev 1.10   08 Mar 1996 16:46:30   AGUPTA2
// Removed tables gTAB_MCBPC_INTRA, gTAB_MCBPC_INTER, gTAB_CBPY_INTRA, and
// gTAB_CBPY_INTER. Added pragma data_seg to put all the tables in the Pass 1
// data segment.
// 
// 
//    Rev 1.9   27 Dec 1995 14:36:08   RMCKENZX
// Added copyright notice
// 
//    Rev 1.8   08 Oct 1995 13:41:58   CZHU
// 
// Fixed zz-run table with two wrong entries, 
// 
//    Rev 1.7   18 Sep 1995 08:40:28   CZHU
// Fixed bugs with table entries for negative val
// 
//    Rev 1.6   07 Sep 1995 09:46:40   CZHU
// fixed one bug in TCOEFF minor table
// 
//    Rev 1.5   31 Aug 1995 16:42:48   CZHU
// Changed the format of MVD variable length decoder tables: major and minor
// 
//    Rev 1.4   24 Aug 1995 15:34:28   CZHU
// Fixed bugs in the inverse quant table, and TCOEFF minor tables 
// 
//    Rev 1.3   22 Aug 1995 17:39:00   CZHU
// 
// Modified the TCOEFF_MAJOR and MINOR tables for embedded run values.
// 
//    Rev 1.2   18 Aug 1995 15:01:00   CZHU
// Added run length tables ready for joint opt IDCT and RLD+ZZ
// 
//    Rev 1.1   16 Aug 1995 14:25:10   CZHU
// 
// Rebuild the tables for IQ, RLD for Transform coefficients
// 
//    Rev 1.0   11 Aug 1995 15:50:56   CZHU
// Initial revision.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here

#include "precomp.h"

/*
U16 gTAB_MCBPC_INTRA[512]= {

0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01 
};   //total 1024

U16 gTAB_MCBPC_INTER[512]={

0x0,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xd08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1109,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1309,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xb08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xe08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1409,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xd08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x709,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1209,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xb08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xe08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1


};   //total 1024


U16 gTAB_CBPY_INTRA[64]={

0x0,  0xd04,0xc04,0xf02,0x205,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x606,0xd04,0xc04,0xf02,0x105,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x0,  0xd04,0xc04,0xf02,0x205,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x906,0xd04,0xc04,0xf02,0x105,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02
};		    //total 128

U16 gTAB_CBPY_INTER[64]={

0x0,  0x204,0x304,0x2,0xd05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x906,0x204,0x304,0x2,0xe05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x0,  0x204,0x304,0x2,0xd05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x606,0x204,0x304,0x2,0xe05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2 

};		    //total 128
*/

#pragma data_seg("IADATA1")
U16 gTAB_MVD_MAJOR[256]={
0x0,
0x0,0x0,0x0,0x0,0x0,0x708,0xf908,0x608,
0xfa08,0x508,0xfb08,0x407,0x407,0xfc07,0xfc07,0x305,
0x305,0x305,0x305,0x305,0x305,0x305,0x305,0xfd05,
0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0x204,
0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,
0x204,0x204,0x204,0x204,0x204,0x204,0x204,0xfe04,
0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,
0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1
};     //total 512

U16 gTAB_MVD_MINOR[256]={

0x0,
0x0,0x0,0x0,0x0,0xe00d,0x1f0d,0xe10d,0x1e0c,
0x1e0c,0xe20c,0xe20c,0x1d0c,0x1d0c,0xe30c,0xe30c,0x1c0c,
0x1c0c,0xe40c,0xe40c,0x1b0c,0x1b0c,0xe50c,0xe50c,0x1a0c,
0x1a0c,0xe60c,0xe60c,0x190c,0x190c,0xe70c,0xe70c,0x180b,
0x180b,0x180b,0x180b,0xe80b,0xe80b,0xe80b,0xe80b,0x170b,
0x170b,0x170b,0x170b,0xe90b,0xe90b,0xe90b,0xe90b,0x160b,
0x160b,0x160b,0x160b,0xea0b,0xea0b,0xea0b,0xea0b,0x150b,
0x150b,0x150b,0x150b,0xeb0b,0xeb0b,0xeb0b,0xeb0b,0x140b,
0x140b,0x140b,0x140b,0xec0b,0xec0b,0xec0b,0xec0b,0x130b,
0x130b,0x130b,0x130b,0xed0b,0xed0b,0xed0b,0xed0b,0x120b,
0x120b,0x120b,0x120b,0xee0b,0xee0b,0xee0b,0xee0b,0x110b,
0x110b,0x110b,0x110b,0xef0b,0xef0b,0xef0b,0xef0b,0x100b,
0x100b,0x100b,0x100b,0xf00b,0xf00b,0xf00b,0xf00b,0xf0b,
0xf0b,0xf0b,0xf0b,0xf10b,0xf10b,0xf10b,0xf10b,0xe0b,
0xe0b,0xe0b,0xe0b,0xf20b,0xf20b,0xf20b,0xf20b,0xd0b,
0xd0b,0xd0b,0xd0b,0xf30b,0xf30b,0xf30b,0xf30b,0xc0b,
0xc0b,0xc0b,0xc0b,0xf40b,0xf40b,0xf40b,0xf40b,0xb0b,
0xb0b,0xb0b,0xb0b,0xf50b,0xf50b,0xf50b,0xf50b,0xa0a,
0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xf60a,
0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0x90a,
0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0xf70a,
0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0x80a,
0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0xf80a,
0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xc0b,
0xc0b,0xc0b,0xc0b,0xf40b,0xf40b,0xf40b,0xf40b,0xb0b,
0xb0b,0xb0b,0xb0b,0xf50b,0xf50b,0xf50b,0xf50b,0xa0a,
0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xf60a,
0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0x90a,
0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0xf70a,
0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0x80a,
0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0xf80a,
0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a

};     //total 512

U32 gTAB_TCOEFF_MAJOR[256]={
0x3,
0x3,0x3,0x3,0x3,0x3,0x1,0x1,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x221204,
0x221206,0x221004,0x221006,0x220e04,0x220e06,0x220c04,0x220c06,0x201a04,
0x201a06,0x201804,0x201806,0x201604,0x201606,0x200210,0x200212,0x1e0a04,
0x1e0a04,0x1e0a06,0x1e0a06,0x1e0804,0x1e0804,0x1e0806,0x1e0806,0x1e0604,
0x1e0604,0x1e0606,0x1e0606,0x1e0404,0x1e0404,0x1e0406,0x1e0406,0x1c1404,
0x1c1404,0x1c1406,0x1c1406,0x1c1204,0x1c1204,0x1c1206,0x1c1206,0x1c1004,
0x1c1004,0x1c1006,0x1c1006,0x1c0e04,0x1c0e04,0x1c0e06,0x1c0e06,0x1c0408,
0x1c0408,0x1c040a,0x1c040a,0x1c020c,0x1c020c,0x1c020e,0x1c020e,0x180c04,
0x180c04,0x180c04,0x180c04,0x180c06,0x180c06,0x180c06,0x180c06,0x180a04,
0x180a04,0x180a04,0x180a04,0x180a06,0x180a06,0x180a06,0x180a06,0x180804,
0x180804,0x180804,0x180804,0x180806,0x180806,0x180806,0x180806,0x160204,
0x160204,0x160204,0x160204,0x160204,0x160204,0x160204,0x160204,0x160206,
0x160206,0x160206,0x160206,0x160206,0x160206,0x160206,0x160206,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0x100404,
0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,
0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100406,
0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,
0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x140604,
0x140604,0x140604,0x140604,0x140604,0x140604,0x140604,0x140604,0x140606,
0x140606,0x140606,0x140606,0x140606,0x140606,0x140606,0x140606,0x140208,
0x140208,0x140208,0x140208,0x140208,0x140208,0x140208,0x140208,0x14020a,
0x14020a,0x14020a,0x14020a,0x14020a,0x14020a,0x14020a,0x14020a

};  //total 1024

U32 gTAB_TCOEFF_MINOR[1024]={
0x100,
0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,
0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x190204,
0x190204,0x190205,0x190205,0x190106,0x190106,0x190107,0x190107,0x180116,
0x180116,0x180117,0x180117,0x180114,0x180114,0x180115,0x180115,0x171d02,
0x171d02,0x171d02,0x171d02,0x171d03,0x171d03,0x171d03,0x171d03,0x171c02,
0x171c02,0x171c02,0x171c02,0x171c03,0x171c03,0x171c03,0x171c03,0x171b02,
0x171b02,0x171b02,0x171b02,0x171b03,0x171b03,0x171b03,0x171b03,0x171a02,
0x171a02,0x171a02,0x171a02,0x171a03,0x171a03,0x171a03,0x171a03,0x160a04,
0x160a04,0x160a04,0x160a04,0x160a05,0x160a05,0x160a05,0x160a05,0x160904,
0x160904,0x160904,0x160904,0x160905,0x160905,0x160905,0x160905,0x160804,
0x160804,0x160804,0x160804,0x160805,0x160805,0x160805,0x160805,0x160704,
0x160704,0x160704,0x160704,0x160705,0x160705,0x160705,0x160705,0x160604,
0x160604,0x160604,0x160604,0x160605,0x160605,0x160605,0x160605,0x160406,
0x160406,0x160406,0x160406,0x160407,0x160407,0x160407,0x160407,0x160306,
0x160306,0x160306,0x160306,0x160307,0x160307,0x160307,0x160307,0x160208,
0x160208,0x160208,0x160208,0x160209,0x160209,0x160209,0x160209,0x180118,
0x180118,0x180119,0x180119,0x18020a,0x18020a,0x18020b,0x18020b,0x181802,
0x181802,0x181803,0x181803,0x181902,0x181902,0x181903,0x181903,0x191e02,
0x191e02,0x191e03,0x191e03,0x191f02,0x191f02,0x191f03,0x191f03,0x192002,
0x192002,0x192003,0x192003,0x192102,0x192102,0x192103,0x192103,0x1a020c,
0x1a020d,0x1a0308,0x1a0309,0x1a0506,0x1a0507,0x1a0606,0x1a0607,0x1a0706,
0x1a0707,0x1a0b04,0x1a0b05,0x1a1a02,0x1a1a03,0x1a1b02,0x1a1b03,0x1b2202,
0x1b2203,0x1b2302,0x1b2303,0x1b2402,0x1b2403,0x1b2502,0x1b2503,0x1b2602,
0x1b2603,0x1b2702,0x1b2703,0x1b2802,0x1b2803,0x1b2902,0x1b2903,0x180118,
0x180118,0x180119,0x180119,0x18020a,0x18020a,0x18020b,0x18020b,0x181802,
0x181802,0x181803,0x181803,0x181902,0x181902,0x181903,0x181903,0x191e02,
0x191e02,0x191e03,0x191e03,0x191f02,0x191f02,0x191f03,0x191f03,0x192002,
0x192002,0x192003,0x192003,0x192102,0x192102,0x192103,0x192103,0x1a020c,
0x1a020d,0x1a0308,0x1a0309,0x1a0506,0x1a0507,0x1a0606,0x1a0607,0x1a0706,
0x1a0707,0x1a0b04,0x1a0b05,0x1a1a02,0x1a1a03,0x1a1b02,0x1a1b03,0x1b2202,
0x1b2203,0x1b2302,0x1b2303,0x1b2402,0x1b2403,0x1b2502,0x1b2503,0x1b2602,
0x1b2603,0x1b2702,0x1b2703,0x1b2802,0x1b2803,0x1b2902,0x1b2903,0x160112,
0x160112,0x160112,0x160112,0x160113,0x160113,0x160113,0x160113,0x160110,
0x160110,0x160110,0x160110,0x160111,0x160111,0x160111,0x160111,0x151902,
0x151902,0x151902,0x151902,0x151902,0x151902,0x151902,0x151902,0x151903,
0x151903,0x151903,0x151903,0x151903,0x151903,0x151903,0x151903,0x151802,
0x151802,0x151802,0x151802,0x151802,0x151802,0x151802,0x151802,0x151803,
0x151803,0x151803,0x151803,0x151803,0x151803,0x151803,0x151803,0x151702,
0x151702,0x151702,0x151702,0x151702,0x151702,0x151702,0x151702,0x151703,
0x151703,0x151703,0x151703,0x151703,0x151703,0x151703,0x151703,0x151602,
0x151602,0x151602,0x151602,0x151602,0x151602,0x151602,0x151602,0x151603,
0x151603,0x151603,0x151603,0x151603,0x151603,0x151603,0x151603,0x151502,
0x151502,0x151502,0x151502,0x151502,0x151502,0x151502,0x151502,0x151503,
0x151503,0x151503,0x151503,0x151503,0x151503,0x151503,0x151503,0x151402,
0x151402,0x151402,0x151402,0x151402,0x151402,0x151402,0x151402,0x151403,
0x151403,0x151403,0x151403,0x151403,0x151403,0x151403,0x151403,0x151302,
0x151302,0x151302,0x151302,0x151302,0x151302,0x151302,0x151302,0x151303,
0x151303,0x151303,0x151303,0x151303,0x151303,0x151303,0x151303,0x151202,
0x151202,0x151202,0x151202,0x151202,0x151202,0x151202,0x151202,0x151203,
0x151203,0x151203,0x151203,0x151203,0x151203,0x151203,0x151203,0x150104,
0x150104,0x150104,0x150104,0x150104,0x150104,0x150104,0x150104,0x150105,
0x150105,0x150105,0x150105,0x150105,0x150105,0x150105,0x150105,0x141702,
0x141702,0x141702,0x141702,0x141702,0x141702,0x141702,0x141702,0x141703,
0x141703,0x141703,0x141703,0x141703,0x141703,0x141703,0x141703,0x141602,
0x141602,0x141602,0x141602,0x141602,0x141602,0x141602,0x141602,0x141603,
0x141603,0x141603,0x141603,0x141603,0x141603,0x141603,0x141603,0x141502,
0x141502,0x141502,0x141502,0x141502,0x141502,0x141502,0x141502,0x141503,
0x141503,0x141503,0x141503,0x141503,0x141503,0x141503,0x141503,0x141402,
0x141402,0x141402,0x141402,0x141402,0x141402,0x141402,0x141402,0x141403,
0x141403,0x141403,0x141403,0x141403,0x141403,0x141403,0x141403,0x141302,
0x141302,0x141302,0x141302,0x141302,0x141302,0x141302,0x141302,0x141303,
0x141303,0x141303,0x141303,0x141303,0x141303,0x141303,0x141303,0x141202,
0x141202,0x141202,0x141202,0x141202,0x141202,0x141202,0x141202,0x141203,
0x141203,0x141203,0x141203,0x141203,0x141203,0x141203,0x141203,0x141102,
0x141102,0x141102,0x141102,0x141102,0x141102,0x141102,0x141102,0x141103,
0x141103,0x141103,0x141103,0x141103,0x141103,0x141103,0x141103,0x141002,
0x141002,0x141002,0x141002,0x141002,0x141002,0x141002,0x141002,0x141003,
0x141003,0x141003,0x141003,0x141003,0x141003,0x141003,0x141003,0x140504,
0x140504,0x140504,0x140504,0x140504,0x140504,0x140504,0x140504,0x140505,
0x140505,0x140505,0x140505,0x140505,0x140505,0x140505,0x140505,0x140404,
0x140404,0x140404,0x140404,0x140404,0x140404,0x140404,0x140404,0x140405,
0x140405,0x140405,0x140405,0x140405,0x140405,0x140405,0x140405,0x14010e,
0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010f,
0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010c,
0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010d,
0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x131102,
0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,
0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131103,
0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,
0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131002,
0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,
0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131003,
0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,
0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x130f02,
0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,
0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f03,
0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,
0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130e02,
0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,
0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e03,
0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,
0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130d02,
0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,
0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d03,
0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,
0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130c02,
0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,
0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c03,
0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,
0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130b02,
0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,
0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b03,
0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,
0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130a02,
0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,
0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a03,
0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,
0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x120f02,
0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,
0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f03,
0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,
0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120e02,
0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,
0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e03,
0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,
0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120304,
0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,
0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120305,
0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,
0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120206,
0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,
0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120207,
0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,
0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x12010a,
0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,
0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010b,
0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,
0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b

}; //total 4096

I16 gTAB_INVERSE_Q[1024] = { 
  0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    3,   -3,    5,   -5,    7,   -7,    9, 
  -9,   11,  -11,   13,  -13,   15,  -15,   17, 
 -17,   19,  -19,   21,  -21,   23,  -23,   25, 
 -25,   27,  -27,   29,  -29,   31,  -31,    0, 
   0,    5,   -5,    9,   -9,   13,  -13,   17, 
 -17,   21,  -21,   25,  -25,   29,  -29,   33, 
 -33,   37,  -37,   41,  -41,   45,  -45,   49, 
 -49,   53,  -53,   57,  -57,   61,  -61,    0, 
   0,    9,   -9,   15,  -15,   21,  -21,   27, 
 -27,   33,  -33,   39,  -39,   45,  -45,   51, 
 -51,   57,  -57,   63,  -63,   69,  -69,   75, 
 -75,   81,  -81,   87,  -87,   93,  -93,    0, 
   0,   11,  -11,   19,  -19,   27,  -27,   35, 
 -35,   43,  -43,   51,  -51,   59,  -59,   67, 
 -67,   75,  -75,   83,  -83,   91,  -91,   99, 
 -99,  107, -107,  115, -115,  123, -123,    0, 
   0,   15,  -15,   25,  -25,   35,  -35,   45, 
 -45,   55,  -55,   65,  -65,   75,  -75,   85, 
 -85,   95,  -95,  105, -105,  115, -115,  125, 
-125,  135, -135,  145, -145,  155, -155,    0, 
   0,   17,  -17,   29,  -29,   41,  -41,   53, 
 -53,   65,  -65,   77,  -77,   89,  -89,  101, 
-101,  113, -113,  125, -125,  137, -137,  149, 
-149,  161, -161,  173, -173,  185, -185,    0, 
   0,   21,  -21,   35,  -35,   49,  -49,   63, 
 -63,   77,  -77,   91,  -91,  105, -105,  119, 
-119,  133, -133,  147, -147,  161, -161,  175, 
-175,  189, -189,  203, -203,  217, -217,    0, 
   0,   23,  -23,   39,  -39,   55,  -55,   71, 
 -71,   87,  -87,  103, -103,  119, -119,  135, 
-135,  151, -151,  167, -167,  183, -183,  199, 
-199,  215, -215,  231, -231,  247, -247,    0, 
   0,   27,  -27,   45,  -45,   63,  -63,   81, 
 -81,   99,  -99,  117, -117,  135, -135,  153, 
-153,  171, -171,  189, -189,  207, -207,  225, 
-225,  243, -243,  261, -261,  279, -279,    0, 
   0,   29,  -29,   49,  -49,   69,  -69,   89, 
 -89,  109, -109,  129, -129,  149, -149,  169, 
-169,  189, -189,  209, -209,  229, -229,  249, 
-249,  269, -269,  289, -289,  309, -309,    0, 
   0,   33,  -33,   55,  -55,   77,  -77,   99, 
 -99,  121, -121,  143, -143,  165, -165,  187, 
-187,  209, -209,  231, -231,  253, -253,  275, 
-275,  297, -297,  319, -319,  341, -341,    0, 
   0,   35,  -35,   59,  -59,   83,  -83,  107, 
-107,  131, -131,  155, -155,  179, -179,  203, 
-203,  227, -227,  251, -251,  275, -275,  299, 
-299,  323, -323,  347, -347,  371, -371,    0, 
   0,   39,  -39,   65,  -65,   91,  -91,  117, 
-117,  143, -143,  169, -169,  195, -195,  221, 
-221,  247, -247,  273, -273,  299, -299,  325, 
-325,  351, -351,  377, -377,  403, -403,    0, 
   0,   41,  -41,   69,  -69,   97,  -97,  125, 
-125,  153, -153,  181, -181,  209, -209,  237, 
-237,  265, -265,  293, -293,  321, -321,  349, 
-349,  377, -377,  405, -405,  433, -433,    0, 
   0,   45,  -45,   75,  -75,  105, -105,  135, 
-135,  165, -165,  195, -195,  225, -225,  255, 
-255,  285, -285,  315, -315,  345, -345,  375, 
-375,  405, -405,  435, -435,  465, -465,    0, 
   0,   47, -47,   79,  -79,  111, -111,  143, 
-143,  175, -175,  207, -207,  239, -239,  271, 
-271,  303, -303,  335, -335,  367, -367,  399, 
-399,  431, -431,  463, -463,  495, -495,    0, 
   0,   51,  -51,   85,  -85,  119, -119,  153, 
-153,  187, -187,  221, -221,  255, -255,  289, 
-289,  323, -323,  357, -357,  391, -391,  425, 
-425,  459, -459,  493, -493,  527, -527,    0, 
   0,   53,  -53,   89,  -89,  125, -125,  161, 
-161,  197, -197,  233, -233,  269, -269,  305, 
-305,  341, -341,  377, -377,  413, -413,  449, 
-449,  485, -485,  521, -521,  557, -557,    0, 
   0,   57,  -57,   95,  -95,  133, -133,  171, 
-171,  209, -209,  247, -247,  285, -285,  323, 
-323,  361, -361,  399, -399,  437, -437,  475, 
-475,  513, -513,  551, -551,  589, -589,    0, 
   0,   59,  -59,   99,  -99,  139, -139,  179, 
-179,  219, -219,  259, -259,  299, -299,  339, 
-339,  379, -379,  419, -419,  459, -459,  499, 
-499,  539, -539,  579, -579,  619, -619,    0, 
   0,   63,  -63,  105, -105,  147, -147,  189, 
-189,  231, -231,  273, -273,  315, -315,  357, 
-357,  399, -399,  441, -441,  483, -483,  525, 
-525,  567, -567,  609, -609,  651, -651,    0, 
   0,   65,  -65,  109, -109,  153, -153,  197, 
-197,  241, -241,  285, -285,  329, -329,  373, 
-373,  417, -417,  461, -461,  505, -505,  549, 
-549,  593, -593,  637, -637,  681, -681,    0, 
   0,   69,  -69,  115, -115,  161, -161,  207, 
-207,  253, -253,  299, -299,  345, -345,  391, 
-391,  437, -437,  483, -483,  529, -529,  575, 
-575,  621, -621,  667, -667,  713, -713,    0, 
   0,   71,  -71,  119, -119,  167, -167,  215, 
-215,  263, -263,  311, -311,  359, -359,  407, 
-407,  455, -455,  503, -503,  551, -551,  599, 
-599,  647, -647,  695, -695,  743, -743,    0, 
   0,   75,  -75,  125, -125,  175, -175,  225, 
-225,  275, -275,  325, -325,  375, -375,  425, 
-425,  475, -475,  525, -525,  575, -575,  625, 
-625,  675, -675,  725, -725,  775, -775,    0, 
   0,   77,  -77,  129, -129,  181, -181,  233, 
-233,  285, -285,  337, -337,  389, -389,  441, 
-441,  493, -493,  545, -545,  597, -597,  649, 
-649,  701, -701,  753, -753,  805, -805,    0, 
   0,   81,  -81,  135, -135,  189, -189,  243, 
-243,  297, -297,  351, -351,  405, -405,  459, 
-459,  513, -513,  567, -567,  621, -621,  675, 
-675,  729, -729,  783, -783,  837, -837,    0, 
   0,   83,  -83,  139, -139,  195, -195,  251, 
-251,  307, -307,  363, -363,  419, -419,  475, 
-475,  531, -531,  587, -587,  643, -643,  699, 
-699,  755, -755,  811, -811,  867, -867,    0, 
   0,   87,  -87,  145, -145,  203, -203,  261, 
-261,  319, -319,  377, -377,  435, -435,  493, 
-493,  551, -551,  609, -609,  667, -667,  725, 
-725,  783, -783,  841, -841,  899, -899,    0, 
   0,   89,  -89,  149, -149,  209, -209,  269, 
-269,  329, -329,  389, -389,  449, -449,  509, 
-509,  569, -569,  629, -629,  689, -689,  749, 
-749,  809, -809,  869, -869,  929, -929,    0, 
   0,   93,  -93,  155, -155,  217, -217,  279, 
-279,  341, -341,  403, -403,  465, -465,  527, 
-527,  589, -589,  651, -651,  713, -713,  775, 
-775,  837, -837,  899, -899,  961, -961
};


U32 gTAB_ZZ_RUN[64]= { 0,  1,  8,  16, 9,  2,  3,  10,
                       17, 24, 32, 25, 18, 11, 4,  5,
					   12, 19, 26, 33, 40, 48, 41, 34, 
					   27, 20, 13, 6,  7,  14, 21, 28, 
					   35, 42, 49, 56, 57, 50, 43, 36, 
					   29, 22, 15, 23, 30, 37, 44, 51, 
					   58, 59, 52, 45, 38, 31, 39, 46,
					   53, 60, 61, 54, 47, 55, 62, 63
}
; //input is the cumulative run value
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxgetbit.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 13:54:10  $
;// $Archive:   S:\h26x\src\dec\dxgetbit.cpv  $
;// $Header:   S:\h26x\src\dec\dxgetbit.cpv   1.2   22 Dec 1995 13:54:10   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxgetbit.cpv  $
// 
//    Rev 1.2   22 Dec 1995 13:54:10   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   01 Aug 1995 12:28:10   DBRUCKS
// change to read most sig bit first and to not read too many bytes
// 
//    Rev 1.0   31 Jul 1995 13:00:16   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   28 Jul 1995 09:46:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

const U32 GetBitsMask[33] = {
	0x00000000, 0x00000001, 0x00000003, 0x00000007,
	0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
	0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
	0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
	0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
	0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
	0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
	0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
	0xffffffff
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxgetbit.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  dxgetbit.h
 *
 *  Description:
 *	  bit reading interface
 */

/*
 * $Header:   S:\h26x\src\dec\dxgetbit.h_v   1.5   27 Dec 1995 14:36:20   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\dxgetbit.h_v  $
;// 
;//    Rev 1.5   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
 */

#ifndef __DXGETBIT_H__
#define __DXGETBIT_H__

/*****************************************************************************
 *
 *  DESCRIPTION:
 *    The bit reading functions support reading from 1 to 24 bits from a 
 *    stream of bytes.  The most significant bit is read first.
 *
 *  VARIABLES:
 *    U8 FAR * fpu8 - pointer to a stream of bytes
 *	  U32 uWork - working storage
 *    U32 uBitsReady - the number of bits that have been read into the 
 *					   working storage
 * 	  U32 uCount - the number of bits
 *    U32 uResult - the output value
 *    BITSTREAM_STATE FAR * fpbsState - the bitstream state.
 *    U32 uCode - the code used to look up the uResult
 *    U32 uBitCount - number of bits in the code
 */

/*****************************************************************************
 * 
 *  The GetBitsMask is an array of masks indexed by the number of valid bits
 */
extern const U32 GetBitsMask[33]; 

/*****************************************************************************
 *
 *  The state of a stream can be represented using the following structure.
 *  This state structure can be passed between functions and used to initialize
 *  or reinitialize the bitstream.
 */
typedef struct {
	U8 FAR * fpu8;
	U32 uWork;
	U32 uBitsReady;
} BITSTREAM_STATE;

/*****************************************************************************
 *
 *  GET_BITS_INIT
 *
 *  Initialize the bit reading functions.
 *
 *  Parameters:
 *	  uBitsReady - OUT parameter
 *    uWork - OUT parameter
 */
#define GET_BITS_INIT(uWork, uBitsReady) {	\
	uBitsReady = 0;		 					\
	uWork = 0;								\
}

/*****************************************************************************
 *
 *  GET_BITS_SAVE_STATE
 *  
 *  Save the state
 *
 *  Parameters
 *    fpu8 - IN
 *    uBitsReady - IN
 *    uWork - IN
 *    fpbsState - OUT
 */
#define GET_BITS_SAVE_STATE(fp, uW, uBR, fpbs) { \
	fpbs->fpu8 = fp;				\
	fpbs->uBitsReady = uBR;			\
	fpbs->uWork = uW;				\
}

/*****************************************************************************
 *
 *  GET_BITS_RESTORE_STATE
 *
 *  Restore the state
 *
 *  Parameters
 */
#define GET_BITS_RESTORE_STATE(fp, uW, uBR, fpbs) { \
	 fp = fpbs->fpu8;				\
	 uBR = fpbs->uBitsReady;		\
	 uW = fpbs->uWork;				\
}

/*****************************************************************************
 *
 *  GET_FIXED_BITS
 *
 *  Read from 1 to 24 bits from the pointer.
 * 
 *  Parameters:
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_FIXED_BITS(uCount, fpu8, uWork, uBitsReady, uResult) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* setup uBitsReady for next time */	\
	uBitsReady = uBitsReady - uCount;		\
	uResult = (uWork >> uBitsReady);		\
	uWork &= GetBitsMask[uBitsReady];		\
}

/*****************************************************************************
 *
 *  GET_ONE_BIT
 *
 *  Read 1 bit from the pointer. This is a special case of GET_FIXED_BITS 
 *  provided because of the possible assembly optimization advantages.
 * 
 *  Parameters:
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult) {		\
	GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult)		\
}


/*****************************************************************************
 *
 *  GET_VARIABLE_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */
#define GET_VARIABLE_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	uResult = fpTable[uCode];				\
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#endif /* __DXGETBIT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxblkcpy.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:34  $
// $Archive:   S:\h26x\src\dec\dxblkcpy.cpv  $
// $Header:   S:\h26x\src\dec\dxblkcpy.cpv   1.4   08 Mar 1996 16:46:34   AGUPTA2  $
// $Log:   S:\h26x\src\dec\dxblkcpy.cpv  $
// 
//    Rev 1.4   08 Mar 1996 16:46:34   AGUPTA2
// Rewritten to reduce code size by avoiding 32-bit displacements.  Added
// pragma code_seg.  May need to optimize for misaligned case.
// 
// 
//    Rev 1.3   31 Jan 1996 13:15:14   RMCKENZX
// Rewrote file to avoid bank conflicts.  Fully unrolled the loop.
// Module now really will execute in 52 cycles if the cache is hot.
// 
//    Rev 1.2   22 Dec 1995 13:51:06   KMILLS
// added new copyright notice
// 
//    Rev 1.1   25 Sep 1995 09:03:22   CZHU
// Added comments on cycle counts
// 
//    Rev 1.0   11 Sep 1995 16:52:26   CZHU
// Initial revision.
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// Note:
//	-	BlockCopy reads and writes in DWORDS.
//	-	The __fastcall convention is used.
//	-	Code re-written to minimize code size.
//	-	We assume the output frame to NOT be in cache.
//	-	The constants PITCH and U32 are defined internally (no include files used).
//
// Registers used: 
//	eax		accumulator
//	ebx		accumulator		
//	ecx		destination address
//	edx		source address
//	ebp		PITCH			
//
// Pentium cycle count (input cache hot, output cache cold):  
//	33 + 8*(cache miss time)		input aligned
//	81 + 8*(cache miss time)		input mis-aligned
//
//------------------------------------------------------------------------------

#include "precomp.h"

#define U32 unsigned long
// Already defined in precomp.h
#define DXPITCH 384

#pragma code_seg("IACODE2")
/*
 *  Notes:
 *    The parameter uDstBlock is in ecx and uSrcBlock is in edx.
 */
__declspec(naked)
void __fastcall BlockCopy (U32 uDstBlock, U32 uSrcBlock)
{		
__asm {
    push    edi
     push    ebx
    push    ebp
     mov     ebp, DXPITCH
    // row 0
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 1
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 2
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 3
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 4
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 5
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 6
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 7
    add     ecx, ebp
     pop     ebp
    mov     eax, [edx]
     mov     ebx, [edx+4]
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     pop     ebx
    pop     edi
     ret        
    }     // end of asm
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxblkadd.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:39:58  $
// $Archive:   S:\h26x\src\dec\dxblkadd.cpv  $
// $Header:   S:\h26x\src\dec\dxblkadd.cpv   1.7   30 Aug 1996 08:39:58   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxblkadd.cpv  $
// 
//    Rev 1.7   30 Aug 1996 08:39:58   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.6   17 Jul 1996 15:33:56   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.5   08 Mar 1996 16:46:32   AGUPTA2
// Moved the ClampTbl to be common between this module and IDCT.  Reduced
// the size of the ClampTbl from 256+256+256 to 64+256+64.  IDCT INTER coeffs
// are biased by 1024 and is taken care of when accessing ClampTbl.  Added
// pragma code_seg to place the rtn in Pass 2 code segment.
// 
// 
//    Rev 1.4   22 Dec 1995 13:52:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   25 Sep 1995 09:03:36   CZHU
// Added comments on cycle counts
// 
//    Rev 1.2   13 Sep 1995 08:46:44   AKASAI
// Set loopcounter back to 8.  Intermediate is 8x8 of DWORDS so TEMPPITCH4
// should be 32 not 64.
// 
//    Rev 1.1   12 Sep 1995 18:19:20   CZHU
// 
// Changed loop from 8 to 7 to start with.
// 
//    Rev 1.0   11 Sep 1995 16:52:20   CZHU
// Initial revision.


// -------------------------------------------------------------------------
// T is routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference and output use PITCH  
//              current  as some other pitch 
// -------------------------------------------------------------------------

#include "precomp.h"

#define TEMPPITCH4 32

#pragma data_seg("IADATA2")
#define FRAMEPOINTER		esp
#define L_LOOPCOUNTER    	FRAMEPOINTER	+    0	// 4 byte
#define LOCALSIZE		    4		                // keep aligned

#pragma code_seg("IACODE2") 
__declspec(naked)
void BlockAdd (U32 uResidual, U32 uRefBlock,U32 uDstBlock)
{		
__asm {
	push  ebp			         // save callers frame pointer
	mov	ebp,esp		             // make parameters accessible 
    push  esi			         // assumed preserved 
	push  edi			
    push  ebx 			
	sub	esp,LOCALSIZE	          // reserve local storage 

  mov     edi, uDstBlock         ;// edi gets Base addr of OutputBuffer
      mov   ecx, 8
    mov     esi, uRefBlock;      ;// esi gets Base addr of Current
      mov   ebp, uResidual       ;// ebp gets Base addr of Reference
    mov     ebx, [edi]           ;// pre-fetch output
      xor   eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi+0]         ; 3) fetch ref[i]
    mov     dl, ClampTbl[CLAMP_BIAS+eax-1024]  ; 1) fetch clamp[result2]
      mov   eax, [ebp+0]                ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClampTbl[CLAMP_BIAS+ebx-1024]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClampTbl[CLAMP_BIAS+eax-1024]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClampTbl[CLAMP_BIAS+eax-1024]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, PITCH                  ; Update address of next line
    mov     dl, ClampTbl[CLAMP_BIAS+ebx-1024]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    mov     ebx, [edi]                  ; pre-fetch output
      jnz   loop_for_i


	add esp,LOCALSIZE	           // free locals 
    pop	ebx 
	 pop edi
	pop	esi
	 pop ebp
	ret   
  }	 //end of asm

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxcolori.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MBODART  $
// $Date:   17 Dec 1996 10:36:46  $
// $Archive:   S:\h26x\src\dec\dxcolori.h_v  $
// $Header:   S:\h26x\src\dec\dxcolori.h_v   1.21   17 Dec 1996 10:36:46   MBODART  $
// $Log:   S:\h26x\src\dec\dxcolori.h_v  $
;// 
;//    Rev 1.21   17 Dec 1996 10:36:46   MBODART
;// Exlude function prototypes that either aren't used, or do not match,
;// those for H.261.
;// 
;//    Rev 1.20   16 Dec 1996 13:53:48   MDUDA
;// Adjusted output color convertor table to account for H263' problem
;// with MMX output color convertors (MMX width must be multiple of 8).
;// 
;//    Rev 1.19   09 Dec 1996 09:35:54   MDUDA
;// 
;// Some re-arrangement for H263P.
;// 
;//    Rev 1.18   29 Oct 1996 13:45:34   MDUDA
;// Added prototype for MMX_YUV12ToYUY2.
;// 
;//    Rev 1.17   06 Sep 1996 16:10:18   BNICKERS
;// 
;// Added Pentium Pro color convertor function prototypes.
;// 
;//    Rev 1.16   18 Jul 1996 09:24:56   KLILLEVO
;// implemented YUV12 color convertor (pitch changer) in assembly
;// and added it as a normal color convertor function, via the
;// ColorConvertorCatalog() call.
;// 
;//    Rev 1.15   19 Jun 1996 14:27:54   RHAZRA
;// 
;// added #define YUY2DDRAW 33, added YUY2 Init color convertor function
;// and the YUY2 color convertor to the list of color convertors.
;// 
;//    Rev 1.14   14 Jun 1996 17:27:48   AGUPTA2
;// Updated the color convertor table.
;// 
;//    Rev 1.13   30 May 1996 15:16:44   KLILLEVO
;// added YUV12 output
;// 
;//    Rev 1.12   30 May 1996 11:26:44   AGUPTA2
;// Added support for MMX color convertors.
;// 
;//    Rev 1.11   01 Apr 1996 10:26:36   BNICKERS
;// Add YUV12 to RGB32 color convertors.  Disable IF09.
;// 
;//    Rev 1.10   18 Mar 1996 09:58:52   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.9   05 Feb 1996 13:35:50   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.8   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

#define YUV12ForEnc           0   // Keep these assignments consistent with
#define CLUT8                 1   // assembly .inc file
#define CLUT8DCI              2
#define CLUT8ZoomBy2          3
#define CLUT8ZoomBy2DCI       4
#define RGB24                 5
#define RGB24DCI              6
#define RGB24ZoomBy2          7
#define RGB24ZoomBy2DCI       8
#define RGB16555              9
#define RGB16555DCI          10
#define RGB16555ZoomBy2      11
#define RGB16555ZoomBy2DCI   12  
#define IF09                 13
#define RGB16664             14
#define RGB16664DCI          15
#define RGB16664ZoomBy2      16
#define RGB16664ZoomBy2DCI   17 
#define RGB16565             18
#define RGB16565DCI          19
#define RGB16565ZoomBy2      20
#define RGB16565ZoomBy2DCI   21 
#define RGB16655             22
#define RGB16655DCI          23
#define RGB16655ZoomBy2      24
#define RGB16655ZoomBy2DCI   25 
#define CLUT8APDCI           26
#define CLUT8APZoomBy2DCI    27
#define RGB32                28
#define RGB32DCI             29
#define RGB32ZoomBy2         30
#define RGB32ZoomBy2DCI      31
#define YUV12NOPITCH         32
#define YUY2DDRAW            33

#define H26X_DEFAULT_BRIGHTNESS  128
#define H26X_DEFAULT_CONTRAST    128
#define H26X_DEFAULT_SATURATION  128

#if !defined(H263P)
enum {PENTIUM_CC = 0, PENTIUMPRO_CC, MMX_CC};
#endif

typedef struct {
  LRESULT (* Initializer) (      /* Ptr to color conv initializer function.   */
                           T_H263DecoderCatalog FAR *, UN);
#if defined(H263P)
  void (FAR ASM_CALLTYPE * ColorConvertor[2][3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#else
  void (FAR ASM_CALLTYPE * ColorConvertor[3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#endif
} T_H263ColorConvertorCatalog;

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUY2_Init        (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUV_Init         (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB16_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB24_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_RGB32_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_CLUT8AP_Init     (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8AP_InitReal (LPDECINST,T_H263DecoderCatalog FAR * , UN, BOOL);

extern "C" {
#if !defined(H261)
	long Convert_Y_8to7_Bit(HPBYTE, DWORD, DWORD, DWORD, HPBYTE, DWORD);
	long AspectCorrect(HPBYTE,HPBYTE,HPBYTE,DWORD,DWORD,WORD FAR *,
			           DWORD,HPBYTE,HPBYTE,DWORD,DWORD);
	void FAR ASM_CALLTYPE BlockEdgeFilter (
              U8 FAR * P16Instance,        /* Base of instance data.          */
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_YPlane,              /* Offset to YPlane to filter.     */
              X32 X32_BEFDescr,            /* BEF Descriptors.                */
              UN BEFDescrPitch,            /* BEF Descriptor Pitch.           */
              X32 X32_BEFApplicationList,  /* BEF work space.                 */
              UN YPitch,                   /* Pitch of Y plane.               */
              UN YOperatingWidth);         /* Portion of Y line actually used.*/
#endif
	void FAR ASM_CALLTYPE AdjustPels (
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_Plane,               /* Offset to plane to adjust.      */
              DWORD Width,                 /* Width of plane.                 */
              DWORD Pitch,                 /* Pitch of plane.                 */
              DWORD Height,                /* Height of plane.                */
              X32 X16_AdjustmentTable);    /* Lookup table to do adjustment.  */
}

											 
extern "C" {

#if defined(H263P)
void FAR ASM_CALLTYPE
MMX_H26x_YUV12ForEnc   (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
#endif

void FAR ASM_CALLTYPE
H26x_YUV12ForEnc     (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
void FAR ASM_CALLTYPE
YUV12ToCLUT8         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToIF09          (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8AP       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8APZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUY2          (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUV           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
#ifdef USE_MMX // { USE_MMX
//  MMX routines
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB32       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB32ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB24       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB24ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB16       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB16ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToCLUT8       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToCLUT8ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToYUY2        (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
#endif // } USE_MMX
}

// For now the YUY2 color convertor is in C

// extern void FAR ASM_CALLTYPE YUV12ToYUY2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//
// $Author:   CLORD  $
// $Date:   17 Apr 1997 16:50:04  $
// $Archive:   S:\h26x\src\dec\dxbase.cpv  $
// $Header:   S:\h26x\src\dec\dxbase.cpv   1.48   17 Apr 1997 16:50:04   CLORD  $
//	$Log:   S:\h26x\src\dec\dxbase.cpv  $
// 
//    Rev 1.48   17 Apr 1997 16:50:04   CLORD
// moved updating xres and yres from DecompressQuery to DecompressBegin,
// this fixes VPhone frame dimension changes, when a Query was sent after the 
// DecompressEnd and before the DecompressBegin
// 
//    Rev 1.47   27 Mar 1997 12:32:48   MDUDA
// No longer checking input compression in Decompress. This change
// is to fix problem where DVP nulls out compression field between
// calls to DecompressBegin and Decompress.
// 
//    Rev 1.46   24 Mar 1997 15:00:34   mbodart
// Fix PVCS tracker bug 150 in the H.263 bug base:  allow a change of
// dimensions in "redundant" DecompressBegin's.
// 
//    Rev 1.45   18 Mar 1997 16:21:10   MDUDA
// Commented out call to H263TermColorConvertor in DecompressEnd.
// This fixes a Graphedt problem where starts and stops cause a hang.
// 
//    Rev 1.44   18 Mar 1997 10:43:28   mbodart
// Quick one-line fix to previous change.  Note that there are still problems
// in graphedt, when trying a bunch of play-pause-stop-play... combinations.
// We need to re-evaluate how DecompressBegin/DecompressEnd deal with
// memory allocation and initialization.
// 
// Also rearranged some DbgLog messages in DecompressQuery to give more
// condensed information.
// 
//    Rev 1.43   14 Mar 1997 19:01:36   JMCVEIGH
// Removed H263TermDecoderInstance from DecompressEnd. Some apps.
// send a DecompressEnd, but then restart decompressing at the
// middle of the sequence (i.e., not a the previous keyframe). We
// therefore need to retain the reference frame. The instance is
// free in DrvClose.
// 
//    Rev 1.42   07 Mar 1997 09:07:42   mbodart
// Added a missing '#ifndef H261' in DecompressQuery.
// Added a call to _clearfp() in the Decompress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.41   14 Jan 1997 11:16:22   JMCVEIGH
// Put flag for old still-frame mode backward compatibility under
// #ifdef H263P
// 
//    Rev 1.40   13 Jan 1997 10:51:14   JMCVEIGH
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.39   10 Jan 1997 18:30:24   BECHOLS
// Changed decompress query so that it will accept negative heights.
// 
//    Rev 1.38   06 Jan 1997 17:40:24   JMCVEIGH
// Added support to ensure backward compatibility with old
// still-frame mode (crop CIF image to 320x240). Since 320x240 size
// is valid with arbitrary frame size support in H.263+, we check
// for this case by either comparing the source/destination header
// sizes or the source header size and the size contained in the
// picture header of the bitstream.
// 
//    Rev 1.37   03 Jan 1997 15:05:16   JMCVEIGH
// Re-inserted check in DecompressQuery that allows a H263 bitstream
// with frame dimensions 320x240 in non-prime decoder to be
// supported. This undos the elimination of this check in rev. 1.33.
// 
//    Rev 1.36   11 Dec 1996 16:02:34   MBODART
// 
// In Decompress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.35   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.34   27 Nov 1996 13:55:18   MBODART
// Added a comment to DecompressQuery that explicitly enumerates the
// formats and transformations that H.261 supports.
// 
//    Rev 1.33   21 Nov 1996 17:27:18   MDUDA
// Disables YUV12 output zoom by 2 and removed 160x120, 240x180,
// and 320x240 acceptance of H263 input.
// 
//    Rev 1.32   15 Nov 1996 08:39:56   MDUDA
// Added 640x480 frame size for H263 and FOURCC_YUV12.
// 
//    Rev 1.31   14 Nov 1996 09:22:34   MBODART
// Disable the ability to select a DCI color convertor, they don't exist!
// However, DCI col. conv. initialization does exist, and differs from
// non-DCI initialization.
// 
//    Rev 1.30   13 Nov 1996 10:58:32   RHAZRA
// H.261 YUV12 decoder now accepts CIF, QCIF, 160x120, 320x240 and 640x480
// 
//    Rev 1.29   12 Nov 1996 08:47:12   JMCVEIGH
// Removed initial arbitrary frame size support, i.e., reverted back
// to rev 1.27. Will hold off on custom picture format support until
// branch for release candidate for PS 3.0.
// 
//    Rev 1.28   11 Nov 1996 11:51:14   JMCVEIGH
// Added initial support for arbitrary frame sizes (H.263+ draft,
// document LBC-96-263). Define H263P to allow frame sizes from
// 4 <= width <= 352 and 4 <= height <= 288, where both width and
// height are multiples of 4.
// 
//    Rev 1.27   20 Oct 1996 13:31:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.26   26 Sep 1996 09:46:00   BECHOLS
// 
// Turned on Snapshot for H263.  This code merely sets up for the Snapshot
// copy, and waits on an event for the decoder to do the copy.  When the
// event is signaled, the Snapshot trigger wakes up and returns the status
// of the copy to the caller.
// 
//    Rev 1.25   25 Sep 1996 17:30:32   BECHOLS
// changed the snapshot code to wait on an event while the decoder
// does the snapshot copy.
// 
//    Rev 1.24   24 Sep 1996 13:51:42   BECHOLS
// 
// Added Snapshot() implementation.
// 
//    Rev 1.23   03 Sep 1996 16:29:22   CZHU
// enable DDRAW, removed define
// 
//    Rev 1.22   18 Jul 1996 09:24:36   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.21   01 Jul 1996 10:05:10   RHAZRA
// 
// Turn off aspect ratio correction for YUY2 color conversion.
// 
//    Rev 1.20   19 Jun 1996 16:38:54   RHAZRA
// 
// Added a #ifdef to coditionally disable DDRAW (YUY2) support
// 
//    Rev 1.19   19 Jun 1996 14:26:28   RHAZRA
// Added code to (i) accept YUY2 as a valid output format (ii) select
// YUY2 color convertor in SelectColorConvertor()
// 
//    Rev 1.18   30 May 1996 17:08:52   RHAZRA
// Added SQCIF support for H263.
// 
//    Rev 1.17   30 May 1996 15:16:38   KLILLEVO
// added YUV12 output
// 
//    Rev 1.16   30 May 1996 10:13:00   KLILLEVO
// 
// removed one cluttering debug statement
// 
//    Rev 1.15   01 Apr 1996 10:26:34   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.14   09 Feb 1996 10:09:22   AKASAI
// Added ifndef RING0 around code in DecompressGetPalette to eliminate
// warning in building RING0 release version of codec.
// 
//    Rev 1.13   11 Jan 1996 16:59:14   DBRUCKS
// 
// cleaned up DecompressQuery
// added setting of bProposedCorrectAspectRatio (in Query) and
// bCorrectAspectRatio (in Begin) if the source dimensions are SQCIF,
// QCIF, or CIF and the destination dimensions are the aspect ratio
// sizes with a possible zoom by two.
// 
//    Rev 1.12   18 Dec 1995 12:51:38   RMCKENZX
// added copyright notice
// 
//    Rev 1.11   13 Dec 1995 13:22:54   DBRUCKS
// 
// Add assertions to verify that the source size is not changing on
// a begin.
// 
//    Rev 1.10   07 Dec 1995 13:02:52   DBRUCKS
// fix spx release build
// 
//    Rev 1.9   17 Nov 1995 15:22:30   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.8   15 Nov 1995 15:57:24   AKASAI
// Remove YVU9 from decompress and decompress_query.
// (Integration point)
// 
//    Rev 1.7   25 Oct 1995 18:12:36   BNICKERS
// Add YUV12 color convertors.  Eliminate YUV9 looking glass support.
// 
//    Rev 1.6   17 Oct 1995 17:31:24   CZHU
// 
// Fixed a bug in DecompressQuery related to YUV12
// 
//    Rev 1.5   18 Sep 1995 08:40:50   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.4   08 Sep 1995 12:11:12   CZHU
// Output compressed size for debugging
// 
//    Rev 1.3   25 Aug 1995 13:58:06   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.2   23 Aug 1995 12:25:12   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.1   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.0   31 Jul 1995 13:00:12   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:14   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern BYTE PalTable[236*4];

#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/***************************************************************************
 *
 * Build16bitModeID().
 *
 * given red, green and blue values showing their maximum value,
 * count the bits standing and then form a decimal digit which lists
 * the number of red bits in the hundreds position, green in the tens
 * position and blue in the ones position.
 *
 * This code is used when the RGB16 table is built so the correct
 * field size will be used.
 *
 * returns the 16 bit mode ID
 *
 * Prototype in rgb16cct.h
 *
 ***************************************************************************/
int Build16bitModeID(I32 red, I32 green, I32 blue)
{
int rval;
int Rbits, Gbits, Bbits;
U32 i;

	for (Rbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Rbits += (red & i) ? 1 : 0;
	for (Gbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Gbits += (green & i) ? 1 : 0;
	for (Bbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Bbits += (blue & i) ? 1 : 0;
	rval = Rbits * 100 + Gbits * 10 + Bbits;

return(rval);
}


/***********************************************************************
 * SelectConvertor(LPDECINST, BOOL);
 * History:        03/18/94 -BEN-
 ***********************************************************************/
static UINT SelectConvertor(
    LPDECINST lpInst,
    LPBITMAPINFOHEADER lpbiDst, 
    BOOL bIsDCI)
{
	UINT    uiCnvtr = 0xFFFF;
	DWORD FAR * pDW = (DWORD FAR *)((LPBYTE)lpbiDst+sizeof(BITMAPINFOHEADER));
	int RequestedMode;

	FX_ENTRY("SelectConvertor")

	/* Force off the DCI color converters because we can not be sure that the
	 * archive data has not changed.
	 * Also, we have no DCI color convertors, so don't select one!
	 */

	bIsDCI = 0;		 

	switch(lpInst->outputDepth)
	{
	case    12:
		if ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Selected 12 bits color convertor: raw YUV12 output\r\n", _fx_));
			uiCnvtr = YUV12NOPITCH;  // YUV12 output
		}
		break;

    case    8:  
		DEBUGMSG(ZONE_INIT, ("%s: Selected  8 bits color convertor\r\n", _fx_));
		if (lpInst->UseActivePalette==0)
		{
			switch(lpInst->XScale)
			{
			case 1:
				if(bIsDCI == TRUE)
				{
					uiCnvtr = CLUT8DCI;
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8DCI convertors selected\r\n", _fx_));
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8 convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8; 
				}
				break;

			case 2:
				if(bIsDCI == TRUE)
				{   
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8ZoomBy2DCI convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8ZoomBy2DCI;
				}
				else 
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8ZoomBy2 convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8ZoomBy2; 
				}
				break;
			} 
		}
		else
		{
			switch(lpInst->XScale)
			{
			case 1:
				if(bIsDCI == TRUE)
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUTAPDCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APDCI;                                       
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUTAPDCI  is selected\r\n", _fx_));
					uiCnvtr = CLUT8APDCI;
				}
				break;

			case 2: 
				if(bIsDCI == TRUE)
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8APZoomBy2DCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APZoomBy2DCI;                                       
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8APZoomBy2DCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APZoomBy2DCI;
				}
				break;
			}   
		}
		break;
 
	case 16:
		// check which mode is
		if (lpbiDst->biCompression == FOURCC_YUY2)
		{
			DEBUGMSG(ZONE_INIT, ("%s: Selected  16 bits YUY2 color convertor\r\n", _fx_));
			uiCnvtr = YUY2DDRAW;
			break;
		}
		else
		{
			if (lpbiDst->biCompression == BI_RGB)
				RequestedMode = 555; /* default rgb16 mode */
			else //if (lpbiDst->biCompression == BI_BITFIELDS)
				RequestedMode = Build16bitModeID(pDW[0], pDW[1], pDW[2]);

			switch (RequestedMode)
			{
				case 555:  
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 555 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16555DCI;
						else
							uiCnvtr = RGB16555;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 555 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16555ZoomBy2DCI;
						else
							uiCnvtr = RGB16555ZoomBy2;
						break;
					}   //end of 555
					break; 

				case 664:   
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 664 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16664DCI;
						else
							uiCnvtr = RGB16664;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 664 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16664ZoomBy2DCI;
						else
							uiCnvtr = RGB16664ZoomBy2;
						break;
					}   //end of 664
					break; 

				case 565:  
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 565 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16565DCI;
						else
							uiCnvtr = RGB16565;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 565 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16565ZoomBy2DCI;
						else
							uiCnvtr = RGB16565ZoomBy2;
						break;
					}   //end of 565
					break; 

				case 655:   
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 655 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16655DCI;
						else
							uiCnvtr = RGB16655;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 655 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16655ZoomBy2DCI;
						else
							uiCnvtr = RGB16655ZoomBy2;
						break;
					}   //end of 655
					break; 

				default:
				break;

				} // switch

	    } // else
	        		           
		break;

	case    24:   
		switch(lpInst->XScale)
		{
			case 1:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 24 bits color convertor\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB24DCI;
			else
				uiCnvtr = RGB24;
			break;

			case 2:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 24 bits color convertor, x2\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB24ZoomBy2DCI;
			else
				uiCnvtr = RGB24ZoomBy2;
			break;
		}
		break;

	case    32:   
		switch(lpInst->XScale)
		{
			case 1:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 32 bits color convertor\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB32DCI;
			else
				uiCnvtr = RGB32;
			break;

			case 2:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 32 bits color convertor, x2\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB32ZoomBy2DCI;
			else
				uiCnvtr = RGB32ZoomBy2;
			break;
		}
		break;
	}

    return(uiCnvtr);
}

/***********************************************************************
 *   DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
 * History:        02/18/94 -BEN-
 *
 * The following table summarizes the transformations that the H.261 decoder
 * and I420 color convertor support.
 *
 * H.261 Decoder Inputs and Outputs
 *
+--------------------------+-------------------------------------------------+
| Input Format             | Supported Output Formats for this Input Format  |
+--------------------------+-------------------------------------------------+
| H.261 FCIF (352 x 288)   | 352 x 288 RGBnn, YUV12 or YUY2                  |
|          or              | 352 x 264 RGBnn (aspect ratio correction)       |
| YUV12 FCIF (352 x 288)   | 704 x 576 RGBnn (zoom by 2)                     |
|                          | 704 x 528 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| H.261 QCIF (176 x 144)   | 176 x 144 RGBnn, YUV12 or YUY2                  |
|          or              | 176 x 132 RGBnn (aspect ratio correction)       |
| YUV12 QCIF (176 x 144)   | 352 x 288 RGBnn (zoom by 2)                     |
|                          | 352 x 264 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| YUV12  640 x 480         |  640 x 480 RGBnn, YUV12 or YUY2                 |
|                          | 1280 x 960 RGBnn (zoom by 2)                    |
+--------------------------+-------------------------------------------------+
| YUV12  320 x 240         | 320 x 240 RGBnn, YUV12 or YUY2                  |
|                          | 640 x 480 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
| YUV12  160 x 120         | 160 x 120 RGBnn, YUV12 or YUY2                  |
|                          | 320 x 240 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
 *
 *  Notes:
 *    o RGBnn represents RGB8, RGB16, RGB24 and RGB32.
 *    o Zoom by 2 and aspect ratio correction are not supported with YUY2 and
 *      YUV12 *output*.
 *    o Aspect ratio correction on output is only supported
 *      when the *input* resolution is exactly QCIF or FCIF.
 *
 ***********************************************************************/
DWORD PASCAL DecompressQuery(
	LPDECINST            lpInst, 
	ICDECOMPRESSEX FAR * lpicDecEx, 
	BOOL                 bIsDCI)
{
    LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;
	int iSrcWidth;
	int iSrcHeight;
	int iDstWidth;
	int iDstHeight;
	BOOL bSupportedSrcDimensions;

	FX_ENTRY("DecompressQuery")

	// Check for NULL pointers
    if ((lpicDecEx == NULL) || (lpicDecEx->lpbiSrc == NULL))
		return (DWORD)ICERR_ERROR;

	// Set source and destination bitmap info headers
	lpbiSrc = lpicDecEx->lpbiSrc;
    lpbiDst = lpicDecEx->lpbiDst;

	// Check the source dimensions
	iSrcWidth = lpbiSrc->biWidth;
	iSrcHeight = lpbiSrc->biHeight;
	bSupportedSrcDimensions = FALSE;
	if (lpbiSrc->biCompression == FOURCC_H263)
	{
		/* H261 supports CIF and QCIF 
		 * H263 supports CIF, SQCIF, and QCIF.
		 * H263 also may need 160x120, 240x180, and 320x240 as Tom put special
		 * code into exbase to accept these.
		 */
#ifdef H263P
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
#ifndef H261
#ifdef USE_BILINEAR_MSH26X
			(iSrcWidth == 80 && iSrcHeight == 64)  ||
#endif
			(iSrcWidth == 128 && iSrcHeight == 96)  ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 240 && iSrcHeight == 180) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
#endif
			(iSrcWidth == 176 && iSrcHeight == 144))
			bSupportedSrcDimensions = TRUE;
#endif // H263P
	}
#ifdef USE_BILINEAR_MSH26X
	else if (lpbiSrc->biCompression == FOURCC_H26X)
	{
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
	}
#endif
	else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
#ifndef H261
		if (((iSrcWidth <= 352 && iSrcHeight <= 288) &&
		     (iSrcWidth >= 4 && iSrcHeight >= 4) &&
			 ((iSrcWidth & ~3) == iSrcWidth) &&
			 ((iSrcHeight & ~3) == iSrcHeight)) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
            (iSrcWidth == 176 && iSrcHeight == 144) ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#endif
			bSupportedSrcDimensions = TRUE;
	}
	
	if (! bSupportedSrcDimensions )
	{
		ERRORMESSAGE(("%s: Unsupported source dimensions in query\r\n", _fx_));
		return (DWORD)ICERR_UNSUPPORTED;
	}
	
	/* Stop if just querying input
	 */
    if (lpbiDst == NULL)
		return ICERR_OK;                               

	/* Check the bit depth
	 */
	switch (lpbiDst->biBitCount)
	{
	case 8:  
		DEBUGMSG(ZONE_INIT, ("%s: Checking 8 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
			return((DWORD)ICERR_BADFORMAT); 
		break;

	case 12: 
		DEBUGMSG(ZONE_INIT, ("%s: Checking 12 bits\r\n", _fx_));
		if ((lpbiDst->biCompression != FOURCC_YUV12) && (lpbiDst->biCompression != FOURCC_IYUV)) 
	    	return((DWORD)ICERR_BADFORMAT); 
		break;
 

	case 16:  
		DEBUGMSG(ZONE_INIT, ("%s: Checking 16 bits\r\n", _fx_));
		switch (lpicDecEx->lpbiDst->biCompression)
		{
		case BI_RGB: 
			DEBUGMSG(ZONE_INIT, ("%s: BI_RGB\r\n", _fx_));
			break;
		case BI_BITFIELDS: 
			DEBUGMSG(ZONE_INIT, ("%s: BI_BITFIELDS\r\n", _fx_));
			break;
		/*
		 * This definition of BI_BITMAP is here because MS has not provided
		 * a "standard" definition. When MS does provide it, it will likely be
		 * in compddk.h. At that time this definition should be removed.
		 */
		#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
		case BI_BITMAP:  
			DEBUGMSG(ZONE_INIT, ("%s: Checking BI_BITMAP\r\n", _fx_));
			if (lpicDecEx->lpbiDst->biYPelsPerMeter != 0)
            {   
                // output shouldn't cross a segment boundary in a scan line.
	    		return((DWORD)ICERR_BADFORMAT); 
			}
	    break;

		case FOURCC_YUY2:
			DEBUGMSG(ZONE_INIT, ("%s: Checking YUY2 for DirectDraw\r\n", _fx_));
		break;
		default:
			return((DWORD)ICERR_BADFORMAT); 
		} // switch biCompression
  		break;

	case 24:
		DEBUGMSG(ZONE_INIT, ("%s: Checking 24 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
		{
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	case 32:
		DEBUGMSG(ZONE_INIT, ("%s: Checking 32 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
		{
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	default:
	    return((DWORD)ICERR_BADFORMAT); 
		break;
	}

/*
    if(lpbiDst->biCompression != BI_RGB && lpbiDst->biCompression != FOURCC_IF09)    // check color space
	{
#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
	if(lpbiDst->biCompression != BI_BITMAP)
	    return (DWORD)ICERR_UNSUPPORTED;
	if(lpbiDst->biYPelsPerMeter != 0)
	    {   
		
	    return (DWORD)ICERR_UNSUPPORTED;
	    }
	}
*/

   	//  Find the destination dimensions
	if (bIsDCI == TRUE)
	{
		iDstWidth = lpicDecEx->dxDst;
		iDstHeight = lpicDecEx->dyDst;
	}
	else
	{
		iDstWidth = lpbiDst->biWidth;
		iDstHeight = lpbiDst->biHeight;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Query destination %d,%d\r\n", _fx_, iDstWidth, iDstHeight));

	// For the sake of the checks below, we need to take the absolute value
	// of the destination height.
	if(iDstHeight < 0)
	{
		iDstHeight = -iDstHeight;
	}

	// Check out the instance pointer
	if (!lpInst)
		return ICERR_ERROR;

	// Check the destination dimensions
	if ((iSrcWidth == iDstWidth) && (iSrcHeight == iDstHeight))
	{
		lpInst->pXScale = lpInst->pYScale = 1;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if ( ((iSrcWidth<<1) == iDstWidth) && ((iSrcHeight<<1) == iDstHeight) )
	{
		lpInst->pXScale = lpInst->pYScale = 2;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if (
#ifndef H261
	         ((iSrcWidth == 128) && (iSrcHeight ==  96)) ||
#endif
	         ((iSrcWidth == 176) && (iSrcHeight == 144)) ||
			     ((iSrcWidth == 352) && (iSrcHeight == 288))
			 )
	{
		/* Support aspect ratio correction for SQCIF, QCIF, and CIF
		 */
		if ( (iSrcWidth == iDstWidth) && ((iSrcHeight*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 1;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else if ( ((iSrcWidth<<1) == iDstWidth) && 
		          (((iSrcHeight<<1)*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 2;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else
		{
			return(DWORD)ICERR_UNSUPPORTED;
		}
	}
	else
	{
	    return(DWORD)ICERR_UNSUPPORTED;
	}

    /* check color depth 
     */
    if(lpbiDst->biBitCount !=  8 &&
       lpbiDst->biBitCount != 16 &&
       lpbiDst->biBitCount != 12  &&   // raw YUV12 output
       lpbiDst->biBitCount != 24 &&
       lpbiDst->biBitCount != 32)
	{
		return(DWORD)ICERR_UNSUPPORTED;
	}

    lpInst->xres = (WORD)lpbiSrc->biWidth;
    lpInst->yres = (WORD)lpbiSrc->biHeight;

	/* aspect ratio correction with YUV12 is not supported 
	 */
	if (lpInst->bProposedCorrectAspectRatio && 
	    ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming in DirectDraw */

	if ( ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     (lpbiDst->biCompression == FOURCC_YUY2) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming for YUV12 */

	if ( ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}
    return (DWORD)ICERR_OK;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL DecompressGetPalette(
    LPDECINST lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    LPBYTE lpPalArea, PalStart;  
#ifndef RING0
    HDC hDC;
#endif
    BYTE tmp;
    int i;
//    int iUseActivePalette;
    ICDECOMPRESSEX icDecEx;

	FX_ENTRY("DecompressGetPalette")

    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = lpbiDst;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	if (lpbiDst == NULL) 
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
        return (DWORD)ICERR_ERROR;
	}

    if(lpbiDst->biBitCount != 8)
    {
		ERRORMESSAGE(("%s: called with biBitCount != 8\r\n", _fx_));
        return (DWORD)ICERR_ERROR;
    }
    lpbiDst->biClrUsed = 256;        /* specify all used */
    lpbiDst->biClrImportant = 0;

#ifndef RING0
    /* copy system palette entries (valid entries are 0-9 and 246-255) */
	hDC = GetDC(NULL);
	lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
	GetSystemPaletteEntries(hDC, 0, 256, (PALETTEENTRY FAR *)lpPalArea);
	ReleaseDC(NULL, hDC);  
#endif
/*
#ifdef DEBUG
	iUseActivePalette = GetPrivateProfileInt("indeo", "UseActivePalette", 0, "system.ini");
	if (iUseActivePalette) {
		for (i = 0; i < 256; i++) {
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea += 4;
		}
		lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
		_fmemcpy(lpInst->ActivePalette, lpPalArea, sizeof(lpInst->ActivePalette));
		lpInst->UseActivePalette = 1;
	}
#endif
*/

	if (!lpInst)
		return ICERR_ERROR;

#ifndef RING0
    if (lpInst->UseActivePalette == 1) 
      {
		#ifdef WIN32
        memcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
		#else
        _fmemcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
		#endif
		DEBUGMSG(ZONE_INIT, ("%s: Return the current active palette saved...\r\n", _fx_));
	}  
	else
	{  
#endif
	DEBUGMSG(ZONE_INIT, ("%s: return the fixed palette...\r\n", _fx_));
	PalStart = (LPBYTE)lpbiDst + (int)lpbiDst->biSize;
	lpPalArea = PalStart + 40;        // fill in starting from the 10th
	for(i = 0; i < (236 << 2); i++)
		*lpPalArea++ = PalTable[i]; 

	lpPalArea = PalStart;   // reverse r&b: dealing with DIBs
	for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
							// fixed by CZHU, 1/23/95
	{
		tmp = *lpPalArea;
		*lpPalArea = *(lpPalArea+2);
		*(lpPalArea+2) = tmp;
		lpPalArea+=4;
	} 
#ifndef RING0
   }
#endif

    return (DWORD)ICERR_OK;
}


/***********************************************************************
 * DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER,
 *                                  LPBITMAPINFOHEADER);
 * Description:    This allows us to suggest a good format to decompress to.
 *
 * History:        02/18/94 -BEN-
 ***********************************************************************/
DWORD PASCAL DecompressGetFormat(
#ifdef USE_BILINEAR_MSH26X
    LPINST             pi, 
#else
    LPDECINST          lpInst, 
#endif
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
#ifdef USE_BILINEAR_MSH26X
	LPDECINST lpInst = (LPDECINST)pi->DecompPtr;
#endif
	DWORD dw;
	ICDECOMPRESSEX icDecEx;
	LPBYTE lpPalArea;
	int i;
	BYTE tmp;
	HDC hDC;
	BOOL f8Bit;

	FX_ENTRY("DecompressGetFormat")

	// check input format - dont check output: being asked to give one back
	icDecEx.lpbiSrc = lpbiSrc;
	icDecEx.lpbiDst = NULL;
	if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
		return dw;

	// If the current disply mode is 8 bit return a size large enough
	// to hold a 256 palette after the BMIh
	hDC = GetDC(NULL);
	f8Bit = (8 == GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES));
	ReleaseDC(NULL, hDC);
#ifdef FORCE_8BIT_OUTPUT // { FORCE_8BIT_OUTPUT
	f8Bit = TRUE;
#endif // } FORCE_8BIT_OUTPUT
#if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT) // { if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)
	f8Bit = FALSE;
#endif // } if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)

	// if lpbiDst == NULL return size required to hold a output format
	// (add palette size)
	if (lpbiDst == NULL) 
		return(sizeof(BITMAPINFOHEADER) + (int)(f8Bit ? 1024 : 0));

	// check for NULL parameter
	if (lpbiSrc == NULL) 
	{
		// This was probably verified in DecompressQuery, but just to be safe...
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return (DWORD)ICERR_ERROR;
	}

	lpbiDst->biSize = sizeof(BITMAPINFOHEADER);
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
		lpbiDst->biHeight = lpbiSrc->biHeight << 1;
	}
	else
	{
#endif
#ifdef FORCE_ZOOM_BY_2 // { FORCE_ZOOM_BY_2
		lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
		lpbiDst->biHeight = lpbiSrc->biHeight << 1;
#else // }{ FORCE_ZOOM_BY_2
		lpbiDst->biWidth  = lpbiSrc->biWidth;
		lpbiDst->biHeight = lpbiSrc->biHeight;
#endif // } FORCE_ZOOM_BY_2
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#ifdef FORCE_16BIT_OUTPUT // { FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = 16;
#else // }{ FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = (int)(f8Bit ? 8 : 24);
#endif // } FORCE_16BIT_OUTPUT
	lpbiDst->biPlanes = 1;
	lpbiDst->biCompression =  BI_RGB;
	lpbiDst->biXPelsPerMeter = 0;
	lpbiDst->biYPelsPerMeter = 0;
	lpbiDst->biSizeImage = (DWORD) WIDTHBYTES(lpbiDst->biWidth * lpbiDst->biBitCount) * lpbiDst->biHeight;
	lpbiDst->biClrUsed = lpbiDst->biClrImportant = 0;

	if (f8Bit)
	{
		// Copy the palette
		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER) + 40;        // fill in starting from the 10th
		for(i = 0; i < (236 << 2); i++)
			*lpPalArea++ = PalTable[i]; 

		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER);   // reverse r&b: dealing with DIBs
		for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
								// fixed by CZHU, 1/23/95
		{
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea+=4;
		}
	}

	return ICERR_OK;
}

/**********************************************************************
 * DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL)
 *  Description:    Provides codec indication to prepare to receive
 *                 decompress requests for a particular input to output
 *                 conversion.  Begins arrive asynchronously, and should
 *                 result in the codec adapting to the changes specified,
 *                 if any.
 *
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressBegin(
    LPDECINST           lpInst, 
    ICDECOMPRESSEX FAR *lpicDecEx, 
    BOOL                bIsDCI)
{
	int     CodecID;
	DWORD   dw;
	UINT    ClrCnvtr;
	LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;

	FX_ENTRY("DecompressBegin")

	// Check for NULL parameters
	if (lpInst == NULL || lpicDecEx == NULL) 
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return (DWORD)ICERR_ERROR;
	}

	// Set source and destination pointers
	lpbiSrc = lpicDecEx->lpbiSrc;
	lpbiDst = lpicDecEx->lpbiDst;

    // at begin need to know input and output sizes
    if (lpbiSrc == NULL || lpbiDst == NULL)
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if(lpInst->Initialized == TRUE)	
    {
		/* We assume the source dimensions never change.  If they do change
		 * we should terminate the instance because the allocations are
		 * based on dimensions.  Until we add code to do that we need this
		 * assertion.
		 */
    	ASSERT(lpInst->xres == (WORD)lpbiSrc->biWidth);
    	ASSERT(lpInst->yres == (WORD)lpbiSrc->biHeight);
		
		if(lpbiDst != NULL)	
        { 
		    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
            {
				return(dw);    // error
			} 
            else 
            {    // apply changes
				lpInst->XScale = lpInst->pXScale;
				lpInst->YScale = lpInst->pYScale;
				lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
				lpInst->outputDepth = lpbiDst->biBitCount;
				ClrCnvtr = SelectConvertor(lpInst,lpbiDst, bIsDCI); 
				if (ClrCnvtr != lpInst->uColorConvertor ) 
                {
					if((dw = H263TermColorConvertor(lpInst)) == ICERR_OK)
					    dw = H263InitColorConvertor(lpInst, ClrCnvtr); 
					lpInst->uColorConvertor=ClrCnvtr; 
				}
				return(dw);
			}
	    }
	}

    // first time begin - check if this is a format I like
    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
    {
		return(dw);    // error
	} 
    else 
    {    // apply proposed format to 'current' format
		lpInst->XScale = lpInst->pXScale;
		lpInst->YScale = lpInst->pYScale;
		lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
		lpInst->outputDepth = lpbiDst->biBitCount;
	}
    
#ifdef USE_BILINEAR_MSH26X
    if ((lpbiSrc->biCompression == FOURCC_H263) || (lpbiSrc->biCompression == FOURCC_H26X))
#else
    if  (lpbiSrc->biCompression == FOURCC_H263)
#endif
    {
         CodecID = H263_CODEC;
    }
    else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	     CodecID = YUV12_CODEC;
	}

    if(dw = H263InitDecoderInstance(lpInst, CodecID))
	{
		return(dw);
	}
    ClrCnvtr = SelectConvertor(lpInst, lpbiDst, bIsDCI);
    dw = H263InitColorConvertor(lpInst, ClrCnvtr);
    
    return(dw);
}


/**********************************************************************
 * DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESS FAR *, DWORD);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL Decompress(
	LPDECINST           lpInst, 
	ICDECOMPRESSEX FAR *lpicDecEx, 
	DWORD               dwSize,
	BOOL                bIsDCI)
{
	DWORD ret = (DWORD) ICERR_ERROR;

	FX_ENTRY("Decompress")

	// Check for NULL parameters
    if ((lpInst == NULL) || (lpInst->Initialized != TRUE) || (lpicDecEx == NULL) ||
		(lpicDecEx->lpbiSrc == NULL) || (lpicDecEx->lpbiDst == NULL)) 
    {
		ret = (DWORD) ICERR_ERROR;
		goto done;
 	} 

#ifdef USE_BILINEAR_MSH26X
    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) || (lpicDecEx->lpbiSrc->biCompression == FOURCC_H26X)
#else
    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) 
#endif
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_YUV12)
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_IYUV) )
	{ 
		try
		{
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI, TRUE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		}
		catch (...)
		{
			// For a DEBUG build, display a message and pass the exception up.
			// For a release build, stop the exception here and return an error
			// code.  This gives upstream code a chance to gracefully recover.
			// We also need to clear the floating point control word, otherwise
			// the upstream code may incur an exception the next time it tries
			// a floating point operation (presuming this exception was due
			// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
			ERRORMESSAGE(("%s: Exception during H263Decompress!!!\r\n", _fx_));
			throw;
#else
			_clearfp();
			ret = (DWORD) ICERR_ERROR;
#endif
		}
	}

done:
	return ret;
}


/**********************************************************************
 * DWORD PASCAL DecompressEnd(LPDECINST);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressEnd(LPDECINST lpInst)
{
	if(lpInst && lpInst->Initialized == TRUE)
	{
		H263TermColorConvertor(lpInst);
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		H263TermDecoderInstance(lpInst, TRUE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		H263TermDecoderInstance(lpInst);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	}

	return ICERR_OK;
}


/*****************************************************************************
 *
 * DecompressSetPalette() is called from the ICM_DECOMPRESS_SET_PALETTE
 * message.
 *
 * Fill in the palette using lpParam1.
 *
 ****************************************************************************/
DWORD PASCAL DecompressSetPalette(LPDECINST pinst,
						 LPBITMAPINFOHEADER lpbi,
						 LPBITMAPINFOHEADER unused)
{
	int i;
	unsigned char FAR * palette;
	RGBQUAD FAR *palptr;

	FX_ENTRY("DecompressSetPalette")

	// Check for NULL parameter
	if (pinst == NULL)
	{
		return (DWORD)ICERR_ERROR;
	}

	pinst->InitActivePalette = 0;	/* must re-init AP at Begin */
	pinst->UseActivePalette = 0;	/* must re-init AP at Begin */

	if (lpbi && (lpbi->biBitCount == 8 && lpbi->biCompression == 0))
	{
		palette = (unsigned char FAR *)lpbi + (int)lpbi->biSize;

		// Check if palette passed is identity
		for (i = 0*4, palptr = (RGBQUAD FAR *)PalTable; i < 236*4; 
             i += 4, palptr++)
		{
			if (palette[i+40] != palptr->rgbRed ||
				palette[i+41] != palptr->rgbGreen ||
				palette[i+42] != palptr->rgbBlue
               )
			break;
		}

		if (i < 236*4)
		{	/* broke early - not the identity palette */
			/* Actually RGBQUAD (BGR) format. */
			if (
#ifdef WIN32
				memcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
#else
				_fmemcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
#endif
				)
			{	/* same as last palette - don't re-init AP */
				DEBUGMSG(ZONE_INIT, ("%s: Use current active palette\r\n", _fx_));
				pinst->UseActivePalette  = 1;
				pinst->InitActivePalette = 1;
			}
			else
			{
				DEBUGMSG(ZONE_INIT, ("%s: Use new active palette\r\n", _fx_));
#ifdef WIN32
				memcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
#else
				_fmemcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
#endif
				pinst->UseActivePalette = 1;
			}
		}
		else
		{   
			DEBUGMSG(ZONE_INIT, ("%s: Use fixed palette\r\n", _fx_));
		}
	}
	else
	{      
		DEBUGMSG(ZONE_INIT, ("%s: Use NULL (fixed) palette\r\n", _fx_));
	}

	return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxidctab.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:39:54  $
// $Archive:   S:\h26x\src\dec\dxidctab.cpv  $
// $Header:   S:\h26x\src\dec\dxidctab.cpv   1.6   30 Aug 1996 08:39:54   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxidctab.cpv  $
// 
//    Rev 1.6   30 Aug 1996 08:39:54   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.5   17 Jul 1996 15:34:06   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.4   08 Mar 1996 16:46:36   AGUPTA2
// Added data_seg pragma. Added ClampTbl def; used by IDCT and dxblkadd.cpp.
// Deleted ClipPixIntra, ClipPixInter.  MapMatrix is an array of bytes instead of 
// DWORDs.
// 
// 
//    Rev 1.3   22 Dec 1995 13:55:56   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:39:18   AKASAI
// 
// Changed ClipPix tables to ClipPixIntra table and added
// ClipPixInter table.
// 
//    Rev 1.1   22 Aug 1995 10:29:08   CZHU
// Fixed include file dxfm.h instead of fm.h
// 
//    Rev 1.0   21 Aug 1995 14:39:02   CZHU
// Initial revision.


// FMapIDCT tables

#include "precomp.h"

#pragma data_seg("IARDATA2")
const I32 ROUNDER = 0x801000;

const I8  Unique[NUM_ELEM] = {
0x1, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
};    // 64 elements


const I8  PClass[NUM_ELEM] = {
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
};    // 64 elements


const I32 KernelCoeff[NUM_ELEM][10] = {
0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x07b2, 0x0686, 0x045b, 0x0187, 0x0587, 0x03b2, 0x014c, 0x0278, 0x00dd, 0x004d,
0x073f, 0x0300, 0x0625, 0x028b, 0x041b, 0x01b3, 0x0171, 0x0098, 0x0000, 0x0000,
0x0686, 0x0187, 0x07b2, 0x045b, 0x0587, 0x014c, 0x03b2, 0x00dd, 0x0278, 0x004d,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x07b2, 0x0187, 0x0686, 0x03b2, 0x014c, 0x0587, 0x0278, 0x00dd, 0x004d,
0x0300, 0x073f, 0x028b, 0x0625, 0x01b3, 0x041b, 0x0098, 0x0171, 0x0000, 0x0000,
0x0187, 0x045b, 0x0686, 0x07b2, 0x014c, 0x03b2, 0x0587, 0x00dd, 0x0278, 0x004d,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x073f, 0x0625, 0x041b, 0x0171, 0x0300, 0x028b, 0x01b3, 0x0098, 0x0000, 0x0000,
0x06d4, 0x02d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0625, 0x0171, 0x073f, 0x041b, 0x028b, 0x0098, 0x0300, 0x01b3, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x041b, 0x073f, 0x0171, 0x0625, 0x01b3, 0x0300, 0x0098, 0x028b, 0x0000, 0x0000,
0x02d4, 0x06d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0171, 0x041b, 0x0625, 0x073f, 0x0098, 0x01b3, 0x028b, 0x0300, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0686, 0x0587, 0x03b2, 0x014c, 0x0187, 0x00dd, 0x004d, 0x07b2, 0x045b, 0x0278,
0x0625, 0x028b, 0x0171, 0x0098, 0x073f, 0x0300, 0x041b, 0x01b3, 0x0000, 0x0000,
0x0587, 0x014c, 0x0686, 0x03b2, 0x004d, 0x0187, 0x00dd, 0x07b2, 0x045b, 0x0278,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x03b2, 0x0686, 0x014c, 0x0587, 0x00dd, 0x0187, 0x004d, 0x045b, 0x07b2, 0x0278,
0x028b, 0x0625, 0x0098, 0x0171, 0x0300, 0x073f, 0x01b3, 0x041b, 0x0000, 0x0000,
0x014c, 0x03b2, 0x0587, 0x0686, 0x004d, 0x00dd, 0x0187, 0x045b, 0x07b2, 0x0278,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x03b2, 0x0278, 0x00dd, 0x07b2, 0x0686, 0x0187, 0x014c, 0x004d, 0x0587,
0x041b, 0x01b3, 0x073f, 0x0300, 0x0171, 0x0098, 0x0625, 0x028b, 0x0000, 0x0000,
0x03b2, 0x00dd, 0x045b, 0x0278, 0x0686, 0x0187, 0x07b2, 0x014c, 0x004d, 0x0587,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0278, 0x045b, 0x00dd, 0x03b2, 0x07b2, 0x0187, 0x0686, 0x004d, 0x014c, 0x0587,
0x01b3, 0x041b, 0x0300, 0x073f, 0x0098, 0x0171, 0x028b, 0x0625, 0x0000, 0x0000,
0x00dd, 0x0278, 0x03b2, 0x045b, 0x0187, 0x0686, 0x07b2, 0x004d, 0x014c, 0x0587,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0300, 0x028b, 0x01b3, 0x0098, 0x073f, 0x0625, 0x041b, 0x0171, 0x0000, 0x0000,
0x02d4, 0x012b, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x028b, 0x0098, 0x0300, 0x01b3, 0x0625, 0x0171, 0x073f, 0x041b, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x01b3, 0x0300, 0x0098, 0x028b, 0x041b, 0x073f, 0x0171, 0x0625, 0x0000, 0x0000,
0x012b, 0x02d4, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0098, 0x01b3, 0x028b, 0x0300, 0x0171, 0x041b, 0x0625, 0x073f, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0187, 0x014c, 0x00dd, 0x004d, 0x045b, 0x03b2, 0x0278, 0x0686, 0x0587, 0x07b2,
0x0171, 0x0098, 0x041b, 0x01b3, 0x0625, 0x028b, 0x073f, 0x0300, 0x0000, 0x0000,
0x014c, 0x004d, 0x0187, 0x00dd, 0x03b2, 0x045b, 0x0278, 0x0587, 0x0686, 0x07b2,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x00dd, 0x0187, 0x004d, 0x014c, 0x0278, 0x045b, 0x03b2, 0x0686, 0x0587, 0x07b2,
0x0098, 0x0171, 0x01b3, 0x041b, 0x028b, 0x0625, 0x0300, 0x073f, 0x0000, 0x0000,
0x004d, 0x00dd, 0x014c, 0x0187, 0x0278, 0x03b2, 0x045b, 0x0587, 0x0686, 0x07b2,
};    // [64][10] elements


const I8 MapMatrix[NUM_ELEM][KERNEL_SIZE] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x01, 0x04, 0x05, 0x06,
0x02, 0x05, 0x07, 0x08, 0x03, 0x06, 0x08, 0x09,
0x00, 0x01, 0x09, 0x08, 0x02, 0x03, 0x0b, 0x0a,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x04, 0x0f, 0x0a, 0x10,
0x06, 0x11, 0x0d, 0x12, 0x05, 0x13, 0x0b, 0x11,
0x00, 0x04, 0x04, 0x00, 0x01, 0x05, 0x05, 0x01,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x04, 0x0d, 0x05, 0x06,
0x07, 0x0a, 0x08, 0x04, 0x08, 0x0c, 0x09, 0x05,
0x00, 0x09, 0x01, 0x08, 0x02, 0x0b, 0x03, 0x0a,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x04, 0x0f, 0x06, 0x0c,
0x07, 0x12, 0x05, 0x0b, 0x09, 0x11, 0x04, 0x0a,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x01, 0x02, 0x05, 0x04,
0x04, 0x05, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x04, 0x0d, 0x0e, 0x0f,
0x0c, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x01, 0x03, 0x03, 0x01,
0x03, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x04, 0x0d, 0x06, 0x07,
0x0c, 0x05, 0x0e, 0x0f, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x02, 0x03, 0x00, 0x05,
0x05, 0x00, 0x03, 0x02, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x04, 0x0d, 0x06, 0x0f,
0x0c, 0x05, 0x0e, 0x07, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0d, 0x0f, 0x10,
0x11, 0x0a, 0x12, 0x0e, 0x12, 0x0c, 0x13, 0x0f,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x0c, 0x0d, 0x05, 0x04, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0b, 0x04, 0x05, 0x06,
0x0c, 0x05, 0x07, 0x08, 0x0d, 0x06, 0x08, 0x09,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x06, 0x02, 0x02, 0x06, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x10, 0x0c,
0x11, 0x08, 0x0f, 0x0b, 0x13, 0x07, 0x0e, 0x0a,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x0c, 0x05, 0x0d, 0x04, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x05, 0x0a, 0x06,
0x10, 0x07, 0x0d, 0x08, 0x0f, 0x09, 0x0b, 0x07,
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00,
0x02, 0x03, 0x01, 0x00, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x04, 0x01, 0x02, 0x03,
0x04, 0x01, 0x02, 0x03, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x03,
0x02, 0x00, 0x00, 0x02, 0x01, 0x03, 0x03, 0x01,
0x00, 0x05, 0x02, 0x03, 0x04, 0x01, 0x06, 0x07,
0x04, 0x01, 0x06, 0x07, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x02, 0x01, 0x03, 0x00,
0x02, 0x01, 0x03, 0x00, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x04, 0x01, 0x06, 0x03,
0x04, 0x01, 0x06, 0x03, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x0a, 0x10,
0x06, 0x07, 0x03, 0x08, 0x05, 0x09, 0x01, 0x07,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x05, 0x06, 0x02,
0x07, 0x12, 0x0f, 0x0b, 0x09, 0x11, 0x0e, 0x0a,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x0b, 0x04, 0x0f, 0x10,
0x02, 0x0f, 0x07, 0x08, 0x03, 0x10, 0x08, 0x09,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x03, 0x0f, 0x06,
0x07, 0x0a, 0x08, 0x0e, 0x08, 0x0c, 0x09, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03,
0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f,
0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x05, 0x03, 0x00, 0x02,
0x02, 0x00, 0x03, 0x05, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06, 0x07,
0x04, 0x0d, 0x0e, 0x0f, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x03, 0x01, 0x01, 0x03,
0x01, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x0c, 0x05, 0x0e, 0x0f,
0x04, 0x0d, 0x06, 0x07, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x04, 0x02, 0x05, 0x01,
0x01, 0x05, 0x02, 0x04, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x0c, 0x05, 0x0e, 0x07,
0x04, 0x0d, 0x06, 0x0f, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x10, 0x0c,
0x07, 0x08, 0x05, 0x01, 0x13, 0x11, 0x0e, 0x0a,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x03, 0x05, 0x06,
0x07, 0x0a, 0x12, 0x0e, 0x12, 0x02, 0x09, 0x05,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x0a, 0x10,
0x06, 0x11, 0x03, 0x08, 0x0f, 0x09, 0x0b, 0x11,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0b, 0x04, 0x0f, 0x06,
0x02, 0x0f, 0x07, 0x12, 0x0d, 0x06, 0x12, 0x09,
};    // [64][16] elements

const U8 ClampTbl[CLIP_RANGE] = {
             0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 
            ,0x08 ,0x09 ,0x0a ,0x0b ,0x0c ,0x0d ,0x0e ,0x0f 
            ,0x10 ,0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 
            ,0x18 ,0x19 ,0x1a ,0x1b ,0x1c ,0x1d ,0x1e ,0x1f 
            ,0x20 ,0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 
            ,0x28 ,0x29 ,0x2a ,0x2b ,0x2c ,0x2d ,0x2e ,0x2f 
            ,0x30 ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 
            ,0x38 ,0x39 ,0x3a ,0x3b ,0x3c ,0x3d ,0x3e ,0x3f 
            ,0x40 ,0x41 ,0x42 ,0x43 ,0x44 ,0x45 ,0x46 ,0x47 
            ,0x48 ,0x49 ,0x4a ,0x4b ,0x4c ,0x4d ,0x4e ,0x4f 
            ,0x50 ,0x51 ,0x52 ,0x53 ,0x54 ,0x55 ,0x56 ,0x57 
            ,0x58 ,0x59 ,0x5a ,0x5b ,0x5c ,0x5d ,0x5e ,0x5f 
            ,0x60 ,0x61 ,0x62 ,0x63 ,0x64 ,0x65 ,0x66 ,0x67 
            ,0x68 ,0x69 ,0x6a ,0x6b ,0x6c ,0x6d ,0x6e ,0x6f 
            ,0x70 ,0x71 ,0x72 ,0x73 ,0x74 ,0x75 ,0x76 ,0x77 
            ,0x78 ,0x79 ,0x7a ,0x7b ,0x7c ,0x7d ,0x7e ,0x7f 
            ,0x80 ,0x81 ,0x82 ,0x83 ,0x84 ,0x85 ,0x86 ,0x87 
            ,0x88 ,0x89 ,0x8a ,0x8b ,0x8c ,0x8d ,0x8e ,0x8f 
            ,0x90 ,0x91 ,0x92 ,0x93 ,0x94 ,0x95 ,0x96 ,0x97 
            ,0x98 ,0x99 ,0x9a ,0x9b ,0x9c ,0x9d ,0x9e ,0x9f 
            ,0xa0 ,0xa1 ,0xa2 ,0xa3 ,0xa4 ,0xa5 ,0xa6 ,0xa7 
            ,0xa8 ,0xa9 ,0xaa ,0xab ,0xac ,0xad ,0xae ,0xaf 
            ,0xb0 ,0xb1 ,0xb2 ,0xb3 ,0xb4 ,0xb5 ,0xb6 ,0xb7 
            ,0xb8 ,0xb9 ,0xba ,0xbb ,0xbc ,0xbd ,0xbe ,0xbf 
            ,0xc0 ,0xc1 ,0xc2 ,0xc3 ,0xc4 ,0xc5 ,0xc6 ,0xc7 
            ,0xc8 ,0xc9 ,0xca ,0xcb ,0xcc ,0xcd ,0xce ,0xcf 
            ,0xd0 ,0xd1 ,0xd2 ,0xd3 ,0xd4 ,0xd5 ,0xd6 ,0xd7 
            ,0xd8 ,0xd9 ,0xda ,0xdb ,0xdc ,0xdd ,0xde ,0xdf 
            ,0xe0 ,0xe1 ,0xe2 ,0xe3 ,0xe4 ,0xe5 ,0xe6 ,0xe7 
            ,0xe8 ,0xe9 ,0xea ,0xeb ,0xec ,0xed ,0xee ,0xef 
            ,0xf0 ,0xf1 ,0xf2 ,0xf3 ,0xf4 ,0xf5 ,0xf6 ,0xf7 
            ,0xf8 ,0xf9 ,0xfa ,0xfb ,0xfc ,0xfd ,0xfe ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
   };

/*
U8 ClipPixIntra[64+256+64] = {
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03,
0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b,
0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13,
0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b,
0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23,
0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b,
0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33,
0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b,
0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43,
0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b,
0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53,
0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b,
0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63,
0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b,
0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73,
0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b,
0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b,
0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93,
0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b,
0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3,
0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3,
0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb,
0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3,
0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb,
0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3,
0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb,
0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3,
0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb,
0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3,
0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb,
0xfc, 0xfd, 0xfe, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
};    // 64+256+64 elements

I32 ClipPixInter[CLIP_RANGE] = {
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff01, 0xffffff02, 0xffffff03,
0xffffff04, 0xffffff05, 0xffffff06, 0xffffff07,
0xffffff08, 0xffffff09, 0xffffff0a, 0xffffff0b,
0xffffff0c, 0xffffff0d, 0xffffff0e, 0xffffff0f,
0xffffff10, 0xffffff11, 0xffffff12, 0xffffff13,
0xffffff14, 0xffffff15, 0xffffff16, 0xffffff17,
0xffffff18, 0xffffff19, 0xffffff1a, 0xffffff1b,
0xffffff1c, 0xffffff1d, 0xffffff1e, 0xffffff1f,
0xffffff20, 0xffffff21, 0xffffff22, 0xffffff23,
0xffffff24, 0xffffff25, 0xffffff26, 0xffffff27,
0xffffff28, 0xffffff29, 0xffffff2a, 0xffffff2b,
0xffffff2c, 0xffffff2d, 0xffffff2e, 0xffffff2f,
0xffffff30, 0xffffff31, 0xffffff32, 0xffffff33,
0xffffff34, 0xffffff35, 0xffffff36, 0xffffff37,
0xffffff38, 0xffffff39, 0xffffff3a, 0xffffff3b,
0xffffff3c, 0xffffff3d, 0xffffff3e, 0xffffff3f,
0xffffff40, 0xffffff41, 0xffffff42, 0xffffff43,
0xffffff44, 0xffffff45, 0xffffff46, 0xffffff47,
0xffffff48, 0xffffff49, 0xffffff4a, 0xffffff4b,
0xffffff4c, 0xffffff4d, 0xffffff4e, 0xffffff4f,
0xffffff50, 0xffffff51, 0xffffff52, 0xffffff53,
0xffffff54, 0xffffff55, 0xffffff56, 0xffffff57,
0xffffff58, 0xffffff59, 0xffffff5a, 0xffffff5b,
0xffffff5c, 0xffffff5d, 0xffffff5e, 0xffffff5f,
0xffffff60, 0xffffff61, 0xffffff62, 0xffffff63,
0xffffff64, 0xffffff65, 0xffffff66, 0xffffff67,
0xffffff68, 0xffffff69, 0xffffff6a, 0xffffff6b,
0xffffff6c, 0xffffff6d, 0xffffff6e, 0xffffff6f,
0xffffff70, 0xffffff71, 0xffffff72, 0xffffff73,
0xffffff74, 0xffffff75, 0xffffff76, 0xffffff77,
0xffffff78, 0xffffff79, 0xffffff7a, 0xffffff7b,
0xffffff7c, 0xffffff7d, 0xffffff7e, 0xffffff7f,
0xffffff80, 0xffffff81, 0xffffff82, 0xffffff83,
0xffffff84, 0xffffff85, 0xffffff86, 0xffffff87,
0xffffff88, 0xffffff89, 0xffffff8a, 0xffffff8b,
0xffffff8c, 0xffffff8d, 0xffffff8e, 0xffffff8f,
0xffffff90, 0xffffff91, 0xffffff92, 0xffffff93,
0xffffff94, 0xffffff95, 0xffffff96, 0xffffff97,
0xffffff98, 0xffffff99, 0xffffff9a, 0xffffff9b,
0xffffff9c, 0xffffff9d, 0xffffff9e, 0xffffff9f,
0xffffffa0, 0xffffffa1, 0xffffffa2, 0xffffffa3,
0xffffffa4, 0xffffffa5, 0xffffffa6, 0xffffffa7,
0xffffffa8, 0xffffffa9, 0xffffffaa, 0xffffffab,
0xffffffac, 0xffffffad, 0xffffffae, 0xffffffaf,
0xffffffb0, 0xffffffb1, 0xffffffb2, 0xffffffb3,
0xffffffb4, 0xffffffb5, 0xffffffb6, 0xffffffb7,
0xffffffb8, 0xffffffb9, 0xffffffba, 0xffffffbb,
0xffffffbc, 0xffffffbd, 0xffffffbe, 0xffffffbf,
0xffffffc0, 0xffffffc1, 0xffffffc2, 0xffffffc3,
0xffffffc4, 0xffffffc5, 0xffffffc6, 0xffffffc7,
0xffffffc8, 0xffffffc9, 0xffffffca, 0xffffffcb,
0xffffffcc, 0xffffffcd, 0xffffffce, 0xffffffcf,
0xffffffd0, 0xffffffd1, 0xffffffd2, 0xffffffd3,
0xffffffd4, 0xffffffd5, 0xffffffd6, 0xffffffd7,
0xffffffd8, 0xffffffd9, 0xffffffda, 0xffffffdb,
0xffffffdc, 0xffffffdd, 0xffffffde, 0xffffffdf,
0xffffffe0, 0xffffffe1, 0xffffffe2, 0xffffffe3,
0xffffffe4, 0xffffffe5, 0xffffffe6, 0xffffffe7,
0xffffffe8, 0xffffffe9, 0xffffffea, 0xffffffeb,
0xffffffec, 0xffffffed, 0xffffffee, 0xffffffef,
0xfffffff0, 0xfffffff1, 0xfffffff2, 0xfffffff3,
0xfffffff4, 0xfffffff5, 0xfffffff6, 0xfffffff7,
0xfffffff8, 0xfffffff9, 0xfffffffa, 0xfffffffb,
0xfffffffc, 0xfffffffd, 0xfffffffe, 0xffffffff,
0x00000000, 0x00000001, 0x00000002, 0x00000003,
0x00000004, 0x00000005, 0x00000006, 0x00000007,
0x00000008, 0x00000009, 0x0000000a, 0x0000000b,
0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f,
0x00000010, 0x00000011, 0x00000012, 0x00000013,
0x00000014, 0x00000015, 0x00000016, 0x00000017,
0x00000018, 0x00000019, 0x0000001a, 0x0000001b,
0x0000001c, 0x0000001d, 0x0000001e, 0x0000001f,
0x00000020, 0x00000021, 0x00000022, 0x00000023,
0x00000024, 0x00000025, 0x00000026, 0x00000027,
0x00000028, 0x00000029, 0x0000002a, 0x0000002b,
0x0000002c, 0x0000002d, 0x0000002e, 0x0000002f,
0x00000030, 0x00000031, 0x00000032, 0x00000033,
0x00000034, 0x00000035, 0x00000036, 0x00000037,
0x00000038, 0x00000039, 0x0000003a, 0x0000003b,
0x0000003c, 0x0000003d, 0x0000003e, 0x0000003f,
0x00000040, 0x00000041, 0x00000042, 0x00000043,
0x00000044, 0x00000045, 0x00000046, 0x00000047,
0x00000048, 0x00000049, 0x0000004a, 0x0000004b,
0x0000004c, 0x0000004d, 0x0000004e, 0x0000004f,
0x00000050, 0x00000051, 0x00000052, 0x00000053,
0x00000054, 0x00000055, 0x00000056, 0x00000057,
0x00000058, 0x00000059, 0x0000005a, 0x0000005b,
0x0000005c, 0x0000005d, 0x0000005e, 0x0000005f,
0x00000060, 0x00000061, 0x00000062, 0x00000063,
0x00000064, 0x00000065, 0x00000066, 0x00000067,
0x00000068, 0x00000069, 0x0000006a, 0x0000006b,
0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f,
0x00000070, 0x00000071, 0x00000072, 0x00000073,
0x00000074, 0x00000075, 0x00000076, 0x00000077,
0x00000078, 0x00000079, 0x0000007a, 0x0000007b,
0x0000007c, 0x0000007d, 0x0000007e, 0x0000007f,
0x00000080, 0x00000081, 0x00000082, 0x00000083,
0x00000084, 0x00000085, 0x00000086, 0x00000087,
0x00000088, 0x00000089, 0x0000008a, 0x0000008b,
0x0000008c, 0x0000008d, 0x0000008e, 0x0000008f,
0x00000090, 0x00000091, 0x00000092, 0x00000093,
0x00000094, 0x00000095, 0x00000096, 0x00000097,
0x00000098, 0x00000099, 0x0000009a, 0x0000009b,
0x0000009c, 0x0000009d, 0x0000009e, 0x0000009f,
0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3,
0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7,
0x000000a8, 0x000000a9, 0x000000aa, 0x000000ab,
0x000000ac, 0x000000ad, 0x000000ae, 0x000000af,
0x000000b0, 0x000000b1, 0x000000b2, 0x000000b3,
0x000000b4, 0x000000b5, 0x000000b6, 0x000000b7,
0x000000b8, 0x000000b9, 0x000000ba, 0x000000bb,
0x000000bc, 0x000000bd, 0x000000be, 0x000000bf,
0x000000c0, 0x000000c1, 0x000000c2, 0x000000c3,
0x000000c4, 0x000000c5, 0x000000c6, 0x000000c7,
0x000000c8, 0x000000c9, 0x000000ca, 0x000000cb,
0x000000cc, 0x000000cd, 0x000000ce, 0x000000cf,
0x000000d0, 0x000000d1, 0x000000d2, 0x000000d3,
0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7,
0x000000d8, 0x000000d9, 0x000000da, 0x000000db,
0x000000dc, 0x000000dd, 0x000000de, 0x000000df,
0x000000e0, 0x000000e1, 0x000000e2, 0x000000e3,
0x000000e4, 0x000000e5, 0x000000e6, 0x000000e7,
0x000000e8, 0x000000e9, 0x000000ea, 0x000000eb,
0x000000ec, 0x000000ed, 0x000000ee, 0x000000ef,
0x000000f0, 0x000000f1, 0x000000f2, 0x000000f3,
0x000000f4, 0x000000f5, 0x000000f6, 0x000000f7,
0x000000f8, 0x000000f9, 0x000000fa, 0x000000fb,
0x000000fc, 0x000000fd, 0x000000fe, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
};    // 2048 elements
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxfm.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:41:42  $
// $Archive:   S:\h26x\src\dec\dxfm.h_v  $
// $Header:   S:\h26x\src\dec\dxfm.h_v   1.6   30 Aug 1996 08:41:42   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxfm.h_v  $
;// 
;//    Rev 1.6   30 Aug 1996 08:41:42   KLILLEVO
;// changed bias in ClampTbl from 128 to CLAMP_BIAS (defined to 128)
;// 
;//    Rev 1.5   17 Jul 1996 15:34:14   AGUPTA2
;// Increased the size of clamping table ClampTbl to 128+256+128.
;// 
;//    Rev 1.4   08 Mar 1996 16:46:34   AGUPTA2
;// Modified the definition of CLIP_RANGE.  Commented out decls for
;// ClipPixIntra and ClipPixInter.
;// 
;// 
;//    Rev 1.3   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:40:40   AKASAI
// 
// Changed ClipPix to ClipPixIntra and added ClipPixInter.
// 
//    Rev 1.1   22 Aug 1995 10:29:32   CZHU
// 
// Added #define to prevent multiple inclusion.
// 
//    Rev 1.0   21 Aug 1995 14:38:48   CZHU
// Initial revision.

#ifndef _DXFMIDCT_
#define _DXFMIDCT_


#define NUM_ELEM	64	// Number of elements in the block (8x8)
#define KERNEL_SIZE	16	// Number of elements needed in kernel
#define CLAMP_BIAS  128 // Bias in clamping table 
#define CLIP_RANGE	CLAMP_BIAS + 256 + CLAMP_BIAS
                        
#define SCALER 13

extern const I32 	ROUNDER;

extern const I8  Unique[];
extern const I8  PClass[];
extern const I32 KernelCoeff[NUM_ELEM][10];
extern const I8 MapMatrix[NUM_ELEM][KERNEL_SIZE];
extern const U8 ClampTbl[CLIP_RANGE];
#endif //_DXFMIDCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxctrls.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;//
;// Description:    This module implements the following functions.
;//                     CustomChangeBrightness();
;//                     CustomChangeContrast();
;//                     CustomChangeSaturation();
;//                     CustomResetBrightness();
;//                     CustomResetContrast();
;//                     CustomResetSaturation();
;//                     CustomGetBrightness();
;//                     CustomGetContrast();
;//                     CustomGetSaturation();
;//
;// $Author:   BECHOLS  $
;// $Date:   09 Dec 1996 08:51:44  $
;// $Archive:   S:\h26x\src\dec\dxctrls.cpv  $
;// $Header:   S:\h26x\src\dec\dxctrls.cpv   1.14   09 Dec 1996 08:51:44   BECHOLS  $
;//	$Log:   S:\h26x\src\dec\dxctrls.cpv  $
// 
//    Rev 1.14   09 Dec 1996 08:51:44   BECHOLS
// Fixed reset saturation, so that it modified chroma table, not luma.
// 
//    Rev 1.13   20 Oct 1996 13:33:32   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.12   10 Sep 1996 10:31:38   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.11   11 Jul 1996 14:09:18   SCDAY
// Added comments re: CustomGetB/C/S functions
// 
//    Rev 1.10   10 Jul 1996 08:21:26   SCDAY
// Added functions for CustomGetBrightness/Contrast/Saturation (DBrucks)
// 
//    Rev 1.9   04 Jun 1996 09:04:00   AKASAI
// Fixed bug in CustomResetSaturation where it was reseting the LumaTable
// instead of the ChromaTable.  This was discovered in Quartz testing.
// 
//    Rev 1.8   01 Feb 1996 10:16:24   BNICKERS
// Fix the "knobs".
// 
//    Rev 1.7   22 Dec 1995 13:53:06   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.6   17 Nov 1995 15:22:12   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.5   01 Nov 1995 16:52:24   TRGARDOS
// Fixed unmatched GlobalUnlocks.
// 
//    Rev 1.4   25 Oct 1995 18:14:02   BNICKERS
// 
// Clean up archive stuff.
// 
//    Rev 1.3   20 Sep 1995 09:23:52   SCDAY
// 
// added #ifdef for #include d?dec.h
// 
//    Rev 1.2   01 Sep 1995 09:49:36   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.1   23 Aug 1995 12:24:04   DBRUCKS
// change to H26X_DEFAULT_* from H263_ as these are shared values.
// 
//    Rev 1.0   31 Jul 1995 13:00:14   DBRUCKS
// Initial revision.
// 
//    Rev 1.1   24 Jul 1995 15:00:40   CZHU
// 
// Adjust the changes to the decoder catalog structure
// 
//    Rev 1.0   17 Jul 1995 14:46:18   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#define SCALE               128
#define ACTIVE_RANGE        256
#define OFFSET_TABLE_COPY   256 + 16

typedef BOOL FAR *LPBOOL;
typedef struct {
    LPBYTE  LumaTable;
    LPBOOL  LumaFlag;
    LPBYTE  ChromaTable;
    LPBOOL  ChromaFlag;
    LPBYTE  Brightness;
    LPBYTE  Contrast;
    LPBYTE  Saturation;
    } PIXDAT, FAR *LPPIXDAT;

/**********************************************************************
 * static WORD LockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This function locks the memory and fills the Pixel Data
 *                 Structure with valid pointers to the tables that I need
 *                 to adjust.
 * History:        06/29/94 -BEN-
 **********************************************************************/
static LRESULT LockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	FX_ENTRY("LockLCTables")

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: ICERR_BADPARAM\r\n", _fx_));
		return(ICERR_BADPARAM);
	}
	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)(DC->p16InstPostProcess +
								    DC->X16_LumaAdjustment);
	lpPixData->ChromaTable = (LPBYTE)(DC->p16InstPostProcess +
									  DC->X16_ChromaAdjustment);
	lpPixData->LumaFlag = (LPBOOL)&(DC->bAdjustLuma);
	lpPixData->ChromaFlag = (LPBOOL)&(DC->bAdjustChroma);
	lpPixData->Brightness = (LPBYTE)&(DC->BrightnessSetting);
	lpPixData->Contrast = (LPBYTE)&(DC->ContrastSetting);
	lpPixData->Saturation = (LPBYTE)&(DC->SaturationSetting);

	return(ICERR_OK);
}

/*********************************************************************
 * static LRESULT UnlockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This funtion unlocks
 * History:        06/30/94 -BEN-
 **********************************************************************/
static LRESULT UnlockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)NULL;
	lpPixData->ChromaTable = (LPBYTE)NULL;
	lpPixData->LumaFlag = (LPBOOL)NULL;
	lpPixData->ChromaFlag = (LPBOOL)NULL;

	return(ICERR_OK);
}

/**********************************************************************
 * static VOID MassageContrast(BYTE, PBYTE);
 * Description:    input is 0 to 255, 1/SCALE to 256/SCALE inclusive
 *                 0 = 1/SCALE
 *                 1 = 2/SCALE
 *                 n = (n + 1) / SCALE
 *                 SCALE - 1 = 1        yields no change
 *                 255 = 256/SCALE
 *                 if the response is too coarse, SCALE can be increased
 *                 if the response is too fine, SCALE can be decreased
 *
 * History:        02/22/94 -BEN-  Added header.
 **********************************************************************/
static VOID MassageContrast(BYTE offsetfactor, LPBYTE table)
    {
    int i;
    long temp, contrastfactor;

    contrastfactor = ((long)((DWORD)offsetfactor)) + 1; // 1 - 256
    contrastfactor = (contrastfactor * ACTIVE_RANGE) / 256L;
    for(i = 0; i < 256; i++)
        {
        temp = (long)((DWORD)table[i]);
        temp -= (ACTIVE_RANGE / 2L);                    // add centering
        temp *= contrastfactor;
        temp /= SCALE;
        temp += (ACTIVE_RANGE / 2L);                    // remove centering
        if(temp < 0)                                    // and clamp
            table[i] = 0;
        else if(temp <= 255)
            table[i] = (unsigned char) temp;
        else
            table[i] = 255;
        table[i+OFFSET_TABLE_COPY] = table[i];
        }
    return;
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeBrightness(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeBrightness(LPDECINST lpInst, BYTE offsetdelta)
    {
    LRESULT lRes;
    int     delta, temp, i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetBrightness(lpInst);
        if(offsetdelta != H26X_DEFAULT_BRIGHTNESS)
            {
            delta = ((offsetdelta - 128) * ACTIVE_RANGE) / 256; // -128 to 127
            for(i = 0; i < 256; i++)
                {
                temp = (int)PixData.LumaTable[i] + delta;
                if(temp < 0) PixData.LumaTable[i] = 0;
                else if(temp <= 255) PixData.LumaTable[i] = (BYTE)temp;
                else PixData.LumaTable[i] = 255;
                PixData.LumaTable[i+OFFSET_TABLE_COPY] = PixData.LumaTable[i];
                }
            *(PixData.Brightness) = offsetdelta;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeContrast(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeContrast(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetContrast(lpInst);
        if(offsetfactor != H26X_DEFAULT_CONTRAST)
            {
            MassageContrast(offsetfactor, PixData.LumaTable);
            *(PixData.Contrast) = offsetfactor;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeSaturation(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeSaturation(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetSaturation(lpInst);
        if(offsetfactor != H26X_DEFAULT_SATURATION)
            {
            MassageContrast(offsetfactor, PixData.ChromaTable);
            *(PixData.Saturation) = offsetfactor;
            *(PixData.ChromaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }
#ifdef QUARTZ

/************************************************************************
 *  CustomGetBrightness
 *
 *  Gets the current brightness value
 ***********************************************************************/
LRESULT CustomGetBrightness(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->BrightnessSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetBrightness() */

/************************************************************************
 *  CustomGetContrast
 *
 *  Gets the current contrast value
 ***********************************************************************/
LRESULT CustomGetContrast(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->ContrastSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetContrast() */

/************************************************************************
 *
 *  CustomGetSaturation
 *
 *  Gets the current saturation value
 ***********************************************************************/
LRESULT CustomGetSaturation(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->SaturationSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetSaturation() */

#endif /* QUARTZ */


;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetBrightness(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetBrightness(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.LumaTable[i] = i;
			PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.LumaFlag) = FALSE;
		*(PixData.Brightness) = H26X_DEFAULT_BRIGHTNESS;
		if(*(PixData.Contrast) != H26X_DEFAULT_CONTRAST)
			CustomChangeContrast(lpInst, *(PixData.Contrast));
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetContrast(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetContrast(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.LumaTable[i] = i;
			PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.LumaFlag) = FALSE;
		*(PixData.Contrast) = H26X_DEFAULT_CONTRAST;
		if(*(PixData.Brightness) != H26X_DEFAULT_BRIGHTNESS)
			CustomChangeBrightness(lpInst, *(PixData.Brightness));
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetSaturation(LPDECINST);
;//
;// Description:    Sets chroma tables to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetSaturation(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.ChromaTable[i] = i;
			PixData.ChromaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.ChromaFlag) = FALSE;
		*(PixData.Saturation) = H26X_DEFAULT_SATURATION;
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3enc.cpp ===
#define P6Version 0
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * e3enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance
 * 	H263Compress
 *  H263TermEncoderInstance
 *
 */
//
// $Author:   JMCVEIGH	$
// $Date:   22 Apr 1997 10:44:58  $
// $Archive:   S:\h26x\src\enc\e3enc.cpv  $
// $Header:   S:\h26x\src\enc\e3enc.cpv   1.185   22 Apr 1997 10:44:58   gmlim  $
// $Log:   S:\h26x\src\enc\e3enc.cpv  $
// 
//    Rev 1.185   22 Apr 1997 10:44:58   gmlim
// Change to not return an ICERR_ERROR in H263Compress() when a PB frame
// is dropped due to 8k/32k buffer size overflow.  ICERR_OK will be
// returned and the encoded P frame will be output.
//
//	  Rev 1.184   18 Apr 1997 10:45:18	 JMCVEIGH
// Clean-up of InitMEState when resiliency is turned on. Before, we
// would duplicate the number of GOBs forced to be intra if packet
// loss was requested.
//
//	  Rev 1.183   18 Apr 1997 08:43:22	 gmlim
// Fixed a bug where uAdjCumFrmSize was not being updated when RTP was
// disabled.
//
//	  Rev 1.182   17 Apr 1997 17:12:20	 gmlim
// Added u32sizeBSnEBS to indicate the total buffer size.  Changed
// u32sizeBitBuffer to indicate the 8k/32k frame size without the
// RTP extension and trailer.  Added check for buffer overflow before
// attaching the EBS and trailer to a PB frame.  Also, added
// uAdjCumFrmSize to be used with rate control in the IA case.
//
//	  Rev 1.181   17 Mar 1997 20:22:06	 MDUDA
// Adjusted calls to motion estimation to use pseudo stack space.
// Moved local storage to encoder catalog from H263Compress.
// This fixes were needed to support 16-bit apps that had insufficient
// stack space.
//
//	  Rev 1.180   12 Mar 1997 16:51:02	 CLORD
// now check for NULL in H263TermEncoder
//
//	  Rev 1.179   11 Mar 1997 13:47:36	 JMCVEIGH
// Catch AVIIF_KEYFRAME flag for coding as an INTRA frame. Some
// apps. use ICCOMPRESS_KEYFRAME, others AVIIF_KEYFRAME.
//
//	  Rev 1.178   10 Feb 1997 11:43:26	 JMCVEIGH
//
// Support for new interpretation of blocking filter -
// allow for motion vectors outside of the reference picture.
//
//	  Rev 1.177   05 Feb 1997 13:07:44	 JMCVEIGH
//
// Further clean-up of improved PB.
//
//	  Rev 1.176   05 Feb 1997 12:18:16	 JMCVEIGH
// Pass GOBHeaderPresent parameter to MMxEDTQ() for EMV bug fix
// support latest H.263+ draft bitstream spec, and support for
// separate improved PB-frame flag.
//
//	  Rev 1.175   20 Jan 1997 17:02:16	 JMCVEIGH
//
// Allow UMV without AP (MMX only).
//
//	  Rev 1.174   14 Jan 1997 17:55:04	 JMCVEIGH
// Allow in-the-loop deblocking filter on IA encoder.
//
//	  Rev 1.173   09 Jan 1997 13:49:46	 MDUDA
// Put emms instruction at end of H263Compress for MMX.
//
//	  Rev 1.172   08 Jan 1997 11:37:22	 BECHOLS
// Changed ini file name to H263Test.ini
//
//	  Rev 1.171   30 Dec 1996 19:54:08	 MDUDA
// Passing input format to encoder initializer so input color convertors
// can be initialized.
//
//	  Rev 1.170   19 Dec 1996 16:32:52	 MDUDA
// Modified call to colorCnvtFrame to support H263 backward compatibility.
//
//	  Rev 1.169   19 Dec 1996 16:01:38	 JMCVEIGH
// Fixed turning off of deblocking filter if not MMX.
//
//	  Rev 1.168   16 Dec 1996 17:50:00	 JMCVEIGH
// Support for improved PB-frame mode and 8x8 motion vectors if
// deblocking filter selected (no OBMC unless advanced prediction
// also selected).
//
//	  Rev 1.167   16 Dec 1996 13:34:46	 MDUDA
// Added support for H263' codec plus some _CODEC_STATS changes.
//
//	  Rev 1.166   11 Dec 1996 15:02:06	 JMCVEIGH
// 
// Turning on of deblocking filter and true B-frames. Currently
// only deblocking filter is implemented. Also, we do not automatically
// turn on 8x8 motion vectors when the deblocking filter is selected.
// Will use 8x8 vectors when the OBMC part of AP can be selectively
// turned off.
// 
//    Rev 1.165   09 Dec 1996 17:57:24   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.164   09 Dec 1996 09:49:56   MDUDA
// 
// Modified for H263P.
// 
//    Rev 1.163   05 Dec 1996 16:49:46   GMLIM
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Modifications made to RTP related function calls in H263Compress().
// 
//    Rev 1.162   03 Dec 1996 08:53:22   GMLIM
// Move the check for TR==TRPrev a few lines forward so that it is done
// before any write to the bitstream buffer.
// 
//    Rev 1.161   03 Dec 1996 08:47:36   KLILLEVO
// improved overflow resiliency for PB-frames. Still not perfect, since
// that would require re-encoding of parts of the P-frames as well as the
// corresponding parts of the B-frames.
// 
//    Rev 1.160   27 Nov 1996 16:15:50   gmlim
// Modified RTP bitstream bufferring to improve efficiency and also to
// avoid internal bitstream buffer overflow.
// 
//    Rev 1.159   26 Nov 1996 16:28:30   GMLIM
// Added error checking for TR == TRPrev.  Merged two sections of identical
// code into one block common to both MMX and non-MMX cases.
//
//    Rev 1.157   11 Nov 1996 09:14:26   JMCVEIGH
// Fixed bug that caused all blocks in interframes to be intra coded
// after the second I frame in a sequence. Now the ME states are
// re-initialized when the previous frame was an I frame and the current
// frame is a non-intra frame (also reinitialized when the AP state
// changes).
// 
//    Rev 1.156   06 Nov 1996 16:29:20   gmlim
// Removed H263ModeC.
// 
//    Rev 1.155   05 Nov 1996 13:33:22   GMLIM
// Added mode c support for mmx case.
// 
//    Rev 1.154   03 Nov 1996 18:56:46   gmlim
// Added mode c support for rtp bs ext.
// 
//    Rev 1.153   24 Oct 1996 15:25:54   KLILLEVO
// 
// removed two string allocations no longer needed
// 
//    Rev 1.152   24 Oct 1996 15:19:40   KLILLEVO
// 
// changed loglevel for instance events to 2 (from 4)
// 
//    Rev 1.151   23 Oct 1996 17:13:36   KLILLEVO
// 
// typo in one DbgLog statement fixed
// 
//    Rev 1.150   23 Oct 1996 17:11:36   KLILLEVO
// changed to DbgLog()
// 
//    Rev 1.149   22 Oct 1996 14:51:10   KLILLEVO
// Blocktype initialization in InitMEState() is  now only called if
// the AP mode has changed from the previous picture.
// 
//    Rev 1.148   18 Oct 1996 16:57:00   BNICKERS
// Fixes for EMV
// 
//    Rev 1.147   10 Oct 1996 16:43:00   BNICKERS
// Initial debugging of Extended Motion Vectors.
// 
//    Rev 1.146   04 Oct 1996 17:05:22   BECHOLS
// When we set the output flags lpdwFlags to AVIIF_KEYFRAME, we also set
// dwFlags to ICCOMPRESS_KEYFRAME, to support changes Sylvia Day made to
// CXQ_MAIN.CPP
// 
//    Rev 1.145   04 Oct 1996 08:47:40   BNICKERS
// Add EMV.
// 
//    Rev 1.144   16 Sep 1996 16:49:52   CZHU
// Changed interface for RTP BS initialization for smaller packet size
// 
//    Rev 1.143   13 Sep 1996 12:48:30   KLILLEVO
// cleaned up intra update code to make it more understandable
// 
//    Rev 1.142   12 Sep 1996 14:46:14   KLILLEVO
// finished baseline+PB
// 
//    Rev 1.141   12 Sep 1996 14:09:58   KLILLEVO
// started baseline+PB changes (not finished)
// added PVCS log
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
#endif

#define DUMPFILE 0

/* QP level for which the AP mode is turned off for IA */
/* on MMX AP is always used if the caller asks for it */
const int AP_MODE_QP_LEVEL = 11;



/*
  Pick a resiliency strategy.
*/

#define REQUESTED_KEY_FRAME 0
#define PERIODIC_KEY_FRAME  1
#define FAST_RECOVERY       2
#define SLOW_RECOVERY       3

#define RESILIENCY_STRATEGY PERIODIC_KEY_FRAME

#define PERIODIC_KEY_FRAME_PERIODICITY 15     // Select periodicity (max 32767)

#define UNRESTRICTED_MOTION_FRAMES 16 // Number of frames that don't have an
                                      // Intra slice.  0 for FAST_RECOVERY.
                                      // Modest amount for SLOW_RECOVERY.
                                      // Unimportant for other strategies.

#define REUSE_DECODE 1  // Set to one if second decode (as under Videdit)
                        // can reuse the encoder's decode.

/* 
 * Need this hack to allow temporarily turning off PB frames
 * when they are turned on usin the INI file.
 */
#define	TEMPORARILY_FALSE  88

#ifdef STAT
#define STATADDRESS 0x250
#define ELAPSED_ENCODER_TIME 1  // Must be set for other timers to work right.
#define SAMPLE_RGBCONV_TIME  0  // Time conversion of RGB24 to YUV9 step.
#define SAMPLE_MOTION_TIME   0  // Time motion estimation step.
#define SAMPLE_ENCBLK_TIME   0  // Time encode block layer step.
#define SAMPLE_ENCMBLK_TIME  0  // Time encode macroblock layer step.
#define SAMPLE_ENCVLC_TIME   0  // Time encode VLC step.
#define SAMPLE_COMPAND_TIME  1  // Time decode of encoded block step.
#else
#define STATADDRESS 0x250
#define ELAPSED_ENCODER_TIME 0  // Must be set for other timers to work right.
#define SAMPLE_RGBCONV_TIME  0  // Time conversion of RGB24 to YUV9 step.
#define SAMPLE_MOTION_TIME   0  // Time motion estimation step.
#define SAMPLE_ENCBLK_TIME   0  // Time encode block layer step.
#define SAMPLE_ENCMBLK_TIME  0  // Time encode macroblock layer step.
#define SAMPLE_ENCVLC_TIME   0  // Time encode VLC step.
#define SAMPLE_COMPAND_TIME  0  // Time decode of encoded block step.
#endif

//#pragma warning(disable:4101)
//#pragma warning(disable:4102)

#if ELAPSED_ENCODER_TIME
// #include "statx.h"	 --- commented out to allow updating dependencies

DWORD Elapsed, Sample;
DWORD TotalElapsed, TotalSample, TimedIterations;

#endif

//#define PITCH  384
#define PITCHL 384L
#define DEFAULT_DCSTEP 8
#define DEFAULT_QUANTSTEP 36
#define DEFAULT_QUANTSTART 30

#define LEFT        0
#define INNERCOL    1
#define NEARRIGHT   2
#define RIGHT       3

#define TOP         0
#define INNERROW    4
#define NEARBOTTOM  8
#define BOTTOM     12

#ifdef USE_MMX // { USE_MMX
extern BOOL MMxVersion;   // from ccpuvsn.cpp

BOOL MMX_Enabled = MMxVersion;
#endif // } USE_MMX

BOOL ToggleAP = TRUE;
BOOL TogglePB = TRUE;

U8 u8QPMax;

#ifdef REUSE_DECODE
extern struct {               // Communicate Encoder's decode to display decode.
  U8 FAR * Address;                    // Addr at which encoded frame is placed.
  DECINSTINFO BIGG * PDecoderInstInfo; // Encoder's decoder instance.
  unsigned int  FrameNumber;           // Frame number last encoded, mod 128.
} CompandedFrame;
#endif

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#pragma message ("Current log encode timing computations handle 105 frames max")
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo);
void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

/*
 * Look up table for quarter pel to half pel conversion of chroma MV's.
 * The motion vectors value is half the index value. The input to the
 * array must be biased by +64.
 */
const char QtrPelToHalfPel[] = {
-32, -31, -31, -31, -30, -29, -29, -29, -28, -27, -27, -27, -26, -25, -25, -25,
-24, -23, -23, -23, -22, -21, -21, -21, -20, -19, -19, -19, -18, -17, -17, -17,
-16, -15, -15, -15, -14, -13, -13, -13, -12, -11, -11, -11, -10,  -9,  -9,  -9, 
 -8,  -7,  -7,  -7,  -6,  -5,  -5,  -5,  -4,  -3,  -3,  -3,  -2,  -1,  -1,  -1,
  0,   1,   1,   1,   2,   3,   3,   3,   4,   5,   5,   5,   6,   7,   7,   7,
  8,   9,   9,   9,  10,  11,  11,  11,  12,  13,  13,  13,  14,  15,  15,  15,
 16,  17,  17,  17,  18,  19,  19,  19,  20,  21,  21,  21,  22,  23,  23,  23,
 24,  25,  25,  25,  26,  27,  27,  27,  28,  29,  29,  29,  30,  31,  31,  31};

/*
 * Look-up table for converting the sum of four motion vectors to a chroma 
 * motion vector. Since motion vectors are in the range [-32,31.5], their
 * indices are in the range [-64,63]. Hence the sum are in the range [-256,248].
 * The input to the array must be biased by +256.
 */
const char SixteenthPelToHalfPel[] = {
-32, -32, -32, -31, -31, -31, -31, -31, -31, -31, -31, -31, -31, -31, -30, -30,
-30, -30, -30, -29, -29, -29, -29, -29, -29, -29, -29, -29, -29, -29, -28, -28,
-28, -28, -28, -27, -27, -27, -27, -27, -27, -27, -27, -27, -27, -27, -26, -26,
-26, -26, -26, -25, -25, -25, -25, -25, -25, -25, -25, -25, -25, -25, -24, -24,
-24, -24, -24, -23, -23, -23, -23, -23, -23, -23, -23, -23, -23, -23, -22, -22,
-22, -22, -22, -21, -21, -21, -21, -21, -21, -21, -21, -21, -21, -21, -20, -20,
-20, -20, -20, -19, -19, -19, -19, -19, -19, -19, -19, -19, -19, -19, -18, -18,
-18, -18, -18, -17, -17, -17, -17, -17, -17, -17, -17, -17, -17, -17, -16, -16,
-16, -16, -16, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -14, -14,
-14, -14, -14, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -12, -12,
-12, -12, -12, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -10, -10,
-10, -10, -10,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -8,  -8,
 -8,  -8,  -8,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -6,  -6,
 -6,  -6,  -6,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -4,  -4,
 -4,  -4,  -4,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -2,  -2,
 -2,  -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   0,   0,
  0,   0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,
  2,   2,   2,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   4,   4,
  4,   4,   4,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,
  6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,
  8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,
 10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,
 12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,
 14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,
 16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,
 18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,
 20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,
 22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,
 24,  24,  24,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  26,  26,
 26,  26,  26,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,
 28,  28,  28,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  30,  30,
 30,  30,  30,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  32};

void InitMEState(T_H263EncoderCatalog *EC, ICCOMPRESS *lpicComp, T_CONFIGURATION * pConfiguration);

UN FindNewQuant(
	T_H263EncoderCatalog *EC, 
	UN gquant_prev,
	UN uComFrmSize,
	UN GOB,
	U8 u8QPMax,
	U8 u8QPMin,
	BOOL bBitRateControl,
	BOOL bGOBoverflowWarning
	);

static void encodeFrameHeader(
    T_H263EncoderCatalog *  EC,
    U8                   ** ppCurBitStream,
    U8                   *  u8BitOffset,
    BOOL                    bPBframe
);

/*
static void copyEdgePels(T_H263EncoderCatalog *  EC);
*/

extern "C" {
  void ExpandPlane(U32, U32, U32, U32);
}

#ifdef USE_MMX // { USE_MMX
static void Check_InterCodeCnt_MMX(T_H263EncoderCatalog *, U32);
#endif // } USE_MMX

static void Check_InterCodeCnt    (T_H263EncoderCatalog *, U32);

static void calcGOBChromaVectors(
	T_H263EncoderCatalog *EC,
	U32             StartingMB,
	T_CONFIGURATION *pConfiguration
);

static void calcBGOBChromaVectors(
	 T_H263EncoderCatalog *EC,
	 const U32             StartingMB
);

static void GetEncoderOptions(T_H263EncoderCatalog * EC);

/*static U8 StillImageQnt[] = {
	31, 29, 27, 26, 25, 24, 23, 22, 21, 20, 
	19, 18, 17, 16, 15, 14, 14, 13, 13, 12,
	12, 11, 11, 10, 10,  9,  9,  8,  8,  7,
	 7,  6,  6,  6,  5,  5,  5,  4,  4,  4,
	 3,  3,  3,  3}; */
  
static U8 StillImageQnt[] = {
	31, 18, 12,	10, 8, 6, 5, 4, 4, 3}; //ia

#ifdef USE_MMX // { USE_MMX
static U8 StillImageQnt_MMX[] = {
	31, 12, 10,	8, 6, 4, 3, 3, 3, 2};  //mmx
#endif // } USE_MMX
  
const int numStillImageQnts = 10;

#ifdef COUNT_BITS
static void InitBits(T_H263EncoderCatalog * EC);
void InitCountBitFile();
void WriteCountBitFile(T_BitCounts *Bits);
#endif


#ifdef USE_MMX // { USE_MMX
/*
 * Exception Filter for access violations in MMxEDTQ B-frame motion estimation
 * No memory is allocation before run-time, it is only reserved.
 * Then, when an access violation occurs, more memory is allocated,
 * provided the access violation is withing the reserved memory area.
 */


int ExceptionFilterForMMxEDTQ(
	LPEXCEPTION_POINTERS exc, 
	LPVOID lpMBRVS,
	BOOL fLuma)
{
	DWORD dwCode;
	LPVOID lpAddress;

	FX_ENTRY("ExceptionFilterForMMxEDTQ")

	dwCode = exc->ExceptionRecord->ExceptionCode;

	// check that this is an access violation
	if (dwCode != EXCEPTION_ACCESS_VIOLATION)
		return EXCEPTION_CONTINUE_SEARCH;

	lpAddress = (LPVOID)exc->ExceptionRecord->ExceptionInformation[1];

	// check for access violation outside address range
	if (lpAddress < lpMBRVS)
		return EXCEPTION_CONTINUE_SEARCH;  // this exception is not handled here  

	if (fLuma)
	{
		if ((DWORD)lpAddress > ((DWORD)lpMBRVS + 18*65*22*3*4))
			return EXCEPTION_CONTINUE_SEARCH;	// this exception is not handled here
	}
	else
	{
		if ((DWORD)lpAddress > ((DWORD)lpMBRVS + 18*65*22*3*2))
			return EXCEPTION_CONTINUE_SEARCH;	// this exception is not handled here
	}

	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Access Violation. Don't worry - be happy - committing another page\r\n", _fx_));

	// commit another page
	if (VirtualAlloc(lpAddress,4095,MEM_COMMIT,PAGE_READWRITE) == NULL)
	{
		return EXCEPTION_CONTINUE_SEARCH;	// could not commit
		// this should never happen, since RESERVE was successfull
	}

	// return and try instruction causing the access violation again
	return EXCEPTION_CONTINUE_EXECUTION;
}
#endif // } USE_MMX


/*******************************************************************************
H263InitEncoderGlobal -- This function initializes the global tables used by
                        the H263 encoder.  Note that in 16-bit Windows, these
                        tables are copied to the per-instance data segment, so
                        that they can be used without segment override prefixes.
                        In 32-bit Windows, the tables are left in their staticly
                        allocated locations.
*******************************************************************************/
LRESULT H263InitEncoderGlobal(void)
{
    // Initialize fixed length tables for INTRADC
    InitVLC();

    return ICERR_OK;
}

/*******************************************************************************
H263InitEncoderInstance -- This function allocates and initializes the
                          per-instance tables used by the H263 encoder.
*******************************************************************************/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER lpbiInput, LPCODINST lpCompInst)
#else
LRESULT H263InitEncoderInstance(LPCODINST lpCompInst)
#endif
{

	LRESULT ret;

	UN i;

  	U32 Sz;

  	T_H263EncoderInstanceMemory * P32Inst;
  	T_H263EncoderCatalog * EC;

#if ELAPSED_ENCODER_TIME
  	TotalElapsed = 0;
  	TotalSample = 0;
  	TimedIterations = 0;
#endif

	T_CONFIGURATION * pConfiguration;
	UN uIntraQP;
	UN uInterQP;

	FX_ENTRY("H263InitEncoderInstance")

  /*
   * Allocate memory if instance is not initialized.
   * TO ADD: If instance IS intialized, we have to check to see
   * if important parameters have changed, such as frame size, and
   * then reallocate memory if necessary.
   */
  	if(lpCompInst->Initialized == FALSE)
  	{
    	/*
     	* Calculate size of encoder instance memory needed. We add the size
     	* of a MacroBlock Action Descriptor to it since we want the MacroBlock
        * Action Stream (which is the first element of the memory structure)
        * to be aligned to a boundary equal to the size of a descriptor.
     	*/
    	Sz = sizeof(T_H263EncoderInstanceMemory) + sizeof(T_MBlockActionStream);

    	/*
     	* Allocate the memory.
     	*/
//    	lpCompInst->hEncoderInst = GlobalAlloc(GHND, Sz);

		// VirtualAlloc automatically zeros memory. The bitstream
		// needs to be zeroed when I change this to HeapAlloc.
    	lpCompInst->hEncoderInst = VirtualAlloc(
    		NULL,  // can be allocated anywhere
    		Sz,    // number of bytes to allocate
    		MEM_RESERVE | MEM_COMMIT,  // reserve & commit memory
    		PAGE_READWRITE);	 // protection

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz1, "E3ENC: (VM) %7ld Ln %5ld\0", Sz, __LINE__);
		AddName((unsigned int)lpCompInst->hEncoderInst, gsz1);
#endif

		/* Indicate that we have allocated memory for the compressor instance. */
		lpCompInst->Initialized = TRUE;
  	}
/*  else
  	{
    	// check if parameters have changed, thay may make us have
		// to reallocate memory.
  	}	
*/

//  	lpCompInst->EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
  	lpCompInst->EncoderInst = lpCompInst->hEncoderInst;
  	if (lpCompInst->hEncoderInst == NULL)
  	{
    	ret = ICERR_MEMORY;
    	goto  done;
  	}

   /*
   	* Calculate the 32 bit instance pointer starting at required boundary.
   	*/
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
   /*
   	* The encoder catalog is at the start of the per-instance data.
   	*/
  	EC = &(P32Inst->EC);

	#ifdef COUNT_BITS
	InitCountBitFile();
	#endif

	#ifdef ENCODE_STATS
	InitQuantStats();
	InitFrameSizeStats();
	InitPSNRStats();
	#endif /* ENCODE_STATS */

	/* Initialize the Configuration information 
	 */
	pConfiguration = &(lpCompInst->Configuration);
#if 0
	if (LoadConfiguration(pConfiguration) == FALSE)
		GetConfigurationDefaults(pConfiguration);
#endif
	pConfiguration->bInitialized = TRUE;
	pConfiguration->bCompressBegin = TRUE;
	EC->hBsInfoStream= NULL;

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	// We really want those timings to match the actual use we
	// will make of the codec. So initialize it with the same values
	pConfiguration->bRTPHeader = TRUE;
	pConfiguration->unPacketSize = 512;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

	DEBUGMSG(ZONE_INIT, ("%s: Encoder Configuration Options: bRTPHeader=%d, unPacketSize=%d, bEncoderResiliency=%d, bDisallowPosVerMVs=%d\r\n", _fx_, (int)pConfiguration->bRTPHeader, (int)pConfiguration->unPacketSize, (int)pConfiguration->bEncoderResiliency, (int)pConfiguration->bDisallowPosVerMVs));
	DEBUGMSG(ZONE_INIT, ("%s: Encoder Configuration Options: bDisallowAllVerMVs=%d, unPercentForcedUpdate=%d, unDefaultIntraQuant=%d, unDefaultInterQuant=%d\r\n", _fx_, (int)pConfiguration->bDisallowAllVerMVs, (int)pConfiguration->unPercentForcedUpdate, (int)pConfiguration->unDefaultIntraQuant, (int)pConfiguration->unDefaultInterQuant));
	
   /*
   	* Initialize encoder catalog.
   	*/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	// In H.263+, we encode and decode the padded frames (padded to the right
	// and bottom to multiples of 16). The actual frame dimensions are used
	// for display purposes only.
	EC->FrameHeight = (lpCompInst->yres + 0xf) & ~0xf;
	EC->FrameWidth = (lpCompInst->xres + 0xf) & ~0xf;
	EC->uActualFrameHeight = lpCompInst->yres;
	EC->uActualFrameWidth = lpCompInst->xres;

	ASSERT(sizeof(T_H263EncoderCatalog) == sizeof_T_H263EncoderCatalog);
	{
		int found_cc = TRUE;
		if (BI_RGB == lpCompInst->InputCompression) {
#ifdef USE_BILINEAR_MSH26X
			if (24 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB24toYUV12;
#else
			if (32 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB32toYUV12;
			} else if (24 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB24toYUV12;
#endif
			} else if (16 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB16555toYUV12;
			} else if (8 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = CLUT8toYUV12;
			} else if (4 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = CLUT4toYUV12;
			} else {
				found_cc = FALSE;
				ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
			}
		} else if (FOURCC_YVU9 == lpCompInst->InputCompression) {
			EC->ColorConvertor = YVU9toYUV12;
		} else if (FOURCC_YUY2 == lpCompInst->InputCompression) {
			EC->ColorConvertor = YUY2toYUV12;
		} else if (FOURCC_UYVY == lpCompInst->InputCompression) {
			EC->ColorConvertor = UYVYtoYUV12;
		} else if ((FOURCC_YUV12 == lpCompInst->InputCompression) || (FOURCC_IYUV == lpCompInst->InputCompression)) {
			EC->ColorConvertor = YUV12toEncYUV12;
		} else {
			found_cc = FALSE;
			ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
		}
		if (found_cc) {
			colorCnvtInitialize(lpbiInput, EC->ColorConvertor);
		}
	}
#else
  	EC->FrameHeight = lpCompInst->yres;
  	EC->FrameWidth  = lpCompInst->xres;
#endif
  	EC->FrameSz		= lpCompInst->FrameSz;
  	EC->NumMBRows	= EC->FrameHeight >> 4;
  	EC->NumMBPerRow	= EC->FrameWidth  >> 4;
  	EC->NumMBs		= EC->NumMBRows * EC->NumMBPerRow;

	// This should default to zero. If RTP is used, it will be changed later
	EC->uNumberForcedIntraMBs = 0;
#ifdef H263P
	EC->uNextIntraMB = 0;
#else
	if(pConfiguration->bEncoderResiliency &&
	   pConfiguration->unPercentForcedUpdate &&
	   pConfiguration->unPacketLoss) 
	{//Chad Intra GOB
	//	EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPercentForcedUpdate) + 50) / 100;
		EC->uNextIntraMB = 0;
	}
#endif

  	// Store pointers to current frame in the catalog.
  	EC->pU8_CurrFrm        = P32Inst->u8CurrentPlane;
  	EC->pU8_CurrFrm_YPlane = EC->pU8_CurrFrm + 16;
  	EC->pU8_CurrFrm_UPlane = EC->pU8_CurrFrm_YPlane + YU_OFFSET;
  	EC->pU8_CurrFrm_VPlane = EC->pU8_CurrFrm_UPlane + UV_OFFSET;

  	// Store pointers to the previous frame in the catalog.
  	EC->pU8_PrevFrm        = P32Inst->u8PreviousPlane;
  	EC->pU8_PrevFrm_YPlane = EC->pU8_PrevFrm + 16*PITCH + 16;
  	EC->pU8_PrevFrm_UPlane = EC->pU8_PrevFrm_YPlane + YU_OFFSET;
  	EC->pU8_PrevFrm_VPlane = EC->pU8_PrevFrm_UPlane + UV_OFFSET;

  	// Store pointers to the future frame in the catalog.
  	EC->pU8_FutrFrm        = P32Inst->u8FuturePlane;
  	EC->pU8_FutrFrm_YPlane = EC->pU8_FutrFrm + 16*PITCH + 16;
  	EC->pU8_FutrFrm_UPlane = EC->pU8_FutrFrm_YPlane + YU_OFFSET;
  	EC->pU8_FutrFrm_VPlane = EC->pU8_FutrFrm_UPlane + UV_OFFSET;

  	// Store pointers to the B frame in the catalog.
  	EC->pU8_BidiFrm     = P32Inst->u8BPlane;
  	EC->pU8_BFrm_YPlane = EC->pU8_BidiFrm + 16;
  	EC->pU8_BFrm_UPlane = EC->pU8_BFrm_YPlane + YU_OFFSET;
  	EC->pU8_BFrm_VPlane = EC->pU8_BFrm_UPlane + UV_OFFSET;

  	// Store pointers to the signature frame in the catalog.
  	EC->pU8_Signature        = P32Inst->u8Signature;
  	EC->pU8_Signature_YPlane = EC->pU8_Signature + 16*PITCH + 16;

  	// Store pointer to the macroblock action stream in the catalog.
  	EC->pU8_MBlockActionStream = P32Inst->MBActionStream;

  	// Store pointer to the GOB DCT coefficient buffer in the catalog.
  	EC->pU8_DCTCoefBuf = P32Inst->piGOB_DCTCoefs;

	// Store pointer to area in which to pre-compute OBMC predictions.
	EC->pU8_PredictionScratchArea = P32Inst->u8PredictionScratchArea;

  	// Store pointer to the bit stream buffer in the catalog.
  	EC->pU8_BitStream = P32Inst->u8BitStream;
  	EC->pU8_BitStrCopy = P32Inst->u8BitStrCopy;

	// Store pointer to the RunValSign triplets for Luma and Chroma
	EC->pI8_MBRVS_Luma   = P32Inst->i8MBRVS_Luma;
	EC->pI8_MBRVS_Chroma = P32Inst->i8MBRVS_Chroma;

	// Reserve virtual memory
	EC->pI8_MBRVS_BLuma   = (I8 *) VirtualAlloc(
		NULL,			          // anywhere
		18*(65*3*22*4),	          // number of bytes
		MEM_RESERVE,              // reserve
		PAGE_READWRITE);		  // access

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "E3ENC: (VM) %7ld Ln %5ld\0", 18*(65*3*22*4), __LINE__);
	AddName((unsigned int)EC->pI8_MBRVS_BLuma, gsz2);
#endif

	EC->pI8_MBRVS_BChroma =  (I8 *) VirtualAlloc(
		NULL,			          // anywhere
		18*(65*3*22*2),	          // number of bytes
		MEM_RESERVE,              // reserve
		PAGE_READWRITE);		  // access

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "E3ENC: (VM) %7ld Ln %5ld\0", 18*(65*3*22*2), __LINE__);
	AddName((unsigned int)EC->pI8_MBRVS_BChroma, gsz3);
#endif

	if (EC->pI8_MBRVS_BLuma == NULL	|| EC->pI8_MBRVS_BChroma == NULL)
	{
    	ret = ICERR_MEMORY;
    	goto  done;
  	}



  	// Store pointer to private copy of decoder instance info.
  	EC->pDecInstanceInfo = &(P32Inst->DecInstanceInfo);

	/*
	 * Check to see if there is an H263test.ini file. If the UseINI key
	 * is not 1, or the INI file is not found, then we allow option
	 * signalling in the ICCOMPRESS structure. If set, the INI
	 * options override the ICCOMPRESS options.
	 */
	GetEncoderOptions(EC);

    EC->u8SavedBFrame = FALSE;

  	// Fill the picture header structure.
  	EC->PictureHeader.TR = 0;
  	EC->PictureHeader.Split = OFF;
  	EC->PictureHeader.DocCamera = OFF;
  	EC->PictureHeader.PicFreeze = OFF;
  	EC->PictureHeader.PB = OFF;		// Leave this off here. It is turned on after the P frame
									// has been encoded, when the PB frame is written.
    EC->prevAP  = 255;
	EC->prevUMV = 255;
#ifdef H263P
	EC->prevDF = 255;
#endif

  	EC->PictureHeader.CPM = 0;
  	EC->PictureHeader.TRB = 0;
  	EC->PictureHeader.DBQUANT = 1;  
  	EC->PictureHeader.PLCI = 0;
  	EC->PictureHeader.PEI = 0;
  	
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	EC->pEncTimingInfo = P32Inst->EncTimingInfo;
#endif // } LOG_ENCODE_TIMINGS_ON

	/*
	 * This flag is used by the encoder to signal that the 
	 * next frame should be encoded as an INTRA regardless of what
	 * the client asks for. This may be either because an error was
	 * detected in compressing the current delta, or to ensure that 
	 * the first frame is encoded INTRA.
	 */
  	EC->bMakeNextFrameKey = TRUE;	// Ensure that we always start with a key frame.

  /*
   * Initialize table with Bit Usage Profile
   */
	for (i = 0; i <= EC->NumMBRows ; i++)
		EC->uBitUsageProfile[i] = i;   // assume linear distribution at first

   /*
  	* Check assumptions about structure sizes and boundary
  	* alignment.
  	*/
  	ASSERT( sizeof(T_Blk) == sizeof_T_Blk )
  	ASSERT( sizeof(T_MBlockActionStream) == sizeof_T_MBlockActionStream )
  	ASSERT( ((sizeof_T_MBlockActionStream-1) & sizeof_T_MBlockActionStream) == 0);  // Size is power of two
  	ASSERT( sizeof(T_H263EncoderCatalog) == sizeof_T_H263EncoderCatalog )

  	// Encoder instance memory should start on a 32 byte boundary.
  	ASSERT( ( (unsigned int)P32Inst & 0x1f) == 0)

  	// MB Action Stream should be on boundary equal to size of a descriptor.
  	ASSERT((((int)EC->pU8_MBlockActionStream) & (sizeof_T_MBlockActionStream-1)) == 0);  // Allocated at right boundary.

  	// Block structure array should be on a 16 byte boundary.
  	ASSERT( ( (unsigned int) &(EC->pU8_MBlockActionStream->BlkY1) & 0xf) == 0)

  	// DCT coefficient array should be on a 32 byte boundary.
  	ASSERT( ( (unsigned int)EC->pU8_DCTCoefBuf & 0x1f) == 0)

  	// Current Frame Buffers should be on 32 byte boundaries.
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_YPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_UPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_VPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_VPlane & 0x1f) == 0x10)

  	// Previous Frame Buffers should be on 32 byte boundaries.
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_VPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_VPlane & 0x1f) == 0x10)
  
  	// Decoder instance structure should be on a DWORD boundary.
  	ASSERT( ( (unsigned int)EC->pDecInstanceInfo & 0x3 ) == 0 )


	/*
 	* Initialize MBActionStream
 	*/
  	int YBlockOffset, UBlockOffset;

  	YBlockOffset	= 0;
  	UBlockOffset = EC->pU8_CurrFrm_UPlane - EC->pU8_CurrFrm_YPlane;

  	for(i = 0; i < EC->NumMBs; i++)
  	{
    	// Clear the counter of the number of consecutive times a
    	// macroblock has been inter coded.
    	(EC->pU8_MBlockActionStream[i]).InterCodeCnt = (i & 0xf);

		// Store offsets to each block in the MB from the beginning of
		// the Y plane.
		(EC->pU8_MBlockActionStream[i]).BlkY1.BlkOffset = YBlockOffset;
		(EC->pU8_MBlockActionStream[i]).BlkY2.BlkOffset = YBlockOffset+8;
		(EC->pU8_MBlockActionStream[i]).BlkY3.BlkOffset = YBlockOffset+PITCH*8;
		(EC->pU8_MBlockActionStream[i]).BlkY4.BlkOffset = YBlockOffset+PITCH*8+8;
		(EC->pU8_MBlockActionStream[i]).BlkU.BlkOffset = UBlockOffset;
		(EC->pU8_MBlockActionStream[i]).BlkV.BlkOffset = UBlockOffset+UV_OFFSET;

		YBlockOffset += 16;
		UBlockOffset += 8;

		(EC->pU8_MBlockActionStream[i]).MBEdgeType = 0xF;
		if ((i % EC->NumMBPerRow) == 0)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsLeftEdge;
		}
		if (((i+1) % EC->NumMBPerRow) == 0)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &=
                            MBEdgeTypeIsRightEdge;
	  		// Set bit six of CodedBlocks to indicate this is the last
	  		// MB of the row.
	  		(EC->pU8_MBlockActionStream[i]).CodedBlocks  |= 0x40;
	  		YBlockOffset += PITCH*16 - EC->NumMBPerRow*16;
	  		UBlockOffset += PITCH*8  - EC->NumMBPerRow*8;
		}
		if (i < EC->NumMBPerRow)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsTopEdge;
		}
		if ((i + EC->NumMBPerRow) >= EC->NumMBs)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsBottomEdge;
		}

	}	// end of for loop.

  /*
   * Initialize previous frame pointers. For now we can do this from here.
   */
/*
  YBlockAddress	= EC->pU8_PrevFrm_YPlane;
  UBlockAddress = EC->pU8_PrevFrm_UPlane;

  for(i = 0; i < EC->NumMBs; i++)
  {
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastRef = YBlockAddress;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastRef = YBlockAddress+8;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastRef = YBlockAddress+PITCH*8;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastRef = YBlockAddress+PITCH*8+8;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastRef = UBlockAddress;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastRef = UBlockAddress+UV_OFFSET;

	// Zero all motion vectors.
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastVMV = 0;

	YBlockAddress += 16;
	UBlockAddress += 8;

	if( (i != 0) && (( (i+1) % EC->NumMBPerRow ) == 0) )
	{
	  YBlockAddress += PITCH*16 - EC->NumMBPerRow*16;
	  UBlockAddress += PITCH*8  - EC->NumMBPerRow*8;
	}

  }	// end of for loop.
*/

   /*
 	* Initialize bit rate controller.
 	*/
	if(pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{
		uIntraQP = pConfiguration->unDefaultIntraQuant;
		uInterQP = pConfiguration->unDefaultInterQuant;
	}
	else
	{
		uIntraQP = def263INTRA_QP;
		uInterQP = def263INTER_QP;
	}
	InitBRC(&(EC->BRCState), uIntraQP, uInterQP, EC->NumMBs);

	if (pConfiguration->bRTPHeader)
		H263RTP_InitBsInfoStream(lpCompInst,EC);

   /*
 	* Create a decoder instance and initialize it. DecoderInstInfo must be in first 64K.
 	*/
  	EC->pDecInstanceInfo->xres = lpCompInst->xres;
  	EC->pDecInstanceInfo->yres = lpCompInst->yres;

  	ret = H263InitDecoderInstance(EC->pDecInstanceInfo, H263_CODEC);
  	if (ret != ICERR_OK)
  		goto done1;
  	ret = H263InitColorConvertor(EC->pDecInstanceInfo, YUV12ForEnc);
  	if (ret != ICERR_OK)
  		goto done1;

   /*
  	* Clear initialized memory.
	*/
	// to be added.

   lpCompInst->Initialized = TRUE;
  	ret = ICERR_OK;

#if defined(H263P)
	// Set the pseudo stack space pointer (to be used for motion estimation and
	// whatever else needs extra stack space).
	EC->pPseudoStackSpace =
		((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->u8PseudoStackSpace +
			(SIZEOF_PSEUDOSTACKSPACE - sizeof(DWORD));
#endif

done1:

  	//GlobalUnlock(lpCompInst->hEncoderInst);

done:

  	return ret;

}


/*******************************************************************************
 *
 * H263Compress 
 *   This function drives the compression of one frame
 * Note:
 *   The timing statistics code produces incorrect no. after PB-frame changes 
 *   were made.
 *******************************************************************************/

LRESULT H263Compress(
#ifdef USE_BILINEAR_MSH26X
    LPINST     pi,
#else
    LPCODINST   lpCompInst,		// ptr to compressor instance info.
#endif
    ICCOMPRESS *lpicComp	    // ptr to ICCOMPRESS structure.
)
{
	FX_ENTRY("H263Compress");

#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpCompInst = (LPCODINST)pi->CompPtr;		// ptr to compressor instance info.
#endif
	//	Start PB-frame data
#if !defined(H263P)
	T_FutrPMBData FutrPMBData[GOBs_IN_CIF*MBs_PER_GOB_CIF + 1];
	I8	WeightForwMotion[128];	//	values based on TRb and TRd
	I8	WeightBackMotion[128];	//	values based on TRb and TRd
#endif
	U8	FutrFrmGQUANT[GOBs_IN_CIF];
	//	End PB-frame

	LRESULT ret;
	UN	GOB, SizeBitStream;
	UN	SizeBSnEBS;

#ifdef DEBUG
	UN i;
#endif

    U8	*pCurBitStream;	// pointer to the current location in the bitstream.
    U8	u8bitoffset;	// bit offset in the current byte of the bitstream.

	U32 uCumFrmSize = 0, GOBHeaderMask;
	U32 uAdjCumFrmSize = 0;

	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    T_MBlockActionStream 		*MBlockActionPtr;

	BOOL  bGOBoverflowWarning = FALSE;	 //RH
	U32   u32tempBuf;					 //RH
	U32   u32sizeBitBuffer; 			 //RH
	U32   u32sizeBSnEBS;

    LPVOID         EncoderInst;
    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };

    unsigned int   gquant, gquant_prev;
    U32			   QP_cumulative;
    U32            IntraSWDTotal, IntraSWDBlocks, InterSWDTotal, InterSWDBlocks;
    int            StartingMB;
    EnumOnOff      bBitRateControl;

    T_CONFIGURATION * pConfiguration = &(lpCompInst->Configuration);

#ifdef ENCODE_STATS
    U32 uBitStreamBytes;
#endif /* ENCODE_STATS */

	U32 iSumSWD = 0, iSumBSWD = 0;
	U32 iSWD = 0, iBSWD = 0;
    U8 u8QPMin;
	// PB-frame variables
    I32 TRb;         
    I32 TRd;         
    I32 j;
    U8 *pP_BitStreamStart;
    U8 *pPB_BitStream;
    U8  u8PB_BitOffset;
    U8 *temp;
	BOOL bEncodePBFrame;
	BOOL bPBFailed;
	U32 u32BFrmZeroThreshold;

    //Chad, intra gob
	int uUsedByIntra=0;
	DWORD dwRTPSize=0;

#if ELAPSED_ENCODER_TIME
    SetStatAdd (STATADDRESS);
    InitStat ();
    ConfigElapsed ();
    ConfigSample ();
    StartElapsed ();
#endif

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uEncodeTime = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	U32 uInputCC = 0;
	U32 uMotionEstimation = 0;
	U32 uFDCT = 0;
	U32 uQRLE = 0;
	U32 uDecodeFrame = 0;
	U32 uZeroingBuffer = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
#endif // } LOG_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#ifdef REUSE_DECODE
    CompandedFrame.Address = NULL;
    CompandedFrame.PDecoderInstInfo = NULL;
    CompandedFrame.FrameNumber = 0xFFFF;
#endif

    ret = ICERR_OK;
    
	// check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

    /*
     * Lock the instance data private to the encoder.
     */
    // EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
    EncoderInst = lpCompInst->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        ret = ICERR_MEMORY;
        goto  done;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));

    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);

	// Check pointer to encoder catalog
	if (!EC)
		return ICERR_ERROR;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (EC->uStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT)
	{
		EC->uStartLow = uStartLow;
		EC->uStartHigh = uStartHigh;
	}
	EC->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_ENCODE_TIMINGS_ON

#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force PB-Frame for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_PB;

	// Force UMV for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_UMV;

	// Force AP for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_AP;

	// Force SAC for testing
	EC->PictureHeader.SAC = ON;

	if (!(lpicComp->dwFlags & ICCOMPRESS_KEYFRAME))
	{
		lpicComp->lFrameNum *= 5;
	}
#endif // } FORCE_ADVANCED_OPTIONS_ON

    /***************************************************************************
     *  Do per-frame initialization.
     **************************************************************************/
	if ((lpicComp->dwFlags & ICCOMPRESS_KEYFRAME) ||
		(*(lpicComp->lpdwFlags) & AVIIF_KEYFRAME) ||
		(EC->bMakeNextFrameKey == TRUE))
    {
		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Coding an Intra Frame\r\n", _fx_));
        EC->PictureHeader.PicCodType = INTRAPIC;
        EC->bMakeNextFrameKey = FALSE;
        EC->u8SavedBFrame = FALSE;
    }
    else
        EC->PictureHeader.PicCodType = INTERPIC;

   /*
    * Check for H.263 options. This is the location that
	* you can manually enable the options if you want.
	*/
	
    if (!EC->bUseINISettings)
	{
        // Check to see if PB frames is requested.
        // For our particular implementation, unrestricted motion vectors
        // are used when PB is on.
        //
        if (lpicComp->dwFlags & CODEC_CUSTOM_PB)
            EC->u8EncodePBFrame = TRUE;
		else
		{
			EC->u8EncodePBFrame = FALSE;
		}

		// Check to see if advanced prediction is requested. 
        if (lpicComp->dwFlags & CODEC_CUSTOM_AP)
			EC->PictureHeader.AP = ON;
		else
			EC->PictureHeader.AP = OFF;

		// Check to see if advanced prediction is requested. 
        if (lpicComp->dwFlags & CODEC_CUSTOM_UMV)
			EC->PictureHeader.UMV = ON;
		else
			EC->PictureHeader.UMV = OFF;

#ifdef H263P
		if (pConfiguration->bH263PlusState)
		{
			// Check to see if in-the-loop deblocking filter is requested.
			if (pConfiguration->bDeblockingFilterState)
				EC->PictureHeader.DeblockingFilter = ON;
			else
				EC->PictureHeader.DeblockingFilter = OFF;

			// Check to see if improved PB-frame mode requested.
			if (pConfiguration->bImprovedPBState)
			{
				EC->PictureHeader.ImprovedPB = ON;
				EC->u8EncodePBFrame = TRUE;
			}
			else
				EC->PictureHeader.ImprovedPB = OFF;
		}
#endif

    	// Turn off AP mode if the QP_mean is lower than a certain level. This should increase
    	// sharpness for low motion (low QP => no AP), and reduce blockiness at high motion 
    	// (higher QP => with AP)
#ifdef USE_MMX // { USE_MMX
		if (ToggleAP == ON && MMX_Enabled == FALSE) 
#else // }{ USE_MMX
		if (ToggleAP == ON) 
#endif // } USE_MMX
		{
			if (EC->PictureHeader.AP == ON && 
			    EC->BRCState.QP_mean < AP_MODE_QP_LEVEL  &&
			    EC->u8EncodePBFrame == FALSE)
				EC->PictureHeader.AP = OFF;
		}
	}

	// If we are not going to encode as a PB-frame, reset the saved flag
	if (EC->u8EncodePBFrame == FALSE)
		EC->u8SavedBFrame = FALSE;

	// verify that flags are set correctly
	if (EC->PictureHeader.UMV == ON)
	{
#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == FALSE)
#endif // } USE_MMX
		{
			// can't do this		
#ifdef USE_MMX // { USE_MMX
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning UMV off MMX_Enabled is FALSE\r\n", _fx_));
#else // }{ USE_MMX
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning UMV off MMX_Enabled is FALSE\r\n", _fx_));
#endif // } USE_MMX
			EC->PictureHeader.UMV = OFF;
		}
	}

#ifdef H263P
	if (EC->PictureHeader.ImprovedPB == ON)
	{
#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == FALSE)
#endif // } USE_MMX
		{
			// can't do this
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning improved PB off MMX_Enabled is FALSE\r\n", _fx_));
			EC->PictureHeader.ImprovedPB = OFF;
		}
	}
#endif // H263P

#ifdef COUNT_BITS
	// Clear bit counters.
	InitBits(EC);
#endif

#ifdef USE_MMX // { USE_MMX
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: AP: %d, PB: %d, UMV: %d, MMX: %d, Target fr.size: %d\r\n", _fx_, EC->PictureHeader.AP, EC->u8EncodePBFrame, EC->PictureHeader.UMV, MMX_Enabled, lpicComp->dwFrameSize));
#else // }{ USE_MMX
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: AP: %d, PB: %d, UMV: %d, Target fr.size: %d\r\n", _fx_, EC->PictureHeader.AP, EC->u8EncodePBFrame, EC->PictureHeader.UMV, lpicComp->dwFrameSize));
#endif // } USE_MMX

#if H263P
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: H.263+ options: IPB: %d, DF: %d\r\n", _fx_, EC->PictureHeader.ImprovedPB, EC->PictureHeader.DeblockingFilter));
#endif

   /*
    * Check to see if this is an inter-frame and if a B frame has not been
	* saved yet. If so, we do nothing but save the frame to the B frame 
	* buffer and exit.
	* 
	*/
	U32	TRB;

	/*
	 * Turn PB frame option back on if it was just
	 * temporariy turned off for last frame.
	 */

	if( EC->u8EncodePBFrame == TEMPORARILY_FALSE )
		EC->u8EncodePBFrame = TRUE;


	// If this is to be saved as a B frame.
    if (EC->u8EncodePBFrame == TRUE &&
        EC->PictureHeader.PicCodType == INTERPIC &&
        EC->u8SavedBFrame == FALSE)
    {
		/*
		 * Set temporal reference for B frame.
		 * It is the number of non-transmitted pictures (at 29.97 Hz)
		 * since the last P or I frame plus 1. TRB has a maximum value
		 * of 7, and can never be zero.
		 * TODO: At the beginning of a sequence, the key frame is compressed,
		 * and then the first frame is copied over to the B frame store, so that
		 * temporal reference for B is zero, which is not allowed. This may cause
		 * problems in some decoders.
		 */	
		 				 
		TRB = (lpicComp->lFrameNum % 256);	// Take the modulo in order to compare it with TR.
		if ( TRB < EC->PictureHeader.TR )
			TRB += 256;						// It should always be greater than TR.

		TRB = TRB - EC->PictureHeader.TR;	// Calculate the TRB value for the bitstream.

		if (TRB > 7)
		{	
			/*
			 * We don't want to encode this as a PB-frame because TRB > 7, or
			 * the adaptive switch has turned PB-frames off for a while.
			 */

			EC->PictureHeader.TR = (lpicComp->lFrameNum % 256);
			EC->u8EncodePBFrame = TEMPORARILY_FALSE;	// Turn off PBframe for this frame.
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: TRB too big (%d), making P frame, TR = %d\r\n", _fx_, TRB, EC->PictureHeader.TR));
		}
		else
		{
			EC->PictureHeader.TRB = (U8) TRB;

			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Saving B Frame, TRB = %d\r\n", _fx_, EC->PictureHeader.TRB));

        	//  Copy with color conversion and return
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
			colorCnvtFrame(EC->ColorConvertor, lpCompInst, lpicComp, EC->pU8_BFrm_YPlane,
					   EC->pU8_BFrm_UPlane, EC->pU8_BFrm_VPlane);
#else

			colorCnvtFrame(EC, lpCompInst, lpicComp, EC->pU8_BFrm_YPlane,
					   EC->pU8_BFrm_UPlane, EC->pU8_BFrm_VPlane);



#endif

        	EC->u8SavedBFrame = TRUE;		// indicate that we saved a B frame.
        	lpCompInst->CompressedSize = 8; //  Internal Encoder/decoder agreement
#ifdef ENCODE_STATS
			StatsFrameSize(lpCompInst->CompressedSize, lpCompInst->CompressedSize);
#endif /* ENCODE_STATS */

        	goto done;  //  <<<<<<<<<<<<<<<<<<<<
		}
    }
	else	// This is a P or I frame.
	{
		// Save temporal reference modulo 256.
		EC->PictureHeader.TR = (lpicComp->lFrameNum % 256);

#ifdef _DEBUG
		if (EC->u8EncodePBFrame == TRUE)
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
		else if (EC->PictureHeader.PicCodType == INTRAPIC)
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: I Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
		else
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: P Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
#endif
	}
	// Initialize Motion Estimation state
	InitMEState(EC, lpicComp, pConfiguration);

    // Get pointer to macrobock action stream.
    MBlockActionPtr = EC->pU8_MBlockActionStream;

    /******************************************************************
     * RGB to YVU 12 Conversion
     ******************************************************************/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	colorCnvtFrame(EC->ColorConvertor, lpCompInst, lpicComp,
				   EC->pU8_CurrFrm_YPlane,
				   EC->pU8_CurrFrm_UPlane,
				   EC->pU8_CurrFrm_VPlane);
#else


	colorCnvtFrame(EC, lpCompInst, lpicComp,
				   EC->pU8_CurrFrm_YPlane,
				   EC->pU8_CurrFrm_UPlane,
			   EC->pU8_CurrFrm_VPlane);


#endif

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInputCC)
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if SAMPLE_RGBCONV_TIME && ELAPSED_ENCODER_TIME
    StopSample ();
#endif

   /******************************************************
    * Set picture level quantizer.
	******************************************************/

	// clear the still quantizer counter if this is not a still frame or
	// it is the key frame for a still frame sequence. R.H.
  	if ( 
  	     ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) == 0 )  ||
		 ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) && 
		  (EC->PictureHeader.PicCodType == INTRAPIC))
	   )
		EC->BRCState.u8StillQnt = 0;

	// If the Encoder Bit Rate section of the configuration has been
	// set ON then, we override quality only or any frame size normally
	// sent in and use frame rate and data rate to determine frame
	// size.
    if (EC->PictureHeader.PicCodType == INTERPIC &&
        lpCompInst->Configuration.bBitRateState == TRUE &&
        lpCompInst->FrameRate != 0.0f &&
		lpicComp->dwFrameSize == 0UL)
	{
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Changing dwFrameSize from %ld to %ld bits\r\n", _fx_, lpicComp->dwFrameSize << 3, (DWORD)((float)lpCompInst->DataRate / lpCompInst->FrameRate) << 3));
		
        lpicComp->dwFrameSize = (U32)((float)lpCompInst->DataRate / lpCompInst->FrameRate);
	}

	// Use a different quantizer selection scheme if this is a
	// progressive still transmission.	
  	if (lpicComp->dwFlags & CODEC_CUSTOM_STILL)
	{
        bBitRateControl = OFF;

#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == TRUE)
        	EC->PictureHeader.PQUANT = StillImageQnt_MMX[ EC->BRCState.u8StillQnt ];
		else
			EC->PictureHeader.PQUANT = StillImageQnt[ EC->BRCState.u8StillQnt ];
#else // }{ USE_MMX
		EC->PictureHeader.PQUANT = StillImageQnt[ EC->BRCState.u8StillQnt ];
#endif // } USE_MMX

		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Setting still frames QP : %d\r\n", _fx_, EC->PictureHeader.PQUANT));
	}
    //  If requested frame size is 0, then we simply set the quantizer
    //  according to the value in dwQuality.
    else
    if (lpicComp->dwFrameSize == 0)
    {
        bBitRateControl = OFF;
        EC->PictureHeader.PQUANT = clampQP((10000 - lpicComp->dwQuality)*32/10000);

		// In case a fixed quality setting is chosen (for example from VidEdit),
		// we have to limit the lower QP value, in order not to blow the quite
		// small bitstream buffer size. This size is set to be compliant with
		// the H.263 spec. If the "chance of buffer overflow" code had not been
		// added (search for "bGOBoverflowWarning", these limits would have had 
		// to be even higher. 
		if (EC->PictureHeader.PicCodType == INTERPIC)
		{
			if (EC->PictureHeader.PQUANT < 3)
				EC->PictureHeader.PQUANT = 3;
		}
		else
		{
			if (EC->PictureHeader.PQUANT < 8)
				EC->PictureHeader.PQUANT = 8;
		}

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller disabled (no target frame size), setting EC->PictureHeader.PQUANT = %ld\r\n", _fx_, EC->PictureHeader.PQUANT));

		// Limit the picture header QP to 2. Because of the calculation of u8QPMin
		// below, this will effectively limit the QP at 2 for all macroblocks.
		// The reason we need this is that the encoder generates an illegal
		// bitstream when encoding a synthetic image for QP=1
		if (EC->PictureHeader.PQUANT == 1)
			EC->PictureHeader.PQUANT = 2;       

		// Calculate the lower level for GQuant in this picture
		u8QPMin = EC->PictureHeader.PQUANT -  EC->PictureHeader.PQUANT/3;

    }
    else
    {
		// Calculate PQUANT based on bits used in last picture

		// Get Target Frame Rate that was passed from CompressFrames structure.
		if (lpCompInst->FrameRate != 0)
			EC->BRCState.TargetFrameRate = lpCompInst->FrameRate;

		bBitRateControl = ON;

		// If this is to be compressed as a PB frame, then we modify
		// the target framesize for the P frame to be a percentage
		// of twice the target frame size.
		if ((EC->u8EncodePBFrame == TRUE) && (EC->PictureHeader.PicCodType == INTERPIC) && (EC->u8SavedBFrame == TRUE))
			EC->BRCState.uTargetFrmSize = (80 * 2 * lpicComp->dwFrameSize)/100;
		else
			EC->BRCState.uTargetFrmSize = lpicComp->dwFrameSize;

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, (DWORD)lpicComp->dwQuality, (DWORD)lpicComp->dwFrameSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - lpicComp->dwQuality)*15/10000)));

		// Get the new quantizer value
		EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);

		// Calculate the min and max value for GQuant in this picture
		u8QPMax = 31;
        u8QPMin = clampQP((10000 - lpicComp->dwQuality)*15/10000);

    }

	gquant_prev = EC->PictureHeader.PQUANT;
	QP_cumulative = 0;

	// Check for AP, UMV or deblocking-filter modes. Each of these allows
	// motion vectors to point outside of the reference picture.
	// Need to verify this in final H.263+ spec for the deblocking filter.
	if (EC->PictureHeader.AP == ON || EC->PictureHeader.UMV
#ifdef H263P
		|| EC->PictureHeader.DeblockingFilter == ON
#endif
	   )
	{
		ExpandPlane((U32)EC->pU8_PrevFrm_YPlane,
			(U32)EC->FrameWidth,
			(U32)EC->FrameHeight,
			16);
		ExpandPlane((U32)EC->pU8_PrevFrm_UPlane,
			(U32)EC->FrameWidth>>1,
			(U32)EC->FrameHeight>>1,
			8);
		ExpandPlane((U32)EC->pU8_PrevFrm_VPlane,
			(U32)EC->FrameWidth>>1,
			(U32)EC->FrameHeight>>1,
			8);
	}

	// If PB-frames are used and AP or UMV is not used at the same time, we can't search
	// for a PB-delta vector (this is a limitation in the motion estimation routine,
	// not the standard)
	// If we allowed searching for B-frame vectors without AP, UMV or DF, we would need
	// to worry about searching outside of the frame
	if (EC->u8EncodePBFrame == TRUE && EC->PictureHeader.AP == OFF &&
		EC->PictureHeader.UMV == OFF
#ifdef H263P
		&& EC->PictureHeader.DeblockingFilter == OFF
#endif
		)
		u32BFrmZeroThreshold = 999999;	 // do not search for other vectors than zero vector
	else
#ifdef USE_MMX // { USE_MMX
		u32BFrmZeroThreshold = (MMX_Enabled == FALSE ? 384 : 500);
#else // }{ USE_MMX
		u32BFrmZeroThreshold = 384;
#endif // } USE_MMX

	// Variables which will not change during the frame
	// Gim 4/16/97 - added u32sizeBSnEBS
	// u32sizeBitBuffer : max. allowable frame size w/o RTP stuff
	// u32sizeBSnEBS	: max. allowable size w/ RTP stuff (EBS & trailer)
#if defined(H263P)
	u32sizeBSnEBS = CompressGetSize(lpCompInst, lpicComp->lpbiInput,
												lpicComp->lpbiOutput);
#elif defined(USE_BILINEAR_MSH26X)
	u32sizeBSnEBS = CompressGetSize(pi, lpicComp->lpbiInput,
												lpicComp->lpbiOutput);
#else
	u32sizeBSnEBS = CompressGetSize(lpCompInst, lpicComp->lpbiInput, 0);
#endif

	if (pConfiguration->bRTPHeader)
		u32sizeBitBuffer = u32sizeBSnEBS - getRTPBsInfoSize(lpCompInst);
	else
		u32sizeBitBuffer = u32sizeBSnEBS;

	u32tempBuf = (3 * u32sizeBitBuffer / EC->NumMBRows) >> 2;

    /*
     * Check to see if we told VfW to create a buffer smaller
     * than the maximum allowable.
     */
    ASSERT(u32sizeBitBuffer <= sizeof_bitstreambuf)

	// Check to see if we are to encode a PB frame
    bEncodePBFrame = (EC->u8EncodePBFrame && EC->u8SavedBFrame);
    bPBFailed = FALSE;

#if defined(H263P)
	EC->pFutrPMBData = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->FutrPMBData;
	EC->pWeightForwMotion = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->WeightForwMotion;  //  values based on TRb and TRd
	EC->pWeightBackMotion = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->WeightBackMotion;  //  values based on TRb and TRd
#endif

	if (bEncodePBFrame)
	{
		TRb = EC->PictureHeader.TRB;

		TRd = (I32) EC->PictureHeader.TR - (I32) EC->PictureHeader.TRPrev;

		if (TRd == 0) {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: TR == TRPrev. Setting TRd = 256\r\n", _fx_));
		}
		else if (TRd < 0) TRd += 256;

		for (j = 0; j < 128; j ++)
		{
#if defined(H263P)
			EC->pWeightForwMotion[j] = (I8) ((TRb * (j-64)) / TRd);
			EC->pWeightBackMotion[j] = (I8) (((TRb-TRd) * (j-64)) / TRd);
#else
			WeightForwMotion[j] = (I8) ((TRb * (j-64)) / TRd);
			WeightBackMotion[j] = (I8) (((TRb-TRd) * (j-64)) / TRd);
#endif
		}
	}
    
	/***************************************************************
     * Initialization before encoding all GOBs.
     * Store frame header code into bitstream buffer.
	 ***************************************************************/

    if (pConfiguration->bRTPHeader)
        H263RTP_ResetBsInfoStream(EC);

    // zero bit stream buffer
    pCurBitStream = EC->pU8_BitStream;
    u8bitoffset = 0;

    GOBHeaderMask = 1;
	EC->GOBHeaderPresent = 0;	// Clear GOB Header Present flag.
  
    encodeFrameHeader(EC, &pCurBitStream, &u8bitoffset, FALSE);

#ifdef USE_MMX // { USE_MMX
    if (MMX_Enabled == FALSE)
	{
        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
            StartingMB = GOB * EC->NumMBPerRow;
		
			gquant = FindNewQuant(EC,gquant_prev,uAdjCumFrmSize,GOB,u8QPMax,u8QPMin,
								  bBitRateControl,bGOBoverflowWarning);

            //  Save gquant for PB-frames
	        FutrFrmGQUANT[GOB] = gquant;
	        QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			MOTIONESTIMATION(
				&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,			 // Not used for H.263.
				1,			 // Do Radius 15 search.
				1,			 // Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
				(EC->PictureHeader.AP == ON ||	EC->PictureHeader.DeblockingFilter) ? 1 : 0,   // Block MVs flag
				 EC->pPseudoStackSpace,
#else
				(EC->PictureHeader.AP == ON) ? 1 : 0,	// Block MVs flag
#endif
				0,			 // No Spatial Filtering
				150,//384,	 // Zero Vector Threshold. If less than this threshold
							 // don't search for NZ MV's. Set to 99999 to not search.
				128,		 // NonZeroMVDifferential. Once the best NZ MV is found,
							 // it must be better than the 0 MV SWD by at least this
							 // amount. Set to 99999 to never choose NZ MV.
				512,		 // BlockMVDifferential. The sum of the four block SWD
							 // must be better than the MB SWD by at least this
							 // amount to choose block MV's.
				20,//96,	 // Empty Threshold. Set to 0 to not force empty blocks.
				550,///1152, // Inter Coding Threshold. If the inter SWD is less than
							 // this amount then don't bother calc. the intra SWD.
				500,		 // Intra Coding Differential. Bias against choosing INTRA
							 // blocks.
				0,			 // Spatial Filtering Threshold.
				0,			 // Spatial Filtering Differential.
				&IntraSWDTotal,
				&IntraSWDBlocks,
				&InterSWDTotal,
				&InterSWDBlocks
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Sum up SWD 
			iSumSWD += IntraSWDTotal + InterSWDTotal;

	       /*
	        * If it's an inter frame then calculate chroma vectors.
			* Also check the inter coded count for each macro block
			* and force to intra if it exceeds 132.
			*/
			if (EC->PictureHeader.PicCodType == INTERPIC)
			{
				calcGOBChromaVectors(EC, StartingMB, pConfiguration);
				// for IA this is called after motion estimation
				Check_InterCodeCnt(EC, StartingMB);
            }

	        //  Save the starting offset of the GOB as the start
	        //  bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	        {
				unsigned int GFID;

				// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
				EC->GOBHeaderPresent |= GOBHeaderMask;

	            // Write GOB start code.
                PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	            // Write GOB number.
                PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	            // Write GOB frame ID.
				// According to section 5.2.5 of the H.263 specification:
				// "GFID shall have the same value in every GOB header of a given
				// picture. Moreover, if PTYPE as indicated in a picture header is
				// the same as for the previous transmitted picture, GFID shall have
				// the same value as in that previous picture. However, if PTYPE in
				// a certain picture header differs from the PTYPE in the previous
				// transmitted picture header, the value for GFID in that picture
				// shall differ from the value in the previous picture."
				// In our usage of H.263, we usually send either I of P frames with
				// all options turned of, or always the same options turned on. This
				// simplifies the fix in allowing us to compute a GFID based only on
				// the picture type and the presence of at least on option.
				GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
					GFID++;
                PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	            // Write GQUANT.
                PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	            gquant_prev = gquant;

				#ifdef COUNT_BITS
				EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
				#endif
	        }

	        /*
	         * Input is the macroblock action stream with pointers to
	         * current and previous blocks. Output is a set of 32 DWORDs
	         * containing pairs of coefficients for each block. There are
	         * from 0 to 12 blocks depending on if PB frames are used and
	         * what the CBP field states.
	         */
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			FORWARDDCT(&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,
				EC->pU8_DCTCoefBuf,
				0,							// 0 = not a B-frame
				EC->PictureHeader.AP == ON, // Advanced prediction (OBMC)
				bEncodePBFrame, 			// Is P of PB pair?
				EC->pU8_PredictionScratchArea,
				EC->NumMBPerRow
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			/*
			* Input is the string of coefficient pairs output from the
			* DCT routine.
			*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			GOB_Q_RLE_VLC_WriteBS(
				EC,
				EC->pU8_DCTCoefBuf,
				&pCurBitStream,
				&u8bitoffset,
#if defined(H263P)
				EC->pFutrPMBData,
#else
				FutrPMBData,
#endif
				GOB,
				gquant,
				pConfiguration->bRTPHeader,
				StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		    //Chad	 INTRA GOB
			if (pConfiguration->bRTPHeader && IsIntraCoded(EC, GOB)) 
				uUsedByIntra += pCurBitStream - EC->pU8_BitStream + 1 - uCumFrmSize;

            // Accumulate number of bytes used in frame so far.
	        uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1; 

			// Here we will check to see if we have blown the buffer. If we have,
			// then we will set the next frame up to be a key frame and return an
			// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
			// overflow the buffer for the next frame.

            if (uCumFrmSize > u32sizeBitBuffer)
			{
				ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
                // Now clear the buffer for the next frame and set up for a key frame
				memset(EC->pU8_BitStream, 0, uCumFrmSize);
				EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
                ret = ICERR_ERROR;              // we blow the buffer on the first key frame: RH
				goto done;
			}
			else 
			{ 
                if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
				{
					// set the next GOB quantizer to be higher to minimize overflowing the
					// buffer at the end of GOB processing.
					bGOBoverflowWarning = TRUE;

					DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Anticipating overflow: uCumFrmSize = %ld bits > (GOB + 1) * u32tempBuf = (#%ld + 1) * %ld\r\n", _fx_, uCumFrmSize << 3, GOB, u32tempBuf << 3));
				}
				else 
					bGOBoverflowWarning = FALSE;  
			}

			// Gim 4/16/97 - moved this adjustment from before to after the
			// buffer check above
			// if the current GOB is intra coded, adjust the cumulated sum
			if (pConfiguration->bRTPHeader)
			{
				if (!GOB)
					uAdjCumFrmSize = uCumFrmSize - uUsedByIntra / 4;
				else
					uAdjCumFrmSize = uCumFrmSize - uUsedByIntra;
			}
			else
				uAdjCumFrmSize = uCumFrmSize;

	    } // for GOB

        //Chad  INTRA GOB restore after use
        uUsedByIntra = 0;

		// Store the number of bits spent so far
		EC->uBitUsageProfile[GOB] = uAdjCumFrmSize;

    }
    else // MMX_Enabled == TRUE
	{
        MMxMESignaturePrep(EC->pU8_PrevFrm_YPlane,
                           EC->pU8_Signature_YPlane,
                           EC->FrameWidth,
                           EC->FrameHeight);

        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
            StartingMB = GOB * EC->NumMBPerRow;
			
			// Check inter code count for all macroblocks on this row
			// Need special version for MMX since it is called before motion estiamtion
			// When the intra coding flag is set, Brian still does motion estimation
			// for this MB in MMXEDTQ if the PB coding flag is set
			Check_InterCodeCnt_MMX(EC, StartingMB);

			gquant = FindNewQuant(EC,gquant_prev,uCumFrmSize,GOB,u8QPMax,u8QPMin,
			                      bBitRateControl,bGOBoverflowWarning);

	        //  Save gquant for PB-frames
	        FutrFrmGQUANT[GOB] = gquant;
	        QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// This does the pass over the Luma blocks...
			__try
			{
				MMxEDTQ (
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_CurrFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_BFrm_YPlane,
					EC->pU8_Signature_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion,
					EC->pWeightBackMotion,
#else
					WeightForwMotion,
					WeightBackMotion,
#endif
					EC->FrameWidth,
					1,							// Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
					// H.263+, deblocking filter automatically turns on
					// block level MVs, but not OBMC
					(EC->PictureHeader.AP == ON) || (EC->PictureHeader.DeblockingFilter == ON), // Block MVs flag
					EC->pPseudoStackSpace,
#else
					EC->PictureHeader.AP == ON, // Block MVs flag
#endif
					0,							// No Spatial Filtering
					EC->PictureHeader.AP == ON, // Advanced Prediction (OBMC) and MVs outside of picture flag
					bEncodePBFrame, 			// Is PB pair?
#ifdef H263P
					EC->PictureHeader.DeblockingFilter == ON,  // Use deblocking filter (8x8 and unrestricted MV's)
					EC->PictureHeader.ImprovedPB == ON,  // Use improved PB-frame method
#endif
					1,							// Do Luma blocks this Pass
					EC->PictureHeader.UMV,		// MVs outside of picture and within [-31.5, 31.5]
#ifdef H263P
					(GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev)),
												// GOB header present. Used to generate MV predictor and search range in UMV
#endif
					gquant,
					min((6*gquant)>>2, 31), 	// TODO: to match DBQUANT in picture header
					u32BFrmZeroThreshold,		// BFrmZeroVectorThreshold
					0,							// SpatialFiltThreshold
					0,							// SpatialFiltDifferential
					&iSWD,
					&iBSWD,
					EC->pI8_MBRVS_Luma,
					EC->pI8_MBRVS_BLuma+GOB*(65*3*22*4)
				);
			}
			__except(ExceptionFilterForMMxEDTQ(GetExceptionInformation(),EC->pI8_MBRVS_BLuma,1))
			{
				// no exception handler
			}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Sum up SWDs
			iSumSWD += iSWD;
			iSumBSWD += iBSWD;

	       /*
	        * If it's an inter frame then calculate chroma vectors.
			* Also check the inter coded count for each macro block
			* and force to intra if it exceeds 132.
			*/
	        if (EC->PictureHeader.PicCodType == INTERPIC)
	        {
				calcGOBChromaVectors(EC, StartingMB, pConfiguration);

				if (bEncodePBFrame) 
                    // Calculate chroma vectors.
					calcBGOBChromaVectors(EC, StartingMB);
            }

            // Save the starting offset of the GOB as the start
            // bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	        {
				unsigned int GFID;

				// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
				EC->GOBHeaderPresent |= GOBHeaderMask;

	            // Write GOB start code.
                PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	            // Write GOB number.
                PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	            // Write GOB frame ID.
				// According to section 5.2.5 of the H.263 specification:
				// "GFID shall have the same value in every GOB header of a given
				// picture. Moreover, if PTYPE as indicated in a picture header is
				// the same as for the previous transmitted picture, GFID shall have
				// the same value as in that previous picture. However, if PTYPE in
				// a certain picture header differs from the PTYPE in the previous
				// transmitted picture header, the value for GFID in that picture
				// shall differ from the value in the previous picture."
				// In our usage of H.263, we usually send either I of P frames with
				// all options turned of, or always the same options turned on. This
				// simplifies the fix in allowing us to compute a GFID based only on
				// the picture type and the presence of at least on option.
				GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
					GFID++;
                PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	            // Write GQUANT.
                PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	            gquant_prev = gquant;

				#ifdef COUNT_BITS
				EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
				#endif
	        }

	        /*
	         * Input is the macroblock action stream with pointers to
	         * current and previous blocks. Output is a set of 32 DWORDs
	         * containing pairs of coefficients for each block. There are
	         * from 0 to 12 blocks depending on if PB frames are used and
	         * what the CBP field states.
	         */
	           // This does the pass over the Chroma blocks....
	           //
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			__try
			{
				MMxEDTQ (
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_CurrFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_BFrm_YPlane,
					EC->pU8_Signature_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion,
					EC->pWeightBackMotion,
#else
					WeightForwMotion,
					WeightBackMotion,
#endif
					EC->FrameWidth,
					1,							// Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
					// H.263+, deblocking filter automatically turns on
					// block level MVs, but not OBMC
					(EC->PictureHeader.AP == ON) || (EC->PictureHeader.DeblockingFilter == ON), // Block MVs flag
					EC->pPseudoStackSpace,
#else
					EC->PictureHeader.AP == ON, // Block MVs flag
#endif
					0,							// No Spatial Filtering
					EC->PictureHeader.AP == ON, // Advanced Prediction (OBMC)
					bEncodePBFrame, 			// Is PB pair?
#ifdef H263P
					EC->PictureHeader.DeblockingFilter == ON,  // Use deblocking filter (8x8 and unrestricted MV's)
					EC->PictureHeader.ImprovedPB == ON,  // Use improved PB-frame method
					0,							// If not H.263+, must be 0
					0,							// If not H.263+, must be 0
#endif
					0,							// Do Chroma blocks this Pass
					0,							// 1 for extended motion vectors
#ifdef H263P
					0,							// GOB header present. Used in UMV to generate MV predictor.
#endif
					gquant,
					min((6*gquant) >> 2, 31),
					500,						// BFrmZeroVectorThreshold
					0,							// SpatialFiltThreshold
					0,							// SpatialFiltDifferential
					&iSWD,
					&iBSWD,
					EC->pI8_MBRVS_Chroma,
					EC->pI8_MBRVS_BChroma+GOB*(65*3*22*2)
				);
			}
			__except(ExceptionFilterForMMxEDTQ(GetExceptionInformation(),EC->pI8_MBRVS_BChroma,0))
			{
				// no exception handler
			}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			/*
			* Input is the string of coefficient pairs output from the
			* DCT routine.
			*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			GOB_VLC_WriteBS(
				EC,
				EC->pI8_MBRVS_Luma,
				EC->pI8_MBRVS_Chroma,
				&pCurBitStream,
				&u8bitoffset,
#if defined(H263P)
				EC->pFutrPMBData,
#else
				FutrPMBData,
#endif
				GOB,
				gquant,
				pConfiguration->bRTPHeader,
				StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Accumulate number of bytes used in frame so far.
			uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1;

			// Here we will check to see if we have blown the buffer. If we have,
			// then we will set the next frame up to be a key frame and return an
			// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
			// overflow the buffer for the next frame.

			if (uCumFrmSize > u32sizeBitBuffer) 
			{
				ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
				memset(EC->pU8_BitStream, 0, uCumFrmSize);
				EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
				ret = ICERR_ERROR;				// we blow the buffer on the first key frame: RH 
				goto done;
            }
			else 
			{ 
                if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
					// set the next GOB quantizer to be higher to minimize overflowing the
					// buffer at the end of GOB processing.
					bGOBoverflowWarning = TRUE;
				else 
					bGOBoverflowWarning = FALSE;  
			}
	    } // for GOB

	    // Store the number of bits spent so far
	    EC->uBitUsageProfile[GOB] = uCumFrmSize;

		// This is the new MMX PB-frames switch
		// Simple check to see if B-frame will look bad
		// This could be possibly be improved by looking at the
		// actual number of coefficients, or the number of bits
		// in the bitstream.
#ifdef H263P
		// Always use the B frame if improved PB-frame mode and AP or UMV mode requested
		if (TogglePB == TRUE && iSumBSWD >= iSumSWD &&
			!(EC->PictureHeader.ImprovedPB == ON &&
			 (EC->PictureHeader.AP == ON || EC->PictureHeader.UMV == ON ||
			  EC->PictureHeader.DeblockingFilter == ON)))
#else
		if (TogglePB == TRUE && iSumBSWD >= iSumSWD)
#endif
        {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
            bEncodePBFrame = FALSE;
            EC->u8SavedBFrame = FALSE;
		}
    }
#else // }{ USE_MMX
    for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	{
        StartingMB = GOB * EC->NumMBPerRow;
	
			gquant = FindNewQuant(EC,gquant_prev,uAdjCumFrmSize,GOB,u8QPMax,u8QPMin,
								  bBitRateControl,bGOBoverflowWarning);

        //  Save gquant for PB-frames
	    FutrFrmGQUANT[GOB] = gquant;
	    QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			MOTIONESTIMATION(
				&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,			 // Not used for H.263.
				1,			 // Do Radius 15 search.
				1,			 // Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
				(EC->PictureHeader.AP == ON ||	EC->PictureHeader.DeblockingFilter) ? 1 : 0,   // Block MVs flag
				 EC->pPseudoStackSpace,
#else
				(EC->PictureHeader.AP == ON) ? 1 : 0,	// Block MVs flag
#endif
				0,			 // No Spatial Filtering
				150,//384,	 // Zero Vector Threshold. If less than this threshold
							 // don't search for NZ MV's. Set to 99999 to not search.
				128,		 // NonZeroMVDifferential. Once the best NZ MV is found,
							 // it must be better than the 0 MV SWD by at least this
							 // amount. Set to 99999 to never choose NZ MV.
				512,		 // BlockMVDifferential. The sum of the four block SWD
							 // must be better than the MB SWD by at least this
							 // amount to choose block MV's.
				20,//96,	 // Empty Threshold. Set to 0 to not force empty blocks.
				550,///1152, // Inter Coding Threshold. If the inter SWD is less than
							 // this amount then don't bother calc. the intra SWD.
				500,		 // Intra Coding Differential. Bias against choosing INTRA
							 // blocks.
				0,			 // Spatial Filtering Threshold.
				0,			 // Spatial Filtering Differential.
				&IntraSWDTotal,
				&IntraSWDBlocks,
				&InterSWDTotal,
				&InterSWDBlocks
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Sum up SWD 
		iSumSWD += IntraSWDTotal + InterSWDTotal;

	   /*
	    * If it's an inter frame then calculate chroma vectors.
		* Also check the inter coded count for each macro block
		* and force to intra if it exceeds 132.
		*/
		if (EC->PictureHeader.PicCodType == INTERPIC)
		{
			calcGOBChromaVectors(EC, StartingMB, pConfiguration);
			// for IA this is called after motion estimation
			Check_InterCodeCnt(EC, StartingMB);
        }

	    //  Save the starting offset of the GOB as the start
	    //  bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

        if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	    {
			unsigned int GFID;

			// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
			EC->GOBHeaderPresent |= GOBHeaderMask;

	        // Write GOB start code.
            PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	        // Write GOB number.
            PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	        // Write GOB frame ID.
			// According to section 5.2.5 of the H.263 specification:
			// "GFID shall have the same value in every GOB header of a given
			// picture. Moreover, if PTYPE as indicated in a picture header is
			// the same as for the previous transmitted picture, GFID shall have
			// the same value as in that previous picture. However, if PTYPE in
			// a certain picture header differs from the PTYPE in the previous
			// transmitted picture header, the value for GFID in that picture
			// shall differ from the value in the previous picture."
			// In our usage of H.263, we usually send either I of P frames with
			// all options turned of, or always the same options turned on. This
			// simplifies the fix in allowing us to compute a GFID based only on
			// the picture type and the presence of at least on option.
			GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
			if (EC->PictureHeader.PicCodType == INTRAPIC)
				GFID++;
            PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	        // Write GQUANT.
            PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	        gquant_prev = gquant;

			#ifdef COUNT_BITS
			EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
			#endif
	    }

	    /*
	     * Input is the macroblock action stream with pointers to
	     * current and previous blocks. Output is a set of 32 DWORDs
	     * containing pairs of coefficients for each block. There are
	     * from 0 to 12 blocks depending on if PB frames are used and
	     * what the CBP field states.
	     */
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		FORWARDDCT(&(EC->pU8_MBlockActionStream[StartingMB]),
			EC->pU8_CurrFrm_YPlane,
			EC->pU8_PrevFrm_YPlane,
			0,
			EC->pU8_DCTCoefBuf,
			0,							// 0 = not a B-frame
			EC->PictureHeader.AP == ON, // Advanced prediction (OBMC)
			bEncodePBFrame, 			// Is P of PB pair?
			EC->pU8_PredictionScratchArea,
			EC->NumMBPerRow
		);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/*
		* Input is the string of coefficient pairs output from the
		* DCT routine.
		*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		GOB_Q_RLE_VLC_WriteBS(
			EC,
			EC->pU8_DCTCoefBuf,
			&pCurBitStream,
			&u8bitoffset,
#if defined(H263P)
			EC->pFutrPMBData,
#else
			FutrPMBData,
#endif
			GOB,
			gquant,
			pConfiguration->bRTPHeader,
			StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		//Chad	 INTRA GOB
		if (pConfiguration->bRTPHeader && IsIntraCoded(EC, GOB)) 
			uUsedByIntra += pCurBitStream - EC->pU8_BitStream + 1 - uCumFrmSize;

        // Accumulate number of bytes used in frame so far.
	    uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1; 

		// Here we will check to see if we have blown the buffer. If we have,
		// then we will set the next frame up to be a key frame and return an
		// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
		// overflow the buffer for the next frame.

        if (uCumFrmSize > u32sizeBitBuffer)
		{
			ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
            // Now clear the buffer for the next frame and set up for a key frame
			memset(EC->pU8_BitStream, 0, uCumFrmSize);
			EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
            ret = ICERR_ERROR;              // we blow the buffer on the first key frame: RH
			goto done;
		}
		else 
		{ 
            if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
				// set the next GOB quantizer to be higher to minimize overflowing the
				// buffer at the end of GOB processing.
				bGOBoverflowWarning = TRUE;
			else 
				bGOBoverflowWarning = FALSE;  
		}

		// Gim 4/16/97 - moved this adjustment from before to after the
		// buffer check above
		// if the current GOB is intra coded, adjust the cumulated sum
		if (pConfiguration->bRTPHeader)
		{
			if (!GOB)
				uAdjCumFrmSize = uCumFrmSize - uUsedByIntra / 4;
			else
				uAdjCumFrmSize = uCumFrmSize - uUsedByIntra;
		}
		else
			uAdjCumFrmSize = uCumFrmSize;

	} // for GOB

    //Chad  INTRA GOB restore after use
    uUsedByIntra = 0;

	// Store the number of bits spent so far
	EC->uBitUsageProfile[GOB] = uAdjCumFrmSize;
#endif // } USE_MMX

    #ifdef COUNT_BITS
    WriteCountBitFile( &(EC->Bits) );
    #endif

    // ------------------------------------------------------------------------
    //  Write the MBStartBitOff in the sentinel macroblock
    // ------------------------------------------------------------------------

	if (bEncodePBFrame)
	{	// Encoding future P frame
#if defined(H263P)
		EC->pFutrPMBData[EC->NumMBs].MBStartBitOff
			= (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
		FutrPMBData[EC->NumMBs].MBStartBitOff
			= (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif

		#ifdef DEBUG
		for (i = 0; i < EC->NumMBs; i++)
		{
#if defined(H263P)
			ASSERT(EC->pFutrPMBData[i].MBStartBitOff < EC->pFutrPMBData[i + 1].MBStartBitOff)
			ASSERT(EC->pFutrPMBData[i].CBPYBitOff <= EC->pFutrPMBData[i].MVDBitOff)
			ASSERT(EC->pFutrPMBData[i].MVDBitOff <= EC->pFutrPMBData[i].BlkDataBitOff)
			ASSERT(EC->pFutrPMBData[i].BlkDataBitOff <= (EC->pFutrPMBData[i + 1].MBStartBitOff - EC->pFutrPMBData[i].MBStartBitOff))
#else
			ASSERT(FutrPMBData[i].MBStartBitOff < FutrPMBData[i + 1].MBStartBitOff)
			ASSERT(FutrPMBData[i].CBPYBitOff <= FutrPMBData[i].MVDBitOff)
			ASSERT(FutrPMBData[i].MVDBitOff <= FutrPMBData[i].BlkDataBitOff)
			ASSERT(FutrPMBData[i].BlkDataBitOff <= (FutrPMBData[i + 1].MBStartBitOff - FutrPMBData[i].MBStartBitOff))
#endif
		}
		#endif
	}

    // ------------------------------------------------------------------------
    // Copy the compressed image to the output area.
    // ------------------------------------------------------------------------

    SizeBitStream = pCurBitStream - EC->pU8_BitStream + 1;

    /* make sure we don't write 8 empty bits */
    if (!u8bitoffset) SizeBitStream --;

    // Gim 4/21/97 - added check for overall buffer overflow before attaching
	// RTP info and trailer to the end of a P or I frame bitstream
    if (pConfiguration->bRTPHeader)
    {
        SizeBSnEBS = SizeBitStream + H263RTP_GetMaxBsInfoStreamSize(EC);

        if (SizeBSnEBS > u32sizeBSnEBS)
        {
			ERRORMESSAGE(("%s: BS+EBS buffer overflow, SizeBSnEBS %d > %d\r\n", _fx_, SizeBSnEBS, u32sizeBSnEBS));
			memset(EC->pU8_BitStream, 0, SizeBitStream);
            EC->bMakeNextFrameKey = TRUE;
            ret = ICERR_ERROR;
            goto done;
        }
    }

    #ifdef ENCODE_STATS
    uBitStreamBytes = SizeBitStream;
    #endif

    memcpy(lpicComp->lpOutput, EC->pU8_BitStream, SizeBitStream);
    memset(EC->pU8_BitStream, 0, SizeBitStream);

    if (pConfiguration->bRTPHeader)
        SizeBitStream += (WORD) H263RTP_AttachBsInfoStream(EC,
                         (U8 *) lpicComp->lpOutput, SizeBitStream);

    lpCompInst->CompressedSize = SizeBitStream;

    // ------------------------------------------------------------------------
    //  Run the decoder on this frame, to get next basis for prediction.
    // ------------------------------------------------------------------------

    ICDecExSt = DefaultICDecExSt;
    ICDecExSt.lpSrc = lpicComp->lpOutput;
    ICDecExSt.lpbiSrc = lpicComp->lpbiOutput;
    ICDecExSt.lpbiSrc->biSizeImage = SizeBitStream;

    // Decode it in future frame if doing PB-frame
    ICDecExSt.lpDst   = bEncodePBFrame ? EC->pU8_FutrFrm : EC->pU8_PrevFrm;

    ICDecExSt.lpbiDst = NULL;

    if (EC->PictureHeader.PicCodType == INTERPIC)
        ICDecExSt.dwFlags = ICDECOMPRESS_NOTKEYFRAME;

    // Call the decompressor
	// Call the decompressor 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeFrame)
#endif // } DETAILED_ENCODE_TIMINGS_ON

    if (ret != ICERR_OK)
    {
        // Check to see if an error occurred in the decoder.  If it did
        // we don't have a valid "previous frame" hence force the next
        // frame to be a key frame.
		ERRORMESSAGE(("%s: Decoder failed in encoder\r\n", _fx_));
        EC->bMakeNextFrameKey = TRUE;
        ret = ICERR_ERROR;
        goto done;
    }

    // ------------------------------------------------------------------------
    //  Start processing the saved B frame.
    // ------------------------------------------------------------------------

    if (bEncodePBFrame)
    {
        #ifdef COUNT_BITS
        InitBits(EC);
        #endif

        // zero PB-frame bit stream buffer.
        pPB_BitStream     = EC->pU8_BitStrCopy;
        pP_BitStreamStart = (U8 *) lpicComp->lpOutput;
        u8PB_BitOffset    = 0;

        // Encode the frame header
        EC->PictureHeader.PB = ON;

        // Clear GOB Header Present flag.
        EC->GOBHeaderPresent = 0;
        GOBHeaderMask = 1;

        gquant_prev = EC->PictureHeader.PQUANT;

        if (pConfiguration->bRTPHeader)
            H263RTP_ResetBsInfoStream(EC);

        encodeFrameHeader(EC, &pPB_BitStream, &u8PB_BitOffset, TRUE);

#ifdef USE_MMX // { USE_MMX
        if (MMX_Enabled == FALSE)
        {
            /*****************************************
	         *  . copy edge pels in the previous frame
	         *  . initialize arrays used in motion estimation
	         *  . foreach(GOB)
	         *      . BFRAMEMOTIONESTIMATION
	         *      . Compute Chroma motion vectors
	         *      . Write GOB header
	         *      . FORWARDDCT
	         *      . PB_GOB_Q_RLE_VLC_WriteBS
	         *****************************************/

            for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	        {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));

                gquant = FutrFrmGQUANT[GOB];

                if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
                {
                    // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                    EC->GOBHeaderPresent |= GOBHeaderMask;

                    gquant_prev = gquant;
                }

                StartingMB = GOB * EC->NumMBPerRow;

				BFRAMEMOTIONESTIMATION(
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_BFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_FutrFrm_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion+32,
					EC->pWeightBackMotion+32,
#else
					WeightForwMotion+32,
					WeightBackMotion+32,
#endif
					u32BFrmZeroThreshold, // Zero Vector Threshold. If less than this threshold don't search for
#if defined(H263P)
					EC->pPseudoStackSpace,
#endif
							// NZ MV's. Set to 99999 to not search.
					128,	// NonZeroMVDifferential. Once the best NZ MV is found, it must be better
							// than the 0 MV SWD by at least this amount.
							// Set to 99999 to never choose NZ MV.
					96, 	// Empty Threshold. Set to 0 to not force empty blocks.
					&InterSWDTotal,
					&InterSWDBlocks
				);

				iSumBSWD += InterSWDTotal;
                if (TogglePB && iSumBSWD >= (3 * iSumSWD) >> 1)
                {
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
                    memset(EC->pU8_BitStrCopy, 0, pPB_BitStream - EC->pU8_BitStrCopy + 1);
                    bPBFailed = TRUE;
                    break;
                }

                // Calculate chroma vectors.
	            calcBGOBChromaVectors(EC, StartingMB);

                FORWARDDCT( 
                    &(EC->pU8_MBlockActionStream[StartingMB]),
                    EC->pU8_BFrm_YPlane,
                    EC->pU8_PrevFrm_YPlane,
                    EC->pU8_FutrFrm_YPlane,
                    EC->pU8_DCTCoefBuf,
                    1,               //  1 = BFrame
                    0,               //  Advanced prediction irrelevant for B frame.
                    0,               //  Is not P of PB pair.
                    0,               //  PredictionScratchArea unneeded.
                    EC->NumMBPerRow
                );

                // GOB header is copied to PB stream when the data for the first
                // macroblock in the GOB is copied

				PB_GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6*FutrFrmGQUANT[GOB])>>2, 31), // TODO: to match DBQUANT in picture header
					pConfiguration->bRTPHeader
				);
            }
        }
        else // MMX_Enabled == TRUE
	    {
            for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	        {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));

                gquant = FutrFrmGQUANT[GOB];

                if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
                {
                    // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                    EC->GOBHeaderPresent |= GOBHeaderMask;

                    gquant_prev = gquant;
                }

                // GOB header is copied to PB stream when the data for the first
                // macroblock in the GOB is copied

				PB_GOB_VLC_WriteBS(
					EC,
					EC->pI8_MBRVS_BLuma+GOB*(65*3*22*4),
					EC->pI8_MBRVS_BChroma+GOB*(65*3*22*2),
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6 * gquant) >> 2, 31),
					pConfiguration->bRTPHeader);
            }
        }
#else // }{ USE_MMX
        /*****************************************
	     *  . copy edge pels in the previous frame
	     *  . initialize arrays used in motion estimation
	     *  . foreach(GOB)
	     *      . BFRAMEMOTIONESTIMATION
	     *      . Compute Chroma motion vectors
	     *      . Write GOB header
	     *      . FORWARDDCT
	     *      . PB_GOB_Q_RLE_VLC_WriteBS
	     *****************************************/

        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));
            gquant = FutrFrmGQUANT[GOB];

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
            {
                // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                EC->GOBHeaderPresent |= GOBHeaderMask;

                gquant_prev = gquant;
            }

            StartingMB = GOB * EC->NumMBPerRow;

				BFRAMEMOTIONESTIMATION(
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_BFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_FutrFrm_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion+32,
					EC->pWeightBackMotion+32,
#else
					WeightForwMotion+32,
					WeightBackMotion+32,
#endif
					u32BFrmZeroThreshold, // Zero Vector Threshold. If less than this threshold don't search for
#if defined(H263P)
					EC->pPseudoStackSpace,
#endif
							// NZ MV's. Set to 99999 to not search.
					128,	// NonZeroMVDifferential. Once the best NZ MV is found, it must be better
							// than the 0 MV SWD by at least this amount.
							// Set to 99999 to never choose NZ MV.
					96, 	// Empty Threshold. Set to 0 to not force empty blocks.
					&InterSWDTotal,
					&InterSWDBlocks
				);

			iSumBSWD += InterSWDTotal;
            if (TogglePB && iSumBSWD >= (3 * iSumSWD) >> 1)
            {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
                memset(EC->pU8_BitStrCopy, 0, pPB_BitStream - EC->pU8_BitStrCopy + 1);
                bPBFailed = TRUE;
                break;
            }

            // Calculate chroma vectors.
	        calcBGOBChromaVectors(EC, StartingMB);

            FORWARDDCT( 
                &(EC->pU8_MBlockActionStream[StartingMB]),
                EC->pU8_BFrm_YPlane,
                EC->pU8_PrevFrm_YPlane,
                EC->pU8_FutrFrm_YPlane,
                EC->pU8_DCTCoefBuf,
                1,               //  1 = BFrame
                0,               //  Advanced prediction irrelevant for B frame.
                0,               //  Is not P of PB pair.
                0,               //  PredictionScratchArea unneeded.
                EC->NumMBPerRow
            );

            // GOB header is copied to PB stream when the data for the first
            // macroblock in the GOB is copied

				PB_GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6*FutrFrmGQUANT[GOB])>>2, 31), // TODO: to match DBQUANT in picture header
					pConfiguration->bRTPHeader
				);
        }
#endif // } USE_MMX

        if (bPBFailed == FALSE)
		{
			// Copy the compressed image to the output area.
			SizeBitStream = pPB_BitStream - EC->pU8_BitStrCopy + 1;

			// make sure we don't write 8 empty bits
			if (u8PB_BitOffset == 0) SizeBitStream --;

            // Gim 4/21/97 - check to see if the PB buffer overflows the spec
            // size. If it does, zero out the PB buffer and continue.  The P
            // frame encoded will be returned.
			if (SizeBitStream > u32sizeBitBuffer)
			{
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB buffer overflow, SizeBitStream %d > %d\r\n", _fx_, SizeBitStream, u32sizeBitBuffer));
                bPBFailed = TRUE;
			}
            else
            if (pConfiguration->bRTPHeader)
            {
                SizeBSnEBS = SizeBitStream + H263RTP_GetMaxBsInfoStreamSize(EC);

                if (SizeBSnEBS > u32sizeBSnEBS)
                {
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB BS+EBS buffer overflow, SizeBSnEBS %d > %d\r\n", _fx_, SizeBSnEBS, u32sizeBSnEBS));
                    bPBFailed = TRUE;
                }
            }

            if (bPBFailed == TRUE)
			{
                // if buffer overflow has been detected, we will drop the PB
                // and return the encoded P
                memset(EC->pU8_BitStrCopy, 0, SizeBitStream);
                EC->u8SavedBFrame = FALSE;
			}
			else
            {
                #ifdef ENCODE_STATS
				uBitStreamBytes = SizeBitStream;
				#endif

				memcpy(lpicComp->lpOutput, EC->pU8_BitStrCopy, SizeBitStream);
				memset(EC->pU8_BitStrCopy, 0, SizeBitStream);

                if (pConfiguration->bRTPHeader)
                    SizeBitStream += (WORD) H263RTP_AttachBsInfoStream(EC,
                                     (U8 *) lpicComp->lpOutput, SizeBitStream);

				lpCompInst->CompressedSize = SizeBitStream;
			}
        }

        // For the next PB-frame, frame pointers are swapped; i.e. for the next
        // frame future ...

        temp = EC->pU8_PrevFrm;
        EC->pU8_PrevFrm = EC->pU8_FutrFrm;
        EC->pU8_FutrFrm = temp;

        temp = EC->pU8_PrevFrm_YPlane;
        EC->pU8_PrevFrm_YPlane = EC->pU8_FutrFrm_YPlane;
        EC->pU8_FutrFrm_YPlane = temp;

        temp = EC->pU8_PrevFrm_UPlane;
        EC->pU8_PrevFrm_UPlane = EC->pU8_FutrFrm_UPlane;
        EC->pU8_FutrFrm_UPlane = temp;

        temp = EC->pU8_PrevFrm_VPlane;
        EC->pU8_PrevFrm_VPlane = EC->pU8_FutrFrm_VPlane;
        EC->pU8_FutrFrm_VPlane = temp;

        EC->u8SavedBFrame = FALSE;
        EC->PictureHeader.PB = OFF;   // RH: why is this here ?
    } // if (bEncodePBFrame)

	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Frame size: %d\r\n", _fx_, lpCompInst->CompressedSize));

    #ifdef ENCODE_STATS
    StatsFrameSize(uBitStreamBytes, lpCompInst->CompressedSize);
    #endif

    // ------------------------------------------------------------------------
    //  update states for next frame, etc.
    // ------------------------------------------------------------------------

	// This is a still image sequence and there is still more quantizers
	// in the sequence, then increment the quantizer.
    if ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) &&
        (EC->BRCState.u8StillQnt < (numStillImageQnts-1)))
        EC->BRCState.u8StillQnt ++;

    // Calculate average quantizer to be used for next frame.
    if (EC->PictureHeader.PicCodType == INTERPIC)
    	EC->BRCState.QP_mean = (QP_cumulative + (EC->NumMBRows >> 1)) / EC->NumMBRows;
	else
		// If this is an INTRA frame, then we don't want to
		// use the QP for the next delta frame, hence we just
		// reset the QP_mean to the default.
    	EC->BRCState.QP_mean = def263INTER_QP;

    // Record frame size for bit rate controller on next frame.

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)
	DWORD dwTransportOverhead;

	// Estimate the transport overhead
	if (pConfiguration->bRTPHeader)
		dwTransportOverhead = (lpCompInst->CompressedSize / pConfiguration->unPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		dwTransportOverhead = 0UL;

#ifdef USE_MMX // { USE_MMX
	if (EC->PictureHeader.PicCodType == INTRAPIC)
		EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize);
	else
		EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize);

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize) << 3) + (dwTransportOverhead << 3), ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize) << 3, dwTransportOverhead << 3));
#else // }{ USE_MMX
    if (EC->PictureHeader.PicCodType == INTRAPIC)
        EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + uAdjCumFrmSize;
    else
		EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + uAdjCumFrmSize;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (uAdjCumFrmSize << 3) + (dwTransportOverhead << 3), uAdjCumFrmSize << 3, dwTransportOverhead << 3));
#endif // } USE_MMX

	// Save temporal reference for next frame.
	EC->PictureHeader.TRPrev = EC->PictureHeader.TR;

	// Save AP, UMV and DF modes in case InitMEState needs to re-initialize some data
	if (EC->PictureHeader.PicCodType == INTERPIC)
	{
		EC->prevAP = EC->PictureHeader.AP;
		EC->prevUMV = EC->PictureHeader.UMV;
#ifdef H263P
		EC->prevDF = EC->PictureHeader.DeblockingFilter;
#endif
	}

	// send mean quantizer to real-time app. Not necessary, info. only
	*(lpicComp->lpdwFlags) |= (EC->BRCState.QP_mean << 16);

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uEncodeTime);

	if (bTimingThisFrame)
	{
		// Update the decompression timings counter
		#pragma message ("Current encode timing computations assume P5/90Mhz")
		UPDATE_COUNTER(g_pctrCompressionTimePerFrame, (uEncodeTime + 45000UL) / 90000UL);

		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Compression time: %ld\r\n", _fx_, (uEncodeTime + 45000UL) / 90000UL));
	}
#endif // } ENCODE_TIMINGS_ON

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (bTimingThisFrame)
	{
		pEncTimingInfo = EC->pEncTimingInfo + EC->uStatFrameCount;
		pEncTimingInfo->uEncodeFrame      = uEncodeTime;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		pEncTimingInfo->uInputCC          = uInputCC;
		pEncTimingInfo->uMotionEstimation = uMotionEstimation;
		pEncTimingInfo->uFDCT             = uFDCT;
		pEncTimingInfo->uQRLE             = uQRLE;
		pEncTimingInfo->uDecodeFrame      = uDecodeFrame;
		pEncTimingInfo->uZeroingBuffer    = uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
		EC->uStatFrameCount++;
	}
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

/*
#ifdef REUSE_DECODE
    CompandedFrame.Address = (unsigned char*) lpicComp->lpOutput;
    CompandedFrame.PDecoderInstInfo = PDecoderInstInfo;
    CompandedFrame.FrameNumber = PFrmHdr->FrameNumber;
#endif
*/

#if ELAPSED_ENCODER_TIME
    StopElapsed ();
    Elapsed = ReadElapsed () / 4L;
    Sample = ReadSample () / 4L;
#if 01
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: "%ld,%ld us\r\n", _fx_, Elapsed, Sample));
#else
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Elapsed time to encode frame: %ld us\r\n", _fx_, Elapsed));
#if SAMPLE_RGBCONV_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to convert RGB24 to YUV9: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_MOTION_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to do motion estimation: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode block layer: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCMBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode macroblock layer: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCVLC_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode VLC: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_COMPAND_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to decode companded image: %ld us\r\n", _fx_, Sample));
#endif
#endif
    TotalElapsed += Elapsed;
    TotalSample  += Sample;
    TimedIterations++;
#endif

done:
//    GlobalUnlock(lpCompInst->hEncoderInst);

#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force advanced options for testing
	if (!(lpicComp->dwFlags & ICCOMPRESS_KEYFRAME))
		lpicComp->lFrameNum /= 5;
#endif // } FORCE_ADVANCED_OPTIONS_ON

#ifdef USE_MMX // { USE_MMX
	if (MMX_Enabled)
	{
		__asm {
			_emit 0x0f
			_emit 0x77	//	emms
		}
	}
#endif // } USE_MMX

    return ret;
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func UN | FindNewQuant | This function computes the GQUANT value to
 *   use for a GOB.
 *
 * @parm T_H263EncoderCatalog * | EC | Specifies a pointer to the encoder
 *   catalog (global encoder state).
 *
 * @parm UN | gquant_prev | Specifies the GQUANT value of the previous GOB.
 *
 * @parm UN | uCumFrmSize | Specifies the cumulated size of the previous GOBs.
 *
 * @parm UN | GOB | Specifies the number of the GOB to find a new quantizer
 *   for.
 *
 * @parm U8 | u8QPMax | Specifies the maximum GQUANT value for the GOB. It
 *   is always set to 31.
 *
 * @parm U8 | u8QPMin | Specifies the minimum GQUANT value for the GOB. It
 *   is typically 1 when compressing at high quality, or 15 at low quality.
 *
 * @parm BOOL | bBitRateControl | If set to TRUE, the new value for GQUANT
 *   is computed to achieve a target bitrate.
 *
 * @parm BOOL | bGOBoverflowWarning | If set to TRUE, the previous GQUANT was
 *   tool low and could potentially generate a buffer overflow.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f CalcMBQUANT>
 ***************************************************************************/
UN FindNewQuant(
	T_H263EncoderCatalog *EC, 
	UN gquant_prev,
	UN uCumFrmSize,
	UN GOB,
	U8 u8QPMax,
	U8 u8QPMin,
	BOOL bBitRateControl,
	BOOL bGOBoverflowWarning
	)
{
	FX_ENTRY("FindNewQuant");

	I32 gquant_delta;
	I32 gquant;

	if (bBitRateControl == ON)
	{
		// Check out if some GOBs have been arbitrary forced to be Intra coded. This always
		// returns TRUE for an I-frame, and FALSE for all other frame types since this can only
		// return TRUE for predicted frames when the error resiliency mode is ON, and we never
		// use this mode.
		if (IsIntraCoded(EC,GOB) && GOB)
			gquant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[GOB], EC->uBitUsageProfile[EC->NumMBRows], uCumFrmSize,INTRAPIC);
		else
			gquant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[GOB], EC->uBitUsageProfile[EC->NumMBRows], uCumFrmSize, EC->PictureHeader.PicCodType);

		EC->uBitUsageProfile[GOB] = uCumFrmSize;

		// Make sure we don't exceed the maximum quantizer value
		if (gquant > u8QPMax)
			gquant = u8QPMax;

		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller enabled for GOB #%ld (uCumFrmSize = %ld bits and gquant_prev = %ld), setting gquant = %ld (min and max were %ld and %ld)\r\n", _fx_, GOB, uCumFrmSize << 3, gquant_prev, gquant, u8QPMin, u8QPMax));
    }
    else
    {
		// No bitrate control. Use the picture quantizer value for this GOB
        gquant = EC->PictureHeader.PQUANT;

		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller disabled for GOB #%ld (uCumFrmSize = %ld bits and gquant_prev = %ld), setting gquant = %ld (min and max were %ld and %ld)\r\n", _fx_, GOB, uCumFrmSize << 3, gquant_prev, gquant, u8QPMin, u8QPMax));
    }
    
	// Make sure we're not below the minimum quantizer value
    if (gquant < u8QPMin)
		gquant = u8QPMin;

    // Limit the amount that GQUANT can change from frame to frame
    gquant_delta = gquant - gquant_prev;

	// Increase the QP value if there is danger of buffer overflow
	if (!bGOBoverflowWarning)
	{
		// There's no overflow warning, but we don't want the quantizer value to
		// fluctuate too much from GOB to GOB
		if (gquant_delta > 4L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Limiting amount of increase for GOB #%ld to 4, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev + 4L)));

			gquant = gquant_prev + 4L;
		}
		else if (gquant_delta < -2L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Limiting amount of decrease for GOB #%ld to -2, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev - 2L)));

			gquant = gquant_prev - 2L;
		}
	} 
	else 
	{
		// There's a risk of overflow - arbitrarily raise the value of the quantizer if necessary
		if (gquant_delta < 4L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Danger of overflow for GOB #%ld, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev + 4L)));

			gquant = gquant_prev + 4L;
		}
	}

	return clampQP(gquant);
}


/*******************************************************************************

H263TermEncoderInstance -- This function frees the space allocated for an
                          instance of the H263 encoder.

*******************************************************************************/
LRESULT H263TermEncoderInstance(LPCODINST lpInst)
{
	LRESULT ret;
	U8 BIGG * P32Inst;
	T_H263EncoderCatalog FAR * EC;

	FX_ENTRY("H263TermEncoderInstance")

	#if DUMPFILE
	_lclose (dmpfil);
	#endif

	#if ELAPSED_ENCODER_TIME
	if (TimedIterations == 0) TimedIterations = 10000000;
	TotalElapsed /= TimedIterations;
	TotalSample  /= TimedIterations;
	#if 01
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: "%ld,%ld us\r\n", _fx_, TotalElapsed, TotalSample));
	#else
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average elapsed time to encode frame: %ld us\r\n", _fx_, TotalElapsed));
	#if SAMPLE_RGBCONV_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to convert RGB24 to YUV9: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_MOTION_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to do motion estimation: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode block layer: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCMBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode macroblock layer: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCVLC_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode VLC: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_COMPAND_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to decode companded image: %ld us\r\n", _fx_, TotalSample));
	#endif
	#endif
	#endif

	// Check instance pointer
	if (!lpInst)
		return ICERR_ERROR;

	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: Uninitialized instance\r\n", _fx_));
		ret = ICERR_OK;
		goto done;
	}
	lpInst->Initialized = FALSE;

	//  lpInst->EncoderInst = (LPVOID)GlobalLock(lpInst->hEncoderInst);
	lpInst->EncoderInst = lpInst->hEncoderInst;

	P32Inst = (U8 *)
		    ((((U32) lpInst->EncoderInst) + 
		              (sizeof(T_MBlockActionStream) - 1)) &
		             ~(sizeof(T_MBlockActionStream) - 1));
	EC = ((T_H263EncoderCatalog  *) P32Inst);

	// Check encoder catalog pointer
	if (!EC)
		return ICERR_ERROR;

	if (lpInst->Configuration.bRTPHeader)
		H263RTP_TermBsInfoStream(EC);

	#ifdef ENCODE_STATS
	OutputQuantStats("encstats.txt");
	OutputPSNRStats("encstats.txt");
	OutputFrameSizeStats("encstats.txt");
	#endif /* ENCODE_STATS */

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (EC->pEncTimingInfo)
		OutputEncodeTimingStatistics("c:\\encode.txt", EC->pEncTimingInfo);
#endif // } LOG_ENCODE_TIMINGS_ON

	ret = H263TermColorConvertor(EC->pDecInstanceInfo);
	if (ret != ICERR_OK) goto done;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263TermDecoderInstance(EC->pDecInstanceInfo, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263TermDecoderInstance(EC->pDecInstanceInfo);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (ret != ICERR_OK) goto done;

	// Free virtual memory
	VirtualFree(EC->pI8_MBRVS_BLuma,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pI8_MBRVS_BLuma);
#endif
	VirtualFree(EC->pI8_MBRVS_BChroma,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pI8_MBRVS_BChroma);
#endif
	// No matter how many sparse pages we committed during encoding,
	// the whole memory block is released with these calls.
	// Documentation on VirtualFree() says the individual pages must
	// first be decommitted, but this is not correct, according
	// to Jeffrey R. Richter

	//  GlobalUnlock(lpInst->hEncoderInst);
	//  GlobalFree(lpInst->hEncoderInst);

	VirtualFree(lpInst->hEncoderInst,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst->hEncoderInst);
#endif

	ret = ICERR_OK;

	done:

	return ret;
}

/************************************************************************
 *
 *  GetEncoderOptions
 *
 *  Get the options, saving them in the catalog
 *************************************************************************/
static void GetEncoderOptions(T_H263EncoderCatalog * EC)
{
	/* Default Options
	 */
#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force PB-Frames for testing
	EC->u8EncodePBFrame = OFF;
	// Force UMV for testing
	EC->PictureHeader.UMV = ON;
	// Force SAC for testing
	EC->PictureHeader.SAC = ON;
	// Force AP for testing
	EC->PictureHeader.AP = ON;
#else // }{ FORCE_ADVANCED_OPTIONS_ON
	EC->u8EncodePBFrame = FALSE;
	EC->PictureHeader.UMV = OFF;
	EC->PictureHeader.SAC = OFF;
	EC->PictureHeader.AP = OFF;
#endif // } FORCE_ADVANCED_OPTIONS_ON
#ifdef USE_MMX // { USE_MMX
	MMX_Enabled = MMxVersion;
#endif // } USE_MMX
#ifdef H263P
	EC->bH263Plus = FALSE;
	EC->PictureHeader.DeblockingFilter = OFF;
	EC->PictureHeader.ImprovedPB = OFF;
#endif
	EC->bUseINISettings = 0;	// Clear option override.
	return;

} /* end GetEncoderOptions() */

/*************************************************************
 *  Name:         encodeFrameHeader
 *  Description:  Write out the PB-frame header to the bit stream.
 ************************************************************/
static void encodeFrameHeader(
    T_H263EncoderCatalog *  EC,
    U8                   ** ppCurBitStream,
    U8                   *  pBitOffset,
    BOOL                    PBframe
)
{
	U8 temp=0;
#ifdef H263P
	BOOL bUseH263PlusOptions = FALSE;
#endif

    //  Picture start code
    PutBits(FIELDVAL_PSC, FIELDLEN_PSC, ppCurBitStream, pBitOffset);
    //  TR : Temporal reference
    PutBits(EC->PictureHeader.TR, FIELDLEN_TR,  ppCurBitStream, pBitOffset);
    //  PTYPE : bits 1-2
    PutBits(0x2, FIELDLEN_PTYPE_CONST, ppCurBitStream, pBitOffset);
    //  PTYPE : bit 3 split screen indicator
    PutBits(EC->PictureHeader.Split, FIELDLEN_PTYPE_SPLIT,  ppCurBitStream,
            pBitOffset);
    //  PTYPE : bit 4 document camera indicator
    PutBits(EC->PictureHeader.DocCamera, FIELDLEN_PTYPE_DOC, ppCurBitStream,
            pBitOffset);
    //  PTYPE : bit 5 freeze picture release
    PutBits(EC->PictureHeader.PicFreeze, FIELDLEN_PTYPE_RELEASE,
            ppCurBitStream, pBitOffset);

#ifdef H263P
	if ((EC->FrameSz == CUSTOM) ||
		(EC->PictureHeader.DeblockingFilter == ON) ||
		(EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
		// other supported H.263+ options
		)
	{
		// PTYPE : bits 6-8 extended PTYPE flag
		enum FrameSize tmpFrameSz = EPTYPE;

		bUseH263PlusOptions = TRUE; 		// at least one H.263+ optional mode requested
		PutBits(tmpFrameSz, FIELDLEN_PTYPE_SRCFORMAT, ppCurBitStream, pBitOffset);
	}
	else
	{
		//	PTYPE : bits 6-8 source format
		PutBits(EC->FrameSz, FIELDLEN_PTYPE_SRCFORMAT,	ppCurBitStream, pBitOffset);
	}
#else
	//  PTYPE : bits 6-8 source format
	PutBits(EC->FrameSz, FIELDLEN_PTYPE_SRCFORMAT,  ppCurBitStream, pBitOffset);
#endif

    //  PTYPE : bit 9 picture coding type
    PutBits(EC->PictureHeader.PicCodType, FIELDLEN_PTYPE_CODINGTYPE,
             ppCurBitStream, pBitOffset);
    //  PTYPE : bit 10 UMV
    PutBits(EC->PictureHeader.UMV, FIELDLEN_PTYPE_UMV,
             ppCurBitStream, pBitOffset);
    //  PTYPE : bit 11 SAC
    PutBits(EC->PictureHeader.SAC, FIELDLEN_PTYPE_SAC,
            ppCurBitStream, pBitOffset);
    //  PTYPE : bit 12 advanced prediction mode
    PutBits(EC->PictureHeader.AP, FIELDLEN_PTYPE_AP,
            ppCurBitStream, pBitOffset);
    //  PTYPE : bit 13 PB-frames mode
    PutBits(EC->PictureHeader.PB, FIELDLEN_PTYPE_PB,
            ppCurBitStream, pBitOffset);

#ifdef H263P

	// EPTYPE : 18 bits
	if (bUseH263PlusOptions) {
		//	EPTYPE : bits 1-3 source format
		PutBits(EC->FrameSz, FIELDLEN_EPTYPE_SRCFORMAT,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 4 custom PCF
		PutBits(EC->PictureHeader.CustomPCF, FIELDLEN_EPTYPE_CPCF,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 5 advanced intra coding mode
		PutBits(EC->PictureHeader.AdvancedIntra, FIELDLEN_EPTYPE_AI,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 6 deblocking filter mode
		PutBits(EC->PictureHeader.DeblockingFilter, FIELDLEN_EPTYPE_DF,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 7 slice structured mode
		PutBits(EC->PictureHeader.SliceStructured, FIELDLEN_EPTYPE_SS,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 8 improved PB-frame mode
		PutBits((EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB),
				FIELDLEN_EPTYPE_IPB,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 9 back-channel operation mode
		PutBits(EC->PictureHeader.BackChannel, FIELDLEN_EPTYPE_BCO,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 10 SNR and spatial scalability mode
		PutBits(EC->PictureHeader.Scalability, FIELDLEN_EPTYPE_SCALE,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 11 true B-frame mode
		PutBits(EC->PictureHeader.TrueBFrame, FIELDLEN_EPTYPE_TB,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 12 reference-picture resampling mode
		PutBits(EC->PictureHeader.RefPicResampling, FIELDLEN_EPTYPE_RPR,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 13 reduced-resolution update mode
		PutBits(EC->PictureHeader.RedResUpdate, FIELDLEN_EPTYPE_RRU,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 14-18 reserved
		PutBits(0x1, FIELDLEN_EPTYPE_CONST, ppCurBitStream, pBitOffset);
	}

	if (EC->FrameSz == CUSTOM) {
		// CSFMT : bit 1-4 pixel aspect ratio code
		// TODO. For now, force to CIF
		PutBits(0x2, FIELDLEN_CSFMT_PARC,
				ppCurBitStream, pBitOffset);
		// CSFMT : bits 5-13 frame width indication
		PutBits((EC->uActualFrameWidth >> 2) - 1, FIELDLEN_CSFMT_FWI,
				ppCurBitStream, pBitOffset);
		// CSFMT : bit 14 "1" to avoid start code emulation
		PutBits(0x1, FIELDLEN_CSFMT_CONST, ppCurBitStream, pBitOffset);
		// CSFMT : bits 15-23 frame height indication
		PutBits((EC->uActualFrameHeight >> 2) - 1, FIELDLEN_CSFMT_FHI,
				ppCurBitStream, pBitOffset);
	}
#endif

    //  PQUANT
    PutBits(EC->PictureHeader.PQUANT, FIELDLEN_PQUANT,
            ppCurBitStream, pBitOffset);
    //  CPM
    PutBits(EC->PictureHeader.CPM, FIELDLEN_CPM,
            ppCurBitStream, pBitOffset);
    if (PBframe == TRUE)
    {
        
        //  AG:TODO
        //  TRB
        PutBits(EC->PictureHeader.TRB, FIELDLEN_TRB,
                ppCurBitStream, pBitOffset);
        //  AG:TODO
        //  DBQUANT
        PutBits(EC->PictureHeader.DBQUANT, FIELDLEN_DBQUANT,
                ppCurBitStream, pBitOffset);

		#ifdef COUNT_BITS
		EC->Bits.PictureHeader += FIELDLEN_TRB + FIELDLEN_DBQUANT;
		#endif
    }
    
    //  PEI
    PutBits(EC->PictureHeader.PEI, FIELDLEN_PEI,
            ppCurBitStream, pBitOffset);

	#ifdef COUNT_BITS
	EC->Bits.PictureHeader    += FIELDLEN_PSC + FIELDLEN_TR
	+ FIELDLEN_PTYPE_CONST     + FIELDLEN_PTYPE_SPLIT
	+ FIELDLEN_PTYPE_DOC       + FIELDLEN_PTYPE_RELEASE
	+ FIELDLEN_PTYPE_SRCFORMAT + FIELDLEN_PTYPE_CODINGTYPE
	+ FIELDLEN_PTYPE_UMV       + FIELDLEN_PTYPE_SAC
	+ FIELDLEN_PTYPE_AP        + FIELDLEN_PTYPE_PB
	+ FIELDLEN_PQUANT          + FIELDLEN_CPM
	+ FIELDLEN_PEI;
	#endif
}


/*************************************************************
 *  Name:         InitMEState
 *  Description:  Initialize the MB action stream for the ME 
 *                state engine. 
 ************************************************************/
 void InitMEState(T_H263EncoderCatalog *EC, ICCOMPRESS *lpicComp, T_CONFIGURATION *pConfiguration)
 {
 	register unsigned int i;
	U8 u8FirstMEState;

	FX_ENTRY("InitMEState")

	// TODO: The FirstMEState initialization can be avoided
	// for each compress by either adding a parameter to the
	// motion estimator signalling key frame, or by not calling
	// motion estimation on intra frames, and resetting MBType,
	// CodedBlocks ourselves.
    if (EC->PictureHeader.PicCodType == INTRAPIC)
    {
        for(i=0; i < EC->NumMBs; i++)
        {
            // Clear the intercode count.
            (EC->pU8_MBlockActionStream[i]).InterCodeCnt = (i & 0xf);
            // For the motion estimator, this field must be set to force
            // intra blocks for intra frames.
            (EC->pU8_MBlockActionStream[i]).FirstMEState = ForceIntra;
        }

        *(lpicComp->lpdwFlags) |=  AVIIF_KEYFRAME;
        lpicComp->dwFlags |= ICCOMPRESS_KEYFRAME;

		// Store that this frame was intra coded. Used during the initialization
		// of the ME state for the next frame.
		EC->bPrevFrameIntra = TRUE;

    }
    else  //  Picture Coding type is INTERPIC
    {
		/*
		 * The FirstMEState element in each MB structure must be set
		 * to indicate its position in the frame. This is used by the
		 * motion estimator.
		 */

	   /*
		* Check for AP or UMV modes. When these mode is signalled, motion vectors are
		* allowed to point outside the picture.
		*/

	    /* We also need to perform the initialization if the previous frame
		   was an intra frame! (JM) 
		 */
		if (EC->bPrevFrameIntra ||
			EC->PictureHeader.AP != EC->prevAP ||
			EC->PictureHeader.UMV != EC->prevUMV
#ifdef H263P
			|| EC->PictureHeader.DeblockingFilter != EC->prevDF
#endif
			) {

			if( (EC->PictureHeader.UMV == ON) || (EC->PictureHeader.AP == ON)
#ifdef H263P
				|| (EC->PictureHeader.DeblockingFilter == ON)
#endif
			  )
			{
				// Set ME state central blocks.
				for(i=0; i < EC->NumMBs; i++)
					(EC->pU8_MBlockActionStream[i]).FirstMEState = CentralBlock;
			}
			else	// No AP or UMV option.
			{
        		// Set upper left corner
        		(EC->pU8_MBlockActionStream[0]).FirstMEState = UpperLeft;

        		// Set ME state for top edge.
        		for(i=1; i < EC->NumMBPerRow; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = UpperEdge;

        		// Set upper right corner.
        		(EC->pU8_MBlockActionStream[ EC->NumMBPerRow - 1 ]).FirstMEState = UpperRight;

        		// Set ME state for central blocks.
        		for(i=EC->NumMBPerRow; i < EC->NumMBs; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = CentralBlock;

        		// Set ME state for bottom edge.
        		for(i= (EC->NumMBs - EC->NumMBPerRow); i < EC->NumMBs; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = LowerEdge;

        		// Set ME state for left edge
        		for(i= EC->NumMBPerRow ; i < EC->NumMBs; i += EC->NumMBPerRow)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = LeftEdge;

        		// Set ME state for right edge.
        		for(i= 2 * EC->NumMBPerRow - 1 ; i < EC->NumMBs; i += EC->NumMBPerRow)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = RightEdge;

        		// Bottom left corner.
        		(EC->pU8_MBlockActionStream[EC->NumMBs - EC->NumMBPerRow]).FirstMEState = LowerLeft;

        		// Bottom right corner.
        		(EC->pU8_MBlockActionStream[EC->NumMBs - 1]).FirstMEState = LowerRight;

			} // end of else (not UMV)

		} // end of if (bPrevFrameIntra || prevAP != AP || prevUMV != UMV || prevDF != DF)

      	// Clear key frame flag.
       	*(lpicComp->lpdwFlags) &= ~AVIIF_KEYFRAME;
		lpicComp->dwFlags &= ~ICCOMPRESS_KEYFRAME;

		// Store that this frame was not intra coded. Used during the initialization
		// of the ME state for the next frame.
		EC->bPrevFrameIntra = FALSE;

    }

	// RTP stuff which needs to be done for every frame (?)
	if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{	//Chad	intra GOB
		
		// Of course unPacketLoss is non-zero. Why are we checking it here
		if (pConfiguration->unPacketLoss > 0)
		{	//Chad INTRA GOB
			EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPacketLoss) + 50) / 100;
			EC->uNumberForcedIntraMBs = (EC->uNumberForcedIntraMBs+EC->NumMBPerRow-1) / EC->NumMBPerRow * EC->NumMBPerRow;
		}

		if (EC->uNumberForcedIntraMBs > 0)
		{
			/* Force all the MBs in a GOB to intra.
			 */
			for ( i = 0 ; i < EC->uNumberForcedIntraMBs ; i++, EC->uNextIntraMB++)
			{ // Reset it to the first row when we reach the end.

				if (EC->uNextIntraMB >= EC->NumMBs)
				{
					EC->uNextIntraMB = 0;
				}
				 (EC->pU8_MBlockActionStream[EC->uNextIntraMB]).FirstMEState = ForceIntra;

			}

		}

		if (pConfiguration->bDisallowAllVerMVs)
	 	{
	 		/* Walk thru all the FirstMEStateME settings turning off Vertical.
	 		 */
	      	for(i=0; i < EC->NumMBs; i++)
	 		{
	 			u8FirstMEState = (EC->pU8_MBlockActionStream[i]).FirstMEState;
	 			switch (u8FirstMEState)
	 			{
	 				case ForceIntra:
	 					break;
	 				case UpperLeft:
	 				case LeftEdge:
	 				case LowerLeft:
	 					u8FirstMEState = NoVertLeftEdge;
	 				    break;
	 				case UpperEdge:
	 				case CentralBlock:
	 				case LowerEdge:
	 				    u8FirstMEState = NoVertCentralBlock;
	 				    break;
	 				case UpperRight:
	 				case RightEdge:
	 				case LowerRight:
	 				    u8FirstMEState = NoVertRightEdge;
	 				    break;
	 				case NoVertLeftEdge:
	 				case NoVertCentralBlock:
	 				case NoVertRightEdge:
	 					ASSERT(0);  /* It should work, but why was this already on */
	 					break;
	 				default:
						DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: Unexpected FirstMEState\r\n", _fx_));
	 					break;
	 			}
	 			(EC->pU8_MBlockActionStream[i]).FirstMEState = u8FirstMEState;
	 		}
	 	} 
	 	else if (pConfiguration->bDisallowPosVerMVs)
	 	{	/* Walk thru all the FirstMEState settings turning off Positive Vertical
	 	     */
	      	for(i=0; i < EC->NumMBs; i++)
	 		{
	 			u8FirstMEState = (EC->pU8_MBlockActionStream[i]).FirstMEState;
	 			switch (u8FirstMEState)
	 			{
	 				case ForceIntra:
	 				case LowerLeft:
	 				case LowerEdge:
	 				case LowerRight:
	 					break;
	 				case UpperLeft:
	 					u8FirstMEState = NoVertLeftEdge;
	 					break;
	 				case LeftEdge:
	 					u8FirstMEState = LowerLeft;
	 				    break;
	 				case UpperEdge:
	 				    u8FirstMEState = NoVertCentralBlock;
	 				    break;
	 				case CentralBlock:
	 				    u8FirstMEState = LowerEdge;
	 				    break;
	 				case UpperRight:
	 				    u8FirstMEState = NoVertRightEdge;
	 				    break;
	 				case RightEdge:
	 				    u8FirstMEState = LowerRight;
	 				    break;
	 				case NoVertLeftEdge:
	 				case NoVertCentralBlock:
	 				case NoVertRightEdge:
	 					ASSERT(0);  /* It should work, but why was this already on */
	 					break;
	 				default:
						DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: Unexpected FirstMEState\r\n", _fx_));
	 					break;
	 			}
	 			(EC->pU8_MBlockActionStream[i]).FirstMEState = u8FirstMEState;
	 		} /* for */
	 	} /* else if... */
	 } /* if (pConfiguration->bEncoderResiliency) */

} // end of InitMEState()


#ifdef USE_MMX // { USE_MMX
/*************************************************************
 *  Name: Check_InterCodeCnt_MMX
 *  Description:  Track inter code count for macro blocks
 *				  for forced update. Called before Motion 
 *                Estimation.
 ************************************************************/
static void Check_InterCodeCnt_MMX(T_H263EncoderCatalog *EC, U32 StartingMB)
{
	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
    
	for(; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++) 
	{
		// Check to see if it's time to refresh this block.
		if(pCurrMB->InterCodeCnt > 132) 
		{
			pCurrMB->CodedBlocks |= 0x80;
			// InterCodeCnt is reset in GOB_VLC_WriteBS() in e3mbenc.cpp */
		}

	}
}
#endif // } USE_MMX


/*************************************************************
 *  Name: Check_InterCodeCnt
 *  Description:  Track inter code count for macro blocks
 *				  for forced update. Called after Motion 
 *                Estimation.
 ************************************************************/
static void Check_InterCodeCnt(T_H263EncoderCatalog *EC, U32 StartingMB)
{
	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
    
	for(; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++) 
	{
		// Check to see if it's time to refresh this block.
		if(pCurrMB->InterCodeCnt > 132) 
		{

			if (pCurrMB->BlockType == INTER4MV)
			{
				pCurrMB->BlkY1.PHMV = pCurrMB->BlkY2.PHMV = pCurrMB->BlkY3.PHMV = pCurrMB->BlkY4.PHMV = 
					(pCurrMB->BlkY1.PHMV+pCurrMB->BlkY2.PHMV+pCurrMB->BlkY3.PHMV+pCurrMB->BlkY4.PHMV+2) >> 2;
				pCurrMB->BlkY1.PVMV = pCurrMB->BlkY2.PVMV = pCurrMB->BlkY3.PVMV = pCurrMB->BlkY4.PVMV = 
					(pCurrMB->BlkY1.PVMV+pCurrMB->BlkY2.PVMV+pCurrMB->BlkY3.PVMV+pCurrMB->BlkY4.PVMV+2) >> 2;
			}
			pCurrMB->BlockType = INTRABLOCK;
			pCurrMB->CodedBlocks |= 0x3f;
			// InterCodeCnt is reset in GOB_Q_VLC_WriteBS() in e3mbenc.cpp */
		}

	}
}

/*************************************************************
 *  Name: calcGOBChromaVectors
 *  Description:  Compute chroma motion vectors 
 ************************************************************/
static void calcGOBChromaVectors(
     T_H263EncoderCatalog *EC,
     U32             StartingMB,
     T_CONFIGURATION *pConfiguration
)
{

	register T_MBlockActionStream *pCurrMB;
    T_MBlockActionStream *pLastMBPlus1;
    char	       HMV, VMV;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
            
    for( ; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++)
    {

		// The ME should generate MV indices in the range
		// of [-32,31].
 //     ASSERT( (pCurrMB->BlkY1.PHMV >= -32) &&
 //                     (pCurrMB->BlkY1.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY1.PVMV >= -32) &&
 //                     (pCurrMB->BlkY1.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY2.PHMV >= -32) &&
 //                     (pCurrMB->BlkY2.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY2.PVMV >= -32) &&
 //                     (pCurrMB->BlkY2.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY3.PHMV >= -32) &&
 //                     (pCurrMB->BlkY3.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY3.PVMV >= -32) &&
 //                     (pCurrMB->BlkY3.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY4.PHMV >= -32) &&
 //                     (pCurrMB->BlkY4.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY4.PVMV >= -32) &&
 //                     (pCurrMB->BlkY4.PVMV <= 31) )

#ifdef _DEBUG
		if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
		{
			if (pConfiguration->bDisallowAllVerMVs)
			{
				ASSERT(pCurrMB->BlkY1.PVMV == 0);
				ASSERT(pCurrMB->BlkY2.PVMV == 0);
				ASSERT(pCurrMB->BlkY3.PVMV == 0);
				ASSERT(pCurrMB->BlkY4.PVMV == 0);
			}
			else if (pConfiguration->bDisallowPosVerMVs)
			{
				ASSERT(pCurrMB->BlkY1.PVMV <= 0);
				ASSERT(pCurrMB->BlkY2.PVMV <= 0);
				ASSERT(pCurrMB->BlkY3.PVMV <= 0);
				ASSERT(pCurrMB->BlkY4.PVMV <= 0);
			}
		}
#endif /* _DEBUG */

		// TODO: Don't calculate chroma vectors if this is not a P-frame
		// inside a PB frame and it's an INTRA MB or inter code count
		// exceeded 132.
		if(pCurrMB->BlockType != INTER4MV)
		{
        	HMV = QtrPelToHalfPel[pCurrMB->BlkY1.PHMV+64];
            VMV = QtrPelToHalfPel[pCurrMB->BlkY1.PVMV+64];
		}
		else	// 4 MV's per block.
		{
			HMV = SixteenthPelToHalfPel[
						pCurrMB->BlkY1.PHMV + pCurrMB->BlkY2.PHMV +
						pCurrMB->BlkY3.PHMV + pCurrMB->BlkY4.PHMV + 256 ];
			VMV = SixteenthPelToHalfPel[
						pCurrMB->BlkY1.PVMV + pCurrMB->BlkY2.PVMV +
						pCurrMB->BlkY3.PVMV + pCurrMB->BlkY4.PVMV + 256 ];
		}

        pCurrMB->BlkU.PHMV = HMV;
        pCurrMB->BlkU.PVMV = VMV;
        pCurrMB->BlkV.PHMV = HMV;
        pCurrMB->BlkV.PVMV = VMV;
                
        pCurrMB->BlkU.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + pCurrMB->BlkU.BlkOffset 
                    					+ (VMV>>1)*PITCH + (HMV>>1);
        pCurrMB->BlkV.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + pCurrMB->BlkV.BlkOffset 
                                        + (VMV>>1)*PITCH + (HMV>>1);


		// The increment of pCurrMB->InterCodeCnt is now done 
		// in void GOB_VLC_WriteBS and void GOB_Q_RLE_VLC_WriteBS
		// When it was incremented here, it was always incremented,
		// no matter whether coefficients were coded or not.

    }  //  end of for loop

} // end of 



/*************************************************************
 *  Name: calcBGOBChromaVectors
 *  Description:  Compute forward and backward chroma motion vectors for the 
 *                B-frame GOB starting at MB number "StartingMB".  Luma motion 
 *                vectors are biased by 0x60.  Chroma motion vectors are also 
 *                biased by 0x60.
 ************************************************************/
static void calcBGOBChromaVectors(
     T_H263EncoderCatalog *EC,
     const U32             StartingMB
)
{
    register T_MBlockActionStream *pCurrMB;
    register I8                    HMVf, HMVb, VMVf, VMVb;

    for(pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
        pCurrMB < &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]); 
        pCurrMB++)
    {
        //  Luma block motion vectors
        HMVf = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.HMVf-0x60+64]+0x60;
        HMVb = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.HMVb-0x60+64]+0x60;
        VMVf = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.VMVf-0x60+64]+0x60;
        VMVb = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.VMVb-0x60+64]+0x60;
        
        pCurrMB->BlkU.BestMV.HMVf = HMVf;
        pCurrMB->BlkU.BestMV.HMVb = HMVb;
        pCurrMB->BlkU.BestMV.VMVf = VMVf;
        pCurrMB->BlkU.BestMV.VMVb = VMVb;
        pCurrMB->BlkV.BestMV.HMVf = HMVf;
        pCurrMB->BlkV.BestMV.HMVb = HMVb;
        pCurrMB->BlkV.BestMV.VMVf = VMVf;
        pCurrMB->BlkV.BestMV.VMVb = VMVb;
   }
}

/*************************************************************
 *  Name: InitBits
 ************************************************************/
#ifdef COUNT_BITS
static void InitBits(T_H263EncoderCatalog * EC)
{

	EC->Bits.PictureHeader = 0;
	EC->Bits.GOBHeader = 0;
	EC->Bits.MBHeader = 0;
	EC->Bits.DQUANT = 0;
	EC->Bits.MV = 0;
	EC->Bits.Coefs = 0;
	EC->Bits.Coefs_Y = 0;
	EC->Bits.IntraDC_Y = 0;
	EC->Bits.Coefs_C = 0;
	EC->Bits.IntraDC_C = 0;
	EC->Bits.CBPY = 0;
	EC->Bits.MCBPC = 0;
	EC->Bits.Coded = 0;
	EC->Bits.num_intra = 0;
	EC->Bits.num_inter = 0;
	EC->Bits.num_inter4v = 0;

}
#endif

#ifdef COUNT_BITS

void InitCountBitFile()
{
  FILE *fp;

  fp = fopen("bits.txt", "w");

  ASSERT(fp != NULL);
  fclose(fp);
}

void WriteCountBitFile(T_BitCounts *Bits)
{
  FILE *fp;

  fp = fopen("bits.txt", "a");
  ASSERT(fp != NULL);

  fprintf(fp, "%8d %8d %8d %8d %8d %8d %8d\n",
  	Bits->PictureHeader,
  	Bits->GOBHeader,
  	Bits->MBHeader,
  	Bits->MV,
  	Bits->Coefs,
  	Bits->CBPY,
  	Bits->MCBPC
  	);

  fclose(fp);
}
#endif

#ifdef DEBUG_ENC

void trace(char *str)
{
  FILE *fp;

  fp = fopen("trace.txt", "a");

  fprintf(fp, "%s\n", str);

  fclose(fp);
}

#endif

#ifdef DEBUG_DCT
void cnvt_fdct_output(unsigned short *DCTcoeff, int DCTarray[64], int BlockType)
{
    register int i;
    static int coefforder[64] = {
     // 0  1  2  3  4  5  6  7
        6,38, 4,36,70,100,68,102, // 0
       10,46, 8,44,74,104,72,106, // 1
       18,50,16,48,82,112,80,114, // 2
       14,42,12,40,78,108,76,110, // 3
       22,54,20,52,86,116,84,118, // 4
        2,34, 0,32,66, 96,64, 98, // 5
       26,58,24,56,90,120,88,122, // 6
       30,62,28,60,94,124,92,126  // 7
    };
	static int zigzag[64] = {
	0, 1, 5, 6, 14, 15, 27, 28,
	2, 4, 7, 13, 16, 26, 29, 42,
	3, 8, 12, 17, 25, 30, 41, 43,
	9, 11, 18, 24, 31, 40, 44, 53,
	10, 19, 23, 32, 39, 45, 52, 54,
	20, 22, 33, 38, 46, 51, 55, 60,
	21, 34, 37, 47, 50, 56, 59, 61,
	35, 36, 48, 49, 57, 58, 62, 63
	};

	unsigned int index;

    for (i = 0; i < 64; i++) {

      index = (coefforder[i])>>1;

  	  if( (i ==0) && ((BlockType & 1) == 1)   )
        DCTarray[zigzag[i]] = ((int)(DCTcoeff[index])) >> 4 ;
	  else
        DCTarray[zigzag[i]] = ((int)(DCTcoeff[index] - 0x8000)) >> 4;
    }

}
#endif

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	FX_ENTRY("OutputEncodeTimingStatistics")

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
		ERRORMESSAGE(("%s: Error opening encode stat file\r\n", _fx_));
	    goto done;
	}

	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < ENC_TIMING_INFO_FRAME_COUNT ; i++, pTempEncTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputEncTimingDetail(pFile, pTempEncTimingInfo);
	}

	/* Compute the total information
	*/
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < ENC_TIMING_INFO_FRAME_COUNT ; i++, pTempEncTimingInfo++ )
	{
		iCount++;
		etiTemp.uEncodeFrame      += pTempEncTimingInfo->uEncodeFrame;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.uInputCC	      += pTempEncTimingInfo->uInputCC;
		etiTemp.uMotionEstimation += pTempEncTimingInfo->uMotionEstimation;
		etiTemp.uFDCT             += pTempEncTimingInfo->uFDCT;
		etiTemp.uQRLE             += pTempEncTimingInfo->uQRLE;
		etiTemp.uDecodeFrame      += pTempEncTimingInfo->uDecodeFrame;
		etiTemp.uZeroingBuffer    += pTempEncTimingInfo->uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);

		/* Compute the average
		*/
		etiTemp.uEncodeFrame = (etiTemp.uEncodeFrame + (iCount / 2)) / iCount;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.uInputCC	      = (etiTemp.uInputCC + (iCount / 2)) / iCount;
		etiTemp.uMotionEstimation = (etiTemp.uMotionEstimation + (iCount / 2)) / iCount;
		etiTemp.uFDCT             = (etiTemp.uFDCT + (iCount / 2)) / iCount;
		etiTemp.uQRLE             = (etiTemp.uQRLE + (iCount / 2)) / iCount;
		etiTemp.uDecodeFrame      = (etiTemp.uDecodeFrame + (iCount / 2)) / iCount;
		etiTemp.uZeroingBuffer    = (etiTemp.uZeroingBuffer + (iCount / 2)) / iCount;
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tEncode Frame =     %10d (%d milliseconds at 90Mhz)\n", pEncTimingInfo->uEncodeFrame,
			(pEncTimingInfo->uEncodeFrame + 45000) / 90000);
	uOther = pEncTimingInfo->uEncodeFrame;
	
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pEncTimingInfo->uEncodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
	fprintf(pFile, "\tInputCC =          %10d (%2d%%)\n", pEncTimingInfo->uInputCC, 
			(pEncTimingInfo->uInputCC + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uInputCC;
								   
	fprintf(pFile, "\tMotionEstimation = %10d (%2d%%)\n", pEncTimingInfo->uMotionEstimation, 
			(pEncTimingInfo->uMotionEstimation + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uMotionEstimation;
								   
	fprintf(pFile, "\tFDCT =             %10d (%2d%%)\n", pEncTimingInfo->uFDCT, 
			(pEncTimingInfo->uFDCT + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uFDCT;

	fprintf(pFile, "\tQRLE =             %10d (%2d%%)\n", pEncTimingInfo->uQRLE, 
			(pEncTimingInfo->uQRLE + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uQRLE;
								   
	fprintf(pFile, "\tDecodeFrame =      %10d (%2d%%)\n", pEncTimingInfo->uDecodeFrame, 
			(pEncTimingInfo->uDecodeFrame + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uDecodeFrame;
								   
	fprintf(pFile, "\tZeroingBuffer =    %10d (%2d%%)\n", pEncTimingInfo->uZeroingBuffer, 
			(pEncTimingInfo->uZeroingBuffer + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uZeroingBuffer;
								   
	fprintf(pFile, "\tOther =            %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);
#endif // } DETAILED_ENCODE_TIMINGS_ON

}
#endif // { LOG_ENCODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3enc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   19 Mar 1997 14:58:04  $
// $Archive:   S:\h26x\src\enc\e3enc.h_v  $
// $Header:   S:\h26x\src\enc\e3enc.h_v   1.87   19 Mar 1997 14:58:04   MDUDA  $
// $Log:   S:\h26x\src\enc\e3enc.h_v  $
;// 
;//    Rev 1.87   19 Mar 1997 14:58:04   MDUDA
;// Increased motion estimation stack space from 16k to 64k bytes.
;// 
;//    Rev 1.86   17 Mar 1997 20:19:50   MDUDA
;// Moved local storage to encoder catalog and allocated pseudo stack
;// space needed to work around problem with 16-bit apps that allocated
;// insufficient stack space.
;// 
;//    Rev 1.85   10 Feb 1997 11:43:28   JMCVEIGH
;// 
;// Support for new interpretation of blocking filter -
;// allow for motion vectors outside of the reference picture.
;// 
;//    Rev 1.84   07 Feb 1997 10:58:14   CZHU
;// Added three entry in EC to remove static variable used in e3rtp.cpp
;// 
;//    Rev 1.83   05 Feb 1997 12:19:18   JMCVEIGH
;// Pass GOBHeaderPresent parameter to MMxEDTQ() for EMV bug fix
;// support latest H.263+ draft bitstream spec, and support for 
;// separate improved PB-frame flag.
;// 
;//    Rev 1.82   30 Dec 1996 19:55:48   MDUDA
;// Added color convertor initializer prototype.
;// 
;//    Rev 1.81   19 Dec 1996 16:33:38   MDUDA
;// Modified call to colorCnvtFrame to support H263 backward compatibility.
;// 
;//    Rev 1.80   16 Dec 1996 17:49:48   JMCVEIGH
;// H263Plus flag.
;// 
;//    Rev 1.79   16 Dec 1996 13:35:30   MDUDA
;// 
;// Added ColorConvertor field to Encoder Catalog.
;// 
;//    Rev 1.78   11 Dec 1996 15:03:58   JMCVEIGH
;// 
;// Changed size of padding of encoder catalog to handle H.263+
;// options.
;// 
;//    Rev 1.77   10 Dec 1996 09:07:48   JMCVEIGH
;// Fixed bug in padding of T_H263EncoderCatalog to 512 bytes when
;// H263P not defined.
;// 
;//    Rev 1.76   09 Dec 1996 17:59:28   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
;// Normally, application will pass identical (arbitrary) frame
;// sizes in lParam1 and lParam2 of CompressBegin(). If 
;// cropping/stretching desired to convert to standard frame sizes,
;// application should pass the desired output size in lParam2 and
;// the input size in lParam1.
;// 
;//    Rev 1.75   09 Dec 1996 09:49:44   MDUDA
;// Modified for H263P.
;// 
;//    Rev 1.74   11 Nov 1996 09:12:28   JMCVEIGH
;// Added bPrevIntra. This is used to re-initialize the ME states
;// when the previous frame was intra coded and the current frame
;// is to be inter coded.
;// 
;//    Rev 1.73   06 Nov 1996 16:32:12   gmlim
;// Removed H263ModeC preprocessor definitions.
;// 
;//    Rev 1.72   05 Nov 1996 13:25:08   GMLIM
;// Added mode c support for mmx case.
;// 
;//    Rev 1.71   03 Nov 1996 19:01:26   gmlim
;// Parameters changed in PB_GOB_Q_RLE_VLC_WriteBS() for mode c.
;// 
;//    Rev 1.70   22 Oct 1996 14:51:52   KLILLEVO
;// Blocktype initialization in InitMEState() is  now only called if
;// the AP mode has changed from the previous picture.
;// 
;//    Rev 1.69   10 Oct 1996 16:43:02   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.68   04 Oct 1996 08:47:56   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.67   12 Sep 1996 10:56:12   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.66   06 Sep 1996 16:12:28   KLILLEVO
;// fixed the logical problem that the inter code count was always
;// incremented no matter whether coefficients were transmitted or not
;// 
;//    Rev 1.65   22 Aug 1996 11:31:24   KLILLEVO
;// changed PB switch to work the same for IA as for MMX
;// 
;//    Rev 1.64   19 Aug 1996 13:49:04   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.63   25 Jun 1996 14:24:50   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.62   30 May 1996 15:09:08   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.61   29 May 1996 15:38:02   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.60   14 May 1996 12:18:44   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.59   03 May 1996 14:59:32   KLILLEVO
;// added one parameter to MMXEDTQ() : pointer to B-frame stream of
;// run,lengt,sign triplets
;// 
;//    Rev 1.58   03 May 1996 10:55:00   KLILLEVO
;// 
;// started integrating Brian's MMX PB-frames
;// 
;//    Rev 1.57   02 May 1996 12:01:02   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.56   28 Apr 1996 19:56:52   BECHOLS
;// Enabled RTP header stuff in calls.
;// 
;//    Rev 1.55   26 Apr 1996 11:06:36   BECHOLS
;// Added rtp stuff... but still need to get rid of ifdef's
;// 
;//    Rev 1.54   26 Mar 1996 12:00:16   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.53   15 Mar 1996 15:57:32   BECHOLS
;// 
;// Added support for monolithic MMx code.
;// 
;//    Rev 1.52   12 Mar 1996 13:26:52   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.51   27 Feb 1996 14:12:56   KLILLEVO
;// 
;// PB switch
;// 
;//    Rev 1.50   22 Feb 1996 18:48:50   BECHOLS
;// 
;// Added declarations for MMX functions.
;// 
;//    Rev 1.49   24 Jan 1996 13:21:26   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.48   22 Jan 1996 17:13:22   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.47   22 Jan 1996 16:29:20   TRGARDOS
;// Started adding bit counting structures and code.
;// 
;//    Rev 1.46   03 Jan 1996 12:19:02   TRGARDOS
;// Added bUseINISettings member to EC structure.
;// 
;//    Rev 1.45   02 Jan 1996 17:07:54   TRGARDOS
;// Moved colorCnvtFrame into excolcnv.cpp and made 
;// color convertor functions static.
;// 
;//    Rev 1.44   27 Dec 1995 15:32:56   RMCKENZX
;// Added copyright notice
;//
;// Added uBitUsageProfile for BRC.
;// added a control to activate the chaned BRC
;// Hookup init from Registry instead of ini
;// Add a parameter to QRLE entry point - bRTPHeader flag
;// Add a variable to the encoder catalog to store the netx intra MB 
;// Added comments
;// integrate with build 29
//
////////////////////////////////////////////////////////////////////////////

#ifndef __H263E_H__
#define __H263E_H__

/*
 * This file declares structs which catalog the locations of various
 * tables, structures, and arrays needed by the H263 encoder.
*/

const U8 def263INTRA_QP = 16;  //  default QP values
const U8 def263INTER_QP = 16;

/*
 * Block description structure. Must be 16-byte aligned.
 * See e3mbad.inc for more detail on each structure entry.
 */
typedef struct {
    U32     BlkOffset;	// [0-3]  Offset to 8*8 target block from start of Y plane.
    union {
	   /*
		* Adress of reference block for P frame motion estimation.
		*/
        U8 	*PastRef;	// [4-7]  Address of 8*8 reference block.
	   /*
		* MVf and MVb vectors for B-frame motion estimation as defined in
		* H.263 spec. The reference block addresses are generated for
		* frame differencing. The numbers are biased by 60H.
		*/
        struct {
            U8 HMVf;
            U8 VMVf;
            U8 HMVb;
            U8 VMVb;
        }	CandidateMV;
    } B4_7;
    struct {		// Scratch variables used by ME.
        U8 HMVf;
        U8 VMVf;
        U8 HMVb;
        U8 VMVb;
    } BestMV;
	char PHMV;		// [12]   Horizontal motion vector for P block..
	char PVMV;		// [13]   Vertical motion vector for P block..
	char BHMV;		// [14]   Horizontal motion vector (delta?) for B block..
	char BVMV;		// [15]   Vertical motion vector (delta?) for B block..
} T_Blk;
const int sizeof_T_Blk = 16;

/*
 * T_MBlockActionStream - Structure to keep side information for a MB
 * used by encoder. This structure must be 16-byte aligned when allocated.
 * CodedBlocks must be DWORD aligned. The entire structure must be a multiple 
 * of 16 bytes, and must match the size of the structure in e3mbad.inc.
 */

#define SIZEOF_PSEUDOSTACKSPACE   (1024 * 64)

typedef struct {
	U8	BlockType;		// 0   -- See block types below.
        U8      MBEdgeType;     // 1   -- 1 off if left edge | 2 right | 4 top | 8 bottom.
	U8	Unassigned1;   	// 2   --
	U8	FirstMEState;	// 3   -- First State Num for Motion Estimation engine.
	U8	CodedBlocks;	// 4   -- [6] End-of-Stream indicator
						//        [0] indicates Y1 non-empty
						//        [1...5] indicates Y2, Y3, Y4, U, V nonempty.
						//        Other bits zero.
	U8	CodedBlocksB;	// 5   -- [0...5] like CodedBlocks, but for B frame.
						//        Set to 0 for non bi-di prediction.
	U8	Unassigned2[2]; // 6...7
	U32	SWD;			// 8...11  Sum of weighted diffs, from motion estimation.
	U32	SWDB;			// 12...15 Sum of weighted diffs, from B frame motion estimation.
	T_Blk	BlkY1;		// 16...31
	T_Blk	BlkY2;		// 32...47
	T_Blk	BlkY3;		// 48...63
	T_Blk	BlkY4;		// 64...79
	T_Blk	BlkU;		// 80...95
	T_Blk	BlkV;		// 96...111

	U8	COD;			// 112 -- Coded macroblock indication. When set to "0"
	  					//        indicates that macroblock is coded. If set to
						//        "1", it indicates that the macroblock is not coded
						//         and the rest of the macroblock layer is empty.
	U8	MBType;			// 113 -- Macro block type, {INTER, INTER+Q, INTER4V, INTRA, INTRA+Q}
	U8	CBPC;			// 114 -- Coded block pattern for chrominance.
	U8	MODB;			// 115 -- Macroblock mode for B-blocks.
	U8	CBPB;			// 116 -- Coded block pattern for B blocks.
	U8	CBPY;			// 117 -- Coded block pattern for luminance.
	U8	DQUANT;			// 118 -- Quantizer information. A two bit pattern to define
	   					//        change in QUANT.
	U8	InterCodeCnt;	// 119 -- Count number of times current MB has been intercoded.
	U8	Unassigned4[8];// 120...127 -- Pad out to a power of two.
} T_MBlockActionStream;
const int sizeof_T_MBlockActionStream = 128;

/*
 * Block Types
 */
const U8 INTERBLOCK = 0;
const U8 INTRABLOCK = 1;
const U8 INTERBIDI  = 2;
const U8 INTRABIDI  = 3;
const U8 INTER4MV	= 4;

const U8 IsINTRA    = 1;		// Mask to check for INTRA or ITNRABIDI.
const U8 IsBIDI     = 2; 	// Mask to check for INTRABIDI or INTERBIDI.

/*
 * MB Types
 */
const U8 INTER	= 0;
const U8 INTERQ	= 1;
const U8 INTER4V= 2;
const U8 INTRA	= 3;
const U8 INTRAQ	= 4;

/*
 * MB Edge Types
 */

const U8 MBEdgeTypeIsLeftEdge   = 0xE;
const U8 MBEdgeTypeIsRightEdge  = 0xD;
const U8 MBEdgeTypeIsTopEdge    = 0xB;
const U8 MBEdgeTypeIsBottomEdge = 0x7;

/*
 * First ME state for ME engine
 */
const U8 ForceIntra	= 0;
const U8 UpperLeft	= 1;
const U8 UpperEdge	= 2;
const U8 UpperRight	= 3;
const U8 LeftEdge	= 4;
const U8 CentralBlock = 5;
const U8 RightEdge	= 6;
const U8 LowerLeft	= 7;
const U8 LowerEdge	= 8;
const U8 LowerRight	= 9;
const U8 NoVertLeftEdge	= 10;
const U8 NoVertCentralBlock = 11;
const U8 NoVertRightEdge = 12;

/*
 * Coded block bit masks.
 */
const U8 Y1BLOCK = 0x01;
const U8 Y2BLOCK = 0x02;
const U8 Y3BLOCK = 0x04;
const U8 Y4BLOCK = 0x08;
const U8 UBLOCK  = 0x10;
const U8 VBLOCK  = 0x20;

const I32 GOBs_IN_CIF = 18;
const I32 MBs_PER_GOB_CIF = 22;

typedef struct {
    U8 StateNumInc_SelectCentralPt;
    U8 MVIncIdx_SelectCentralPt;
    U8 StateNumInc_SelectRef1;
    U8 MVIncIdx_SelectRef1;
    U8 StateNumInc_SelectRef2;
    U8 MVIncIdx_SelectRef2;
    U16 pad;
} T_SADState;


/* 
 * Structure to store bit counts.
 */
typedef struct {
	U32	PictureHeader;	// 0	All of picture header.
	U32	GOBHeader;		// 4	All of GOB Header.
	U32	MBHeader;		// 8	All of MB header.
	U32	DQUANT;			// 12	Bits spent on DQUANT.
	U32	MV;				// 16	Bits spent on MV's.
	U32	Coefs;			// 20	Total bits spent on coefs.
	U32	Coefs_Y;		// 24	Total bits spent on Y coefs.
	U32	IntraDC_Y;		// 28	Bits spent on IntraDC coefs for Y.
	U32	Coefs_C;		// 32	Total bits spent on Chroma Coefs
	U32	IntraDC_C;		// 36	Bits spent on IntraDC coefs for C.
	U32	CBPY;			// 40	Bits spent on CBPY
	U32	MCBPC;			// 44	Bits spent on MCBPC
	U32	Coded;			// 48	Number of coded blocks.
	U32	num_intra;		// 52	Number of intra coded blocks.
	U32	num_inter;		// 56	Number of Inter coded blocks.
	U32	num_inter4v;	// 60	Number of Inter4V coded blocks.
} T_BitCounts;

typedef struct {
    U32  MBStartBitOff;             //  Start of MB Data
    U8   CBPYBitOff;                //  from start of MB data
    U8   MVDBitOff;
    U8   BlkDataBitOff;             //  from start of MB data
} T_FutrPMBData;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	U32 uEncodeFrame;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	U32 uInputCC;
	U32 uMotionEstimation;
	U32 uFDCT;
	U32 uQRLE;
	U32 uDecodeFrame;
	U32 uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
} ENC_TIMING_INFO;
#define ENC_TIMING_INFO_FRAME_COUNT 105
#endif // } LOG_ENCODE_TIMINGS_ON

/*
 * T_H263EncoderCatalog - Catalog of information needed for an instance.
 * This structure must be multiple of 16.
 */
typedef struct {
    U8        *pU8_CurrFrm;             // 0
    U8        *pU8_CurrFrm_YPlane;	    // 4 Pointers to current frame buffers.
    U8        *pU8_CurrFrm_VPlane;	    // 8
    U8        *pU8_CurrFrm_UPlane;      // 12

    U8        *pU8_PrevFrm;             // 16
    U8        *pU8_PrevFrm_YPlane; 	    // 20 Pointers to previous frame buffers
    U8        *pU8_PrevFrm_VPlane;      // 24
    U8        *pU8_PrevFrm_UPlane;	    // 28

    U8        *pU8_FutrFrm;             // 32
    U8        *pU8_FutrFrm_YPlane; 	    // 36 Pointers to previous frame buffers
    U8        *pU8_FutrFrm_VPlane;      // 40
    U8        *pU8_FutrFrm_UPlane;	    // 44

    U8        *pU8_BidiFrm;             // 48
    U8        *pU8_BFrm_YPlane;		    // 52 Pointers to B frame buffers.
    U8        *pU8_BFrm_UPlane;		    // 56
    U8        *pU8_BFrm_VPlane;		    // 60

    T_MBlockActionStream *pU8_MBlockActionStream; // 64 Pointer to macro block action stream.

    I32       *pU8_DCTCoefBuf;		    // 68 Pointer to GOB DCT coefficient buffer.
    
    U8        *pU8_BitStream;		    // 72 Pointer to bitstream buffer.
    U8        *pU8_BitStrCopy;          // 76 Pointer to bitstream buffer
                                        //    for the PB-frame

    T_H263FrameHeaderStruct PictureHeader;// 80..127 (48 bytes)    // Picture layer header structure.

    UN        FrameHeight;	            // 128
    UN        FrameWidth;	            // 132
    FrameSize FrameSz;		            // 136 -- Define frame size: SQCIF, QCIF, CIF
    UN        NumMBRows;                // 140 -- Number of rows of MB's
    UN        NumMBPerRow;              // 144 -- Number of MB's in a row.
    UN        NumMBs;		            // 148 -- Total number of MBs.

    U8        *pU8_RGB24Image;	        // 152
    U8        *pU8_MBlockCodeBookStream;// 156
    U8        *pU8_BlockCodeBookStream; // 160
    U8        *pU8_BlockOfInterCoeffs;  // 164
    U8        *pU8_BlockOfIntraCoeffs;  // 168
    U32       AvgIntraSAD;              // 172 Average SAD for Intra macroblocks.
    LPDECINST pDecInstanceInfo;         // 176 Private decoder instance info.

    BRCStateStruct BRCState;            // 180 State variables for bitrate control (32 bytes)

    U8        u8EncodePBFrame;          // 212 Should encoder encode PB frames
    U8        u8SavedBFrame;            // 213 Do we have a B-Frame saved for
                                        //     encoding PB-frame
    U8        bMakeNextFrameKey;        // 214
    U8        bUseINISettings;			    // 215
    U32		  GOBHeaderPresent;	        // 216...220 Flag which GOB headers are present.
    U32       LastSWDBeforeForcedP;			// 220...224 The last SWD before B frames were turned off
    T_BitCounts Bits;					          // 224 .. 288
    U8        *pU8_PredictionScratchArea; // 288...292 Pointer to area for pre-computing predictions.
	U8        prevAP;                   // 292 AP mode for previous picture
	U8        prevUMV;                  // 293 UMV mode for previous picture (not used)
	U8        bPrevFrameIntra;          // 294 Flag whether previous frame was intra coded (used to set the ME states)
    U8        Unassigned0[1];           // 295...295  available 
    U32       uBitUsageProfile[19];     // 296...372 Table for storing bit usage profile
                                        // 19 is large enough for CIF
                                        // element 0...NumGOBs-1 stores cumulative bit usage
                                        // element NumGOBs stores the final frame size
    I8        *pI8_MBRVS_Luma;          // 372..376 Pointer to area for Luma Run Value Sign Triplets.
    I8        *pI8_MBRVS_Chroma;        // 376..380 Pointer to area for Chroma Run Value Sign Triplets.

    HANDLE    hBsInfoStream;            // 380..384 memory handle for blocks allocate for extended portion of bs
    void *    pBsInfoStream;            // 384..388 point to next BITSTREAM_INFO struct for next packet
    U32       uBase;                    // 388..392 byte offset of at the beginning of this packet from start
                                        // 392..396 of the whole bitstream;
    U32       uPacketSizeThreshold;     // 396..400 the packet size used by the codec
    void *    pBaseBsInfoStream;        // 400..404 start of bitstream extension
    U32       uNumOfPackets;            // 404..408
    U32       uNextIntraMB;             // 408..412 Used to implement rolling intra MBs
    U32       uNumberForcedIntraMBs;    // 412..416 Number of forced intras in each frame
    I8        *pI8_MBRVS_BLuma;         // 416..420 Pointer to area for Luma Run Value Sign Triplets for the B-frame (MMX)
    I8        *pI8_MBRVS_BChroma;       // 420..424 Pointer to area for Chroma Run Value Sign Triplets for the B-frame (MMX)

    U8        *pU8_Signature;           // 424
    U8        *pU8_Signature_YPlane;    // 428 Pointers to signature buffers

#ifdef USE_BILINEAR_MSH26X
	U32		  uActualFrameWidth;		// 460+40 Actual (non-padded) frame width
	U32		  uActualFrameHeight;		// 464+40 Actual (non-padded) frame height
	U32       ColorConvertor;           // 468+40 Input color convertor.
#endif

#ifdef H263P
	//NEWCHANGES
	U32       uBitOffset_currPacket;	// 432+40 bit offset for current packet
    U8        *pBitStream_currPacket;	// 436+40 pointer to current bitstream, last MB
    U8        *pBitStream_lastPacket;	// 440+40 pointer to bitstream at last packet
	U8        *pPseudoStackSpace;		// 444+40 pointer to buffer for motion estimation
	T_FutrPMBData *pFutrPMBData;		// 448+40 pointer to buffer previously on local stack in 
    I8        *pWeightForwMotion;		// 452+40 values based on TRb and TRd
    I8        *pWeightBackMotion;		// 456+40 values based on TRb and TRd
	U32		  uActualFrameWidth;		// 460+40 Actual (non-padded) frame width
	U32		  uActualFrameHeight;		// 464+40 Actual (non-padded) frame height
	U32       ColorConvertor;           // 468+40 Input color convertor.
	U8		  bH263Plus;				// 469+40 Flag for using H.263+
	U8        prevDF;                   // 470+40 Deblocking filter mode for previous picture
    
	// sizeof_T_H263FrameHeaderStruct = 88
    U8        Unassigned2[2];          // Pad size to 512 bytes.
#else
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO *pEncTimingInfo;	// 432
	U32 uStatFrameCount;				// 436
	int bTimingThisFrame;				// 440
	U32 uStartLow;						// 444
	U32 uStartHigh;						// 448
#ifdef USE_BILINEAR_MSH26X
    U8        Unassigned2[62];          // Pad size to 512 bytes.
#else
    U8        Unassigned2[64];          // Pad size to 512 bytes.
#endif
#else // }{ LOG_ENCODE_TIMINGS_ON
#ifdef USE_BILINEAR_MSH26X
    U8        Unassigned2[72];          // Pad size to 512 bytes.
#else
    U8        Unassigned2[84];          // Pad size to 512 bytes.
#endif
#endif // } LOG_ENCODE_TIMINGS_ON
#endif
    
} T_H263EncoderCatalog;
const int sizeof_T_H263EncoderCatalog = 512;

/*
 * T_H263EncoderInstanceMemory
 *     Memory layout for encoder instance. The memory is allocated 
 * dynamically and the beginning of this structure is aligned to a 
 * 32 byte boundary.
 * All arrays should be start on a DWORD boundary.
 * MBActionStream should start on a 16 byte boundary.
 */

// Define bit stream buffer size.
const unsigned int sizeof_bitstreambuf = 352*288*3/4;

// This structure is allocated on a N-byte boundary, where N is the size of
// a MacroBlock Action Descriptor, which must be a power of two.
typedef struct {
	T_H263EncoderCatalog EC;
        U8      UnAssigned0[2560]; // so that MMX ME (EMV case) can read outside
                                   // of legal address range of MBActionStream.
	T_MBlockActionStream MBActionStream[22*18+3];
	U8	UnAssigned1[16]; 
	U8	u8CurrentPlane [ (288+16+8+144)*384 + 8 ];
	U8	u8Pad1[ 72 ];
	U8	u8PreviousPlane[ (16+288+16+8+144+8)*384 + 64]; //  reconstructed past
    U8  u8FuturePlane  [ (16+288+16+8+144+8)*384 +  0]; //  reconstructed future
	U8	u8BPlane       [ (288+16+8+144)*384 + 8 ];      //  like current plane
	U8      u8Pad2[1928];
	U8      u8Signature[(16+288+16)*384 + 24];
	U8	u8Scratch1[4096];
	U8	u8BitStream [ sizeof_bitstreambuf ];
    U8  u8BitStrCopy[ sizeof_bitstreambuf ];
	/*
	 * Allocate space for DCT coefficients for an entire GOB.
	 * Each block of coefficients is stored in 32 DWORDS (2 coefs/DWORD)
	 * and there can be up to 6 blocks in a macroblock (P frame),
	 * and up to 22 macroblocks in a GOB (CIF size).
	 */
	U32         UnAssigned2[6];				// insert 6 DWORDS to put DCT on 32 byte boundary.
	I32	        piGOB_DCTCoefs[32*6*22];	// For best performance align to 32 byte boundary
   /*
    * Allocate scratch space for storage of prediction blocks.  We need
    * enough space for a whole GOB, luma only.  This is used for the
    * calculation of OBMC predictions only.
    */
	U8          u8PredictionScratchArea[16*384];
	// The following arrays are needed for MMX
	I8 i8MBRVS_Luma[65 * 3 * 22 * 4];
	I8 i8MBRVS_Chroma[65 * 3 * 22 * 2];
	DECINSTINFO	DecInstanceInfo;	        // Private decoder instance.

#if defined(H263P)
	U8 u8PseudoStackSpace[SIZEOF_PSEUDOSTACKSPACE];
    T_FutrPMBData FutrPMBData[GOBs_IN_CIF*MBs_PER_GOB_CIF + 1];
    I8  WeightForwMotion[128];  //  values based on TRb and TRd
    I8  WeightBackMotion[128];  //  values based on TRb and TRd
#endif

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
#endif // { LOG_ENCODE_TIMINGS_ON

}	T_H263EncoderInstanceMemory;

// Define offsets from Y to U planes, and U to V planes.
const int YU_OFFSET = (288+16+8)*384;
const int UV_OFFSET = 192;
const int CurPrev_OFFSET = 181328;	// Offset from current to previous frame buffer.

/****************************************************************
 * Function prototypes
 ****************************************************************/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
void colorCnvtFrame (
    U32                  ColorConvertor,
    LPCODINST            lpCompInst,
    ICCOMPRESS           *lpicComp,
    U8                   *YPlane,
    U8                   *UPlane,
    U8                   *VPlane
);
void colorCnvtInitialize(LPBITMAPINFOHEADER	lpbiInput, int InputColorConvertor);
#else
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
);
#endif

void PutBits(
	unsigned int fieldval, // Value of field to write to stream.
	unsigned int fieldlen, // Length of field to be written
	unsigned char **pbs, 				// Pointer to current byte in bitstream
	unsigned char *bitoffset	// bit offset in current byte of bitstream.
);

extern "C" void FORWARDDCT (T_MBlockActionStream * MBlockActionStream,
    U8 *  TargetFrameBaseAddr,
    U8 *  PreviousFrameBaseAddr,
    U8 *  FutureFrameBaseAddr,
    I32 * CoeffStream,
    int   IsBFrame,
    int   IsAdvancedPrediction,
    int   IsPOfPBPair,
    U8 *  ScratchBlocks,
    int   NumberOfMBlksInGOB
);

extern "C" void MOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FilteredFrameBaseAddr,
    int   DoRadius15Search,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    int   DoSpatialFiltering,
    int   ZeroVectorThreshold,
    int   NonZeroMVDifferential,
    int   BlockMVDifferential,
    int   EmptyThreshold,
    int   InterCodingThreshold,
    int   IntraCodingDifferential,
    int   SpatialFilteringThreshold,
    int   SpatialFilteringDifferential,
    U32 * IntraSWDTotal,
    U32 * IntraSWDBlocks,
    U32 * InterSWDTotal,
    U32 * InterSWDBlocks
);

#ifdef USE_MMX // { USE_MMX
extern "C" void MMxMESignaturePrep (U8 * PreviousFrameBaseAddr,
    U8  * SignatureBaseAddr,
    int FrameWidth,
    int FrameHeight
);

extern "C" void MMxEDTQ (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * BTargetFrameBaseAddr,
    U8  * SignatureBaseAddr,
    I8  * WeightForWardMotion,
    I8  * WeightBackwardMotion,
    int   FrameWidth,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    int   DoSpatialFiltering,
    int   DoAdvancedPrediction,
    int   DoBFrame,
#if defined(H263P)
	int   DoDeblockingFilter,				// Only H.263+ should use this
	int   DoImprovedPBFrames,				// Only H.263+ should use this
#endif
    int   DoLumaBlocksInThisPass,
    int   DoExtendedMotionVectors,
#if defined(H263P)
	int   GOBHeaderPresent,
#endif
    int   QuantizationLevel,
    int   BQuantizationLevel,
    int   BFrmZeroVectorThreshold,
    int   SpatialFiltThreshold,
    int   SpatialFiltDifferential,
    U32 * SWDTotal,
    U32 * BSWDTotal,
    I8  * CodeStreamCursor,
    I8  * CodeBStreamCursor
);
#endif // } USE_MMX

extern "C" void BFRAMEMOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FutureFrameBaseAddr,
    I8  * WeightForWardMotion,
    I8  * WeightBackwardMotion,
    U32   ZeroVectorThreshold,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    U32   NonZeroMVDifferential,
    U32   EmptyBlockThreshold,
    U32  * InterSWDTotal,
    U32  * InterSWDBlocks
);
    
extern "C" I8 * QUANTRLE(
    I32  *CoeffStr, 
    I8   *CodeStr, 
    I32   QP, 
    I32   BlockType
);

extern "C" void MBEncodeVLC(
    I8 **,
    I8 **,
    U32 , 
    U8 **, 
    U8 *, 
    I32,
    I32
);

/*
 * Routine to quantize, rle, vlc and write to bitstream
 * for an entire GOB.
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I32                  *DCTCoefs,
	U8                  **pBitStream,
	U8                   *pBitOffset,
   T_FutrPMBData        *FutrPMBData,
	U32                   GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                   StartingMB
);

void GOB_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I8                   *pMBRVS_Luma,
	I8                   *pMBRVS_Chroma,
	U8                  **pBitStream,
	U8                   *pBitOffset,
	T_FutrPMBData        *FutrPMBData,  //  Start of GOB
	U32                  GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                  StartingMB
);

void PB_GOB_Q_RLE_VLC_WriteBS(
    T_H263EncoderCatalog       * EC,
	I32                        * DCTCoefs,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
	const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
);

void PB_GOB_VLC_WriteBS(
	T_H263EncoderCatalog       * EC,
    I8                         * pMBRVS_Luma,
    I8                         * pMBRVS_Chroma,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
    const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
);

void CopyBits(
    U8       **pDestBS,
    U8        *pDestBSOffset,
    const U8  *pSrcBS,
    const U32  uSrcBitOffset,
    const U32  uBits
);
    
void InitVLC(void);


#ifdef DEBUG_ENC
void trace(char *str);
#endif

#ifdef DEBUG_DCT
void cnvt_fdct_output(unsigned short *DCTcoeff, int DCTarray[64], int BlockType);
#endif

struct T_MAXLEVEL_PTABLE {
	int	maxlevel;
	int * ptable;
};

//extern "C" { UN FAR ASM_CALLTYPE H263EOffset_DecoderInstInfo(); }

#endif		// #ifndef _H263E_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3mbenc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * e3enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance			
 * 	H263Compress
 *  H263TermEncoderInstance
 *  
 *
 *  
 *  $Author:   JMCVEIGH  $
 *  $Date:   05 Feb 1997 12:19:24  $
 *  $Archive:   S:\h26x\src\enc\e3mbenc.cpv  $
 *  $Header:   S:\h26x\src\enc\e3mbenc.cpv   1.54   05 Feb 1997 12:19:24   JMCVEIGH  $
 *  $Log:   S:\h26x\src\enc\e3mbenc.cpv  $
// 
//    Rev 1.54   05 Feb 1997 12:19:24   JMCVEIGH
// Support for separate improved PB-frame flag.
// 
//    Rev 1.53   19 Dec 1996 16:02:04   JMCVEIGH
// 
// And'ed CodedBlocksB with 0x3f to surpress high bit that indicates
// if only forward prediction is to be used in improved PB-frame mode.
// This is done in the VLC generation of CBPB and the block coeffs.
// 
//    Rev 1.52   16 Dec 1996 17:50:38   JMCVEIGH
// Encoding of MODB for improved PB-frame mode.
// 
//    Rev 1.51   05 Dec 1996 17:02:32   GMLIM
// 
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Calls to update bitstream info buffer were modified.
// 
//    Rev 1.50   06 Nov 1996 16:30:32   gmlim
// Removed H263ModeC.
// 
//    Rev 1.49   05 Nov 1996 13:33:48   GMLIM
// Added mode c support for mmx case.
// 
//    Rev 1.48   03 Nov 1996 18:47:02   gmlim
// Modified to generate 
// rtp bs ext. for mode c.
// 
//    Rev 1.47   28 Oct 1996 12:03:16   KLILLEVO
// fixed an EMV bug in the writing of motion vectors for the PB-frame
// 
//    Rev 1.46   24 Oct 1996 16:27:40   KLILLEVO
// 
// changed from DBOUT to DbgLog
// 
//    Rev 1.45   22 Oct 1996 17:09:04   KLILLEVO
// reversed the condition on whether or not to skip a macroblock.
// Fall-through is now coded.
// Set the pCurMB->COD member properly and use that in the coded/
// not-coded test in the PB-frame encoding instead of repeating
// the same test as in the P-frame case.
// 
//    Rev 1.44   14 Oct 1996 11:58:42   KLILLEVO
// EMV bug fixed
// 
//    Rev 1.43   04 Oct 1996 08:43:16   KLILLEVO
// initial support for extended motion vectors
// 
//    Rev 1.42   13 Sep 1996 12:48:04   KLILLEVO
// cleaned up intra update code to make it more understandable
// 
//    Rev 1.41   10 Sep 1996 17:51:42   KLILLEVO
// moved reset of InterCodeCnt to e3enc.cpp CalcGobChroma..._InterCodeCnt
// 
//    Rev 1.40   09 Sep 1996 17:05:50   KLILLEVO
// changed small type in intercodecnt increment
// 
//    Rev 1.39   06 Sep 1996 16:12:24   KLILLEVO
// fixed the logical problem that the inter code count was always
// incremented no matter whether coefficients were transmitted or not
// 
//    Rev 1.38   03 May 1996 10:53:56   KLILLEVO
// 
// cleaned up and fixed indentation in two routines which might
// need to be rewritten for MMX PB-frames
// 
//    Rev 1.37   28 Apr 1996 20:19:30   BECHOLS
// 
// Merged RTP code into Main Base.
// 
//    Rev 1.36   15 Mar 1996 15:58:56   BECHOLS
// 
// added support for monolithic MMx code with separate passes over
// luma and chroma.
// 
//    Rev 1.35   22 Feb 1996 18:52:44   BECHOLS
// 
// Added boolean to switch between MMX and P5 quantization function.
// 
//    Rev 1.34   26 Jan 1996 16:25:42   TRGARDOS
// Added conditional compilation code to count bits.
// 
//    Rev 1.33   12 Jan 1996 16:34:30   BNICKERS
// 
// Fix numerous macroblock layer bugs w.r.t. PB encoding.
// 
//    Rev 1.32   22 Dec 1995 11:12:46   TRGARDOS
// Fixed bug in MV prediction calculation for blocks 2-4 of
// AP. Was not zeroing outside motion vectors when their
// block was INTRA coded.
// 
//    Rev 1.31   18 Dec 1995 12:40:18   RMCKENZX
// added copyright notice
// 
//    Rev 1.30   13 Dec 1995 22:00:58   TRGARDOS
// Changed MV predictor to not use ME state variable.
// 
//    Rev 1.29   13 Dec 1995 12:18:38   RMCKENZX
// Restored version 1.27
// 
//    Rev 1.27   11 Dec 1995 10:00:30   TRGARDOS
// Fixed debug messages for motion vectors.
// 
//    Rev 1.26   06 Dec 1995 12:06:26   TRGARDOS
// Finished 4MV support in MV delta and VLC/bit stream writing.
// 
//    Rev 1.25   05 Dec 1995 10:20:30   TRGARDOS
// Fixed MV predictors in GOBs with headers.
// 
//    Rev 1.24   09 Nov 1995 14:11:24   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.23   19 Oct 1995 11:35:14   BNICKERS
// Made some changes to MacroBlockActionDescriptor structure to support B-Fram
// Motion Estimation and Frame Differencing.  Added some arguments to ME and F
// 
//    Rev 1.22   12 Oct 1995 17:39:34   TRGARDOS
// Fixed bug in MV prediction.
// 
//    Rev 1.21   03 Oct 1995 18:34:26   BECHOLS
// Changed the table sizes to reduce the memory requirements for the
// data to about half.  This also required a change to the initialization
// routine that sets up TCOEF_ and TCOEF_LAST_ tables.
// 
//    Rev 1.20   03 Oct 1995 09:21:34   TRGARDOS
// Fixed bug VLC encoding regarding MV prediction.
// 
//    Rev 1.19   29 Sep 1995 17:14:06   TRGARDOS
// Fixed offset value for cur to prev frame
// 
//    Rev 1.18   27 Sep 1995 19:10:02   TRGARDOS
// 
// Fixed bug in writing MB headers.
// 
//    Rev 1.17   27 Sep 1995 11:26:30   TRGARDOS
// Integrated motion estimation.
// 
//    Rev 1.16   18 Sep 1995 17:08:54   TRGARDOS
// Debugged delta frames.
// 
//    Rev 1.15   15 Sep 1995 16:37:32   TRGARDOS
// 
// 
//    Rev 1.14   13 Sep 1995 10:26:44   AGUPTA2
// Added blockType flag to QUANTRLE and changed the name to all upper-case.
// 
//    Rev 1.13   11 Sep 1995 14:10:42   BECHOLS
// 
// Changed this module to call the VLC routine in E35VLC.ASM.  I also
// renamed a couple of tables for clarity, and moved tables that I needed
// to the ASM module.
// 
//    Rev 1.12   08 Sep 1995 17:39:30   TRGARDOS
// Added more decoder code to encoder.
// 
//    Rev 1.11   07 Sep 1995 17:46:30   TRGARDOS
// Started adding delta frame support.
// 
//    Rev 1.10   05 Sep 1995 15:50:20   TRGARDOS
// 
//    Rev 1.9   05 Sep 1995 11:36:26   TRGARDOS
// 
//    Rev 1.8   01 Sep 1995 17:51:10   TRGARDOS
// Added DCT print routine.
// 
//    Rev 1.7   01 Sep 1995 10:13:32   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.6   31 Aug 1995 11:00:44   TRGARDOS
// Cut out MB VLC code.
// 
//    Rev 1.5   30 Aug 1995 12:42:22   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.4   29 Aug 1995 17:19:16   TRGARDOS
// 
// 
//    Rev 1.3   25 Aug 1995 10:36:20   TRGARDOS
// 
// Fixed bugs in integration.
// 
//    Rev 1.2   22 Aug 1995 17:20:14   TRGARDOS
// Finished integrating asm quant & rle.
// 
//    Rev 1.1   22 Aug 1995 10:26:32   TRGARDOS
// Removed compile errors for adding quantization asm code.
// 
//    Rev 1.0   21 Aug 1995 16:30:04   TRGARDOS
// Initial revision.
// 
// Add quantization hooks and call RTP MB packetization only if 
// the bRTPHeader boolean is true
// 
*/

#include "precomp.h"

/*
 * VLC table for MCBPC for INTRA pictures.
 * Table is stored as {number of bits, code}.
 * The index to the table is built as:
 * 	bit 2 = 1 if DQUANT is present, 0 else.
 * 	bit 1 = 1 if V block is coded, 0 if not coded
 * 	bit 0 = 1 if U block is coded, 0 if not coded. 
 */
//  TODO : why int, why not const
int VLC_MCBPC_INTRA[9][2] =
	{ { 1, 1},	// 0
	  { 3, 2},	// 1
	  { 3, 1},	// 2
	  { 3, 3},	// 3
	  { 4, 1},	// 4
	  { 6, 2},	// 5
	  { 6, 1},	// 6
	  { 6, 3},	// 7
	  { 9, 1} };// 8  stuffing

/*
 * VLC table for MCBPC for INTER pictures.
 * Table is stored as {number of bits, code}.
 * The index to the table is built as:
 * bits 3,2 = MB type <0,1,2,3>
 * bit 1 = 1 if V block is coded, 0 if not coded.
 * bit 0 = 1 if U block is coded, 0 if not coded.
 * 
 * For INTER pictures, MB types are defined as:
 * 0: INTER
 * 1: INTER+Q
 * 2: INTER4V
 * 3: INTRA
 * 4: INTRA+Q
 */
//  TODO : why int, why not const
const int VLC_MCBPC_INTER[20][2] =
	{ { 1, 1},	// 0
	  { 4, 2},	// 1
	  { 4, 3},	// 2
	  { 6, 5},	// 3
	  { 3, 3},	// 4
	  { 7, 6},	// 5
	  { 7, 7},	// 6
	  { 9, 5},	// 7
	  { 3, 2},	// 8
	  { 7, 4},	// 9
	  { 7, 5},	// 10
	  { 8, 5},	// 11
	  { 5, 3},	// 12
	  { 8, 3},	// 13
	  { 8, 4},	// 14
	  { 7, 3},	// 15
	  { 6, 4},	// 16
	  { 9, 3}, 	// 17
	  { 9, 4},	// 18
	  { 9, 2} };// 19

/*
 * VLC's for motion vector delta's
 */
//  TODO : why int, why not const
int vlc_mvd[] = {
     // Index: Vector Differences
    13,5,	//  0: -16	16
    13,7,
    12,5,
    12,7,
    12,9,
    12,11,
    12,13,
    12,15,
    11,9,
    11,11,
    11,13,
    11,15,
    11,17,
    11,19,
    11,21,
    11,23,
    11,25,
    11,27,
    11,29,
    11,31,
    11,33,
    11,35,
    10,19,
    10,21,
    10,23,
    8,7,
    8,9,
    8,11,
    7,7,
    5,3,
    4,3,
    3,3,
    1,1,	// 32: 0
    3,2,
    4,2,
    5,2,
    7,6,
    8,10,
    8,8,
    8,6,
    10,22,
    10,20,
    10,18,
    11,34,
    11,32,
    11,30,
    11,28,
    11,26,
    11,24,
    11,22,
    11,20,
    11,18,
    11,16,
    11,14,
    11,12,
    11,10,
    11,8,
    12,14,
    12,12,
    12,10,
    12,8,
    12,6,
    12,4,
    13,6,
};


/*
 * VLC table for CBPY
 * Table is stores as {number of bits, code}
 * Index into the table for INTRA macroblocks is the
 * coded block pattern for the blocks in the order
 * bit 3 = block 4
 * bit 2 = block 3
 * bit 1 = block 2
 * bit 0 = block 1
 *
 * For INTER macroblocks, a CBP is built as above and
 * then is subtracted from 15 to get the index into the 
 * array: index = 15 - interCBP.
 */
//  TODO : why int, why not const
int VLC_CBPY[16][2] = 
	{ { 4, 3},	// 0
	  { 5, 2},	// 1
	  { 5, 3}, 	// 2
	  { 4, 4},	// 3
	  { 5, 4}, 	// 4
	  { 4, 5}, 	// 5
	  { 6, 2},	// 6
	  { 4, 6}, 	// 7
	  { 5, 5}, 	// 8
	  { 6, 3}, 	// 9
	  { 4, 7}, 	// 10
	  { 4, 8},	// 11
	  { 4, 9}, 	// 12
	  { 4, 10}, // 13
	  { 4, 11}, // 14
	  { 2, 3}  // 15
	};

/*
 * TODO : VLC tables for MODB and CBPB
 */
const U8 VLC_MODB[4][2] = 
{ 
    {1, 0},  //  0
    {1, 0},  //  should not happen
    {2, 2},  //  2
    {2, 3}   //  3
};

#ifdef H263P
/*
 * VLC table for MODB when improved PB-frame mode selected
 */
const U8 VLC_IMPROVED_PB_MODB[4][2] = 
{
	{1, 0},		// Bidirectional prediction with all empty blocks		(CBPB=0, MVDB=0)
	{2, 2},		// Forward prediction with all empty blocks				(CBPB=0, MVDB=1)
	{3, 6},		// Forward prediction with some non-empty blocks		(CBPB=1, MVDB=1)
	{3, 7}		// Bidirectional prediction with some non-empty blocks	(CBPB=1, MVDB=0)
};
#endif

/*
 * TODO : VLC tables for CBPB; indexed using CodedBlocksB
 *        
 */
const U8 VLC_CBPB[64] = 
{
    0,   //  000000
    32,  //  000001
    16,  //  000010
    48,  //  000011
    8,   //  000100
    40,  //  000101
    24,  //  000110
    56,  //  000111
    4,   //  001000
    36,  //  001001
    20,  //  001010
    52,  //  001011
    12,  //  001100
    44,  //  001101
    28,  //  001110
    60,  //  001111
    2,   //  010000
    34,  //  010001
    18,  //  010010
    50,  //  010011
    10,  //  010100
    42,  //  010101
    26,  //  010110
    58,  //  010111
    6,   //  011000
    38,  //  011001
    22,  //  011010
    54,  //  011011
    14,  //  011100
    46,  //  011101
    30,  //  011110
    62,  //  011111
    1,   //  100000
    33,  //  100001
    17,  //  100010
    49,  //  100011
    9,   //  100100
    41,  //  100101
    25,  //  100110
    57,  //  100111
    5,   //  101000
    37,  //  101001
    21,  //  101010
    53,  //  101011
    13,  //  101100
    45,  //  101101
    29,  //  101110
    61,  //  101111
    3,   //  110000
    35,  //  110001
    19,  //  110010
    51,  //  110011
    11,  //  110100
    43,  //  110101
    27,  //  110110
    59,  //  110111
    7,   //  111000
    39,  //  111001
    23,  //  111010
    55,  //  111011
    15,  //  111100
    47,  //  111101
    31,  //  111110
    63   //  111111
};

/*
 * VLC table for TCOEFs
 * Table entries are size, code.
 * Stored as (size, value)
 * BSE -- The "+ 1" and "<< 1" makes room for the sign bit.  This permits
 *   us to do a single write to the stream, versus two writes.
 */
//  TODO : why int, why not const
int VLC_TCOEF[102*2] = {
	 2 + 1,  2 << 1,	/* 0, runs of 0  ***  table for nonlast coefficient */
	 4 + 1, 15 << 1,
	 6 + 1, 21 << 1,
	 7 + 1, 23 << 1,
	 8 + 1, 31 << 1,
	 9 + 1, 37 << 1,
	 9 + 1, 36 << 1,
	10 + 1, 33 << 1,
	10 + 1, 32 << 1,
	11 + 1,  7 << 1,
	11 + 1,  6 << 1,
	11 + 1, 32 << 1,
	 3 + 1,  6 << 1,	/* 24, runs of 1 */
	 6 + 1, 20 << 1,
	 8 + 1, 30 << 1,
	10 + 1, 15 << 1,
	11 + 1, 33 << 1,
	12 + 1, 80 << 1,
	 4 + 1, 14 << 1,	/* 36, runs of 2 */
	 8 + 1, 29 << 1,
	10 + 1, 14 << 1,
	12 + 1, 81 << 1,
	 5 + 1, 13 << 1,	/* 44, runs of 3 */
	 9 + 1, 35 << 1,
	10 + 1, 13 << 1,
	 5 + 1, 12 << 1,	/* 50, runs of 4 */
	 9 + 1, 34 << 1,
	12 + 1, 82 << 1,
	 5 + 1, 11 << 1,	/* 56, runs of 5 */
	10 + 1, 12 << 1,
	12 + 1, 83 << 1,
	 6 + 1, 19 << 1,	/* 62, runs of 6 */
	10 + 1, 11 << 1,
	12 + 1, 84 << 1,
	 6 + 1, 18 << 1,	/* 68, runs of 7 */
	10 + 1, 10 << 1,
	 6 + 1, 17 << 1,	/* 72, runs of 8 */
	10 + 1,  9 << 1,
	 6 + 1, 16 << 1,	/* 76, runs of 9 */
	10 + 1,  8 << 1,
	 7 + 1, 22 << 1,	/* 80, runs of 10 */
	12 + 1, 85 << 1, 
	 7 + 1, 21 << 1, /* 84, runs of 11 */
	 7 + 1, 20 << 1, /* 86, runs of 12 */
	 8 + 1, 28 << 1, /* 88, runs of 13 */
	 8 + 1, 27 << 1, /* 90, runs of 14 */
	 9 + 1, 33 << 1,
	 9 + 1, 32 << 1,
	 9 + 1, 31 << 1,
	 9 + 1, 30 << 1,
	 9 + 1, 29 << 1,
	 9 + 1, 28 << 1,
	 9 + 1, 27 << 1,
	 9 + 1, 26 << 1,
	11 + 1, 34 << 1,
	11 + 1, 35 << 1,
	12 + 1, 86 << 1,
	12 + 1, 87 << 1,
	 4 + 1,  7 << 1,  /* Table for last coeff */
	 9 + 1, 25 << 1,
	11 + 1,  5 << 1,
	 6 + 1, 15 << 1,
 	11 + 1,  4 << 1,
	 6 + 1, 14 << 1,
	 6 + 1, 13 << 1,
	 6 + 1, 12 << 1,
	 7 + 1, 19 << 1,
	 7 + 1, 18 << 1,
	 7 + 1, 17 << 1,
	 7 + 1, 16 << 1,
	 8 + 1, 26 << 1,
	 8 + 1, 25 << 1,
	 8 + 1, 24 << 1,
	 8 + 1, 23 << 1,
	 8 + 1, 22 << 1,
	 8 + 1, 21 << 1,
	 8 + 1, 20 << 1,
	 8 + 1, 19 << 1,
	 9 + 1, 24 << 1,
	 9 + 1, 23 << 1,
	 9 + 1, 22 << 1,
	 9 + 1, 21 << 1,
	 9 + 1, 20 << 1,
	 9 + 1, 19 << 1,
	 9 + 1, 18 << 1,
	 9 + 1, 17 << 1,
	10 + 1,  7 << 1,
	10 + 1,  6 << 1,
	10 + 1,  5 << 1,
	10 + 1,  4 << 1,
	11 + 1, 36 << 1,
	11 + 1, 37 << 1,
	11 + 1, 38 << 1,
	11 + 1, 39 << 1,
	12 + 1, 88 << 1,
	12 + 1, 89 << 1,
	12 + 1, 90 << 1,
	12 + 1, 91 << 1,
	12 + 1, 92 << 1,
	12 + 1, 93 << 1,
	12 + 1, 94 << 1,
	12 + 1, 95 << 1
  };

/*
 * This table lists the maximum level represented in the
 * VLC table for a given run. If the level exceeds the
 * max, then escape codes must be used to encode the
 * run & level.
 * The table entries are of the form {maxlevel, ptr to table for this run}.
 */

T_MAXLEVEL_PTABLE TCOEF_RUN_MAXLEVEL[65] = {
	{12, &VLC_TCOEF[0]},	// run of 0
	{ 6, &VLC_TCOEF[24]},	// run of 1
	{ 4, &VLC_TCOEF[36]}, 	// run of 2
	{ 3, &VLC_TCOEF[44]},	// run of 3
	{ 3, &VLC_TCOEF[50]},	// run of 4
	{ 3, &VLC_TCOEF[56]},	// run of 5
	{ 3, &VLC_TCOEF[62]},	// run of 6
	{ 2, &VLC_TCOEF[68]}, 	// run of 7
	{ 2, &VLC_TCOEF[72]},  	// run of 8
	{ 2, &VLC_TCOEF[76]},  	// run of 9
	{ 2, &VLC_TCOEF[80]},  	// run of 10
	{ 1, &VLC_TCOEF[84]},	// run of 11
	{ 1, &VLC_TCOEF[86]},	// run of 12
	{ 1, &VLC_TCOEF[88]},	// run of 13
	{ 1, &VLC_TCOEF[90]},	// run of 14
	{ 1, &VLC_TCOEF[92]},	// run of 15
	{ 1, &VLC_TCOEF[94]},	// run of 16
	{ 1, &VLC_TCOEF[96]},	// run of 17
	{ 1, &VLC_TCOEF[98]},	// run of 18
	{ 1, &VLC_TCOEF[100]},	// run of 19
	{ 1, &VLC_TCOEF[102]},	// run of 20
	{ 1, &VLC_TCOEF[104]},	// run of 21
	{ 1, &VLC_TCOEF[106]},	// run of 22
	{ 1, &VLC_TCOEF[108]},	// run of 23
	{ 1, &VLC_TCOEF[110]},	// run of 24
	{ 1, &VLC_TCOEF[112]},	// run of 25
	{ 1, &VLC_TCOEF[114]},	// run of 26
	{ 0, 0},	// run of 27 not in VLC table
	{ 0, 0},	// run of 28 not in VLC table
	{ 0, 0},	// run of 29 not in VLC table
	{ 0, 0},	// run of 30 not in VLC table
	{ 0, 0},	// run of 31 not in VLC table
	{ 0, 0},	// run of 32 not in VLC table
	{ 0, 0},	// run of 33 not in VLC table
	{ 0, 0},	// run of 34 not in VLC table
	{ 0, 0},	// run of 35 not in VLC table
	{ 0, 0},	// run of 36 not in VLC table
	{ 0, 0},	// run of 37 not in VLC table
	{ 0, 0},	// run of 38 not in VLC table
	{ 0, 0},	// run of 39 not in VLC table
	{ 0, 0},	// run of 40 not in VLC table
	{ 0, 0},	// run of 41 not in VLC table
	{ 0, 0},	// run of 42 not in VLC table
	{ 0, 0},	// run of 43 not in VLC table
	{ 0, 0},	// run of 44 not in VLC table
	{ 0, 0},	// run of 45 not in VLC table
	{ 0, 0},	// run of 46 not in VLC table
	{ 0, 0},	// run of 47 not in VLC table
	{ 0, 0},	// run of 48 not in VLC table
	{ 0, 0},	// run of 49 not in VLC table
	{ 0, 0},	// run of 50 not in VLC table
	{ 0, 0},	// run of 51 not in VLC table
	{ 0, 0},	// run of 52 not in VLC table
	{ 0, 0},	// run of 53 not in VLC table
	{ 0, 0},	// run of 54 not in VLC table
	{ 0, 0},	// run of 55 not in VLC table
	{ 0, 0},	// run of 56 not in VLC table
	{ 0, 0},	// run of 57 not in VLC table
	{ 0, 0},	// run of 58 not in VLC table
	{ 0, 0},	// run of 59 not in VLC table
	{ 0, 0},	// run of 60 not in VLC table
	{ 0, 0},	// run of 61 not in VLC table
	{ 0, 0},	// run of 62 not in VLC table
	{ 0, 0},	// run of 63 not in VLC table
	{ 0, 0}		// run of 64 not in VLC table
	 };

static char __fastcall median(char v1, char v2, char v3);

static I8 * MB_Quantize_RLE(
    I32 **DCTCoefs,
    I8   *MBRunValPairs,
	U8   *CodedBlocks,
	U8    BlockType,
	I32   QP
);

/*************************************************************
 *  Name:  writePB_MVD
 *  Description: Writes out the VLC for horizontal and vertical motion vector
 *    to the bit-stream addressed by (pPB_BitStream, pPB_BitOffset) in a 
 *    PB-frame (in a PB-frame, a predictor is NOT set to 0 for INTRABLOCKS).
 *    In its current incarnation, it cannot be used to write MV for non-PB 
 *    frames.
 *  Parameters:
 *    curMB            Write MV for the MB no. "curMB" in the frame.  MBs are 
 *                     numbererd from 0 in a frame.
 *    pCurMB           Pointer to the current MB action descriptor
 *    NumMBPerRow      No. of MBs in a row; e.g. 11 in QCIF.
 *    pPB_BitStream    Current byte being written
 *    pPB_BitOffset    Offset at which VLC code is written
 *  Side-effects:
 *    Modifies pPB_BitStream and pPB_BitOffset.
 *************************************************************/
static void writePB_MVD(
    const U32               curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32               NumMBPerRow,
    const U32               NumMBs,
    U8                   ** pPB_BitStream,
    U8                    * pPB_BitOffset,
	U32						GOBHeaderFlag,
	const T_H263EncoderCatalog *EC
);

/*************************************************************
 *  Name:  writeP_MVD
 *  Description: Writes out the VLC for horizontal and vertical motion vector
 *    to the bit-stream addressed by (pP_BitStream, pP_BitOffset) in a 
 *    P-frame.
 *  Parameters:
 *    curMB            Write MV for the MB no. "curMB" in the frame.  MBs are 
 *                     numbererd from 0 in a frame.
 *    pCurMB           Pointer to current MB action descriptor
 *    NumMBPerRow      No. of MBs in a row; e.g. 11 in QCIF.
 *    pP_BitStream     Current byte being written
 *    pP_BitOffset     Offset at which VLC code is written
 *	  GOBHeaderPresent IF true, then GOB header is present for this GOB.
 *  Side-effects:
 *    Modifies pP_BitStream and pP_BitOffset.
 *************************************************************/
static void writeP_MVD(
    const U32                     curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32                     NumMBPerRow,
	const U32					  NumMBs,
    U8                         ** pP_BitStream,
    U8                          * pP_BitOffset,
	U32							  GOBHeaderPresent,
	T_H263EncoderCatalog         *EC
);

/**********************************************************************
 *  Quantize and RLE each macroblock, then VLC and write to stream.
 *  This function is only used for P or I frames, not B.
 *
 *  Parameters:
 *    FutrPMBData   
 **********************************************************************/
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I32                  *DCTCoefs,
	U8                  **pBitStream,
	U8                   *pBitOffset,
    T_FutrPMBData        *FutrPMBData,  //  Start of GOB
	U32                   GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                   StartingMB
)
{
  	U32   MB, curMB, index;
  	I8    MBRunValSign[65*3*6], * EndAddress, *rvs;
  	U8	  bUseDQUANT = 0;	// Indicates if DQUANT is present.
	U8 	  MBType;
    U8   *pFrmStart = EC->pU8_BitStream;  //  TODO : should be a param.
	U32	  GOBHeaderMask, GOBHeaderFlag;

	#ifdef COUNT_BITS
	U32   savebyteptr, savebitptr;
	#endif

    register T_MBlockActionStream *pCurMB;

	FX_ENTRY("GOB_Q_RLE_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    // Loop through each macroblock of the GOB.
  	for(MB = 0, curMB = GOB*EC->NumMBPerRow, 
  			pCurMB = EC->pU8_MBlockActionStream + curMB; 
        	MB < EC->NumMBPerRow; 
        	MB++, curMB++, pCurMB++)
  	{
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: MB #%d: QP=%d\r\n", _fx_, MB, QP));

	   /*
	 	* Quantize and RLE each block in the macroblock,
	 	* skipping empty blocks as denoted by CodedBlocks.
	 	* If any more blocks are empty after quantization
	 	* then the appropriate CodedBlocks bit is cleared.
	 	*/
    	EndAddress = MB_Quantize_RLE(
    		&DCTCoefs,
    		(I8 *)MBRunValSign,
    		&(pCurMB->CodedBlocks),
    		pCurMB->BlockType,
			QP
    		);

		// default COD is coded (= 0). Will be set to 1 only if skipped
		pCurMB->COD = 0;

#ifdef ENCODE_STATS
		StatsUsedQuant(QP);
#endif /* ENCODE_STATS */

		if(EC->PictureHeader.PicCodType == INTRAPIC)
		{
			pCurMB->MBType = INTRA;
			MBType = INTRA;
		}
		else	// inter picture code type
		{
    		if(pCurMB->BlockType == INTERBLOCK)
			{
				pCurMB->MBType = INTER;
				MBType = INTER;
			}
			else if(pCurMB->BlockType == INTER4MV)
			{
				pCurMB->MBType = INTER4V;
				MBType = INTER4V;
			}
			else if(pCurMB->BlockType == INTRABLOCK)
			{
				pCurMB->MBType = INTRA;
				MBType = INTRA;
			}
			else
			{
				ERRORMESSAGE(("%s: Unexpected MacroBlock Type found\r\n", _fx_));
			}
		}
        
        //  Save starting bit offset of the macroblock data from start of 
        //  of the frame data.  The offset for the first macroblock is saved
        //  in e3enc.cpp before this routine is called.
        if (EC->u8EncodePBFrame == TRUE
            && MB != 0)
        {
            FutrPMBData[curMB].MBStartBitOff 
            = (U32) (((*pBitStream - pFrmStart)<<3) + *pBitOffset);
        }        

        /*
	 	 * Write macroblock header to bit stream.
	 	 */
    	if( (MBType == INTER) || (MBType == INTER4V) )
		{
	  		// Check if entire macroblock is empty, including zero MV's.
			// If there is only one MV for the block, all block MVs in the
			// structure are still set but are equal.
	  		if( ((pCurMB->CodedBlocks & 0x3f) != 0) 
                 || (pCurMB->BlkY1.PHMV != 0) 
                 || (pCurMB->BlkY1.PVMV != 0)
                 || (pCurMB->BlkY2.PHMV != 0) 
                 || (pCurMB->BlkY2.PVMV != 0)
                 || (pCurMB->BlkY3.PHMV != 0) 
                 || (pCurMB->BlkY3.PVMV != 0)
                 || (pCurMB->BlkY4.PHMV != 0) 
                 || (pCurMB->BlkY4.PVMV != 0)
                 )
	  		{
				PutBits(0, 1, pBitStream, pBitOffset);	// COD = 0, nonempty MB

#ifdef COUNT_BITS
    			if(MBType == INTER)
    				EC->Bits.num_inter++;
    			else if (MBType == INTER4V)
					EC->Bits.num_inter4v++;
				EC->Bits.MBHeader += 1;
				EC->Bits.Coded++;
#endif

				// Increment the InterCoded block count if the block
				// is intercoded (not B frame) and is not empty.
				if (((pCurMB->CodedBlocks & 0x3f) != 0) &&
					((pCurMB->BlockType == INTERBLOCK) || (pCurMB->BlockType == INTER4MV)))
				{
					// Macroblock is coded. Need to increment inter code count if
					// there are no coefficients: see section 4.4 of the H.263
					// recommendation
					pCurMB->InterCodeCnt++;
				}

				// 	pCurMB->InterCodeCnt is reset in calcGOBChromaVecs_InterCodeCnt

  	   		   /*******************************************
	    		* Write macroblock header to bit stream.
	    		*******************************************/	  
	    	    // Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
	    		index = (pCurMB->CodedBlocks >> 4) & 0x3;

				// Add the MB type to next two bits to the left.
				index |= (MBType << 2);

				// Write code to bitstream.
	    		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                        pBitStream, pBitOffset);

#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
				EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
#endif
                
                //  Save bit offset of CBPY data from start of macroblock data
				//  if PB frame is on since we will reuse this later.
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].CBPYBitOff
                    = (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                            - FutrPMBData[curMB].MBStartBitOff);
                }

	    		// Write CBPY to bitstream.
	    		index = pCurMB->CodedBlocks & 0xf;
				index = (~index) & 0xf;
	    		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], 
                        pBitStream, pBitOffset);

#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_CBPY[index][0];
				EC->Bits.CBPY += VLC_CBPY[index][0];
#endif

	    		//if( bUseDQUANT )
	    		//{
	      			// TODO: write DQUANT to bit stream here. We can only do
					// this if MBtype is not INTER4V since that type doesn't 
					// allow quantizer as well.
	    		//}	

                //  Save bit offset of CBPY data from start of macroblock data
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].MVDBitOff
                    = (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                            - FutrPMBData[curMB].MBStartBitOff);
                }

                // Write motion vectors to bit stream.
				if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
				{
					GOBHeaderFlag = TRUE;
				}
				else
				{
					GOBHeaderFlag = FALSE;
				}
                writeP_MVD(
                	curMB,		// Current MB number.
                	pCurMB,		// pointer to current MB action desc. struct.
                	EC->NumMBPerRow,
					EC->NumMBs,
                	pBitStream, 
                    pBitOffset,
                    GOBHeaderFlag,
					EC
                    );

                //  Save bit offset of block data from start of MB data
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].BlkDataBitOff
                    = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                             - FutrPMBData[curMB].MBStartBitOff);
                }

	   			/*
	    		 * Encode intra DC and all run/val pairs.
				 */
#ifdef COUNT_BITS
				savebyteptr = (U32) *pBitStream;
				savebitptr  = (U32) *pBitOffset;
#endif

            	rvs = MBRunValSign;
				MBEncodeVLC(&rvs,NULL, pCurMB->CodedBlocks, 
                            pBitStream, pBitOffset, 0, 0);

#ifdef COUNT_BITS
				EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
#endif
	  		}
	  		else	// Macroblock is empty.
	  		{
	    		PutBits(1, 1, pBitStream, pBitOffset);		// COD = 1, empty MB

				// Instead of repeating the above test in the PB-frame encoding
				// pCurMB->COD can now be tested instead.
				pCurMB->COD = 1;

                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].CBPYBitOff = 1;
                    FutrPMBData[curMB].MVDBitOff  = 1;
                    FutrPMBData[curMB].BlkDataBitOff = 1;
                }
				
				#ifdef COUNT_BITS
				EC->Bits.MBHeader += 1;
				#endif

	  		}	// end of else
		} // end of if macroblock
		else if( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTERPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

  	 		/*******************************************
	  		* Write macroblock header to bit stream.
	  		*******************************************/	  
    		PutBits(0, 1, pBitStream, pBitOffset);		// COD = 0, nonempty MB

 			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += 1;
			EC->Bits.Coded++;
			#endif

	  		// Write MCBPC to bitstream.
	  		index = (pCurMB->CodedBlocks >> 4) & 0x3;
	  		index |= (MBType << 2);
	  		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                    pBitStream, pBitOffset);

 			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
			#endif

            //  Save bit offset of CBPY data from start of macroblock data
            if (EC->u8EncodePBFrame == TRUE)
            {
                FutrPMBData[curMB].CBPYBitOff
                = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                         - FutrPMBData[curMB].MBStartBitOff);
            }

	  		// Write CBPY to bitstream.
	  		index = pCurMB->CodedBlocks & 0xf;
	  		//index = pMBActionStream[curMB].CBPY;
	  		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, 
                    pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

	  		//if( bUseDQUANT )
	  		//{
	    		// write DQUANT to bit stream here.
	  		//}

            //  Save bit offset of block data from start of macroblock data
            if (EC->u8EncodePBFrame == TRUE)
            {
                FutrPMBData[curMB].BlkDataBitOff = FutrPMBData[curMB].MVDBitOff
                = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                         - FutrPMBData[curMB].MBStartBitOff);
            }

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif
            
            //  Encode run/val pairs
         	rvs = MBRunValSign;
  	  		MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocks, pBitStream,
                        pBitOffset, 1, 0);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} // end of else
		else if ( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTRAPIC))
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

            //  An INTRA frame should not be the P-frame in a PB-frame
            ASSERT(EC->u8SavedBFrame == FALSE)
  	 		/*******************************************
	  		* Write macroblock header to bit stream.
	  		*******************************************/	  
	  		// Write MCBPC to bitstream.
	  		index = (pCurMB->CodedBlocks >> 4) & 0x3;
	  		//index = pMBActionStream[curMB].CBPC;
	  		//index |= bUseDQUANT << 2;
	  		PutBits(VLC_MCBPC_INTRA[index][1], VLC_MCBPC_INTRA[index][0], 
                    pBitStream, pBitOffset);

 			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += VLC_MCBPC_INTRA[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTRA[index][0];
			#endif

	  		// Write CBPY to bitstream.
	  		index = pCurMB->CodedBlocks & 0xf;
	  		//index = pMBActionStream[curMB].CBPY;
	  		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], 
                    pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

	  		//if( bUseDQUANT )
	  		//{
	    		// write DQUANT to bit stream here.
	  		//}

 			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

         rvs = MBRunValSign;
 	  		MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocks, 
                        pBitStream, pBitOffset, 1, 0);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} // end of else
		else
			ERRORMESSAGE(("%s: Unexpected case in writing MB header VLC\r\n", _fx_));

		// Calculate DQUANT based on bits used in previous MBs.
		// CalcDQUANT();

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pBitStream,
                                                    (U32) *pBitOffset);
  	} // for MB
} // end of GOB_Q_RLE_VLC_WriteBS()


void GOB_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I8              *pMBRVS_Luma,
	I8              *pMBRVS_Chroma,
	U8             **pBitStream,
	U8              *pBitOffset,
	T_FutrPMBData   *FutrPMBData,  //  Start of GOB
	U32              GOB,
	U32              QP,
	BOOL             bRTPHeader,
	U32              StartingMB)
{
	U32   MB, curMB, index;
	U8	  bUseDQUANT = 0;	// Indicates if DQUANT is present.
	U8 	  MBType;
	U8   *pFrmStart = EC->pU8_BitStream;  //  TODO : should be a param.
	U32	  GOBHeaderMask, GOBHeaderFlag;

	#ifdef COUNT_BITS
	U32   savebyteptr, savebitptr;
	#endif

	register T_MBlockActionStream *pCurMB;

	FX_ENTRY("GOB_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

	// Loop through each macroblock of the GOB.
	for(MB = 0, curMB = GOB*EC->NumMBPerRow, pCurMB = EC->pU8_MBlockActionStream + curMB; 
	    MB < EC->NumMBPerRow; MB++, curMB++, pCurMB++)
	{
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: MB #%d\r\n", _fx_, MB));

		// default COD is coded (= 0). Will be set to 1 only if skipped
		pCurMB->COD = 0;

		if(EC->PictureHeader.PicCodType == INTRAPIC) 
		{
			pCurMB->MBType = INTRA;
			MBType = INTRA;
		} 
		else 
		{	// inter picture code type
			if(pCurMB->BlockType == INTERBLOCK) 
			{
				pCurMB->MBType = INTER;
				MBType = INTER;
			} 
			else if(pCurMB->BlockType == INTER4MV) 
			{
				pCurMB->MBType = INTER4V;
				MBType = INTER4V;
			} 
			else if(pCurMB->BlockType == INTRABLOCK) 
			{
				pCurMB->MBType = INTRA;
				MBType = INTRA;
			} 
			else 
			{
				ERRORMESSAGE(("%s: Unexpected MacroBlock Type found\r\n", _fx_));
			}
		}
		//  Save starting bit offset of the macroblock data from start of 
		//  of the frame data.  The offset for the first macroblock is saved
		//  in e3enc.cpp before this routine is called.
		if(EC->u8EncodePBFrame == TRUE && MB != 0) 
		{
			FutrPMBData[curMB].MBStartBitOff 
			= (U32) (((*pBitStream - pFrmStart)<<3) + *pBitOffset);
		}        
		/*
		* Write macroblock header to bit stream.
		*/
		if((MBType == INTER) || (MBType == INTER4V)) 
		{
			// Check if entire macroblock is empty, including zero MV's.
			// If there is only one MV for the block, all block MVs in the
			// structure are still set but are equal.
			if(((pCurMB->CodedBlocks & 0x3f) != 0) 
			 || (pCurMB->BlkY1.PHMV != 0) 
			 || (pCurMB->BlkY1.PVMV != 0)
			 || (pCurMB->BlkY2.PHMV != 0) 
			 || (pCurMB->BlkY2.PVMV != 0)
			 || (pCurMB->BlkY3.PHMV != 0) 
			 || (pCurMB->BlkY3.PVMV != 0)
			 || (pCurMB->BlkY4.PHMV != 0) 
			 || (pCurMB->BlkY4.PVMV != 0)) 
			{
				PutBits(0, 1, pBitStream, pBitOffset);	// COD = 0, nonempty MB
				
				#ifdef COUNT_BITS
				if(MBType == INTER)
					EC->Bits.num_inter++;
				else if (MBType == INTER4V)
					EC->Bits.num_inter4v++;
				EC->Bits.MBHeader += 1;
				EC->Bits.Coded++;
				#endif

				// Increment the InterCoded block count if the block
				// is intercoded (not B frame) and is not empty.
				if (((pCurMB->CodedBlocks & 0x3f) != 0) &&
					((pCurMB->BlockType == INTERBLOCK) || (pCurMB->BlockType == INTER4MV)))
				{
					// Macroblock is coded. Need to increment inter code count if
					// there are no coefficients: see section 4.4 of the H.263
					// recommendation
					pCurMB->InterCodeCnt++;
				}

				// 	pCurMB->InterCodeCnt is reset in calcGOBChromaVecs_InterCodeCnt

				/*******************************************
				* Write macroblock header to bit stream.
				*******************************************/	  
				// Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
				index = (pCurMB->CodedBlocks >> 4) & 0x3;
				// Add the MB type to next two bits to the left.
				index |= (MBType << 2);
				// Write code to bitstream.
				PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
				pBitStream, pBitOffset);

				#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
				EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
				#endif

				//  Save bit offset of CBPY data from start of macroblock data
				//  if PB frame is on since we will reuse this later.
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].CBPYBitOff
					= (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				// Write CBPY to bitstream.
				index = pCurMB->CodedBlocks & 0xf;
				index = (~index) & 0xf;
				PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

				#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_CBPY[index][0];
				EC->Bits.CBPY += VLC_CBPY[index][0];
				#endif

				//if(bUseDQUANT) 
				//{
					// TODO: write DQUANT to bit stream here. We can only do
					// this if MBtype is not INTER4V since that type doesn't 
					// allow quantizer as well.
				//}
					
				//  Save bit offset of CBPY data from start of macroblock data
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].MVDBitOff
					= (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				// Write motion vectors to bit stream.
				if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
				{
					GOBHeaderFlag = TRUE;
				} 
				else 
				{
					GOBHeaderFlag = FALSE;
				}

				writeP_MVD(
					curMB,		// Current MB number.
					pCurMB,		// pointer to current MB action desc. struct.
					EC->NumMBPerRow,
					EC->NumMBs,
					pBitStream, 
					pBitOffset,
					GOBHeaderFlag,
					EC);

				//  Save bit offset of block data from start of MB data
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].BlkDataBitOff
					= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				/*
				* Encode intra DC and all run/val pairs.
				*/

				#ifdef COUNT_BITS
				savebyteptr = (U32) *pBitStream;
				savebitptr  = (U32) *pBitOffset;
				#endif

				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
				            pBitStream, pBitOffset, 0, 1);

				#ifdef COUNT_BITS
				EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
				#endif

			} 
			else 
			{	// Macroblock is empty.
				PutBits(1, 1, pBitStream, pBitOffset);		// COD = 1, empty MB

				// Instead of repeating the above test in the PB-frame encoding
				// pCurMB->COD can now be tested instead.
				pCurMB->COD = 1;

				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].CBPYBitOff = 1;
					FutrPMBData[curMB].MVDBitOff  = 1;
					FutrPMBData[curMB].BlkDataBitOff = 1;
				}
				#ifdef COUNT_BITS
				EC->Bits.MBHeader += 1;
				#endif
			}	// end of else
		} 
		else if( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTERPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

			/*******************************************
			* Write macroblock header to bit stream.
			*******************************************/	  
			PutBits(0, 1, pBitStream, pBitOffset);		// COD = 0, nonempty MB

			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += 1;
			EC->Bits.Coded++;
			#endif

			// Write MCBPC to bitstream.
			index = (pCurMB->CodedBlocks >> 4) & 0x3;
			index |= (MBType << 2);
			PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
			#endif

			//  Save bit offset of CBPY data from start of macroblock data
			if(EC->u8EncodePBFrame == TRUE) 
			{
				FutrPMBData[curMB].CBPYBitOff
				= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
				- FutrPMBData[curMB].MBStartBitOff);
			}
			// Write CBPY to bitstream.
			index = pCurMB->CodedBlocks & 0xf;
			//index = pMBActionStream[curMB].CBPY;
			PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

			//if( bUseDQUANT ) 
			//{
				// write DQUANT to bit stream here.
			//}

			//  Save bit offset of block data from start of macroblock data
			if(EC->u8EncodePBFrame == TRUE) 
			{
				FutrPMBData[curMB].BlkDataBitOff = FutrPMBData[curMB].MVDBitOff
				= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
				- FutrPMBData[curMB].MBStartBitOff);
			}

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

			//  Encode run/val pairs
			MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
			            pBitStream, pBitOffset, 1, 1);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} 
		else if ( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTRAPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

			//  An INTRA frame should not be the P-frame in a PB-frame
			ASSERT(EC->u8SavedBFrame == FALSE)

			/*******************************************
			* Write macroblock header to bit stream.
			*******************************************/	  
			// Write MCBPC to bitstream.
			index = (pCurMB->CodedBlocks >> 4) & 0x3;
			//index = pMBActionStream[curMB].CBPC;
			//index |= bUseDQUANT << 2;
			PutBits(VLC_MCBPC_INTRA[index][1], VLC_MCBPC_INTRA[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += VLC_MCBPC_INTRA[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTRA[index][0];
			#endif

			// Write CBPY to bitstream.
			index = pCurMB->CodedBlocks & 0xf;
			//index = pMBActionStream[curMB].CBPY;
			PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

			//if( bUseDQUANT ) 
			//{
				// write DQUANT to bit stream here.
			//}

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

			MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
			            pBitStream, pBitOffset, 1, 1);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		}
		else
			ERRORMESSAGE(("%s: Unexpected case in writing MB header VLC\r\n", _fx_));

		// Calculate DQUANT based on bits used in previous MBs.
		// CalcDQUANT();

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pBitStream,
                                                    (U32) *pBitOffset);
	} // for MB
} // end of GOB_VLC_WriteBS()

/*************************************************************
 *  Name: PB_GOB_Q_RLE_VLC_WriteBS 
 *  Description:  Write out GOB layer bits for GOB number "GOB".
 *  Parameters:
 *    EC                 Encoder catalog
 *    DCTCoefs           Pointer to DCT coefficients for the GOB
 *    pP_BitStreamStart  Pointer to start of bit stream for the future
 *                       P-frame.  Some data from future P frame is copied over
 *                       to PB-frame.
 *    pPB_BitStream      Current PB-frame byte pointer
 *    pPB_BitOffset      Bit offset in the current byte pointed by pPB_BitStream
 *    FutrPMBData        Bit stream info on future P-frame.  This info. is 
 *                       initialized in GOB_Q_RLE_VLC_WriteBS()
 *    GOB                GOBs are numbered from 0 in a frame.
 *    QP                 Quantization value for B-block coefficients.
 *  Side-effects:
 *    pPB_BitStream and pPB_BitOffset are modified as a result of writing bits 
 *    to the stream.
 *************************************************************/
void PB_GOB_Q_RLE_VLC_WriteBS(
    T_H263EncoderCatalog       * EC,
	I32                        * DCTCoefs,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
	const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
)
{
    UN   MB;
  	U32  curMB, index;
    U32  GOBHeaderMask, GOBHeaderFlag;
  	I8 	 MBRunValSign[65*3*6], *EndAddress, *rvs;
  	U8	 bUseDQUANT = 0;	// Indicates if DQUANT is present.
    U8   emitCBPB, emitMVDB;

    register T_MBlockActionStream *pCurMB;

	FX_ENTRY("PB_GOB_Q_RLE_VLC_WriteBS")

#ifdef H263P
	// The H.263+ options are currently only available in MMX enabled
	// encoders. If the improved PB-frame mode is desired in non-MMX
	// implementations, the H263P-defined code in PB_GOB_VLC_WriteBS
	// should be mimiced here.
#endif

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    for (MB = 0, curMB = GOB*EC->NumMBPerRow,
            pCurMB = EC->pU8_MBlockActionStream + curMB;
         MB < EC->NumMBPerRow;
         MB++, curMB++, pCurMB++)
    {
	   /*
	 	* Quantize and RLE each block in the macroblock,
	 	* skipping empty blocks as denoted by CodedBlocks.
	 	* If any more blocks are empty after quantization
	 	* then the appropriate CodedBlocks bit is cleared.
	 	*/
    	EndAddress = (I8 *)MB_Quantize_RLE(
    		&DCTCoefs,
    		(I8 *)MBRunValSign,
    		&(pCurMB->CodedBlocksB),
            INTERBLOCK,                           //  B coeffs are INTER-coded
			QP
    	);

#ifdef ENCODE_STATS
		StatsUsedQuant(QP);
#endif /* ENCODE_STATS */

        //  Write MBlock data
        // Check if entire macroblock is empty, including zero MV's.
        if( ((pCurMB->MBType == INTER)
             || (pCurMB->MBType == INTER4V))
            && (pCurMB->COD == 1) )
		{
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0))
            {
                //  P-mblock not coded, and neither is PB-mblock.
                //  COD = 1, empty MB.
                //  If it is the first MB in the GOb, then GOB header 
                //  is also copied
                CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                         FutrPMBData[curMB+1].MBStartBitOff                  // len
                         - FutrPMBData[curMB].MBStartBitOff);
            }
            else	// Macro block is not empty.
            {
                //  Copy COD and MCBPC
                //  If it is the first MB in the GOB, then GOB header 
                //  is also copied.
                if (FutrPMBData[curMB+1].MBStartBitOff - FutrPMBData[curMB].MBStartBitOff != 1)
                {
                    CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                             pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                             FutrPMBData[curMB+1].MBStartBitOff                  // len
                             - FutrPMBData[curMB].MBStartBitOff - 1);
				}
	    		PutBits(0, 1, pPB_BitStream, pPB_BitOffset);	// COD = 0, nonempty MB

  	   		   /*******************************************
	    		* Write macroblock header to bit stream.
	    		*******************************************/	  
	    	    // Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
	    		index = (pCurMB->CodedBlocks >> 4) & 0x3;

				// Add the MB type to next two bits to the left.
				index |= (pCurMB->MBType << 2);

				// Write code to bitstream.
	    		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                        pPB_BitStream, pPB_BitOffset);

                //  Write MODB
                if ((pCurMB->CodedBlocksB & 0x3f) == 0)
                {
                    emitCBPB = 0;
                }
                else
                {
                    emitCBPB = 1;
                }
            
                if (((pCurMB->BlkY1.BHMV != 0)
                     || (pCurMB->BlkY1.BVMV != 0))
                   || emitCBPB == 1)
                {
                    emitMVDB = 1;
                }
                else
                {
                    emitMVDB = 0;
                }

                index = (emitMVDB<<1) | emitCBPB;
                PutBits(VLC_MODB[index][1], VLC_MODB[index][0], 
        